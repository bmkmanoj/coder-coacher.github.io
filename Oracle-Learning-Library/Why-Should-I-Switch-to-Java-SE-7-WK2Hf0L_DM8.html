<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Why Should I Switch to Java SE 7? | Coder Coacher - Coaching Coders</title><meta content="Why Should I Switch to Java SE 7? - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Why Should I Switch to Java SE 7?</b></h2><h5 class="post__date">2013-01-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/WK2Hf0L_DM8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi good morning and welcome to Java one
great to see so many people here this is
too long can we get the mic up a bit
can everyone hear me now perfect so
great to see so many people here in the
morning and gets half of your jet like
so is easy to get out having girls talk
today together with Dave keen and the
keenest performance architect at Oracle
put in Java so both for the JDK
libraries and the JVM I'm product
manager for the JVM so working with
hotspot and Jay rocket we're going to
talk about why we think sort of it's
time to switch to Java SE 7 or JDK 7
we're gonna try to focus as much as
possible on why it's sort of interesting
or why it's beneficial to switch to it
even if you're not using and I'm Joe
Bessey features we're gonna talk a bit
about those but the focus will be more
on just general benefits even if your
code is Java Java c6 personal the
standard Oracle slide you'll see it a
few more times this week I'm gonna start
off with a bit of why we think Java SE 7
or JDK 7 is mature and why we recommend
it and Dave is gonna go into a bit more
into sort of the new features that it
has some of the performance benefits and
then we'll end with sort of backwards
compatibility which has always been uh
one of the key points in in Java and
then just a quick summary at the end and
we should have some time for questions
but before we end this session as well
so michurin recommended and Java 7 was
long overdue and a long full release and
it got picked up it's a fairly rapid
tempo once we released it in back in
July last year and even within six
months Sarah turnaround they did I
started with the developers and users of
stair technology and they found that 23%
were already up and running on JDK 7
which was quite impressive within six
months and just last month jelastic did
report on how their job which dedicates
were being used in their deployments in
their cloud service that they provide
and during the summer it had completely
shift it's now 80 percent almost 80
percent were up and running on JDK 7 so
it's a clear testament that people are
actually already on the NDK 7 and it's
been a rough edge year so as I said it's
been one year since GA during this year
I believed the JDK 7 has matured
immensely we have had seven updates
releases with bug fixes terrific says
new features being added in these update
releases and also a bunch of performance
enhancement and I can't sort of say
enough how happy we are with the
community picking out helping us out
testing it and also Java IVs doing
products on top of it and of course we
have all the oracle stock that's
basically all most of it is basically
running java and we've been testing and
trying it out there during this year and
releasing a java new jdk or Java update
for that matter is similar to what
happens when World of Warcraft for
example is released you have they have a
bunch of testers they probably load
20,000 200,000 hours of test time before
they release and then they release an
hour later they have two million hours
of game time and it's similar when we
release the jdk on a node to update
that's just after we have released we
have sort of more runtime than we can
ever sort of get in our labs so we
appreciate your help with with doing
this type of testing and picking up
early and that's why we have the early
access bill that was mentioned yesterday
in the keynotes so please pick those up
and and help us get more testing and
more stable products out there
and today so a year later we also see
that it's certified it's supported by
all the major IDs development tools
j-unit or code coverage applications the
java ee servers both GlassFish WebLogic
cables tomcat except our support JDK 7
so they're independent of watch that
you're using Java SE 7 is supported
today and from Oracle's perspective we'd
recommend JDK 7 for any new deployments
on the server side the independence act
there or especially if you're doing a
client application it is the default
Jerry on java.com so someone installs
Java today and that would have it before
they're gonna get JDK 7 we're about to
turn on auto update and that's going to
make make sure that we have Java 7 just
across all the installations on the
client side as well
and this was mentioned a bit yesterday
we support all the platforms we did
before we have the Windows Linux Solaris
on both Intel or sorry x86 and 64-bit
x86 SPARC and 64-bit SPARC and so during
the summer here we added mac OS x so if
you're doing development you can use JDK
7 both in your develop number
environment on your Mac and in
deployment and if you're doing hobby
projects on a Raspberry Pi or doing
embedded projects you have a full jdk
available for linux and arm and it
supports both arm v6 and rb7
and if you want to drill down into
exactly which OSS we certify on and you
can go to the oracle page on the Oracle
technology Network you have the link
here which basically if you search for
Java and certified platform so you can
find it and you'll see it in a slideshow
on
so support around Java six and seven
Jarvis is six we're gonna end the public
of publicly available to update releases
early next year and this is follows the
standard that has been set a long time
ago around how we handle the public
updates of Java we can't continue to
sort of have sort of spread our
resources so thing that we continue to
provide updates probably good for
everything so what we said what's what
set up was the rule that three years
minimum of three years after the GA
release minimum one year after the next
major release and six months after it
becomes the default cherry so in all
these three are sort of fulfilled now
which I see six the three years since it
was releases definitely overdue and with
the six months from being defaults we
made with 7u5 I believe it was we made
at the default JD Jerry on or Java calm
so looking at these numbers Java C 7 has
is gonna have public support at least
until 2007 2014 so if you're running a
open source stack for example and you
don't want to pay for support we're
gonna provide support if you're
interested we have support contracts for
that but if you want to run a completely
free stack you should start looking at
upgrading to JDK 7
and our talk here we're gonna focus
mainly on the OpenJDK or sorry the
Oracle JDK JDK 7 but a lot of things
that we're talking about here today are
valid for other JDK implementations or
Java SE 7 implementation out there we do
ourselves most of our work in open JDK
so a lot of the features that we put in
goes into opening the case if you're
running open JDK 7 you're gonna have a
lot of the benefits that we're talking
about if you're running an
implementation from one of the Java SE
licensees like as a PHP fujitsu they all
have JDK 7 products out there today
supported on there you UNIX system for
example for sa P and hp-ux iBM has their
own implementation with their j9 JVM
where they put in new features into
their JDK 7 they have the balance GC
they talked about last year as part of
their JDK 7 release and they also
optimized their class libraries so with
that I'm gonna leave over today we're
just gonna go into a mid or it's more
about the technical stuff but
all right hello everyone
I'm Dave Keenan and the performance
architect so we're gonna talk about new
features and performance now starting
with new features
okay so development aren't our focus
moving forward is clearly for
development to be in JDK 7 update
releases in JDK 8 so performance
features new features you know things
that would benefit you as within an
update are gonna go into seven so you're
not gonna see those in six six is not
completely frozen obviously we're gonna
we're gonna maintain security and bug
fixes and so forth but for those that we
were used to you know hey I get a new
update sometimes I get a new hotspot
version and it's gonna be you know a bit
faster that's that stops in 6 in fact
that should have stopped what what what
versions not stopping 25 yeah all of our
you know the last drop of performance
work went into the particular the 25 all
right thank you Stefan ok you actually
let me just go back just to drive this
this home a bit so I mean it you know
this is something that you get you have
to be you know considering moving
forward as well you know we have to be
able to focus our efforts and and that's
what we're doing okay so serviceability
features that are that have come from J
rocket that are now in hot spot due to
the J rocket hot spot can convergence
Java Mission Control has has come in in
a7 updated its its its core focuses
monitoring managing and profiling your
application for those who are GI rocket
users this is a big benefit and we're
really happy to see this over and in
hotspot so it's new tooling for those
that are used to using open JDK and
hotspot and I think you'll find it quite
useful so the same thing goes for flight
recorder a bit more detailed you know
than Mission Control Mission Control get
was to go over to you more of a
graphical display and flight recorder
gives us the and the nitty gritty
information that we're looking for from
a development point of view it's
partially implemented in JDK 6 7 so you
know it's really just the Oracle Fusion
Middleware probes at this point you know
we needed to start somewhere and want to
get a future out so that was in 7 update
4 and
the remainder is targeted and then in
the next year okay
moving forward to diagnose more
diagnostic commands specifically
targeting JDK introspection J command
another command that another tool that
came from J rocket you know it's it's
it's a framework for easy implementation
of additional tooling a quick
integration of your of your tooling to
to use introspection in that a JDK as it
stands now M you know it's got about 15
different commands that it supports that
come with it if you do Stu J command
you'll see a list of the the running
Java processes and if you do a J command
with the pin of a Java process with a
help you'll see all the tools available
I've got a list here of a few so you
know heap dumps finalization is being
run
you know the flags that you're running
with things like that it gets pretty
detailed information of a running
process would love with generally low
overhead now that being said a class
histogram is one of the things that that
it can give you and depending on the
size of your application obviously that
could be significant overhead if we do
what I've asked to keep it low so now
for those have used to how to use
hotspot and other open JDK tools in the
past it was always a few different
commands that to get this information
the information was there
this is consolidated under one command
you know it's a lot less jumping around
a lot less using you know various
different tools its consolidated here
okay again moving forward the next
feature I'll get to talk about is
garbage first garbage first is a new
garbage collection of framework that we
have first fully supported for
production use in seven update for our
it stands now in production what we
generally recommend for G one is large
heaps if you're looking to run more than
a six gig keep and you want stable you
know low latency is you know we say less
than a five second point five seconds
here but you know 200 milliseconds is a
default that G one is going to try to go
after it is a soft real-time collector
so it's gonna do the best it possibly
can to achieve its its its response time
goals but it's not
you know them you know throw your
application under the bus in order to
achieve it as a hard real-time collector
would do and we've got to had a lot of
success with it you know basically if
you've got you know an application that
has a live high live data count greater
than 50% you've got a variable object
allocation rate maybe it's a bit bursty
if you if you're suffering from long GCS
and compaction causes a compaction
clause meaning like a full GC where
you're running into a situation where
you have fragmentation on the heap you
know you're just not able to get free
enough free free space for your
allocations g1 shines with with high
levels of fragmentation mainly because
it's a parallel and concurrent
compacting collector where we don't you
know hotspot hasn't had such such a
thing in the past we did have a low cost
collector in CMS and very successful but
it does not get packed so if you get to
the point where your fragmentation is
too high you have a full GC which is
painful but that's why we have g1 so as
you see here in a typical Java EE
application you'll see that the parallel
GC is you know very long would you see
that's the big bar that's parallel old
GC and you see very long tires it pauses
the two little ones are the first of
which is g1 and the second one which is
CMS you can see that g1 is close to CMS
in this situation it's not beating CMS
but it is rather close so why is that
there's a lot of machinery that we
pulled around with g1 to actually to
achieve these low pause times mainly
barriers memory barriers and that's
something that the parallel collectors
and CMS simply don't have to deal with
so there's overhead as time goes on
we'll be optimizing that to to achieve
to surpass CMS performance but right now
in a second typical Java application
it's close to CMS so so what it does do
that CMS doesn't do is handle those high
levels of fragmentation very very well
you notice that the parallel collector
in this case does better with
fragmentation fragmentation than CMS and
the main reason there is that it's a
parallel old generation competi
collector so when it has to it one
actually gets the point where it has to
do a compaction and it has to handle
a ssin parallel GC is parallel in that
regard it's going to be fast CMS when
that happens it's a single-threaded
process it doesn't you know it's it's
single threaded in that regard and you
know that the full generation compaction
in CMS is going to be slow however look
at g1 it handles it gracefully so
regardless of the size of your heap we
now have a collector that we're pretty
confident saying that you know hey you
know we can we can achieve pretty low
pause times regardless of that the size
of the heap that you have you got this
is a level of fragmentation that you
have and we've got this outburst your
application is you know is it perfect no
I mean it's a new framework but it is
indeed fully supported in production so
you know we've got a lot of confidence
about how how well it's doing at this
point all right moving forward runtime
compiler optimizations tier compilation
tier compilation is something that we've
worked on for quite some time and here
in Java 7 it is still not on by default
but it's definitely worth looking at
here a couple oh and we've always had
several compilers in hotspot we've
always run up with a interpreter and if
you're running on a client you'd run the
c1 our client compiler if you're running
on a server you dependency to our server
compiler and what tier compilation does
is is is it's the it's the Union of them
it's it's we first run an interpreter an
interpreter provides information to
compile into an instrumented c1 we use
that instrument instrumentation in c1 to
optimize for c2 so it's it's a it's a
two-phase optimizing compiler the
information that we get to optimize in
c2 is better than it was in the past
because we're actually you know it's not
just interpreted information it's from a
compiler so we're running optimized code
and instrumenting that optimized code to
be able to make our optimization choices
for this for the highly optimized server
so why isn't on by default it was
actually very close and the main reason
is is that it's the heuristics that we
have for the code cache ended up being a
bit there was some corner cases that we
weren't very happy about with very very
large applications so as you got into a
lot of code and you're compiling a lot
of code the code cache where all the
optimizations got all your compiled code
go into was running out of space
and we need we need to have a better way
of managing that before we make it out
by default so if you decide to use tier
compilation I do is highly suggest that
you give it a try if it doesn't improve
your performance take a look at reserve
code cache and make sure that you have
enough code cache we did increase it by
default to 96 megabytes but it's you
know for a large applications it's not
enough to - you know and not not stable
well stability is not the problem is
just that we have those corner cases
that we we're not terribly happy with so
it will be anima by default in the
future all right Sokka direct protocol
and InfiniBand support so we have
transparent IP network support using
regular sockets in Java 7 now it is not
on by default you need to do to make a
you need to create an STP configuration
file and set the system property that
specifies the location that file but the
directions are you know right here it's
basically if you just do it SP you can
search for SDP on the docs for Oracle
calm and you'll you'll find it ok very
good
now performance benefits I I tried to
focus specifically on those performance
benefits that you would get just moving
to JDK 7 initially no not using any of
the features not not taking advantage
any of the new language features so what
happens if you just dropped JDK 7 in
your application as I went through this
there's just a couple features that I
couldn't ignore okay so I'm mentioning
them anyway so you'll see those all
right class library changes there was a
bit of a contention in dates and date is
pretty heavily used in Java EE
applications so the hash table that that
date which is synchronized is now a
concurrent hash map which alleviated the
synchronization bottlenecks we're
running into big decimal improvements
maybe mainly reducing a few allocations
that we could avoid and tightening up
the path length in big decimal again is
heavily used it used in business
applications we see a lot of its use
with an Oracle and other enterprise
applications and
if you see big dad's decimal on a
profile Java 7 certainly will improve it
does a lot of work went in to big
decimal copy elision and sun PPS j and i
called so we were doing extra copies as
we went to the security layer using some
PKS and we got rid of those copies if
you can remove a copy or an allocation
you improve performance simple as that
so that's what we did all right again
moving forward more crypto configuration
changes so in short this is a rather
simple change but our default crypto and
as we instantiate a crypto on solaris
and linux it was just not the quickest
path there was a better way to do it it
was just a configuration file change but
that has been on that's not by default
in in seven now userland crypto force
party for so it's new it's a spark tea
for where user crypto instructions so we
took advantage of those very large
improvements on that platform that went
to seven you to to the tune of you know
factors faster in our in our in our work
in our micro were close adler 30s you
crc32 we're leveraging those those
specific instruction sets on the
t-series as well and that also made it
into seven you to okay
string the by conversions
again this is an optimized string care
to by conversion to the 3x performance
improvement in micro benchmarks you know
these type of conversions are heavily
used in a lot of applications and we've
been doing point optimizations with
conversion for quite some time
our completely focused some of the work
we've done in optimizing compilers to to
optimize this these type of code paths
but the libraries themselves needed some
work in order for us to do that so a
combination of you know revamping the
the you know what we're doing in the
class libraries and making sure that
hotspot can optimize those new code
paths more effectively is what we did
here and there's there's more there
there there's a more opportunities as we
as we go on with string the concurrency
API so kay here's one of those that you
know it's a new feature there are
improvements in JDK 7 alone if you're
using GSR 166 that's the concurrency
api's JDK 7 will be faster a good amount
of work went in there but one of the
biggest features that came with 166 why
what went into JDK 7 is for joint and
the fork/join framework is a pretty
slick tool to say so if you're building
new concurrency a building new highly
concurrent applications for joint is
probably something you want to consider
as well I'll get a my graphic not work
there you go a little bit
all right more about fork/join
it'sit'sit's framework is its goal is to
take advantage of multiple multiple
processes or processes automatically and
it's designed for tasks that can be
broken down into little pieces figure
the Fibonacci sequence is a good example
of that and you know a typical algorithm
it is you know can I manage this task
I'm gonna you know if I can do that if
it I'll perform it you know Ellis if I
can break it up into many different you
know smaller similar tasks you know
let's execute those and then join the
results so the having that you know
capability on on multi-core systems
simply you know greatly simplifies your
you know use of those multiple cores and
their multiple threads that are
available right we've often to the
native compilers for JDK 7 you could
take JDK 7 if you if you're if you're
java application is bottlenecked on
garbage collection you could take JDK 7
drop it in and you'll see a 20 to 30
percent improvement in garbage
collection
it's just GCC and and the Oracle Studio
compilers are just that much faster on a
newer hardware and actually any hardware
we've tested quite a few the grave the
newer hardware obviously benefits more
we're generating better code for the new
hardware but in general GCC for 2 was a
big improvement across the board any
really really any native code
I say garbage collection because that's
that they're one of the biggest code
paths for biggest aspect of the JDK
that's native but we're seeing faster
compilation we're seeing faster network
it's it was it was a good change
NUMA support in JDK and Java 7 on Linux
requirements is you need two six one
nine kernel or later in G live C two six
one but if used used Numa on Solaris
which has been supported for quite some
time
significant performance improvement you
know the whole idea of what the Numa
allocator can do with this is the
parallel parallel GC and PL o GC only we
are working for it we're working to move
that to g1 in the future it's a not an
easy task so I'm not gonna I can't
we project that one but the idea with
Numa is to have your young generation
generation and all your allocation to be
local to your Numa nodes so you know
what was you know across remote node
allocations and accesses you know the
large majority of your memory axises and
Java are allocation in the young
generation and that's all local to your
new Minoans now we interleave the old
generation as well okay next is the
partial perm gen remover and removal
alright so we partially removed the perm
gen in JDK 7 and and what we did is we
moved the intern strings to the Java
heat from the permanent generation it is
this is our this was our first step in
that and along that path and we're in
the full we come to completion in JDK 8
one thing that notice you may need to
adjust your GC tuning because you know
all your string your intern strings are
now in the heap which they weren't
before right so you if you if you notice
that your applications have higher GC
times and you didn't change anything you
know take a look at increasing your heap
- - to handle the the string count as a
larger Keith may be needed in general
strength in turn strings don't take up a
lot of space so it's not a traumatic
amount of memory that work with that
we're taking up in the heap at this
point and we were taking up in the perm
gen anyway but if you around the cusp of
what your equipment capacity was for the
heap that you're running and you're
doing a lot of garbage collection yeah
this might be that a little bit of
change that could make it a bit worse
for you
ok more on in turn strings I have a talk
tomorrow they'll go into more detail
about this the JVM advanced tuning talk
but I'll just touch on at this point but
in turn strings are managed internally
in an internal hash table as are the
distinct class names that it better
loaded so they're two different hash
tables one is the string table one is
the system dictionary in the JVM both of
which as I said our hash tables they are
locked tables on access and they have a
default size of a thousand
9 so of those who know what a hash table
does if you have more than a thousand
nine entries you start to increase your
bucket chains right now the accesses are
locked so if you get you know as those
chains start to get longer and longer
the critical region of your lock gets
longer and longer and performance starts
to suffer so the quick fix to that is
increase your string table size so we
have a flag for that in JDK 7 actually
pretty quick fix you can you can use J
hats and other keep introspection tools
to find out how many in turn strings
you're actually running you know once
you have an idea of that how many in
turn strings you're using you can set
the string table size to that value
we've seen Java EE applications use up
to you know 60,000 70,000 in turn
strings so you can imagine that you know
that was a big performance improvement
because we were spending a lot of time
in a string string table but it's it's
it's an easy change and it's worth
looking into if you if you've not
recommend if you do application profile
using well I would suggest the studio
analyzer may because it can it can look
into the the JVM vtune can do the same
thing and if you see string table
accesses this is this is the problem you
want to just increase that size the
other one is is is that stink last names
we don't we have this protected by the
unlock experimental vm options it is it
is supported to use this but but it's
not you know we rather have this be more
it's a less common case and we want you
to be aware that you are you know kind
of twiddling with internals if you if
you if you change this it does not have
a negative performance penalty making it
too big just that the distinct last name
data structure is something that we want
to be able to tune automatically frankly
we don't want you to have to deal with
that I mean only have to deal with
string internet either but it's more
likely that you'll have to I can deal
with in turn strings so that's the
reason why we have a protected by an
experimental vm option but it is indeed
supported to use if you need it we would
like to know if you run into that though
I mean we have what Elias as an open JDK
so let us know
all right client library updates I give
this looking to feel you know
significant platform as far as changing
the look and feel for the doctor clad
the clients matching nervous does a very
good job of mapping matching the native
looking feels better than what we got in
the past know we have some shaped and
translucent windows for AP eyes now we
have improvements of J later
I'm sorry we including J layer which
came out of swing labs we have
optimizations to the 2d rendering
pipeline and X render support and Linux
so again just running JDK 7 on you know
your client application on Linux most
these are tart you know improve on the
next but you'll see that benefit JDBC
for one updates ok so there's some
additional well there's some slight
changes here to your connection of his
result set and statement general
performance improvements as a whole as
far as the implementation in the JDK and
additional classes are added to the to
the package as well
you know these these are the distinct
differences but again you would see that
the the packages of je-vc JDBC and JDK 7
in of itself is going to be faster an
XML API check updates as well we've
updated XP you know using stacks 1 2
significant performance improvements for
Jack's being updated Jack's be for
binding as well I was actually quite I
didn't anticipate performance
improvements of Jack be but Jack's
people we are actually saying you know
slight improvements in certain workloads
and jax-ws as well was updated again the
Jack's P if you're using that they're
that the performance improvements were
pretty significant ok asynchronous i/o
new feature in JDK 7 you need to code to
it obviously you're not gonna take
advantage of it but the reason why I'm
bringing it up here is is that it's been
a long time coming in synchronous i/o
and JDK image and Java so we had
blocking i/o you know pre JDK 1/4 we had
non-blocking i/o and memory mapped files
and one for moving forward but jk7 is
the first async async' i/o
implementation that we that we have and
it does take advantage of the operating
system io facilities where they are
available on say Linux or Solaris
Windows too bad I'm pretty sure that
Windows it's got special a special case
for that yes is you
okay so here's a just a general
performance objective spec JB 2005 this
is one of the simple workloads that we
had available to us to see to track JDK
development over time this is through
the course of the builds of JDK 7 so you
see a slow trend of improvement from the
tenth build all the way up to the one
hundred and thirty eighth built this is
on this out-of-the-box no tuning a 2.2 X
improvement
Jamie B 2005 is a relatively simple
workload but what it does stress well is
memory allocation memory locality and
code generation and you can see the last
big jump between 120 and 138 was a lot
of a lot of the code optimization work
escape analysis and authors day when in
Layton JT so alright here's another
slide it's not JDK 7 but I think you can
see that the trend here I kinda wanted
to show what you know what what our
performance is over time if you combine
what we've done in hardware and what
we've done and software as well then I
am looking at the wrong slide sorry
that's wise old this is the right slide
oops
right so this is combined hardware and
software over time we've had a
collaboration with Intel we have
collaborations with a lot of the
hardware vendors AMD obviously spark
and until one of the specific heart
specifically targeted be 2005 on their
hardware and a 14x combined improvement
hardware and software over the last well
five Intel CPU releases about four years
pretty massive improvement yeah a little
unfair mainly because we didn't work
with Intel before those four years there
was a there was a big backlog of work we
had to do but we got that done and we're
actually leading as I'll show you in on
the Intel platforms and a lot of
workloads the trend you see similar
trends with AMD actually quite similar
with AMD you see different spark I mean
we thought up an optimizing spark a lot
longer so it's you're not gonna see as
big of a yield in the last several
releases but it's uh you know Intel's
now x86 is appropriate platform for us
alright
competitive landscape
all right so right now GPB 2005 for Java
7 Java 7 is leading that workload it's
I've been in IBM's j9 implementation
that's doing it they are the four CPU
performance leader at the moment so you
know JDK IBM you know JDK 7
implementation has been pretty solid
I have we've seen it we've seen a lot of
use in the competitive benchmarking
world and and it's it's been pretty
successful Oracle hot spot is the
current performance leader with Jana
price both x86 and SPARC and IBM also
has the lead on the power performance
workload of ssj 2008
okay real-world performance right not a
lot of content but basically we've
tested a lot of applications many many
applications JDK 7 update 4 we wanted to
be able to say and recommend that you
know 90% of the applications that we
test run better around Java 7 that if
they went both Java 6 and J rocket and
it was a very it was actually quite a
quite a long project that we took this
on and in the end result after of course
fixing several issues is 97% of the
application that we tested it faster
than JT's Java 6 and 96% of are faster
than J rocket those three with few
percentages that are left we have bodies
filed and we'll be addressing them in
Java eight quarter case is truly not not
anything that's a showstopper by by any
means okay that brings us to backwards
compatibility and I think we're doing
pretty good on time and we'll switch
over to stuff on to talk about backwards
compatibility yes I mentioned earlier in
the talk we take backwards compatibility
quite seriously with Java we have a
defined three hours where we always make
sure we will try to stay as compatible
as possible we call it source
compatibility binary compatibility and
behavior compatibility and it's
basically we want to make sure all code
continues to compile with the new Java
version you can link basically you can
load your old jar files that you have
previously compiled and run them with
with your new Java 7 program and also if
you do execution or is when you execute
your application you want to the
behavior to be the same you want to get
the same result if you're running Java 7
as you were which are 6 so those are the
three RS we're looking at and we have a
full document which describes sort of
anything that we believe changes the
comparability most of these things are
sort of smaller things that we have
changed or added AAA
a method suited to an API for example so
all those changes all documented if you
go to this page you can actually see all
the difference that are between 6 &amp;amp; 7
that you could experience if you're
unlike about most things are very small
and we have basically no one running
into them but we want to document them
anyway I'm gonna go through a couple of
things that people actually have been
been seeing as the update it's a new
major release it contains a lot of new
features a lot of new libraries so while
it's not so if you do if when we do a
minor update 7 new update we basically
expect that to be a slot in replacement
you can take that and virtually so short
you want to do some certification or
sort of some testing but the idea is
that the command-line options are the
same
everything works saying the things that
are have changed it's bug fixes and we
strive very hard to make our bug fixes
our security fixes so as
backwards-compatible as possible so this
one they talked a bit about if you have
sort of really fine-tuned and balanced
your perm gen and heap you might want to
take an extra look at that if you're in
memory constrained environment since
we're moving from the permian it's gonna
be less usage share and more usage on
the heap and these are the tools of main
people's pitfalls that we have seen
people experience when they update to
JDK 7 and they have sort of the first
one is we are more stringent when doing
bytecode verification on Java SE 7
classes it's mainly an issue if you're
using of different compilers or if
you're using a bytecode modifier to for
example do code code coverage for
example that inserts new bytecode
so what we're verifying in this
particular case series stack maps which
basically describes sort of how many
things you have on the stack in a given
point in time and we're we want to make
sure that we actually so what the class
file described is actually sort of
correct with what the bytecode
execute some puts on a stack there's a
way to work around this it's not
recommended you can sort of this you
split fire fire and - - or disable split
fire fire that's gonna revert back to
sort of how we did verification in JDK 6
it's it's a short-term solution if you
have an issue what we're seeing that
code coverage tools third-party compile
lipsticks that I have all fixed their
issues so if you pick up JDK 7 now
unless you are sort of you can't update
some parts of your other parts of the
stack you shouldn't run into this issue
at all another part that's changed is
when you do reflection so if you do
reflection on the class you do get
methods if you read the the Java SE 7
API or the jeddak API Docs you'll see
quite clearly stated since one but one
one since reflection was added the order
of these methods will be sort of
unspecified however the Oracle JDK or
saanddk have had an order of them so
that the order was basically in the
order they were stated in the classifier
and with knowledge about this or without
them so thinking about it things started
depending on this there is no workaround
for this you have to sort of make code
changes if you run into this that that
you are depending on on the order of
methods are returned and the quick fix
will basically to sort of return the
methods and do some sorting on them on
your level but the JDK or JVM won't be
able to help you in that case and the
reason for this is basically we changed
how we're managing methods and rather
than punish everyone with the sort
method the when you need to sort them
please do so
so somewhere in the end so hopefully
we've been able to show of it that what
we believe is a mature proven release
it's heavily used in but by white people
out there already and you will be able
to continue to get free public updates
which are back c7 and as they talked
about air several new features and there
are plenty of performance improvements
in JDK 7 and it's also the from our
point of respecting to recommend the
release and it's a completely support
release and certified with a lot of
tools out there and just as a final
comment so if we focus more so if I
don't do anything what do I get
and I think that in by itself is quite
compelling but there are more to Java 7
there's a reason why we did a major
release we've put in a lot of new code
new libraries in there new features and
there are several sessions this year
talking about this there's one on the
four I've listed here and Joe Dawsey and
Anil and others would be probably
interesting to go to and we talked a bit
about g1 on Wednesday morning there's a
g1 talk also early in the morning at the
8:30 I believe that I could highly
recommend going to and also if you don't
want to go watch Pearl Jam and all the
other things that happening in the night
you can always log into parlays and
watch sessions from last year they are
up there still and there you have a lot
of talks about Java SE 7 as well and
that's what we had so we're open up for
questions if people have I don't know if
we're having my mic back there or if you
just have to speak loudly and I'll try
to repeat the question as much as
possible thank you
as so the question was what's the
difference between
OpenJDK and the Oracle JDK and we will
sort i will yesterday like 95% of the
code is basically the same i would say
it's probably more we will sort of do
some we have the JVM convergence project
as we mentioned briefly we have some
license features in J rocket like flight
recorder like Mission Control that we
will continue to have as license
features and that will only be part of
the Oracle JDK but g1 basically all of
like all the performance features that
we're doing are all part of open JDK so
so from from our perspective we we have
some features that we feel adds sort of
value externally and we like to compete
with others on those we have
yeah Java C and JDK 7 is a absolutely
sort of exactly the same I don't know if
yeah there's no difference there should
be no difference between those two right
and as Stefan said it's really the
additional tooling like Mission Control
as you referenced you know that's the
difference as far as run time there is
no difference I mean it's more or less I
mean it's just additional things that we
would be able to you know have add value
and yes if you look at open JDK you will
see sort of in real time as we do
development work of basically most of
the code in sort of the JDK
so we take or the the open JDK and then
we sort of on top of that we add sort of
flight recorder etc so might like most
of our work is straight and open JDK so
you can follow the mailing list and see
sort of as we add features as we do
fixes as for the difference between them
the Oracle JDK is the dedicated we
provide support or for that we certified
our platform so on and and what we're a
lot of the third-party vendors as well
so start to fight on yeah those are the
binaries that are certified and tested
we granted the differences are probably
pretty small but yeah that's you know
that's what we're testing
any other questions did
police report
we are testing some of those not all of
them a lot of the the sort of how does
certification generally works is like we
provide certification against the OS and
then the upper stack sort of needs to
certified on the jdk but we do a lot of
testing with sort of doctor sack to make
sure
stephannie we don't know of a tool
that's not supported virginity seven as
far as performance know i know that
there were sort of some of the code
coverage tool during back in autumn last
year as we released JDK 7 that run into
this code verify thing but since then
there have gone in fixes and now they
are fully functional is there a tool one
specifically that you're speaking over
why yeah I know for a fact that it's
fully supported yeah yes
we won't go we won't do a JDK 7 onto a
rocket we will continue to support the a
rocket for for sort of quite a bit of
time think it runs at least until 2017
so we will continue to provide support
bug fixes security fixes and all of
those benefits and but we want to end in
you sort of big feature work in J
rockets the new feature work that we're
doing we're taking over the the features
that we feel like we're gonna miss from
the a rocket or that we need from the a
rocket into the hot spot so JDK right
performance perspective if we're not if
hot spot is not able to meet your
expectations that you have in j-rok that
we consider that a bug and it will be
fixed if hot spot for some reason as I
said you know 96% of the applications
that we tested or faster using hot spot
if you find that your your expectations
aren't being met with hot spots and we
would consider that above and would fix
that you know we want you know hot spot
and the Oracle JDK to be to meet or
exceed your expectations that you have a
J bracket
yes in a timeframe we'll see if we get
everything into the DA about something
most sort of things our target afraid
yes
you
how much faster is Java 7 Java 6 on
benchmarks on the benchmarks the
competitive benchmarks that we've tested
is anywhere between 10 and 15% on a
general case some of the cases where new
features were benefiting from say
compressed oops or tier compilation or
new new performance you know advantages
that you have in seven it was upwards of
you know 25 30 % now j-roc and on the
other hand it's it's there's a broader
there's a broader range I mean there are
some applications Jay rocket was highly
tuned for middleware let's not get
ourselves right so there's situations
where we make more we have met that
performance there are other situations
where we exceeded so it's between you
know 0 to 20% would you
are you moving away
make it with
sorry repeat I missed the part in
question
yes so the difference between j-rock and
hot spots are sort of the Oracle the
j-rock JDK I should say in the the
Oracle JDK now was basically the JVM
there were two different JVM is
completely different codebase we shared
the class libraries so the difference
were in the VM itself and we had
different philosophies around so if the
j-rock it was didn't have an
interpretive we were always compiling or
something and compiling in hotspot it's
a different way of doing things in the
sense that we do first and
interpretation step and then you go into
compilation step and it has its benefits
of doing an interpretation
first we so I don't think we will go to
only compilation in hotspot I don't
think it sort of since we have a very
good interpreter it doesn't make sense
it it's really helpful when you have
that there are different methods that
sort of a lot of methods that you only
use once and it actually is faster to
interpret those and then sort of compile
the ones that are actually executed
multiple times but and as as the
interpreter has been improved the
benefit of just doing intuit compilation
thing instantly has sort of dropped and
to be fair we were actually thinking
about should we had an interpreting to J
Rockets last couple of years yeah I'm
sorry position and we didn't have to it
just as quickly ad with JDK 7 with a new
comp with with the updates that
compilers with GCC and in the studio
compilers you know I said that we sought
the improvement with G with with with GC
but we also sought with the interpreter
and and and when we did measurements in
carat compared against J rocket you know
hotspot was faster with startup
significantly faster with startup
however there were situations where that
J rocket shined better because it was
able to have full compilation or least
partial compilation before you actually
got the load from the system and we've
resolved those issues those those those
workloads that we saw differences so if
there are no differences anymore so and
if you have a workload that actually is
a bit beneficial of early compilation
using tiered compilation you can
actually play around with the settings a
bit and get pretty close so that you
basically do one interpretation step and
then go over to compile code for
sample so you can set the fresh soaps
pretty low when using the cleared
completion and through that basically
it's gonna look like you're doing
instant JIT compilation
yeah we've kicked around ahead of time
in hot spot for a long time and never
has it really been a benefit I mean we
just you know we've had prototypes and
we've looked at it and we haven't gotten
to the point where it actually beats the
interpreter so we're just not we're not
going down that path that change
actually just went in so I believe the
next early access bill of eight is gonna
have that feature in there and if you're
interested and want to try it out please
do so
what has changed so yeah yeah yeah I
appreciate you any testing of that one
and I today I mean we've we've done a
lot of work we were very happy we're
happy with where we're at but you know
it's a big change so yeah the that
change set took a while to take I'll
just virgin go that's three weeks just
emergent seriously excellent thank you
so much for coming oh one more question
yes
Hospital would definitely be optimized
for both that as as well as windows I
would characterize it more as we focus
Jared was more focused on server
workloads and and middleware workloads
whereas Hospital has and has had had
brought a range from from client and now
we're focusing on them sort of all the
way down to embed it all the way up to
the server they're so hot spot has been
more broader but Jarek it's sort of week
we knew that we were focusing on servers
we could cut corners like startup wasn't
interesting for us because we didn't
care about client for them yes well
hotspot is the preferred solution now
Oracle jedikiah's hotspot we do still
support J rockin and J Rockets still
being used by some of the applications
because you know it takes time to move
but to your point I think historically J
rocket probably you know definitely had
an advantage on x86 whereas a hot spot
always had advantage on SPARC simply
because of the roots with Sun that there
is no difference anymore
I don't think it is that the way you
have to the way you access methods are
the other get methods and you have an
iterator so it's similar to sort of
doing an iteration on the hashmap except
I there was a quality issue really sorry
but did you understand what Stefan
suggestion was as far as doing a sort or
dependents work right if you yeah
unfortunately
always better than inspired exhibition
I mean spots or
so is the question is a visit this is
more of a platform with a performance
comparison question okay yes yeah well
let me let me say this way the newer
versions of the SPARC microarchitecture
are significantly faster and they have a
lot of new features that we've taken
advantage of you know with the newer
versions starting with spark t4 you
would expect to see you know higher
levels optimization that being said you
know we we've you know spark I I think
the the workloads
it's very workload dependent I I think
with T 4 and T 4 is a general
performance improvement and we took
advantage of all those features that we
could but with that being said with Java
7 on any of the SPARC architecture
heavily threaded workloads are gonna do
very well but if we can talk
specifically about the situation you're
happening in we can you know it might
have something inside of it in a general
sense it should be built a spark and X a
set eddie's x86 are hardflip premiere
platforms are treated equally so so if
we're not seeing performance
improvements on spark as we should
expect to see on x86 that's a problem
for us with what that's not acceptable
agnostic of the platform changes yes
however this last year we saw major you
know releases from Intel and and and and
spark and with those of course every
time that happens competitive
differences you know shift and the last
major revisions from spark there was a
very significant shift in performance
you know I would say the red well as I
said at equal it's a we treat them
equally and we're close to behave
differently a dependent platform so we
could talk let me talk offline a little
bit and I can I can get you more
information
the next six months the sex
we're already doing yeah Anna and we're
basically already since JDK 7 was
released the the only things that gone
into 6 has been bug fixes security fixes
so no new features has gone into 6 after
February what's gonna happen is that
we're not gonna do public releases of
JDK 6 anymore so they will be available
sort of Lea support contracts at
February 2013 so five months ok and
again you know you know we would in a
perfect world we would continue to
support JDK 6 but we just we got to
focus our efforts and we want to make
make sure that we move the Clank which
forward and so that's why we're doing
this so it's similar to what the state
104 and 105 is in today those are only
available via support now security would
be we would issue a security fixes that
corrector only critical ones yeah if
there are like but stop you seen and yes
that's not gonna happen</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>