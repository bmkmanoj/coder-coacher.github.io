<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Technical Intro to Graal: A Multi-language VM Platform | Coder Coacher - Coaching Coders</title><meta content="Technical Intro to Graal: A Multi-language VM Platform - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Technical Intro to Graal: A Multi-language VM Platform</b></h2><h5 class="post__date">2017-07-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/8aku17r-oaU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm here today to talk to you about a
new open-source project that we've been
working on here at Oracle for several
years now it's actually a breakthrough
in virtualization we're taking
virtualization in the next level with a
project called growl VM so you know
we're living in an agile world today
where the pace of everything is moving
faster and faster in our lives and
especially in our data centers you know
you produce code you produce new
releases multiple times a day now rather
than multiple once every multiple years
and you've got to be able to keep up
with it and over the course of it you
know we've been moving from these big
private data centers and big web servers
to environments where everything's IOT
machine learning in a Iong and
cloud-based and we're going from a
capital expense to a subscription model
and along the way there have been lots
of languages that have come up to be
able to solve particular problems for
example are in scale ax you know allow
you to do data data mining data
analytics you know node for scripting
node.js for scripting Go Java the list
goes on and on and on there's really a
plethora of languages to choose from you
know we've been we've been moving cloud
software we've been moving from big iron
into virtual machines and you know
inside of virtual machines you have the
guest OS then you have your libraries
and your binaries and the a of your
application sitting on top of it stacks
actually really quite tall it does give
you you know a level of abstraction a
level of flexibility because you can
move between physical machines
containers we're supposed to and they
really do make things more efficient
right containers are isolated but their
shared OS virtualized the OS you know
with virtual machines we virtualize the
hardware with containers we've now
virtualized the operating system and we
want to go take this to the next level
though because if you
look at if you look at like what a
container actually looks like and what
the container stack actually looks like
even though it looks like this so you
have in it you have your host operating
system in your container virtualization
at the bottom then you have an entire
stack on top of that just so you can run
your app and if you're running a small
JavaScript app for example a small
servlet or something there's an awful
lot of memory and disk and everything
else that's used just to run that little
application you know just to write a
simple hello world of Java takes 24
megabytes you know Java scripts it 18
megabytes and in Ruby it's 8 megabytes
that's a lot of that's a lot just to be
able to print literally print HelloWorld
so what if we could share these
resources what if we could take these
things and these in these stacks and
share the comet the commonality of the
things that are common between them give
them the same service like the
interpreter the JIT and compiler the
garbage collector memory manager the
code cache thread scheduler network
access and the file system access what
if we could share all of that because
those are all common whether you're
talking about Ruby or you talk about
Java you're talking about even C or C++
or any LLVM language you know when you
look at these vertical scotch you have
all of those things happening in every
single one of them but we could what if
we could share them well there's been
some problems one is garbage collection
coupling and then the other one is other
languages just don't run in the JVM very
well for example and you try to do it
with any other language model and it
doesn't really work either
whether it be done that or something
else it's just there's problems with the
language object models being able to
interact between each other well we've
actually solved that and how we solve
that is with a with a project that we've
been working on called growl VM so let's
talk a little bit about growl so growl
is polyglot that is multi-language
virtualization and we started with the
Java Runtime and the foundation it gives
us the virtual machine to do the
virtualization on top of
then what we do is we build up an API
that we call truffle now truffle is a
multi language API that allows us to
create objects and structures inside of
the Java VM then we take the language
interpreters like the Ruby language
interpreter the our language interpreter
we have it interact with truffle by
doing that and we're now able to create
objects within the JVM like the job
JavaScript or Ruby objects inside of the
JVM this allows us the opportunity to -
how share the objects as you'll see
we're going to be able to share the
objects inside the JVM between the
environments so this really gives us an
opportunity to eliminate all of the code
that you've had to write and debug to
move data between these language
environments so when you have a multi
language application you've had to build
out these environment you've had to
build out ways to connect these
environments whether it be a pipe of
some kind or you know you write a JSON
file or you write a JSON file to a pipe
that then gets read in it gets broken up
reinterpreted and created a new object
act on it ship the data back but we're
actually going to be able to pass data
back and forth between these without
having to do that it's really pretty
cool the next piece of it is the growl
vm compiler now this is this is cool
because grah vm compiler Amanat monitors
the truffle api and learns about the
language through the truffle api and
then pre compiles the code into code
snippets and something really cool that
growl vm does the compiler does is it'll
even notice that if it optimized
pre-optimized incorrectly and we'll pull
the optimization tree apart and rebuild
it properly so that you can be sure that
the code that's been compiled is
actually the fastest code for your
application then on top of the
interpreters we build the libraries and
the you know like nodejs and rails and
your applications on top of that so now
we we have this shared common
infrastructure and a much smaller stack
to operate with
but we take it a step further I mean
this sounds easy but there are some
complications you know like well doesn't
this break security
well we've handled that by being able to
isolate the memory for each of the
stacks and for each of the applications
through a thing called an isolate and
this actually works really well for not
allowing anything in that space to
access anything outside of that space
unless it's explicitly requested and
then how about native code that's
another problem right a lot of the Ruby
a lot of the JavaScript stack is
actually native code well what we did is
we plugged in the LLVM bit code
interpreter so we now have LLVM and all
the capabilities of LLVM inside of
grothy amol so that means that things
like the our native libraries the
JavaScript native libraries Ruby and
rails native libraries and eventually
even seen C++ will be able to be run
through LLVM inside of the truffle and
Java Runtime so really any application
can be run inside this environment so
here's a little bit more of a thorough
picture of what it looks like so you
know you go to run an application and
say JavaScript and how you do it is you
type it you give an eval statement you
say you're going to run it in Ruby and
you give the the line or the series of
lines that you want to execute and that
gets passed over to the Ruby interpreter
it gets handled by the Ruby interpreter
and then that object gets passed back in
the meantime the growl compiler is
interacting with the truffle API and the
Java Runtime via the truffle CI and JVM
ci interfaces to be able to compile the
code so that the next time you try to
run it re even faster and you'll notice
also that you can run a native
application a native java application on
top of that same JVM and now you don't
have the all of the capabilities that
you do with truffle but it does mean
that you have Java being able to run
there too you can also run java in a
Java interpreter on top a truffle and
then get the same kind of interactivity
and I'm going to show you how that looks
in just a minute so the truffle polygon
API
is what allows us to do this
interconnect between these language
environments and actually be able to
pass objects back and forth between
these language environments in fact it's
the exact same object in memory that
gets passed that around between the
object environments the other thing that
growl allows us to do it actually allows
us to the truffle API in particular a
lot in the runtime allow us to embed in
the Oracle database and eventually in
other databases also in other data data
engines so this allows us to use Ruby or
JavaScript or are inside the database
significantly improving the speed
because one of the big problems with
like writing in our application to
interact with the databases you either
have to pull a bunch of data over so you
don't make a bunch of round trips back
and forth or you make a whole bunch of
round trips back and forth if you're
pulling data over you're spending time
pulling data most of what you probably
won't need and which exposes your
application to the possibility of
exposing that data when it shouldn't and
if you make the round trips to only get
the data you need right now you're
slowed down by all the round trips all
the queries and everything else but by
being able to put the Gras VM inside the
database and run your application or
your your analysis inside the database
you actually can significantly speed up
multiple X speed-up of your application
and again the truffle API follows there
so remove a canned looking at this right
we talked about these large stacks that
were really big what does it look like
what would this stack look like using
grow VM what would look like this so you
have a couple of Java you know a few
Java apps that are native that are
running right on top of the runtime and
then you have some Ruby apps that are
running in a single Ruby stack Python X
absolute are running a single Python
stack and some Java app node apps
running in a node stack so you say you
can say you save a lot of CPU time you
save scheduling time you save code
you can reuse code memory management
gets simpler you get higher performance
and you even get you can even get more
containers and and get higher server
density now this is another thing is you
look at this surveillance environments
that we're building today and you know
the idea is that you should be on just
throw some code at a server at an
environment and have it run and execute
and come back with the answer and go
away what that means is you have to have
a some kind of container or virtual
machine or some environment running
waiting to take the code but if you're
going to build out a server this
environment you're either going to
target particular containers or
particular VMs for particular languages
or you have to run all of those going
back to this one if to run all of those
environments all inside that serverless
environment inside of that VM to so that
it can be ready for anything that's
thrown at it but with Grall you know it
you literally just throw the code at it
and it'll handle it you know I told you
things it goes faster so let me just
give you some numbers so you know this
is an open source project and we've been
working on it for a while so you know
I'm going to give you the real numbers
Java Scala they're about anywhere from
point A techs of the natives per in
performance to 2x faster JavaScript is
about you know 50 percent slower to 150
percent you know 1.5 X faster and it
seems to be right around a you know
right on par for JavaScript Ruby and R
can get significantly faster somewhere
around 5 X is what we've seen and then C
and C++ it can be pretty slow but we're
working on that and actually we're you
know the whole point of talking to you
about this project is we're looking for
people to get involved to add your
favorite language to it it helped us
make this faster we want it you know
we're going to give this away we're
putting it out there it's out on git
it's available today and has been for
quite some time we're looking to get
people involved so we can make this
faster and spread this around the world
so that people can use it and benefit
from it
you know application level performance
it's not just about benchmark so let's
look at a real application Twitter
actually has published this they did a
talk about this withdrawal Twitter rinse
25% faster so they put out 25% more
tweets per second with youth by using
grow and the WebLogic server we did some
tests there and we get about 10% faster
performance so real-world performance
you can get real-world performance
better real-world applications you have
real-world performance benefits so we're
pretty excited about that we've been
working with Twitter and we're you know
looking for other companies to pick this
up and use it in their infrastructure
too so let me give you a demo guys I've
got a couple of little demos of how this
all works I'm going to walk through the
code for the polyglot demo first and
then I'll show you so we have a Java
class called tests and it prints a
HelloWorld in HTML HelloWorld and so
you'll see this is a Java this is a Java
class here okay now this is what the
server this the Java Script looks like
I'm going to dig into this a little bit
let's break it down a little bit make it
a little easier so we create a Java type
a big integer right and first thing
we're going to then do is start out the
text with hello world from growl dejay s
so that's going to print now we're going
to add to that big integer we're
actually going to make it 2 or yeah 2 to
the 100 and we're going to print that
out and add that to that text so now
we've taken this Java integer and we
printed it into the Java Script text
then we're going to call that test class
which printed out that hello world now
we're going to now it gets interesting
now we're getting out of the world with
Java into the AR and we're actually
going to run a query oops we're going to
run a query that gives us an eval you
and evaluate into an array and we're
going to add that then we're going to
build out an entire SVG object so we're
going to actually build a
cloud graph and plot it and we're going
to take that and we're going to return
that into that text object also and then
finally we're going to set up and we're
going to listen on in port 3000 to
actually execute this so this is what
this looks like here so it's actually
starting up now we can flip back here
and you can see it says it's loaded the
required lattice package from our and
here you go so you can see here the
hello worlds from garage is that's the
JavaScript print then we have the the
big number and we have hello from Java
we have the random number in the that
was in that array element zero and we
have a cloud plot here and we can even
refresh this you can see the numbers
change and the cloud plot changes fresh
again and every time we're calling into
our and redoing this entire thing so the
key here is is in other you know another
environment you would have you couldn't
have done this you would have had to
pass this data back and forth this cloud
plot would have had to been generated
maybe written to a file or piped across
a you know a pipe to get the job done in
here we just passed it back as an object
so that was the first thing so that's
that's kind of cool I'm really really
excited about what's possible here for
engineers so let's talk about the other
one which is Java streams and here
there's not really anything in the slide
deck home ok so I actually have a little
script here I'm going to run that's
going to print out what it's doing well
sorry but what we're going to do is
we're going to compare compliation and
run of native JDK against running growl
so I'll just as it I'll just uh there we
go as it runs so here we did a
compliation of test stream Java and it's
running and you can see here 20 passes
it took four point eight seconds now
we're going to build an image which is a
special specific compliation so growl
has the ability to create a compile
compile
just for the platform you're on and just
for the application you're going to run
it takes here a couple of seconds a
couple of 20 or 30 seconds to create
that compiler and then we're going to do
we're going to do another compile of
that exact same code and then run it
using draw it's just about done here
actually a couple more lines so you can
see here it's actually going through the
entire java environment and looking at
the features and the objects and the
type flow and everything else and
putting it all together to build this
specialized compiler and very good we're
down to debug info so we're just about
done here and then there you go so now
we've compiled and you can see it took
almost no time to compile the thing just
a little app to show you what it can do
that was that and then we have a we have
a couple of sites that you can go to get
more information the we have a growl VM
OTN page which is where you can download
the binaries as they currently stand and
they're updated on a regular basis
almost a weekly basis and then we have
and that QR link on the left-hand side
will get you that and then we have all
of the source code is available on get
like I said this is an open source
project and that location is available
in the QR code in the on the right hand
side so I look forward to I hope to see
you around I hope to be interacting with
you as we work on making Grall a
worldwide sensation thank you very much
for your time today</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>