<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JAX-RS-ME: A New JSR for RESTful Web Clients on Java ME 7 | Coder Coacher - Coaching Coders</title><meta content="JAX-RS-ME: A New JSR for RESTful Web Clients on Java ME 7 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JAX-RS-ME: A New JSR for RESTful Web Clients on Java ME 7</b></h2><h5 class="post__date">2013-02-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Hx74U2CZnTE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so I guess we get started good
morning my name is mike luckily i work
for oracle and the Java platform group
and I'm going to present to you Jack sir
as I mean checks are SME is a new API
for restful web clients on Java ME we
have been working on this as an internal
project for several well actually since
the beginning of the year and we have
developed sorry we have developed an API
that follows restful patterns on Java ME
clients we have a client api which is
based on how can I stop disk which is
based on jaisa 339 to consume web
services with a rest concepts from Java
we provide a higher level abstraction
than HTTP to access web resources to
transmit arbitrary mind types between a
client and the server and to transmit
java objects actually we encapsulate web
concepts such as a target the path we do
in vacations we have a request we talked
about responses entities and headers so
this is the structure of the
presentation first of all I'm going to
explain to to you why rest is important
maybe just for my for my inside who of
you has been working on rest api sore
using rest ok so I'm going probably
that's not not new for you why rest is
important and what it is but anyway I'm
going to give a little bit of motivation
on that then I talk about the tracks are
SME API specifically about the
architecture the principles and the
model and also i'm going to show on some
examples how jacks or SME can be used
and the beauty of the API and where it
really helps us to go to a higher level
abstraction than just talking and plain
HTTP packets
and then a little bit of under the hood
look where I'm going to show how it
works and what the concepts and the
extensibility is so first of all very
high level what is rest so it's an it's
an acronym for representational state
transfer which is a model for
distributed services in service-oriented
architectures it's one of the structures
that's prevalent on the internet and
basically the principle is that we have
a system of distributed reusable and
decoupled web services with a nice
couple of nice features like scalability
and having a common and simple protocol
that works across all different devices
and firewalls there are earlier
technologies for example a distributed
computing environment ECE then korba
Java RMI and also so based web services
and typically when we talk about rest
people think rest over HTTP but it
doesn't have to be over HTTP you can do
it also a truss and over other protocols
basically every web services rest so
even a simple web server which just
delivers web pages static web pages
without anything beyond that is a
restful server why is rest important so
there's a nice page on the internet
which is called a programmable web com
which has a directory of restful web
services that has a director of web
servers in general but you can filter
for categories and for protocols and
styles and if you go there I did that
one month ago or so there have been more
than 4,400 rest services with all the
who's who in the Internet in the list so
you can it's a little bit small but you
can read twitter twitter and flickr and
amazon and facebook and ebay and last.fm
and delicious and yahoo and google ajax
urgent yahoo again and Foursquare so
basically everything is rest
and this has by far outweigh the sub
services for example so there's only
1350 so based web services 150 xml-rpc s
and probably the figures by now have
changed again rest is basically a
collection of principles of how to do
conversation between different machines
so first of all the underlying concept
is every addressable object is called a
resource so a service and an object is a
resource and each of these items has a
URI so we have a unique way of
identifying an object or on service then
on so we have a way of identifying and
not yet and then we have a couple of
simple methods and these are just the
HTTP methods and basically you just need
four of them you need to get put post
and delete to talk to every resource
that's on the net its representation
oriented and a single resource on D on
any server can have different external
representations so on the server you may
have something which is implemented in
let's say in C++ or it could be Java EE
or it could be any any other way of
implementing a web service and the
external representation could be just in
common exchange format like HTML XML
JSON or others we have stateless
communication so that means that you can
easily scale you can deploy a service
across different servers you don't need
to have a certain context and everything
every state is just contained in the
request itself and then there's another
acronym hypermedia as the engine of the
application state so
that's that's a complicated acronym but
the idea is pretty simple so basically
we are using hypermedia which means
linked documents and the hyperlinks
actually represent the state transitions
between the different application states
so that was about jay arrest in general
now we come to jax or as me so we have
not been reinventing the world but we
have been taking a subset of the new jsr
jaisa 339 which is currently just going
into public review so it's an enterprise
edition jsr and we have been tailoring
it down to run on CL DC now Jo 339 is a
Jegs RS to the dog client and server API
and since we're on the client only we
have only been using the client API it's
a higher level API framework so it is
above HTTP and it enables transmitting
of arbitrary Java types it is the API is
completely agnostic from the external
representations of the API does not
limit you to use JSON or to use XML or
anything else and the client at the
server negotiate over HTTP content
negotiation on a common understandable a
set of representations so basically the
client tells the server and ask the
server with it what it can provide and
tells the server the capabilities that
can support and then they agree
automatically on what they do and what
language they speak and we are
encapsulating rest and that concepts
like your eye and path and we had that
before um a high level architecture
picture so underneath we just have cldc
and on top of that we have the jacks or
SME API and specification which consists
of a provider framework that allows to
configure and text
and to modify the behavior of the API
we're coming to that in more detail
later on and we have configurable types
so we have a client we have a web target
which is appointed to the server we have
an invocation which is basically a call
to a method on the server and on top of
that we have an application we can have
a midlet we can have an I'm amulet which
is the embedded application equivalent
to a midlet we can also have a simple
plain cldc main so we don't need to have
anything from a higher profile if we
have a higher profile like mid p or IM p
or what is now called me a better
profile the API gets extended and that's
a bit hard to draw an architecture
diagram but in this case we can use the
service loader to also plug in
additional things into the provider
framework just using the concepts that
we have here so basically we can use
shared libraries to extend what the
behavior of the Jags are SME API would
be and if you look at the picture again
we have the providers and providers is a
very generic concept here so provider is
basically the mapping of of a protocol
into the framework so we can have as we
see in the in the lower layer we have
the provider framework which as filters
which has interceptors or entity
providers and these providers can be
extended by platform providers so by
plugins as a shared library if we have
mid p or I MP or that can also be
supplied by the application so if an
application wants to speak a very exotic
language or needs to support a very
specific protocol like co-op for example
this could be provided as part of the
application or it could be provided as
part of a shared library west jax-rs
useful on Java ME on a client so first
of all it's a lightweight API it's
simple simple to use and it's powerful
to use all rest based web services from
a feature phone and from a small
embedded device it's based on HTTP which
is mmm it's a small API as I said before
it's it has limited footprint it has a
powerful extensible framework for
serialization and deserialization of
Java types so basically you can put you
can put and get java objects over HTTP
and the platform takes care over the
serialization at the t serialization and
so you basically invoke a method with a
java object on a web server and you get
a java object back jax-rs defines
out-of-the-box support for simple types
so it supports by the arrays strings and
input streams but it's as powerful as to
support generics and arrow types and
arbitrary collections of objects it has
it supports a fluent api style i'm going
to talk about it a little bit later so
it allows a very expressive way of
training method calls into a combined
statement which has a lot of
expressiveness in a single line the API
has protocol and content representation
details from the application so a small
animation on how it works we have the
client on the left side with the jags RS
framework and the server on the right
side where we have the target so some
kind of resource on the web and we want
to use it and talk from the client to
the server so we have a drum object or
one and we are invoking something on the
target with 01 as an parameter and 02 is
the return object of this invocation
so we just do an HTTP request to the
target and we get an external
representation of 0 1 in in a form that
this server understands so it could be
XML it could be Jason it could be binary
it could be anything then on the target
the server d codes or D marshals the
object that has the object 01 again it
can do something with it it processes it
and at some point of time it has a
return object 02 this object is returned
over the network again as an HTTP
request a response with another external
representation of o2 and then on the
client side we have the object O'Toole
and the external representation is not
seen in the Java API on the client side
i'm going to show you a little bit more
how this works in the examples so that's
a simple example of receiving an
instance of a user-defined class via
jason and first of all we have to create
a client this this is a little bit of
boiler boilerplate code so we create a
client instance using the client factory
it's very faint don't it's hard to see
okay so we're here then we create an
instance of a web target so we just
talked to the server HTTP example calm
and we address a remote remote resource
on this server so the blue marked
methods are checks or s methods so first
of all we create a target then on the
target we address
and this is a web resource for Jason so
it could be just in a path segment for a
resource where we know that it is
capable of returning a JSON response
then we create a request and we tell the
request that we want to get the jason
type so media type is also defined by
jax-rs and we are building a get and
this basically is our invocation and
then we just invoke this method and here
we get a response and we read the entity
into a user class and then we have the
instance that looks pretty simple i
would say and here we in this example we
see all the important concepts we see
the target we see the path we see the
request we see the method we see the
invocation and we see reading the result
now let's make this a little bit more
simple so now we convert this into into
fluence a fluent style it's the same
example so boilerplate code again clan
factory new client api we get the
response by invoking the get method and
now we just do it in a single line so we
do client a target with the URL then we
add a path with the web resource so
that's the identification of the remote
object we do request on this web
resource and we expect the response in
the media type Jason we build a get on
that and we invoke it and then we get
the user class of tricked again so now
we have been folding this set of five
six different programming lines into a
single line and this is what what is
called fluid style so it's a chaining of
method calls and this is more expressive
and we have more compact source code so
you can do
whole invocation on the single line if
you look briefly again into the previous
one it's a couple of lines longer and
now we have been folding five four lines
into a single line that's all no magic a
second example so say we wanted to raise
up receive something from a server but
we don't know exactly whether the server
can support Jason or it might also just
only support XML as an external
representation so in this case we create
a web target again as we did and on the
target line we now have basically a web
resource which could be just the same as
we had it before and the only difference
here is on the invocation that we under
request line query both media types so
we ask for jason or for xml and we build
a get here and we invoke the method and
we get a response object and read the
object again okay that was receiving of
an object and now we are sending
something so let's assume we have a user
class object and an instance you see oh
we do what we have already been doing
before so we create a target with the
path and now we create an entity for the
user class instance and that's a mistake
here this should be not Jason but XML so
we create an entity for the user class
instance and we encoded in XML and now
we just call the method again so we
build a post with the entity as a
parameter so we have a kind of wrapped
encoding of the user class object
we invoke the method here and then we
check the response status and if the
response status is not okay then we do
some error handling and we don't care
about HTTP headers we don't care about
XML encoding everything is just
happening behind the scenes in the
framework a couple of observations here
so the method invocation is completely
independent from the external
representation and they're only minimum
change is required if you want to adapt
to other representations all details of
the parsing and encoding process are
separated from the application so we
have not seen any XML parser adjacent
parts in these examples an application
just invokes methods on web resources
and pass passes java objects as
parameters and we get return objects
which are also java objects and this
works for simple objects it works for
arrays it works for generic types and we
can use fluent style to Jane methods
into a single statement or single a
single line so you've seen the magic now
you're certainly interested how it works
the API defines a client-side framework
so and you can use it to construct
object references to remote app tricked
that's the web target we have seen that
before we can create server requests we
can invoke requests on the server and we
can process server responses and the
framework supports converting between
Java and external representation formats
and has a common interface in the common
way of defining defining these kind of
wrappers and converters marshalling are
marshalling that as the type that's that
it's used in in korva
the Tuaregs RS operations are HTTP
methods so get put post and delete is
used here get is equivalent to reading
an object put is writing an object post
is adding an object and delete is delete
so how do we speak a common language
between the client and server since we
have different capabilities and the
external representation format depends
very much on the common capability so
you have a server which can handle
several media types you have a client
which can only handle a subset of that
and they need to indicate and
communicate somehow the capabilities and
there's this HTTP content negotiation
where the client tells the server that
it can handle the following mime types
for example it can only handle text
responses or text HTML or application
XML or application Jason as types then
it can also indicate language encodings
in the locally and you can imagine doing
additional encoding of the actual
protocol like gzip compression or
deflation the client maps the Java
objects to requests and responses and
processes the HTTP messages and the
mapping happens via an extensible
framework of what is called here
providers and there's a couple of
configurable types to modify the
behavior of the framework we have
basically four configurable types we
have client where you can hook in
different providers we have a web target
we have an invocation builder which is
creating what's actually happening in
the invocation so it puts together the
different segments and parameters that
go into the invocation and then we have
the invocation by itself and /
configurable type lead providers and
other properties can be individually
it so several provider types we have
entity providers and there are basically
two interfaces that can be implemented
we have a message body reader we have a
message body writer and they define a
mapping between the external
representation and the java objects and
here we if you just think briefly how an
HTTP message looks like so you have a
header and you have a body and these
providers map the body of the message
into a java object so you have we see a
little bit more in detail how this works
then we have another extension point so
first of all we have the marshaling we
are marshalling which can be plugged in
then we have the entity interceptors so
we can wrap around the read and write
methods of the providers as I said
before we have something to read and to
write from the message body and you can
put a wrap around that and this is
called entity interceptor and can be
also extended here so for example you
could extend all providers all readers
and writers with a common compression
scheme and last we have filters which
define an extension point before and
after request is dispersant to inform
the transport layer so there are
different layers here and when before a
message gets actually sent into the
protocol the filters are called so you
could also use the filters to convert to
a completely different protocol and not
use HTTP but use something else like
co-op for example these filters can be
used for other purposes as well like for
having a common log and facility where
you have all your messages being just
locked to some some kind of deeper
protocol mmm the extension of the
framework works because the providers
are looked up and used dynamically so
they are determined dynamically at
runtime based on what you actually get
in the protocol response based on the
mindtap and the java type and this is
extensible so if no reader for a
specific type can be found so you try to
well try to receive some some kind of
second version of a user class and then
if no reader is in the system for this
specific sub for this specific sub class
well there's a mechanism to find the
reader and use the reader for the
nearest supertype so it's a common
mechanism to always use the best
possible matching reader to read the
response and to process the message and
there's also some kind of binding
president's on the filters and
interceptors so there's a guaranteed
sequence of how these filters and
interceptors are executed so assume you
have multiple filters you can have just
a sequence of how they are applied
assume you wanted to do logging and
conversion to a different protocol and
you want it to do gzip encoding you can
ensure wire binding presidents when of
which one of these filters happens and
is applied how can new providers be
deployed so as I said before additional
providers can be created to adapt to
other transport formats or new content
types so basically to extend the
framework and also single provider can
be used for multiple roles so you can
create a message body reader to handle
multiple Java types so it let's say you
have three user classes and you wanted
to serialize them to Jason then it
doesn't mean that you have to create
three different instances of a for
reader for that you just create one and
you do some some type in first
introspection and find out which type
you are going to use and the reader then
just
can process them accordingly providers
can be included in the platform so when
drugs are assist applied you have a
couple of standard providers that are
guaranteed to be in all platforms these
are very simple things like string or by
Terry providers we can deploy them as a
service if the platform supports the
service loader so it's able to have to
Angela shared libraries and they can be
bundled with the application as we have
seen in the architecture picture before
and that's the common and flexible
extension mechanism so an example the
message body reader interface and this
is used for converting an HTTP message
body to a java objects and you only have
to implement two methods so that's
pseudocode without all the details of
the parameter names but basically it
looks like that you have to implement
two interfaces when you want to create a
new message body reader you have a
boolean method called is readable which
checks whether the implementation can
read a Java type from the media type
that is specified here so you can call
it's readable byte array with a media
type of Jason or you can call it's
readable of java.awt image for example
well that doesn't exist in cotc let's
pick something else it's readable for EM
string array and the media type would be
application XML so you would return true
if the writer can be used to convert
from a media type to the Java type and
then the framework itself caused the
read from so all this is hidden from the
ecliptic application we are currently
under the hood we are creating custom
and extended providers and extend the
extent the interface so the read
from method is simple as well so we have
the Java type in the media type once
again and then we have an input stream
and we have HTTP headers which can also
be used from the provider implementation
to do it if no additional processing in
this method is read from returns an
instance of the Java type that's on the
parameter line so it reads an input
stream and as a parcel for the
appropriate media type format so as a
practical example for example if you if
you have a Jason reader here you would
understand the media type application
Jason and you would have adjacent power
set as the implementation here or if you
have a media type application XML you
would have an XML parser and read just
an XML block from the HTTP packet and
convert it to a Java type which you're
then return as the return value of the
read from and that's pretty flexible
message body writer is also not very
complicated so we have an is writable
which is very similar to the is readable
once again checking whether this
provider can be used to convert from the
media type to Java type direct from the
Java type to the media tab now we are
writing so we're doing just the opposite
way we return true if the writer can be
used to convert and this is just used
internally from the framework to
determine which of the providers can be
used for a specific invocation and this
is happening completely dynamically as I
said before there's also a new method
which is called get size to find out
what the length of the serial assessed
serialized form of the Java type would
be this is important if you want to
segment things or if you want to ensure
that things fit into a certain payload
size just to do
potentially to snipping a message into
into different segments and then we have
the right tool which takes an instance
of the Java object and writes it to the
output stream in the appropriate media
type and I gave the example of having a
provider for for only one media type but
you could also imagine to have a common
provider which can write a Java object
class into JSON or XML so it could
support both it just would check on the
mediator and the media type and
dependent on what you have what you want
to create you can use the same writer
and it would just use a different way to
externalize the media type at the the
Java tap into a media tab ok so we touch
the readers and writers the filters and
interceptors basically work in a similar
way we don't go down because that would
blow the scope of the presentation the
interesting thing is you can set you can
have various extension points so you're
not and only have the and you can set
them at individual at individual
extension points so you can set the
providers on the configuration and you
can have multiple configurations and the
same in the same runtime so you could
imagine having even two different
protocol configurations that you would
would use and one would be using HTTP
HTML and the other would be for example
co-op the readers and writers can handle
arbitrary driver types and you can use
them to adapt for new payloads and new
formats the filters and interceptors can
be used to do additional pro
assessing compressing or mapping to
other protocols mmm we talked briefly
about standard entity providers so what
comes out of the box we have byte arrays
that can be transferring coded we have
strings we have input streams and we
have readers and then a couple of the ID
the multivalued map and the streaming
output with a couple of eggs of
constraints and this basically is the
API a very small frame work to do in
vacations to do to flexibly construct
method cause and to return objects to
encode and decode Java objects we have
been defining a clean subset of data 339
with no additional classes and methods
so everything that you code against this
API should run on jaisa 339 it's
suitable for resource-constrained phones
and small embedded devices so we have
done a reference implementation which
has a footprint of something like 200 k
and we match the capabilities of the
Java ME platform which was quite a
challenge in some areas because drugs
are SSE has some well a lot of concepts
which don't exist on Java ME the
applications can be written using a
subset of the familiar REST API from
trees are 339 so if you want to go on
the mobile platform on an embedded
platform and if you know drizzle 339
you're unfamiliar groans we have been a
couple of challenges and Java ME for
example we don't have runtime
annotations in Java ME we just have the
compile time annotations and so we
cannot do annotation based discovery of
providers we need to have explicit
registration form from the application
from the server
here that's an implementation detail it
doesn't limit the what you can actually
do with the with the API there's also no
out-of-the-box platform support for exp
in Java ME so we don't have an
automatically well way of parsing XML
here but that's something the
application of the provider could
provide and this is something like an
Outlook here we have been recently
looking into using a common rest api for
also embedded servers where maybe not
HTTP is used but some other protocols
and i mention it before co-op is defined
in at sea and it's used for m2m
communication and there is a mapping as
part of the co-op spec between co-op
protocol so it's a binary protocol but
it follows the same scheme as HTTP or so
you find also similar methods like a
foot post and delete and you have binary
representations here and we are
currently investigating a mapping and an
extension or maybe just the use of this
API for also court protocol and the
current view and we are still
investigating is whether a mapping
biofilters and interceptors can handle
the whole thing so we have a pretty
abstract API which does not really
expose a lot of HTTP there is one class
where we have access to the HTTP HTTP
headers but they don't would not have to
be HTTP so it's it's basically just a
header class for additional attributes
that gets sent and then request okay but
this is work in progress and we're
continuing and that so some more
information there is the jsr 339 which
as I said before is currently a public
specification done by colleagues of mine
from Oracle
there's the jersey implementation that's
a Java EE jax-rs implementation with a
lot of documentation on jersey that
java.net there's a very useful book
written by bill burke on restful java
with jax-rs which explains in an
excellent way all the concepts so it can
strongly recommend that and if you want
to know additional things about what we
do here or what we have I'm here I'm
here for Fred for questions I have
business cards I have an email address
so I'll be happy to answer everything in
addition that goes beyond the slides all
this would not have been possible with
the help of many people so many thanks
to the speculates of JSL 339 this would
not be possible without them and also
many people at Oracle who helped on
contributing support feedback and
discussions ok that's the safe harbor
statement so basically everything I just
told you in the last 45 minutes has been
untrue completely lies and now I'm
available for questions so the question
was
how I think how this rules well what not
sure what I understand the question when
you say to adapt to that basically you
just use eclipse or okay so basically
you use netbeans or eclipse to write
your readers and writers and apart from
that the invocation of the method caused
by itself you just caught them as plain
java code so it's it's you take your
normal regular Java IDE and you should
not need any specific tooling for doing
the processing of the messages by itself
because it's hidden in the framework
itself so you just take your normal Java
IDE you call methods you have to know
what the method names are on the server
side and what kind of parameters they
take and I'm not very so I was I was
working in this under the hood so I have
no clear insight on what support for
application development beyond the job
ID is there other questions what kind of
applique
you would use that for authentication
security we're using HTTP or you could
also use https but ok it's it's getting
getting far there is the authentication
but this is this is work in progress so
it cannot ask the question right now but
I mean having this API without without
authentication is not good enough but
there's less work going on in JS r 3 39
and we just have to adapt that so we
don't invent anything here a new but we
just take what is what is injuries are
329 further questions
okay then thanks very much for your time
and for your interest I'm here for
individual questions and as I said
before if you want to know more or have
a look at the API give me a business
card and we talk about it thanks very
much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>