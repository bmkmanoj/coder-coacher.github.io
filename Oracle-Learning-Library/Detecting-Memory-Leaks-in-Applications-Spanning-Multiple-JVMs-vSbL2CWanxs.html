<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Detecting Memory Leaks in Applications Spanning Multiple JVMs | Coder Coacher - Coaching Coders</title><meta content="Detecting Memory Leaks in Applications Spanning Multiple JVMs - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Detecting Memory Leaks in Applications Spanning Multiple JVMs</b></h2><h5 class="post__date">2013-01-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/vSbL2CWanxs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Albert Nabokov and I'm gonna
be talking about memory leaks and you
know I started software development
about 16 years ago in school and my
initial project where I started was a C
C++ and assembler and I'm sure most of
you know when you deal with these
languages that a lot of times you deal
with memory leaks and I remember myself
locked up in the in the in the labs
where I would spend hours sometimes days
trying to track down you know these
nasty memory leaks
now when Java came out I started you
know programming in Java I thought this
was great
you know the garbage collection and
memory management and all this so memory
leaks will be you know a thing of the
past although I discovered the opposite
where you know because it's all kind of
taken care of by the underlying machine
by the VM it's kind of hard to figure
out exactly what happens to memory and
you know sometimes things happen under
the covers and you're not really sure
you know is this actually released or
not so and then the the flipside of that
as well is that some people who are not
some developers who don't have a very
strict memory management kind of
practice in Java then end up writing
really poor code where in fact that you
have instead of having kind of a more
efficient code you end up with actually
bloated code with memories leaking all
over the place so and in fact you talk
to some of the Java developers and they
would say well there is no real Java
leak there's no really memory leaks in
Java and I would say technically it's
probably true because old memory is
probably accounted for and it's actually
resides on the heap it's not like in C
C++ where you drop and reference and
it's gone you can't really get it back
so it's kind of difficult to track them
so in Java also it's very interesting
because sometimes leaks are not really
leaks because they are really part of a
normal work
right so if you blow out your heap space
it doesn't necessarily mean you have a
leak it may be that your heap or your VM
is not properly sized so therefore this
whole concept of the leak is kind of I
mean you got to take it with a little
bit of grain assault here but
nevertheless I remember when I you know
and even now when I code and I do code I
sometimes I spend a lot of time trying
to profile memory and try to understand
why I'm getting these nasty out of
memory exceptions so when I started
looking at this problem and my
background is in performance monitoring
I tried to say well I don't really want
to spend all this time trying to figure
out why there is a problem or if there
is a problem I want to be able to
automate that somehow and I started to
deconstruct vm's and I started to look
at this problem a little more detail so
I look at the really two perspectives of
of the JVM so an example obviously when
you look at when you're running a VM and
before we get into the multiple VM so
let's look at one instance you get one
VM and from the operating system there's
a view of the VM from the way the
operating system views it right so
you're looking at you know the memory
footprint you looking at handles you're
looking at you know threads you're
looking at CP utilization of the VM and
then you're looking at actually when you
run within the virtual machine you have
a little bit of different view of the
memory usage and that's typically what
we call heap right and then you have
allocation and you have garbage
collection and in fact you can have a
situation where this perimeter kind of
stays kind of constant where the box in
the in between is kind of like goes up
and down up and down and in often times
I remember when we had one of the
applications installed at one of our
clients they would say well you know how
come you know this perimeter is at you
know four gig but really inside it's
really something different I mean why
doesn't it release the memory so the end
of all these kinds of questions which
sometimes it's very difficult to
quantify
so when we look at memory leaks and one
of the interesting things is you can
have leaks that are kind of in the
perimeter right so you can have leaks in
these green sections and then you can
have leaks that are in the in the in the
box and bit in the middle so and a good
example would be which is you find often
times it could be a bug right in the VM
itself which could potentially be leaky
memory so you have an expansion in the
perimeter while the heap ins internally
actually is fairly constant so that's
that's one way so if we look at for
example there's obviously different ways
that you can allocate heap size so
here's an example of a when you start a
VM and you pre allocate the heap all up
front right in that case the perimeter
of the VM kind of stays the same so from
the operating system point of view let's
say you're doing a four gig VM this will
fairly stay constant let's just assume
there's no leaking outside of the VM in
terms of the handles or threads or
anything like that but my heap size can
fluctuate quite dramatically internally
meaning the memory that I'm actually
using so here's an example of 10% so as
I'm running in the VM I could be seeing
at 10% memory utilization 90% free but
from the outside I'm actually using or
all four gig right so if somebody were
to look in and say well you know this VM
is that if I'm just looking at the OS
perimeter I'm gonna say this VM is
outside you know it's probably leaking
memory because I'm using all this memory
so that could be a false positive right
there
and I think it's important to realize
and I think most of the when I talk
again Java developers they really focus
on this and really not so much on that
outside layer and in fact you can have a
situation where you're running here and
actually if everything is perfect but
let's say you loading a gen I like a
library and it's got a leak inside that
would be part of the address space
of the JVM and in fact the perimeter can
grow outside and you can experience a
memory league without actually having a
problem inside the JVM and those are
typically very hard to trace down
because it's in the bowels of the of the
dynamic link library which is kind of
tough to to to detect and then obviously
top tough to diagnose you have to talk
to your third-party provider whoever is
providing the actual DLL to figure that
out so a fairly complex problem
especially if you're you know when in
development you dealing with one or two
instances but if you actually deploy
running application and you know in live
environments you don't really want to
have these type of problems happening
you want to be able to kind of
proactively detect it and proactively
figure out if in fact you have one VM
that's kind of what I would call in a
leaky situational leaking so here's
another example where you have a
floating heap right where the perimeter
and the internal can actually flow right
and it obviously depends on how you you
know you start up your VM but again all
this examples so that I think what I'm
trying to demonstrate here is they you
can't just look at one perspective and
you can't look at the other perspective
you have to really look at both
perspectives I think I'd like for
example and we look I mean a very clear
example would let's say JDBC right you
can create you know statements and
sometimes you know you if you don't
close the statements you in fact will
cause a memory leak while the statements
themselves could have been garbage
collected but the resources that are
being allocated the database resources
would actually be still part of the VM
so you got to be really careful about
that so what are the typical symptoms of
leaks and I know that the typical one
that people get is out of memory and
there's obviously different kinds of out
of memory exceptions you can have a heap
out of memory heap exception or you can
have a perm gen exception
which most cases actually deals with
class loaders which is also very hard to
trace so that's one so if you get one
you know definitely have a memory
problem and what typically happens is is
then people would look at the stack
trace and say well which thread actually
reported the problem right and they
think well that's probably where you
know the memory leak is so the
diagnostic is typically looking at where
the the thread is reporting the problem
in most cases it's actually not the case
it's not where the memory leak is it
also could be not a leak at all right
you just not sighs do gvm appropriately
so if my des application goes into
database loads a billion rows and my JVM
is sized for a gig I'll probably blow
out that heap right you know in a few
seconds it's not really a leak it may be
a design flaw it may be a problem in the
sizing maybe you need to change your
application logic
so again leak I would use it either you
know you don't have it sized properly or
you have a problem in the in the
application now increasing GC activity
that's one of the others I mean if you
monitor for example garbage collection
activity and you see that the the
frequency and the timing of DGC
collections start to expand I would say
you don't even have to wait until you
hit a 90% or 99% hippo realization you
would probably you probably need to
start looking at you know looking at
your application a little closer and
obviously as a developer you know what
the workloads are so if you know your
application is sitting doing nothing and
suddenly you're getting these types of
problems the most usual answer is
probably have a leak right you may have
a background process or a background
thread that's keeping connections and
maybe it's just eating up resources so
the obvious you know you have you know
increasing heap usage was typically what
people do or you're not so obvious you
have the
other interesting leaks that are a
little more complicated to to
troubleshoot especially the classloader
leaks right when you deploy redeploy the
applications in the application server a
lot of times you get into these
classloader leaks so now imagine you
have a form of application service and
you've got all these variables what is
how do you typically try to figure out
if maybe one of them is at risk maybe
the other one is not if you have a
clustered environment you may have
copies of the same application running
across so you have a memory leak in one
you probably have a memory leak in all
of them right so you typically want to
be able to address those instead of try
to rip you know over-provision the app
right so instead of if your application
typically deals with 2gig space maybe
you want to give it six but now you're
wasting so many resources just trying to
mask a problem now again this is one of
the interesting ones because even if GC
activity picks up I think you also may
want to look at the workload they may be
changing the workload so interesting
things now the typical causes of leaks
now some of the simple some of them are
not and what I found a you know when
dealing with Java you end up with you
know a simple one like you stuffing
things into the array or a hash table
and maybe you're stuffing in an object
and you didn't overload the hash code
you know the hash code properly so when
you try to remove an object it's
actually maybe you're not removing the
same object or you're not cleaning it up
appropriately so as I mentioned also
JDBC connections I find a lot of leaks
have to do with just not properly
closing statements some of them are
actually buried in the drivers
themselves which becomes even tougher to
deal with right so you're using for
example some third-party drivers to
connect to a sequel server and Oracle
and that's leaking memory which is then
kind of you try to figure out well what
can I do about this ball you can detect
it and maybe you can somehow avoid that
problem but and then report it obviously
to the
also you may have bad JVM arguments
right this is one of the examples right
so that you need to look at as well and
outside of the parameters I talked about
that is typically had to do with things
like and then when we for example when I
you know developed a muttering solution
for Java I mean we looked at things like
not just the heap utilization but also
for example handles and threads and the
memory semaphores and things like that
so you want to be able to look at those
as well now a typical typical so this is
the typical causes of leaks and the the
interesting thing is and as I talked
about about specifically a class loader
here's an example which is actually very
difficult to deal with where you have an
old class loader that has a specific set
of classes and Static feels that they've
got has loaded with ki bholi typically
keeps it in the perm Gen pull and then
as you redeploy the application you
create a new class loader that creates a
new set of classes and then stuffs it in
the perm gen pull in fact we had an
example of that we developed a little
module that actually hooks into the
class loader and if you keep on creating
new class loaders you end up with the
with the leak and then your application
server falls over now you have people
obviously interacting and if you're not
watching them appropriately the
application server suddenly Falls and
then you taught a service now typical
remedies now the typical remedies I mean
most of the time I see people basically
increasing the heap size I say oh you
know 4 gig is not enough we need to have
an 8 gig now they end up to the 8 gig
it's not enough we got to go to whatever
16 gig typically what you'd find is
typical remedies you see I got
especially in Java I would say most of
the time it's a bug in the code
or if you're not properly sizing the
workload you just didn't properly size
the VM but most of the time if you have
a problem with the memory there's really
not much you can do other than fix the
code right I mean you can provision over
provision you can take it or maybe
offline maybe you can failover but
reality is if you're talking about a
remedy can I fix can it be automatically
fixed I would say probably not because
somebody's somewhere in not closing
statements is not closing files is not
you know stuffing stuff in the memory
maybe not properly designed application
where it reads the stuff from the
database as an example and just not
releasing it but we see most often times
it's really over provisioning is the
answer and then they wait until they
exhaust it and then maybe failover
and what we try and is and I'm gonna try
to show here is an early detection
system that will try to basically
attempt to do it automatically now what
that means is and I'm gonna show
examples of that it's not gonna give you
a hundred percent but what it will give
you is the probability of a leak in the
in a VM right with a very high degree of
probability say well these want this one
the other one is in fact is a candidate
for a memory leak and what allows it to
do why would you want to do that when
one is it gives you really the time to
buffer right and time to solve a problem
a time to diagnose the problem before
you actually you end up in a situation
when the Japanese you serve it just
falls over second thing is a lot of
times it's very difficult to replicate
the problem you know you may have let a
production environment where the
applications are running but it's very
difficult to replicate that problem in
dev so it would be actually quite nice
to be able to say well this application
server is not behaving properly maybe I
want to try to take it offline and
diagnose it while the problem is
actually occurring versus having to take
it down restart it and then task by
developers with actually trying to
replicate that problem that
times actually takes a long time to do I
mean I found for example I work with the
team of developers that replicating
problems are typically very difficult
especially in highly concurrent
environments with many users I mean how
do you replicate the problem where you
have a thousand users connected and you
have all kinds of things going on at the
same time so a lot of times just the
load is difficult to replicate I mean
you may be using some you know software
you know for trying to replicate load
but it's still not the same thing as
real users doing real things on your in
your environment so I'd rather look at
my form of application service I'm gonna
say well this application service may
have a problem
I want to baby isolated take it offline
and give him what my developers to
actually diagnose the problem while it's
happening and really avoids the crisis
situation right now if you're over
provisioning you can do failover this
that's great but you know many times you
have maybe one or two instances and you
have a problem if you have a clustered
application the problem is in all of
those right so you've just take one
offline but it actually is you know it
still existed my other instance so it
doesn't really solve the problem but I
want to be able to avoid the you know
the crisis situation I don't want end
users calling me and telling me hey you
know I just submit an order and I'm
sitting timing out and why because my
application server is stuck on a you
know in GC and it's paused right you
can't process anything because the VM is
stuck so unfortunately not not a real
good fix other than trying to do some
diagnostics and preventive actions and
still has to really go back to
development to try to figure out why and
we're trying to basically help that
process and reduce that process also
very interesting for example I would
call it aggressive leaks a term I call
aggressively now an aggressive leak is I
mean one of the things if you look at
the and we're gonna look go and look at
the chart patterns you're gonna find
that any league has a certain trajectory
but aggressive leaks a very have a very
obvious one right
start it up and in a matter of minutes
or a few minutes you're gonna see that
you know spike and it's good if you're
watching it it's great but if you're
kind of not watching it then you know
you're not even you don't even know that
there's a problem
so restarting the VMS could be a
solution but if you have an aggressive
problem restarting doesn't really help
you right because after a few minutes it
falls over so we're going to talk a bit
about leak detection and one of the
interesting concepts I mean and the way
I looked at the problem I myself is one
of the things I do you know kind of on
the side is if I kind of might think of
it as my my hobbies I do technical you
know chart analysis related to stocks
and I'm sure many of you do as well you
know you trade stocks and you look at
the charts and you say well this is uh
you know the stock is going you know
high and this is good I want to buy that
or the stock is going low I want to sell
that so I do a lot of the technical
chart analysis and then I say well this
is interesting because it really applies
to the resource consumption because it's
really a supply and demand equation
right you have a limited supply of stock
as an example and there is people that
want to buy it and at some point the
supply and demand equation meets with
resources kind of very similar right you
have a limited supply of virtual memory
or memory and you have demand
applications are coming in and kind of
trading that right they buying certain
you know they or they take on some
memory and then then well they don't
they don't need it they release it back
into the pool right so if that balance
is out of whack what you're gonna have
is you're gonna have a chart pattern
which we're gonna show is kind of like
this right it's good when you have a
stock right it's going here you because
you're making money right you're making
money you're very happy when you look at
VM usage you're not that happy right
it's just a little bit opposite but
reality is you take the labels and then
you put different labels and the story
is the same right that story is very
much
the same so here's an example of a VM
heap usage and it's kind of you're gonna
see that VMs if you monitor for example
a C C++ applications you're gonna see a
very fluid memory graph right why
because the memories created or
allocated and D allocated by the
application and you don't get these
jumps well the reason why you get this
jumps typically is because you have a
you know a buffering of the memory and
then the GC kicks in and then releases
it right so you have these you know kind
of spikes so clearly this kind of a
pattern is very much steady even though
you see ups and downs ups and downs ups
and downs the theme is a fairly steady
trend line right versus here the trend
line here is actually accelerating so
what you want to do is basically trying
to look for these trend lines and we're
gonna look a little more further now
this is what I would call a resource
accumulation very much like in a stock
you have an accumulation you know people
are coming up and buying you have you
know rise in the stock price so now if I
change the labels completely I have the
same really equation here I'm looking at
GC duration and I can put that chart up
and I can say well it really follows the
same pattern right if I if my GC
duration is fairly low I don't really
need to worry about anything other than
maybe if it's too low maybe there's no
activity on the application server maybe
that's something I need to worry about
right but those are those are not that
not would be wouldn't be an indicative
of a problem in memory this could be an
indication of a workload right I have an
expansion in the workload which doesn't
necessarily tell me there is a leak but
it tells me that there is an increase in
activity right and if I have post times
that are increasing I know that my
performance is going to be degrading and
I don't want that and again same pattern
if my GC activity or GC duration is
fairly constant then it's not really an
issue right so looking at simply chart
it really becomes obvious because I can
look at anything whether it's a CPU
memory and leaks and figure out if I
have a problem or not one of the
interesting ones I actually have a phone
I just got a new phone and I was saying
well you know and yesterday my battery
started dying so I was saying well can I
apply that same concept to batteries and
I thought probably not because batteries
you really get always skip that you
always really get a line down right it's
not really I've never seen the phone
that every time you talk it really goes
up like this right it's kind of a
depleting resource so it always goes
down until there is a recharge so it's
interesting because some of these
resources are kind of I would say
perishable and some of them are non
perishable so this is method really for
non perishable resources right things
that are could be cleaned and reclaimed
and given back but if you have a
perishable resource you know I don't
need to be a scientist I know the line
will be down and that's the expectation
so you want to also look at that are you
looking at the resources that are kind
of perishable or these are non
perishable resources so anyway let's
dive in a little deeper into one of
these I would say one of these things
and expand it a little bit and what you
find is when I looked at most of the
leaks I mean you can obviously have a
lot of noise going on right you can have
ups and downs and all kinds of things
going on but in realities if your
abstract it you're gonna have a pattern
that's very obvious you have a trend
line up you have a channel and then you
have higher lows and higher highs so if
I'm looking at 100% you know if I'm
looking at let's say VM form of you know
let's say can application service
whatever the number may be I really need
to look at this type of a pattern right
you have a high a lot highs I mean high
highs and higher lows an example if I
have higher lows but no highs I don't
really care because I'm not gonna really
blow
my heap space right so if my hi here
some ways at a hundred percent but I
never end up in the high highs it
doesn't matter I mean it may be a
behavior of my application or workload
but it's not really gonna get me in
trouble so this leg up will be my memory
allocations when you create your
statements and you create your objects
and this will be a leg down which is
basically a GC activity but at the end
if I look at the span of let's say hours
I really need to see that kind of a
pattern before I start to to to say hey
I have a problem oh here's an
interesting the other one which is an
interesting pattern which is you have
steady lows which is it basically goes
our kids but then you have higher highs
which could present a problem but I
wouldn't call it a leaking or a memory
leak why because I would call it a
workload expansion now I can be the
application server might be taken on
more work but all of the memory that
it's doing is actually reclaimed back
right so yes it could get you in trouble
where I can hit a hundred percent but
that's to me more of a sizing issue
rather than the leaking problem so and
there are other variations like that the
concept is again going back here is that
for for me to be able to detect without
looking at the VMS without having myself
being glued to a screen and saying hey
is this VM you know having a problem or
not I really need to wait to automate
this process right I need to number one
is look at resource allocations whether
you're talking about CPU memory or
basically anything any non-perishable
resource that you're looking at whether
it's from VM perspective or from the
operating system perspective right if
I'm just monitoring a process and all I
want to know does it follow this pattern
I should be able to look at it
understand it and write a program so to
speak right right some kind of a
automated process that would be able to
actually collect the data from a variety
of different places and it's actually
with
overhead right I don't need I don't need
you know special
you know instrumentation to do that
anybody who has some jamek some basic
programming you can probably hook up to
you know a VM any VM remotely and start
sampling activity and try to figure that
out
so it doesn't really take you no special
skills to collect the data so let's go
back but it does take a method or
methodology in order to actually detect
it so here's an example now we're trying
to say okay so we know what kind of
pattern we were looking for now by
induction we kind of say well if we know
how to detect in one we should be able
to you know very quickly to devise how
we detect in many right so here's I have
a bunch of vm's and even though they're
not scaled appropriately but I have
different performance characteristics if
I build kind of a chart for each one and
I what I call a determined detection
model for a single VM and then I
implemented across I should be able to
automatically detect the problems right
I should be basically go to a point
where I get an email if I'm let's say an
application supporter or a developer and
I'm tasked with supporting an
application that's running in production
I don't want to be kind of waking up at
4 o'clock in the morning maybe and have
a you know a wake up call saying hey we
have a fire you know if crisis situation
go figure it out I want to have a more
proactive way to be able to come in
avoid the crisis knowing that I have a
problem on the application server and
then really try to figure out what to do
about it
so use use this method for one apply the
model across multiple VMs you can
monitor and I would obviously my
recommendation is monitor perimeter
operating system perimeter but also
within the JVM itself and then try to
actually correlate the two and one of
the interesting things is every resource
has a different
you know measuring measurement right you
have heap measured in megabytes
gigabytes CPU measure didn't person in
percentages so I want to be able to
normalize all this I don't really want
to even know what it is so one of the
things what we've done is applied what
we call a momentum oscillator we're
going to talk about what a momentum
oscillator is but momentum oscillator
basically allows you to apply kind of a
little bit of mathematics not a not
anything complex but say I don't care
exactly what it is if my hassle later is
showing me a problem I know that I need
to pay attention right I don't I don't
care if you're talking about gigabytes a
CPU memory or anything like that so
building that model allows it to
basically build an index kind of a
resource index and what I'm gonna go
into that end up in a minute
so the concept or kind of the vision
here is I have a farm of VMs I have that
index that basically tells me I have a
problem I don't have a problem and then
I typically get a notification when in
fact there is and telling me exactly
which VM then I use my Diagnostics tools
to figure out what the problem is right
so this is not gonna tell me hey you
you're not closing your JDBC statements
this is gonna tell me this is the
problem now get your developers or
whoever understands this application get
them to use whatever tools they need to
now diagnose the problem so let's look a
little deeper into the into the
mechanics of that now the oscillator now
it's going to look very similar but the
concept of the oscillator is that no
matter what it is that you're monitoring
it's gonna compress it and really
provide a metric that is fairly
consistent across so you got an
oscillator that goes from 0 to 100 and
it goes up and down up and down or up I
mean it depends on exactly what how your
resources are allocated but the bottom
line is you want to stay around 50 right
this means that and the way that
oscillator works is basically it
measures this
speed of advances and declines in the
underlying metric whatever it is that we
muttering could be you know heap could
be CPU memory handles threads whatever
and trying to figure out if in fact we
the advances outpaced declines or they
in fact even and the speed of those
advances and declines so in a sense I
could apply this to garbage collection
duration CPU memory and this index will
tell me whether I need to pay attention
or not
so here's an example if you're right
here it's not a question you do have a
problem anytime you staying over 50 for
prolonged period of time you will
exhaust your resource it's a matter of 1
it's not a matter of if if you are on
this side that means the application
server is morale is actually decreasing
memory and you're gonna oscillate around
this axis as soon as you start going
above that and stay there you typically
have a problem and there's certain
certain levels that we typically choose
one of the ones we use is for example
level 6070 typically you never get to
100 I mean if you do that means there
was never a garbage collection ever all
of the advances were never followed by
any declines which is very difficult to
kind of foresee in the application
server so if you're at this level I
would never see the probably that either
because all it means is there was never
any allocations there was always the
allocations which is not practical right
you're not going to see that so you're
typically gonna find yourself here and
then if you have a memory leak you're
gonna be somewhere over here now some
note here was actually the developed
this formula developed I'm gonna show
you an example of the format it's not
complicated at all how it's actually
used but this is an example of an
oscillator so instead of monitoring heap
size I'm actually gonna be looking at
take the heap size feed it through the
oscillator and then I'm gonna set my
thresholds on the oscillator now one of
the maybe questions could be well why
can't I just said a you know a threshold
on the heap size I'm gonna say if I'm up
90% I get an alert well you could do
that but you're gonna get a lot of false
positives well possibly you're gonna get
full positive why because here's an
example I'm gonna go back a little bit
here here's the VM that's oscillating in
the 90% so it goes up hits the 19 goes
down up 90 it goes down every time
you're gonna touch it exceed 90 you're
gonna get an alert are you gonna get a
problem not a situation you want to be
in I want to be able to abstract it out
and I want to be able to look at the
advances and declines and smooth it out
that's why the oscillator is it better
is a better concept it's a better
approach and we used it actually quite
successfully and we have you know our
own applications and these applications
get installed at the customer and then
they call when they say well you know we
believe you have a memory leak well yes
let's look at the oscillators let's look
at what they tell us maybe it's a sizing
issue it's not really a memory issue now
building on top of that this what I
would call a steady-state so you want to
be around here is now that you're doing
it for one what's interesting is you can
then have oscillators built on top of
oscillators right if all of my
oscillators are trending higher if my
oscillator in fact the top one is
watching the other oscillators there in
fact start trending higher so here's an
example where multiple VMs produce that
index which I would call an oscillator
right it goes zero 50 I mean I would say
30 50 goes up and down and I feed it
through this function and that becomes
an input in my top oscillator so that's
my top level index what it telling me if
my index of combined index is in fact
around this mark it tells me that the
combined
resource allocation is in fact normal
now this in itself could be out of out
of resources which I'll get an alert but
as a combined VM farm it's in fact in a
steady state I give you an example let's
say this loses one gig in in in memory
this gains one gig the net net is zero
as an example this oscillator on top
will show me a steady state while maybe
this oscillator will actually give me a
warning right so so you got to keep in
mind that if I want to build a kind of a
composite index here of my resource
activity I can do that now you can do a
little more something more sophisticated
where you can actually feed multiple
resource indices right you can have a
memory index storage index and maybe
some other index and what it really
allows you to do that and then you can
weigh them appropriately then you can
develop kind of a top level index that
tells you what is the resource
consumption actually looks like across
multiple VMs and this kind of a
mathematical model I mean to me is a lot
more I guess appropriate and I like that
model versus constantly hunting down for
you know and trying to figure out this
and you know I have a problem with you
know heap or or anything like that and I
gave it a kind of a name CRI
yeah kind of a combined resource index
right because I can apply it pretty much
to anything I want so let's let's move a
little further social some example some
calculations I mean this is not
complicated stuff I mean this is fairly
simple stuff so here's the way it's
calculated I mean you take the number of
past samples and you take the
exponential moving average and of gains
divided by declines over x period of
samples now if you want to simplify it a
little bit you can do a simple moving
average exponential moving average is a
little more complex to compute as you
can see for example here the there's a
division by zero possible in this case
if this is a division by zero what it
basically means
there's absolutely no declines results
always advances that makes are as pretty
much equal to or makes the RSI by
definition is a hundred so the only way
you can get to 100 is when there's
absolutely no declines so that's I would
use that as a simple formula to actually
detect that I mean to to apply that so
the only thing really need to do is
collect the data collect the or sample
the data build a kind of a history of
your samples fit it through this formula
get your get your oscillator and and
then feed it through other oscillators
if you need to right now there are other
oscillators that you can use and I
suggest if you want to you know read up
on that you can just do a search in
momentum oscillators they're used very
extensively in technical analysis when
you do charts and you're trying to
understand whether the stocks are or
they buy or sell it's a similar concept
let's look a little further here's an
example there's a real example actually
here's an example where we're looking at
an automated leak detection where we're
looking at a hip utilization at 41 while
the index the oscillator is over 60 this
is precisely what is happening in the
leaking VM
right so setting up a threshold at 90
gives you absolutely no warning right so
here's an example my VM in fact I have
maybe VM instances let's say this Web
Store application servers would be
WebLogic whatever right there running
here's the heap utilization look at
these this runs at 93% 68 and 86 none of
them are having a problem however this
VM that's running only at 41 the
oscillator is telling me that you need
to pay attention to that VM it's not
behaving the way that you would expect
it to behave
and you start actually looking into this
virtual machine before it reaches 93 and
you get your you know famous out of
memory exception right so it's a and I
mean it's interesting because you could
look at this pattern say well that's
obvious right I mean I can look at this
pattern and say you have a problem the
basic principle behind it is I don't
want to be looking at this charts I
don't want to be sitting there hooking
up my performance moderate is and
looking at these charts all day long
right I want it to be doing
automatically so that's a that's a
perfect example and then you can do
diagnostics I mean this is one of the
tools we built but the Diagnostics is
well now that I have a problem let me go
in and look at where the problem is
while I look at my top 10 here's my you
know here's my you know 27 megabytes and
depending on how you sizes well let me
look at you know what's going on and you
could see that hey my GC impact is sones
so forth and is this is where I spend
time so the diagnostic is really
secondary part right now I'm gonna point
you to the place where you have a
problem use whatever diagnostic tool you
have in order to figure that out right
whether it's a you know you do a heap
dump you know a feed it through some
tool and try to understand what the heap
structure looks like but otherwise it's
really up to you so in summary I think
we're in about 10 15 minutes right what
I try to put together here is kind of a
method for you know I'm kind of lazy I
you know I don't want to be sitting
there with you know charts and looking
at them I want to have my system that's
gonna be out there looking at the farms
of VMs or operating systems or whatever
it is that you care about feed it
through some mathematical mathematical
model and I want to look at that one
number and then the other thing I want
to be able to do is I want to be able to
say hey if my oscillator is greater than
60 and stays there for five minutes or
10 minutes let me know and then tell me
exactly which VM I need to pay attention
to that's that's really the concept
right right is I want
I want to have the system do all the
heavy lifting and I want to have a very
high degree of probability that when I
look at that VM I'm most likely gonna
find a problem right and I have my
developers actually look at that the
biggest thing is again I want to be able
to avoid downtime and I don't wanna or
over-provision I'd rather have this
problem fixed rather than expanding my
heap sizes until you know I blow out my
you know memory and an order maybe more
service space and then usually whatever
Diagnostics tools you have to diagnose
the problem so that's the basics of of
you know my detection model now you can
go do a search and you know look at
other momentum oscillators there are
other very interesting momentum
oscillators you can use to and there are
other you know they're not fairly common
you know they're not complicated and you
can apply them in your own you know in
your own practice thank you for your
attention if you have any questions let
me know
is there a question oh you can come
often
yeah as I mentioned we're you know I'm
part of the company that actually
provides the monitoring solutions
performance monitoring solution so one
of the things we've done is we actually
implemented that approach along with
other indicators I mean this is one of
the indicators but that's one of the
things that we do meaning proactively
looking at VMs dotnet whatever we have a
variety of different technology with
support and then figuring out if the
patterns of behavior are in fact
abnormal meaning abnormal to a point
where you need to look at that we also
provide some Diagnostics to get into
that as well so it's a it's a kind of a
dual thing you could go and build it
yourself or we have a product that
actually does it out of the box all you
have to do is hook it up to your VMs and
will tell you which VM you need to look
at and when you can use it with whatever
Diagnostics tools that you have it's a
completely independent outside watch's
activity no overhead at all or very
little overhead whatever it takes to
sample GC and memory are the VM and then
tell you you know what the oscillators
are what those indicators are and alert
you when you have a problem so that that
is you know it's already been
implemented it works and you know
customers use it for this specific
purpose yes
yeah so the the question was is it only
from VM perspective and the answer is no
it's not is as an example of how to use
it in VM but it's actually any metric I
mean you could use it from OS you could
use it for storage you could use it
pretty much anything again for any
resource that's not as I said it's not
perishable right like a battery I mean
you can also do it in the back a matter
it's just not that useful right because
you know it's always down right all you
know I don't need to be
I don't need heuristic to figure that
out anything that's a little more
chaotic where you don't know exactly
what the outcome would be I want to be
able to apply this method so that I know
when I have a problem when I need to
look so this is not specific to Java
even though we do have hooks at the Java
could be used and it's used in Java
could be used for dotnet anything that
uses resources I mean I am I the the guy
will get yeah so let me see what okay
what is that what I don't know what this
I can called there I can't pronounce
this name though cell soft sell soft
sell soft
well sorry alright here we should lose
I'm gonna close my Navis who's that
yeah Michael Michael Wiggins no
congratulations</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>