<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Putting the Metaobject Protocol to Work: Nashorn's Java Bindings | Coder Coacher - Coaching Coders</title><meta content="Putting the Metaobject Protocol to Work: Nashorn's Java Bindings - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Putting the Metaobject Protocol to Work: Nashorn's Java Bindings</b></h2><h5 class="post__date">2013-02-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/UIv86fUSORM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">right hi everybody my name is Achilles
jaggedy i'm currently with oracle as a
principal member of technical staff in
the Java language and tools group
primarily working on NASA for these days
and this is the concluding talk in the
series of talks on various things
related to nass horn at this job on
conference and it will be dealing with
how are we actually leveraging invoke
dynamic and how are we using it to
implement higher level operations on
JavaScript object and how we are how we
are also linking to java objects as well
you're right all right okay so we'll be
talking a little bit about what invoke
dynamic is I will talk about about I
will talk about the diner link which is
a higher level dynamic linking framework
on the JVM that I develop and I will
talk specifically about how did we
integrate Dino link into NASA for this
talk is primarily of interest to people
that either implement a language runtime
on the JVM quick show of hands who's
doing that right and alternatively to
people who are interested in how it's
done which is hopefully the rest of you
all right so what's your vogue dynamic
and how did we actually managed to
implement dynamic languages before we
had it what we did is that in a
hypothetical situation and I'll have
some code I'll have some code on the
slide so if you don't see it well you're
welcome to move forward we had this
hypothetical situation where you have a
dynamic language expression where you
need to print the color of an object you
want to retrieve our property so for
instance back in the days in st. rhino
you would have a static helper named get
property pass the object 20 pass the
name of the property that you want and
this guy's compiled roughly to this
sequence of byte code which
well the object load the string invoke
the static method all right so that's
what we had now the get property itself
might be implemented something like this
where you are doing a lot of things but
most notably you end up invoking a get
method on an object with their third
start parameter for various prototype
resolutions and whatnot and for instance
for a native scripting object this might
end up being a retrieval of a slot or
some nap so JavaScript objects are
basically just associative dictionaries
so they look like a map and they walk
like a map so they are pretty much a map
and if you have an integration with the
Java object you might have a wrapper
around the Java object where you would
do some reflective discovery of your of
your of your Gator maybe a field maybe a
metal name get something and then you
invoke it and this invocation then is
again reflective so what's the problem
with this approach the problem is that
you end up with mega morphic code paths
there's no way to optimize for that so
every reflective method invocation to
java will go through this code
regardless of what class that is there's
no way for hotspot to optimize this
thing it defeats in lining every other
optimization all right so how does
invoke dynamic changes things for us now
instead of being now instead of having
to go to any kind of a helper you can
just use your invoke dynamic instruction
and you can you can specify your pray
your operation here which is a get the
property named color on something that's
an object and and I will get back an
object especially in a highly dynamic
language like a JavaScript you have no
idea what will you get back and what
you're passing so your signatures
usually end up quite generic if your
language is such that you have you can
infirm types at compilation time this
might be more specific but generally
these are not the case and you also need
to use something that's named
bootstrap method which if you ever heard
a talk about metal handles and invoke
dynamic you know what it is want to go
too deeply into it basically it's a
method that returns you something called
something named the call site which is
the runtime reification of that
particular invoke dynamic instruction
and it tells the virtual machine that
hey okay at this point I will return you
an object that is a holder for a
function pointer as I said the call site
it holds a metal handle metal handles
are basically anonymous function
pointers except that they're safe and
the hood slag metal needs to return a
call site that somehow bound to a metal
handle and when the jvm invokes gets to
the execution to the point where this
invoke dynamic instruction is it will
invoke whatever method is currently
linked it into that call site some call
sites are immutable when you create it
you link it to a metal handle and it
always stays linked to that one and you
also have an j the java platform
provides you mutable call sites that you
can change the linkage to them any
number of times and these are the really
interesting ones for us the difference
between metal handles and reflective
methods in case you wonder is that
reflective metals they always correspond
12 12 a java method so if you have a
method foo on a class you can take a
reflective method to that you can get a
reflective shin metal object that
represents that method on the other hand
method handles our genre just said in a
another top preceding mind they are
functional programming basically on the
JDM because they can combine them you
can you can build combinations of them
there are basically if statements you
can do folding binding of arguments
permutation of arguments all other kinds
of things and the nice thing about them
they can get in line and they are not
mega more fixed so we suppose it we get
a much better performance than using the
previous approach so uh as think Charlie
Nutter said ones that invoke dynamic is
neither invoke no
hammock and that's true it's really a
way for applications to govern their own
linkage so if you have a call site
normally normal JVM linking rules with
the instructions invoke virtual and book
well mostly mocha virtually invoke
interface they will specify I want this
call to link to a call in this class
method name this with a signature dish
and there is a whole set of rules in the
JVM specification that tells you how the
how will the JVM find the target class
doing virtual dispatch if it needs to
find the target class find the method in
it and and and and call call into it
obviously a linkage happens there as
well invoke dynamic is basically a way
for applications to use any linkage they
want they can govern their own linkage
they can specify that at this point in a
call I want to determine what method
gets called alright small digression is
let's consider what is a property on an
object here we have two examples i will
probably going with this object color
example for the most of the talk it's
very simple to understand and it's it
demonstrates most of the concerts so you
can have a class that has a public field
right you can consider that the public
field is something that can reasonably
be expected to be addressed when you say
object of color right or you can have a
class that has a private field and has a
metal name get color that corresponds to
the to the beans proper to ghetto naming
conventions or you can even have
something completely wild as a class
that implements something in implements
a marker interface unconventional api
that will tell it that hey i will be
using some completely different naming
scheme for my methods and maybe it will
using get underscore and no
capitalization and again it it should
still when you say object of color the
run
times should still be able to somehow
figure this out so on and what if you
have crazy code like this where you take
an array that has an instance of the
first class with a public field another
class with a beam getter and a third
class with the unconventional getter and
then you and then you run in a loop and
you want to retrieve the color property
on all of them right so on your loop
body while it gets compiled to is and we
want to concentrate on this line there
is some other things as in you can
dynamically invoke the print line
function and you have a dynamic
invocation did a dynamic retrieval of
the index element of a collection as
well but hear this call site it needs to
be linked to three different gators it
needs to be able to dispatch the three
different getters as those objects are
encountered transparently oh yeah
something about the println if it's
actually on and if it's actually an
instance of function that goes back to a
prince tree in println probably one
retrieve that system out then which
overload of println does need to be
invoked here right or what happens we
want to invoke a variable argument
function here's the thing invoke dynamic
does not give you these kinds of
high-level operations invoke dynamic
only gives you the ability to specify
what method do you want to to wink but
it doesn't help you with actually
finding the appropriate method that you
want to link in a particular situation
so if you have any of these questions
for you implement your language runtime
how do you get or set properties on an
object how do you evoke a function how
do you retrieve elements how do you
invoke a constructor then these are all
things that invoke dynamic as such on
its own won't help you with or again you
need to retarget your call site for a
previously unseen kind of object and you
have all scenarios from multiple
dispatch Java
reloaded methods are a prime example of
a multiple dispatch so yes when you are
implementing your language runtime you
will have a bootstrap method and it's
great that the JVM gives you an ability
to write a bootstrap method that will
decide what gets linked into your call
site but what do you put in it anyway
right what is it that you will actually
put into your entire bootstrap method so
this higher level operation this is what
we normally refer to as a metal object
protocol so all these high-level kind of
operations getting a property setting a
property everything that they had on two
slides before invoke dynamic is not a
metal object protocol it stops short of
being a metal object protocol it is
however a very good low-level
infrastructure for actually building one
this is rodinah Lincoln same dyno link
is an open source library that started
development before i joined oracle and
that i keep developing with the same
conditions apache license independently
open source after i joined oracle and
dino link nass horn uses dyna link for
all of its dynamic linkage right now
both routes own objects and to java
objects it is basically a library that
that gives you that what goes here part
in your boots thread methods and it's
already ships with a linker for playing
java objects in general and it because
every javian language will want this
maybe not but it's hard to imagine a
language running on the JVM wanting to
benefit from the JVM ecosystem from the
class libraries that you have there that
will not want to have integration with
plain java objects ability to call them
manipulate them handle them and this
library basically solves all these
problems for you so the question what do
I put in my bootstrap method the answer
if you use Dino link is you have
something called the dynamic linker
factory which you used to create a
linker and afterwards you do
have this dynamic linker and this
actually looks a little bit scary but
all it is is in your you get your linker
you invoke its link method you create a
call site which can be any cool site
really we ship with something that's
called the chained call site which does
a really good caching of it's basically
a polymorphic inline caches such and and
this is some administrivia that you
don't really need to worry about right
now it is at the end of the day this is
a single statement that's that's the
that's all that's all you need at this
point what it does is it will take your
call site and it will link it to a
special method handle that does nothing
at all it does not know at this point
what needs to be invoked it will link to
a to a special metal handle that when
it's involved with actual arguments if
you know how to relink the call site for
those actual arguments so going back to
our example with the be getting the
property color from three different from
three different classes with three
different conventions for for how is
something named colored coming down then
what dino link does is it has a way to
discover different linkers that are
available in the class bus it's actually
using the meta in services mechanism
where the various jar files with
language runtimes can declare that hey i
have a linker for my language so ideally
you will have if you're using javascript
mass horn you will have an asshole
linker and then you will have something
for that unconventional api which knows
how to retrieve a get underscore color
when it's when you require a color from
it and you also have a beans linker
which is something that that is part of
dining that's the fallback linker that
he that you normally include and when
any other linker don't doesn't know how
to handle an object then you just fall
back to the beans linker and it just
gets treated as a poacher so when get
prop color gets invoked on a class 3
which was this unconventional API and
commercial linker would say hey I know
what to do with this guy and it will
return back a method hand
that's a composition of a test saying as
long as it's basically a guard that
determines the validity of the of the of
the operation it says as long as what
you will be passing here is an instance
of class three this is what you need to
do so this is a pair of metal handles
one is a one returns a boolean which is
a test for the validity of the operation
and the other is the actual operation
and then the call site sorry question
you would use instance of class three
because you need to cast the class three
because you don't have a method get'
underscore color on the unconventional
API imagine it as just being a marker
unconventional if you are publishing
classes you have a language runtime and
it creates a classes that that conform
to some kind of an metal object protocol
some kind of an object model that is not
the exact Java object model right then
you need to have your linker but usually
can have one linker for every class
that's published by your runtime because
it your runtime would normally just
follow a single non-standard object
model if your language runtime is just
following the standard object mode you
don't even need any of this because then
beans beans linker has you covered all
right what then happens is that the call
site itself will take these two and it
will compose them into a so-called guard
with test method handle which says if
this is true then do this if this is
false then go back and real income on
the next iteration of the loop you might
get an instance of class one I know this
is not the same ordering that I was
using in the in the original I had class
1 class to class 3 there but you get the
idea so in that case inquire for class 1
there is no specific link
so what we get is yes as long as the
enemy's linker will say as long as what
time passed is actually off class class1
and notice there's not actually instance
off I will cast it and i will return the
field the reason we could use instance
off in the previous example is that we
were invoking a method with no arguments
which cannot be over which cannot be
overridden in this in a subclass well
even if it is it's not about overriding
even if it is you get virtual dispatched
to the override but you cannot
overloaded it variable arity but if you
are going to a field then you need to
have exact class matching so what
happens in the next step is that we had
this part and now the call site will
again recompose it into this cascading
set of tests saying all right if what I
got is of class want and I will invoke
this if I didn't I'll see whether I get
across three then I will invoke this
otherwise again go Andrew link and then
or third iteration you get the idea this
will also be handled by being Slinker
and it will say okay the class to it
doesn't have a public field but it does
have a conforming beans conforming
getter I will return you recite for
linking saying as long as what you get
is instance of class to cast it to that
invoke the get color function and then
it again gets linked as a cascade so at
this point your call site is actually
linked into one two three four five six
seven method handles that are composed
into these nested if blocks which in
metal tender parallels we call the guard
with test Combinator so this is in a
nutshell this is how it works that's not
a question the question was how well is
that in line the answer is none of my
business really that's that that's an
excellent question to be asked from the
the JVM compiler people yeah so what
properties do do do we do we support
sorry what operations do we support
right now we have appropriate together a
property setter and operation for
getting
and setting elements of a container
which are typically raised with some
apps directly invoking the name method
on an object invoking something that has
serves as a constructor if we have a
first class function object and we can
just call it and honestly we can just
expand the list of these operations as
we need because they are just string
constants in invoke dynamic instructions
and there is not even any kind of fun
Java interface or anything it can
confirm with so expanding the set of
these operations is is easy we will be
adding as we identified the need for
them probably in the near future we'll
we'll add support for iterations for
iteration over a container element's
properties and so on and there is also
an interesting thing that I just
recently did which is a support for
so-called combined operations so in a
single invoke dynamic call you can say I
want to retrieve either an elementary
property this comes into play when you
have a language like Java Script in
which basic and object dot foo is
property accessor but javascript doesn't
have a separate namespace for four
properties and four elements of a
container so if you may be addressing a
java.util.map when you say map dot empty
are you now addressing the is empty
property together or do I actually
trying to retrieve an element of the map
with the key empty right and by letting
the language runtimes specify that at a
particular call site you can request
more than one operation and it's the job
of the linker to figure out which one is
appropriate at that point you can
resolve these ambiguities in JavaScript
you can do that if if you're using the
dot operator then we will ask for a
composite operation of get property that
then get elemental there is no such
property and if you're using the square
bracket notation then you can say get
element if there's no element then get
the property and that that resolves most
of the ambiguity as I said we have a
bean Slinker which is before back linker
for everything that's not recognized by
the linker and it provides your element
access for arrays lists and maps full
method field and property access and
Java objects and on on and on special
objects that are exposed as this static
I call it the static facet of the
application I'm not using the
java.lang.class object as the static
facet of the application rather we have
a separate representation for something
that can be invoked as a constructor and
that exposed the static methods
completely handles all the overloads and
variably arity methods these are not
previously hard to get right so this I
usually pitch this as the as the as the
biggest selling point of the library
normally if you have your own language
runtime you will need to write a linker
there is an interface for that it's
named guarding dynamic linker it's a
long name but it's it's guarding because
you normally specify two linkages two
methods in a linkage a guard and a
actual method as I show you and it's
dynamic because it runs very late in the
invocation process basically it runs for
the first time a particular invoked
dynamic instruction is in is called with
that object type ad that cause site not
had not yet having been seen and well
duh it's a linker you will just need to
work with so you need to implement this
interface you will need to return
instances of this type named The
Guardian invocation which has the
invocation and the garden and those are
switch point which you can use for
asynchronous invalidation of the call
sites which is sometimes a nice thing to
do because we can get more optimal
linkages and Andrew and whenever you are
invoked you will have to deal with with
an object of the type link request which
would describe for you what's the name
of the operation at the call site what
are the types there and what actual
arguments did you receive at the
invocation so so your linker is invoked
it clicks in at the first invocation so
you do have the actual arguments that
that the function that the method at the
at the call site is being invoked with
at that point there is an important
distinction between a linker and a co
site linkers produce the guard and
invocation metal handles they don't
compose them into this guard with tests
so they are returning a pair of metal
handles back to the underlying machinery
and eventually the call site itself
receives them and it decides how to
compose them we can I showed you the
chain call site will do this chaining of
guard with tests basically this cascade
but you can have a really simplistic one
which was we just just always installs
the latest one that it got Andrea links
in every other case that that pretty
much gives you a monomorphic in line
cash at that point this is this is the
right design because linker decides what
is linked and the course I decides how
it's linked and since the course site
over resides in the code that you've
generated in your language runtime you
always control how it is linked but you
might need to link to you know a POJO or
something so you don't know what needs
to be linked but still in your target
language one time where you omit the co
sites you get to decide how it is linked
we support all the method invocation
conversions as specified by the JLS if
your language has additional conversions
there's again there's a place to plug
those in in the framework as well you
can have your type converter factories
which produce again usually guard with
test converter saying hey as long as I
got an instance of my my special object
and it needs to be converted to string
because my language in its infinite
wisdom actually supports conversion of
arbitrary objects the strings then then
here's a metal handle that does it and
you will also need another interesting
level interface which we know called the
conversion comparator which we had to
add because at least with NASA on I mean
javascript is such a good proving ground
because it's the most highly dynamic
language you can imagine so on you
pretty much have an implicit conversion
from anything to everything right and so
we were running into as soon as we
started allowing more type
versions we started running into very
wide ambiguities when you had to choose
and overloaded the method among several
overloads when you are linking to a to a
POJO overloaded method set and for that
we introduced conversion comparator
which can which can augment the the Java
language specification overload
resolution rules to make sure that you
can still still still the it basically
compensates for your ambiguity in
allowing more type conversions yeah it's
not important so in summary dinah link
we use it in a sworn there is quite wide
interest to be used in other projects
within Oracle as well where languages
are being implemented it's Apache
License open stores you can get it at
this URL I'm publishing binaries to
maven central repository and publishing
snapshots as I go so you can always just
grab it and use it which brings us to
the final topic as in how do we use Dino
link in a swarm so in short nASA uses
Dino link for all of its dynamic linking
that's that's the way this library is
intended to be used you don't have a
separate code pass for your native
objects and they say oh and I will just
use dynamic for everything else rather
you just go to die knowing for
everything with that get some
interesting use cases that came up first
one was that yeah remember that slide
when I told you what comes in here and I
told you that oh yeah you can just do a
new dynamic linker factory and you can
create a linker and off to the races
well if you have your own language this
gets a little bit more complicated so
you will do your you instantiate your
factory but you will then be setting
several linkers in it and as you can see
there's this nice method saying set
prioritize linkers have fallback linkers
prioritize linkers are an asshole linker
and the National primitive linker wait
we need to yes we do I'll explain
they're also fallback linkers which I
told you that when you normally cannot
link
anything you don't know how to link it
then you just fall back to a beam
Slinker however we also ended up having
a nice one button winker so instead you
would expect that normally in a language
one time we will have a linker for the
language runtime and a fallback to a
beam slink away end up with two others
and this seems to be a pattern that will
probably valid for for for many other
languages too and then you create a
linker and then yes you're off to races
so so many linkers right what do they do
the Nazca linker links our script object
which is a napster class that all the
nass for javascript classes subclass
from it also links undefined which is a
special value type in javascript that
that specify a value that was not
defined that's from primitive linker on
the other hand it links strings boolean
number and a static class which i won't
go into but you recognize these right
these are your typical java boxed types
for for for boolean for arbitrary number
and yes the java string now these values
are actually being used as primitives in
in in in javascript then we have
something that's called o discovered
linkers all other linkers that are in
the in the in the class will def in
class bus will come here and then we
have a beans linker to make the java
objects and finally we haven't the
bottom linker because we have something
that that even the beans linker falls
through for some cases namely what
happens if you want to link a function
call on no right you want to call no in
JavaScript you can try to it should fail
missing property operations and some
other things so it's a lot of linkers
but this is okay and this is expected
most of the linkers can implement it an
additional interface named type type
based guarded guarding dynamic linker
which has an additional method that the
framework can interrogate for hey can
you link a class of this type so
normally we bind a linker to a class in
a class value so dispatch is fast so you
have a lot of linkers
floating around your runtime it's it's
fine because in most cases they you can
just dispatch based on the class it's
really really fast as I said we have of
some air question is the linker used to
handle a Jes adapter defined Reyes
adapter j/s adapters are native script
objects so so yes it is used the NASA
fun linker will be linking it yep okay
so why do we have the separate primitive
linker for for a string bully and a
number now here's the architectural
background for that for one thing we
don't want them to fall back to being
Slinker because we are having special
semantics for them within the JavaScript
runtime you can do things like can take
a boolean false and you can invoke a
method on it right you can so we don't
want them to fall through to the beans
linker so if you need to have something
that catches them before on the other
hand we don't want this semantics to
escape outside of our runtime and the
nass one linker itself is exported so
other language runtimes can discover the
nests on linker for cross-language
interoperability but we so what we have
is we export the nice one linker to be
visible through meta in services but we
don't export an ass from primitive
linker so it's a separate linker
additional semantics but it's private 22
hour runtime this is a technique that's
eminently applicable to any other
language runtime too why do we have a
separate bottom linker well as I said
again we have these corner cases we have
no objetos setters for non-existent
properties and we need to throw a bunch
of type errors when we try to use a Java
object this JavaScript constructor you
cannot do that try to invoke a
non-existent method on a job engine try
to invoke an operation or no things like
that we also have a separate thing where
we we intercept the
new operation which is normally just
either handled by bicycle if you get in
an asshole link or a new operation or
script function we know that it's a
constructor invocation of a function in
a JavaScript but if we if we get a new
invocation on on a Java interface that's
that happens to be a single abstract
method interface then well in JavaScript
you can use this syntax where you say
well you cannot use it in JavaScript but
conventionally the JavaScript
implementation a JVM Rhino will allow
you this syntax or say new runnable and
it's a Java runnable and then you pass
some JavaScript function as a
constructor argument and you know
instinctively what this needs to be
right you want a new adapter Java class
that implements the runnable interface
and when it's run method is invoked it
delegates to the function now obviously
beans linker cannot handle this because
beans linker knows nothing about
JavaScript functions and it needs to be
somewhere so again our primitive linker
inter subsidies and if you are having a
known same type then our new will just
fall back to being Slinker and linked
with whatever so you can say new Java
util timer task and if you just go down
to the to the beans linker that's trick
actually because it's an abstract method
but we we happen to hand those to one
other thing that you want to do is to
out Dino link we use something that's
called a call side descriptor you can
think about I told you a call site is
mutable usually you can relink it and
when they are passing things around
linkers we don't want linkers to even
accidentally just think about relinking
the call site so we don't ever pass them
the call site they don't see the call
site what they see is a call site
descriptor object which is an immutable
object that contains the name of the
invocation at the call site so then get
prop color signature of the call site
and the metal handles lookup object that
was used to used at that point which
usually is the public one for dynamic
languages but it can be a specific one
if you want to deal with with with
access to protected members from a
subclass however we don't have that in
mass one we do have a default
implementation of a cosine descriptor in
the end I know link which again can be
used by any language runtime
interestingly NASA phone does not
actually use it there's a reason for
that because we need to have a language
runtime specific arguments in our call
sites we we actually carry an int there
and that int contains a bunch of flags
whether the invocation is for scope
whether we have tracing and profiling
set on and more importantly whether at
that particular call site we are using
the strict mode invocation semantics of
JavaScript and these are interest-only
to an ass one so you need to be careful
when you are writing your code because
other language runtimes if they ever
receive an asshole cause I descriptor a
beans linker can always receive it right
because we are invoking something from
mass horn and it happens to be a pojo it
falls down to the beans linker the beans
linker will get the mass from cause I
descriptor fortunately it is an instance
of plain old called sigh descriptor it's
actually interface so other language
runtimes can use it they have no
knowledge about this edition of flags
and it's it's right that they don't
because they couldn't do anything with
it there's no semantics for them there
some discipline is required when you're
doing this because NASA on linker itself
cannot assume it will always receive one
of these since it's an exported linker
so you can get into a situation where
you have maybe a Python or a ruby
implementation that uses Dino link and
and sometimes you will get a request in
an asshole link or two maybe your Ruby
runtime will get an asshole object and
the Ruby runtime will need to link to
our operation on that nice form object
and it will pass it its own Ruby Co site
descriptor so publicly expose linkers
they cannot make an assumption that they
always get their native call site
descriptors they have to be prepared to
play nicely with foreign ones so we have
static hell
that extract that bit field and then
just fall back and assume it's 0 if they
get some kind of a coal descriptor that
they don't recognize on the other hand
that's from primitive and bottom linker
since they are never exported they can
just go wild and cast to to NASA on both
side the script because since they are
never exported they will always receive
that and they actually it's better if
they rely that they do because if we
cast and we fail then there's a bug in a
pro in our linker implementation so we
need to do something about it yeah so
this is pretty much the the way we
implement this is I get flags will say
hey is that ko Sai description sir hoon
ass home cause I descriptor yes it is
cast get the flags that have I assume
zero and then and then I request say for
hey is it a scope invocation will do on
is flags call site which will do on this
flag which will basically delegate back
to to here to this this flag which does
the get flags and so this is the
graceful fall back so if you are faced
with a vida foreign one you always just
go back and this is how nice one linkers
accessible code checks for scope it uses
the static helper code that's only
accessible from massillon primitive
linker it doesn't weigh anything of the
source it just blind the cast's because
it's an assertion that it should be able
to do so type conversions I think this
is our last topic both NASA and linker
and a strim primitive linker have
implementations for for type conversions
nasan linker will be converting Script
object two strings numbers bullion's and
single abstract method interface types
they can convert string number and
boolean to each other because that's
something that you need to be able to do
in javascript and we actually had to do
cross boxing we have a really really
good test suite that shook out all of
these things is a nice one does have
thanks to Marcus work has ever better
internal type optimizations so sometimes
you will end up with you just don't
assume as you
could theoretically in JavaScript at all
of your numbers are always doubles with
us they're not always doubles but they
are still sometimes boxed so you
legitimately can find yourself in a
situation when you need to to have a
conversion between upper case I integer
and upper case D double which again this
is something that JLS does not provide
you as I said dining gives you all the
JLS specific type conversions this was
something that we had to build on top of
it and I don't intend to put it in a
lower level in to die knowing because it
doesn't have any place there this is
this is entirely JavaScript
implementation specific this kind of a
cross boxing and of course as I said we
have the conversion comparator interface
that does that prioritizes conversions
because that was also an interesting
test case failure when you said all
right new tread new runnable something
and at first you get an ambiguity
because in JavaScript anything can be
converted to a string so it said okay
well you know both threat string and
thread runnable apply at this point and
according to the JLS resolution rules
neither is more specific than the other
one so this is a linkage time error now
obviously you know if you we all know
what we want we want this guy to get
invoked so our conversion comparator
augments the JLS rules and specifically
says if you're faced with a if there is
an object and you have to choose between
a string and a some interface and the
object happens to implement the
interface then go for that and you have
some exotic things like if you have a
Java function overloaded method and one
takes a string another takes a boolean
and from chaska to evoke it with one
well what should what do you do again
you can just throw an error but
rejection might be a sensible thing to
do because but what if this pool
programmer is not actually aware of the
fact that you just or maybe this is not
a literal one
maybe just manifested itself as a as an
as a result of a calculation right and
if there's a there's a number there's a
Java object I need to invoke a method on
the geologic with that name and I only
have a string and a boolean version
which one do I call so right now what we
do I believe is that I will I will I
will prioritize string over boolean with
the heuristics that that it's a less
amenable to information loss because a
one can have a representation as a
string well one can have a
representation is a boolean as well
right but what if it went one what if it
were 42 right so you can you can convert
it to a string so that if you inspect it
you still can realize that maybe was a
number and it's still a number and you
cannot do the same with the boolean now
the nice thing about all of this is that
you just need to implement a conversion
comparator interface really simple it
says it takes three classes it says i
have an integer and i have a candidates
that are string and a boolean which one
should I choose that's what you
implements a method that answers this
question and it plugs into the
overloaded method resolution machinery
that lies underneath and just works
dinoland gives you that sometimes we
want to do use type converters outside
of linking we have a solution for that
too there is a dynamic linker has a
method on it that the his name get type
converter and you specify a source type
and a target type and you get a metal
handle that when invoked with an object
of the source type gives you an object
of the destination type we specifically
use it to convert JavaScript arrays to
Java raise we don't have this as an
implicit conversion because we are not
forced to fortunately this is outside of
the scope of the Java of the JavaScript
specification but we do have an API
named capital java dot s java array and
then you can take a JavaScript array and
say I really need this thing to be
converted into a Java array of strings
and then what you do is what we do is we
get a type converter usually from object
to string and just run it through every
element of the array the nice thing
about it is that for whatever reason you
maybe got some foreign thing maybe
Ruby or Python object stuck into your
array then this kind of a conversion
will actually find the appropriate
conversion of a ruby object to string
and make sure to invoke that too well
these are the interesting use cases that
that that we found as we were actually
integrating Dinah linked in Tunis horn
as I said invoke dynamic is a start but
it's not a metal object protocol Dinah
link is a framework for implementing
metal object protocols and it ships with
them at without standard methods of
protocol for pojos that you can use as a
fallback and additionally you can just
additionally you will need to implement
the object model for your for your own
language runtime for death to for it to
be a full-blown usable something in your
in your language as we could see your
language runtimes requirements can drive
some interestingly elaborate
architectures we can have multiple
linkers we can have custom course I
descriptors with language specific flags
in them you might need slanguage
specific type conversions some of them
are public that is exposed some of their
private to your language runtime
semantics you can have some extension of
Java semantics for singular abstract
metal the interface constructors these
are all things that you will be faced
with when you are implementing a line
which one time and using Dino link but
this is to be expected this is this is
this is part of the of the of the
integration efforts you will need to
solve these problems even if you don't
use the ionic so you might as well
alright that's all I have
ok I think we still have time for
questions yes
Oh
alright the question is that the real
benefits of dynamic seem to be will seem
to be realized when every language
runtime starts using this and then we
have actual cross language communication
single JVM and what are we doing to get
other language implementers to start
using it well I'm evangelizing it
whenever I can I'm talking about it left
and right and Paul being even a little
bit annoying with it over the course of
first version of this library I was
presenting at the 2008 JVM language
summit at that time we didn't have
invoked dynamic it's it was a purely
library based solution the invoke
dynamic version is something I started
hacking up on a vacation in 2009 and I
showed it at the 2009 JVM language
summit and we had Ruby JRuby guys daikon
guys other guys there I presented it I
presented it again on 2011 jaylene
language summit Charlie not specifically
he's always really really enthusiastic
about it it's a I guess I need to grab
him sooner or later I don't see that he
had opted it yet I think he should I
think he himself thinks he should he's
probably I know I don't want a second
guess Charlie ok but as far as I'm
concerned yes i'm i'm i'm talking about
it to j2 to language implementers
whenever I meet them that's what I do
and hopefully the fact that yes we do
now have it proven as working in a in a
swarm is is probably additional
credibility to it it is an independent
open source project on github so it can
be adopted we will see going forward
where it will end up I don't want to say
anything with regard to its future fate
sort of seems reasonable for it to
eventually get part of the standard JDK
but again as a as I said I actually I
can talk about anything because I show
you my safe harbor slide that says that
I can any
anything that I said can not be taken
seriously but so but yeah the the
overall idea is that just just by making
a show that's a big with this available
in multiple places and you know it will
it will it just needs to get interaction
it gained I think a significant and
right scholar specifically i think in
2.9 and introduce their own some kind of
a facility for dynamic invocation but
it's funny because it's you need to have
a static interface that declares that
the object is dynamic in order to call i
think that's how it works it's uh i
don't know the specifics haven't looked
into it yes
right okay all right yeah okay so if I
understand the question correctly it is
basically it's not so much a question is
an expression of a worry that if we need
to incorporate all the all the
operations possible on objects coming
from every language runtime that's out
there we will end up with a with a
really really big operation surface that
the the number of operation that will be
very large well that's one way to think
about it another way to think about it
is that for one thing you don't have to
expose every operation I have was very
careful to for all the common operations
I always use the prefix named dine so
it's dying column get crop whatever if
you have your language and you need to
want to go through the linker in every
case but you don't necessarily you might
have some private operation you can just
use your language prefixes as the
operation schema basically and run with
it so you don't need to expose all the
operations necessarily on the other hand
the intent here is that we want to
identify a wide usable subset of
operations that are common to many
languages on the JVM I mean yes I mean
it cannot really be an ideal list you
cannot really have an idealistic view
here because then you really end up with
an unmanageable sighs for everything but
I'm saying that we definitely can have a
pragmatic subset that still allows
meaningful interoperability in in
majority of cases that you would want to
but you're right and as far as adding
operations I am very open to suggestions
to how incorporate things like operator
overloading and so on and so on
just that I don't have the bandwidth to
start writing the Ruby linker and see
what things will it need as a support
but if somebody starts to do it I will
be really happy to cooperate with them
and see where we can get so yes I'm
aware that there are still unidentified
requirements and needs here and i am
actually very careful to not end up with
something that is specifically
JavaScript shaped it's a so that's
that's that's something that I'm paying
attention to just the fact that you have
a separation of the element of a
container and a property and actually
method right now and they're not lumping
those into a single namespace right is
something that I wouldn't have to do if
I only targeted JavaScript but since i'm
i'm targeting a wider number of
languages I'm I try to make sure that I
maintain a high fidelity API high
definition weather whatever you want to
call it yes
well it's a hard coded in library you
can write your own linkers and those
linkers are consulted when something
needs to be linked so the question was
whether I see any benefits in having a
more declarative set of rules and
strategies is for linkage instead of it
being hard coded right now they think
that you could say is hard-coded is the
beans linker which I ship but it is it
is meant to because it implements the
beans protocol for for for accessing
java objects you can override it though
because we already override it when we
use our nasscom primitive linker we will
we will treat the java.lang boolean
java.lang.string and everything that's a
Java line number we will treat this
separately so if you put a linker in
your chain that comes before your bins
linker you can override any
functionality in there so this kind of
flexibility is something that you
already have yes
get
mm-hmm no it's not so of course you can
have plug-in for everything yeah so the
question is whether the beans linker
copes with non-being conformant method
names as in collections have a size
method instead of get size and maps will
have keys instead of get keys and so on
the answer is no these are not exposed
as proper togethers they are exposed as
methods so you can still do list dot
size braces to invoke it right so they
will as I said they will still be
exposed as methods that you can invoke
so you can use the the the call verb in
the in the Dino link to invoke them as
methods so in your source language you
will actually need to say you will you
need to use the method invocation syntax
instead of the property access syntax
for those
yes yes you get yeah you're getting the
gist of it that's that's pretty much
what you can do if you want to oh yeah
we actually have somebody in house who
is who is uh I was pleasantly surprised
because he's having a lot of fun
actually writing additional linkers for
things it's like special linker for maps
that that happens to expose these and
and the special linker for for jas
object those netscape specific
javascript api is that are reflected
into java when you're using applets from
a browser or i think he was also writing
a linker for for xml dome objects as
well which is again something that you
can do so it's is having a yeah so so
we'll have those as examples all right
any more questions going going gone all
right thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>