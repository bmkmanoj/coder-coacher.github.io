<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Techniques for Responsive Real-Time Web User Interfaces | Coder Coacher - Coaching Coders</title><meta content="Techniques for Responsive Real-Time Web User Interfaces - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Techniques for Responsive Real-Time Web User Interfaces</b></h2><h5 class="post__date">2013-02-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/-XyuzD2IHpk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Roger kitane I work for
oracle corporation my primary
responsibilities are I work on a
specification and implementation called
GSF perhaps some of your part of it
javaserver faces I've been working on
jsf from just about the beginning I was
actually co spec lead for jsf 12 and 290
with my colleague at burns so I'm sure
you you know work-related passions I
really like to dabble around and
client-side stuff some JavaScript and
reel web communications so I often post
some blogs on jsf and how jsf can work
with things like WebSocket server sent
events and and stuff like that hobbies I
like music I player hack around with
guitar a little bit I like hockey my
oldest son plays ice hockey I'm into
robotics I'm a code slinger probably
just like everybody else here and I like
all things cool of course all this takes
time and we've got a family like I do
you try and do the best you can so this
is this the slide that I'm sure
everybody's seen and probably a sick of
seeing by now so I'll just jump to the
next one so I'm going to start off by
doing a short introduction mainly talk
about just a little bit of history that
most of you are probably aware of where
the web has been where it is now and and
how we got to where it is now i'll talk
about the real time web a little bit
some of the techniques that have been
used historically and some of the
techniques that are being used now
especially with html5 then i'll get into
talking a little bit get into a little
bit more the GSF expects and how you can
use some of the html5 communication
techniques with JSF do a couple of demos
along the way hopefully that one will
cooperate with a network connection if
it does it does if it doesn't it doesn't
but first I have is a little more stable
doesn't rely on a network connection is
so and then I'll wrap things up with a
summary and hopefully we'll have enough
time for some Q&amp;amp;A at the end so just a
couple of quotes that I dug up off the
wed web so when we're talking about real
time stuff you know Twitter comes to
mind obviously and there's the canonical
application for WebSockets probably
which is chat which I'm sure everybody
have seen and heard so just a couple of
quotes from some well-known folks out
there about real time and where we are
right now so traditionally and still is
very common obviously is the canonical
HTTP request response protocol and you
know that works great for web apps but
it doesn't really work obviously for
real-time streaming or pushing
information from the server you
basically poster a post a request and
get a response back and there's a full
page refresh and so forth so for for a
while back I mean folks have been
looking to increasingly get more dynamic
and they wanted they wanted they wanted
the web their web applications to really
mimic rich clients that are out there so
long came the dynamic web you know it's
since the 1990s it has been more dynamic
many of you probably remember Java
applets I was kind of a weak attempt to
try and try and get there I frames which
you guys are probably familiar with then
there's JavaScript and HTML and of
course Ajax came along and the
interesting thing about Ajax of course
is that it's been around for years you
know Microsoft actually had an
implementation nobody really thought
anything about it 2004-2005 somebody
comes along and coins an acronym Ajax
asynchronous java and xml and all of a
sudden it's the greatest thing since
sliced bread that everybody wants to use
it and you know it works great but it's
amazing how far an acronym will take you
alright so traditional patterns on the
far left I'm on the far left excuse me
on the form excuse me on the farm left
is a polling excuse me think I need some
water so there's the traditional polling
technique that has been used with Ajax
mainly because you're trying to simulate
excuse me a server push mm-hmm excuse me
I server push so what you do with the
idea hein that is over a specific time
Oh time hmm excuse me over a specific ah
my voice I don't know what's going on
here
so the idea my polling is that your
you're submitting requests to the server
over specific time intervals to simulate
real time push from the server and you
know this would probably work okay if
your server side updates are not
happening frequently where you don't
have to pull over short periods of time
obviously that's a performance set if
you find yourself doing that so you know
in most cases that may not work out
really well so then there's long polling
where you basically open up you submit a
request and the request stays open until
a response gets received from your
server once the response gets received
from the server you initiate another
request again it's a little bit better
right I mean because you're not you're
not initiating requests large number of
quests from the client so it's a little
bit better performance then there's not
streaming which opens up some more
possibilities where you submit an
initial request and the connection stays
open and then you can constantly receive
information from the server and this is
where comet actually started comet was
more or less I consider it a hack first
attempt hack to to get real-time push
from the server we're trying to do it
over trying to force HTTP HTTP request
response mechanism to do that so he
ended up with all this hockey code that
was one problem with it the other
problem with it is there was no
standardization of it so you had all
these different implementations of it
then of course there's Ajax which like I
said before you can simulate with a
real-time push through polling the big
thing about Ajax is partial page refresh
and if many of you guys are familiar
with JSF in jsf 20 we have introduced
ajax into the specification
okay so let's get into some of the html5
the html5 excuse me again some of the
html5 communication techniques that can
be used now some recent events are
probably a less well known band min
websockets everybody I talked to her i
said i've ever heard of server sent
events and they say no this has actually
been out for some times for some time as
well
and the idea with server central server
sent events is where you can you can
make basically open up it's a JavaScript
API associated with it just like a lot
of the html5 communication techniques so
you can basically open up open up a
connection excuse me I'm sorry
so you can open up a connection from the
server using the event source JavaScript
API so the advantage of this is that it
is a it's kind of a standard and that
it's under the html5 html5 umbrella and
it's it's the advantage of this is that
it's actually over HTTP so the idea is a
connection is opened up and then you
basically stream Dom events from the
server so what you do is when you create
the event source object you feed it an
event source URL which is basically an
end point on the server okay so the
thing about a server sent events is that
it's a unidirectional so it's
unidirectional so you basically receive
information from from the server whereas
websockets is bi-directional I don't
know how much water I can drink all
right so WebSockets is bi-directional so
essentially what it is is you know this
whole this whole conference has been a
lot of talk about web sockets and it's
pull me one of the more exciting to go
and technology technologies to use with
html5 communication so the idea behind
the idea behind WebSockets is that this
is initial HTTP request to establish
mmm thanks to establish an initial
handshake all right thanks so once that
HTTP connection is made it to establish
the handshake the UM it's upgraded from
HTTP to W into a WebSocket protocol
which is essentially a layer over tcp/ip
so much what you have is a real tcp/ip
full duplex connection so I mean this
this is great for for real for real time
communication
so just like you know there's a
JavaScript API for server sent events
there's also one for web sockets which
some of you might be familiar with it's
pretty simple to use with WebSockets
most of the work is actually going to be
on the server but the JavaScript API is
very easy to use from the client so the
idea is basically open up a connection
to the function for that yeah there's an
odd message function where you can
register who event less than our event
handler in JavaScript so when you
receive information back from the server
you handle that information most people
update the Dom with information thanks
there's a non closed function and one of
the things that people don't talk about
very much is you know what happens if
you know you've got a WebSocket
connection going and the connection
drops for example you lose the
connection what do you do I mean how
does your bad as you use their interface
handle that well the WebSocket
specification the way it's supposed to
work in theory in certain cases and I
haven't doubled around with it myself
but if the connection closes you can use
the on clothes function from your client
and and do something some people try and
reopen the connection again
automatically MC put some people maybe
just spew out a nice error message
in this various ways you could probably
handle that the other thing I want to
mention about websockets is you know
it's really exciting having an open tcp
connection basically a full duplex
connection because you can do so much
with it but it's probably something you
want to use sparingly one of the demos
i'm going to show actually opens up to
web socket connections you know what's
standard a request-response there's
typically a 2 connection limit for the
browser web sockets you can go more than
that but you know obviously you want to
use it sparingly don't go crazy with it
think about think about valid use cases
you would want to use web sockets for
and you know there's plenty of web
sockets talks here and I'm sure you guys
have been to some of them and they've
probably talked about some of that stuff
okay so I'm going to get in this portion
I'm going to get into talking a little
bit about jsf and how many people know
jsf all right let's fair amount of
people so this is not an introductory
course on jsf but I am going to be
talking about some of the features in
jsf 20 and how we can use some of that
with WebSockets in particular so what
I'm calling this the component pattern
so in jsf todaro we introduced something
called composite components which is an
easier way to put together components
and use an interface and so it as it
turns out composite components work
really really well with JavaScript and
that you can see where that ties in with
some of these html5 api's because
they're JavaScript so we can actually
encapsulate html5 JavaScript API within
a jsf component so a page author was
actually used to you know putting jessup
tags on their page it's it should be
seamless to them so the connection is
made the WebSocket is connection with
the page loads we can also have GSF
components which render place all
remark up for receiving msgs data so
when you get WebSocket information
coming back from the server data from
the server remember you have those on
message handlers so they're just
JavaScript functions so you can make
that work with JSF as well I've dumb
dumb as in the past with server sent
events as well using the same technique
so this technique I'm going to show you
also works with super sent events and
WebSocket there's another pattern i like
to call as the modern pattern so in jsf
you've got you know you have managed
beans or beans or any plain old POJO
would work with that assuming you have a
Java API for initiating WebSocket
requests or whatever you can do that
from a pojo as well the demos i'm going
to show you actually use the the new
WebSocket jsr stuff that's been
developed for java ee 7 that's still a
work in progress but has some really
nice annotations you can use with pojos
and even JSF managed beans so you can
have GF managed beans as endpoints
WebSocket endpoints so let's take a
chance and look at our first demo here
so I'm going to do is just start a
WebSocket server here okay so this is
big so you guys probably can't see too
much of it but the idea is that you have
on the left head at the very top you
guys can see a running clock so that's
11 WebSocket connection i have in this
user interface the second WebSocket
connection i have is for this randomly
generated flight information coming
getting pushed from the server on the
left lower left-hand side and then i
also have as i receive that data from
the server i'm just using a third-party
graphics library graph library
javascript library to just display the
data graphically and that's you can see
that changing the other part of this
demo we see if i can
this is really big so let me see if I
can
change the display a little bit
as to show you guys
we're back again
so the other part of this demo if I
scroll down there's a little area here
on the lower left hand side where i can
actually input flight information this
is where the the full duplex by
bi-directional capabilities of web
sockets so let's say I want to put in
flight information here too I put an
existing flight and let's say I want to
update gate so I'm going to update
United Airlines flight number 210
Baltimore I'm just going to change this
to some large number press apply then
you can see the update there so you know
even as you're streaming data you can
get that get that going across a nice
thing about this with WebSockets is I'm
not going to display the ipad here but
I'm using an iPad here with the same
with the same UI if this would work
the idea is basically you can the idea
is you send with this demo on other
real-time streaming demos you make an
update like that it goes it gets updated
on the server now with WebSockets you
can broadcast that information to
multiple clients so multiple clients
will have that updated information
real-time I welcome it like I've
mentioned before comet as it sits you
can do the same thing with comet but
it's a lot messier than WebSockets okay
let me just get connected here if I can
that says I can't join for some reason
so okay so let's try this again
okay so i have i have this demo running
here you guys are probably not going to
see it from back there I don't want to
switch to display because I don't want
to use that lose that but the same JSF
UI is is running on the iPad here so I'm
going to see if I can update some flight
information here let's try Austin 1661
let's see if that comes out
there's a connection here still
I was the wrong
see if that comes out there trying to
get something that would show up on both
so let's try
the information stream by a little bit
fast but the idea is that I can actually
put in updated flight information here
and because it's going to the server
gets updated on the server and then the
information will get broadcast back to
all clients that are connected via web
sockets so the information will get
updated here and also on the laptop
which is another client right now so I
can't get that working right now but
we'll just move on so what I want to do
is show you a little bit of the code
that was used to produce this
so the first thing
so this is the main page of the
application it's called flight XHTML and
it's just a plain old JSF page the first
thing that you want to look at our line
number 65 and 66 where I basically
created two GSF composite components
websocket components actually it's one
WebSocket component but I'm using it
twice for two of my web socket
connections it has a channel attribute
and the channel attribute actually has
the WebSocket endpoint that i'm going to
be using in this case i'm using you know
the same web socket in point but two
connections then i have handlers after
the colon there you can see I have a
clock handler registered so i'm
specifying the name of a javascript
function which is going to be my on
message handler for that guy and that's
the handler that actually updates the
user interface for the running clock
from the server on the second one line
number 66 I have actually two handlers
registered there's a flight handler and
a graph handler in the flight hem are
actually that's the one that updates the
DUI with all the flight information and
then the graph handler is another
handler that takes that same information
and dynamically updates the graph that
you saw there so the WebSocket component
itself if you're familiar with composite
components this is really just a pretty
simple component that has an interface
section and an implementation section as
all composite components do you know the
interface section you can see where you
have a channel the implementation
section what I've done is I created a
very simple JavaScript WebSocket jsf API
and we're calling the init method
because icing init function passing in
the channel that guy will open up the
WebSocket connection so that's really
all there is to that composite component
piece let's take a little bit look at
the JavaScript API you can see where
it's basically calling the underlying
JavaScript WebSocket stuff so the on
open method basically sending an initial
and register because this is actually
using the the java ee 7 web stock and
stuff the process message function is
just a function that is going to when
information comes back over the
connection remember i can specify one or
more handlers those are actually going
to be invoked when data comes back over
the connection and here's my here's my
innate function so in the NIP function
there's where you can actually see the
under underlying WebSocket javascript
sees me api
excuse me i also created a get socket
function kind of a simple access or
function that could be used depending on
where you are in your code you can get
that information you can get this actual
socket handle return so you can use it
so that's all there is to that
javascript api i'm going to speed things
up a little bit again this is a clock
composite component there's nothing
really special it follows the same
pattern as they had before this is the
javascript file for the clock handler i
mean you can actually see you get the
event data back over the WebSocket
connection and it's basically setting an
element in the Dom the flight monitor is
the one that actually gets the graft of
the flight information back and what
this is going to do is it this is
basically going to create a table where
it's actually going to put information
in there to a placeholder for the
JavaScript that backs this which is
flight jas so flight AS IS has a send
change function if you recall on a UI I
was able to put in flight information
and gate information to update it and
that's what that guy does you can see
where I'm using that get socket a
JavaScript function and sending that off
to the server there's my flight handler
which is going to dynamically create the
table we saw the flight information
being added nothing if you're familiar
with JavaScript this is really it's just
plain old JavaScript nothing really
fancy there
again the graph the graph one is just a
plain ol composite component I'm then
going to get too much into you know what
the JavaScript looks for like that but
that's a third party on JavaScript graph
library you could use something like
jQuery if you want it to or your
favorite gruff library that you're used
to okay all right so one of the other
things which is pretty cool with
WebSockets is that you can actually use
it to control physical devices whether
it be you know some sensors in your home
you know turning on off some lights or
maybe a robot you know so the idea is
basically you have your client side your
browsers and you know you can use the
JavaScript API like we did even with JSF
submitted a submitter WebSocket request
to a WebSocket server and have that guy
use a socket connection to talk to a
robot and maybe tell the robot to turn
on some lights or you know they could
move or whatever so it's pretty cool but
in this particular scenario you want to
have you want to have real-time updates
as possible so you know imagine imagine
you you're over the connection and you
you want to control some sensors but at
the same time it's great that you can
control some sensors but you want some
feedback back on the UI seeing what's
the status of those sensors are they on
are they off still or what's going on so
you can see where the bi-directional
communication capabilities of WebSockets
come in for that so see if I can do a
demo here looks like there's some
problems already but we'll see
so I don't know if this is going to work
we'll see if the network folks are with
me you know maybe this will work but
so the idea yeah there we go so the idea
is this is a this is again a jsf user
interface I've got a little robot over
there with a couple of LEDs on there the
robot has a Wi-Fi shield what's called a
Wi-Fi shield on there you can also get
them with bluetooth but I for whatever
reason I chose Wi-Fi it's got a little
see sketch on there so I did a little
bit of c programming I had to open up my
old see books it's been a while since I
programmed and see so the ideas I have a
JSF UI here showing the patterns that I
showed you guys before nothing nothing
really out of the ordinary there's one
WebSocket connection here it's opening
up a WebSocket connection and I can shut
this guy off I can have controls here to
make it pulse
oh you can actually but the screen is
actually big there is let me scroll down
a little bit because I do have a little
status table here which shows the what's
happening as information is coming back
so if I put this guy on the red lights
on and then I also get an indication
coming back saying it's on signals on if
i turn it off same thing if I want to do
a 100 millisecond poultry a 100
millisecond pole pulse race rate same
thing I can control it information comes
back the UI gets updated can change the
pulse pulse rate again and so forth
simple on and off but but you get the
idea so you know WebSockets is great for
stuff like this as well where you want
to utilize that bi-directional
communication especially controlling
devices and at the same time getting a
real-time status back saying hey did it
did it you know is that is the device
actually on or off or whatever to get
immediate feedback so kind of glad that
worked let me go back to the
presentation well actually before I go
back to the presentation I can show you
some of this code hopefully we're not
running out of time but we might be I'm
not going to go over and show you guys
all the composite component stuff that
went into this UI because it's the same
pattern that was used in the first demo
so what I'd like to do is show you what
the actual beam looks like so this is
this is what I call the light beam so
this
this is the first entry point for a
WebSocket request so this happens
through your jsf managed bean which is
also an endpoint and this how many
people have looked at the WebSocket GSR
stuff we looked at it so you're familiar
with some of these annotations so the
nice thing about this is that it
provides some really nice annotations
you can see they at WebSocket annotation
on line 53 you can open up you can
specify a WebSocket endpoint this case /
led there was also a remote attribute
there which is used to it's another
class which is helpful for broadcasting
information back there's a WebSocket
context which is useful there's a
WebSocket message annotation that I'm
using and that basically annotates a
java method and your being and that's
the one that's going to receive
information back from the WebSocket
server so imagine you know they imagine
that you know this is actually going to
actually this is going to this is
actually going to process the message
coming in and then what you're going to
do is you can see online number 70 and
beyond or broadcasting that information
back so all kind of all interested
clients that are connected over this
connection will get information back via
this broadcast method which is really
nice so you can see this is a really
nice API with annotations that you can
annotate any pojo and have this work
over a website WebSocket connection so
that's that guy so what I'd like to show
then so the other piece to this demo ok
so remember that initial diagram I
showed I showed
I showed information coming from the
client to the wood excuse me to the wind
WebSocket server in the in the case of
this robotics demo I need something when
I when I receive a request I need to be
able to talk to this robot device so
this is our robot device like I
mentioned before has a little bit of C
code on there which opens up a socket so
this Java class that I wrote is really
nothing special it just uses a java.net
socket API to actually communicate with
that and then that guy sends information
back to here and this guy forwards it
back so it eventually ends back at the
UI so you can do tricks like that nice
thing about the Wi-Fi shield that i'm
using on here too is that you can
actually have a tiny web server running
on here so you can you can post HTTP
requests to that guy and have back i
send replies back or whatever crest
response but since i wanted to use web
sockets for this demo that's why i was
using the the socket API
second place both HX
no it doesn't replace it Ajax is not
going away comet yes I would say you
could still use comma you can use
anything you want that you're
comfortable with but right well in the
beginning of the talk i mentioned that
ajax follows the traditional and it is
basically HTTP it's a follows the
request response protocol but the idea
behind that is that you can use ajax to
get information back from the server and
do a partial page update so in
traditional request but response web
applications there's always a full page
refresh going on with ajax you can
update single Dom element if you want so
it gives the appearance of a rich client
user interface so there's nothing
preventing you and I don't have a demo
here but you can certainly use Ajax
along with WebSockets on your UI it's
nothing there's nothing wrong with that
excuse me yes I'll get into that a
little bit so here's just a little
overview of the the demo that we just
looked at on the browser client we have
the JavaScript API on the WebSocket
server implementation I have there's a
simple Java Bean could be a jsf managed
bean and that uses a socket handler to
actually communicate to the SDK that's
on the actual device it's the
information back and it gets back to the
client so it's really it's just all
socket stuff with WebSockets so these
are a couple of resources that I find
useful you can go to and find out what
HTML html5 technologies are available in
which browsers this is kind of what it
looks like so this is an example this is
for server sent Dom event so we'll tell
you and I think this stuff is pretty
update pretty updated and fairly recent
but
you know we'll tell you where that with
the support in which browsers which
versions and so forth same thing with
WebSockets so as of a couple of versions
ago web sockets is available in Firefox
actually i was using firefox for the
demo which is nice for the longest time
it wasn't available in web sockets and
there's nothing wrong with chrome chrome
has probably been one of the pioneer
browsers for web socket support but that
just gives you an idea of what's
available so a little summary we talked
to but we talked about traditional web
and dynamic web kind of like where we've
been historically then how we ended up
where we are and why I went over some
patterns and technologies Ajax comet
then I went into a little bit about some
of the html5 communication techniques
super sent events and web sockets talked
a little bit of how you can use this
stuff specific to jsf and then we went
over a couple of use cases and showed
you guys some device manipulation using
web sockets as one use case some
references the top 10 third the third
stone com that's a sight i put together
it's it's kind of new there's not a
whole lot of information out there mmm i
will be putting more stuff out there the
second link is a link to the the
WebSockets specification that's going to
go into java ee 7 and they were
corresponding JC excuse me JCP site and
questions yep
yeah well we're typical even with Ajax
and typical HTTP and stuff there's like
a two connection limit something like
that yeah I haven't been up to date with
that but right I haven't tried that but
uh I know if you have if you try and do
three Ajax or whatever you know some of
the or whatever that traditional HTTP
that's that won't work out I just know
with WebSockets you can have more
available but like I said you want to
use that sparingly right well like I
said before and we're going to talk with
WebSockets it's a lot of the work
complicated work thread management all
that stuff request management is really
on the server and thankfully there's you
know there's quite a few server
implementations out there you know from
the client you have to really manage
stuff in terms of if what happens if a
connection drops and so forth any other
questions
all right thank you very much sorry
about the boys</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>