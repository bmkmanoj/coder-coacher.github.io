<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>A New Platform for Ubiquitous Computing: Oracle Java ME Embedded | Coder Coacher - Coaching Coders</title><meta content="A New Platform for Ubiquitous Computing: Oracle Java ME Embedded - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>A New Platform for Ubiquitous Computing: Oracle Java ME Embedded</b></h2><h5 class="post__date">2013-02-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Z-KgNHCQfyM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so good morning thanks for coming my
name is turns far I'm a technologist and
a product manager at Oracle I know this
is a tough time for for a tech talk
tuesday morning at eight-thirty but
nevertheless i think we have some some
really interesting stuff to share with
you today this is about a product that
we just released last week I don't know
if you followed my blog or the press
releases so this is brand-new me ask
first who in the audience whose first
java wanted sis you're here for the very
first time at javaone ok thanks and who
has any embedded background at all or
are you all like enterprise the desktop
developers embedded background oh pretty
good ok thank you alright so the title
is kind of lengthy but I really think
this is going to be too because this
product really aims at mass markets
large-scale deployments of embedded Java
into resource-constrained devices so I
call it the ubiquitous computing
platform let's tell you more about it
all right so this is my agenda first
I'll talk a little bit about the
opportunity and the challenges in
embedded development which hopefully
some of you are aware of and essentially
how Java can help how Java can make are
developing and deploying embedded
solutions much easier I'll give you a
brief overview of the product itself
Oracle Java ME embedded 32 then we'll do
a bit of a deep dive into the
functionality in the api's I think we
have an hour on the talk so i can take
questions and we can you know if you
interested any particular area just let
me know and we can we can cover it in
the talk then if the demo gods are
willing i'll give you a quick demo of
the product writing some code on both
the actual device as well as the device
emulation that we provide just to get um
show you how easy it is to get
and then wrapping up give you some more
pointers on embedded content at the show
and beyond alright so I'm calling this
tackling the opportunity because
obviously there's a huge opportunity out
there right smart intelligent connected
systems are going to be exploding over
the next couple of years there are
estimates predictions that connected
intelligent devices will outnumber pcs
smartphones and tablet computers
combined in the next couple years so
we're talking billions but it's not easy
to develop embedded applications you
have a lot of things that you need to
consider a security reliability the the
ability to integrate with other systems
networks backends other devices you need
to be able to manage these devices right
once you have billions of devices out
there you need to be able to manage them
connect to them identify if they're any
problems monitor them potentially
upgrade their software and then it's
always a rush to reduce costs and to get
to market quicker right so building
building solutions that reinvent the
wheel where you have to invent you don't
recreate your whole base and your whole
infrastructure and platform every time
is just not going to work anymore you
want to be able to have code that's
portable instead of you know recompiling
and retargeting every time you move to a
new platform like you have to do a
native is just not scalable and you want
to be able to integrate with all sorts
of standards right the more people get
involved in embedded the more solutions
and platforms and infrastructure is
being developed the more you will need
to integrate with those with those
components right so developing embedded
systems is is non-trivial arm
and you know if you look at sort of the
the list of requirements from a high
level perspective on the left these are
kind of the things you need to consider
the system has to be robust you need
often these devices are out in the field
or in market for many years so you need
to be able to remotely upgrade them and
remotely operate them and monitor them
you need to as I said often add an
enhanced functionality over the lifetime
of the product you want to have some
local intelligence on these devices to
be able to do things smart on the edge
of the network and provide additional
value their cost of the the platform the
footprint is always as always important
you need to be able to scale the
platform so that you can take a basic
deployment and basically replicate that
for other use cases and other markets in
order to save costs and get to market
quicker and then finally you know one
major issue you always have with native
embedded development is that you're tied
to the underlying heart and software
combination right you have a particular
platform an operating system a processor
architecture a tool chain a language you
have libraries and they're all
interdependent and it's not not at all
trivial to move from one to the next so
we believe that embedded that Java in
the embedded space addresses many of
these pain points that you traditionally
have in native embedded development so
you know being a virtual execution
environment that Java is you're always
running the applications in a controlled
environment right so robustness and
security is something that's already
been taken care of for you with the
right plugins and protocols and
management support the platform office
you a horizontal functionality and
infrastructure infrastructure from
managing your system you have a lot of
api's and rich functionality through the
Java platform that's a major benefit
it's optimized for resource use I'll
tell you about this product that we have
very you know low footprint
resource-constrained operation as
possible and then you know very
important you can fall back on the
ecosystem of Java so all the the tools
the expertise the libraries the existing
code that's out there you can leverage
that and leverage standards that exist
to build these applications so overall
you know Java me or Java for the
embedded space just makes a lot of sense
so to dive in a little bit deeper so
I've been talking about native embedded
development a lot and that's of course
what most people do today and what you
might be familiar with if you have an
embedded background but from a
developer's perspective you know how
does that compare Java to native and so
here are some of the highlights you know
obviously the first one cross pause for
multi architecture that's a given for
Java development for java programmers
for native developers this is a godsend
right because they're struggling with
transitioning from 8-bit to 16-bit or
from single core to multi-core
processors and this is you know this
just goes away this problem security
sandbox model um you know obviously
Javas had that for for a long time since
the beginning allows you to basically
rely on all the testing and all the
maturity that has gone into the Java
platform in terms of security robustness
in native that's very that really
depends on how much testing and how much
integration testing you do and quality
testing sometimes native solutions are
very robust
sometimes less so you know 11 wrong
pointer and your your system blows up
multitasking that this is really
relevant with multi-core platforms today
that are becoming you know even the
smallest embedded arm platforms now our
multi-core so you want to leverage that
in native you can do that but it's
always platform specific an add-on so
you have to learn new libraries and new
programming methodologies in job of
course that's that's been there from day
one the performance is something people
always worry about you know how how fast
is my java solution going to be and it's
actually in most cases what we found is
that it's certainly fast enough I mean
there might be situations where you just
need a tight native loop to do something
as quick as possible and then you know
you probably don't care about Java in
most instances once you once you take
into account all the features and
functionality that Java offers um you'll
see that the performance tippity is is
you know more than enough so performance
shouldn't keep you from using java
update ability that is very important
the the ability to update your solution
in the field right that's very difficult
with native because of all the
dependencies in your stack so if you
want to update let's say one library arm
on your device because you found a
security issue in a diff that's very
difficult because you have to basically
you know rebuild and we link the whole
image you have to retest everything that
could be dependencies and new issues
that crop up before you download it into
the vice you reflash the device and even
then can things can go wrong right so
it's a very tricky proposition with Java
again because you have a virtual
environment running in a sandbox you
just basically replace that class file
or that class library on Java on the
system you download it remotely and you
restart your application and off you go
right there are very few implications on
the integrity of the system and in fact
that's one reason one of our partners
centurion you might have heard them at
the keynote on Sunday that's one of the
key reasons cinterion actually chose
Java because they wanted to get away
from native as much as
possible it impacted the stability and
the integrity of their system of course
with Java you have you know the the the
development model of Java you can use
the same tools the same programming
model the same expertise across a wide
range of platforms so that's something
that's basically impossible with native
development and then the developer
community that you can lean on right is
very large in Java you'll find many many
people millions of developers like
yourself who who know Java versus a
small very dedicated community of people
who might know a specific native
embedded environment very well okay as I
was going into these things in a little
bit more detail because I think it's
really important to set the stage and
why we believe embedded makes Java makes
so much sense and embedded so this is
kind of the vision that Oracle has you
know if you think about it why is wise
Oracle interested in embedded I think
the message is pretty simple Oracle is
an enterprise data driven company right
the more data that gets generated on the
edge of the network and needs to be
processed and stored the better so it
makes sense from a whole you know
end-to-end perspective for Oracle to
really get involved into what's
happening at the edge of the network so
if you look at where job is today it's
actually spectacularly successful
already write Java is on about 10
billion devices around the world if you
include smart cards and phones and
desktop computers and whatnot and so all
these devices provide you know a very
similar runtime environment for you to
develop applications they're typically
smart they are connected they connect to
back to the cloud Oracle is providing
and will be providing me
we're products to integrate that data to
manage that data go into the back end
where you can analyze the data storage
process it and the you know this
internet of things that people are
talking about that that is where you
know you really need a capable platform
on the edge to be able to to to have
these devices be smart and
interconnected and manageable right so
that was the background let's talk about
the product itself so maybe first why is
it called ME embedded three two and not
one dot zero that's a good question it's
actually based on the same java runtime
that oracle has been shipping for years
into the mobile space which has the
version number 32 so we just took that
version number but this product as
you'll see has many optimizations for
the embedded space so if you just just
look at sort of the the spectrum of
sizes of embedded from small to large
you know they're different requirements
different components that you need to be
aware of from the specific use case for
example on the left java card secure
element so you're not using that really
for much processing it's more of a
security aspect all the way to large
systems which may have high process
high-end processes which probably are
less cost sensitive which can afford to
you know spend 120 megabytes or more for
the java runtime and anything in between
and an oracle offers solutions in each
one of these spaces the space we're
talking about specifically is on the
small side under the general embedded
column right so we're not targeting the
Java card space which is very dedicated
but what we are dead what we are
targeting is the space of a general
purpose
embedded systems that are resource
constrained now of course the benefits
across all these platforms is you know
the Java platform the libraries the
runtime the program methodology the
portability okay so last week on Tuesday
we release this new product here's a
high-level overview so it's what we call
a high-performance java runtime for
small embedded platforms it's
specifically dedicated of functionality
for small embedded so it's a it's
actually a complete stack a complete
java runtime currently it's optimized
for low footprint arm architectures and
i'll talk about which architectures
specifically some more because the
embedded space is so diverse and has so
many different requirements use cases
platforms we made it very extensible and
portable so you know oracle is never
going to be able to deliver solutions
for every embedded market out there we
need to work with partners to deliver
point solutions for specific use cases
so this platform is designed to make
that easy and then it also has a number
of specific embedded features and ap is
that allow you to do sort of the typical
things you need to do in an embedded
system and we'll go into that some more
on the right as I said this is based on
Oracle's existing product line in the
mobile space so we could reuse a lot of
that functionality the vm a lot of the
base libraries the porting layers
because they're very similar between you
know these spaces that both resource
constrained spaces mobile and embedded
so we use that it's a very mature
high-performance optimized vm we're also
including a number of standard api's jsr
s for various functionalities that we'll
we'll talk about
on the lower left so as I mentioned this
having Java on your embedded device
really allows you to or really gives you
this flexible services platform where
you have the device sitting out in the
field and you can update and upgrade the
software over time right as you find
maybe bugs security issues you want to
enhance the functionality or you know
the standards that you have to support
need to change right so there are many
reasons for for why you would want this
um and I'll go into this a little bit
longer but that's it later but this is a
key feature of you know John limited
space in general and then we're
supporting the platform or the product i
would say with a tool chain of course
developer productivity in javas is
always been very important so we'll talk
about the toolchain we have a new
version of the java me sdk and we have
plugins for netbeans and eclipse okay
it's go a little bit more into detail so
I mentioned there are unique embedded
features in this product so the vm is a
multi tasking vm so you can actually run
multiple applications concurrently still
be very memory efficient these
applications can talk to each other so
you really have a pretty rich platform
to modularize your applications and
create sophisticated algorithms um it's
been designed to be very robust and
allow 24 by 7 operations so on it can
monitor resources it can clean up memory
usage it can shut down misbehaving
applications without impacting the rest
of the system over the years over the
years it's been tuned in many ways for
footprint and efficiency on the right
you see some numbers so the typical
actually I'll go into that some more
later but if you really are pressed for
space you can actually cut this product
down to use as little as 100 30
kilobytes of RAM um and then finally on
the left we have some options to
configure the the vm itself in in the
field while it's sitting out in the
field in case you need to make changes
to the way the vm operates it's designed
to be fully headless so currently the
product is is headless so it doesn't
support any graphics or UI we're
targeting the deeply embedded space
where you typically don't have a user
human-machine interface so all the
functionality of the product can be
remotely triggered through extensions
it's we have a variety of connectivity
this is important for this space because
these devices typically are connected
either through Wi-Fi or through a
cellular network or proprietary radio
network so we support all these
different kinds of connectivity you can
as an application developer when you're
developing your application you can
actually access hardware directly from
Java so this is something you typically
can't do in a Java system but you can
talk to peripheral IO directly and then
as I said it's very extensible so the
OEMs or partners downstream can take
this this stack and create a customized
versions for their specific use cases
let's see I think I discussed most of
the other things we'll talk about the
footprint and the architecture some more
oh yeah one one more thing maybe
automatic start up in recovery so again
that's um very relevant for this for
these types of use cases where the
device is sitting out in the field
something might go wrong right and the
system can restart applications can
detect when applications are misbehaving
and try to fix them you know restart
them so remote operation is is designed
in
okay so some more about the the types of
devices that were targeting with this
platform so as I said we're trying to
implement a general purpose small
embedded platform that's really
applicable to many types of markets in
use cases so currently we're supporting
arm architecture system oh no chips
system-on-a-chip platforms so that
includes um arm9 arm11 cortex-m cortex
our cortex a so that covers a really
broad range right from cortex-m
microcontrollers with you know very
little memory very small footprint by
cheap all the way up to pretty powerful
cortex a systems which are used in micro
servers and things like that as i said
the type of device we're targeting is a
resource-constrained headless always on
about the system the platform can scale
up right you can go to larger systems
you know with many megabytes of memory
we're not just targeting the very small
space in terms of operating system you
as an application developer don't really
care you never actually see the
operating system but of course for the
implementer for the OEM or partner they
need to choose a simple kernel or some
some more capable real-time OS where our
product is very flexible as I said
networking we support essentially any
type of tcp/ip or IP connectivity could
be UDP as well including the ability to
access multiple channels communication
channels by the application so for
example one use case is your your device
is sitting out in the field in some
remote location and your wireless
connectivity might not be very good
typically what we're seeing is that
customers actually have multiple SIM
cards multiple cellular interfaces on
these devices so they can switch between
these
two interfaces are depending on you know
the time of day the cost the data
transfer rate and other algorithms so
our API set actually allows an
application to do that intelligently
based on some policy peripheral I oh we
can as a developer you can talk to all
this I oh so serial file g pas various
industry buses like i square C and spi
and I'll give you some examples on that
but you can essentially interface with
most of the hardware that's connected to
your system in terms of footprint so the
standard configuration if you want all
the features um you're at about seven
hundred kilobytes of RAM so it's a
full-blown Java platform with everything
um that's already pretty good and as I
said if you are really pressed for space
you can slice and dice it to go down to
130 kilobytes roughly of RAM you know
with a loss of functionality and there
is some custom work involved but that's
possible but to give you an idea you
know even in the microcontroller space
there are many platforms now that
support one or two megabytes of memory
and so this this runtime will easily
work in that space without any extra
effort so these are the types of use
cases that we are seeing that we believe
on this this product is very appropriate
for so wireless modules as i mentioned
Centurion is one of our strategic
partners they have implemented this on
their on a range of their products very
cool devices by the way you should you
should look at that some more they're
highly integrated little you know chips
that contain everything you need
complete Java Runtime run off the
battery you know cellular connectivity
very cool we see into industrial control
use cases um there are actually some
smart centers smart meter
women's already is also in the medical
health tail health space where people
are using these systems to provide you
know better patient monitoring and
patient care and then as I said because
it's a generalized platform we see it
applicable to the whole machine to
machine space in general so you know be
it logistics or be it you know things
like that environmental monitoring
whatnot okay so that was a high level
product overview let's dive into the
functionality some more all right so
this is a bit of an eye chart um you can
see there's actually quite a bit in this
product or related to the product so
let's start at the bottom we have the
hardware so these are the different
devices right networking file GPS and so
on so these are all supported by the by
the system you have some sort of
operating system as I mentioned it can
be very simple on small currently we
have so the shaded the green greenish
color the win32 emulation port and the
reference board port so these are two
two platforms that we're supporting
initially with this product and and then
of course we're hoping and expecting
that our partners will provide
additional ports to other platforms as
time goes on we have a porting layer
which makes it very easy for you to port
the system to other platforms as I
mentioned it's a standardized layer and
you basically just hook that up to your
to your operating system in your device
drivers and you're ready to go at the
core from a Java perspective you have
the cldc virtual machine um I think
that's you know pretty standard no
surprise that's what we've been using in
the mobile space for years it's been
enhanced with as I said multitasking
support full headless on-device
debugging and this VM configuration
feature
and I'll show you hopefully an example
of on-device debugging later the the
profile with using currently is IM P&amp;amp;G
if you're not familiar with that so its
information module profile next
generation if you're not familiar with
that it's essentially mid p2 without the
graphics so if you're familiar with mid
p2 it provides you an application model
a set of api's connectivity it's a
pretty nice um application environment
and it's perfectly targeted to this kind
of platform all right and then we have a
bunch of features on top and api's for
your application so we have all these
jsr s on the right so its standard AP is
for file web services security and Trust
messaging location and XML processing so
these are all things we believe are
useful in this connected smart device
space typically you want to you know you
need connectivity you want to talk to
some other device you want to exchange
data maybe that's you know an in form of
a web service or XML you might want to
be able to receive messages for
configuration and and remote management
purposes you might be able to you might
want to talk to a local sim card as a
secure element store data locally on
your flash card so all these things are
possible and then on the left the
greenish api's these are new API so
they're not jsr standards the new API is
that we developed for this type of
embedded use case so the logging API is
pretty straightforward as allows you to
do logging it's a logging framework
logging is very important for these
kinds of use cases and you can actually
plug in remote logging handlers as well
so you can log to a remote system if you
need to do that there's this access
point API which I mentioned before that
is the API that allows you to select
between multiple communication channels
so you could say all right so I'm
opening you know my wife
I can actually if I'm in a certain spot
where I have Wi-Fi coverage and then
once the device moves out of that area I
switch to a cellular connection but I
reduce you know my data my bandwidth
needs so that's possible from the from
the develop from the application
perspective to do that we have the
device access API so that is the API
that gives you access to all the i/o
down there your peripheral io that you
need to integrate with sensors for
example or actuators things like that we
have the AMS API this is application
management system this is actually
really interesting because it's a
complete API that allows applications to
control the behavior of the system and
the applications on it so the MS API
allows you to install well it allows you
to verify which applications are running
it allows you to install stop-start
update applications so you're in
complete control of what's happening on
the system of course this is subject to
permissions so you could build like a
system controller application that has
the right permissions that essentially
manages all the applications and the
components that run on the system very
important for again remote management
remote update ability features use cases
and then finally we have this extension
API that I mentioned before where you
can add your own features for specific
markets your applications sit on top so
you just write regular Java applications
that comply with the IM PNG or the mid p
application model pretty straightforward
you can run multiple of them as i said
because it's a multitasking vm they can
run in parallel
on the right you have our tools support
so we have the Java ME SDK this has been
updated to support this product and the
embedded features we also have plugins
if you want to use netbeans ide or
eclipse we have plugins that extend the
ide to support on this product so you
can actually develop deploy debug right
in your IDE as you are used to with
other platforms and i'll be showing that
in the demo in the right corner the the
white area this is services so this is
not part of the product but this is an
important way the way we believe this
product will be extended into the market
by partners or by Oracle to take this
platform and port it to other platforms
take the software put it to other
platforms integrated with solutions
specialized it for particular use cases
any questions so far you're all still
asleep we should be handing out coffee
here anyway so um platform support yes
so as I said we're currently supporting
two platforms the first one is an
emulation environment for windows 32 so
that allows you to essentially develop
and run your application on your desktop
this is integrated with the job in the
SDK so it's all you know all in the box
um you just download the Emmy SDK and
you're ready to go this is available
today what we're planning in the near
future is to have a reference binary for
an actual piece of hardware of course
you know that's where the rubber meets
the road you need to actually have real
hardware to play with a Malaysian
doesn't cut it if you want to build
something so
we are targeting one of these eval
boards and I'll show it to you in a
second the Kyle board this is based on a
SD micro chipset which implements an arm
cortex m3 so it's a it's a very common
chipset that you find in many embedded
platforms and so you can buy the the
Kyle board online with distributors
around the world it's about three
hundred fifty dollars us it's an
evaluation platform so it's pretty big
it has lots of oil to you it's this guy
here so lots of all the i/o is broken
out this is of course not the platform
you would deploy it's much too big and
too expensive but it's a very good
developer platform so this is coming
very soon we got stuck in some paperwork
just before the release so it's all
ready to go but we need to clear that
paperwork and so will hope to have that
available soon so the way that that's
going to work is you can buy the board
at a distributor I have a chip to you
then you can download our binary from
otn with a developer license so it's
free for for developer use and you
basically just flash it onto the board
and hit the reset button then you have a
java runtime and you can start
programming um if you are if you're
somebody who is looking to actually
deploy this in a in a specific market
solution and you need other platforms to
be supported let's say you have some
optimized arm-based little environment
that you're you know little platform
that you're using for your your solution
then come talk to us arm or to an Oracle
partner and we can make that port happen
so I think we walk through most of these
you can see this is a pretty pretty
comprehensive set of j srs especially
for a small embedded platform this is
one of the benefits obviously over
native right if you had a native
solution you either
wouldn't have all this functionality or
you would have to integrate it yourself
from different pieces and components
with different api's these are all
standard ap is that people have been
using on on Java for a long time so you
can see on the Windows platforms all of
these are supported on the on the Kyle
board on the eval platform in some cases
hardware is missing so we can't support
it for example there is no cellular
interface so we can support message
while its messaging but if you want to
develop and test against that
functionality can use the Windows
emulation okay so to go into more detail
on the embedded features I think I
mentioned some of this so we have the
AMS which allows you to control the
applications that are running on the
system including installing and updating
them you have life cycle what we call
life cycle notifications so if you're if
you're running applications and they
have errors or they terminate for some
reason um your system controller
application actually gets notified and
then you can do something about it for
example we started or you'll send an
error message back to the server so i
said you can auto start and restart
applications if the system you know
comes up after a reset it can restart
automatically I spoke about device
access API logging access point AP i--
debugging i will demonstrate so you can
debug over an IP connection like an
ethernet connection you can debug on the
device in you know java level debugging
so very very comfortable so I spoke
about all these okay so here's the board
I did have a picture so this is to give
you an order an idea of the the order of
magnitude this is a 120 megahertz MCU so
it's not extremely fast but it's
actually for a microcontroller type
system it's it's pretty powerful has two
megabytes of RAM on the board and eight
megabytes of flash
so we can very comfortably run the
system we need about seven hundred
kilobytes of RAM so we can run
comfortably as I said it's readily
available the things we're supporting um
with the product today are the
networking stat so tcp/ip through
ethernet there's a little SD card on the
right the little connector so you can
plug in an SD card and access the file
system to store data there's a serial
port that you can use to talk to other
devices and then any device that's
attached to any of these bus systems i
square CSPI GPL when we mapped devices
so you can talk to all of these devices
as I said we're not supporting the LCD
screen on here that's currently only
used for diagnostic messages but
applications can't actually access the
screen yes what's the operating system
below its all Linux is way too big for
these types of platforms no so what we
actually have here is a small embedded
real-time colonel that's running and it
but it's it's pre integrated with the
binary you get from us right so you
download a binary and you flash on to
the device and that's all you do it's
statically linked by new that contains
the whole thing so it's operating system
drivers Java Runtime everything in one
binary and you never see the operating
system anyway
so is that the general approach it
really depends on the platform in your
use case um typically the way the
embedded space works is armed for many
dedicated solutions that are very
resource constrained you typically have
all of the software you know bundled
together in an image these operating
systems that you're using are typically
not powerful enough for you know don't
want to support things like dynamic
linking and loading because you just
don't have the power and the memory
space to do it so once you get to I
don't know maybe eight or ten megabytes
of RAM you can afford a small linux
kernel but even then you might not want
a Linux kernel because it has so much
overhead so typically what you do is you
have this embedded OS realtime kernel
you statically linked it with your with
your runtime and just burn it into the
flash of the system that's how most
emitted devices work and a lot of the
features that you get from a bigger OS
like Linux for example you know
multiprocessing or the ability to load
and execute applications dynamically you
get that from the java runtime anyway
right so the java runtime allows you to
install and run different applications
it allows you to run multiple
applications concurrently so you don't
really need linux or you're more capable
OS anyway and it just makes things
difficult basically for you you want to
get away from the native layer that's
the whole point so here here is an
example of a sort of a typical
application this is actually running on
our booth in the demo grounds so if you
look for the Java ME embedded booth
you'll see this demo this is sort of a
typical scenario of how we we envisioned
this product is used so this is
industrial
type application where we have on the
far left we have this tilt and pan unit
with a solar panel solar panels actually
not pictured here so that's being
controlled the servers are being
controlled through a server controller
from the device and there's a light
sensor on it the light sensors connected
through the i square c bus and so you
can run applications on the board that
implement some kind of algorithm for
example you know find the brightest
position and position the unit that way
you know optimized for for energy output
or you can implement a tracking
mechanism you can implement you know
error detection mechanism so you can
implement different types of of business
logic application logic and algorithms
because you have a java runtime on here
and you can swap out applications but
not only that you can interface you can
implement a local HMI local user
interface so you can use the push
buttons the joystick and the LEDs arm to
provide a user interface very simple
simple one two you know for an operator
for example to control the device and
because you have a complete java runtime
including networking stack you can of
course talk to other devices and other
platforms so what we're doing is we're
actually connecting this system to a
back-end server so we're running a java
ee server on a separate system which in
this case is used for statistics
tracking so the device every couple of
seconds send statistics data about the
you know the brightness and the position
of the sensors back to the embedded
server back to the enterprise server so
you could you know monitor perform
monitoring and data analysis for example
on the server we also have it connected
to a PC which is running a javafx client
and it's like a graphical remote control
of the system so you see all the
parameters of the system you can
actually remotely run applications on
the system through the pc
and so so you know what we're demoing is
the the fact that you can integrate
different hardware pieces that you can
control them that you can run different
types of applications implementing
different algorithms you have the
connectivity the back end so you can you
know talk protocols to the server you
can be remote controlled remotely manage
so these are all sort of the typical
requirements that you would have in a
system like this so this is something
you can look at at the at the booth okay
so we can have a quick demo so I'll
switch over actually okay let me show
you the code first so this is a really
simple example that comes with the Java
me sdk it shows you how to use the GPIO
port so the GPIO ports on this board are
connected to the buttons and the LEDs so
you can register button presses and make
the LEDs flash this is how you would use
the API so there's a GPIO manager you
would get a pin an object that reference
is a certain pin in this case a pin
that's connected to the LED you would
use the manager to get a pin that's
connected to a button and then you can
register listeners on these pins so if
the value changes your listener gets
called the value chain event changed
event and then you can do something to
react to that so in this case you know
we get the event we get the pin that was
was associated with this event and then
in this case we're setting the LED so
we're basically just making the LED
blink whenever you push the button the
LED changes state so very very
straightforward let me show you how it
works
okay this work excellent all right so we
have NetBeans here NetBeans with the
Java ME embedded plugin you can use
Eclipse just as well and we have this
little sample code that's part of the
Java ME SDK so it first you know defines
the various buttons and pins and LEDs
then this is the typical mid peor I in
PNG lifecycle application model where
the system calls your start app method
so in the start app method this is you
know called once when the application
starts so here you grab all the
different handles to the various buttons
and LEDs us and once you have those you
register different types of listeners
all right so pretty straightforward and
that's all you do for initialization so
then we're not doing anything else we're
just waiting for the buttons to be
pressed if button one is pressed we
execute the value changed method as I
said before and we basically just set
the value of the LED one to either
button being pressed or not so true or
false so when we press the button the
LED goes on if we press the if we
release the button the LED goes off
again so pretty simple just to
illuminate how this works from a
developer perspective now when you
install the Emmy SDK or the NetBeans
plugin you get this device Emily
which is a complete runtime java runtime
that emulates all the aspects of the
system on your desktop so we can use
that without any hardware attached to
start developing applications right so
what we do here is we go into the
properties first we have to select that
we want to use this device so we go okay
we use this device the simulation device
and so I my system is really slow since
i installed corporate virus checking
it's been bugging me down okay so I hit
the Run button and netbeans goes off
compiles the application and starts the
emulator which should pop up in a few
seconds okay here we go and it
automatically runs the application so i
don't know if you can see that this is
red I can't can't make the the blue
background go away so it's running the
GPIO demo you can see here you can
actually control the application state
so you can stop it you can suspend it
you can remove it so this is basically
what you can do in in a deployment
environment right your management system
can remotely start/stop install
applications this is replicated here and
if you go to the GPIO tab you can see
the state of the system so the two LEDs
and the three buttons currently are not
pressed or not illuminated and then we
can open the emulation of these external
events so now what we're doing is we can
basically pretend to push buttons on the
device so here are the buttons and so if
we push this button you can see that the
state changes down here and we actually
see in the output right we have a print
statement so our listener was called and
the state of the IO change so the button
was pushed and the LED is on if we push
it again the button releases in the LEDs
goes off again because that's what our
listener did right so pretty simple
there's much more you can emulate you
can emulate a file connection so you can
actually designate a part of your file
system on the desktop to behave like the
file system on the device or you can
simulate GPS coordinates and events you
can simulate different sim cards for
different connectivity so there's a lot
of functionality there but let's stop
this and show you how to do this on the
real device yes sorry I can I can't he
you know so can you can you use this
functionality for automatic testing it's
basically externally injecting events um
I don't think you can do it right now
but I know that our internal testing
teams are doing that so there might be
hooks into the emulation I could check
for you not sure could be yeah if you
give me a business card I can I can
check and let you know all right so
let's go back to the device so the first
thing I'll do is I will go back into the
properties and say I want to use this
external device for my development so i
have it hooked up
it's powered through USB the USB is not
doing anything except providing power
you can already see that some of the
LEDs are on from my previous run and
then I'm just connected through ethernet
directly our local connection you can
see the vm when it boots up it gives you
some messages it tells you the IP
address and it says starting Java ME
embedded so what I'll do now I switched
the device and I'll just hit the Run
button again like I did before again it
compiles the app and then actually
deploys it onto the device over the
network connection so it whoops yeah
it's scrolling back to too quickly but
if I run the app it's so the app is
automatically running now and if i push
the buttons i don't know if you can see
it then the leds change right so it's
it's actually running on the board now
more interesting is to debug something
right this is the holy grail of embedded
development is being able to debug
directly on your target because that's
typically difficult or not possible so
i'm just using instead of the run button
i'm just using the debug button and
recompile is the application with debug
symbols um starts the debug listener and
connects to the debugger here on the
system and then i can set ok it switches
to the debug output so you can see now
there are some threads running um
nothing's happening because I haven't
pushed the button and I haven't set a
breakpoint so I'll set a breakpoint up
here on the value changed listener of
but one so if I hit button one you can
see the green symbol here which means we
hit a breakpoint and win this code now
right so i can do single stepping into
the code i can actually look at um some
of the objects so if i hover over here
it should give me ok here it gives me
information I you know this works just
like any other source level Java
debugging but
we're doing this on an embedded target
right which is for you as a Java
developer you go like yeah sure why not
right for an embedded developer this is
like whoa this is cool okay so that's
pretty much it so it's really really
easy to get started as I said right now
we have the we have the windows 32
emulation which is packaged with the SDK
for you to get started and then the
binary for the board will be available
soon so wrapping up so I hope that gave
you a taste of what we're up to I am
very excited about this because this is
really the first time that Oracle is
creating a standardized horizontal
universally available small embedded
product with tools and hopefully we'll
see this and you know many many devices
out there you know I always like to say
the next 10 billion at the show there is
actually a lot going on in terms of
embedded here are just some highlights
of some of the sessions there is a
session right after this talk i am
talking tomorrow with Folker battery who
is one of the spec leads another speck
lead Michael legali is sitting here in
the audience if you want to ask him
about embedded Java specifications
you'll have a talk as well there is as
you know there's a whole dedicated
conference for job embedded it's called
Java embedded at javaone that's tomorrow
and Thursday it's a hundred dollars
extra if you have a job one ticket
already Java one pass so you can go to
that it's business oriented so we're
talking about you know value add value
proposition about use cases target
markets for embedded so it's pretty
interesting conference i'll be talking
though as well and then go check out the
demos and the demo grounds including
some of the stuff i showed you today
there's a lot on OT n on Oracle
technology Network on basically just
look for oracle embedded java you'll
find it
we have all the documentation of this
product is up and ready so we have
getting started guide shows you how to
write your first application within half
an hour we have frequently asked
questions if you want to know more about
the product sample code data sheet what
not armed and then my blog I try to keep
abreast of what's happening in the
embedded java space I don't blog as much
as I want to right now because there's
so much other stuff going on but um keep
that book marked and yep so Java is the
platform for embedded devices and this
product is our entry into this market as
a standardized product so we believe it
has great potential and come back soon
for the cortex and release and let me
know if you have any questions and I
think that's the end of the talk thanks
for coming this early yes
right good question so what about real
time so this product is not designed to
be real time we find that real time
applications have very specific
requirements in terms of memory budget
in terms of you know performance anyway
obviously and you also have to you need
to basically change the semantics of the
Java language right if you want real
time in Java because you know if you can
have a garbage collection happening at
any time and you as a developer cannot
specify that you want to avoid garbage
collector right now right then you're
never going to get real-time behavior
that's why there is a separate real-time
spec jsr one RTS because you make
changes to the semantics of the Java
language so we didn't want to do that we
find that the vast majority of embedded
use cases don't require real time if you
still have a real time application arm
there are two ways to do this um the
first way is you have some native code
and you use the native code the native
real-time features of the underlying
operating system right so we have a
real-time operating system underneath
this platform we're not using the real
time features but you could write a
little piece of real time code that runs
on that platform on that OS that just
grabs the data sticks it into a buffer
somewhere and then you can process it in
non real-time on the Java level right
that's one possibility the other
possibility which we find more often is
that you have a small dedicated embedded
system running separately so that can be
a tiny controller with some interfaces
that just all it does is just grab data
from the data source and stick it into a
buffer and then you have your your Java
system which is decoupled and just reads
that data and processes it right makes
the software architecture much easier
and you don't have to make any changes
in the Java semantics so that's what we
typically see if you have real hard
real-time
requirements and you want to use Java
then you should use a dedicated Java
system Java real-time system but then
you pay for it in other ways right you
pay for it in footprint in overhead in
programming you know programming
methodology changes so there's a cost
associated with that you don't get real
time for free so yes another question oh
good question yes so as you noticed
right now we're using cldc one which is
you know kind of old outdated small cut
down version of the java language will
that change over time absolutely so if
you listen to the other talks there is a
seal dc-7 cldc eight coming along which
essentially lifts small java runtime up
to almost all of the java 7 language
features so you'll have generics and
annotations and all those nice things as
a side benefit that means you can take
existing library code that was written
for java SE and put it on your embedded
platform without having to change the
code itself right now you might not
always want that because the code was
designed you know with large resource
you know intensive operations in mind
but fundamentally it makes the platform
much mohamed genius so that's coming are
planned for next year not until well we
first have to update the COTC spec to
seal dc-8 and once that's done and
approved then we'll do an implementation
of that so michael is right here there's
actually another time
by Roger Riggs I think right after this
where he also goes into some of the
features of cl dc-8 I think it's called
the Java plateau of me platform let's
see service platform I think that's the
59 43 but yeah talk Michael is suspect
Lee 44 cldc eight so he can ask him any
other questions so the actual when you
actually go to deployment what would the
cost be um well it obviously depends on
the hardware the hardware is the biggest
cost varies widely I mean anywhere so so
cortex m3 system on a chip the chip
itself in volume is about three dollars
you can get very small developer boards
with cortex m4 chips on them for about
fifteen dollars u.s. dollars and that's
a developer board so you can imagine
once you shrink that down into
production you're probably talking a few
dollars there is of course a licensing
costs for the Java Runtime that you
would have to pay Oracle or your partner
but that's typically you know much
smaller than the hardware costs so I'd
say a final system for production is
probably anywhere from a few dollars to
thirty forty dollars anywhere in that
range you can get the the Centurion
modules which are very powerful and have
you know cellular interface and pretty
powerful platforms I think they cost
roughly 50 US dollars or something in
that order of magnitude
um but they might be more powerful than
what you need so we're really targeting
you know very very small cheap devices
that can be deployed in millions that's
the idea okay well thanks a lot for
hanging out and enjoy the rest of the
show</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>