<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Rendering in JavaFX with the New Canvas Feature | Coder Coacher - Coaching Coders</title><meta content="Rendering in JavaFX with the New Canvas Feature - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Rendering in JavaFX with the New Canvas Feature</b></h2><h5 class="post__date">2013-01-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/V2yXGdC98jM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everybody my name is John Drayson
graphics engineer for JavaFX
and this is Jim 2d graphics architect
and we're going to talk about the new
canvas feature and JavaFX 2.2 how it's
different from scene graph and the
goodies inside some legal stuff so what
we're going to talk about we're gonna
put some context around canvas and talk
about the scene graph rendering API very
briefly and then go into an overview of
the canvas rendering API kind of the ins
and outs of what what we did and then go
into some example applications problems
you may run into solutions and then if
we have enough time we can go through a
ton of demos and answer questions and
another thing too is that the strata the
this talk is going to shift from talking
about API to talking about strategies
when you would want to use canvas when
you'd want to use the scene graph not
necessarily saying canvas is better than
the scene graph it's just there are some
cases where maybe canvas might be more
useful or easier to use than the scene
graph
so very briefly many of you if you know
JavaFX has a scene graphs model of
rendering which is basically just a
graph of note objects nodes are
traversed and then those results are
rendered to a destination which can be
now in 2.2 we have rendered an image so
it could be an image it can be a scene
so the destination can vary nodes we
have rectangles circles ellipses
controls various kinds of nodes and a
node provides different features with
the scene graph animation layout effects
properties that you can animate and
things and the canvas rendering API
canvas is rendered as an image and
canvas itself is a node but when you
render to a canvas your using method
calls and it's kind of an immediate mode
style kind of API so in the scene graph
where you're creating a rectangle object
and then adding it to the scene to the
root of the scene for canvas you're
creating a canvas adding it to the root
of the scene and then saying getting a
graphics context from it and saying you
know gee draw rect or G dot fill rect or
what have you so one of the one of the
big points about canvas is it's
persistent so when you write pixels or
write or render to the canvas it is
going to stay those pixels are going to
stay there until you clear them and
lastly as you'll see some of the API
from Java FX blend modes effects and
colors paints those are applied to the
canvas API as well
so Jim's gonna okay so I'm gonna briefly
go over the the API for canvas show you
how it compares point by point to what
we've done with seeing graph nodes
previously so that the basic API is as
joe said you have this canvas object in
a new package JavaFX seeing canvas which
is a node and use that to hook yourself
into the scene graph it provides a
method to get a graphics context and
there's one of those graphics contacts
per canvas for the life of the canvas so
if you keep calling that you'll get the
same context back with the same state in
it so you have some persistence of you
can call that and get a rendering
context from every anywhere it'll be set
up as you previously set it up the
context has a bunch of setters and
getters for various rendering attributes
it has methods to render actual
graphical objects it has a graphic state
stack so that you can save and restore
your say state to do temporary changes
that only affect a few calls and they're
returned to the context you came from
and it has a current path instead of a
path object which is more of a
postscript style of rendering than a
Java 2d style of rendering or a path
node style of rendering so what kind of
attributes do provide basically they're
almost all one for one similar to an
attribute attribute you would find on a
shape node but there are some
differences in how they're interpreted
so for instance it has a set fill and a
set stroke which sets the paint for
filling and stroking
in the node in the shape node if you set
a null it means don't fill or don't
stroke this object on a canvas you can't
set a null because the paint is just
always there available well for when you
call Phil something or draw something
there needs to be a paint because you're
calling Phil something so we never we
don't allow the nulls
Cetaphil rule to change the fill rule
from even-odd to non-zero in a shape
note if you sit if you say set fill role
of null we just ignore what you did in
the canvass if you set a null we just
pick a default non zero so it basically
becomes a way to say even odd instead of
nonzero but we just applied an
interpretation to null similar to and I
think we didn't mention this yet but we
kind of modeled this loosely after what
they were doing with html5 so that html5
programmers would be familiar with what
we're doing and in html5 because if you
set an unknown value it interprets it as
nonzero so we're kind of doing that here
you can set an effect on a node which
will apply that effect after the node is
rendered and you can set it on a canvas
which would apply after every single
rendering operation and in both cases if
you said it's a null it means there's no
effect that's going to happen you can
set a blend mode which controls how your
pixels blend into the stuff behind what
you're rendering and on a node if you
don't send one set one on a node it
means use the blend mode that was set by
one of your parents in canvas we ignore
the null because you always have to have
a blend Motors there's nothing to
inherit from it's an immediate mode API
all the stroke attributes on the that
main one of the main differences is on
the shape node it's a full node with a
huge number of properties in a number of
different namespaces so being saying
something like set width doesn't make
sense when it's got a lot of things that
have width on it so it tends to have all
of the method names be set stroke
attributes set stroke this other
attribute whereas on canvas it's just a
rendering API so the names are a little
bit simpler so you'll see set stroke
line cap which is very verbose on the
node because it has a rich namespace it
has to compete with and just set line
cap on the canvas
again for example of with the the
shape-note allow you to set it to
anything but it will clamp it to be a
positive number
canvas has specific rules that we
adopted from html5 about ignore 0 any
negative number or any infinity and just
don't change the value and similarly
shape will default if you set a null for
the line cap of the line join join
whereas we simply ignore them on canvas
because that was more in line with what
the html5 did the miter limit was just
clamps to a useful value on the node and
we ignore the standard values from html5
the clip attribute is fundamentally
different shape being a node has a set a
an arbitrary clip that you can set which
can be any node and it uses the visual
representation of that clip node to mask
what this node renders which is very
flexible and very you can do a wide
variety things you can even set a group
to have a whole bunch of objects that
contribute to what is clipped against
this node whereas canvas has a more
basic typical graphics interpretation of
a clip which is just there are a bunch
of paths and you can add a path or you
can't add a path to a clip you can clip
to a new path which intersects the old
clip with the new path so it's
constantly getting smaller as you clip
two more paths the font and text
attributes all use the same objects that
that the text node used but it's the
names are slightly different because of
the change in name space and also of
what we do in in some default cases is
different there is a default font that
the the nodes will use if you set set it
to null
we ignore it as per what html5 did there
were a couple bugs that ran into when
coming up with a slide the null for text
alignment it looks like it's supposed to
be ignored but there's actually a bug in
that they try to dereference it they get
a null pointer exception and it's at a
part of the scene graph which basically
it's bad don't cross the streams so you
can look up those bugs and hopefully
they'll be fixed soon but it's it's not
bad in that your machine will die but
your scene graph won't be happy after it
but in all most of those cases I believe
that if what did what it looked like it
was intending to do was to ignore the
value the basically setting an alpha is
like a fade on an operation so on a node
we call it opacity in the whole node
fades as you as the alpha goes to zero
for rendering it's an additional opacity
on top of the paint's opacity on every
rendering operation and in in html5
parlance they call it global alpha
instead of opacity finally transforms
nodes tend to have objects you can set
they have a few helper methods you can
set a scale on your X using a single
method of our single property but then
they have a generic observable list of
transform objects for setting everything
else
whereas in canvas it has a current
transform matrix and you modify that
with additional methods in a more
standard practice the rendering
primitives are pretty much the same
almost all of them are on the node shape
side you have a node that is that shape
on the canvas side you have a fill and
Stroke method that fill and Stroke it
the notable differences are that round
rectangle and a rectangle are the same
thing in the nodes you just set an arc
with or not depending on whether you
want the rounded corners in canvas its
separate methods the polyline node
allows you to set a fill so you can fill
a polyline
than though that's really what a polygon
is for but it still lets you fill it
there is no fill polyline method on the
canvas because you should be using fill
polygon if you're going to do that and
finally on the paths there's obviously a
node for the the scene graph and in
canvas rather than having one fill path
method that takes a path object as an
argument it has a current path that you
build in the graphics context using
methods and then once you've built it
there you call the method fill with no
parameters that means fill that current
shape or stroke it or use it as a clip
path
finally for image rendering they both
use the image object but you embed that
in an image view for a scene graph
whereas you just call a draw image
method for canvas path elements are
mostly the same just the names have been
changed there's a list on a path node
that you can clear on a canvas you call
begin path to clear out the existing
path and slight slight name changes on
some of them we tended to follow the
html5 naming conventions and the only
difference in behavior is that the arc
node and the the arc primitive on canvas
actually do different math the the
canvas which is based upon html5 follows
the PostScript our operator in the way
I'll show you an example of what it does
whereas the the arc node follows a
different set of math that allows you to
specify with different points and
different radii and how those are
interpreted to construct an arc finally
there is no way to just add a rectangle
to a path nodes
path list whereas canvas provides a
convenience operator called rect which
takes four parameters it adds those as
path segments to the current path and
both of them can take an SVG path
specification
so this is the the different arc they
have in canvas and html5 and it follows
what PostScript does you basically have
the current point you give it two more
points and it it draws sort of a corner
going to the first point through the
first point to the second point and at
the corner it inserts an arc of the
appropriate radius and you notice from
the middle example if the radius is
large enough that arc can actually be
inserted behind you opposite of what you
were expecting we have a double will
show later because we have to switch
machines it's just not worth it for
right now but I'll show it to you later
and okay the state stack
it's very postscript like it has a save
and restore which is like PostScript G
save G restore it saves and restores
almost the entire state that you would
think except for some reason the current
path was not part of the graphic state
in html5 and we adopted that the current
path is part of the state and PostScript
which is kind of one place where they
kind of broke with a postscript
rendering convention and we followed
that instead of doing the PostScript and
unlike PostScript which I think has a
constant deferring to how many times you
can save and restore we just let you to
save until we run out of memory
so hopefully you won't save a billion
times and run over your 12 gig of memory
on your desktop and the state and that
in this graphic state stack are the same
every time you call get graphics context
2d that doesn't reset anything the
object is in the same state as it was
the last time you used it so we
preserved all the state and the whole
stack of you can save go away and a new
method could start up use it and restore
and you'll restore to the state that was
saved over in the previous event handler
so it's probably bad programming product
kind practice I'm not saying to do that
I'm just describing the behavior of the
object
miscellaneous you can if you came to the
image ops talk yesterday we talked to
about all the things you can do with a
pixel writer which is basically set
pixels and set rectangles of pixels from
a buffer and you can get one of those
objects from a graphics context and use
it to push your own pixels there's an
apply effect method which does something
that isn't really available anywhere in
the scene graph which takes the whole
canvas with everything rendered into it
up to the current point and applies an
effect to all of that it would be kind
of applying an effect to whole scene
except it just does it and then the
results are back in the in the canvas
and you can do it again so you could
apply you know a blur over and over and
it would get really really blurry over
time as you applied it over and over
because each one is applied to the
results of the next that go back into
the canvas it also does have a set
effect but that effect is applied only
on a given rendering operation actually
on all rendering operations but
individually so if you set it and then
you say fill rect we will apply the
effect to that fill rect and then put
that in the scene and if you follow that
up with fill oval the effect is still
set we'll apply it to that fill oval and
put the results of that affected oval
into the scene and then finally the clip
intersects the current path with the
current clip similar to the way
PostScript works there is no set clip or
reset clip you have to use G save the
save and restore commands if you want to
apply a temporary clip and then back it
out because there is no way to reset
that back to Joe
all right so now we're gonna kind of
shift
themes here and go into like strategy
you have the scene graph you have canvas
rendering API is when would you want to
use one over the other and so on so pros
of the scene pros and cons of the scene
graph obviously you have picking you
have the timeline and properties that
you can animate and you know for
interactive components buttons and such
in your UI it's it's pretty easy in the
scene graph obviously to implement that
stuff and the big con of this the scene
graph is kind of the the idea of
primitives via objects so you have to
define lots of objects to get the
rendering you're looking for where if
you're doing a simple rendering it can
maybe be a little more verbose than then
you want with canvas you know you can
render a shape with one line of code and
the canvas itself is a node so all those
properties and picking and stuff you can
pick on the canvas so you still have
some of that benefit and of course the
the made your callin of canvas is well
all you're doing is rendering you you
don't get any of the fancy stuff which
you know it it I'm putting that as a con
because it kind of contradicts with with
the scene graph in this sense but there
may be a use case that you have where
all you need is rendering so yeah so I'm
gonna go over an example application the
ensemble path preloader so way back
probably about a year man it like a year
ago before canvas existed
we were actually recording the
screencasts that are that are on the job
FX website and we thought man wouldn't
it be cool if we could you know have a
pre loader for Java effects that you
know isn't just a boring you know
animating circle like what if it was
actually a cool-looking preloader and
then we thought well you know that's
kind of difficult because you know it's
just a preload or it can't do anything
complex and well you know soon enough
this is this is what we we came up with
but the scene graph version we render a
path node and then we use two groups of
moving rectangle nodes and then we add a
blend to that group and then we have an
array of path transitions that is
connected each to a node and we use that
to traverse or to animate the rectangle
nodes along the path so we're gonna show
you that one okay which one you
so I'm basically going to show you the
the scene graph implementation and the
canvas implementation so you you want to
go ahead and run it and then okay so can
we turn the microphones on the table on
are they on hello okay
so this this perch is gonna run it to
show you exactly what a preloader is
it's basically a visual eye candy that
can be running while you're basically
loading stuff in the background so this
loads quickly draw something to keep
them entertained meanwhile in the
background you're loading huge but a
huge amount of media or the rest of your
application or whatever and this one is
basically chasing around that that that
word with some highlights so to get that
basic basically there's an SVG path just
finding the the shape of the in Samba
word and that's rendered once to provide
sort of the the etched racetrack that
those highlights are going to run
through and then two groups are
constructed with a bunch of rectangles
in them that will move around following
the the shape of that path with first of
all I highlight color that they're
filled with and then an effect that adds
a glow of the same color to them
so each group has its own drop shadow of
a similar color added to it and then a
whole bunch of rectangles are added into
those groups and assigned to path
transitions so they follow the SVG path
along and again you have to have a path
transition per rectangle so there's two
arrays of path transitions that are
being used and the end result is you see
the dark gray stroke with the black fill
of the of the base rendering of the word
and then the two groups of cyan and
magenta rectangles that are being
animated along it and then blurred with
a drop shadow
it's a great a glow effect okay right
and just for context let's go to the top
for the number of rectangles oh so that
included 2,000 rectangles per per
highlight per highlight its 2,000 sine
rectangles in 2,000 magenta rectangles
chasing around right and okay so that's
the seam graph version okay yep we have
a canvas version that if we we run so
I'll run it first just you can see it
does the same thing yeah exact same
thing I'm using canvas and in this case
it creates so in the previous example we
had two groups that had effects on them
so we had a bunch of reksai and
rectangles in one group with an effect
on the group and a bunch of magenta
rectangles in another group with an
effect on that and with a canvas you can
apply effect to a canvas or you can set
an effect that will affect each
operation you do so the choice is
between set one of those glow effects
and render the 2000 rectangles which
will mean that that effect will be
individually applied 2000 times which
gets tedious and slow or somehow collect
that group of rectangles together
somehow so you can apply the effect to
it and the only way to collect them for
applying the effect to those groups is
by using separate canvases so this is
actually uses these three canvases the
route has that extra race track rendered
into it and then the other two have
either all of the cyan rectangles or all
the magenta rectangles in them and then
every frame it simply runs through and
renders all of the rectangles into the
appropriate groups and at the end
applies the appropriate effect to the
appropriate canvas to get the glow on
that canvas
and so here you have the black canvas in
the background the magenta canvas with
magenta rectangles and magenta effect
and the cyan canvas with the cyan
rectangles and they say an effect and
they're rendered on top of each other
because the canvas is transparent by
default right so between the two couple
of things I want to point out the actual
animation the thing that's that's
driving the animation between the canvas
and the scene graph it's actually more
or less the same the we have a timeline
which is connected to property which is
just going between 0 and 1 and it's it
does it the same in the scene graph and
doesn't the same in canvas obviously the
first example uses many nodes where this
example uses many method calls and then
it also uses the multiple canvases
instead of the group right so for for
this for the canvas version rather than
using an array of path transitions I
just had a a dummy node that was the the
front of the line so to speak and then
the rest of the draw Rex just kind of
filled behind behind that so so yeah ok
I guess we could switch back to okay
yeah
Oh
freaked out here
my slides are coming back me
my slides aren't coming back
detect
it's not detecting yeah it's not
detecting the slides
I think it was that unplug for too long
could be just oh yeah
ah okay crisis averted so we went over
the canvas implementation in the scene
graph implementation comparison summary
right so the many nodes versus one node
animations more or less the same and the
properties are set on the nodes as
opposed to being global attributes that
you save and restore on the canvas so
another example that I wanted to our
concept really is layered rendering like
Jim said canvases are at default
transparent and so you know with layered
rendering you you group commands
rendering commands or rendering
operations into separate images and then
blend them together you know image
composition that's a big part of
Photoshop and a lot of image tools in
canvas this is a really important thing
it can have like visual implications of
using apply effect obviously but also it
has performance implement implications
because you know with the canvas being
persistent it kind of acts like a cache
so you can like in our example we showed
you that racetrack was only rendered
once in the scene graph that's kind of
automatic but in in canvas you have to
really pay attention and make sure that
you're not going to render your path
every time that you you do that do frame
so the setup code would render it into
the canvas once and then we would render
on the other canvases kind of over it
so what does layered rendering get you
in the it gets you like we were saying
you know static versus dynamic content
rendering you can use apply effect to
apply effect to a subset of your
rendering operations and then it's
really similar to a group node but
obviously a lot more lightweight so so
go through this okay so we have from
from here on out we're going to show
various you know maybe problems you
might have with canvas and strategies
that we use for updating or problems
with the scene graph for example so
common problem number one scrolling and
updating I think yeah so in the scene
graph
you've obviously constructed a whole
bunch of nodes they're representing what
you want to render and if you want to
make a change to them so success to
scroll then that can invalidate all
sorts information we've cached about
those nodes or you just want to change
the layout of one part of it and so
there's a tremendous amount of work that
has gone in to optimizing how the
changes of bounds propagate to parent
groups and to sibling groups and affect
the layout but still in some cases you
have a very simple layout and it's
obvious what this change will do to
everything else and that can be
communicated by code that you wrote with
your pre knowledge of how things are set
up that does it with just a few lines of
code whereas we have to go and compare
balance against each other and across a
huge group of things that you know
didn't move but we don't know until
we've done the calculations
this is so basically there are cases
where you have a very simple concept of
laying out but it's not something that
can easily be conveyed through the way
you've grouped your nodes in the scene
graph obviously we've done a lot of work
on that that goes pretty fast but
there's sometimes scalability problems
you know might work great for a couple
hundred nodes but you've got ten
thousand nodes then suddenly those
calculations start adding up and also
it's just work that can be completely
eliminated by a piece of code that knows
what it's doing so canvas allows you to
just basically do what you know needs to
be done but then obviously using that
you give up all of the flexibility and
capabilities you get with nodes to
basically just add event handlers under
given node without having to do your own
picking code so it depends on the the
ratio of how complicated your layout is
to what you need to do with it if you
don't need to do a lot with it and it's
a very simple layout you might actually
be able to render it faster than you
could express it in nodes and then a
question we got was canvas is not
implicitly out of the box
set up to a participate in layout
managers but if you want to have a
canvas in your layed out control how do
you get it to to play with that and so
Joe wrote an example that shows exactly
what you need to override to make it
work with layout managers and we're
gonna we're gonna wait until the end of
the slide switch to the demo machine
because we've had problems with
switching we only want to switch once
and we're ready for the
one thing to note also about late laying
out layout with a canvas is that since
there's two ways of kind of resizing
your canvas you know maybe you would
like to just scale the content that
you're rendering or maybe you would like
to expand the viewport so that you can
include more content it's it layout is
up to the guy using the canvas and so
that's that's kind of why we decided to
make it extendable so one thing we
didn't show about the path preloader
that shows off the the layered rendering
was that he actually had created this
other timeline which would animate all
three of those canvases against each
other to make it more obvious what was
going on but we had that commented out
for the first demonstration purposes but
if I start playing that timeline then
you'll see the three actually can be
moved around independently because it's
three separate canvases with the lowest
layer that's the little racetrack and
then the cyan and magenta layers that
was just to point out that it is being
done with three independent canvases
finally
there we go contact list one thing I did
when we were first experimenting with
scene graphs was I did the standard
contact list like you might have on your
phone which you have a thousand contacts
and it needs to be scroll back and forth
at the time our first iteration of the
scene graph pre-job FX actually spent a
huge amount of time calculating all the
bounds of everything when you all you
did was move it by 10 pixels we've
gotten way better than that in Java FX
but still that's work that doesn't
necessarily need to be done for a
contact list where you know it's just
now we're at a different you know that
the contact list can see these contacts
it's all needs to be written so I wrote
a little or Joe write a little demo and
I worked on it that basically just
creates a thousand contacts or we
actually upped it to 2,000 contacts and
then basically animates scrolling up and
down through those contact lists and
prints out how fast it can do it and we
call this mixing methods so that we have
two different implementations one that
will use a scene graph to make it and
one that will use a canvas so the scene
graph version creates a scrollable pane
creates a group containing a background
rectangle first name last name phone
sets those into a group with
translations on each one and then
returns that that pain and it sets a
property that that's what you need to
animate to get it to scroll in this case
we just grabbed the vertical value
property from the scroll pane and you
run that and there it goes so that you
can see we've got the gradient
background fill and where each contact
is three names and we're getting about
17 frames per second scrolling that back
and forth in a scroll pane then created
a canvas version which is similar but it
doesn't have a lot of capabilities like
I don't have a scroll scroll bar on this
if I didn't have that animation driving
it I
have to write a whole bunch of code to
add a scrollbar to set the property to
get it to scroll which I didn't have to
do because I just did an animation that
Scrolls it back and forth so it's
deceptively the same amount of code but
there's a lot missing here that the
other one buys you for free however you
run it and it's getting 400 frames per
second basically because the contact
list has no real intelligence at all at
how it's laid out it's just a big long
list and you can use a simple division
to figure out which contact is supposed
to be drawn and you only draw the five
contacts that are drawn you need no
balance calculations no update
everybody's transformed pass but again
that's an example of the huge ratio of
such a simple layout to not needing many
capabilities because I didn't need a
scrollbar I just had the animation to
scroll me but it shows you the
difference in performance when you can
get rid of all of that so again choose
how much flexibility you want versus
whether you can do it yourself and
there's the trade-offs another example
of updating is we keep calling this
Christmas tree but really it came from I
think like the stock market traders have
multiple monitors with a huge number of
little cells that are telling them
what's happening with the different
stocks and they'll blink red or green
depending on whether the stocks going up
and they want to buy it and there's just
a huge number of them laid out in a
simple grid to get a huge visibility
across a variety of stocks and that's a
stress test for a lot of things there
there was a version of this that ran in
swing for them to do performance work in
swing we have a version that runs in
scene graph to do performance worth of
the scene graph I created a simple
version of it just for demonstration
purposes so there's a base the base
class that just defines how many cells
we're gonna have and then it asks the
subclass to make all the cells and then
to update them with a new state and the
three states are green white or red for
low normal or high and then it just has
an animation timer to deal with updating
it sells for each frame and then
printing out the frames per second so we
have a version that uses scene graph to
make a cell it just makes a little group
containing a rectangle in the text and
then it's updated it just changes the
fill color and changes the text in the
node and when you run this it gets lots
of bling keys and it's running at 90
frames per second I have the vsync
turned off for that for these so I can
go above 60 frames per second so it gets
almost hundred frames per second a lot
of lots of blinky things and the canvas
version to make a cell it really just
makes a canvas once so it checks with GC
is null it makes the canvas and then the
next time it gets called to make a cell
it doesn't really make it it just draws
it using the update cell but it's told
to update to a new state it just simply
draws that cell again and you end up
with 170 to 180 frames per second so
roughly double the performance again an
extreme ratio of how simple the layout
is here and how easy it is to go and
just update the pickles that need to be
updated using prior knowledge about what
the application is doing compared to
that's about all you can do is go draw
that rectangle there's no you know
picking support would they have to be
manually coded you get it for free in
the in the scene graph so that's another
example of layouts in scrolling
land Oh so the example of how to get
your canvas to participate in layout
there's this layout test it's a very
simple application I'll just draw it
first all it is is a giant rectangle
with this alternating white black
pattern but as I resize the window you
see it's actually being controlled by
the layout manager of the container it
got put in and so it's responding to
where it needs to go sending it and so
really I listed kind of the steps in the
layout slide but I just extended canvas
so so here's where is it oh except for
file sorry so canvas layout extends
canvas you override these resizable to
say yes I am you override the preferred
height and width to return your own
height and width and when you're called
to resize that's abstract yeah so back
in the demo he overrides that and when
it's called to resize he changes the
size and then calls his due frame method
to rerender the code right and so what I
was saying earlier it how you resize
your canvas matters you may want to
scale your content or whatever and so
that's why I provided this method so
that you can kind of do whatever your
canvas needs to do to resize so
basically resize is the only method that
needs to be custom per canvas that wants
to be laid out but the rest of them are
common to any canvas that wants to
participate in the layout
oh one thing I wouldn't point out the
apply effect enables you to do something
that couldn't be done I hope you've been
to some of my talks in previous Java
ones I have this little eye candy that I
wrote in the swing using buffered image
and I just push pixels around in pretty
patterns and you can't do it with a
scene graph because each frame is a
modification of the frame before it it's
not its own definition and so finally
with canvas and the ability to apply
effect on a canvas and get the results
back into the canvas you can create
zoomy yeah so zoomies just basically
inject some color into the scene and
apply some kind of smushy displacement
effect to get pretty pictures out of it
and in just a second I'll go to one of
the more startling ones hello there
woohoo so eye candy the best reason to
create canvas I think this point let's
switch to questions yeah
right so the question is is there any 3d
capabilities in canvas and at this point
no we followed the we followed the html5
example they're all 2d and in fact their
method is get context and then the
string you hand in is 2d which gets this
so we called our method get graphics
context 2d with the intention that if we
want to then provide a 3d rendering
canvas we could then have a different
method which returns you a 3d oriented
rendering context but for now all we
have is that get graphics context 2d and
we only support 2d operations there
there I wouldn't but there isn't
anything to share so that can be
something we can discuss on the mailing
lists and see if the people want to get
an effort started but they're working on
3d now 3d major heavyweight 3d nodes
right now we have the ability to add a
couple of Z transform properties on a
node that can get you some 3d and they
can have to do a lot of cool things with
it but if you went to the talk yesterday
or was it Monday they actually showed
you like the ability to create meshes
and have cameras fly through them so
that's just getting started on the scene
graph side canvas is gonna wait to see
how that plays out and then before we
even make a road map
guess where the not requirements to
that's what different
okay so that the comment was for charts
if you try to do 3d charts you can it
greatly increase your note count if
you're doing it with the scene graph but
with canvas you could do it much simpler
and you know I've seen plenty of demos
in Java 2d where they just did the 3d
calculations themselves and and rendered
paths yeah so you have that capability
as well I didn't get that so so the
thing you have to be careful is the the
canvas is kind of an immediate mode
style you're not you're you're once the
commands are drawn it's done but any any
work you have to do is going to have to
be executed I mean I want to say
simultaneously it's not really
simultaneous but there's not a ton of
stuff cached on the on the graphics card
in this game scene graph we do use that
as a kind of a strategy and that's why I
was saying in one of the slides where
you have to kind of knowingly treat
canvas like a cache but when you talk
about 3d it very much is a good idea to
want to cache stuff on the GPU and so if
you're using an immediate mode style API
to render 3d stuff it's it kind of gets
a little hairy so you need to make sure
that the strategy that you're using the
canvas for is the same kind of strategy
that the canvas is catered to for for
rendering it's a good that's a good
point because MIT most 3d api's are
scene graph based in the first place
all of it yeah we meet Hardware
accelerate everything you see happening
there yeah just just we do the similar
nodes on scene rap it uses the same
rendering library yeah that's actually
part of the reason why we don't have you
know get pixel reader from a canvas is
because the pixels haven't been created
in Hardware yet until we do a sync up
and it would just be a nightmare and it
would be slow reading the back off the
card so we don't want to encourage
reading from your canvas until we know
how to get that responsibly done because
everything is done at hardware any more
questions or another question or more
questions about 3d
Mandelbrot so when we were testing the
canvas we found a lot of html5 demos and
we started porting those over some of
them don't run well here because like
they come up they don't have the screen
real estate on this projector and I
didn't test them at this real estate and
they come up with a window that just
doesn't do anything here's here's a
fluid solver that I think I did run
earlier that Joe found on the net
imported that so it basically uses a
canvas and then draws small rectangles
and then runs a fluid simulation on them
so that the smoky stuff is basically
like ink in a fluid that's being
distributed by the momentum that you
pushed through the fluid with and the
JavaFX version so there's a version
exactly like this in JavaScript we get
double the performance so with a fluid
solver that's a huge deal because you
can have more iterations you can have a
bigger a bigger image to do it do it on
so it actually made a pretty big
difference there's also this Mandelbrot
I haven't tested to see if this comes
out oh it works so this you know running
on JavaScript even with the the best
browsers this lets you zoom in on the
Mandelbrot set and then it'll draw the
next frame and it usually it's measured
in how many seconds it takes to draw the
next frame whereas we're instantaneous
because it's all Java code that gets
compiled by hotspot and so you can zoom
in as far as you want and Ya Allah
256 by 256 yeah yeah
Oh
well
the I mean there's a couple of ways oh
because you want them the locations to
modify but not there we don't provide a
separate transform for coordinates
versus attributes so your paints will be
affected by the transform and your line
width will be affected by your transform
and the decorations of the line are
affected by the transform for doing
something where your maps are zooming
though it might be just as easy to throw
the amount of transforms you're doing
just do it yourself and figure out what
the new locations are it's it's three
four multiplies and two adds to get a
nice 2d transform going for your
locations and then your dren during with
just the fixed line with whatever you
want
actually there's there's two more things
I want to bring up in this presentation
that didn't quite get to make it in the
slides there is was a guy who did a blog
post about new 2.2 JavaFX features
rendered to image image pattern and
canvas and what he was able to do was
render kind of a custom canvas look kind
of pattern image and then he did use
render to image to save it to an image
and then used image pattern to put it as
a background to one of his controls
I actually showed something like that in
my and my image ops talk and I have one
basically that uses a render to image to
I don't have any uses canvas sorry but
basically just creates dynamic images on
the fly to uses an image pattern I could
have done this with canvas as well but I
did it with nodes and render to image so
that's that's one thing and then another
thing I was talking to Kirill who we
work with who worked on the 3d stuff
when he saw canvas his first impression
was you know can I use canvas to render
a bump map and in the in the future that
will absolutely be be doable
yeah
so you have to port it but one of the
exercises we did modeling after the
html5 canvas the reason we did all of
these ports was to see how you know what
it's like because we want somebody who's
an html5 developer to easily go from one
to the other and it wasn't it's it's
pretty straight one-to-one pretty much
it's very easy oh yeah that's something
as cameras yeah yeah yeah this is
something that Jasper did for animations
from one of the demos he's writing and
he's basically doing this on a canvas
all of those are our have custom
locations every screen so you don't get
any advantage out of all the work we do
to run through to calculate the bounds
on everything and the transforms he just
you render them and that's all you need
done with it you can forget everything
else about it so that's an advantage of
canvas is low footprint for doing
something like this
any more questions okay this that's it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>