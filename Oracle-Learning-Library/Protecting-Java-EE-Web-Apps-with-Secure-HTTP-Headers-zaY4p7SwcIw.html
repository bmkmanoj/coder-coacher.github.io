<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Protecting Java EE Web Apps with Secure HTTP Headers | Coder Coacher - Coaching Coders</title><meta content="Protecting Java EE Web Apps with Secure HTTP Headers - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Protecting Java EE Web Apps with Secure HTTP Headers</b></h2><h5 class="post__date">2013-01-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/zaY4p7SwcIw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to protecting Java Web Apps with
secure HTTP headers how you guys doing
all right awesome I hope you're enjoying
Java one as much as I am my name is
Frank Kim I'm a consultant do some work
with my own company called pink SEC and
I also do a bunch of stuff with the SANS
Institute as well has anybody heard of
the SANS Institute quick show of hands
wow that's pretty good that's pretty
good for a developer conference the SANS
Institute is a computer security
training organization that does security
training along a number of different
disciplines like pen testing forensics
as well as application and software
security the part that I'm involved in
and I wanted before we get started I
just want to a quick shout out to Jason
Lam a friend of mine who actually helped
me co-author these slides so thanks a
lot Jason out there wherever you are all
right I was actually here at JavaOne
last year and after Java one I was
fortunate enough to receive a rock star
award and I got an email about it and I
was reading it to my daughter who was 4
years old at the time and I read it to
her and I finished reading it and she
said yay daddy win and she looked
immediately at my wife who was sitting
right next to us and said mommy when are
you gonna win so my wife didn't like
that too much but she recently just got
promoted at a work a couple weeks ago so
finally we said hey guess what yeah
mommy won so she was happy about that
all right so we're gonna be talking
about four different things today
we're gonna talk about three common web
application vulnerabilities cross-site
scripting session hijacking and cliff
jacking and talk about how you can
easily mitigate these in your web apps
easily prevent these by using some HTTP
headers and finally we're gonna close up
just with a quick wrap-up summarizing
everything that we've talked about sound
good all right so let's start with
cross-site scripting now this is just a
real quick review quick show of hands
who has heard of cross-site scripting
excellent that looks like pretty much
everybody who was actually fixed
cross-site scripting in one of their
applications maybe thirty percent of the
folks alright good now as you guys
probably know cross-site scripting
occurs when some evil data gets rendered
gets sent back down to your browser
that's it some evil untrusted data
that's usually in the form of JavaScript
all right now there's may three main
types of
cross-site scripting you see down here
on the slides at the bottom there's
reflected cross-site scripting now to
kind of illustrate that let's talk about
tennis for a second
are there any tennis fans out there just
a handful of hands just a handful of
hands all right any Maria Sharapova fans
all right we have a few more hands so it
turns out that a while back it was
announced that Maria Sharapova was going
to be leaving the world of tennis to
become a CCIE
a Cisco Certified internetworking expert
isn't that awesome
it was jointly announced on both Cisco
comm and Maria Sharapova comp
on the exact same day so it had to be
true right turns out it was April 1st
April Fool's Day and some Russian
hackers had found cross-site scripting
vulnerabilities in both Cisco comm and
Maria Sharapova comm they'd saved him up
until April 1st then sent out these
malicious links that had a bunch of bad
data at the end of them when users
clicked on those links this evil
JavaScript got sent down to the users
browsers executed and rewrote the
contents of the pages write that making
it look like there was a press release
that was issued by each respective
website so that's your classic case of
reflected cross-site scripting where you
click a link the evil parameters the URL
parameters get sent up the app and then
get echoed back down in the in the
response right make sense store
cross-site scripting is exactly the same
thing but instead of the day of data
being sent up in a URL parameter let's
say right it's saved into your database
right and that save data may be in your
profile or something like that gets
displayed back to you in the browser at
some point and dom-based cross-site
scripting is conceptually conceptually
the same thing just when you're
accessing untrusted evil data as part of
the Dom all right something from
document URL or document out location so
let's show a quick demo of just how
cross-site scripting works now this is a
very basic demo I'm just going to switch
over to a VM here that I have running if
it'll switch over there we go now in in
Firefox right here you can see that
we've got a bunch of links here that
we're just going to use
throughout the course of this talk so we
can easily quickly navigate between the
different parts of the application that
I want to show you guys so the first
link here is just some simple cross-site
scripting now might be a little bit
small in the back but you can see in the
URL bar that we've got a purposely
vulnerable page here called XSS JSP and
it takes a couple parameters and so I
could simply go ahead and change this to
this whatever string I want and it gets
I go back to the browser right very
basic basic stuff but here if we simply
change this to script alert script and
hit enter you can see right we get some
arbitrary JavaScript some evil code
untrusted code being executed in the
browser in this case all we're doing is
popping up the simple alert box right
I'm sure who who's seen this before kind
of the standard way we test for
cross-site scripting and of course what
attackers really want they don't want to
just pop up little alert boxes all right
one of the things that they might try to
do is try to access your document cookie
so that then they can steal your session
and you can see in this particular case
the JavaScript arbitrary code has access
to anything in the Dom in this
particular case your j'ai session ID
which is very important because it keeps
track of your authenticated state now if
we take a look in the code this is just
some very simple code here and down at
the bottom on line 14 hopefully you can
see that in the back all we're doing is
using JSP syntax less than percent equal
right writing out these untrusted
unvalidated parameters directly to the
output stream right so it's your classic
case of reflected cross-site scripting
all right so if I switch back to the
slides here alright so that was just a
quick refresher right to make sure that
we're all on the same page about XSS
make sense so how do we stop this from
occurring well we're talking about
various things that you could do that
are related to HTTP headers one of the
things that you can do is add this HTTP
only flag to all of your sensitive
cookies and the HTTP only flag
specifically states that client-side
script JavaScript for example cannot
access the contents of any HTTP only
cookies and that's good because it helps
mitigate some common cross-site
scripting attacks like the one that we
just saw where the arbitrary JavaScript
is trying to access document cookie now
in the old days before servlet 3.0 there
was no way to configure the je session
ID in your app server to be HTTP only
per the spec for the standard you had to
use various vendor proprietary
configurations right and vendor
contendere proprietary XML files but
fortunately as of servlet 3.0 you can
simply add this little snippet of XML to
your web XML file and it'll
automatically set your je session ID to
be HTTP le alright if you want to do it
from the code and you want to create
some random cookies arbitrary cookies
with the HTTP only flag unfortunately
there's no set HTTP only method on the
cookie class if you look at the Java doc
so you have to create the header
manually like you see all the way down
here at the bottom it might be kind of
hard to see in the back but you can see
we're creating a cookie just a string
value with the HTTP only flag at the
very end in the lower right hand corner
and then simply adding that header
directly to the response all right
that's it so this is the first way we're
gonna talk about three different ways
that you can mitigate cross-site
scripting this is the first thing that's
pretty easy to add to your applications
all right the second thing that we can
do is use the X XSS protection header
anybody heard of this header before a
couple people all right now this is
really handy this is a really valuable
header because in most modern browsers
ie Safari and Chrome this protection the
XSS protection functionality is enabled
by default right unfortunately it's not
yet supported by Firefox they've
actually got a bug out there they're
working on it fixing it right now but
basically if there's any reflected
cross-site scripting like the example
that we saw in the VM using one of these
modern browsers it'll automatically
block that from happening right except
in Firefox they're working on it
now that's a good question the question
is what version of these browsers is X
XSS protection in and I can't remember
off the top of my head it's these
browsers get modified and updated so
quickly like Chrome is on version like a
thousand isn't it right so I can't quite
remember but it's it's at least n minus
1 but yeah that's that's a good point we
should we should I should I should add
that we will show you that in just a
moment here the question was when we say
it's blocked this reflected XSS is
blocked what does the user see what's
the experience we'll see that in just a
second all right so the way that you
enable this well it's enabled by default
which basically means X XSS protection
with the header value 1 right that's
enable that functionality is enabled by
default but if you want to turn it off
for some reason you simply from your app
set XSS protection equal to zero right
here the second to last bullet right and
that'll turn it off entirely now if you
want to block the page entirely right
you can add this mode equals block at
the very end right to block the xs/s
entirely let's go ahead and take a look
at that now in your java code all right
this is very easy to do all you have to
do is call response dot add header with
the appropriate values for the things
that you want to do all right
you can also you know also configure
this up your web server level if you
wanted to as well all right so let's see
TR to your question up here in the front
let's go ahead and see how this actually
works
so switching over to the VM here so what
I'm going to do now is go back to
Firefox and going to the X XSS
protection demo here again we make this
a little bit bigger for you guys we're
gonna simply show right here now what
we're gonna try to do is we're gonna try
to do that document dot alert right
document dot cookie alert again right
here and you can see in this particular
case the first thing we're talking about
is the HTTP only flag now real quick
what does HTTP only do again
yes exactly it prevents JavaScript from
accessing your cookies so in this
particular case in this app we've now
modified the je session ID to go ahead
and set the HTTP only flag on it and you
can see right in this little alert box
there's no Jake session ID value because
JavaScript can't get access to it all
right so it's helping mitigate some
common cross-site scripting attacks
right and this is all working because
now for this app in particular right
we've got it running on Tomcat 7 and
Tomcat 7 by default adds the HTTP only
flag to the je session ID so that's
pretty handy right it's really easy all
we have to do is use the right server
and it add some protections now I'm
going to switch over to another another
app that I have running here in this
case this is a an app called Paris proxy
it's one of many freely available web
application proxies who's used a web app
proxy before all right maybe 10% of the
folks so real quick a web app proxy sits
in between your browser and your server
right and in this case it's running on
our machine right so the proxy sits in
the middle so all of the traffic from
the browser gets intercepted by the
proxy and then the proxy simply forwards
the traffic up to the server and then
vice versa when the response comes down
from the server it stops at the proxy
and then goes back to the browser all
right so the proxy can see everything
and in this particular case we've got
perros proxy running there's a lot of
other good ones out there a wasp's pass
one called the zed attack proxy burp
suite is my personal favorite one it's
got a lot of good functionality in it
but you can see on the left-hand side
here is just the hierarchy of the
different pages that we visited so far
down at the bottom is the the list of
all of the requests and corresponding
responses that we've sent and received
all right so here if I go to the first
one and look in the response tab you can
see that in particular for the for the J
session ID right here right at the very
end right here Tomcat has automatically
set the HTTP only flag for us which is
what prevents the J session ID from
being displayed in that little popup box
right and get preventing JavaScript from
accessing
all right because what's an attacker
gonna do with the J sessionid he's not
gonna pop it up in an alert box he's
gonna simply append it to a URL that
points to his web server right so then
he can look at his web logs to go ahead
and scrape out all of the J session IDs
that he's stolen that he's hijacked all
right so that's looking at HTTP only
specifically but let's go ahead and look
at the XSS protection header so going
back to the home page here with all of
our links now in let's go ahead and look
in chrome right because chrome has this
enabled by default
all right so if we try to do the exact
same thing in chrome script alert script
XSS and this is to your point in the
front here what happens to the user in
this case we don't see an alert box
right still this script in the URL bar
is being trying to send up to the server
and go back down in the response right
but the browser is not executing it
because Chrome has the XSS protection
functionality built into it and if we
view the source to this page right click
view source you can see that the script
still gets script alert scripts still
gets sent down into HTML response but
the browser's are smart enough to
recognize that this is a reflected
cross-site scripting and prevent it from
executing all right any questions so far
yes yeah that's a good question the
question is does this XSS protection
header that we're talking about right
now does it work for the other types of
cross-site scripting and no it really
only works for reflected cross-site
scripting so there's a whole other class
of XSS vulnerabilities that we will
still have to worry about but reflected
or some of the most common right so it's
doing a good job of helping protect
against that excellent question
anything else yes the question is is
there a difference between a get and a
post when you're talking about the XSS
protection as long as it's in this
particular case reflected XSS where some
data simply gets sent up and echo back
then there's there's not a difference
yes
so can you set that header on your
server yeah good question the question
is can you take advantage of this header
if somebody's using an older browser can
you still pass this header down from
your application from your server to the
browser have an older browser and will
something still happen and unfortunately
the short answer is no if you're using
an older browser a non modern browser
that doesn't support this XSS protection
header is not going to do anything so
the browser will just ignore that header
right so nothing bad will happen in
terms of the functionality but it won't
protect them against XSS if you're using
an older for older browser yeah good
yeah B yeah the version numbers again I
don't have that off the top of my head
but it's browsers within the last couple
years have these protections built in
yeah anything else guys all right so
let's look at it keeps trying to join
this wireless network all right so if I
go back to eclipse real quick and you
can see on line number three this is the
default protection XSS protection equals
one but if I go ahead and change it to
uncomment line four let me expand this
here and change it to pass in one
meaning it's enabled but say mode equals
block right now if I go back to fire to
Chrome and try to pass the same thing
instead of seeing most of the page like
we see right now right but without the
script executing when I go ahead and hit
enter to send this request you can see
that Chrome simply displays a blank page
entirely because we're blocking the
entire page from being displayed by
chrome itself all right so this is a
this is the difference in the user
functionality that you were asking about
all right so if I switch back to the
slides now all right so we've talked
about two ways to help mitigate
cross-site scripting using the HTTP only
flag and using the XSS protection header
now the third and final way the final
thing that we could do is use content
security policy now I'm really excited
about content security policy this is
some really cool stuff who's heard of
this before
few people handful of people content
security policy was originally created
by the folks over at Mozilla so first
implemented in Firefox of course it's
currently a w3c draft and it's supported
in both Firefox and ie using the X
content security policy header we see
down here at the bottom in the lower
right hand corner now Chrome and Safari
in particular they also support it but
because it's just still a draft
specification they support it using the
experimental X WebKit CSP header all the
way down here in the lower right hand
corner now content security policy
specifically allows you to pass these
headers right and specifically prevent
JavaScript from being executed in your
browser right untrusted javascript from
being executed in your browser and they
do this by essentially creating a
whitelist of the sources from which
JavaScript can run all right so before
we get to see how you actually define
that whitelist well we have to talk
about some restrictions if you're using
content security policy you can no
longer in your application have inline
scripts or inline style sheets right
inline meaning just in your HTML having
an arbitrary script block with some
JavaScript or having inline event
handlers like we see here in the third
in the second bullet all right and
that's because just like we saw with the
reflected cross-site scripting example
in the VM all right the browser can't
differentiate between what might be
reflected XSS and what might be actually
trusted that you access its JavaScript
that you've put into you've inlined into
your HTML itself that makes sense
alright so the way that you whitelist
the sources for your scripts and
stylesheets is by using these various
content security policy directives as
part of the headers that we just talked
about so there's various ones here right
the the second from the top script
source what are the locations that
you're gonna allow JavaScript to run
from style source what are the locations
you're gonna allow style sheets to be
loaded from image source media source
frame source font source and so on right
instead of memorizing all of this it's
actually helpful to look at a couple
examples now the first example at the
very top is just an example of voting
resources only from the same origin
right origin of course being your
protocol domain URL and port and here
when we say default source equals self
right that's specifying that you can
only load JavaScript arbitrary
JavaScript from your own location now
this is an example from my quests
website my quest is an engineer on the
Google Chrome team lives over in Germany
and you know if you look at his web site
in the content security policy that he
has set he basically says that well
there's no default source so I'm only
gonna trust the stuff that I whitelist
down below here specifically the Styles
can only come from his content delivery
network right here frames right
the only trusted sources are YouTube and
SlideShare net scripts in particular
right here about 3/4 of the way down can
again only be loaded from his content
delivery network and he's also allowing
scripts from Google Analytics to run
because he wants to have some tracking
on them images can be only loaded from
these locations at the bottom yep I'm
gonna have to turn off Wi-Fi here and
down at the very bottom it might be
tough to see all the way of area in the
back but certain fonts right those can
also only be loaded from his content
delivery network as well all right now
you guys may be thinking if you have
content security policy and you can't
have inline scripts how many people have
probably have inline scripts and inline
styles in their applications right now
right yeah it's a lot of people it's
you know 80% of people it looks like so
one of the things that you can do is you
can use this header instead and this is
actually what Facebook is using right
now you can say X content security
policy but report only so it won't
actually block anything on the browser
so while you're going ahead and looking
at your application seeing where you
have inline scripts and so on you can
set a security policy content security
policy like Facebook is doing in this
particular case to only allow scripts
from these locations and the report only
is very handy because all the way at the
bottom might be tough to see in the back
there's this report URI
parameter right and you can see that
anytime that the browser finds something
that violates the content security
policy the browser is going to send the
data up to facebook.com/cbsnewyork own
good or bad now the second to last line
down here at the bottom bottom is kind
of interesting
they've also specifically added this
options line that says they're gonna
allow inline scripts and eval rights and
they've specific saying even then while
we're reporting on it we're still gonna
allow you to potentially run cross-site
scripting right by having inline scripts
and so on any questions all right so
let's take a look quick look at a quick
content security policy demo now
switching back over to the VM here in
Firefox going back to the home page here
let's go ahead and click the link for
content security policy it's the same
basic JSP that we were looking at and
now in Firefox specifically if we try to
do the same script alert script right
Firefox is blocking it because we've
specifically enabled the content
security policy using this directive
here if I switch over to the code in
Eclipse right on line number three we're
specifically saying content security
policy default source equals self all
right so just by doing a simple
configuration right adding a little bit
of code to send down a header we're
we're eliminating a whole class of
cross-site scripting vulnerabilities
which is very handy
now if you want to go ahead and I'm
gonna go ahead and comment out line two
and here on line four say content
security policy default source but self
and then add these options like Facebook
had to allow inline scripts and eval if
I go back to Firefox and try the same
thing again alright you can see that the
cross site scripting actually executes
write arbitrary JavaScript running in
the browser again
so I know about you guys but isn't this
awesome right three pretty easy ways
that we can use to prevent cross-site
scripting that we just talked about
right we can do HTTP only flag use the
XSS protection header and finally write
potentially use content security policy
as well so let's switch gears a little
bit and talk about session hijacking now
how many of you guys go to let's say
Starbucks or some other cafe and help on
to the wireless network and surf the web
and get some work done
oh yeah it's just one a minute I do it
all the time right now let's say that
you're doing that you are the victim
over here on the left hand side and
you're hopped onto your local cafes
wireless network but unbeknownst to you
also on that local network is an
attacker as represented by this evil red
screen in this black hat right over here
in the lower left and so you as the
victim you decide when you're at the
cafe you want to go ahead and do some
online banking right so you go ahead and
try to access my bank comm here in step
number one well unbeknownst to you the
attacker in step number two is sniffing
the public Wi-Fi network and he steals
your J session ID just off of the wire
and because he's got your J session ID
he can conduct your classic case of
session hijacking and pass your session
ID to the application and log in as you
and that's exactly what he does here in
step number three right so what can we
do to prevent this from happening you
can use the secure flag on your cookies
now who's who uses a secure flag all
right maybe I don't know 15% of you guys
now the secure flag specifically says
that any cookies set with the secure
flag can only ever be transmitted over
SSL right so if the secure fly the
cookie can only be ever transmitted over
SSL the attacker can't sniff it off of
the network because it's not being sent
right in the clear and again this was a
configuration that was introduced in
servlet 3.0 right simply adding in
web.xml right this little configuration
area and will automatically mark your J
session IDs as secure and if you have
some other cookies in your app you can
use the code down at the bottom when you
simply
say new cookie you can simply call the
dot set secure method all right we'll
set your cookies as secure as well now
there's a problem here when you set your
cookies as secure usually what happens
is that at some point you the victim we
are going to access the website over a
non SSL right maybe at some point you
get redirected to SSL and so on well
what happens is one even once you're on
SSL what an attacker can do is they can
downgrade your SSL connection to just
regular HTTP and if when you guys heard
of a security researcher named Moxie
Marlinspike yeah a couple people he's
had some awesome research and one of the
tools as he's developed is called SSL
stripped SSL strip alright just Google
for it search for it find it on his
website it's a really handy tool and it
allows you to conduct this attack where
if the website supports both HTTP and
HTTPS once you're on HTTPS using SSL
strip he can in the background
transparently downgrade you to HTTP
without your knowledge and then go ahead
and sniff all your data steal your
cookies and so on all right so how do
you prevent that from occurring well
we've got the second header here all
right the last header that we're going
to talk about in this section called
strict Transport Security anybody use
strict Transport Security before just
one or two people looks like strict
Transport Security specifically tells
your browser to only ever talk to the
server over SSL how does it do that the
very first time your browser connects to
a server an app it doesn't know right
that's what the SSL certificate is what
it does is that the very first time you
access that site via SSL and you've got
the strict Transport Security header set
within your app being sent down your
browser then saves the certificate info
for some configurable amount of time in
the browser itself so that in the future
if you manually type in HTTP no SSL it's
still gonna do SSL communication for you
under the covers right now supported
browsers implemented in both Firefly
and chrome unfortunately it's not widely
adopted across all of the browsers yet
because it's currently an IETF draft and
in terms of the header all you have to
do from your code right or from your app
is set strict Transport Security and you
can see down here in the lower right the
max age and you can optionally say if
you want this protection to be included
apply to your subdomains as well and
some browsers like Chrome for example
they even have built into it the strict
Transport Security for certain trusted
or certain known domains like Google com
so anytime in chrome that you go to
Google comm it's always going to be over
SSL right under the covers because this
first this first bullet right here where
you access it over HTTP and then it gets
a certificate it automatically does that
for you make sense any questions so far
on anything we talked about cross-site
scripting session hijacking using these
two headers yes the question is has
Microsoft indicated they want to follow
this and yes they have it's just a
matter of them actually getting around
to it yes
yeah that's a really good question the
comment is do common web frameworks like
the gentleman up here in the front uses
fought in but if you're using any other
frameworks like I don't know spring MVC
maybe using the play framework and so on
do any of those frameworks automatically
build in the use of these headers and
unfortunately not widely that I've seen
but I think that's a beautiful comment
because from a application security
perspective the only way we can scale
these protections is to not have all of
you guys build these into your apps one
at a time and configure your app to do
all of this stuff but if your framework
is already doing it right it's going to
help solve a lot of problems and we're
starting to get there right like Tomcat
automatically now in version seven
includes the HTTP only flag for the J's
session ID so it's kind of its kind of
one step at a time but yeah if we if
you're a commuter on Vaadin that would
be great to add some of this stuff yeah
good stuff anything else anyone all
right so now we're gonna move on and
talk about clickjacking clickjacking now
click well who's heard of clickjacking
before alright maybe maybe 5% of the
folks
now click jacking occurs essentially
when I as the attacker trick you in to
clicking a hidden button right because
the hidden button is actually you've got
some site in the front here you can take
a look at this image down at the bottom
you've got some site but under the and
you think you're interacting with the
site that's in the foreground but
clickjacking works by making the actual
target site hidden underneath by
changing the opacity and so when you
actually click something that you think
you're clicking in the foreground it's
actually clicking something in the
background the underlying website itself
so it's tricking you the victim into
clicking a button that you didn't intend
to click maybe the button is to go ahead
and enable your microphone or enable
your camera or maybe it's to go ahead
and transfer some money right so that's
kind of the concept of clickjacking
because the victim site is placed in an
invisible iframe and the attacker
overlays kind of
the benign looking site on top of the
victim site makes sense all right so
let's see how this actually works men so
if I switch back to the VM know let's go
ahead and look at the clickjacking demo
right here now this is a very basic ugly
page that I coded back in the 1990s that
simulates a banking site doing some
transfers uh paying from one person to
another so when I click this I agree to
pay you button you can see that all it's
doing is increasing incrementing this
status counter saying that yeah I've
paid you three times I've paid you four
times five times and so on right
simulating that there's some sensitive
transaction going on here when you click
the button itself alright so now I've
clicked it ten times but if I go back to
the home page right just my links to get
quickly get to the attacker site now the
attacker here has created an iframe and
wrapped the victim site that we just saw
in this iframe and if I go ahead and
click this button that looks relatively
benign on the on this clickjacking page
right it doesn't seem to be anything is
happening but then if I click this show
hidden iframe button I clicked it a
handful of times right you can see and
might be kind of hard to see here but
you can see right here we've I've
actually clicked it nine more times and
so I as the victim think I'm clicking
some benign site in the foreground but
in fact I'm clicking something
unintended in the background make sense
all right
so how does this actually work well here
you can see that simply in an iframe in
an attacker defined iframe right here
all you're doing is setting the iframe
source equal to the victim site right
and putting that into the background by
changing the opacity in this particular
case to zero right so who cares what can
you do with clickjacking well click
tracking was originally discovered by a
couple security researchers Jeremiah
Grossman and Robert arsenic Hanson and
they when they first discovered it when
they first disclosed it they showed how
you could use clickjacking to use then
flash right to go ahead and spy on their
victims by turning on the microphone and
the camera to hear and see everything
that they were doing and that's because
flash at the time had this had itself
this this weakness in it where it would
pop up this little window here and it
would say you want to allow the
microphone in the camera or do you want
to deny it so they simply wrap this
flash setting window in a hidden iframe
put it to the background and then put
some benign looking site in the front
right prompting the user to click on
some button right maybe playing a game
or something like that all right
makes sense uh-oh I'll remember this for
next year all right so it's not just
turning on the microphone in the camera
Facebook gets hit by click jacking all
of the time and this was one click
tracking scam that went around a while
back where the the attacker put up this
image that said hey y-you know these
people are getting rejected in their
passport applications and it's a really
interesting story if you want to find
out more about why people are getting
rejected when applying for passports go
ahead and click this link right here
right but it turns out that this was
clickjacking you weren't really clicking
the link to read the story itself but
what happened is there was all of this
code right all of this HTML code here
now this is a really hard to read so
let's look at this one step at a time
right first what the attacker is doing
is setting the opacity using various
options across different browsers here
to go ahead and make sure that it's
hidden in the background all right what
they want the user to click itself and
then the iframe specifically they are
targeting
facebook.com/ like PHP so they're
targeting the like button right and
specifically they're tricking the victim
into clicking the like button under the
covers and you guys know the like button
right you click the like button and it
like something in Facebook and it adds
you know credibility to it and when you
click the like button right here
specifically it's getting you the victim
to like credit report info and in this
particular case right it's trying to
encourage you well to go to some site
it's increasing the the page ranking of
that particular site and trying to get
you to apply for some credit right and
pay some people pay a pay to apply for a
credit report and all of that stuff all
right so they're trying to monetize this
in various different ways that make
sense everyone now you probably think to
yourself I'm never gonna click one of
those buttons right that's that's
obvious I'm not gonna click some stupid
button that says click here but really
what they what a lot of people actually
feel for this in this particular case
over 15,000 people not a huge number but
this a decent number over 15,000 people
click that fake passport application
like button unbeknownst to them right
now instead of forcing you the victim to
click on one specific button on one
particular area of the screen what you
can do instead is have the like button
in this example follow the cursor itself
so if I switch over to the VM and go
back to the home page here this third
link from the bottom you can see we've
got a little like demo now this is not
click tracking itself this is just
showing what an attacker can do to
further encourage you to click the
button that they want you to click via
clickjacking
and you can see you know this is Firefox
I'm gonna do this in chrome instead here
once I click this link the like demo you
can see this like button comes up but
the code is written in such a way that
no matter where I move my mouse the like
button automatically follows the cursor
so anytime I click that like button is
gonna be clicked no matter where I am on
the page itself you can shut down the
window yeah and this won't be a problem
anymore yeah yeah I know pretty
ingenious right
so if I switch back to the slides oh it
does work in Firefox I can show you it
does work in Firefox but there's a weird
thing in Firefox where the image is
really small so let me show you that's
why I switched over to Chrome see so
when I click this you can see I'm know
if you can see that but there's the like
button right there so if I make the page
even bigger right you can see the like
button better and then I have to like
expand it right so it just wasn't as
visually appealing in this particular
example
yeah the effect is exactly the same yeah
all right so how does this work now in
JavaScript right you've got the you've
got the event you've got the mousemove
event right here and so all this code is
doing is taking the X&amp;amp;Y coordinates of
that mousemove event right and then down
here at the bottom changing right
relatively the location the X&amp;amp;Y
coordinates of the like button based on
the X&amp;amp;Y coordinates of the mousemove
event itself and so that's how you're
getting it to follow the cursor wherever
you're going all right so who cares
about this why and if now it's called
like jacking because click tracking on
Facebook against like buttons is so
popular it's called like jacking right
so why do you want to do like jacking
well if you trick somebody into clicking
a link you can maybe send them to an
evil site that will download malware
onto their machine turn your end-user
machine into a bot right and add it to
their bot army trick you into signing up
for unwanted subscriptions like getting
a credit report ongoing subscription and
what a lot of people do is use it to
drive traffic to increase ad revenues to
their site and this is exactly what this
company called add send media did
anybody heard of add send media yeah one
couple people add send media is alleged
to have made over a million dollars
using clickjacking using like jacking
techniques on Facebook and as a result
of this fraud both Facebook and the
state of Washington filed lawsuits
against ads send media to get them to
stop this from occurring
and since I put these slides together
both of them have settled right the
state of Washington actually settled for
the huge sum of $100,000
right but they still made over a million
dollars right so it's pretty good ROI on
their investment Facebook also settled
with them but the terms of that
settlement were undisclosed so who knows
how much who knows how much they gave up
right so how do you fix this how do you
prevent clickjacking from occurring this
is where we have another header called X
frame options who's used X frame options
before all right now that may be 10
people all right good
all right now X frame options basically
if you set this and send it down to your
browser right the bar all modern
browsers support this if you if your
browser supports this it's gonna stop
what we saw from happening X frame
options has three options right there's
deny that you could prevent any site
from framing that page in particular
there's same-origin which only allows
well as the name says stuff from the
same origin to frame your site right and
then the last one this allow from
specifying a list of the origin the
origin itself that you can you can call
out now this last one here based on my
testing only ie supports this right and
X frame options was originally developed
by Microsoft and X frame up and the
allow from down at the very bottom is it
was a later edition and if you actually
look in the Firefox bug history this bug
number down at the very bottom might be
hard to see from the back but they say
that because Firefox doesn't support
this option they say that it was an
unintentional oversight and they're
planning to add it right like the other
browsers are doing but right now this
last option allow from appears to be
only supported by IE in my in my testing
all right so how do you set this in your
java code it's very easy all you have to
do is say response dot add header right
and add the appropriate headers that you
want to send in or often alternatively
configure it from your web server as
well all right so let's go ahead and
take a look at a demo if I switch back
to the VM here
and go back to the home page if I go
ahead and click the second link from the
bottom now this is the same page we were
looking at if I try to click this click
Me button I'm trust me I'm clicking here
on my trackpad here but then
I show the hidden iframe you can see
that nothing happens because it prevents
X frame options prevents the site from
actually getting framed and if I go
ahead and go back to the web app proxy
in Paros here right down here where is
it you can see that this response that
was sent down specifically has the X
frame options deny header set right here
which is what's causing that behavior in
the browser now alternatively if I go
ahead
and let's see let's go back here and I
use the same origin header instead the
same origin attribute now when I go
ahead and click me and I'm clicking a
bunch of times because in this case I'm
at attacker comm in the URL bar the site
that I'm trying to frame is in victim
comm all right so here because we're at
different origins the page still doesn't
get framed but if I go ahead and switch
this to victim comm in the URL bar and
then I click this click Me button and
click show hidden iframe you can see
that it is allowing it to be framed
because the header that we sent if we
look back here in Paris is right here we
no longer set X frame options deny we
set it to X frame options same origin
all right so this is a really easy way
for us to prevent
clickjacking from occurring right if we
care about that in our applications yeah
yeah exactly the comment is yeah so same
origin still allows your own site to do
the iframes right because you know it's
all coming from your website itself yes
I don't think I quite hurt you I think
you said it's oh this header effects a
framing framing in general yeah not the
opacity yes yeah the opacity separate
exactly yes fort so the question is are
there any recommended browser settings
for these headers to work and
fortunately I think here for all of
these headers yeah you know the user
doesn't have to do anything in the
browser as long as they're using a
modern browser that does support these
headers right it'll automatically work
once you send it down to from your app
itself yes
huh
so I think I think the question is if
you're using content security policy
will CSP prevents you from setting the
opacity to zero in this particular
example and so content security policy
is just whitelisting it's just saying
that we can load styles or script from
this trusted source or this known source
so if that trusted source yeah is
sending the opacity then yeah it'll
still it'll still work but it won't
allow an attacker to put in arbitrary
opacity per hat by passing in a style
yep yes there was a comment here
so I think I heard the question is are
there any monitoring or logging tools
that if you do this stuff that we've
been talking about that you can see if
attackers have been trying to do this
stuff on these particular pages is that
is that right and so there's a number of
well there's that's kind of a
multi-pronged question other than with
the headers themselves other than what
content security policy has with the
report only header that's built in right
you can actually see everything that's
happening in those particular cases but
all of these have other headers you
won't see it as something that's sent
from the browser itself now there's a
whole security sub industry based built
around monitoring and logging and
there's various different tools that let
you analyze your log files and correlate
if attacks are going on and trying to
help detect cross-site scripting
vulnerabilities and so on but that's
kind of a maybe uh maybe a larger
discussion yeah yes good one there is
there any special header pervert for
preventing CSRF attacks cross-site
request forgery attacks now who's heard
of CSRF before oh good I'll have maybe
half the folks CSRF real quick is when
an attacker forces you to make a forged
request under the covers like so click
jack you think of it like clickjacking
is getting you to trick trick you in to
clicking a button to do something right
but CSRF is basically you don't have to
click a button you just have to go to
some evil web page and not click the
button on the web page essentially and
the comment is is there a header that
allows you to prevent CSRF from
occurring and unfortunately no there's
no way the way to prevent CSRF is to
well manually or as part of your
framework include something in the
request that the attacker doesn't know
but there's not a header to prevent that
and we can talk more about that after at
the end of the session if you like good
stuff anyone else anybody all right
okay so x-frame options now with x-frame
options you might not want to use it for
the entire site up front we had a
comment is what if your site is doing
iframes itself right because it also
prevents legitimate framing of your site
like Google Image Search sometimes will
frame your site itself and it could
cause that to break now for sensitive
transactions you might want to use just
same origins so that like you said
upfront
only your domain only your origin can
actually frame stuff on your site itself
and of course make sure to test
thoroughly because who knows if certain
parts of your application are using
framing and if the page should never be
framed then go ahead and use deny but
then you need to make sure that you do
even more thorough testing in those
particular cases
now whatever what about the browser's
what about browsers that don't support X
frame options the older browsers right
what a lot of people wind up doing is
they add some frame busting code to
their application is just a bunch of
JavaScript it's a little bit of
JavaScript like we see here in the
middle and there's different ways to
implement this but essentially it's
saying that if the current page the top
is not equal to self then let's go ahead
and change the location of the top the
outer page to the to the page itself
self dot location right anybody use this
in their applications this a little bit
of frame busting JavaScript code a
couple people handful of people now this
is good as handy to have in there but
it's not foolproof right there's some
security researchers at Stanford right
some students at Stanford that did a
paper that nicely summarized the
different frame busting techniques ways
to break out of that little bit of
JavaScript code that is trying to
intended to prevent clickjacking from
occurring here in IE you can set iframe
security equals restricted right when
you do that it disables javascript
within the iframe and of course if you
disable javascript that top location
check can't work right so that's one way
you can also call the repeatedly send a
204 204 HTTP response that basically
says there's no content so the on before
unload handler right when you change to
self dot location and change the top
location value then that will get
cancelled it'll never get called so in
that just in cases like that right that
javascript might not work and then
finally another example is certain
browsers also have xs/s filters built-in
like we talked about with the XSS
protection header those features are
automatically built-in in some cases
down at the very bottom in the lower
right here an attacker could simply
simulate cross-site scripting reflected
cross-site scripting by passing in the
code we saw in the previous slide if
top-knot equals self top location gets
self location and if you do that then
the XSS filter built into the browser
itself will say hey this is a potential
attack don't let that little if
statement rot and so that will break
your that could break your frame busting
code all right any questions before we
wrap up here all right so we yes yes yes
the question is are there any sites that
recommend it to keep up on this stuff
the very last slide here is a couple of
references that we use for this and you
know OWASP has some good stuff and sans
has some good stuff as well yes
right yeah so the question is what we
were just talking about with the kind of
the evasion techniques are there other
known evasion techniques for cross-site
scripting to get around some of these
particular things and if you yeah
there's you know that's the problem with
uh with security that we has developers
have a harder job than the attackers
because we have to secure everything the
attackers all they have to do is find
one hole right and they could
potentially get in with that and they're
constantly thinking of different clever
ways to bypass filters bypass all of
this stuff in different ways to attack
the application and if you you know if
you just google for XSS evasion and XSS
ie XSS auditor there's a lot of research
that has been done into various evasion
techniques of different ways that you
could pass JavaScript right and this is
an arsenic has a cross-site scripting
cheat sheet with different things that
you can use different techniques that
you can use to conduct cross-site
scripting itself so yeah yeah exactly
alright so we talked about different
headers header related things that we
can do to prevent some of the most
common vulnerabilities in cross-site
scripting we talked about three things
right using the secure flag using the
XSS protection header and finally using
content security policy for session
hijacking we talked about two ways to
help mitigate that specifically using
the secure flag and using the strict
Transport Security header and then for
clickjacking we talked about how we
could use X frame options to prevent
that from becoming an issue right so
real quick just to wrap up I would say
that if any of you guys want to use
these headers right go ahead and use all
of the ones that we've talked about
today of course you've got to test your
application as well but also plan to use
content security policy because I think
that's really powerful and the reason I
say plan to use it because I think more
than half of you guys raised your hand
and said you had inline scripts so it's
gonna take a little bit of refactoring
right it's not impossible but it takes a
little bit of refactoring your current
app to make content security policy work
but if you do right it can eliminate a
whole class of vulnerabilities all right
which is very handy right without having
to actually change the code and do input
validation and all of the traditional
approaches that we normally take for
reflected XSS right so what do you do
from here
right you know I mentioned at the
beginning that I do some stuff with the
SANS Institute we have a bunch of free
resources to your question up here in
the front over here on the left hand
side website courses blog and so on we
actually also have a booth a SANS
Institute booth up in the Grand Ballroom
we were given away free t-shirts that I
think are pretty nice so go stop by the
booth say hi pick up a free t-shirt of
course we've got our various courses
over here on the right and you know I'm
the author of the secure coding and Java
course so that's the most important box
of course on this whole slide and I'm
also online here's my email if you want
to hook up with me on LinkedIn yeah and
I have business cards up here if you
guys would like if there aren't any
other questions thank you guys all very
much for attending</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>