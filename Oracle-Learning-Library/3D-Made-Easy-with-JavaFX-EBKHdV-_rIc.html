<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>3-D Made Easy with JavaFX | Coder Coacher - Coaching Coders</title><meta content="3-D Made Easy with JavaFX - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>3-D Made Easy with JavaFX</b></h2><h5 class="post__date">2013-02-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/EBKHdV-_rIc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">and we're going to be talking today
about 3d into what is up till now been
primarily a 2d API and that is JavaFX so
we'll go ahead and get started with our
presentation so what I'll do is if there
are any questions meticulous section or
topic I'll take a few during the middle
but I'd rather have most questions wait
until the end but if you have a
clarifying question on something that is
very specific to the topic recovering go
ahead and ask it then but I'll plan to
leave plenty of time probably 15 minutes
or at least ten at the end for questions
so alright go ahead
the lawyers made us put this on here so
be sure to read that go ahead the agenda
that I'd like to go over today some of
you may have attended the talk that we
did last year the first couple of
sections are I'm going to go over them a
little more quickly than I did last year
so but it will be somewhat of a
refresher for those who saw it last year
and it'll be new for those who haven't
and that's that we want to go over a
little bit of an overview on JavaFX
graphics we want to go over the
transform model of JavaFX
and then talk about cameras and the
coordinate system things that now become
important as we're doing 3d and then
talk about things like depth testing and
some of the things we're adding in
JavaFX eight are movable cameras 3d
geometry and attributes and we'll get
into those a little bit later okay next
slide so for those of you so first of
all how many of you have programmed in
Java FX before see by the show of hands
okay so a good number of you have so so
the yes I suspect you have Carol thanks
a lot of a lot of people when they first
get into it find out that it's a
different model especially if you come
from the world of Swing or just doing
straight Java 2d programming Java FX is
fundamentally a scene graph based API
that means you define things in terms of
a scene graph hierarchy with transforms
to position objects relative to one
another we have two different types of
notes in Java FX we have
of group nodes or parent nodes those
have children but no direct geometry and
then at the leaf of our scene graph we
have the geometric primitives the
parent-child relationship is a directed
acyclic graph for those of you who are
familiar with that alright go ahead and
some of the capabilities that the scene
graph provides every node in the scene
graph has a transform and we'll talk
more about that in detail we have
provided animation in JavaFX
to allow you to very easily animate over
time any number of properties whether it
be a transform a color or just some data
value that you want to use you can apply
an animation to that and it will
automatically interpolate those values
over time we have a number of different
2d filter effects like blurs drop
shadows color filters motion blur
various other effects and then we have a
number of rendering attributes that you
can apply to your scene graph objects
next slide so the primary graphical
nodes that we have there's really three
types actually four if we count image in
media separate so we have basic shapes
like rectangles ellipses general paths
and then we have text which is although
it inherits shape it's a very
specialized rendering so we have fonts
and and various types of anti-aliasing
that you can apply to to text nodes it
also does text layout so that it will
wrap in a text field object or on a web
page with our webview component it will
wrap text appropriately as a browser
would and then the other two types of
nodes we have are very similar to one
another and that's we have an ability to
view an image or a media stream as a
node in the scene graph okay next slide
so this is a block diagram of the JavaFX
software structure I guess you'd call it
the application sees the JavaFX UI
controls and the scene graph API
underneath the JavaFX scene
F API we have the prism renderer that's
the rendering engine that we use to
render all JavaFX primitives we have two
main hardware accelerated pipelines one
for direct3d which we use on Windows and
one for OpenGL which we use on all other
platforms including if any of you saw
the keynote or have seen the kiosks
around we now run on linux arm platforms
and all that's done using OpenGL on the
smaller devices we use OpenGL ES on
desktop devices we just use standard
OpenGL GL - although we stick primarily
to the es - subset in addition you'll
see over on the right
a third software our third pipeline the
software pipeline when we're running on
devices that either don't have the
proper hardware support or whose driver
is too old or we haven't managed to
qualify and make it robust we will run
in the software pipeline case usually
for Windows it's only if you're running
on older hardware so we require Intel HD
or better on Intel devices and a
reasonably modern Nvidia or ATI hardware
and similarly on on Mac and Linux and
we'll have a slide on that in the minute
so that you know where you're going to
get hardware acceleration we will
automatically detect and fallback to
software if we need to ok next slide so
this is a simple scene graph for those
of you who haven't seen JavaFX before
it's it's brand new to you and for those
that have it's a refresher a stage is
the JavaFX equivalent of a window so
it's a top-level window that you create
and it can run either in a browser or on
the desktop unchanged so you just create
a JavaFX stage and it can either be
embedded in a browser or we will create
a top-level frame for you and then
render that a scene is the content of
your stage so you can almost think of
that the analogy and swing might be a
the content pane that you would put in
and then a scene has a background color
so in this case we're that this is an
example that will show you in code as
so we're going to put a silver
background color on the scene and that
will fill the entire scene which is
sized to fit the visible drawing area of
the stage then we have a root node which
is just the root of your graph and in
this case it's just a simple group node
and then finally we have a single leaf
node which is an image view and we will
load in an image apply a drop shadow and
then position it in the window okay why
don't we go ahead and go to the next
slide
yeah go to the next slide sorry okay we
are ready then so go ahead and switch to
the demo now so we're going to run the
the first few programs in NetBeans and
we'll show you some code samples for
some of these I hope you can see back
there in the back row sorry we can't
make the font any bigger but what we
have here is just the the most
straightforward JavaFX program the
entire program is actually shown on the
screen right there that that's that's
the whole thing excluding the import
statements that you need to to make
those classes known to Java so we first
start out by defining a subclass of Java
FX application all job FX applications
are defined that way and they have a
start method that you must override we
pass in a stage into that start method
the JavaFX runtime does and that's the
primary stage that your application has
at its disposal
and so when our application does our sub
class which is called simple which is a
pretty basic application is we will set
the title of that stage we will create a
scene and then assign it a color and
then we will create an image and to do
that we just specify a URL and that will
create an image object and from that we
create an image view node apply a drop
shadow effect and then position it on
the scene because we don't have any
other transforms that coordinate to 5250
will be relative to the upper
left-hand corner of the scene all right
why don't we go ahead and run that
program so not not a very exciting
program but it does just what the
program shows it loads in an image and
positions it with a drop shadow so
that's your simplest JavaFX program and
you could actually take that program
compile it and run it with no trouble go
ahead let's go back to the slides
nextslide
okay so we started to touch on the
notion of transforms it when you get to
3d it becomes even more important but
even for 2d transforms are the way you
take nodes and position it relative to
each other so in our previous example
what we did is we took that image view
apply to transform to it in both x and y
to position it in the appropriate place
on the screen so some of the various
properties on node that allow you to do
different transform operations are the
layout x and y properties those are
actually reserved for the layout manager
if you put this in a layout container
such as a flow pane or a an H box or a V
box or any of a number of other built-in
layout containers or ones that you write
it will modify the layout X and layout
ly of every node underneath that so the
only time you as an application
developer should ever use layout X&amp;amp;Y is
if you're doing your own layout and not
putting it in a layout container so
that's sort of for whoever is the layout
manager to do a final positioning of
that relative to its parent and then we
also have a translate x and Y and if
you'll notice in red we've highlighted
translate Z that's actually in the API
today so even though we don't have 3d
geometry we do have 3d transforms today
and they've been in since JavaFX 2.0 and
so you can translate or position your
node in X &amp;amp; Y or in Z so you can push it
forward or pull it back in in terms of
its relative closeness to the viewer
similarly we have rotation and scale
operations the rotation angle by default
is just a 2d rotation it rotates about
the z axis which is just a line going
straight through the center of your your
object and that's what it will rotate
around but you can specify a different
axis and we'll show a few examples of
that where you can rotate an object in Y
and so it will spin around like this or
you can rotate it about X in which case
it will spin around the horizontal axis
or you can define your own axis with any
3d vector likewise we have scales
separate scale values for x y&amp;amp;z you can
scale them uniformly by binding those
three to the same property and then
you'll get a uniform scale or you can
distort it in X and Y or Z and scale
them independently finally we have for
those applications that want a little
more control an arbitrary list of
transform objects and so every node has
those the first few we call them
convenience transforms and a lot of our
built-in interpolators animators will
operate on those or you can just roll
your own and set an array of transforms
okay next slide so the transform objects
that can make up that array of objects
are made up of either translate scale or
rotate we also have a general-purpose a
fine but that's a more advanced topic
than we want to get into today all right
go ahead for next slide it's important
to understand what the order of
transforms are so the way we apply
transforms in a node is similar to how
we apply them going down the hierarchy
from node to node so if you have a
parent node with some transforms they're
applied first and then you have a child
node that might have its own transforms
then they're applied next within each
node they're applied in this following
order the layout and translate x and y
and the translate Z are applied first
and then finally Ari and then we apply a
pivot transform so that we will do our
rotations and scales about the center of
the object and then we do the rotation
and scale and then finally we undo the
pivot so that we put it back so
basically what that does is it allows
you to rotate the object independently
from translation and then finally we
apply the list of all transform objects
in order from 0 through n where n is the
number of transforms you have all right
go ahead next slide
so one of the things that's unique about
3d that you don't encounter in 2d is the
need to have the objects sorted based on
where they are relative to the viewer in
2d the Z order is strictly defined by
the render order so if you define five
nodes a B C D and E they will be
rendered a first so it'll be on the
bottom then B then C then D and lastly E
which will be rendered on the top and
that's always the way it works in 2d
next slide please
that this is an illustration of that
with four nodes I might have a root node
a couple of groups and then for
different leaf nodes so for the four
children a b c and d will be rendered in
that order with a on the bottom and d on
the top next slide so the render order
for 3d objects doesn't necessarily
correspond to what the z-depth of those
objects are if you apply different
transforms or if you have you know
completely different group nodes with
different Z values you might have a case
where you have a very different
rendering order so if you go to the next
slide in this same case imagine that we
have a Z translate values such that the
Z values are shown with the object a
being at Z equals 0 object B at 3 and so
on in this case the rendering order
hasn't changed it's still ABC and D and
that's the order they're going to be
rendered and so D will be on top however
if you go based on the Z orders a should
be on top followed by C D and then B so
we really would like to render B first
and then D then C then a but we can't do
that without reorganizing our scene
graph but we have a different solution
for that and 3d graphics cards will
support this different solution and
that's called a Z buffer so if we go
ahead to the next slide a Z buffer or
depth buffer is part of OpenGL and
DirectX and all three
hardware will support this and what it
does is a per pixel sort based on the Z
value of that pixel so if you draw you
know four rectangles as we showed as we
showed above then regardless of what
order you draw them in the one with the
Z value closest to the viewer will
always appear as if it was on top
whether it was drawn first last or
somewhere in the middle okay so in
JavaFX we've provided control for the Z
buffer by allowing you to construct a
scene with or without a Z buffer the
default is without because most 2d
applications not only don't want a Z
buffer it would actually be harmful and
so we allow you to specify a depth
buffer or that the request to create a
depth buffer in the constructor of the
scene object and then each node lets you
decide whether or not you're going to
use the Z buffer so there's a depth test
property on every node it has three
values and by default it inherits from
its parent and so the root node by
default will inherit from the scene so
only if the scene has requested a Z
buffer will you get Z buffering and then
if you request it you'll get it by
default on everything but you can turn
it on and off as needed go ahead so now
that we've discussed our first 3d
feature it's time for me to point out
that 3d is an optional feature in java
FX so if you remember back we talked
about the three pipelines there's the
two ik hardware-accelerated pipelines
direct3d and OpenGL and then there's the
software unaccelerated pipeline
currently the software pipeline does not
support 3d it is also possible that we
might someday put JavaFX
even with hardware support on a device
that for whatever reason doesn't support
3d or whose driver is incapable of doing
it so we've made 3d an optional feature
it's always in the API but you have to
query it if you want to be sure that
it's actually going to be there at
runtime and the way we provide that is
by having a conditional feature and
that's seen 3d is the conditional
feature bit that you
check and that indicates that 3d is
available on the platform which means a
whole bunch of things it means your
prospective camera which we'll talk
about in a minute is available it means
your depth buffer is going to be
available and it means our 3d geometry
which we'll talk about later is
available so in the absence of this you
can't reliably use 3d ok next slide so
on Windows I alluded to this earlier we
we use direct3d we require version 9.0 C
which is actually very old by now so we
don't have a very high requirement on
our software version but we do require
pixel shader level 3 and so with the
driver support that we need we really
need on Intel Intel HD or higher so
there are some older laptops around that
are going to have Intel's that are pre
HD we don't run hardware accelerated on
those will fall back to software and
pretty much any modern Nvidia ATI can
support it ok on Mac OS X pretty much
any modern hardware that anything that
supports Mountain Lion will run prism
most things that support Lion although
apple doesn't check so you can actually
run it on older hardware but anything on
the hardware configuration list of Lion
supported systems will also be able to
run prism and hardware accelerated motor
ok oh sorry please
yes
that's right so if we detect a platform
that doesn't support
hardware-accelerated we will fall back
to the software pipeline and in that
case if you query conditional feature
seen 3d it will return false
no well fall back to software means you
don't have 3d absolutely okay yeah yeah
to make that clear
fall back to software is for everything
else you would do in Java FX so you
still have to D transform you still have
effects you still have the ability to
draw into a canvas you don't have 3d
that's that's very true okay go ahead on
Linux our story is a little bit evolving
and that's because the driver support on
Linux is spotty at best as of the time
we did JavaFX 2.2 really only nvidia had
decent enough drivers that we felt it
worth our time to qualify it every time
we tried running on Intel it was an
exercise in pain and on ATI we just
didn't have time to qualify it and on
our main platform which is a bun - 10.04
for our current version there was really
no good ATI driver support for our next
version which is FX 8 which will be
releasing with JDK 8 we plan to qualify
ATI drivers and ATI now has reasonably
good driver support for a bun - 12.04
LTS which is going to be what we're
going to spec out for anybody wanting to
use 3d alright go ahead ok so since we
were talking about depth testing we
thought it would be a good idea to show
you a demo of what depth testing is and
why you need it so if you want to we'll
go through the the slides over the the
code first so the first thing to notice
is we are going to create three
rectangles and do pretty much what I
showed you in that sample scene graph
we're going to have it such that the Z
order is different from the rendering
order and so if you look we're creating
a green I'm sorry a red a green and a
blue rectangle the blue rectangle should
be in the middle the red rectangle
should be in front and the green
rectangle should be at the back but
that's not the order they're drawn so in
the absence of a z-buffer
it's going to appear as if the blue rec
is always on top okay why don't you run
the program so sure enough there it
comes up and even before you move it you
can see that the blue rectangle even
though it should be in the middle is on
top now what happens if you rotate it
about the y-axis so you can see it looks
like it's supposed to be in the middle
and then you rotate it up breaks the
illusion because now it's back on topic
in the blue rectangle so the solution
again is to request a Z buffer the
reason this happened is because we just
created a default scene we didn't
request a Z buffer so why don't we go
ahead and do that so if you look at that
line of code there on the screen so we
comment out the or I guess uncomment the
new one you need to no no no wrong one
up there you go so we need to comment
out the old creation of the scene and
then we create a scene with the depth
buffer flag set to true now go ahead and
run it again so in this case correctly
now blue is in the middle regardless and
then red and green are correctly in
front and back as they rotate around
each other and so go ahead and rotate it
again yes
yes we are
we'll get to that in a minute thanks for
the question yes absolutely well we've
got a slide on that but but Z goes
positive into the screen so now if we
wanted to disable z-buffering we can do
that so that this will disable it on the
rotation group that actually has the
three rectangles and so now we're back
no better than we were before because
we've turned z-buffering on and off okay
go ahead and then we run the next
program so the next one we won't show
you source code for this because it's a
it's creating a cube out of six 2d
objects and six transforms and positions
and so that the code isn't really what
we wanted to illustrate here this just
shows you what you can do even with the
existing API so this is possible with
JavaFX 2.2 today and if you expand it
you can see that this really is these
this is just six separate faces each of
which has a media view on it now if you
turn off depth buffering put it back to
the Y rotation thanks okay so if you
turn on depth buffering and then expand
it and collapse it again you can see you
just don't get a very realistic that
does not now feel like a solid object
because it isn't now if you turn depth
buffering back on you get the the solid
effect again so this is why depth
buffering is so important because in the
absent just in the absence of depth
buffering we would have to reorder those
six phases every frame well if all you
had is six phases in your scene that's
not that big a deal but if you have
hundreds or thousands of those cubes
with six phases or if you have spheres
or other things more is just not
practical I'm sorry yes you had a
question we don't but there's no reason
why at least a couple is like so this
one we couldn't post the media because
we don't have the rights to ship it we
have the rights only to show it we do
have so the we do have one that shows a
3d cube like this do you want to run the
color cube so it are you familiar with
the ensemble sample so that that's our
primary sample it's a maybe if we have
time we'll run it at the end I'm not
sure we will but we will be showing that
at the booth it's a demo that shows a
collection of individual samples one of
which is the color cube that you're
seeing here that that one is available
online absolutely just go to the main
download site for java SE
if you go to the demos and samples it
will be there so if you just download
JavaFX samples and look at the color
cube sample inside there and an ensemble
if you also look at the code ensemble
has the check for whether or not scene
3d is supportive and so if you run that
on a Linux machine with an Intel card
and go to the cube 3d sample it'll just
say I'm sorry you can't run 3d so it's
got that yes
the transforms will not work correctly
so what's documented to happen and what
actually happens are ever so slightly
different it's documented that the
transform will be an identity if it has
any 3d so if you do anything other than
a scale translate or rotate about the z
axis anything other than a 2d transform
we say oh we're just going to treat that
as the identity what we actually do is
is treat it as a sort of e2 we use the
2d portion of that because we're just
going to end up doing the math anyway
and then projecting it without
perspective without camera so it doesn't
give you a very happy experience what we
would like to do is do something a
little more consistent and we're going
to have to vote for the 3d primitives we
need to do something better than that I
think in that case we're just going to
say it doesn't draw at all because there
is nothing really sensible we can do in
that case until we have software support
for that ok next slide yeah we already
did the video cube demo okay so we
touched a little bit and then Carol's
question kind of highlighted the fact
that we have to talk about the
coordinate system of JavaFX so we have a
camera in JavaFX and what that is is an
object that says how you're supposed to
view your scene well in 2d there really
isn't much of a concept of a camera in
3d we have two different types of
cameras that we can use one of them is a
parallel camera which actually mimics
exactly what a 2d viewing would be and
that's the default it's a viewing volume
for an orthographic projection and it's
basically just a rectangular viewing
area that you're going to get whatever
is in that rectangular area rendered on
to your window the units are in pixel
coordinates by default and the origin is
in the upper left corner of the window
so for those of you familiar with either
Windows system programming directly or
with Swing or anything else this will be
very familiar to you go ahead and next
slide we also have a perspective camera
which you have to create and select
Blissett ly by default if you use the
fixed camera which is all we have in
JavaFX 2.2 you could switch between a
perspective camera and a parallel camera
and you will see nothing different as
long as you don't have 3d transforms so
for objects at z equals 0 in scene
coordinates they look the same so
independent of whether or not you have
perspective or parallel we have a field
of view property which for any of you
who are familiar with real cameras it
mimics a field of view you know just
says how wide an angle you have on your
your camera the fixed camera that we
have defined right now is located at the
center of the scene and it looks along
the positive z axis so we have X going
to the left Y going down and Z going
into the screen and again the the units
by default are in pixel coordinates
because we didn't want to D users to
have to change everything they do just
because you did a parallel can't our oh
sorry perspective camera next slide so
for those of you who have done a lot of
3d programming there's a few differences
most people tend to think of 0 0 in the
center when you're doing 3d just because
it's a lot easier to model things that
way very often your units will not be
pixel coordinates they will either be
some units like meters or centimeters or
miles or parsecs or maybe even some
normalized coordinate system like just a
minus one to one space and so you want
to be able to handle that well that we
provide 3d transforms in each of our
nodes to allow you to handle that also a
lot of times we have Direction
associated with your model so if you
load a model it might be upside down if
that model are expected that Y was up so
it's just a simple matter to flip your
your object the other way because JavaFX
is camera always goes Y down and always
go Z into the screen alright next slide
so one of the things you could do this
is a just an example of something where
we're currently not planning to provide
a utility directly to do this although
we will provide sample code to do it and
it's something we could someday provide
a ease-of-use utility and that's that
you could provide a simple coordinate
system converter group up at the top of
your scene graph your 3d portion of your
scene graph and then so we're going to
show an example of doing just that where
we have a translate rotate and scale
that we can apply to turn things around
and put them in the centre and then
we're going to show that by having an X
Y and a z axis and then a box that we're
going to put in there yes
so so today a scene can only have one
camera that's something the good
question in will will cover that we've
added the ability to have seen within a
scene but the main scene that's drawn on
the window is drawn with a single camera
so you can switch between them but for
anyone rendering frame there's only one
camera per scene with with an exception
that I'll talk about a little later all
right go ahead and then I think we'll
vibe without that any further ado we'll
run the coordinate system demo so this
is just something we actually did this
for last year's talk as a way to
introduce coordinate systems and I think
it's important enough to to run through
it and so if you want to run the
application I don't think there's much
in the air oh actually there's one one
thing I wanted to highlight is note that
we have explicitly set a perspective
camera as well as turn z-buffering on by
creating the scene with a z-buffer okay
okay so here by default if you just
create an XY and z axis lines it'll show
up in the upper left hand corner that's
where zero zero zero is in the absence
of any other transforms okay go ahead
and add an object so now we're going to
add our image view but the modeler of
this 3d cube of images thought that Y
should be going up and so that's why
it's upside-down so now we could
translate that so with our coordinate
system group we can translate that into
the center now you can move it around
if you want and then reset that and then
but we're still upside down turn that
right-side up and now you can still move
it around okay so and you'll notice
z-buffering is on and you can turn that
off but we've already done that so if
you can see that so that's that's how
our camera works today it's a fixed
camera so the camera does not move in
this case what we're doing is we're
moving the object only all right go
ahead and go back to the slides
okay
yeah in that case we're moving the group
that's correct that the fact that cord
sis helper group is what we're moving
yes
um
no in that one we're using so we're
using separate ones for translating it
to the center and rotating it about
there the mouse controller I can't
remember what we used that one might be
an affine or it might have been three
separate ones I you could do it either
way okay so here are some of the
features now that we're talking about
that are going to be coming in fx8 which
as I mentioned earlier is going to be
part of JDK 8 so that's under
development now early access builds of
fx8 are available with Java FX are sorry
with JDK 8 but we don't have any of the
the stuff we're now talking about is
under development right now so anything
we show you from here on out is a
prototype of what we will eventually
have and so any code snippets we have
will be in slides so what we're adding
is movable cameras so you saw the fixed
cameras we're going to move them now
we've got various 3d primitives 3d
attributes and then we're adding a few
other auxilary functions like 3d picking
okay so this is our class hierarchy
today camera inherits from object it's
not a node in the scene graph what we're
changing is that camera is now going to
inherit from node what that allows you
to do is stick it in the scene graph as
a node in the graph and thereby position
it along with everything else in your
scene graph so the position and
orientation of that camera will inherit
from whatever transforms that it has in
the scene we're also adding a sub scene
so that gets to the question of how do
you have multiple cameras and we'll talk
about that in a minute go ahead next
slide so I think we we pretty much
touched on this already I wanted to
point out though for backward
compatibility if all you have is a fixed
camera you don't need to add it as a
node in the graph you still in all cases
you say scene dot set camera camera
that's the way you tell the scene to use
you the camera to render but you don't
have to add the camera as a node
anywhere in your scene graph if you
don't
- that's only needed if you're going to
move it
we also are adding new properties for
near and far clipping plane to control
the z-buffer range better okay and this
is the code that you saw in the other
slide it's very straightforward and
that's all you have to do to add a
camera to the scene now if you want to
move it the new code so that the first
code in gray there is the same as the
previous slide that doesn't change but
if you want to move the camera in this
case I decided I wanted to create a
group on top of the camera just to
illustrate that you can move the camera
or any of its parents in the scene graph
hierarchy so in this case I create a
group I add the camera as a child of
that group and add the group as a child
of the root node and now I can using
transforms rotate either the camera or
the group node that that camera is a
member of and in either case that moves
the camera and moves what you will see
okay next slide so sub scene is the way
that you can have different parts of
your scene rendered with different
cameras there are many uses of this
there's like a rear view mirror or
picture in a picture type of an
application one of the main uses though
that we expect to be used is that you
could have your 2d content unaffected by
your moveable camera because that would
be rather disconcerting if you wanted to
a straight overlay of UI controls and
didn't want them to start flipping
around and moving every time you moved
your camera sub scene is the way you
would do that okay all right so will
will now go to a moveable camera demo
okay so here what we have is three axes
again they're the X and y or all you can
see because Z is going straight into the
screen up now you can see the Z and now
if you move the object you'll notice in
this case because I've attached the
coordinate system as a representation of
the actual camera's coordinate system it
doesn't move when we move the object but
we can move the camera to now so with
the other control that he's using he's
actually transforming the camera by
changing the transforms above that
camera so one of the other things you'll
notice is you see those buttons up there
that's an example of using sub scene so
those buttons are not moving when he's
moving the camera and they form an
overlay that are always drawn on top of
the object and as you move up there
we'll be able to see that just move it
up a little bit more move that up so
that you can so that it goes above
there we go okay so even though that so
those 2d controls are not being z
buffered they're not positioned using
that camera but that they appear as an
overlay and that's done with those okay
why don't we go back to the slides
okay so 3d geometry everything that
we've shown including that last example
is done exclusively with 2d shapes image
views rectangles circles all we've been
doing that's been 3d has been the
transforms in the camera so what we're
adding in fx8 is real 3d geometry and
we're doing two flavors of 3d geometry
either you define your own mesh your own
surface with whatever mathematical
equation or model that you have created
or you can use three predefined shapes
that we have defined go ahead to the
next slide so mesh view is the way you
define your own geometry and then those
are the other three shapes they inherit
from a new abstract based class called
shape 3d which is analogous to the 2d
shape class next slide and then a mesh
view object takes a mesh data component
which defines the actual geometry and
right now we provide one concrete class
triangle mesh so the triangle mesh is
defined as a set of positions and
texture coordinates
those are the vertexes that are in your
object and the faces define the topology
so you would define the faces as a list
of positions and a list of texture
coordinates that make up each triangle
in your mesh we introduced the concept
of smoothing groups for any of you who
are 3d modelers you'll recognize it in
any that aren't we'll show you an
example later on
it's basically defining which parts of
your mesh should be treated as a
continuous curved surface and which one
should be considered discrete facets and
so should have a hard edge between them
important to note that a single mesh can
be shared among any number of mesh view
objects in the same way that a single
image or media can be shared among any
number of image view or media view
objects okay go ahead to define a mesh
view you would create an array of
positions and texture coordinates and we
won't show that that's beyond the scope
of this talk to say how you're going to
do that and then you would create your
list of faces which are just as I
mentioned earlier indices into the text
chords and
and then finally you create your mesh
object by setting the positions text
chords and faces arrays and then create
your mesh view node and so mesh view is
the thing that's a node in the scene
graph and can go in anywhere any other
node can go in okay so let's
okay this is a mesh view object you can
move it around doesn't look much like a
3d object but if you turn it into
wireframe you'll see it's made up of
lots of tiny little lines you can turn
it back into solid because it's a bunch
of individual vertices we can apply
different operations we can change those
vertices on the fly and we can actually
make it into a function you know any
mathematical function we want we can
define that now you can move that around
so if you rotate that you'll you'll see
that it has some lighting that's playing
off that and some some material
attributes so we'll talk about those
later okay let's move on to the next one
next next slide you have it next slide
yeah it's we have slides on there
that's okay
okay and then just really quickly that
using the predefined shapes we've
defined sphere cylinder and box you
specify a sphere it's as simple as that
first constructor you just give it a
radius and we'll do a default
tessellation on that
so unlike 2d circles or ellipses these
are actually converted into a mesh view
so we will either use a default
tessellation into a mesh view and we'll
show you that in a bit or you can
specify it and then similarly a cylinder
alright go ahead to the next slide notes
from the demo
okay in this case we're going to show
one of the three predefined solids
that's a cylinder and so getting back to
the concept of smoothing group the top
and the bottom are in a different
smoothing group than the body of the
sphere because the body of the sphere is
one continuous curved surface but
there's a hard edge between the body and
each of the top in the bottom so that's
what smoothing groups are used for and
then if you turn it to wireframe you can
see that we really do tessellate this
into a mesh and you can create a higher
res version of this if we want and that
just shows you how its tessellated if
you turn it back to solid you'll see go
to the lower res version you may not be
able to see it as well from the back row
but we could actually see that it's a
it's more faceted this way than them
this way and that's what you would
control with the tessellation alright
let's not show the other primitives
really quickly so we've got sphere and
then we've got a box
all right let's let's move on we're
going to talk about materials next so so
far we have we've not talked about
anything other than the geometry but
there's also different attributes we've
got lighting and materials materials are
used to specify the appearance of the
shape lights are used to define the
environmental lighting that would go on
similar to the way you'd use lights in a
you know a photo shoot we have a couple
of other various attributes like culling
and wireframe mode which we showed the
wireframe mode earlier all right go
ahead so lights inherit from a single
base class called light base and then we
have two types defined now ambient in
point we might consider additional types
of light in the future those only two
are committing to for this release okay
lights are also nodes in the scene graph
just like cameras we have a default
light if you don't specify one but as
soon as you add a light to the scene
graph that now becomes your light will
remove the default light automatically
each light can affect either the whole
scene graph or just a portion of the
scene graph by default it affects the
whole scene graph you can specify a list
of usually group
to define portions of your model that
get affected by that light okay and so
this is just some code showing how to
define a light so the first thing is
just to define the light source and its
color and then we're going to add it to
the scene so at that point it would
affect every light in the scene but it
wouldn't be movable
it would just be at a fixed location not
very interesting the next code is very
similar to what you saw in the moving
camera example we're going to create a
group node add the light to it add that
group node to the root and then we can
using transforms manipulate the position
of that light so the concept is very
similar to cameras all right now we'll
show some demos of lighting
yeah yes thank you
so those two spots are actually visual
representation of the lights in the
world and we can animate it so we
actually have one of the lights and and
we literally have created a group node
with some geometry representing the
light and the light node so it's a group
node with two objects there and then as
we move that group node around not only
does the the position of the light that
you see changes but its effect if you
notice that it now illuminates
the objects differently as it goes
around just like a real light would and
then in the upper right hand corner
we're animating the color of that light
so it's changing from green to white and
back all right now we'll go to where
we're going to talk about materials so
so far everything just looks like a
white blob it's shaded so you can tell
it's got some three deenis to it but
it's not very realistic or very
interesting materials are the way you
add an appearance to your object to make
them look more realistic and more
interesting we define in Java fx8 one
specific type of material it's called a
foam material for any of you who are
familiar with fog lighting that's where
that comes from
so our at our sorry our material
contains the following properties we
have an ambient diffuse and specular
color more interestingly for diffuse in
particular we can define a texture map
that it's an image that will get mapped
onto your object to give you either a
picture that's wrapped around your
object or an interesting pattern and
we'll show you an example of both of
those and then we have a few other
things we have bump mapping which we can
show you like geometry this is shareable
among multiple shaped 3d nodes so you
can create a library of materials and
use them in multiple places okay go
ahead
you create materials pretty similarly to
the way you do everything else up in the
interest of time why don't we go ahead
and move on to the demo
and so what we're going to do here is
this is the same demo but we're going to
show pudding first of all a just a flat
image on there so we're going to put a
diffuse map on there so you can see that
that's got a little bit of things and
now maybe you could switch to the other
primitives so we've got a little
different name oh right no
okay so if you look so go ahead and put
the image back on there so again this is
a just a texture that we've created for
this but it looks pretty flat so that's
where bump mapping comes in and so now
if you turn bump mapping on no so if you
turn bump mapping on in addition to the
texture we've got something that looks a
whole lot more realistic and so we can
show the bump map in the texture
independently or in this case we've got
a different map so again we've got a
nice little textured pattern on here but
it actually looks like it's got some
some texture to it that's not just a
flat image on there and then the box is
an even better example of that so if we
switch to the box so that this one's
interesting if you turn bump map off and
on but leave the texture on the whole
time so if you turn bump mapping off it
has a very different wrong one yeah
there you go
so it has a very different look to it
that looks very flat even though it's a
nice image and then if you turn it back
on you can see it actually looks
properly textured so that's all things
we're adding so this is a prototype of
what we will be delivering in JavaFX 8
so it sounds like there's some interest
in the room from us actually delivering
on that promise so so that's a good
thing we'll try to keep that problem so
I think that that's pretty much yet I
think we had a little bit of a wrap up
or so about the only other thing we
wanted to to highlight on the slide is
we wanted to run sort of a couple of
last little demos so it's all great when
you can define things as easy as
cylinders and spheres and boxes those
are really easy to even I can write the
code for that I can't write a code for
modeling a chair or this room or
anything else complex that requires
somebody with some modeling skills and a
very expensive piece of software and
then they produce a model and so you
need some way to get that in there are
many popular file formats in existence
there's a one of the oldest ones is
wavefront obj file format there's Maya
3d studio max colada kr ml and a number
of others I would imagine as many file
formats as you have companies producing
modelers we're not going to provide a
standard loader as part of JavaFX our
file format is FF XML so we will have F
XML support for for 3d just like we have
for everything else but we recognize
there's a lot of popular files already
out there in file formats and so we want
to provide loaders for at least a couple
of popular formats and we're actually
going to demo one of them here as sample
code though not as part of the shipping
platform ok alright so let's go onto the
loader demo
ok so now we're going to show just a
quick example of loading an object so
this particular one is something that
our good friend Carol had one of his
good friends generate this is a model of
a chair or a sofa and like I said this
is something that I doubt there's anyone
in this room that could come up with a
mathematical representation of that
object but it actually looks pretty
realistic because in addition to having
the geometry modeled with a model or you
can see there's realistic looking
textures with bump mapping on there and
so we've got both the wood grain and the
fabric and that's that's all rendered
using JavaFX prototype in real time and
for one last demo we've we're going to
we're going to end with a demo of it's
like a prototype of an application used
for a shipping container so if any of
you saw the keynote demo I believe the
actual application this was Navis as the
company that does this the actual
application was shown there we're just
showing a prototype demo version of that
here running live but you can see we
have 3d picking that was one of the
things we alluded to earlier and then
you can change the appearance you can
move the camera change the appearance
down there on the lower left so we can
highlight things based on how perishable
they are and you can get stats by
clicking on them and so this is just an
example of something you could actually
do a real app with the JavaFX right and
then you can you can see we can switch
to a more 2d view as well all right
anyway thank you all for your attendance
and didn't leave quite as much time for
questions as I had hoped but we've got
about five minutes oh go ahead throw
well 1 million ways
on this laptop all right
so we're expecting it'll be a pretty
powerful thing yes yes we even for 2d we
do for and actually everything you saw
here makes heavy use of it so even our
2d pipeline uses pixel shaders not at
the user application programming level
we use them internally so when you
define a bump map and a diffuse map and
all of those maps and the Lighting's we
do per-pixel lighting using a pixel
shader in this prototype and that's what
we're going to actually it there are a
lot of challenges in doing that we can
maybe chat about that at some point but
the the main challenge is we're already
using them for other things and what
language would you use so those are the
two big challenges so we don't plan to
do that in this release any other
questions that haven't been answered
already all right well thank you
everyone</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>