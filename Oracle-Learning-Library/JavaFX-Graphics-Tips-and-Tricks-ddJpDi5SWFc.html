<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JavaFX Graphics Tips and Tricks | Coder Coacher - Coaching Coders</title><meta content="JavaFX Graphics Tips and Tricks - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JavaFX Graphics Tips and Tricks</b></h2><h5 class="post__date">2013-01-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ddJpDi5SWFc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right good almost afternoon to
everybody thanks for coming
this talk is Java effects graphics Tips
&amp;amp; Tricks I'm Richard bear the Java
client architect so wow that comes out
yellow on the screen so this talk is
going to talk a lot about performance
tips and as with any talk on performance
tips you know take a big healthy dose of
caution on what you're going to see you
could go completely crazy and pre
optimize everything and you'll be very
sad if you do so first write clean code
then profile if you find out you have
problems that's great a lot of things
I'm going to talk about today are
principles that are always true it'll
always be faster to say you know write
some little code loops in assembly than
it is in some high-level say JavaScript
yeah that's true what is that going to
make a big difference in your
application most of the time probably
not but in those few cases where it's
important it'll apply same sort of stuff
for what we're going to talk about today
this is the state of the art in 2.2 in
Java fx8 we've made a lot of
improvements in performance and so there
some things may not be that applicable
in eight that are presently applicable
in 2.2 so for today we've got our
blackboard out and here's our syllabus
what we're going to cover we're going to
talk about some performance numbers it
did some benchmarking yesterday and I
had some numbers that I wanted to to
show you sort of give some context for
where we're at the second one is just
overall rules or principles for good
performance in Java effects and then a
bunch of tips and tricks along the way
to make stuff faster so the first
benchmark that I had results for was
Glee mark 2 vector so this test has been
around since I believe 2007 and in this
test it basically draws a four-level
stock chart that's continuously animated
and I grabbed performance numbers for
Chrome Safari Firefox and ie 9 all the
latest versions on Windows Linux and Mac
OS to the degree that it was applicable
and then I had two different tests for
JavaFX one that uses the scene graph and
one that uses the canvas node so in the
vector test on windows JavaFX was
beating all three of the browsers I did
not test Safari on Windows on Linux I
spent an hour and a half trying to get
chrome to install and failed so I only
have the number for Firefox there in
which case both the scene graph and
canvas version of Java effects did very
well and on the Mac Safari beat us but
we got the other guys now the
interesting thing on this one is that
you'll notice that on Windows and Linux
actually using the scene graph was
faster than using canvas so when we're
going through the talk just bear in mind
that sometimes it's faster to use one
technique sometimes it's another the
only way you can really tell is to do it
and profile it so the next test that I
did was GUI mark - bitmap this one has a
tower and a bunch of little monsters and
the monsters run around and then the
tower shoots them and in this test Java
effects is a lot faster than the
browser's I think part of it could be
the difference between the execution
speed of a JavaScript engine versus the
execution speed of hotspot but these are
just you know I just ran these tests
yesterday also interesting is the canvas
is way way faster than all the other
options the JavaFX canvas that is in
this case and on the browsers it's all
implemented using canvas now the next
one we had was text and here Java
effects did a pretty good job too in the
first one you just sort of have to
ignore the results on windows because I
was hitting 60 frames per second on the
Windows machine for the browsers as well
as FX and we're all sort of rate limited
at 60 frames per second so we don't use
too much of your battery life so there's
not a whole lot of data that we can
really acquire from looking at the
Windows results but the Linux and Mac OS
10 results are again pretty favorable
for FX now you can't really do text with
canvas and so there's no job effects
canvas version so it's just the scene
graph version so these were you know
these tasks were not meant to be like
official benchmark
information it's just I just ran the
things yesterday to see what would
happen and this is what happened one of
the things that we will be doing is
taking our benchmark information and
making it public so that everybody can
run the benchmarks and find out for
themselves on their own configurations
where we're at
guru mark ii is a public benchmark we
just need to put out the JavaFX versions
and then you guys can just run it now I
did another interesting comparison
because like I said we've been doing a
lot of performance work on JavaFX 8 and
so I wanted to compare how 2.2 vs. 8
went and this is basically what we've
done in JavaFX 8 is we've just about
doubled our performance in each of these
tests and the last one is an
approximation but we've done a lot of
work on the you know making sure the
Java fix eight was really fast and a big
part of it was all the work that we were
doing for the kiosk and embedded and all
the different demos has to be really
fast on those low-end devices and as a
result we got huge performance increases
even on the desktop so as we go through
the rest of the the the session content
bear in mind that we're actually really
fast to begin with and so but you can
stress the system and there are things
that you can do that it will help are
hurt so we'll go through this the first
rule to keep in mind whenever you're
doing Java FEX is that if you want to
make it faster well then do less work
one of the things you could do is you
could just have fewer nodes in the scene
graph so here's a little scene little
mini scene graph here and one of the
things that we have to do is we have to
apply CSS to the scene graph so we're
going to visit the first node then the
next and the one after and the next guy
and the nether one and then we're going
to go and do layout we're going to visit
first node and then the next another one
another one and another one and then
we're going to go do some mouse picking
to make sure that we've got the hover
state of the nodes correct and that's
going to require that we traverse the
scene graph sometimes it goes through
the whole scene graph sometimes it
doesn't have to there we go
and then we're going to have a rendering
pass which is going to do the same thing
it's going to have to visit everybody
we're going to have a dirty region pass
where we compute which area of the scene
graph is dirty and needs to be repainted
that's going to have to visit everything
so there's there's a lot of iterative
work that we have to do in terms of
traversing the scene graph so obviously
if you have an order of magnitude fewer
nodes there's going to be a lot less
work that you have to do so here's
another little piece of advice write
some on your desktop system and you can
get away with murder but on smaller
systems such as the Panda board Spiegel
boards or especially the Raspberry Pi
right it's going to require much more
intensive round of performance analysis
and tuning so the other thing is is that
a lot of times where the time is spent
is not where you may have thought it
would have been spent so here are some
example ways of how you can execute less
code so the first thing is that every
line of code you execute counts when
you're talking about an arm v6 at you
know maybe 320 megahertz or something
like that I mean the Panda boards that
we got by default started off at 320
megahertz they're dual-core we had to
crank them up to 9:20 to get it to you
know perform at 60 frames per second at
320 megahertz you're talking really slow
every line of code you execute really
counts and all those extra method calls
they all add up so some systems like
normally on desktop we always tell you
don't worry about it the JIT will take
care of you right it will analyze it
will in line it'll unroll loops it will
do all those sort of things but like Bob
Ben debt was saying at the keynote on
Sunday sometimes we can't actually do
that because the cache size that's
available on this little embedded system
just isn't big enough to hold a method
that is completely unrolled and inlined
and so we're actually going to have to
execute more code in order to do the job
so on some systems doing a lot of
inlining is expensive the VM isn't going
to do it and that means there's going to
be more method call overhead and all
those excessive method over call you
know method invocations those are
expensive we have to create a new stack
frame we have to populate the stack
frame we have to do a jump to some other
place do some stuff pop these things
back off the stack frame get back and if
you're doing that on tight inner loops
it can hurt you on some of these small
systems so you know as a good
practice we ought to just reduce the
unnecessary method calls so here's an
example of a method that happens a lot
this is a this method is called compute
craft width every every region subclass
any way in the system has one of these
so every UI control so forth has this
method and its job is to figure out what
the preferred width of the node is given
some height and sort of the I guess
simple way that you might have
implemented it was to just say well let
me get the N sets and then get me the
left of that inset and then I'll add 200
to it and then I'll get the in sets and
get the right okay so the only problem
here is that I've got I don't know four
method calls instead let's just read the
thing into a final variable and then
let's just you know do those two reads I
got three method calls instead of four
okay is this what we would call micro
optimizing on desktop absolutely it
turns out that this stuff gets called a
lot and on really small mobile devices
the sort of stuff matters so and it
really didn't take you any more effort
to write it this way than to write it
the first way you might as well just do
it the right way the first time and be
saved the effort now the real question
that you need to ask yourself when you
are approaching a problem in terms of
performance is what is it that's
limiting you why is the thing slow it
could be because of the fill rate in
fact it's almost guaranteed that fill
rate is going to be the thing that you
run into fill rate is every graphics
card has a limit as to how many physical
times it can draw a pixel per second and
if you exceed that it's going to be slow
I don't care how fast your VM is your
language your algorithms or anything
else if you got a graphically intense
application and it's abusing the fill
rate of the card it's going to be slow
and we found that this is this happens a
lot on these embedded devices especially
the geometry rate so every graphics card
it represents your nodes and everything
else are represented on the graphics is
quads or triangles at the end of the day
all the graphics cars deal with
triangles and quads and each one of
those has a vertex and so you've got
three vertices for a triangle and
you know for for quad or more if you do
it wrong and there's a certain limit a
hard limit on each card as to how many
vertices it can handle or triangles it
can handle per second and if you exceed
that you're bummed the thing is with
JavaFX it's very unlikely that you're
going to hit this limit unless you're
doing something like the Navis demo
where they had the shipping containers
and they had these models that they were
importing from the 3d world that had you
know brazilians of vertices in it then
you can run into some geometry issues
but for a typical FX app this is not
likely to be a problem CSS overhead how
much time you're going to spend actually
processing CSS for your scene it's
possible it's possible that you're going
to run into some performance problems
there and there are some things that you
can do to make that faster layout
computation time like I say the layouts
called a lot it's definitely possible
that this can end up being an issue for
you so it's something to be aware of we
do a lot of caching we try to only
layout the things that need to be laid
out so you know it may or may not be an
issue for you may be system i/o okay on
an embedded system there's a very good
chance that any system i/o you're doing
is going to be causing you problems and
it's one of those things that generally
doesn't show up in any of your Java
profilers if you're trying to profile
the thing you're like oh man this thing
says I'm spending 50% of my time in this
one method I went and fixed it and it
didn't change anything
well you're probably either fill rate
limited highly likely or you're just
doing some system i/o that's really
hurting you and it might be just the
overhead of doing system il on the
graphics side because you know we draw
into some OpenGL surface and then we
have to copy that whole surface over
onto where the video card lives and
there's some overhead to that so just
depends now here we have a bottom all
right and this is going to be an example
of a fill rate issue that you can
typically run into with your controls or
with other things that you try to draw
because buttons are drawn with multiple
layers in fact for a for an actual
button like the little the button II
looking part there that's in the middle
is made up of five individual rounded
rectangles that are drawn together
and this is what it looks like so here's
our fill rate first we're going to draw
the background of the thing okay
graphics card is working working working
working working working working to draw
all those pixels and then we're going to
draw the next layer and here goes you
can sort of see the yellow in there a
little bit washed out on the projector
poof and then it's going to do another
layer here it goes working working
working working and as you can see you
know I've got this I got this purple
rectangle guy on the top why did I spend
all that time drawing the other stuff
that was behind it well I've got my
little chalky edge so I sort of had to
draw some of it behind there but there's
a lot of pixels that I'm touching over
and over and over again in fact more
than 90 percent of all the visible
pixels that you see here are being drawn
multiple times three times in fact okay
so when you have a certain fill rate I'm
abusing the fill rate right now right I
am cutting in third what the graphics
card is able to actually draw physically
draw no matter how fast the rest of my
algorithms are I'm cutting in a third
what the thing is able to do so
obviously you're going to want to try to
improve your fill rate there are some
obvious easy things that we've done for
years and graphics the first thing is of
course to only draw what has actually
changed I was looking at as researching
XBMC which is a media player software
right and I don't know what's written in
C there C or Python or something like
that and anyway so so there's the XBMC
media player and they were trying to
port it on the BeagleBoard a couple
years ago and they were having problems
getting the performance up and it turns
out that they had only written XBMC
originally for the for the original Xbox
and their philosophy was to just 60
times a second redraw the whole thing
just keep redrawing the whole thing and
obviously it doesn't work on low-end
devices and so they're like oh well
maybe we should start doing you know
dirty regions which those who are
familiar with swinging programming we've
been doing forever I mean this is a
common technique in graphics programming
since I don't know since way back in the
dirty regions like if you're doing
Android programming or swing programming
you the developer are responsible for
knowing and figuring out what your dirty
regions are if
you have a swing component for example
and only a little portion of the thing
has changed it needs to be repainted
you're supposed to tell this the swing
layout manager or repaint manager you're
supposed to tell only this small little
rectangle has changed and that way when
swing comes back to render later it will
only ask you to draw that little piece
and it'll have a clip there and life is
good and you'll get good fill rate well
Android similar problem the nice thing
for us is the scene graph already
handles this automatically for you we
know every single node that you've got
and we can just make sure that we
repaint the little portion that's
actually physically changed we do all
this work for you however if you use the
canvas node in the scene graph it's back
on your shoulders or if you use writable
images it's back on your shoulders
you're going to have to manage you know
which portion of it has changed and what
you want to draw again well the rest of
the scene graph works for free one of
the other issues that you can run into
is when we use effects there are some
effects that we use probably most of
them that cannot well basically what
they have to do is they have to draw
everything first into a background image
and then they have to do an algorithm on
that background image when that's drawn
again onto the main onto the main back
buffer okay whether you're drawing to
the main back buffer or you're drawing
to an off-screen texture it's still fill
rate limited you're still causing the
graphics card to process multiple pixels
and that obviously is going to reduce it
so whenever you use an effect it's going
to cost you a little bit more now like I
said at the beginning caution right this
doesn't mean you don't use effects
effects are actually almost free on your
desktop system because desktops are so
fast but if you run into issues that's
one thing to look at because effects do
come with some cost there's oh yes
there's another trick that has to do
with clips now in normal 2d rendering if
we did a filled rectangle and it was all
it was access aligned and it was you
know it was pixel pixel bound so you
know you were exactly drawing the thing
from say
100 100 to 200 200 right it's a very
simple algorithm you know exactly what
you're going to do you're going to visit
each pixel and you're going to just turn
it on with whatever color you were told
to turn it on with great now what
happens if that same rectangle is let's
say a half a pixel off what do you want
it to do well if you had no
anti-aliasing then it would not you know
you would not see the little fuzzy edge
it wouldn't be 100 by 100 anymore would
be a couple pixels smaller and it would
have been adjusted to fit obviously
that's not what we want so we do
anti-aliasing same thing if you took
that rectangle and rotate it at 45
degrees you now have to do a ton of work
on the edges in order to make it look
good right
same thing with Clips when we have a
node and we clip it if the clip is
directly aligned with the pixels and
it's you know axis aligned then we can
do that clip very very very fast but if
your clip is rotated 45 degrees we need
to anti-alias the edge of that clip
that's going to take some time in fact
what we have to do is first render your
node into a background image and then
we're going to rotate that image and
stick it on the screen and that will get
us the bilinear filtering and so forth
on the edges and it'll look good that's
work so one of the things that you'll
look at is if you're doing complex clips
that are shapes or if you're doing clips
that are not aligned to pixel boundaries
doing clips that are rotated that's
going to cost you a little bit more
again on a desktop system you'll
probably never notice but if your
application is doing a lot of them
you've got thousands and thousands of
these things it's probably going to show
up because what it has to do is draw
first to an image and then draw to the
thing and now your fill rate limited
again so it's always the problem and
then the last thing that of course you
want to do is reduce the over draw and
that was the example that we showed
previously where we were drawing and
then drawing on it again and drawing on
and again we need to we need to reduce
the over draw so here are some
techniques that you can use to reduce
the amount of over draw that you have in
the application the first thing is to
use image skinning now all the built-in
default UI controls and JavaFX are all
vector based and we did it that way of
course so that whether you were showing
it on a high res screen or low res
screen or so forth it would always look
good it's all vectors and even more
importantly the reason why we did
vectors was so that you could very
easily change what the base color of a
control is and we can read arrive all
the new colors for it and draw the new
thing if you do images it's a little
harder to do but when you're doing your
own applications there's nothing to stop
you from getting a graphics designer and
saying crank out a whole bunch of images
for me and I'll take those images and
I'll apply them to all my controls and
that's it in fact we did a lot of that
for the kiosk we used images for various
buttons and the popovers and so forth so
image skinning is good because you get
the very complex look of the UI but with
no overdraw because you're only drawing
one pixel for each area that you need to
hit so that works out really well for
you another thing that we put into
JavaFX a is an automatic region texture
cache in other words you draw your
normal button with vectors will draw it
smaller into a background texture and
then will stretch it from there in order
to reuse it in other locations so
there's some there's some caveats to it
like for example if you have a button
that's changing its height a lot then
it's not going to use the cache if you
have a gradient that is not going from
top to bottom if the gradients going
diagonally then we won't use the caching
technique so it's one of those things
that we just sort of turn on
optimistically or I say we turn it on
when we discover that we've got a good
fast path that we can follow for all the
normal controls so it's something that
just sort of makes the vector based
stuff as fast as images but with all the
benefits of vectors but you have to you
know there there are some things that
will cause it to happen or not happen so
you may find for example that your
application is working great and then
you styled it with a gradient that went
left to right instead of top to bottom
and all of a sudden your performance is
worse well that's because we're no
longer be getting advantage of the
automatic texture cache so the other
thing you can do of course is just
consolidate your background fills just
simplify the the UI style so instead of
doing five fills you just do one right
that was obviously going to reduce the
overdraw
you can reduce the number of overlapping
nodes so if you have a lot of nodes that
are
laughing each other then they're going
to be drawing over each other and you're
doing a lot of overdraw if they aren't
overlapping well then you don't have
that problem because actually reducing
the number of nodes is not important for
over draw it has no there's no effect on
over draw unless those nodes are
overlapping each other than it does so
if you had 10,000 buttons just right
next to each other and very small
doesn't affect fill rate it'll affect
other parts of the platform but it won't
affect the fill rate if you have 10,000
large buttons then that's going to make
a huge impact on fill rate because
you're going to be drawing the same
pixel 10,000 times once for each button
so here's an example of Metro so one of
the things that Microsoft did with their
Metro UI was they came up with a slick
modern UI style that is very easy to
draw and they did this on purpose
because they wanted something that would
well be nice but also be able to run on
really dirt-cheap hardware so you'll
notice that everything like they're
rectangles they're not rounded
rectangles they're pixel aligned
rectangles very fast to draw we've got
fast paths for all that sort of stuff
when we you can see that that's what's
going on we take the fast path very easy
they focused on typography which is cool
but typography really are just images
right you take the path of the font you
render it into a texture cache we do not
you guys right we do all this stuff for
you you take we you give us a font some
random font like whatever that people is
you say I want to render it at this size
we go okay let me take that once I'll
take that P one time I'll render it into
a texture cache and then or a glyph
cache and then I have to lay that thing
out twice I just render that image in
two different places it's blistering
fast so you know they focused on
typography square rectangles life is
good I mean look at that calendar it's
like made of nothing so this was this
was the point right here's a bigger
bigger example of the same thing you
know they just just some images which as
we've seen have snow fill rate issues
solid rectangles don't feel ready this
shoes and some basic text hey those are
glyphs images no fail rate issues really
fast so this is something you can also
do in your in your
designs if you're designing something on
a small embedded system you know you
have to take into account what that
thing is capable of doing and here's an
example of Android is very similar in
terms of the the simplistic UI it's nice
because it also is modern so you know
this order we went from like the Baroque
style to the modern style here and it
also is a heck of a lot faster and if
you think that's an accident I don't
think it is I think I think everybody
knows really actually quite well what
these chips are capable of and this is
what they have to do to make it fast
now there's another technique that we do
on your behalf
called occlusion culling but there is
something that you can do to help the
occlusion culling engine so this is a
very applicable so basically here's what
occlusion culling is I've got one of my
rectangles then I got a yellow one a
green one and a blue one okay now
suppose that the green rectangle becomes
purple now at the time that it became
purple you can see the dashed line
represents what we have to redraw we
have to redraw that because the purple
has a rough edge and there's some of
that red behind it so therefore we have
to draw that portion of the red plus you
can see some yellow there so we have to
draw a portion of red portion of yellow
portion of purple portion of blue okay
so basically we have to draw four of
them so we really have to draw four of
them of course we only have to draw
inside that clipped area but we still
have to draw them so dirty regions
identified the red area for us
automatically but now we have to draw
four of them so there's going to be a
lot of overdraw there at least three
times for wherever the blue guy is now
suppose the the green guy are sorry the
blue guy becomes green so now our dirty
region is smaller here now the nice
thing here is that we can say hey hold
on a second the green is completely
above a solid opaque purple area so I
don't have to draw the red I don't have
to draw the yellow I can only do this
part so this is what occlusion culling
is by not drawing that is culling out
things that won't be visible we reduce
the over draw
and we increase our rendering
performance because we don't have that
fill rate issue anymore for that
particular area now we will analyze when
you set say some CSS properties on a
region we will analyze those properties
to determine what the opaque area is of
your control and once we know what the
opaque area is if anything on top of it
changes we can just say oh I don't have
to render anything behind that because
it's opaque that's where I can start
from now if you use image skinning on a
control there's actually no way for us
to do this because other than actually
analyzing all the pixels in the image we
don't know which pixels are transparent
or not we don't know if the images
necessarily has transparency or not we
can look at some of the you know headers
and stuff of the images but you know
we're sort of limited a bit as to how we
can automatically solve this problem for
you so there is a CSS property which I
don't have on the slides I think we
called it FX opaque area and base or
opaque in sets that's what it is is the
opaque in sets so you can specify on any
of the nodes what the opaque in sets
actually are and we will honor what you
say rather than trying to figure it out
ourselves so that's a way that you can
get in there and say no no I know this
thing is some crazy image with
transparency on the edges but this is
what the opaque is the center is
completely opaque so this is what the
opaque in sets are and therefore when
the JavaFX engine goes to render it can
do a clusion calling for you and avoid
rendering everything behind you okay so
that's sort of our fill rate now CSS was
another potentially limiting thing that
we talked about so what are the costs
associated with CSS well there's parsing
of the stylesheet there's whenever the
ID or the style class changes of the
node then that node and potentially all
of its child nodes need to be updated so
whenever you change the ID or style
class of a node there's a lot of CSS
work that we have to do because we sort
of have to refigure out the world what
happened down below us
on the other hand if you change the
pseudo-class of a node like say its
hover state changes from false to true
it's typically very very fast unless you
have some children whose state is
dependent on a parent's selector so
here's here's an example of this this is
a horse show right here for CSS engine
now what this selector says is that if I
have a child with the style class of
child and that child is a child of a
parent with a style class of parent and
that parents hover property is true then
I need to style it in a certain way and
what this essentially means when we
analyze the style sheet is that we have
to say ok you there are it there's a
possibility as a parent node whenever
hover changes that some child of yours
down below has to have its style re
computed based on this rule that I've
defined and so we've got to go and do it
now there's a lot of heuristics and
things that you can do with CSS
complicates code takes some time a
little buggy but we're adding all those
things so that we can be smart about it
and say oh well only if the parent has a
child with the dot child does it need to
recompute this and that and everything
else but generally speaking that's all
work as well so whenever you have
selectors like this it's just going to
be more expensive just takes more work
on our side to do the job for you this
is another one yeah this is a very
common easy way to write your CSS but
there's a problem with it which is that
we don't this is the this this rule will
apply to any child with a style class of
child that has an ancestor somewhere in
the chain that has a style class of
parent which means that whenever we
encounter a node of type child we need
to check it and every single one of its
parents until we either get to the top
or we find one that has a style class a
parent now in a case like this it's
probably not a big deal if you only have
a few children in the scene graph it's
not going to be a lot of computational
overhead but imagine if for example we
said a dot button
who had a parents of you know some dot
parent and and I had a tableview with
10,000 buttons in it now I've got 10,000
buttons that all need to walk up the
scene graph looking for a parent in the
case that they find it it's not that bad
in the case that they never find it
you're going all the way to the root
every time you've got an O squared
algorithm going on here and then you
know algorithms takes time here is
another one
the set style so you can specify a style
just like you can in HTML you can
specify style directly on mode which is
really convenient I use it all the time
but you just need to be aware that it
cost more because when you do this we've
got to parse it so there's some overhead
there and then we have to treat it in a
different way than all the other styles
that you find in the style sheet so it
gets inserted into some special parts in
the code and basically we treat it as a
separate style sheet that's been defined
on this layer and you know it takes time
so you need to be careful with those
sort of things if you're running into
performance problems as something to
look at now this is the the honor parade
or the honor show this is the way that
you would want to do it if you can so
this is a child whose immediate ancestor
has a style class of parent okay this is
easy for us to do even if we had to do
it 10,000 times we're only checking the
parent this is very fast we could do
that that's not a problem you know
putting the pseudo classes directly on
the note itself dead easy super fast I
mean it'll be it you can't beat it so
this so there's some some things to look
out for in CSS and other things that
just really don't cost anything so a
question does CSS cost you something
well yeah this work that has to be done
we're doing it for your convenience and
all the power flexibility if you get
into a situation where you really can't
afford it wow that's do it in code so
here's a tip if you're looking for
performance improvement avoid structural
changes to your scene graph on the
kiosks we had out it's about 1,100 or
1,200 nodes on there and they're all
there
we just set some of them visible false
as opposed to creating and pulling them
off and putting them on and so on and so
forth
there's cost associated with it why well
one is that whenever you change the
structure of the scene graph we have to
reanalyze all the CSS from that point
down from where the change occurred on
down because since you can have
selectors that are dependent on the
hierarchy whenever the hierarchy changes
we have to recompute all the dependent
selectors to find out what matches now
and what didn't before the other thing
is whenever you change the structure the
scene graph we do structural integrity
checks so we go you know is there a
cycle somewhere you know you tried to
add this node to another node and you
haven't been removed from the one that
you're in or you're trying to add your
grandchild to be your parent or
something like that you know we need to
do those sort of checks and well that
takes time so instead what you ought to
do if you're going to do structural
changes for the sake of changing the
rendering order of something within the
same parent the best way to do it is not
to remove it and add it back in but just
use two front to back because it's been
optimized there's actually another way
to do it as well which we'll mention
here which is that instead of doing two
front to back you can also use the FX
collections so this the secret what
we're trying to accomplish with as you
know in Java affects almost everything
that has you know a list is of type
observable list which is an FX
collection and it lives in I only
remember the package to be completely
honest with you Java FEX collection or
something and so there's they're all
observable lists you can add listeners
to them so forth the observable lists
are designed to handle mutation and
event notification very efficiently and
so you want to make sure that the
changes you make to an observable list
are done in such a way that we can make
efficient change notifications and this
is especially the case when you're doing
say 15,000 monsters in GUI mark bitmap
you know you've got 15,000 these little
guys and you need to change what order
they're in so that they're not running
on top of each other or whatever you
need to minimize the number of changes
obviously if you get 15,000 ads and
moves you're going to get 15,000
structural integrity checks you're going
to get all these notifications and
everything going on waste of time so you
want to do minimal notification and how
do you do that well for example you can
use the set all method that is defined
on observable lists instead of clear and
at all so instead of first doing a clear
it now I'm going to add 10,000 items you
just say set all and it goes in one
notification and says okay everything's
been replaced from here to here and we
can handle that very very efficiently
you want to like I say avoid multiple
add calls so sometimes what we'll do on
our startup code for example is we'll
create just a normal list we'll just go
in some loop and add items to that list
and then once we exit the loop we'll
just take all those items and just do a
set all on the observable list so that
in one step we do the notifications life
is good
another thing that you've guys you have
methods such as FX collections dot sort
why would you want to use FX collection
store instead of collections dot sort
well because FX collections knows about
observable lists it knows about the
notification and when it does a sort it
can send a single permutation change
event and when it sends a single
permutation change event we can then say
we know two things number one not only
has everything changed from you know
index n to index M but we also know that
none of the items were removed and no
new items were added they were just
moved around from place to place and
that means we can avoid all the
structural integrity checks and other
sort of things we just know things have
moved their order I'm happy I don't care
that's fine I'll just go update the
little peer withdraw a new order life is
good
so permutation very very handy for us so
you know we've built in a lot of these
things into the FX collections helper
static util class thing and you ought to
use it just this this is a really good
thing in order to avoid having to do a
bunch of extra work we know what a
permutation is we've got fast paths for
it and if you're writing your own
listeners for a collection you should
also look at whether you want to take
advantage of writing your own fast
for these things if you know that you
can do less work on a permutation versus
an adit or remove then you should add
some special handling for permutation
events ok the next tip is virtualization
so we talked about this a little bit in
the keynote
you know ListView is blistering fast you
can put 10 million items in that list
view and it'll scroll until its heart
falls out I don't know whatever integer
dot max value is somebody knows and the
reason it's fast is because it reuses a
small number of nodes over and over and
over again but the reusing nodes is good
reduces memory usage but it also is
really smart in that it reduces the
amount of CSS change overhead that goes
on because it's not adding and removing
nodes all the time so it's avoiding all
these structural changes there's a voids
a bunch of layout changes unless it
needs to do them it avoids a whole bunch
of them validations unless it needs to
do them and basically it does everything
else
minimally this is the whole point of our
list view and table view and tree view
is to handle all this stuff for you so
really what you ought to do if you can
is reuse the list view for anything that
you need to virtualize in terms of you
know I have 10 billion items and I need
to you know cycle through them that's
what you ought to use so in in the
schedule builder application we used
ListView on almost every page it's fast
it's really really fast so that's a good
tip there's another tip for you which is
a manual layout now we've got a whole
pile of built-in layout containers and
that's good built-in layouts good tools
know about it life is good but there's a
problem which is that they are
incredibly flexible right
I mean we're providing a grid view we
need to make sure that we can answer the
question you know what's the minimum
size with furred size all sort of stuff
in and what happens when the cell is
bigger than the content should we
position the content here there there
they are down here but we've got this
big pile of code we got to compute all
this stuff if you're doing something
simple you know what you ought to do is
just do your own layout so a lot of
times what we'll do Jasper I'll do this
all the time we'll just create a new
glass and extend from region the reason
we extend from region is so we can style
it from CSS but otherwise it's just a
basic parent you can add children to it
and then you can lay it out when you
extend region you almost always have to
implement the compute pref width and
compute pref height not always it
depends on your usage of it if it's if
your create so here's another thing to
write if you're creating a subclass of
region for your own use
you can cut corners left right and
centre and doing less work will get you
better performance if you're creating
something that's supposed to be reusable
by the rest of your company or something
else but you're going to have to do more
work and be a little bit more serious
about it so you could probably avoid
overwriting compute pref wit and prep
height if if you know that you are
manually going to resize this thing to a
certain size or you're going to specify
you're going to hard-code what the
preferred width and height are and you
don't have to do it but almost always
you're going to want to implement
compute prep with compute prep height
and of course then you have to also
implement layout children so that you
can put things exactly where you want to
put them so custom layout lets you cut
corners and just sort of put things
where you need them so here is what
happens during layout the sort of things
that JavaFX is going to ask your layout
container it's going to ask you how wide
would you like to be or how tall would
you like to be what's your what's your
preferred width and height and what's
your maximum width and height what's the
biggest that you will allow and oh I
also need to know what's your smallest
size because I mean you know I don't
want to allow you to get resized to be
smaller than what you want to be right I
mean oh and by the way is your width
dependent on your height or is your
height dependent on your width or
neither oh and do you have a baseline
where is that exactly um so you know you
what should I consider your natural
position your natural width and height
like if you're a text node you know
you're you're not at zerozero you're at
I don't know
and ten or something I don't know but
you know was sort of your natural layout
bounds position I'll take that into
account so I can put you where you need
to be okay oh by the way can you be
resized or not okay these questions are
asked for every node during layout
we're asked all these things at least
once sometimes 20 times I mean it's it's
out of control and we ask a lot of
questions so I'm just why I'm saying it
sometimes you want to do custom layout
because they can avoid a lot of those
questions you just sort of put things
where you want them and that's that
another thing that you can do is if you
manually specify you can manually
specify in code what your min-width is
what your prep width is breath height
max width max height and so forth those
overrides if you specify them we won't
ask those questions of the layout
container it doesn't have to compute
anything it'll just grab them so that's
another way to sort of short-circuit the
amount of work that goes on during
layout is if you manually say look min
size is zero max size is integer max
value and pref sizes I don't know 200 by
50 I don't care you just give it
something yeah we won't ask any
questions we'll just go about sizing
things to what you tell us but there's a
lot of times when you don't know like
for example if you have text if you have
text what are you going to do right its
height depends on its width in all
languages that run left right or right
to left so here's a tip when you're
dealing with that situation its uses a
thing we call the content bias so the
content bias of a node is either
horizontal or vertical and what that
means is which side is in which way
horizontally are you more important and
your height depends on it so does your
height depend on your width if so your
horizontally biased if your width
depends on your height then you're
vertically biased you want to be a
certain size vertically but you don't
care how wide you are horizontally so
you're biased towards your vertical
dimension okay and if it's null then
width and height are completely
independent so content bias is what you
would use yell for handling some of
these situations now content bias null
is by far the fastest because when we
compete
you preferred widths and a preferred
height if we know that your width is
independent from your height then we'll
just cache that value that you give us
and just save it so the next time the
layout code is asking it or the next
time somebody else is asking it we
already know the answer and we can
return it without having to compute a
new pref width or compute a new pref
height so you know if you're truly
independent in both axes then that's
what you want to do so labelled controls
for example if you if you don't set the
wrapping it for it to be word wrapped
then we're independent in the width and
the height and we can just you know be
fast if you're doing word wrapping well
now our height depends on our width we
have to take some different code paths
so content bias horizontal he is common
for text width wrapping with like I was
talking about right by far the most
common it's usually content bias is
either null or it's going to be
horizontal that's the typical thing now
the unfortunate thing and I discovered
this leading up to Java 1 is that
content bias when it's not null is
actually not very well handled by our
current layout managers there's bugs on
it
people have had some problems that
they've talked about in the forums so
unfortunately it's a bug and we're going
to fix that for Java FX 8 so that we
handle the content bias correctly but
just so you know in your own code if
you're doing your own layout there are
methods it's all well documented how
it's supposed to work it's just that our
current implementations of our layout
managers are not handling it correctly
so something to be aware of ok so all
that was rule number one which was do
less work I did a lot of work for that
rule number two write know your device
so these things are really interesting
so here this is the the nvidia geforce
gtx 690 it was the top of the line on
their website i went to their website
yesterday and i said ok what yes i was
working on my slides yesterday so I went
to the hair and I said ok what is the
absolute fastest graphics card that they
have this is the guy right he's got over
3,000 cores in this graphics card that
you know 234 billion texels a second or
whatever the
thing can push right okay it's got 384
gigabits per second on its memory
bandwidth and my favorite is that the
graphics card itself requires 300 watts
of power in order to operate all right I
mean wow this is one of their lower end
you know it's just you know this is a
very modest 16 cores on this guy you
know you know it's like a I want eight
gigabits per second right that's okay 30
and a half watts I mean this guy's like
a regular hippie he's like you know he's
just doing his part but even this thing
is a fire breather compared to what
you've got in your latest Apple iPhone 5
that little graphics card yeah he's got
three cores and that's one more than the
last version of their graphics chip had
right there's only so much you can do
with three cores and you know that that
thing is not sucking 300 watts of power
that thing is just sipping away it I
don't know a lot and a half or something
these mobile and embedded devices
they're just different beasts you have
to go into it understanding that you
know JavaFX is giving you a single
development platform an API that spans
on all these devices but you really have
to know what you're trying to target to
know what you can do and what you can't
do on some of these guys like if you're
trying to write you know a media player
on a Raspberry Pi you're going to have
to write your application differently
than you would if you were doing it on
desktop you just have to know going into
it that you've got a very bad CPU on the
thing it's just slow so it's got a good
graphics card though so you know but the
but the bus speed on the thing is
abysmal and so at the end of the day you
know you got to try to figure out how
you're going to make your application
fast on that device so that's that's
just the way it is in the world so
here's a basic rule of thumb on desktop
you should be able to handle twenty to a
hundred thousand nodes one hundred
thousand is definitely on the high end
maybe not all of them are visible but
you can have a scene graph that big for
sure and you could probably you know
depending on how the fill rate and
everything
like I say if you tried to do a hundred
thousand nodes and they were all
overlapping you're dead if you have a
hundred thousand nodes but a bunch of
them are outside the window
they've been clipped off from the screen
it's probably going to be just fine
because you're not going to be Phil rate
limited and if you're on a desktop and
we've got you know three and a half you
know I don't know what quad-core three
and a half gigahertz chips or whatever
I'm sure we'd have no problem processing
all that stuff so on desktop you know
you can you can build some if you do
less than 20,000 nodes on desktop I mean
we're going to be offended you're like
why why are you using us all right a
five hundred to a thousand nodes
unembellished or so that was in that
thing and it was fine the happy camper
so you're going to have some fewer nodes
that you can handle on those smaller
devices a lot of it's just memory right
it uses more memory to have more nodes
so you have you have some fewer you have
to sort of take the hit on the
structural changes from time to time
perhaps but you know you can actually do
a lot with a thousand nodes now when you
get into small embedded like let's say
that you were trying to do you know
little touch screen for a printer and
the thing was 640 by 480 or 320 by 200
and it's running on some little measly
you know 20 cent chip or something on
the back end of that thing you're going
to have fewer nodes so 100 to 200 nodes
is actually pretty typical for say a
Java ME class sort of small device but
they usually have much smaller screens
and they're usually like you know not
actually if they had a high pixel
density be even better but you have to
you have to draw big buttons right so on
that 320 by 200
you've got you know 100 by 50 of that is
just one button so you don't really have
that many nodes on such devices anyway
but you know you just have to be aware
that you've got a much smaller space
that you can fit things into just
depends on your hardware if you had a
small screen and the thing was backed by
you know your latest Intel chips then
yeah go ahead and put a hundred thousand
nodes on there it's not like it'll
matter but you know knock yourself out
it just really depends on what the
hardware is capable of doing
now here's another tip and this one
we've talked about before which is
caching so I have some scene graph and
this scene graph I'm going to draw it
and there's a lot of work to do to draw
this scene graph and then it produces
this nice chart okay so I have my graph
I did tons of work I produced myself a
chart and you know the thing is if this
chart is never going to change then by
George yata cache the thing assuming
that you're animating it or moving it
around or changing its opacity or
something like that
if the charts nodes themselves aren't
changing may I cache that thing because
if you do this is what you'll get you'll
draw once to an image and then you'll
draw it a bazillion times to the screen
and it'll be a lot faster because you
won't have to do all the processing and
you you know if there's clips and all
these other things of these rounded
rectangles and intermediate textures and
all it yeah you avoid all that you just
got one copy of it you just draw it a
billion times now on some devices you
actually can't do that it's very
interesting actually on some of these
embedded devices you don't have enough
texture memory I think the the boards
that we're using out there the pandit
boards had was a 42 Meg or 36 Meg of
texture memory vram 40 so it's 40 mega
vram on that thing
total okay all those other devices that
we showed you I mean you've got you know
256 Meg 512 Meg whatever you got all
kinds of it so you can cause yourself
problems by using up tulips texture
memory on the other hand sometimes this
is exactly what you want to do so for
example when we do animations a lot of
times we'll turn cache true
and then we'll animate that thing off
the screen and then turn cache true to
cache false again that's the sort of
thing that you're going to want to do
and like I said on there it backfires if
you're changing the thing a lot so if
your chart is animating your host
another thing is the cache int you know
there's different cache intz you can
choose how you want it to behave you've
got speed and quality and whether it's
rotated and scales and so forth so you
can tell cuz here's the thing right if
you render to an image and then we
rotate the image we have to do some form
of
interpolation to figure out what the
pixels are on the edges and as it's
rotated and we can you know we can do
that very quickly or we could rotate it
and then ask you to redraw all your
stuff and then you know it'll be much
more precise so it depends on what you
need if you know if you're just spinning
this thing off the world then just set
it to speed and you're good to go
if you actually care when it rotates
that you redraw things you're going to
need to set it to a different setting it
just depends on your specific use case
but the cash hints are there for you all
right I think this is the the last
little guy now this is um just added in
JavaFX eight so it doesn't work in the
in the shipping 2.2 and I think this one
is probably going to be there forever
but don't quote me on it yet because
we're still in our development builds of
JavaFX eight but it's a really handy
little guy so if you set this flag
JavaFX top pulse logger to true we print
out a ton of crap to your console and
this is a single pulse now in JavaFX we
have a pulse that occurs if you if
you're doing a lot of animations it'll
happen 60 times a second or if you have
a lot of animations but everything's
slowed and well you'll get a pulse as
frequently as you can and if you're not
really doing a whole lot you'll get
pulses intermittently only when needed
and during the pulse we do CSS we do
layout we do we kick off a drawing and
everything else now the pulse logger is
going to log all sorts of different
things that occur during a pulse so for
example at the top here you can see a
pulse count
this one's pulse one if I had had 10000
pulses in my application it would say
10000 so it's just a different number
you know incremented Auto increment
number for the pulse you can see the
duration which is how long did this
pulse take this particular pulse took
250 milliseconds which typically be a
bad thing because 16 milliseconds is all
you can get and still get 60 frames per
second so this thing is soaking up a ton
of different frames so we're running it
like a quarter I'm sorry four frames per
second is what this thing's running at
based on this pulse you can all
see the time since the last pulse over
there 989 milliseconds which means that
there was a long period of time from the
last pulse to this one and this one took
a long time to complete then you can see
over here that it's got multiple threads
it's got t12 that's thread 12 and t10
which is thread 10 well of course we
have two threads we have a render thread
and an fx thread so we can see that the
FX thread thread 12 in this case did a
CSS pass which took 8 milliseconds was
half of our budget right there for our
16 millisecond budget he used half of it
the layout was only 2 milliseconds so in
this case layout wasn't my problem 151
milliseconds waiting for the previous
rendering okay that obviously is the
lion's share of why this pulse took a
long time it's because he couldn't start
a new render job because the last one
was still going so whatever happened at
the beginning is taking a long time
let's see here he copied some state to
the render graph because because we have
two threads we also have two copies of
the state and we can copy it from the FX
side to the render side so the render
side can go do what it needs to do that
only took two milliseconds that wasn't
too bad
Wow 24 milliseconds to compute the dirty
ops so the dirty ops is the thing that
discovers what's changed so that I only
have to draw the little portion that's
changed a lot of time there so that
would be something that would be worth
looking into or filing a bug if you
could make it reproducible boy and then
then we can see that we had to actually
independent dirty regions to render so
if you have a large scene and something
changed in one corner or something
changing in the other corner instead of
redrawing the entire scene will actually
do two separate paint passes one for the
top left one for the bottom right you
can see in this case that's what it did
two different dirty regions to render
and then we can see one of those took
fifty four milliseconds and one of them
took four milliseconds that's pretty
useful information help you get to the
bottom of what's going on in your
particular pulse and then at the bottom
there's various counters that we put in
and this is really easy for us to change
what we've got but so for example I
wanted to know how many nodes were
actually rendered as a consequence of
this pulse 70 of them and it's amazing
the 70 of them took 54 milliseconds huh
wonder why maybe I'm using effects wrong
maybe I'm doing something going on there
but that's something to know how many
nodes did I have to actually physically
visit in order
to render this thing hundred forty-three
you know how many times was I telling it
that it needed to lay out well there
were one hundred and twenty two dirty
nodes that needed layout interesting
stuff so the pulse logger is there for
you to in Java effects eight that you
can print the stuff out kind of get a
feel for what's going on in each of the
pulses and it's a good thing to feed us
as well if you run into a bug because
you can say exactly sort of what was
going on in your application so I end
the session the same way that I started
with with a caution that you ought to
write the clean code and then profile
because if you overdo it you're going to
end up with an unmaintainable mess
generally speaking everything will be
just really fast but you may run into
cases where you get periodic hiccups
things were smooth and then it was slow
why is that
turn on the pulse logger see what
happened you may run into cases where
your application is just grinding under
eighty thousand nodes and you say well
it should be able to handle eighty
thousand I've got a big expensive
machine here why is that you can go in
and take a look at some of these tips
and tricks and thank you and we have one
minute for questions
I wanted
exhilarated
next transition is in jail and it's not
when that is a kind of sweet
so when I labeled exhilarating
it's hard to say but what you could do I
don't know if you filed an issue on it
but the thing to do in that case if it's
simple and reproducible the way that I
would file that issue is by doing two
things well if you could turn on pulse
lager and Java effects eight that'd be
three things one would be to have that
gives us some information but really if
you can just take a screen capture and
attach it to the issue and the little
chunk of code that would reproduce the
issue and put it on there and of course
tell us what your graphics card is then
we can look at it sometimes what will
happen is people will put a logon issue
and it will have the code but we can't
reproduce it we're like man I don't know
what to do with this one so it just goes
into the backlog but if you have a video
or something that we can look at and we
can go wow that is really bad and then
we can you know work with you and get
that taken care of but off the top of my
head I don't
I couldn't tell why that would be the
case all right oh it's lunch time thanks
everybody</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>