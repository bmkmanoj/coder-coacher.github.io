<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Automating Your Haunted Dungeon with OSGi | Coder Coacher - Coaching Coders</title><meta content="Automating Your Haunted Dungeon with OSGi - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Automating Your Haunted Dungeon with OSGi</b></h2><h5 class="post__date">2013-01-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/6mDCzKiBIDE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to automating your haunted
dungeon with osgi it's going to be a
brief overview of introduction to osgi I
have a few little slides at the
beginning but it's mostly code demos to
show how you would get started with osgi
get some of the concepts of osgi and
hopefully take it home and and use it
for your own dungeons anyways my name is
Kevin fonner and I'm an enterprise
systems developer with Babcock &amp;amp; Wilcox
I do j2ee development and stuff and we
use osgi with that but my real passion
is with robotics and electronic systems
and hardware control systems some
embedded development I got started with
osgi doing home automation back in two
thousand and that's actually around when
OSU osgi was conceived like in like 98
or 99 with my son and a consortium of
other companies they developed it for
the home automation market the embedded
gateway marker like that and it was this
nice little compact embedded framework
that allowed you to dynamically update
things in place and since then it's
really grown beyond that and is used in
everything from embedded in cars to j2ee
application servers anyways quick
introduction about myself is I really
like Halloween and this is my haunted
dungeon that I set up every year as my
wife my wife is nice enough to look away
as I moved the front room furniture out
of the front room and I erect these foam
walls and this is the first year the
dungeon like that and this was the year
that I had real pumpkins around the
outside and I actually use real candles
that year and then I thought live flames
and foam walls didn't go so well
together so the next year i switch to
just I still have real pumpkins but I
use little cheap LED candles and stuff
but I added a tunnel that you can see
right back here and it goes into the
kitchen it has a barrel vaulted ceilings
and a groin vault architecture is better
than my house anyway is the third year I
got kind of in
treas and I started prototyping and I
came up with a little sir tom concer
Katai put together and it's got three
LED three yellow three red and three
blue LEDs and it has an AVR
microcontroller and I control it using
Java an osgi the firmware on the chips
actually see but osgi is how I control
it the pumpkins hook together daisy
chained with on an rs-485 network which
if those of you know what r is 45 is
it's a multi-point serial protocol that
was very popular it was much cheaper
than putting Ethernet chips and all of
them anyways um you guys are really two
here to find out about osgi and so what
is osgi well osgi is a specification for
a framework that implements a dynamic
component model allowing you to make
modular applications which you know what
osgi is is that it's a specification and
there are a number of companies that
have osgi frameworks or they have osgi
embedded in their products and if you're
using an osgi framework or a product
with osgi embedded into it what it
really allows you to do is break up your
application into these little bundles
called modules modules called bundles
and inside these bump these bundles are
just jar files and inside the jar files
or just Java classes maybe some other
jars and libraries that the bundles need
some other resources that they need and
most importantly to osgi a manifest file
and inside the manifest file has some
osgi properties which describe the
bundle to the osgi framework and
basically tells the osgi framework what
to do with the bundle anyways um so
quick example of like what you would use
osgi for say you have like a complex app
and this is like one application you
have like four features feature you know
and you of all these features use a
utility library and and that's great and
this is one app so it's all running on
one jvm sharing a classpath and you want
to update feature d so it uses a new
utility library well if that's a if
they're all sharing the same class path
in a lot of cases they are what happens
is at the very least you'd have to
regression test your other features
inside your application at the very
worse you might have to go back and make
modifications to the other features and
so that and then regression test those
there are ways of loading more than one
version of a jar or package I should say
that into the same class path however a
lot of these are fraught with a lot of
issues well one of the things that osgi
allows you to do is each bundle has its
own class path and that class path is
actually wired up dynamically at runtime
and so it's and it also provides a
mechanism for the various different
bundles to communicate back and forth
without having to be without having to
share the same class path it provides
some mechanisms for more focus sharing
and she'll see and and what this
basically allows it you is you can
upgrade part of your application and
keep it very much realized and update to
a newer version of library and half your
app can be running on one version a
library and half your app can be running
on another version of library and it
doesn't really provide and there won't
be really any kind of a classpath
conflicts like you might have to deal
with and and that's in a nutshell what
osgi is is allowing you to break it up
and have individual class pass and
provide mechanisms for the osgi
framework for the bundles to communicate
back and forth anyways it's easier I
find if you just go ahead and work
through the examples on code so that's
what we're going to do and I hope that's
all right I'm going to go ahead we're
going to create a framework to control
the pumpkins from scratch here and so
the first thing I'm going to do is I'm
going to create a project and we're
going to use a plug-in project and
that's like an eclipse plugin and the
reason why is because
Eclipse actually runs on top of osgi OS
UI framework called equinox and that's
one of the OSI frameworks that I like to
use and so one second I had to change so
my screen resolution stuff and it threw
me off a little bit and so we're going
to be creating a new pumpkin service
which is going to control the framework
and see you'll see some properties right
here and these properties are basically
properties that will gets put into the
manifest file for osgi and you have a ID
for the bundle and you have a version
number for the bundle and you have a
name of the bundle and you can specify a
vendor you can specify an execution
environment if you want to and then
right here is specified a class and
activator and the activator is actually
the class that gets instantiated by the
OSGi framework which allows your bundle
to a to start and stop as you'll see
here and so I'm going to go ahead and
modify a few things here
and here you can see your manifest file
and it has the standard java manifest
version but here's your osgi specific
ones bundle manifest version 2 which is
really just a manifest version number 4
osgi bundle named bundle symbolic name
which is important your bundle version
number and the activator which is what
the class that gets instantiated inside
your osgi bundle and this import package
which we'll get to a little bit more
later but right now we're going to focus
on the activator and inside the
activator there's two key methods that
are important or like that this start in
this stop method inside the activator
the bundle context object is passed to
the activator class which implements the
bundle activator and this bundle context
objects important you want to maintain
the whole debt that's why it gets stored
inside this class this is how you
communicate back to the osgi framework
to do various different operations but
this is a simple example we're just
going to print line started the pumpkin
service and then shut down the pumpkin
service and so I have a couple of ant
scripts that are just going to help us
out on the way what they're basically
doing is just jarring up the files that
I build are like that sticking the
manifest in there so that I can load it
into the OS UI framework and so I'm
going to start up an osgi framework and
a lot of times you would just be using a
application like a j2ee application
server or another product to and using
the osgi facilities inside that or if
you are building a product you have
startup scripts to startup osgi what
we're going to be doing is just running
oh at the osgi equinox framework right
from the command line to keep things
simple and I can type in various
different controls and stuff you can
type in help and has various different
commands and stuff that you can interact
with us Shia framework and the first
thing that we're going to be doing is
installing that bundle that we just
built and we get a bundle ID
and it shows that the bun the pumpkin
service is installed and we're going to
start 10 forget to save it my bad and so
we can also teach you the update command
to update one and you can see that a
printed started the pumpkin service and
I can stop one so that's really exciting
that's your first bundle but that's that
just gets us going now we want our
bundle to start doing stuff one of the
things that's nice is sharing classes
and stuff so we're going to create a
class that we're going to share with
another bundle and it's just going to be
a test class and inside this test class
we're going to have a method that says
print test call and it's just going to
print out this is boring but useful but
we're also going to go inside the
manifest file to make this available to
other people and we're going to export
that package it specifies in the osgi
manifest to export the pumpkin service
to the osgi framework for other bundles
to consume so now we're going to go
ahead and create another plugin
and this is going to be the bumpkin
controller which is going to control the
pumpkins and we have version 10 of its
there's our activate our manifest and
now what's important with this one is
we're now going to import this package
and I can specify a version number much
like this osgi framework if I wanted to
but we just are concerned with importing
the pump the pumpkin service and I'm
going to in the activator of the pumpkin
controller we're going now inside the
activator you'll see that just like
standard Java you would like if as if
the other bundle was in our class path
we're just going to import the pumpkin
service test class and then we're going
to go ahead and create an instance of
tests and print the test call this is
all straight Java pretty simple
straightforward stuff I'm going to
update one and install
so we started the pumpkin service and we
start to this is boring but useful so
one of the interesting things I don't
know if you realize just happen there
though is bundle 1 and bundle to had
completely separate class paths they
both load into the OSGi framework and
they're running within their own class
paths and then what happens as you
specify inside your manifest file that
you want to export this package and
didn't specify in the bundle to that you
wanted to import this package and what
happens is the OSGi framework on the fly
wires up the class paths so that the
packages in one are available in two and
so if you had bundle three you wouldn't
necessarily see the package exported
unless it wanted to see that if you
wanted to you could say import me a
version of this package that's higher
than this version number and the osgi
framework will then search for a version
number that's hot up for what you
requested and will automatically wire
that version of the bundle up to the
class path of that bundle so let's go
ahead and make our pumpkin service that
much more interesting now so we're going
to add some libraries to it
and what this is that I'm placing is
just a serial port driver it's what I
use to communicate with the pumpkins
i'm going to add it to our
half
okay then I'm going to add a couple more
osgi headers to the pumpkin service
now what's neat about well we're wiring
up the bundle club that I add to the
classpath for the bundle the the serial
port driver and then when this is a kind
of a neat osgi header the osgi manifest
property is that these are native
drivers and you can specify the
processor number and the OS number and
the OS name and the OSGi framework will
examine the operating system that the
bundle gets installed on and then
automatically wire up the link the
dynamic library is appropriate for the
OS that are for your bundle to the
operating system so if you're doing a
hardware type development it's kind of
nice and that's kind of where I wish you
I came from anyway so the next thing is
we're going to continue evolving our
pumpkin service and we are going to
create a new interface
called pumpkin service so that other
people can
and inside this interface we're going to
specify a method call command this is
how I actually communicate with the
bumpkins there's an address bite which
is each pumpkin has an individual
address a command bite is a past which
tells it to turn on or Flickr turn off
and then there is a parameter by to tell
it to usually for like a color to
flicker blue or Flickr red or turn on
red so that I use those when I'm calling
it now we're going to create a new class
for the control software for the actual
pumpkins and this is well this is our
implementation logic and actually I
meant to put this into another spot
it's going to
so
my graphics are being goofy I was
actually meant to be in a different
package name space
30 and so what I'm doing is I'm putting
our implementation outside of the
package that we exported because weapons
is we don't want people to really expose
this the rest the osgi framework and
what's inside this pumpkin implement a
service implementation class is code to
initialize the serial port close the
command port and also implements the
interface that we just wrote to output
out via the serial port the address by
it the command bite and the parameter
bite anyway so we're going to go ahead
and add new stuff to our pumpkin
controller activator
one second
we're going to be exposing
we're going to be exposing this as a
pumpkin service to the rest of the OSGi
framework and so now what's important is
that inside the start bundle we create a
new implementation of our pumpkin
service implementation we initialize the
communications and then we register a
service with the name of the pumpkin
service and register and that gets
registered and then print out that we
start the pumpkin service and also when
they have forgot is our activator does
not need to be in the interface so it's
best to put that in the implementation
so I'm moving it back out of the class
that we exported to the rest of the OSGi
framework now we're going to go ahead
into the pumpkin controller and go the
activator and inside the pumpkin control
framework when the bundle starts up
we're going to look for the pumpkin
service reference that we exported with
the pumpkin service and we're going to
do a query against that and we get an
instance of the pumpkin service object
and we can call commands then the cross
of it and we're going to send out a zero
to address all the pumpkins and 04 to
turn it on and Abby to turn a blue going
to
build that now I'm going to because I
have loaded some native libraries I'm
going to stop these
I'm going to reload those and so now
when we start 3 the serial port driver
gets started up from the first bundle
tags mess up somewhere
and working on this different screen
resolution that I men
mmm sorry eyes
three
that's socks I really haven't had this
problem through the demo yet
hmm
you just make sure did I
maybe one second let me check my code
nuts real quick here my code notes
normally I could see him a little better
activator
well I'm sorry guys yeah I went through
this three times a day and it didn't do
that one time hmm yeah I did have that
on there but I haven't had to do that
lately yeah
oh I guess I did have to restart the
pump osea module I'm sorry guys okay
that was all it was normally lately in
the demo I hadn't had to do that anyways
so if we run that demo wow I can't
believe that I'll go ahead reset those
so now when we start seven it changes
all the pumpkins to a blue and what
happened was that the service was
registered with the osgi framework and
then the pumpkin control framework then
consumed that service and started to
sent the command to turn all the
pumpkins blue and what that allows is
you to abstract away the class paths of
the the class paths are hidden away
between the different bundles but expose
the service interface that still allows
your osgi bundles to loosely couple talk
back and forth anyways all right let's
see if I can actually get somewhere i'm
just going to leave those open
the next thing that we're going to do is
we're going to demonstrate so that's
great that that pumpkin service is
available for us and that the osgi
bundle can communicate with it but what
happens is in the enterprise world or in
the embedded world we have constant
communications going on and and we're
going to have to handle if the service
were to disappear and so to simulate
that we're going to set up the
possibility for a service failure and
handle that and so the first thing we're
going to do is we're going to add to the
you pumpkin control framework we're
going to add something to randomize the
light lights so now you get to see my
code samples rather than having them
crammed off the screen and what this
class does is it simply it's a timer
task which goes heads and right sends a
random address bite and a parameter byte
which is actually the color of the
pumpkin or like that to control bumpkin
and then what happens is we're going to
go ahead and modify the activator to
call that timer tasks and so inside the
start bundle here we're just going to go
ahead and get the service reference and
then we're going to go ahead and set it
scheduled for every hundred milliseconds
to randomize the lights and so
we're going to update seven now you can
see the pumpkins are the pumpkin
controllers basically sending a random
address bite and the color and so the
pumpkins are changing colors so so now
what we have is a system that is
continually changing the controller is
continuing sending transmissions to the
pumpkin service now we can't really just
have the pump if the pumpkin service
might go offline because in the
enterprise world you might take down
that particular feature of the
application you need to you want the
controller to be able to respond to
changes in the osgi framework in the
osgi framework makes that easy is they
have a utility called the OSGi tracker
which we're going to go ahead and import
in the manifest and we're going to
modify our pumpkin controller so we're
going to implement a copy of the service
tracker in class we're going to create
the pumpkin service tracker and inside
this pumpkin service tracker it extends
the service tracker which is provided by
the OSGi framework we tell the service
tracker what kind of service that we're
interested in we want where we're
interested in a service with this name
the pumpkin server service class name
and then there is two methods that are
important the adding service which
happens when the pumpkin service becomes
available and then there's the remove
service when the when the pumpkin
service obviously disappears and so
we're going to do is we're going to
modify our activator then to deal with
that use the pumpkin service tracker and
inside this hour start bumble has gotten
a little simpler like that it just
simply creates an instance of that
pumpkin service tracker and then opens
it up
so we'll build that and we'll update 7
in place pumpkin service available so
what happens is that osgi bundle stopped
and then started again when I updated it
and amelie recognize that the pumpkin
service was already loaded into the
framework and so it told me it was
available and it created the timer task
to start routes running but i can stop
the pumpkin service the pumpkin service
and the service tracker automatically
gets notified or the other service
tracker automatically knows that the
pumpkin service got stopped and let's my
application know so that it can take the
appropriate steps and where this is
really cool is is say like in the
enterprise space or like that you create
a Java you create a bundle to handle a
set of applications in your enterprise
and you have a front page and that front
page managed by one bundle and then you
have other applications with other
bundles and say that so then what
happens is you take want to take down
one of your applications well that front
page has links to all your different
applications well what happens is if you
have the front page which is a bundle
with a service tracker that's tracking
your other applications that are loading
your osgi framework you can have the
front page automatically get notified
when that bundle goes down and change a
hyperlinked so that it's disabled and
posts a notice to the front page that
notifies that that application is
currently offline and and as soon as you
bring that application that bundle back
online then the service tracker will
automatically kick into gear and your
front page will then display a link to
the application and so it makes a
applications where you might take down
pieces of it and have multiple pieces
running at the same time it makes it
really easy to have pieces go down and
up and the other components that rely on
that system to automatically adapt to
what's running inside the system anyways
so
so let's go ahead and create a groovy
bundle I'm going to create a create a
groovy bundle and one of the nice things
is that groovy it has osgi headers
already in it and so we're just going to
install that this is just the standard
groovy jar file and so there are lots of
Java classes that have osgi headers Java
libraries that have osgi headers in them
and we're going to go ahead and create
the groovy controller
you can ox framework
and it's going to have its activator
however i'm going to change that to a
groovy class after we get going inside
the manifest file I'm going to take the
shotgun approach to this and this is
going to be the manifest file for our
groovy controller which imports all the
groovy libraries pieces the packages
from the groovy library
and we're going to inside the groovy
controller we're going to replace that
with a groovy class
and so we have groovy bundle activator
started review bundle activators stopped
and we're going to install the groovy
bundle that we just created and you can
see the groovy bundle activator started
so what happens is I wanted you to see
how easy because a lot of people these
days look view JV Piaget via the Java
verse machine much more as a platform
for all sorts of different languages and
so we're coding in JRuby and groovy and
Jai thon and and so it's very easy to do
even though SGI from the other some of
the other languages home even Scala all
seems to work very well anyways so I'm
going to go ahead and we're going to
extend our pumpkins service class just a
little farther and i'm going to import
something to make up for some time here
and i'm going to create a i'm going to
be importing an audio service and what
the audio service is is remember i
created a pumpkin service interface and
that's what we utilize to communicate
with the actual pumpkins however i
wanted to show that you can utilize you
can create other classes that implement
that interface and then categorize the
service and i'll elaborate a little bit
more what happens is this audio service
implements the pumpkin service interface
you can see and instead of controlling
the pumpkins its controlling music
playback and inside the activator we're
going to go ahead and register another
instance of the pumpkin service class
however we're going to attach some
properties to the registration of the
pumpkin service to distinguish it from
the pumpkin service which controls the
pumpkins so I attached a property that
says service type and that's audio
well then what happens is I'm going to
add a property to our pumpkin service
that's actually controlling our pumpkins
and you can see I'm attached I'm now
adding a property when I registered his
service as service type light now where
this comes in handy is you can write if
you're developing an application and I
say like an enterprise application and
and you want to develop an encryption
service that other bundles can use
inside your company you can develop an
interface that says that standardizes
the interface for the encryption service
and then you'll write a bundle which
implements the AES encryption service
and then you can attach a property of
encryption algorithm is equal to aes
well then later on down the road you
could write a bundle which implements
the encryption algorithm Blowfish too
and so you can attach a property then
for saying that it's an encryption type
is Blowfish too but your interface is
standard across all that and then so one
bundle client might that would be
implemented might simply say give me
give me an encryption service around
like that and the osu i don't care what
kind it is and so the osu I framework
you can do a query against the system
and it will return just any old
encryption service that first comes back
and then you can call it and encrypt
your data however you might say I prefer
the Blowfish to so I'm going to see if
that happens and you can do a query
against the osgi framework then that
lists based on properties of your
encryption services that are registered
with us UI framework and it will let you
know whether a Blowfish to it exists and
then you can decide whether you want to
report an error or whether you want to
fall back to a different encryption
service that is registered with the
system anyways so we're going to go
ahead and register that
now i'm going to go ahead and
preparations to make sure that stuff
doesn't fail here at the end I don't
have any repeats that was a disaster I'm
going to stop some stuff sometimes when
you're messing with some of the native
libraries like I'm doing with the
hardware control stuff you have to be a
little bit more careful how you clean
stuff up for warning if any of you guys
are going to be automating your own
dungeon props
and so I'm going to install the pumpkin
service that's going on register
that's always great
like a pilot
hmm
I thought well I meant to start the did
I not run the install command exit start
that again install
ah alright
there's our audio module thank you by
the way you yelled out that and you can
see that we have we have a two pumpkin
services registered with the system and
we can query against the osgi framework
typing services and you can pass
inquiries to the services and you can
see that we have two pumpkin services
that are registered one that has the
service type light and one that has the
service type audio and you'll see what I
mean how I use this in the finale which
hopefully works good we're going to
update the groovy controller here one
last time import
and basically what I added here was this
line at the bottom here for the pumpkin
service to import that and we're going
to create a new groovy class animation
now what this groovy class animation is
going to be doing is going to be opening
up a file that I have of timings and
playback the animation sending the
commands to the service and then we're
going to modify the activator here for
the groovy bundle
now you'll notice that inside my groovy
activator one of the things I'm going to
do is I'm doing a query forget all the
service references so I'm getting all
the bumpkin service references and what
happens as I'm sticking them into a
collection key by the service type and
so what that allows me to do is when I
playback my animation file and i'll show
you that right real quick here i have
timings here of the when to control the
pumpkins and then i have the property
that I'm looking for the service type
and so it allows me just to loop through
these timings are like that and make a
call to the osgi framework from my
collection I grab the service reference
of the pumpkin service that is
controlling the light and the audio and
then I send the command the parameter in
the bite and so I'm going to do that
and I'm going to install all the groovy
oh I'm going to plug in the audio here
and we'll start 12 and in so it's
looping through the timings and
controlling the buckets
you
hey anyways um I went a little rougher
than I was hoping it would I hope you
guys got something out of it and do you
have any questions now oh yeah if you go
to Kevin Garnett I have some details of
me building the pumpkins yes
there are some tools out there I that uh
buying tools put out by somebody if you
search for that it helps you manage the
manifest file it there are some people
who have developed some utilities that
are kind of the what is it convention
over note yeah convention over
configuration where if you lay out your
code in a special way and use that tool
it makes a lot of assumptions and build
your manifest file for you I tend to do
it manually ivi it's probably more habit
than anything because when i started
osgi none of that existed yes yes I'll
put it up here and when I give the slide
to oracle or like that i have the demo
cos a they'll have the presentation up
on there and you can't really demo all
the failures i did today and so so
happens is you can go and see the source
code that's all there so but you'll have
to solder your own pumpkins together yes
Senhor or unit park in the unit part i'm
sorry there's a sensor library our
measurement of you know i haven't
utilized that yet but i I've done I've
read about a little bit oh and that's
one thing that he weddings up a good
point there are tons of osgi bundles and
libraries out there for doing lots of
various different things with the osgi
framework and so I really just scratched
the surface about kind of like what the
core osgi does but there are bundles for
entire web servers that you can load up
and then use to serve out web pages and
security frameworks and authentication
and there's osgi specifications for a
lot of that and built in logging and all
these other stuff and so there's a lot
out there but this was just to give you
guys a kind of an idea the concept yes
one instant does it actually unload the
class party if I have if we have a
running system which is always running
this is turned off which means when you
say java dash out and always da
framework that if you start that OSU we
should always have our system yes but do
we have the old classes in memory in the
JVM or it is gone when you don't
understand it's gone off the JVM all
right like that however there are some
other different osgi frameworks out
there and there's some of that stuff is
up to interpretation of the
implementation and so if that's
something that you're interested in I
would advise double-checking that and
running some tests with the osgi
framework that you end up going with I
tend to use equinox which is what power
is eclipse and seems to be pretty clean
but they're depending on how small or
larger framework is there's lots of
other choices as well as utilities to
help manage it yes it tends to be just a
particular server what happens is though
you you would end up utilizing some of
the tools that are best in that category
as osgi bundles and so you have an osgi
bundle framework running on each of
those systems and the bundle could come
up and depending on you know what white
your clustering software's doing or like
that it would come into memory the osu i
bundle is really from maintaining what's
running on that particular JPM any other
questions I think you can fine tune that
down to a specific class I tend to do it
at the package level to break things out
again though it's I think it's osgi
implementation-specific they've been
they've equipped so what I say that is
like equinox ads why use the equinox
framework and equinox adds a lot of
features specific for Eclipse and so I
can't remember off the top of my head
what the actual osei implementation says
and stuff and so i would i would check
into that but
I've always tended to do it at the
package level and all the tutorials and
stuff that I have gone through over the
years tended to do it that way at the
package level it's pretty easy to
separate out your classes that you want
exposed just in two separate packages
yes two bundles both use the same
third-party library but they're on
different versions can one import the
other bundle without conflict of the
other library that they're both using
yes yes what happens is if they're both
in what happens that library would have
its own package space and so if one
bundle if both bundles are using say
less for simple simplicity is using
package a and the and the but they want
to but bundle a one once to export
package be to bundle to like that well
if bundle it because bundle a one would
have to export that package right and so
what happens is if it exported package a
was that confusing I hope not like that
if it when you you have to export that's
why they do it at the package level you
have to be very explicit that's why when
you saw my osgi my oh sure my groovy
bundle I had to import every single
package it's not nested packages or
anything else so if a bunt one bundle
has multiple things in this class path
and it exports only a specific package
its that's all it exports not even the
nested ones just directly what's inside
that package name actually that's one of
my pet peeves that you have to do even
the nested package names does that
answer your question so you have a
really fine grain amount of control
about what you export and what you
import and the osgi frameworks takes
place at wiring up on the run time what
that bundle needs whether you know very
different versions of the library or
whatnot yes
its exports and use that as important
today with library that you're using you
just take them all or do you
you can pick and choose at times it's at
you know like I said I took the shotgun
in pro trail like that to get the
demonstration together like that in 10
also because i tend to cut and paste
that groovy code around a lot because
when i'm writing groovy bundles i want
to have everything available to me what
happens is you can pick and choose down
to just specifics and and with
third-party libraries if they're
utilizing osgi manifest headers inside
their jar and a lot of Amara like that
you can splice apart the jar and take a
look at what they're exporting and if
for some reason somebody doesn't have a
Oh if their jar their library is not
osgi compliant right there you can just
simply wrap that their library inside
another one of your jars and then export
the package and then so it makes it
really easy to turn any library that is
not osgi ready right out of the box into
an osgi ready library that's actually
pretty easy
yeah that's that's why the are you if
you're talking about just libraries or
whether you're talking about services
with osei with the services it gets
really easy because they provide the
service tracker library that I
demonstrated and it makes it really nice
for your bundle to examine to
automatically examine what's running
inside the system and to respond
accordingly whether that means shutting
down or or just simply turning off
features it's not using on the fly and
then once that service returns back
automatically adjusting and then running
again if it's with libraries um it kind
I guess it just the manifest you know is
not as dynamic you'd have to shut down
the bundle and bring it back up or like
that and a lot of times if a dependency
isn't found the bundle will ship you
know throw an error and that would be up
to you to handle yes
to be able to share some features within
the future but not outside with inside
the bundle so I let's say I've got some
major features three or four major
features inside of each of those
features I have some features that I
want to be able to export the services
within the major feature but not a
bundle hierarchy you mean um no I really
haven't seen anything about that no it's
mostly set to be pretty loosely coupled
so that you registers things with the
osgi framework are like that and import
you know imported if it's your own
library or like that well then no once
is exported onto the osgi framework it's
free game for the rest of us Jeff remark
as far as I know hi things is by
declaring I'm internal but then they
wouldn't be bundles exposed it would
only be used internally within your
future yeah that's that's you if you put
all the features within a single bundle
you know that would give you higher arc
here like that but then that I but I
assume that you wanted the bundle
capabilities yes
installing new one in this place like
wait for that to be done and then have
the tracker um I think you could be able
to do that there's nothing built in to
do that you'd have to do it manually but
I don't see anything that would prevent
you from doing that if I understood your
question correctly any other questions
yes equinox is what I went to after uh
oh it I haven't really investigated a
Felix an awful lot and so I see no
reason the one of the things I like
about Felix is it i think it's closer to
the standard osgi specification equinox
tends to include a lot of eclipses own
stuff that they want to utilize and so
every once in a while I've thought about
going to Felix in order to stay closer
to osgi but I just really haven't made
the switch or like that equinox is what
I naturally went to I was on sons jes
server when they came out with it and
then I went to something called knopfler
fish I think and then and then equinox
and that's just where I've stayed so far
any other questions thank you very much
it's been a hope you guys got something
out of it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>