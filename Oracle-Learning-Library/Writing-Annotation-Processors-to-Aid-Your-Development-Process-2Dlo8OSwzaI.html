<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Writing Annotation Processors to Aid Your Development Process | Coder Coacher - Coaching Coders</title><meta content="Writing Annotation Processors to Aid Your Development Process - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Writing Annotation Processors to Aid Your Development Process</b></h2><h5 class="post__date">2013-01-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/2Dlo8OSwzaI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right going to be talking today
about writing annotation processors the
goal of this talk is just to show you
how you can go about writing an
annotation processor with the specific
goal of writing processors that can aid
the development process in particular if
you're expanding the type system so
thing about writing annotation
processors is it's not hard
in fact it's fairly easy to do once you
know how to do it and in fact the api's
for it are very well documented if you
look at the Java Docs for each of the
classes involved there they're pretty
good unfortunately there's not as much
documentation out there about how to go
about writing a processor from start to
finish what are the things you need to
worry about the goal of this talk is to
give you an overview of how it is that
we write a processor so first of all it
just as I said how do does one write a
processor in particular I want to cover
a few non-obvious aspects of writing a
processor one thing that I don't expect
to be able to do in an hour in covering
annotation processors is give a talk
that will make complete sense so that by
the time you're done you understand
everything I'm striving for that goal
but I don't believe that we'll be able
to completely succeed however the slides
and the code will be available the codes
already up on github I'll show the URL
at the end and the slides will be
available as well and if anyone wants to
know where to find the slides they
should be up on Oracle's website and
I'll probably also put a copy of the low
up along with the code on github so
there's going to be some spots here
where it goes quickly if you're trying
to take notes that completely reproduce
the talk you'll probably fail so I would
recommend sit back and enjoy and try to
get an overall sense of how things go
don't worry too much about the details
you can always refer back to the sample
code later alright so with that what's
the agenda well first of all I just want
to do a very quick review of annotations
talk about what annotation processing is
and what some good uses are of it and
then the majority of the talk will be
focused on exactly how one writes a
processor
so really quickly how many people are
not familiar with annotations how many
people would not raise their hands even
if they weren't familiar with
annotations out of fear okay so these
are annotations uh there's just a few
things I mean you can document
annotations with annotations including
things like the target type in this case
this annotation here entity a JPA
annotation would belong on on classes
otherwise known as type and it would be
available at run time and then at the
bottom you see an example of a class
that is annotated with entity well
annotations can have various values on
them including primitives like intz and
billions and the like other classes
class constants strings Anu Muse
although only for a particular Anu
McLouth one at a time you can't just say
any a new value have to specify which a
new class other annotations and arrays
of any of the things I just mentioned
including I believe arrays the places
that annotations can go they can go on
classes and interfaces otherwise known
as types they can go on other
annotations they can go on fields local
variables parameters methods
constructors you can annotate a package
by basically annotating the file what is
it
package - info dot Java you can put
annotations on packages that way and in
Java 8 they'll be even more places you
can put them down in particular you'll
be able to annotate types that show up
within generic parameters and so forth
now when annotations first came out the
the way they were most likely used was
at runtime and so this would be a pretty
straightforward thing you'd have some
sort of class and then you'd say well
hey get me the annotation in this case
the entity annotation and you're telling
me to lower my mic down aren't you these
are we bet can everyone still hear me
bring it up a little or is this good
bring the mic up a smidgen okay how are
we doing now is this any better we'll go
with this okay
so you can maybe so you can you can you
know ask for the annotation and then you
can treat the annotation like an
instance of a class you can say excuse
me include 50 annotation is an instance
of the class you can ask various
properties so remember entity had a name
property well we can just say entity
don't get name that's what it's like at
runtime but annotation processing is a
little bit different so first thing is
it doesn't run at runtime it is part of
your compilation process it happens
during the build processors get
discovered from the compiled class path
you have and we'll talk a little bit
about that happens and then a processor
at least according to spec can do three
things it can create new resources it
can create new source files and the
third thing it can do is it can issue
notes or warnings or errors and notably
errors will cause compilation to fail
we'll see how this becomes useful in a
second the the one thing to note is that
at least per the spec processors may not
modify existing resources or classes
they can only generate new ones projects
like project Lombok violate this and
they do it by digging into the internals
but at that point you're going off in a
whole new direction so what are the some
of the things we can do just with the
basic annotation processing api well we
can of course we can produce generated
code has anyone here used type safe
queries in JPA 2.0 okay so you're using
generated code from your annotation
processor you can also generate
resources and one example is you might
want to for example list annotated
elements in some fashion or create if
you saw yours loves talked earlier you
can see ways that you can create entries
in your service provider's folder in in
meta m but the most interesting thing to
me is adding additional compile time
validations and the nice thing is
because these are compiled time and
because of the spec i des are going to
pick this up your tooling is going to
pick it up if you're using eclipse that
will pick it up and you can use it to
add type safety to your builds now the
checker framework does some of this all
the checker framework only works if
you're building with Java C in
particular the Eclipse e JC the Eclipse
Java compiler does not support the
checker framework because it's being
down-tuned internals but what we're
going to be talking about today are the
types of things you can do just with the
basic spec and the example we're going
to work with today we're calling JP a
processor and it's going to do two
things the first thing that it's going
to do is verify that any class annotated
with at entity has a no argument
constructor because it turns out that if
you have an entity class in JP a that
does not have one of these you're not
going to get very far might as well find
this out at compile time instead of at
runtime
the second thing is going to be a little
bit more of an involved example to allow
us to see more of the features of the
API and this one's going to say if I
have a property that's annotated with
the one-to-many annotation so think of
this as the annotation you put on a the
parent side of a parent-child
relationship well the child should have
a corresponding property that is
annotated with many to one and it should
have a mapped by attribute that excuse
me the one-to-many annotation should
have a mapped by attribute which points
to that property on the child so we're
going to see if we can do all this but
before we go any further let me just
show you a quick demonstration of how
this processor works in practice and
it's going to be an interesting
challenge because of a couple things one
is that I am NOT able to see what you're
able to see except by looking out to the
side and the second is that I'm not
running this on a Raspberry Pi and so
it's not really a proper demo for Java
one so here we have a class a parent
class and it is annotated with entity
it's got a set of children a set of
child elements called children annotated
with one-to-many so let's try doing a
few things here first of all let's
create a new constructor so we'll say
public parent and that's fine let's have
it take a parameter and now you see
already we have this lovely little red X
up here in the corner
now you can't read
probably but it says missing no argument
constructor that's coming from the
annotation processor that we're going to
go over today so let me fix that up
again similarly we're pointing down here
to a mapped by value and if I change
that from parent to parent with two R's
I now see right here that what does it
say mapped by attributes should be
parents so it tells me what the values
should be in this case but in this case
we'll leave it it is you'll notice also
these warnings are showing up not just
anywhere in the file they're showing up
as close as possible to the problem in
the source code
now that's Eclipse we can see a similar
thing if we if we run a compile right
now if we run a compilation everything
should work just fine but if I again
break the build then everything should
stop running just fine and indeed we're
going to see a compilation failure map I
attribute should be parent so that's all
just to convince you that what we're
doing might actually work so let's see
how we write a processor there's a few
basic steps upfront one is that you need
to create a file in meta MphasiS called
Java X annotation processing dot
processor and put the name of your
processor class into that file this is
just so that the JVM can discover your
your annotation processor at runtime
second thing and and it depends on the
environment you're working in whether
this is strictly necessary or not but at
least in some cases it turns out to be
very useful to turn off annotation
processing while compiling the processor
the reason for this is that some
compiled environments will try to run
the annotation processor that is
currently under compilation or at least
they will see that meta in resources
file and say oh this is a processor X I
should run so it to be a little bit
careful about that
next step is to implement the processing
API which is Java X annotation
processing dot processor you could do
that but you would be far saner to
simply extend Java X annotation
processing abstract processor because
there's a few things you need to do with
an annotation processor one is that you
need to spend
by what you're supported annotation
types are and what version of the
compiler you're targeting and if you
extend abstract process so you can just
specify this with annotations because if
we're not meta what's the point but
additionally it's going to provide a few
other things is going to help track your
processing environment for you and a few
other things that we'll talk about so
let's see what a processor starts off
with well as I said the first thing you
want to do is extend abstract processor
but after that you want to say alright
what are my supported annotation types
now unfortunately supported annotation
types does not take an array of classes
it takes an array of strings so there is
a one-time opportunity to mess up here
or at least this is one of many
opportunities you have to mess up you
just want to make sure you type this
correctly one reason it takes strings is
that you can include wildcards in here
so if you were writing a general JP a
processor you might just say I want
anything in Java X persistence
there's even you can even say I want to
see everything regardless of whether
it's annotated or not we'll talk about
that a little later supported source
version this just says what version of
the compiler you're ready for if you say
you support version six and you're
running in version seven that's going to
be fine not so much the other way around
all right well the next thing that you
might want to do is override the anit
method if you do make sure you call the
super init method because the anit
method is where the processing
environment gets passed in and we will
talk about that just a little more in a
second
you're going to want to hang on to that
unless you're extending abstract
processor in which case it's going to
hang on to it for you in a protected
variable you can easily access called
processing end you might also want to
define certain constants in your net
method we're not going to do that today
just for simplicity but bear in mind
anytime we define something that really
could be defined at a higher level
that's where it belongs
finally you're going to want to override
the process it the process method this
is what does the work it takes in a to
two arguments the first is the set of
annotations that well let me back up
processor gets called for in one or more
rounds the first round is what you're
compiling what you ask the compiler to
compile however remember that processors
can Cree
eight source files those need to get
built too so once you create a source
file a second round is going to be
created where it goes back and compiles
those classes generated in the first
round and this process could repeat a
few times so you have one or more rounds
the round environment is basically
giving you access to what's being dealt
with in the current round annotations
are which annotations are on elements
that are in the current round now
processor is going to do various things
one thing you probably want it to do is
to return false because if you don't
return false if you return true you're
saying I have handled these annotations
and therefore no one else should I can't
think of a good use case for that if you
can then return true but otherwise be
polite return false all right so let's
talk about the processing environment a
little bit as I mentioned it's passed
into the Anette method and abstract
processor will hang on to it for you
it's got a few things in it that are
useful it will give you access to
element utils and Taiki tails element
utils is something that works not
surprisingly on elements type utils
works on types and we're going to talk a
lot about types and elements here in a
bit the filer is what you would use to
create new resources or source files the
messenger is what you use to create
messages like those compiler errors that
we were seeing earlier and options if
you're running Java C you can use -
capital a to pass options into your
annotation processing environment and
the get options method allows you to
access those not commonly used though in
some states in some cases it can be can
be handy so elements and types here's
the tricky thing when you're working in
compiler land you can't use the classes
that you're compiling because they're
not built yet uh and and and there can
be multiple issues with that one is you
know they're not built yet but we're
going to build them okay well why can't
you just ask the compiler to build them
now another issue might be they didn't
build there were compilation errors but
we'd still like to be able to say
something useful about them so instead
of using the reflection API which works
with classes that are available through
a class loader
we're going to use mirrors and in fact
we're going to use two kinds of mirrors
because when you're compiling there are
two types of things that you need to
worry about one or elements these are
basically the units of compilation or
elements of compilations so the element
package contains various interfaces for
modeling elements such as classes the
methods on those classes variables that
are used either as fields or as local
variables that are annotated annotations
of course and and and this sort of thing
the particular thing to bear in mind is
that whenever you see something in the
element package it's talking about a
piece of source code it refers to
something with a line number by contrast
you also have the notion of types now
types I mean this is you know when
people talk about type theory that's
what we're talking about when we say if
I say Java util list I could be
referring to two things one is the the
class list Java which was in the package
double util but I could also be
referring to the return type of a method
and in the latter case I'm talking about
a type notably types are richer than
elements in some ways because types can
have generic parameters to them and in
fact we'll we'll see a little bit more
about that a little later
so just to give you an overview of what
the package layout is in the element
package you've got element underneath
element you've got four main classes
there's packaged element type element
type again type element refers to an
element that's either an interface or
class executable element is going to
refer to things like methods
constructors and variable element will
refer to things like global variables or
fields you can access these somewhat
directly or if you want and you'll like
the visitor pattern you can use the
visitor pattern so there's an element
visitor and there is also an annotation
mirror which is used for looking at
annotations that you don't have
available on your class path but you
still want to look at and then
annotation value is for looking at
values of attributes on those
annotations and then finally because
know life is complete without multiple
uses of the visitor pattern we also have
an annotation value visitor
unfortunately there is no annotation
value visitor Factory apparently spring
was not involved
in in the tight package by contrast we
have several types as before we've got
an executable type we also have a
primitive type to refer to things like
int type we have wildcard type that's
for generics reference type basically
means um well things that you can refer
to things that like you know think the
pointers effectively so declared type
again is interface or class array type
type is is arrays type variable you'll
see within generic parameters null type
refers to null
error type refers to something that the
compiler tried to compile but couldn't
because remember the compiler doesn't
want to break just because the code it's
compiling is broken it needs to be able
to carry on now to me at least this is
all a little hard to grok so got a
picture here let's suppose that we have
a annotation so we public at interface
companion class so this is an annotation
that just will name another class so
that would be modeled the annotation
file itself as a type element and type
elements confusing because you might
think oh that's one of your types no
it's an element now here we have a class
that's annotated with companion class
and it's got a value for friend of Bart
class so the companion class could be
referenced as an annotation mirror so
this will not be something of type
companion classes will be of something
type annotation mirror and on that
annotation mirror we can ask for its
annotation type and get the type element
that refers to companion class we can
also ask well what are your executable
elements and in particular we could get
the friend element so remember
executable elements are a fancy way of
saying methods and on an annotation a
method is just an attribute well friend
is an attribute and I can ask for its
value which would be referenced as an
annotation value now on a lucky day if
Bardock class is in the class path of
the class loader that my annotation
processors running under I could just
say well hey get me that but in more
generality I'm going to have a declared
type because I don't know I I can't
actually refer to the class but I can
refer to the the compilation
that's being talked about now I can ask
for that as an element because declared
type is is a referring to a type and
then I get the type element referring to
the compilation unit bar and finally if
I go to my processing environment and
ask for the type utils object I can go
in the reverse direction I can say get
me the declared type that's based off
this type element and what you're not
seeing here but you can do if your type
can take generic parameters get declared
type can take additional parameters
indicating what the generic values are
so you have a fully-realized generic
type all right so let's see how we can
use all of this we want to write a
processor and the first thing that we
want to do is we want to see how it is
that we're going to annotate or how
we're going to look for elements that
are annotated with entity so the first
thing that you need to do is you need to
ask your processing environment
well I back up a second you're going to
add you're going to want to ask your
round environment for elements that are
annotated with entity but the first
thing you want to do is get ahold of the
entity annotation type there's a few
different ways you can do this the most
general strategy is to use element utils
and ask for the element by name once
you've done that you're really actually
going to need the type and so
fortunately remember we said type utils
has the get declared type method so now
we have the type referring to the entity
annotation and now finally we can ask
the round environment for all the
elements in the current round which are
annotated with entity type element so
we're going to get a set of elements
that have the at entity annotation on
them and now what we want to do is we
want to go through each of these and
check for a no argument constructor well
as it turns out elements annotated with
that can return all sorts of elements a
priori at least it could return classes
it could return fields packages we
happen to know that everything annotated
with entity has to be an interface or
class so in particular it's going to be
of the declared of the type element
class there is a nice class called
element filter
in the in the standard API which has a
static method types in which we'll take
a set of general elements and give you
back just those elements that are of
type element type and the nice thing
about that is that you don't have to do
the casting yourself so we're using that
here even though we know that all of
these are already out types and then
finally we just want to check for a no
argument constructor
now there's only one problem with this
code and that is that the check for no
argument constructor doesn't exist so
let's write it well here we're getting
in an array of we're getting in a single
type element and basically we want to
find out if it has an argument
constructor so let's just start looking
through its constructors so element
filter well first of all the type
element has a get enclosed elements
method on it that method is generally
available on type element and package
element I believe you can get enclosed
elements so there's going to be a bunch
of enclosed elements there's going to be
fields methods constructors we just want
the Constructors so again we can ask
element filter to just give us those
constructors and based off that we will
get enclosed we will get a set of
constructors and then for that for each
constructor in that list we're just
going to ask for the parameters to that
constructor now that's going to be a
list of variable elements but since
we're looking for no argument
constructor is we don't really need to
worry too much about what it's a list of
we just need to ask if it's empty if
it's empty everything's great
we're fine we can we can quit now
but if it's not empty well then we need
to go back to our processing environment
to get the messenger and print the
following message missing no argument
constructor and in particular we're
saying that it's a message of type error
and let's talk about this message or
just a little bit more sure
yes it is thank you yes the the bottom
the bottom row it says type element it
should just read type thank you for
catching that I'll fix that before I
give them the PDF okay so the messenger
class it's got basically a four message
four methods on it the simplest is just
I want to print a message and diagnostic
kind can be info warning or error and
here's the message but that's not
terribly useful that just says there's a
message so that would be the equivalent
of I'm sorry if you printed an error
I'm sorry but compilation failed but I'm
not going to tell you where so you might
want to say well what element is this
attached to it could be the the type
element or it could be a constructor
element or whatnot more precisely if
it's related to an annotation you could
say well what was the annotation that it
was talking about and if you really and
if it was related to a specific value in
the annotation you can even get more
precise so in this case we have the type
element that were that were referring to
namely the class and and we really can't
say anything more precise than it's the
class you're missing a constructor so
you can't annotate the constructor that
you don't have all right and just to be
more precise kind error it doesn't just
log an air a message with with level
error it also will actually signal the
compiler the build is now broken so
merely logging has a noticeable effect
if you go to log error all right well so
far so good okay let's go to the next
step which is doing handling the one to
many and many to one annotations so the
goal here is that again recall for
properties annotated with one too many
the child elements there's a
parent-child relationship the child
element should have a corresponding
property annotated with many to one that
property should have a type of the
parent elements type and the one to many
annotations must all have the one of any
annotation must have a mapped by value
which names that property on the child
so for example if we have a class parent
like the
and we have a corresponding child class
well you can see that parents has a get
children method with a list of child so
child is the type of the child type
we're going to need to drill down and
find that type and then we're going to
need to look after we've matched those
up we're going to need to look at the
mapped by attribute and make sure it
matches the corresponding property in
the child so how we're going to do this
well the first thing that we're going to
need to do as before is we're going to
need to find all the elements annotated
with one-to-many this is just like we
saw before first of all we need to get a
reference to the one-to-many annotation
type and then we want to go through the
round down environment asking for all
types that are annotated with that and
for each element we want to check for a
bi-directional mapping on that now in
this case what are the types of the
elements that are annotated so going
back pardon
there are executable elements if it's a
method or remember in JPA you can also
annotate fields so we're going to be
looking at variable elements or
executable elements depending alright
well last thing we need to do is
actually write the check for
bi-directional mapping so for each
element we're going to try to see if we
have the bi-directional mapping set up
properly okay well this is going to be a
little bit tricky we're going to have to
do it in a few steps so just to give you
a quick outline the first thing that
we're going to need to do is we're going
to need to find the child type from the
collection type so right now we've got
say a reference to the get children
method we need to look at the return
type and that's going to be a list of
child but we really need to know it's a
list of child so once we have that type
the next thing we need to do is to find
the class corresponding to the child
then we want to find the parent property
in that child and then finally we want
to check that the map by maps so that at
a high level is what this check for
bi-directional mapping is going to do so
let's start writing it
well just to refresh the child property
here is referencing in this case to this
get children method that's what we have
to work with the first thing that we
need to do is to find the type of that
property so we can call get property
type or we could if that method existed
so let's see if we can write that so now
it's a little more interesting we've got
an element and we're not sure what kind
of element it is there's two approaches
you can take here one is you can use the
visitor pattern you can create a element
visitor and have it implement the
various visit methods you need and have
it return something and that's nice and
fun especially if you enjoy the visitor
pattern but fortunately element has a
get kind method that returns in a new
and you can just switch off of that for
most cases benefits of the visitor are
not many in my opinion they're there if
you have to do a lot of stuff than the
visitor might make sense but in this
case it's usually fun to do this the one
thing that you don't want to do so well
let me give an example here so if it's a
field well now I know it's a variable
element and variable element has an as
type method so I can get the type off of
a variable element note what I'm not
doing here is saying well if element is
instance of variable element doing that
as a bad idea because under the hood the
compiler has the option to and I believe
Java C does this to implement multiple
types with a single class now at any
given time that class may only be
referring to one kind of tight but if
you use an instance of check you're in
trouble
so just instead switch off I'll make it
kind or write a visitor so if it's a if
it's a field we just asked for the field
type on the other hand if it's a method
we can cast it to executable element and
we can ask for its return type now if
neither of those happens let's think
about this
we have a one-to-many annotation the
retention type of or sorry the target
type for one-to-many allows you to
annotate fields or methods and we just
got something that was neither of those
so in this case might be reasonable to
throw an illegal argument exception now
this won't break the compilation this
will break the compiler
or at least your annotation processor
will stop running and I believe your
compiler will abandon as well so this
only do the only throw exceptions when
you're sure you've made a mistake as
opposed to someone writing code that
you're processing okay so now we have
lists of child in this example we've got
a collection type which is the property
type for our JPA property we now need to
figure out well what is the component
type so I'm going to ask for the
collection type and we need to write
that method as well so how do we get
collection type well the first thing we
need to do is we need to say I want to
make sure that that what I'm dealing
with is actually something that
implements collection so I'll get a
declared type for collection type and I
can do that in the standard way that
we've been seen before first get the
element and get the type and then I can
ask my processing environment for a per
type utils and I can ask type details is
this assignable so this is like you know
the similar to the is assignable method
you'll see in in class Java so if it's
assignable then and here I'm going to do
a bit of a cheat I'm just going to
assume that I'm dealing with something
like list of or set of ArrayList of
something like that that has a single
argument and I can ask for the type
arguments of the declared type so that's
getting the generic types and then I can
ask for the first argument of that class
now in general this is not correct
because of course it could be that the
property type was a class string list
which itself extended ArrayList of
string so to do this properly and we're
not going to do this today to do this
properly you'd actually need to walk up
your inheritance hierarchy tracking type
parameters as you go that's more trouble
than I want to go into today but that's
less about the annotation API and more
just about dealing with generics
well if it wasn't a if it wasn't
assignable from collection then
someone's annotated a property with many
to one that or with one too many that
shouldn't be and so we can raise a
compilation error I won't bother doing
that in the code because we're running
out of slide space alright so now we
have the we have the type that the
property referred to and we have the
child type the which is referring in
this case directly to class and the next
thing we can do is we can ask for that
type as the element so now we have a
reference to child element that's the
compilation unit as opposed to the type
child and we'll need the compilation
unit so we can actually look at things
inside of it
however oh sorry we're gonna need one
other thing we're going to need to know
the the parent type so far we've had the
access we've had access to this property
but this property is a remember this
property is a field or a method that's
something that lives in a class we need
to know about that class itself so we
can ask for the enclosing element of the
child property and that should give us
the the parent element class and again
we're going to need the type referring
to that so we will also ask the type
element corresponding to that okay now
if you're paying close attention you'll
notice something and that's that we're
about to run out of space on our slides
so let's do a little bit of quick
cleanup here get rid of things that we
no longer need scrunch everything down
and we don't need those definitions
anything anymore we just need to
remember that we have the child type and
the parent type the next thing we need
to do is to find in the child type the
property referencing back to the parent
so in particular it's this in this
sample code it's going to be the private
parent parent annotated with many to one
so how are we going to do this well
we're just going to call find parent
reference and child type I mean that's
obvious except of course once again we
need to write it so child element
remember that's the class of child it's
got a bunch of enclosed elements in it
constructors methods fields so we can
just loop through
them now we could have been an element
filter again here except we really need
to loop through two separate kinds we
need to loop through fields and methods
so we'll ask for each element if your
element kind is a field or method then
well can't just be any field or method
you got to be one that's annotated with
many-to-one and here I'm just going to
say element get annotation minute one
class so here I'm relying on many to one
being in my class path I should note
this is not quite always the case in
particular the Eclipse compiler unless
you tell it doesn't put any of the
classes in your class path on your
annotation processor class path there is
another way to get it annotations that
we'll see a little bit later as an
alternative but just to keep things
simple here we'll say if there's a
minute on one annotation on it and then
finally we're going to want to say hey
processing environment well first of all
remember we wrote that get property type
method earlier we're using that again to
ask for the property type of the element
we're looking at and then we want to ask
is this the same type as the type of the
parent class a parent type and if it is
we found our element and if we go
through and we haven't found anything
then we're just going to return null and
say we did not find the the parent
reference or a property referring back
to the parent in the child all right so
now we have the parent property and
child the next step we also need to find
the one-to-many annotation which is on
the child property in the parent class
now here going to do this a little bit
differently again I could ask for the
element I could just say get annotation
of one-to-many however I want a
reference to the mirror and you'll see
why in a little bit why we want the
reference to the mirror it's also useful
again for seeing how to do this when you
don't have access to the annotation
class when you're building your
processor or running your process or
even okay so need to write get
annotation it's going to take in an
element and a declared type and
basically now we're just going to ask
the l
for all annotation mirrors not actual
annotations like get annotations returns
if you call get annotations on a class
object using regular reflection you get
annotations here we're just getting
mirrors because again we may not
actually have access to the classes and
then we'll just look through them we'll
say all right well if the the mirrored
type is the same type of the type of the
annotation I'm looking for that's what
I've got otherwise I don't have it
so now we have annotation one-to-many
annotation is referring precisely to
this one-to-many annotation element here
and we also have a reference again to
the parent property in the child and
since those are the main things we need
let's do some more cleanup and get rid
of stuff which is no longer relevant to
code going forward now we want to verify
the many to one annotation sorry that's
coming from the next room okay never
mind then
alright so how do we verify the minute
one well if the parent property and
child was null and then we've got a
problem here we might as well just list
an error right away so in this context
we're going to say that you know we
weren't able to find a matching property
with many to one on the child element
now remember I told you I needed that
annotation mirror one-to-many annotation
and this is why because now I can
actually say it's not just a problem on
the method get children it's a problem
with the annotation on the method get
children that's what makes us believe
something's wrong so by passing that in
I'm able to precisely place my error
okay well let's assume that that's fine
and move on to the next case
so the next thing I want to do is I want
to get the mapped by value so this is
the on the child property it was
annotated with many to one and many to
one should have a map by attribute I
want to know the value of that attribute
now again in this case if
the many to one annotation is in my
class path at the time my processors
running I can do this the easy way I can
just say well get me the annotation and
then invoke the map by method on it
however more generally you can't always
count on that and let me show you what
you do when you can't so I'm going to
call get map by value and let's let's
write that method so basically what I do
here is I'm given a annotation mirror
for the one-to-many annotation and I can
get a map of all the attribute values
off of that and I basically get say ask
me for the element I asked the processor
for the element values excuse me I asked
the mirror for the element values but
those are basically a bunch of
executable elements with with with
values so the executable element is the
key of the map in this case the
executable element were interested in is
the one corresponding to mapped by and
then the value is going to be something
of type annotation value so what I want
to do is I want to return element values
get mapped by attribute and the way to
get the map file attribute is so
remember I I'll declare this say and my
anit method to ask for the mapped by
attribute off the one-to-many element in
this case how do I do that well pretty
simply I just say let me go through all
the methods on my annotation class and
if the methods simple name as a string
is equal to the name I'm looking for
then that's the one I got and if I don't
find it then again the annotations that
I'm trying to process don't look like I
thought they should so it's actually
reasonable just to completely break
compilation break the compiler itself
well at that point now we can look up
the map by attribute and get back an
annotation value so we have the
annotation value and what's the next
step to do the next step is well if it's
null that means they forgot to say
mapped by so now we can just put out a
quick error saying you know you didn't
have a mapped by attribute and that
would be an error on the child class and
an error that would show up on the child
properties
noticeably right now we are compiling
the parent class but the error is going
to show up on the child class and that's
legal at least I think it is unless Joe
darcy tells me it isn't going once going
twice alright it's legal finally I've
got a value I need to know what it's you
know value as a string is so I can take
a look at it there's two ways you can do
this one is you can write an annotation
value visitor and say well in the case
that it's a string value give me the
string or you can say look there is a
get value method just call that and
that's going to give you something and
if you know what kindness should be then
you can cast that something and in this
case I know it's a string so I'm going
to cast it finally I want to compare
that to the property name of the parent
property so how do I get the property
name well if it's a field I just ask it
for its simple name and then I say to
string because it starts off as
something of type name if you look at
the name type it looks an awful lot like
a string but it's different because it's
a compiler and so compilers get to do
things like that
who knows if it's a method well it's a
little bit more complicated I won't show
all the code here it you basically get
the name of the method but then you have
to do the whole Java Bean thing removed
the get D capitalized next letter and so
forth anyway if those names are not
equal then we have one more error that
we can throw on and now we can even
specify not just the class where the
problem lies not just the method where
the problem lies not just this
annotation but even the annotation
values so write down as precisely as we
want to get and once that's done we're
done okay if you're human you haven't
followed everything but hopefully you've
followed enough that when you go back
and look at the sample code on github
it'll start to you can reference it and
kind of tail yeah I remember this and
then look at the slides and start to
make sense of this what I want to do for
the last little bit of this talk is is
talk about some of the other things to
think about when you're writing
processors one is how to test them so
there's the obvious way to test your
processors you build it and then you can
using your processor and see if it does
what you want it to do but that's not a
very reproducible strategy at best what
you really want is unit testing and in
fact you can unit test these things and
if you're writing an annotation
processor I cannot advise you strongly
enough to set up a unit test not only
for the usual reasons but also because
if you're running a unit test you can
run that unit test from within your IDE
and you can set breakpoints right within
the annotation processor which is kind
of cool because not only can you see
what your annotation processors doing
and as you're trying to figure things
out that can be really useful to see
what the types of things that you're
getting is and so forth you can also
then walk up the stack for trace and
find yourself in the actual compiler
which is always just neat to see you
know compiler stuff so want to use this
not just for the automated test but for
the debugging in this case the thing
that we're doing is you know we are our
processor needs to have side effects and
so how do you how do you test the side
effects well in our case the side effect
involves messages being written out to
the messenger so what you need to do is
first you need to wrap your processor in
a nother X's in this wrap your processor
in one wrapped processing environment
that doesn't make any sense
what it should say is map your processor
in a processor Oh
grab your processor in one that wraps
the processing environment so remember
the anit method of processor takes in a
processing environment you're going to
want your wrapped processor to take that
and pass it on to your processor except
wrapped and the reason you're going to
want to wrap that processing environment
is so that when someone asks the
processing environment for the messenger
excuse me for the messenger you can then
pass in a mock object for that a mock
messenger you written up using mockito
similarly if they're going to try to be
producing source files you might want to
wrap the filer same idea
now I'm not going to show all the code
for that it's it's a fair amount of code
if you've written unit tests and done
mocking none of it's terribly surprising
it is in the github sample another thing
that you might want to do is to handle
all annotations so in this case
supported annotation types from
where I said this is a string not a
class you can have wildcards you can
just say star in this case not only does
your processor run over any element run
if any element is annotated with
particular annotation it runs over even
elements which aren't annotated at all
this can be useful if you want to do
other types of type checking for example
or if you're looking for an annotation
whose name you don't know at the time
that you're building your processor
which seems a little odd but I assure
you there's some very legitimate use
cases for it ask me about it afterwards
if you're interested what this in this
case all you really have is you can ask
the round environment for the root
elements so this isn't elements
annotated with something is just the
root element so this generally is going
to consist of top-level classes and
packages so what you want to then do is
start calling getting closed elements on
anything that you run into except for
the packages because if you call getting
closed elements on packages you're going
to get the same top-level elements that
you were also given before and not only
that but depending on the compiler you
may also get other elements in that
package that aren't even in the
compilation unit you're working on so if
you're if you're doing the thing that of
course we never should do but we
sometimes do where you've got one
project that has three classes in konbu
and then another project introduces a
few more processor would say up conduct
who's a package and you'd ask for the
classes and you get all five and you
probably don't want to do that because
there's nothing more frustrating than
seeing your build break on a library
class another reason you might want to
ask for the round environment is if for
some reason the compiler is having
problems noticing certain inherited
annotations and this is actually an
issue that I've run into with eclipse
and will be filing a bug report just as
soon as I have a spare moment some some
random advice you can ask an element for
its values but if it's an annotation
that has default values you're only
going to get the values that are
actually declared on the element and
then you'd have to sort of know oh well
yeah if the value wasn't present then it
was a default value now if the default
value is empty string okay fine but in
general if the default value is
non-trivial I would reckon
men using the element utils class and
its method get' element values with
defaults that just fills in the default
values for you makes life easier
similarly if you're looking for
inherited annotations on a class and not
annotation not just annotations directly
present so remember an inherit or if you
don't remember I'll tell you an
inherited annotation is an annotation
that is annotated with the annotation
inherited or you can just think of it as
an inherited annotation and not worry
about the meta annotations
don't worry inherited has some
annotations on it too so anyway you can
call get all annotation mirrors and that
will give you not just what's currently
on the element but what's on the parents
as well as I mentioned the class path
that your class loader that your
annotation processor is running under is
guaranteed to include your annotation
processors jar it is not guaranteed to
conclude and include everything else on
the build path at least again in Eclipse
this may be an eclipse bug again but but
Eclipse does things differently they
actually ask you to tell you that they
asked you what exactly is on your class
path and one reason I could see for this
your annotation processing class path
one reason for this may be that since
the Eclipse Java compiler is running in
Eclipse
not in some separated thread as far as I
understand it that means that really
nasty classes in your annotation
processing class path could cause
problems in Eclipse itself and that's
probably not good so I suspect that's
why they do it differently if you're
dealing with inner classes just pay
attention to what format the class name
is you have binary names and qualified
names a one is a dot B the other is a
dollar B if you're running into this
problem you'll recognize it pretty
quickly and just just pay attention to
it in fact if anyone saw the type
checkers talk a couple days ago you'll
learn one or two days ago there was
actually a type checker they had which
allows you to distinguish between these
two types of class names which could be
useful and finally as I mentioned
earlier if you have to grab any declared
types using the element utils get me the
element named this and then get a type
from that do that in the init method so
you do it once and
set up for every single class you
process or every single annotation you
process sample code I told you there
would be sample code and there is it's
on github my github account is I
Robertson and there's not that many
packages under it but the one you're
looking for for what it's worth is JP a
annotation processor so I will leave
this slide up after just a second but
first I'm going to ignore annoy all the
people taking pictures because I worked
hard on this last slide and now put you
back to the slide that you might care
about
but with that thank you and are there
any questions yes that's it so the
question is supported source version how
does that work as far as backwards
compatibility that sort of confused me
and and the answer is supported source
version how does that work with
backwards compatibility kind of confuses
me too I haven't really had occasion to
look into it but my understanding is
that if you try to and I've not tested
this unfortunately but I believe that if
you try to run an annotation processor
with a supported verse source version
say of seven but your compiler is six
then then your compiler is going to
complain I believe that's what it refers
to is there anyone in the audience that
can tell and tell me Joe what'swhat's
the Joe Darcy actually knows this stuff
far better than than I do and he's going
to answer this question now material
thank you
the way supported source version works
is that when we were creating the API we
knew we'd have new version to the
language so the basic problem is if you
wrote your annotation processor for Java
SE six and then in seven or eight you
have new kinds of objects so what should
happen right say in JDK 8 we have
instead of just type element and package
element a module element so how should
your JDK 6 annotation processor handle a
module element in general there's no one
right solution kind of
with your processors doing so we created
a number of hooks in the API to support
this sort of situation and to allow the
processor that you write and the
visitors you write to deal with this so
if you look in the visited interface you
sees only visit unknown that's related
to that so the reason there is a
declared source version for the
processor so the processing environment
can look at that and tell you what to do
so for instance in the java c
implementation in JDK 7 if you're
running a processor which only supports
version 6 in JDK 7 Java C will warn you
if you're setting the source version to
7 the environment you're running in is
version 7 but you only support version 6
this might be a problem because you
might start getting these unknown
element exceptions from your processors
so it's really a tip so that the
compilation environment can let you know
that your processors are out of date and
there are other mechanisms in the API to
let the processors handle newer source
versions in their control way yes the
unit test um
not easily so the question was going to
show the unit test code and and
unfortunately not easily because while
it's easy to say oh just wrap your
processor and then you use the standard
compiler environment and so forth that's
a lot of lines of code however that is
part of the github project so if you
check out the github project you can you
can see all of that and that's a
complete running example pardon I will
put the slides on github as well as
giving them to Fred back here who will
put them on Oracle's site yes yes have I
run into
where the processor in maven behaved
differently than the one in Eclipse and
by the processor in maven generally we
mean Java C uh the answer is yes the the
eclipta processor can be a little bit
more finicky so a couple specific
examples I've run into one is that if I
just say run my processor over only
things annotated with this annotation
and the annotation in question is an
inherited annotation Eclipse won't fire
on it for classes that are inherited
annotated at the moment so that's one
difference another difference is that
the Eclipse processor so in Eclipse
again you have to explicitly tell it
which processors to run and if you're
not careful in your processor depends on
another library eclipse won't pull that
in unless unless you pull that in as
well so that's that's an additional
challenge there yes why would you want
to do annotation processing at the
package level well for the same reason
you'd want to annotate at the package
level so for example JP a you you there
are certain annotations you can put on
your package declaring types and so
forth and and you may want to do some
checking on that to verify you know okay
hey I declared a new persistence type
that refers to a class name I wonder if
that you know exists yes oh you so the
question is any use cases outside of JP
a yes in fact this JP a example was
written just for this talk the the use
case that we've had at overstock is we
have various annotations to aid and
service discovery and when you might
have one annotation saying okay look
there will be someone providing this
service and another annotation saying
I'm the provider for this service well
if you're a service provider you should
have an argument constructor for example
if you say you're the provider for
another service that service should be
of a type that you implement so there's
various and we found in fact that there
were enough of these kinds of things
that we wanted to do or maybe you want
to annotate something as a event
subscriber well then it better implement
the appropriate interface and we found
there were enough of those that what we
actually did was wrote
meta annotation processor what it does
is it looks for annotations that are
annotated with yet another annotation
that says what the meaning of this
annotation should be from a checking
point of view plan on open sourcing that
sometime soon have not been able to get
to that quite yet so the question is are
there any patterns or anti-patterns
beyond the ones that I've listed sort of
in the advice section I can't think of
any off the top of my head you know the
the visitor pattern is of course one
that's designed and as joe said you know
the the visitor pattern has some nice
things like what to do in the event that
you're dealing with an element that you
didn't even know existed at the time and
and and some other things uh but what
i've found is while in general that can
be useful in specific cases it may not
be use one pattern I will mention if the
annotation that you want to look at does
not necessarily is not necessarily going
to be on your class path at the time
that your processor is running one thing
you can do is you can go through and as
you need it you can say ok get me the
executable elements and now give me the
one that's corresponding to this and and
and what the value is for that yada yada
it improves sanity greatly to just
create a mirror class referencing that
annotation so you can just ask the
mirror class for its values and that you
by the way you also may need to do that
if you're writing a processor which
works over classes excuse me which deals
with annotations where one or more of
the annotation attributes is of type
class because those values if you ask
for get value on that you'll almost
certainly run into trouble you'll get a
type mirror exception I believe and
basically what the what it's trying to
do if it just tries to say well get you
know I had the companion class method
example that I had get companion class
so if I call companion class and it
refers to a class that's not in my class
loader but companion class is declared
to turn something of return something of
type class it can't and so all I can do
is throw an exception so a better
strategy in that case is to set up a
mirror that when you
asked for the companion classes instead
of or a companion class instead of
giving you an exception it gives you a
tight mirror or an element mirrored as
you find appropriate
can you write annotation processors that
will effectively wrap calls into a
method not legally so Wambach does this
and and the way Lombok does it is by it
digs down into the processor internals
into the compiler internals so it says
all right if I'm running Java C let me
dig down into the ast and let me modify
it and write out a different class file
then you would normally write out for
this Java code oh but maybe I'm not
running Java C maybe I'm running Eclipse
well then let me dig into its ast which
is completely different and it's able to
extract some commonalities out with a
facade but not everything so basically
they have to do everything they do twice
and the only reason they only have to do
it twice is because no one's written the
third Java compiler yet
that people use so yeah in in short uh
it's not something that's legal and even
even if there were an API for this the
the annotation processor spec says you
really are not supposed to do that
a more common pattern is if you want to
do something like that maybe what you do
is you have your processor generate a
class which extends your class and cause
super uh but wrapped in some fashion on
the method that you want to use and then
you make sure your your clients use the
generating class inside of that class so
there's some tricks that sort of get you
there but you can't do general aspect
oriented programming that way per spec
yes
are there any third-party annotation
processing libraries for the most common
cases not that I am aware of if anyone
else is aware of they should speak up
yes
okay so when this was when I was asking
for the I was looking for the child
property excuse me the parent property
in the child element so in other words
the get parent method and it needed to
be annotated with what many to 1 and so
I just said hey element get annotation
many to one class that'll break if many
to one is not on your compiled class
path and in fact I made that change at
one point and then it all worked fine
from the command line but then in
Eclipse I had then add the JPA library
to the annotation processing class path
before that would actually run so that
that was the the that was the cheat and
now you know why the cheat is a cheat it
and maybe it's not a cheat I'm not sure
if the eclipse processor is to spec or
not in that regard yeah under compiler
options there's annotation processing
you to enable it and under that there is
annotation processor factories or
something it's a sub thing and then you
can you can add jars if you're running
with maven I believe there is an mtoui
plug-in that will do this for you
although I don't know whether it's going
to add all the dependent libraries if
there are any so there there could still
be some challenges there alright there
are no other questions we are over time
in any event so thank you all for coming
out on a day when you should be trying
to get to the airport and not miss your
flights</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>