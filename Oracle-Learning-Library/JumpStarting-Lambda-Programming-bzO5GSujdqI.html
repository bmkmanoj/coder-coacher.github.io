<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Jump-Starting Lambda Programming | Coder Coacher - Coaching Coders</title><meta content="Jump-Starting Lambda Programming - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Jump-Starting Lambda Programming</b></h2><h5 class="post__date">2013-02-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/bzO5GSujdqI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Stuart marks I work on the
core libraries team the JDK group along
with my colleague mic'd we go up here in
the front row we prepared a presentation
called jump-starting lamda and if you've
if you've seen any the presentations on
lamda by Brian gets he is a real
information firehose and so this in
contrast to his talks this is a much
more gentle introduction to lamda so
start out by talking about what what
lamda is just a basic conceptual
definition essentially it's an anonymous
function and what it allows you to do is
to treat code as data and the impact
this will have on your programs is that
it will allow you to parameterize
behavior now if you look at Java the
programming language as it is today that
is in Java Java seven you can have
values and types as parameters and so
lambda is being added it's programming
programming language feature in Java 8
and it allows you to parameterize
behavior as well as those other things
it also provides closures and there's a
considerable history and discussion
about what closures are and the closure
properties actually we are not going to
cover the closure properties of lambdas
today I think that the parameterization
of behaviors is what we'll be
emphasizing and how that can how that
affects the way you can write programs
so lambda is not just a programming
language change we are also making
changes to the JVM and to the class
libraries and so when we combine all of
these together it really enables a very
different programming style from what
we've seen before in Java it's it's
flexible it's higher productivity some
some people might describe it as being a
fluent style of programming I'll show
you some examples of that it's useful
both for simple everyday programming
tasks as well as for heavy lifting you
know writing highly parallel writing
highly parallel programs so it really
hits across a very very broad range
of programming tasks all right so I am
NOT going to be describing the nuts and
bolts syntax of lambda or the very
semantics or what it means to capture
variables instead what I'm going to do
is first start off by talking about an
example program and explore some
techniques about how we can change that
example program around and program it in
different ways and once we've set things
up we can see how we can apply lambda
and the new lambda based library api's
to improve this program and again like I
said this the example I show is actually
quite simple but you can see how how
radically it's transformed by the
application of lambda and lambda based
api's all right so let's just dive right
into the example let's take the quick
overview the example is we'll have a
person object I think every example in
this in this conference uses a person
object we'll also be using a collection
of person objects like a list I think
everybody should be familiar with those
one of the things that we do on lists of
objects is to run through a list and
select some of them so our person object
has a few attributes on it like age and
sex and so we'll be doing that and we
will also be performing operations that
use person objects and the example I'll
be using a lot is perhaps you might be
familiar with this phenomenon of large
companies will get lists of phone
numbers and make automated recorded
phone calls to them so I'll just call
those robo calls and so that's the
that's the example application I will be
using today all right so this is our
canonical example object it's a class
person and it has some some pretty
pretty basic stuff in it get age get sex
get phone number again email get postal
address and it returns value types based
on those sometimes primitives sometimes
other kinds of objects very
straightforward stuff all right now
suppose we wanted to write a program
where we had we had a bunch of persons
we could get from somewhere and we
wanted to make a robo call to every
single person all right the first thing
we'll get a list of persons so that's
what the gathered persons method doesn't
returns a list of person then we use our
standard enhanced for loop in Java for
each person in that list we get the
phone number from that person and then
we call a robo call method on that phone
number pretty simple I mean this is I
mean that simple
should be quite obvious what this does
now let's talk about some use cases that
we want to employ to enhance this
program
all right so sometimes you don't are
quite often you don't want to robo call
every single person instead you want to
robocall a list of persons based on some
criteria for instance in California the
age at which a person becomes eligible
to have a driver's license is 16 so if
we want a robocall all the people who
are eligible to drive then we're not
going to call anybody younger than that
age in the United States the voting age
is 18 so if we want to I mean this is
the season to do it I mean I don't know
how many those of you to live in the
United States you've gotten a lot of
these robo calls for eligible voters and
so you're not gonna call anybody who's
who's who's younger than 18 to do that
now in the state of California the
drinking age is different from the
voting age you have to be 21 to drink
and so if you're if you want to
advertise your latest liquor or cocktail
or something you might want to place
robo calls to a different set of persons
okay pretty simple use cases here just
run through the list and select persons
by age so here is some example code that
robocalls eligible drivers and so you
can see it's quite similar to the
previous one except we've inserted and
if conditional and we get the age of the
person and test to see whether the
person's age is greater than or equal to
16 and only if that's true do we go
ahead get the phone number and then
place a robo call to that person
alright I'm gonna go through this pretty
fast this is really simple if you want
to call eligible voters okay it's kind
of the same thing you say get age
greater than 18 do the same thing and if
you want to call the persons of legal
drinking age get age greater than 20 -
okay right so if you ever see this kind
of code replicated in the code base you
might think that there is there's a
problem right and so a typical problem
is to have cut and paste code where you
basically replicate the same boilerplate
code but make some little tweak inside
and generally we don't like to do this
and so what we're going to do is
introduce parameterization of values now
this this should be very obvious to
everyone but this is kind of this is
review but the point here is we're going
to extract some common code and
parameterize it to be used for all those
three different use cases again very
simple stuff but I just want to set this
up for review so what does this do we
get our list we go through every person
in the list and now we have an age
parameter so instead of a constant being
buried inside the method we pass it in
as a parameter and then we get the
person's age and test that against the
parameter that has been passed in it
should be quite straightforward
now how do we how do we use this new
parameterised method well we can rewrite
those previous three methods and simply
call our common method and pass it a
different parameter each time 16 18 and
21 all right pretty cool pretty good
let's add some more use cases in the
United States I believe the regulation
is that commercial pilots have a
mandatory require retirement age of 65
so something different is going on here
we don't want to test for greater than
or equal to 65 we actually want to if we
want to select all the people who are
eligible to be pilots we actually have
to do a less than comparison so okay so
we can't just pass in 65 because that
won't work so we want to pass in some
different values to the
method to say hmm okay so instead of
testing greater than age 16 we want to
test for less than 65 well that's just a
boolean so let's try it boolean okay so
now we've added a parameter here and it
has an age limit and a parameter that
says oh okay if it's if it's true we
want to test less than but if it's false
we're going to test greater than or
equal to okay so and it took me a couple
tries to write this logic correctly I
means this the same basic logic step
through the list if there's a you know
under the right conditions combined with
this boolean only then go ahead and make
the robocall but I have to say I failed
I did not write a unit test for this but
you know I balled it for a while and I
said no I think that's right okay so but
so this this gives us sort of
parameterization over over the operation
of of less than or greater or equal okay
so now if we move to code that calls it
okay we can rewrite those previous
functions as okay robocall persons with
the age limit 16 false
okay so false means we want to do a
greater than or equal to test okay and
then okay and then so it's the same for
voters drinkers okay now for pilots we
want to do the opposite test we want to
test less than 65 so we'll pass a true
instead I don't want you I think this
sucks
all right okay so let's rewrite it but
also we've learned a little bit too it
turns out that there is a minimum age
for commercial pilots in the United
States as well as a mandatory retirement
age so let's throw that into the mix as
well so there's a minimum age of 23 and
a maximum age of actually well the
mandatory retirement age is 65 okay so
what can we do here let's use an age
range all right so here's you know this
this is this is okay this is a little
nicer okay so we pass in an age range to
integers low and high and we say okay
low is less than that we get the age if
it's low is less than or equal to and
notice notice that this is a half open
interval as is typical like with with
Java like lists of ranges but basically
okay so this is this is nicer it
certainly makes more sense to read when
you are reading this implementation now
how do we use this thing okay so we have
to we have to do a little bit of a
special case here for eligible drivers
it's anybody over 16 so we don't have an
upper end of the range so okay well
integer dot max value is I think you
know that's probably a safe special case
I don't think anybody is ever gonna be
two billion years old so let's just
substitute that in so we'll use that for
drivers voters and drinkers and then of
course when we get to pilots you say aha
okay so now we specify the half-open
range of 23 comma 65 all right good
we're rolling now
okay so let's throw in another use case
in the United States the National
Service Program otherwise known as the
draft is called the United States
Selective Service and it takes people in
the age range from 18 to 25 inclusive
all right so we might be tempted to
write this program or we say oh it just
passed the age range of 18 to 26 okay a
little bit of a special case there
because this is a half open interval so
the eligibility goes through and
including age 25 so we got to add one to
make sure our half open interval right
okay little little bit of wrinkle there
not too bad except that it's wrong the
Selective Service takes men
only alright so let's rewrite this okay
okay not only do we need an age range
but let's let's add another parameter
that says what the sex of the person
that we're interested in okay so we can
we can imagine adding a third parameter
okay so we have a an enumeration and you
know Noom sex male/female and we just
pass in male and that will you know we
can imagine I'm not going to go through
all the code it's getting kind of
ridiculous here but you can imagine it
tests for if the sex matches then you
know only robocall that person but but
what about all those other use cases
right we wanted to catch all eligible
drivers regardless of whether they're
male or female so I know let's add a
don't care you new to this value too
okay well that's kind of silly because
it works for queries right so I can say
I want to select Ben or I want to select
women are I want to SEC to either select
either but of course if you have a
person value now don't care is a legal
sex value for a person object and that's
that's wrong we can use null nulls can
be enum but if you've ever had a
nullpointerexception in your program you
have to now you've introduced you're
introducing more complexity into your
program okay well sometimes null is
legal here but null is not legal for sex
in a person object so now different uses
of this Enuma sex are allowed to be null
and some are not allowed to be null okay
so so a lot of stuff is going on here
so what's happening is that value
parameterization of course is extremely
useful right when we when we learn how
to define methods and pass parameters to
them it's it's the bread and butter of
java programming and so certainly
certainly we couldn't do without it but
the kind of information that i've been
talking about in these examples is what
I would call meta information and so the
example here is that if we're querying
sometimes you don't care about a
particular value and the difficulty is
that if you have a value space like sex
being male or female
where does don't care fit and the
general problem is that in many cases
you have to find and
way to pass the meta information in band
that is inside the value so if you have
an integer you know for ages okay so so
clearly an age you know nobody's gonna
be you know age nobody's age is gonna be
outside the range you know zero to 120
or so so you could use you know max no
integer non max value zero minus one
actually zero might be valued valid but
you'd use negative numbers and that
would pass in band information in that
value and you write some tests in your
code that said okay this is a special
case if this isn't really an age this
means the query function doesn't care
about age okay so you have to put that
special case in your code problem comes
in when you you have a value space where
every value is potentially legal and you
you can't find a special case value to
do something like that that with so you
know you can imagine okay so add I had
another parameter to the method that
says you know another boolean or
something okay
I'm query on again it's on sex I'm
querying on age I'm querying on the
upper bound of the range I'm querying on
the lower bound of the range right and
so what's happening is even in this
simple example if we throw a few more
use cases at it you can start to see the
need to have something that just passing
value parameters is no longer capable of
supporting so it's like we need a query
language or something like that so
instead what I want to introduce right
now is this notion of parameterizing
behavior instead of values so values
have kind of run out of steam and so
actually if you if you think back to
that pilot example ice there was a hint
of it there which is sometimes you want
to test was it less than it well doesn't
really matter less than or equal
sometimes you want to test less than
sometimes you want to test greater than
or equal to what you really want to do
be nice if you could just kind of pass
that operation in as a piece of behavior
instead of just passing values in all
right so I'm going to show you how to do
that but before we do I want to talk
about functions
and this is going to be setup for how to
pass behavior because the way we passed
behavior is as functions but Java really
the notion of functions is a little bit
foreign to the java programming language
as it stands in java 7 and earlier but i
want to talk about functions of the in
the abstract for a moment right here the
we have a few examples of different
kinds of functions the main point is
that a function is a piece of
computation that takes some parameters
and it returns some values and the way
things end up being embodied in Java
there is usually at most one return
value and that's that's sufficient for
many many things and so we'll limit
ourselves to that case here but I'm
going to introduce a notation here which
is an arrow with the left-hand side of
the arrow being the parameters to the
function that and not only that the
types of the parameters to the function
and the right-hand side of the arrow
being the type of the value that's
returned from the function so I want to
stress again that this is a notation
this is not our programming language
just yet so anyway so this first example
here we have int comma int arrow int
alright so what kind of function takes
two intz and returns an int well
addition write a plus B we'll see all
right so we can pass in you know pass in
two in values add them together and that
function returns returns another int
okay so let's think about a function
that takes a string as a parameter and
returns an int string dot length in this
example of that okay so given a string
we find its length it returns an int
alright so now this third example is
something that's application-specific we
have person we have a funky one a
function that takes a person and returns
a boolean and in fact we've seen several
examples of this already in this
presentation so let's let's rewrite
those as standalone functions
okay so these are examples of functions
that that go from person to a boolean so
we say check if person's elbows drive it
takes a person object as a as a
parameter and gets calls P get age on it
and then does a test against our little
value 16 and that expression evaluates
through boolean and that's the return
value from this function so and then
same with eligible vote and eligible to
drink pretty simple
now it turns out it's much easier to
write those other more complex criteria
in in this in this style so we can see
if person is eligible to be pilot we say
ah forget Oh left out some parentheses
there all right if the age is greater
than or equal to 23 and the age is less
than 65 right so that's the criterion
right there so we just write that so no
no passing a boolean a special case or
anything like that and then also
eligibility for selective service okay
we have the person we get the sex make
sure that the sex of the person is male
and we also do an age range check and we
can do an age range in a way that is
natural for this computation right so
the range is from 18 to 25 inclusive so
we can write our expression that way so
we don't have to so notice already there
are there are as many special cases here
we're writing code that makes sense okay
so these are examples of functions in
Java in fact these are functions I mean
you can you can write these today
there's nothing special about these now
how do we pass a function as a parameter
in Java okay so probably many of you are
familiar with this there are already a
handful of cases like this already
around the class libraries in this case
we can consider a runnable to be a
function well there's a there's a
runnable interface and it defines a
method run which takes no parameters and
returns void and what we want when you
create a new thread you know that thread
needs to do something you can't just
pass the thread values and it just
doesn't sit there what you want to do
essentially if you rethink what
what threading is you want to create a
thread and tell it hey painting thread I
want you to execute this function for me
independently of you know you know in a
separate thread of control
that's what this is all about so
runnable in his exam is an example of a
function and it exists today in fact
it's existed from I guess they won in
Java so what does it look like if we
recast runnable in this in this new new
kind of vocabulary reusing here all
right so here if we rewrite it in this
notation we'll use an empty pair of
parentheses to represent no arguments
and then an arrow and then void so this
is a function so runnable is a function
that takes no arguments returns void and
you see the interface definition of
runnable here this is I mean this is not
new right so public void run no
arguments so this kind of interface the
style of interface turns out to be
extremely important for what we're doing
and so things are important we give them
special names so we are calling this
kind of interface a functional interface
and the importance here is that it is an
interface with a single method now their
interface is all over the system and you
know if you implement an interface you
have to implement every single one of
the method signatures defined in that
interface but there are some special
cases that turn out to be very very
useful where an interface has exactly
one interface all right one method
defined on it so we are going to call
those functional interfaces because then
we can say there's there's a blending
between the the method in the interface
and the interface itself so we can we
can call that function we we can call
this a function and name it by its
interface all right so let's go back to
our person arrow boolean example so I'm
introducing a special term here which is
a predicate and it turns out that it is
such a common case where we have a where
we want to have a function that takes an
object and returns a boolean that we
give it a special name predicate so here
we can those those examples where where
we
did the testing of a person we can write
an interface that describes that kind of
method it's a functional interface so it
has a single method on it and that
method is test person takes a person as
a parameter and returns of the Lyne okay
and so all of those all of those methods
we saw a few slides ago conform to this
interface but since this notion of a
predicate is so common we're going to
introduce some type parameterization
here and say let's this this person
object was application specific but in
order to be fully general we can say
let's talk about a predicate as taking
an object of any type T and doing some
evaluation on it and then returning
boolean so that's what we have here we
have an interface type predicate of T
and it has a single method so it's a
functional interface and that takes an
object of any type T and returns a
returns a boolean from that all right
now let's rewrite our robocall example
so that it uses a predicate that was
passed in as a parameter some set of age
ranges and boolean special cases and
stuff let's have the caller pass in a
predicate and say this is how we want to
parameterize the Robo call method and
notice I've renamed it here so it's not
Robo call well Robo call matching person
so so and the point of matching is
whoever is matched depends on the
definition of the predicate that is
passed in so once again you can see this
is basically the same stuff get the list
for each person in the list now in order
to use this function parameter it's I
mean it's an interface in an interface
has a method on it and we have a
reference to an object of an interface
so we call pred dot test and we pass the
person object as a parameter and it
returns us a boolean so we stick that in
our if statement and you know proceed
with our processing as usual okay now
what does this look like on the other
side
okay all right so instead of a couple
simple values now what we have to do is
we have to we can't just pass a bear
method as at least not yet we can't pass
a bear method as as a parameter in Java
and so in Java 7 and earlier what we can
only do is pass instances of objects so
what we have to do is create an
anonymous inner class which is a
subclass of predicate we supply person
as the value of the type parameter and
then we override the test method to say
okay so we want to test for eligible
drivers so we say P get age greater than
greater than or equal to 16 and we wrap
all that stuff inside an inner class and
what an anonymous class declaration and
instantiation what we get back from that
is a reference to an instance of this
anonymous class and then that's what
gets passed to robocall matching persons
okay so now we have this nicely
parameterised robocall matching person's
parameter it's parameters by
parameterised by behavior now but what
we've done is we've pushed out to the
caller this stuff right so now now we
want to find the voters we've changed
the 16 to 18 in here so I'm gonna hit
the next slide right now and the 18
change is 21 so it's very subtle only
two characters well actually that I
changed the name but in the body of that
red stuff they're only a couple
characters changed and we can rewrite
our examples once again we can create a
instead of coming up with named methods
that say you know fine you know test
test person for being you know eligible
pilot we can create anonymous subclass
of predicate of person and override the
test method and put whatever test we
want inside of that so here you can see
the same logic testing the age range
from 23 to 65 and then for selective
service we do the same thing we add the
additional tests here you know it's the
same logic we talked about this before
all right so maybe you're reacting to
this this is very powerful being able to
parameterize behavior but it's really
painful and so having to add all that
boilerplate for anonymous donors inter
classes and stuff it's it's pretty
difficult that's a lot of typing and the
fact is there's so much typing and so
much goop there that people don't do
this as often as they could so that's a
real problem so let's revisit one of
these examples all right so this is the
same code again
robocall eligible drivers we call our
matching persons method the meat of this
of this method is P get age greater than
or equal to 16 now contrast that to the
amount of boilerplate in this method
right so we say new predicate person Bob
public boolean test blah blah right and
so if you overheard Brian Getz's keynote
talk he talked about the beef to bun
ratio so the beef to bun ratio is very
low right because there's all this
boilerplate here that is just
surrounding this little bit of logic
here which is get age compared to 16 so
now let's climb out on a limb here and
erase that boilerplate and I very
cleverly changed the return to an arrow
here and if you watch carefully we have
just created our first lambda expression
all right what's happening here so the
syntax of lambda is patterned after that
functional notation that we talked about
earlier there's an arrow the left hand
side of that arrow is a set of
parameters and on the right hand side is
the body of the lambda that we evaluated
returns a value of the type that you
want and so one key point here is that
when you write a lambda expression in
Java 8 it is converted to an instance of
a functional interface so we talked
about functional interfaces before like
runnable and we introduced a new one
called predicate so this gets converted
into an instance of the predicate
functional interface
all right what happened to the types
okay so there's some interesting stuff
going on here right so how does how is
this legal if we haven't declared what
type P is and you know you can you know
we kind of know that it's a person
because that's what we intended but but
how does how does the program know okay
so if we go look at the signature of the
Robo call matching persons method it
takes a single argument that takes a
single parameter whose type is predicate
of person so let's call that the target
type okay so the target that interface
that's a functional interface it has a
single method it's defined to have a
test method that takes a boolean and
return sorry it takes a person and
returns a boolean okay so if we rewrite
that in our notation its person arrow
boolean and look at that so we take that
notation and apply it to the lambda and
the compiler the compiler actually does
this and the copilot the process
compiler goes through a process called
type inference to figure out what the
type of P has to be in order for this to
work so that's how the compiler
determines that person excuse me that P
is a parameter of type person and then
it looks on the right-hand side of the
arrow parses that and checks to make
sure that that expression evaluates to
boolean all right so one one key point
here is that we are not introducing
dynamic typing to Java Java is still a
statically typed language it's just that
the compiler is doing more work for you
so that you don't have to type the type
names of everything when you declare
when you declare variables all right
we're gonna rewrite our functions again
and so instead of passing inner classes
we are going to rewrite these in terms
of lambda so we call robocall matching
persons and we say Piero P get age
greater than or equal to 16 all right so
there's there's our beef right there and
the bun is mostly gone so then you can
see voters it's the same things have to
be right 18 and drinkers is 21
and again continuing further with our
examples the test for pilots it's right
there we have a logic test ranging age
range from 23 to 65 and our selective
service candidates right there all right
so I'm going to press harder on how we
can use lambda in this method okay so
you might think that okay robocalling is
good and i guess it's a big industry and
people do it so and if they didn't make
money on it they wouldn't do it but
there's lots of other things they can do
as well so so we have some logic here
that that gets a list of people does
some selection on them and oh sorry
before I get into this right so we
rewrote our callers using lambda but but
our robocall matching person's method is
still the same so even though we're
passing in the lambda here as far as the
colleague is concerned this is still an
instance of a functional interface and
so since it's an interface as method on
it we just call that red dot test method
on it so as far as the implementation
that's consuming lambdas is concerned
it's it's the same so what we did is we
made things much more convenient for the
caller okay so let's get back to Robo
calling all right so okay so Robo
calling is good we have some logic that
runs that gets a list of people selects
them according to some criteria that we
can now parameterize using lambda what
if we want to do something different
like send them a text message instead of
Robo calling all right so let's try to
parameterize this behavior so if we look
at the Robo call and text message
methods those also look like functions
and they can be described in terms of
functional interfaces so in this case
this is a function that takes a phone
number and returns void well like we did
before it's not that useful to have
application specific interfaces so what
we intend to do is provide a interface
that takes an object of any type T
and returns a void and we're calling
that a block and just a block because it
contains a block of code and so the idea
is you call the apply method on some
object and it executes some code using
that as a parameter okay so let's go
back and refactor our refactor our
example to use our new block functional
interface
okay so we've added a parameter to this
method that takes a block of phone
number and we call the block dot apply
method on it and pass it the phone
number that we got out of the person
okay good enough now what does this look
like on the calling side okay so before
we had one lambda expression as a
parameter and so we've added a second
one so here it is numb arrow braces
robocall numb or text message numb so
this is a different kind of lambda here
we're calling this a statement lambda so
it says it has braces on it it's it's
like an ordinary block of code in Java
you're gonna have multiple statements
and in this case it returns no value and
if you recall the functional interface
was defined as returning void you can
also have a statement lambda that
returns a value you just have to put a
return statement in it so it's a pretty
ordinary block of code okay
let's press harder on this there's this
thing in the middle where we we take a
person and we we call something on it
and we get a phone number out of the
person what kind of function is that so
we're calling that a mapper and this
comes this term comes from set theory if
you have two sets you can think of a
function that map's the element of this
set to an element of this set that's
where this comes from
in fact it's the same place that the map
data structure came from but this is not
a data structure this is the concept of
a mapping from one set of values to
another set of values so what do we have
here we have a mapper function that
takes a person and returns a phone
number once again we make a generic and
from any type T to any type you and so
the functional interface for mapper is
map or T comma U and once again there's
a single method defined on it it takes
an object of any type T and it returns
an object of some other type u alright
let's look apply that to our processing
function here we'll add a third
functional interface parameter here that
takes a mapper from person to phone
number and then instead of calling get
phone number what we do here is in the
middle we have a person in order to get
to the phone number we call the the
mappers map function we pass it the
person and it returns us a phone number
and once it once again if we pop over to
the calling side we'll pass in a lambda
expression now in this case if we want
to do robo calls it's actually illegal
to do robo calls to a at least the last
time I checked it's illegal to do robo
calls to a cellphone so at least in the
United States so so the mapper for robo
calls is going to get the home phone
number of of the person and then pass
that along to the Robo calling function
and if we want to send a text message
aha okay so we'll get the mobile phone
number and so notice already we're
making good use of being able to
parameterize the behavior of this person
of this process matching person's method
and also notice that the the name of
this method is getting more generic as
we go along because so much of it is
heavily parameterize there's less
specific I mean it's no longer robo call
eligible drivers it's something process
matching persons I mean what what could
be what could be more generic than that
all right so I'm going to do a little
bit of refactoring here and this is
ordinary cleanup but just to just to
make the examples run a little more
smoothly when we started off the example
it had a it had a function or at a
method call to gather persons that just
returned a list I'm going to apply a
value parameterization here and have
have the caller pass in a list but
something interesting is going on here
the only thing we do with this list is
iterate over it using the enhanced
for-loop
and so the only demand that the enhanced
for-loop has over what you pass into it
is that that thing you pass in be
iterable so there's a principle which
says define your interfaces according to
the the fewest requirements so what
we're going to do is change that
parameter to an interval so any iterable
that gets passed in here can be passed
to the enhanced for-loop
all right so so that's what that's what
it looks like now and then I'm gonna pop
back over to the caller side for a
moment and so so instead of passing well
so we've added a new parameter and we
just call it we can just call that same
gather persons method that returns a
list which immediately gets passed into
process matching persons all right so
let's dig into this process matching
persons thing what what is this really
doing right so I've highlighted some
code in red here where so so it's
getting it's getting some persons out of
some source and we don't care where they
came from it's applying some tests to
them we don't we don't care what the
test is our caller passed it in for us
we apply a mapper to to map from a
person to a phone number in this case
but basically an object of a different
type and then we take that result and we
apply a block of code to it so so let's
let's erase all of the boilerplate there
and and and talk about what's going on
we have a source of person objects we
filter and so filtering is the act of
you know screening things through a
predicate so basically you know when you
pass something through a filter only
some of the things pass through and the
rest are discarded so we have a source
of person objects we filter them through
a predicate we map each person object to
a phone number and then we apply a
function a block of code to each phone
number all right well you you can you
can make this even further generic all
right so you can think of taking a
source of an object of any type
filtering it through any predicate
mapping those resulting objects to
objects of a different type and then
applying those right so so what what is
the
really there's no logic in that process
matching person's thing anymore it's
just it's just it's just moving objects
around so if we if we step over into the
hand-wavy you know a block diagram
universe for a moment what we have is we
have a source of objects and we pass
them into a filter and those go through
a mapper and we at the very end we apply
we apply some function to the objects
that come out at the very end all right
well what do filters and mappers
actually do they well they don't know
what to do they have to have a parameter
passed to them that defines what they do
and that's what lambda does for us all
right so we so we're calling this like a
pipeline or a stream of objects because
we have a source of objects and there's
a there's this this idea of passing
streams of objects down a pipeline of
operations each operation of which is
parameterised by passing a lambda
expression to it okay well alright great
block diagrams wonderful can we really
program this way answer yes all right so
we're gonna rewrite our examples yet
again we're gonna start off by creating
a list using our gather persons methods
so we have a list now how do we turn
that into a source of objects at the
head of our pipeline well we're gonna
introduce a new method called stream and
that creates our source and what this
does is now we have there's a new type
in the in the class library called a
stream that represents a stream of
objects now notice or or values probably
more proper to think of this as a stream
of values this is distinct from me like
the input stream which is a stream of
bytes so think stream of values from now
on all right now we have a stream of
values we want to pass them through a
filter and so filter is a method that
takes a stream and returns a stream so
we can chain these up and then we can
call map another new method that takes a
stream and returns a stream and finally
at the very end of our pipeline we have
for each method that consumes the stream
of objects and terminates the pipeline
all right where do the lambdas come in
well those are parameters to those
functions so I'm going to fill those in
right now and so you can see we are
filtering this we take us we take a
stream of objects filter it through our
get age filter map each person object to
home phone number and then call the Robo
call block on it all right what is this
BIOS well this this gets us much more
flexibility in the things we can do into
rearranging the code for instance
there's a Do Not Call list out there so
what we can do is we can add another
filter and we can say okay well if it's
you know only let things through the
filter if they're not on the Do Not Call
list and notice think about how you
would have to do this too if if some
things if you go back to we had our if
statement nested within for loop well
you can certainly add another if
statement in there but what you really
wanted to do is only do that extra test
a certain number of time you know for
certain kinds of queries but not for
others try parameterizing that with
values that's really hard but here in
this new API we can just chain up
different operations to each other so we
need a new filter throw it in there all
right so I'm gonna just run through some
examples here pretty quickly all right
we want to get them you know we want to
send text messages to elbow drivers we
change our age test we change our mobile
phone number and call text message
instead of robocall another example is
we want to we want to send some spam
email to eligible drinkers right so we
you know we do the age test get the
email address and send an email to them
all right so we want to do something
what do we want to do we want to send we
want to send bulk mail to all of our
pilots right so it's again we're just
changing the lambda expressions in here
and so we do our age test get the postal
address and send bulk mail instead okay
so now we want to do something with
selective service candidates and so you
know again we just change things here
and you know get the home address and
then instead of sending a mail we send
an armory rudra to their house all right
now at the outset one of the big
promises of lambda is we can do things
in parallel how do we do this
all right so what I want to do is say
look look at how we created the stream
we said gather persons got us a list and
we turn that into a stream by calling
the stream method on it well by default
that stream is a sequential stream it
happens serially that is there's no
parallelism in and so things happen one
at a time in order all right now how do
we change it into parallel just change
that stream call to parallel call and so
now our pipeline runs in parallel so
this gives us a really easy entry into
writing parallel programs there are
couple considerations we have to we have
to think about here if you're writing a
parallel program now one of the things
we wanted to make sure is that
parallelism was not introduced
implicitly right if parallelism so is so
great why don't you make parallel stream
be the default well the problem is that
there are a lot of other things in the
java world that still are not thread
safe so if you want to write a parallel
stream it is actually pretty easy to do
so but you do have to be careful so let
me introduce what we're calling the
prime directive against non interference
the the different lambda expressions
must not have any side effects they must
not have side effects on the object they
must not have any side effects on the
source of the objects from which the the
objects are coming they must not have
any order dependencies right if you're
running multiple threads then you have
no control over what order things are
executed in but that's to be expected
you want to get parallel speed-up and
you don't want that control because you
want a bunch of things to happen at the
same time and if you do deal with any
data structures you have to make sure
that those data structures are
threatened safe that is they are capable
of of having multiple threads run
through them at the same time but anyway
given this we can take a this is our you
know this is our new proposed API for
Java eight you can take a stream of
operations and make it parallel so let
me recap some things here so I earlier
on I introduced this notion of
functional interfaces what I didn't say
and I want to say
everybody now is that as part of this
API we are defining a standard set of
functional interfaces that is going to
go into Java dot util
you to lot functions and so there a
bunch of them here I'm not going to go
through these all we've seen a few of
them we've seen we've seen block mapper
predicates unary operator and binary
operator are important ones and then I
think factories important one takes no
arguments and return something so anyway
so the point of having this this
repertoire of functional interfaces in
the library is that you can write lambda
expressions for things that take these
functional interfaces as parameters and
then the compiler will match these and
say uh-huh
okay this lambda looks like a binary
operator okay so that's so that's how we
get from lambda expressions to you know
into you know regular parts of your
program alright so now I don't want it
all so to recap quickly a bunch of
stream operations that we were adding
the example showed filter map and for
each there are a bunch of other things
you can do on stream objects again
they're tuning here to go through all at
once but there's some really useful ones
I think you can say you can you can drop
a tea into the middle of the pipeline
and that executes a block for every for
every object as it goes by but it passes
it through you can put a you can you can
say I want to make all the elements even
put unique elements as a pipeline
operation so that everything that comes
out has never been seen before so what
it does it's kind of a fancy filter it's
it's kind of a stateful filtering
operation that says oh I've seen this
one already just drop it you might do
some computations and stuff and you
might want to put put the results of
this stream into a collection or you
might want to convert it to an array so
there are a couple of things to do that
there are some lazy finding and testing
operations that we do suppose you have
an extremely large collection of
something and you say well I want to see
if there is any one place in here that
you know any one of the objects in here
satisfies some criterion and so well you
could run through it sequentially but
now that we have parallel pipelines you
can
okay get me a parallel pipeline and at
the end of the pipeline say you know
pass a predicate to any match and what
will happen is they'll fire off a bunch
of threads and you know run your
predicate on a bunch of them and as soon
as it finds the first one it'll roll
everything back and and return you a
boolean determining you know whether it
found something and then find first find
any are kind of the same except they
actually return the object that was
found that matched that predicate there
couple of higher-order functions here
like I'm not going to go through them
all because they really do require quite
a bit of explanation and I we don't have
that extra talk in here this year but I
will talk about reduce there's some very
powerful operators that we can employ
here but imagine if you have a stream of
numbers you might have a very large
number of very large quantity of numbers
a reduction operation takes a binary
operator and so an example that is
addition so imagine you have a very
large number of of numbers and you put
the plus operator in between each of
them and then the result of that entire
large expression is a you know is a
single value and so that's what reduce
does so for instance it's very easy to
say okay well I have I have some
pipeline that result results in a stream
of numbers and I want to I want to sum
it okay great
so you basically summation is reduction
over addition the advantage is that if
you're if your functions have the right
properties namely that they are
associative you can do all of this in
parallel so imagine trying to to write a
parallel version of a summation
reduction right so you'd have to go
through and fire off a bunch of threads
and gather things and join and so forth
framework does that for you okay so let
me recap here when we learned today was
that lambdas are anonymous functions and
they enable a new very powerful
construct in programming languages which
is parameterization of behavior lambdas
as they are cast in Java eight are
converted to instances of functional
interfaces and so functional interfaces
are
like normal interfaces except they have
one method and so you can call a lambda
simply by calling that method on the
functional interface that it gets
converted to there are two kinds of
lambdas their expression lambdas and
statement lambdas and one of the great
things about lambda is that the compiler
is doing a lot of work for you in type
inference so you don't have to type that
you don't have to put in you don't have
to have all the type names in your code
cluttering things up combined with this
new language feature we've adding a
bunch of api's we have streams of values
and pipeline operations that really make
your programming a lot more expressive
powerful and flexible and also enable
you to write parallel parallel programs
very easily alright so a few more
references for further information and
basically I was looking up other talks
and basically are all by Brian guts so
unfortunately Brian had to talks about
lambda that have already occurred in
this conference but I'm sure you can go
and get the slides and I think there's
some policy where you can get the
recording of them Brian has also given
previous talks one of them is at the JVM
language summit which was just a couple
months ago there's a link to that there
he also gave a talk at devoxx last year
these slides will be posted too in case
you need the links and there's also some
links to to various webpages lamda is an
open source project part of open JDK and
so it has an open JDK website the source
code for lambda has not yet been
integrated into JDK 8 but we have our
own repository off to the side that's
where it is binary drops of lambda are
available so you can download them and
run the gnu compiler and the new JVM and
the new class libraries and try out that
code that I showed on the previous
slides
I encourage you to do that and try it
out and see if it works and if it
doesn't work let us know because you
know that's how we find bugs and there
there are people out there who try that
out and they find bugs and it's like you
know hey I tried this out and it didn't
work am i doing something wrong no
you're not doing something wrong that's
a bug thank you and that's very very
useful at this stage because we are one
year away from JDK a chip the more bugs
we find now means the fewer bugs that
get
when we shipped the thing and finally
Maurice naphthalene has started an FAQ
on lambda and that's up there and it has
some very useful information for our for
all of you okay do you have any
questions for me now okay I think I
waved this guy off first earlier on
okay so the question was about type
inference for for expressions that might
might return things of different types
and so you know I think I think the way
things are now when you write an
expression it pretty definitely has to
return something of a particular type
there is some weakness in the type
inference like for instance the ternary
operator you know the question colon
operator you can actually have different
things on either side of the colon and
we don't handle that right now and it's
it's sort of questionable but there may
be some future work on that but but
basically right now expressions have to
have a definite type so a question over
here
okay the question was about well the
question was about mapper that ended up
calling you know person get phone number
and so that's an extra method call in
there and and yes in fact it does there
there is essentially a method call
overhead and so but method calls are
very fast and actually the the JVM
language summit talk that Brian gets
gave and which is has a large overlap
with the talk he gave this morning
talked about ways to optimize that so so
I think the main thing is that in
comparing this to the way you used to
have to write these programs you'd have
to create an anonymous inner class and
create a new instance of it every single
time you call it and so lambda not only
provides us a more concise syntax for
doing something similar to that but it
also provides a fast path where the VM
can optimize it so we have a lot of
optimization techniques using things
like invoke dynamic and spinning up byte
codes on the fly so yeah okay yeah so so
so anyways so so yeah there is some
there obviously is some overhead to
lambda but our aim is to make it as low
overhead as possible
so see right here aah-ha-aah okay the
question about is their size over the is
there control over the size of the
thread pool answer yes but not in this
API the reason is when you are writing
application code like this you do not
know where this application code is
going to be run and so what thank you
for raising that because I wanted to
mention this in the talk what the
parallel function does is use the
default thread pool or a thread pool
that has been configured into it via
injection by some framework that you
might happen to be running in now and so
right now I believe we have a prototype
of a default thread pool that reads some
system properties but the point is that
the configuration of the number of
threads and how many threads are
allocated to
particular application is something that
is a vastly different concern from the
writer of the application so what we
want to do is keep that kind of stuff
out of the API so we have our API for
writing applications and for
manipulating streams of objects and on
the other side the the framework guys
and we haven't done this yet Brian gets
in another talk got a question about
ejbs it's like well how do you do this
parallel stuff and ejbs
we don't know yet but what we want to do
is make sure that the EJB guys are gonna
tell us how to do that we don't want to
say oh yes we're gonna create five
threads and then that the EJB be guys
say you shouldn't have done that so
really this information about thread
pools and how many threads to use and
that kind of stuff has to come from
somewhere else so that's not done yet
but we're working on it all right I
think I think we're at the end of end of
our time here thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>