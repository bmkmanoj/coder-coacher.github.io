<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Real-World Strategies for Continuous Delivery with Maven and Jenkins | Coder Coacher - Coaching Coders</title><meta content="Real-World Strategies for Continuous Delivery with Maven and Jenkins - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Real-World Strategies for Continuous Delivery with Maven and Jenkins</b></h2><h5 class="post__date">2013-02-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/McTZtyb9M38" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">today or this morning I want to look at
continuous delivery and some techniques
that I've been using for continuous
delivery with maven in particular so
these it's real world techniques real
world tips nothing too theoretical or
fancy there it's really just a few ideas
and techniques that I've been using in
practice that you may find useful my
name is John smart I work in Sydney
Australia I do a lot of work in
continuous delivery continuous
integration test automation TDD or the
technical side of agile development and
as I may have mentioned today I want to
talk about continuous delivery so I'm
assuming if you're here you'll have some
vague idea of what continuous delivery
is yeah no no idea never heard of it so
continuous delivery is really quite
simple continuous delivery is about
getting interesting stuff in front of
your clients as fast as you possibly can
and why do you want to get it as fast as
you possibly can simply say that you
could have a faster feedback loop so if
you have ever used test-driven
development you'll know that the real
value in tester of and development is
not the fact that you're writing tests
it's a factor you get a really fast
turnaround in a really fast feedback
loop so you get an idea you see if it
you specify something that will prove
that it will work or not you see if it
works and you continue it's a very
productive way of working continuous
deliveries that on a macro scale to some
extent so it's really a an approach that
is all about feedback but there are a
lot of things that come into mind when
you talk about continuous delivery some
people will say ok it's a you have to
use a particular build tool or a
particular build pipeline tool or
continuous delivery tool some
people will talk about continuous
integration now if there is a
relationship obviously some people say
you'll need to use this automate this
particular testing tool some will say
you'll need to use automated deployment
might need to use a chef or puppet for
your automated deployments so continuous
delivery from my point of view it
involves a lot of that stuff but that's
not the essential element it's actually
more an attitude it's more a way of
thinking that enables you to put
business value in front of your
customers as fast as possible and as
smoothly as possible and it's frequently
as possible and from there you get to
you need tools to support the that
activity you need certain build pipeline
set up so you go to need automation
you're going to need to automate your
deployment process you're going to need
all that but a particular tool is not
continuous deliver a continuous delivery
is the approach that you're trying to
implement so when you're talking about
putting value in front of customers so
my wife's a medical physicist so what
they do is basically they figure out for
cancer patients how much radiation or
actually how to deliver a certain dose
of radiation into a particular area of
the body now if you're to apply
continuous delivery in that scenario for
a new piece of software in the medical
industry I wonder if it would work so
you say okay this week guys we're going
to deliver a feature you can deliver
radiation to any point in the body but
the dose the actual dosage is fixed yeah
sure they'd be real doctors would be
really happy with that see continuous
delivery is not necessarily about
delivering a working a fully functional
piece of software ever at every release
you can also depending on your software
that can be useful gmail what's
brilliantly other applications it may
not be so practical to deliver a fully
functional iteration in each time maybe
it will maybe at work but continuous
delivery is still applicable
it's about getting feedback so if you
can deliver a particular feature and
show the users how it works at a very
regular smooth interval it's going to be
much easier to adapt and see whether
that's applicable and then when the time
comes it's going to be much smoother to
actually deliver all the features you
need into production so a feed value can
also come in the form of feedback from
the user so you don't want to neglect
these concepts just because you're not
in a position to deliver a a new version
to clients every week you can still be
in a position to you want to get into
the PC and whether if you if the client
is ready if the client says ok we want
this new version that's cool we're ready
you want to press a button and put it
into production that's that's what
continuous delivery is about means that
at any point in time you press a button
and the latest working release there's
always the latest work the working
release the latest working release goes
into production that's that's the
essence of continuous integration
continuous delivery so on the terms as
opposed to continuous deployment now
continuous deployment is more something
that you might see in places like Google
where every legitimate release does go
into production continuous delivery is a
little bit different it means that a
release that passes all of your checks
and quality controls is ready to go into
production and it can go into production
you have the means to put it into
production if you want so that's these
of fundamentals of what continuous
integration is really all about so
in a nutshell we've got a few principles
few fundamental concepts every build is
a potential release so that means that
every commit can generate a release and
that also means that a release is not
something you decide after the fact a
release is because a particular commit
passes all the tests and passes all the
checks it is a potential release
so this is where maven will come into
the picture another important aspect of
continuous delivery is that you cannot
have continuous delivery if the QA
department takes six weeks to test the
software when you after you built it
yeah I mean you can automate your build
and then deploy it to staging and then
okay guys we'll test it for the next two
months and then we'll let you know
that's not continuous delivery because
well not very continuous and it only
gets delivered as far as the QA
department now that often happens in
large organizations and that is a
problem because that slows down the
process significantly and that is a an
organization or as much as a technical
problem you need to be able to eliminate
that those sort of big chunks of delays
in the pipeline the other big area of
delay is the actual deployment process
itself where often in large
organizations the deployment process
going from taking your application into
a development environment is totally
different from the one that goes into
the production environment so that's the
whole DevOps scene we're trying to try
to move those two worlds a little bit
closer when you have a whole different
way of deploying from deploying into
production as you would do as a
developer it makes it much harder to do
continuous delivery often in those cases
there's a lot of automatic
steps it could be automated but that our
manual scripting database backups what
have you a lot of bottlenecks on the
deployment front so that's another
common area where you want to try and
eliminate bottlenecks and the way to
eliminate bottlenecks is automate the
heck out of it so automate as much as
possible and this is really really can't
emphasize it enough if you don't have
confidence in your tests you cannot do
continuous delivery can't even do
continuous integration for that matter
you really need to have heart a high
degree of confidence in your tests I'm
not talking about test coverage we'll
talk about having confidence in your
tests which is much harder it's easy
they're high test coverage Tata to be
confident that when all of your units
integration and acceptance tests pass
your code is ready to go into production
how many people could claim that when
all your tests pass you're ready to go
into production a few that's sort of
what you want to aim to get it it's
easier to do if you start from the
beginning if you do it at the start of a
project and take a fairly disciplined
approach to your to automated tests you
do acceptance test-driven development
BDD TDD whatnot that makes it easier but
it's very hard to do continuous delivery
without having that degree of confidence
because if you don't then it just falls
into the lap of the QA guys and they
have to do all the tests behind the
scenes and it's not only you not only
developers you have to be confident it's
also the QA guys and that's actually
quite hard because you're sort of they
think you're putting them out of a job
when you automate the heck out of their
acceptance tests you're not but they
think you are they'll go and when you
setup this process for the first time
they'll go and do all their manual tests
anyway and you're still getting six
weeks even though you've got all your
automated tests so that can be that's a
culture change as well as a technical
age so moving on to the more technical
side of it one of the fundamental things
in continuous delivery is the idea of a
build pipeline so how do you actually
build a release and shunt it through the
system till it gets into production so
this is a fairly well known concept you
start off with a commit of some kind
you're going to be run you you compile
it build up run unit tests deploy it
somewhere run some integration
acceptance tests and whatnot maybe your
deploy to QA and you deploy to prod
that's a very very simple one the eye
the key things to take away here is that
as I said each commit that goes into the
system can potentially be a release so
there's no process of saying okay this
snapshot is ready to be released let's
build a relief let's cut a release from
this snapshot or from the head at this
point in time in continuous delivery
each commit can be released so it's a
radically different approach to the
traditional approach where you have
snapshots which go in then become
releases they are sort of incompatible
as we'll see later on other thing is you
use the same binaries right through the
process so that it's fairly a fairly
well established best practice there
like so best practices best practice
that you take a binary if you can take a
binary and then deploy it anywhere that
is much a much nicer practice than
having to rebuild the application for
each platform I don't know a lot of
places who still rebuild for each
platform but there are a few but it's
obviously much nicer if you have a
binary you deploy it anywhere and even
better if you have the binary you deploy
it to the platform using exactly the
same process so next stage is your
acceptance tests
so I got unit integration test before
then but the acceptance tests are the
things that are visible to everyone so
the acceptance tests are what give the
QA people confidence as well as
yourselves developers that the code
actually does what you say it does and
that the code does what the client wants
it to do so the acceptance tests are
really important functional regression
whatever you want to call them so you
want your acceptance test to be
repeatable you want the same set of
acceptance tests to run against any
platform potentially a subset whether it
runs in production you don't want to do
too many updates in the production
system their clients get stroppy about
that for some reason so sometimes you'll
have a subset of smoke tests that will
be executed in the production
environment but the principle is you
have the same tests that can be run
anywhere and the same tests we're the
same build job that applies across the
board to any platform so now the fun bit
so who's using maven no that's a dumb
question isn't it it wouldn't be here
were otherwise would you they're there
continuous delivery with maven it is
actually quite tricky because the fun
the a lot of the concepts in maven date
from before continuous delivery was sort
of became popular and so a lot of the
fundamental ideas in maven a
diametrically opposed to the fundamental
ideas in in continuous delivery but that
does not mean you have to go back to ant
god now now you wouldn't one do that and
you don't have to move to Gradle either
that you could Gradle will make things a
little bit easier but still maven has a
lot of advantages so you don't want to
abandon throw the baby out with the
bathwater and so what so forth
let's have a look at what the actual
issue is so it's maven you've got these
very useful concept called the motor to
build the life cycle so
maven lifecycle you when you run maven
test but we'll both compile and run the
unit tests for you if you run maven
verify it will compile test package run
your integration tests and run any thing
that you're bound to the verify phase if
you do a maven deploy it will compile
test package run the integration tests
verify and deploy yeah that's fine now
the advantage of that is that you never
forget to do anything so if you run do
maven install deploy it will not let you
not run the the unit tests on the face
of it that's a good idea
it does but we'll see that has problems
when you want to break that process up
into a build pipeline the other hurdle
that we have with maven is the release
process so the maven release process is
based on the principles you that you
work on a snapshot you work your work
your work then you say hey this
snapshots really cool let's release it
and you use some even release plugin who
uses to make and release plugin yep
pretty much everyone to use a maven
release plug-in which is quite
convenient because it does a lot of the
boring stuff that you have to do
normally have to do manually it does a
lot of checks make sure there are no
snapshots make sure that you're all the
tests run runs the tests creates a new
tag for you runs the tests again builds
it commits it runs the test again and so
forth so the problem in a continuous
delivery context is it does things a lot
the other problem is that the
fundamental concept is that you say okay
I've got the snapshot that's ready cool
we'll take the head at this point in
time and we'll build a release from it
hopefully no one's changed the head
since you've decided to do the release
so in a nutshell the release preparer
does this create your creator tag with
your new version number creates a new
updates of version number and away you
go the perform then goes and does all
the checks but will look yet earlier and
read up everything compile test package
integration test verify how long do your
integration tests run people less than
10 minutes
whose full test suite runs less than 10
minutes more than less than half an hour
less than an hour more than hour so if
you're running maven release process and
the tests check more than an hour how
long does a maven release process take
how long it takes a long time that's one
of the things that annoys me about it
sometimes you do you do actually need
long tests more than an hour that's
starting at a bit a bit really long but
that happens with big applications
especially when you got acceptance tests
in they're actually doing heavyweight
stuff you've got web tests you've got
you're doing serious testing and if
there can be quite a lot of it it can
take time to run so sometimes there's no
way of shorting no we can't not every
application can be entirely tested with
unit tests you the user does not talk to
an application through unit tests user
talks to an application through the user
interface and if you want to demonstrate
that an application works you need to
demonstrate it through the user
interface so you need to do web tests a
lot of time so sometimes there's no way
of avoiding that the tests will take
time to run
and but that craps your style in the
continuous delivery approach that really
slows you down and again there's as I
keep mentioning and reiterating there is
this fundamental disconnect between the
fact that in continuous delivery any
commit can be a release but in
continuous in maven you say okay where
looks like it's good let's let's build a
release so that means you've got these
snapshots which of nebulous concepts
which don't have any relationship with
to what's going to actually be released
then you build from some particular
snapshot and that is your release so my
fundamental issue with which annoys me
with maven the maven release process in
continuous delivery is really that you
have to you don't get a potential
release from every snapshot from every
commit what you want with maven is what
you'd like is every commit can say okay
this commit we're good let's it's passed
all the tests it's a potential release
and then let the client choose let the
business choose which version goes out
so making sense
so that's in a nutshell what and the
fact that there's a huge amount of
repetition because you're when you do a
release process if your tests take an
hour to run you run them two or three
times to get a release out and if
something goes wrong real hell breaks
loose
so it's wasted effort re running your
tests each time when you've just run
them so you can streamline that process
a lot so let's have a look at some
options that we can could use to make it
work a bit better so often what you'll
see is things like this first stage of
the building your build pipeline you
have maven tests you have a second stage
which may even verify to run code
coverage and stuff like that no well
actually integration tests and then
you'll run a maven site for the code
coverage and that's not really very
efficient maven site is really really
slow you don't want to run it as part of
your build pipeline because it's
hideously slow and often you don't
really need everything that is in it as
part of the validation process so your
build pipeline so like agile
documentation when you're talking about
documentation and agile process you want
to know why you're producing a
particular document in a build pipeline
the same thing you'll know why you're
doing a particular task is it
contributing to no to pushing the build
through the pipeline so code coverage
does that contribute to pushing through
the bill pipeline only if you actually
check whether the code coverage is
significant which we'll look at later on
Javadoc does that contribute maybe maybe
not maybe it's just documentation that
you want to do as a separate separate
process off the build pipeline the maven
site I don't think the HTML is going to
be of much use to the to the end user
and it's really slow so generating all
that is not something you want to do as
part of the build pipeline you
to be much more selective about what you
put on the build pipeline and have
anything else like the moment site if
you really want to do maven site you do
it off on another as another build job
and maven all already as we saw already
does all this in a nice staged manner so
you don't want to have separate build
jobs for unit testing integration tests
and whatnot do it all in one go
now just do or maven installs your
initial build that will compile run unit
tests run integration tests do any
checks that you want to do and so forth
that will do them in the right order and
if it fails it will fail early so that's
effectively what you want you don't need
to split that part out of the build
pipeline so let me even do its job where
it can do its job well so true the only
tricky bit here is the this bit tests
and integration tests who knows how to
split tests and unit tests and
integration testing maven who does not
I'm glad I put these slides in there so
there are many actually two or three
very easy ways to do this if you're not
adverse to 50 lines of XML or so the
effectively what you have to do is split
away find a way of identifying unit
tests and integration tests whether it
be in buy a package convention a naming
convention an annotation and then you
buy and you filter the testing and
executed each phase in a nutshell that's
what what it is so if you're using the
Surefire plugin by default here we're
saying skip true so we're skipping all
the unit tests by default then in the in
the test phase here we're excluding see
this line at the bottom excluding
anything in a package called integration
so here we're using a package based
convention that anything
integration in a convent in our package
called integration is an integration
test so you want to skip them in the
unit test you could also obviously do
that by a naming convention if you use
the failsafe plug-in and call all your
integration tests something something
something IT it'll do that for you you
can also use the categories the latest
version of G you know you've got these
single categories where you define a
hierarchy of interfaces and you can say
okay this these tests or integration
tests and these testing unit tests using
annotations can end group them using
exactly the same principle that the
important thing so this is just an
example it's one way out of about three
which are very viable I usually use the
Surefire the failsafe plug-in but if I
was doing a new project I probably use
annotations because it's kind of nice
there are several so there are several
ways of doing it the important thing is
you want to make sure you are splitting
the unit test from the integration tests
so that you if it fails your unit tests
fail or fails fast once your unit tests
are done then you can start with the
slower integration tests so that
distinction is really important if you
make that distinction then you can get
away with just having a single pass
build as the first part of your build
process another thing you want to be
careful of it's maven deploy if you've
got multi module projects
so what maven deploy does is pushes the
jar files or the war file to your
repository manager yeah so when you do
maven deploy it will go and push things
out to Nexis or add a factory or
whatever using and and you're all good
but the problem with a multi module
project is that this doesn't work very
well because if you have a multi module
project it will run the build
sequentially run your first module so
all good deploys runs the second module
it fails it doesn't deploy
so your repository ends up with a
mixture of versions so that's kind of
that kind of sucked so another approach
is you do your maven install and then
well you deploy the artifacts after the
bill that's the essential bit here using
artifactory in Jenkins Jenkins has a
artifact where it's a very nice Jenkins
plugin where you can deploy the
artifacts after the build to any
repository you want so that works quite
nicely if you're using Nexus you can do
the same thing at the maven level we do
maven deploy deploy but after as a
separate step after everything builds
correctly you do the maven deploy so
important the important thing here is
you're separating the deployment from
the actual building the modules
otherwise you get inconsistencies in
your repository another important area
so actually all of this is eliminating
waste you try to eliminate repetition
and waste in the pipeline so you can get
it as streamlined as possible say okay
I'm like in my big fan of code coverage
it depends when you ask and how you ask
I use it a lot but I don't use it alone
ask me later on about code coverage I
could talk for an hour and code coverage
but the point is if you doing something
like code coverage using something like
curvature ER your uneven cobertura
problem with something i cobertura or
clover or yep they're the two main ones
to do this so I will generate
instrumented jar files rerun and rerun
your tests with the instrumented jar
files so you rerun your unit integration
tests whatever so your Joop locating the
whole process here sir in the
integration test phase you run all your
integration tests and then you rebuild
everything with code cover with
instrumentation and you rerun them
that's kind of slow and clunky
so for code coverage my strategy at the
moment for avoiding this or duplication
is using thing called jacoco which is a
who anyone heard of it yep phew so it's
a code coverage library which uses
dynamic instrumentation it doesn't
actually mess with your jar files so you
can actually run code coverage on your
normal jar files which means that you
can actually bind the code courage to
the normal integration or post
integration test phase and then just run
code coverage in your normal build that
doesn't take a lot more time so you can
do things like as I was saying code
coverage at anything is only useful in a
build pipeline if it helps you push the
binary through to production code
coverage only helps push through to
production if you actually do checks on
it the HTML reports are not going to
help you know whether well they will be
you have to look at them there's no
automation in an HTML report so the only
way and the use of code coverage in a
build pipeline is when you decide that
it's going to be significant and you
don't want it you don't want less code
coverage to the certain level so you're
going to in your maven build or well
this is the way I deal with cocoa in the
maven build you setup checks to say
specify the minimum amount of code
coverage that you consider acceptable
and then when you run maven install it
runs the code coverage at the same time
as everything else and it adds a very
minimal overhead as far as time goes so
this normal build versus build with
cocoa as opposed to twice that if you
had to do both if you had to do it as a
separate phase
so you're just having a chunk of time
there too when you include code coverage
in the main build process so that's
quite a quite nice another approach that
we're that we've been talking about is
to reuse the same binaries right through
the process which is something that is
difficult to do with maven out of the
box you have to do a little bit of magic
too but conceptually here's what you
want to happen you run a build it will
generate a version know the version
you'll notice it's not a snapshot it is
a version it's got a number then you're
going to deploy that to a test
environment run your acceptance tests
deploy the same binary to UAT and so
forth so again this is different from
the traditional maven approach where you
have a snapshot at this stage where you
normally build a snapshot here if you
build a snapshot you can't push it
through the process because at some
point you have to actually cut a release
because there's no way you can release a
snapshot into production because it's
not reproducible the build is not
reproducible so you need at some point
to have version numbers so my approach
is to get the version numbers in there
as early as possible we'll see how an
example of how to do this but rather
than using snapshots get version numbers
for each build
another thing now we've got unit and
integration tests in the normal faith
but I put acceptance test is a totally
different module or actually a totally
different project technically because
it's it's a module but it's not part of
the aggregation so acceptance tests are
totally separate in their Prem
parameterised so that you can run them
on any platform but if passing a
parameter tell it where to go where to
test we'll see all these in practice and
as I said if you're bothering to do any
sort of code quality metrics then be
serious about it the HTML reports are
not going to help you push a binary
through the production if you serious
about check style then break the build
if there are violations same thing for
PMD or fine bugs if there's a rule that
you don't like then get rid of it change
the rules to suit your environment and
then make them enforceable make them
break the build if it fails or you might
do find bugs or PMD their levels of
violation there are different levels and
say everything from a certain level
certain severity up will break the build
but come up with a policy and apply it
so any code quality metrics in a build
pipeline are useless if you're not
enforcing them if you're not actively
breaking the build so this is why the
Maven site approach doesn't really work
you want to actually do something a
little bit more proactive little bit
more selective and actually invoke the
plugins individually so if you want PMD
do PMD check find bugs check check style
check cell and so forth
and then configure those plugins to suit
your environment so that's easy enough
to do it's well-documented but the point
is you want to enforce those metrics
actively you want to be serious about
what you're in
what you're asking people to do and if
you don't lies I said if you don't like
a rule just drop the real configure it
so that a rule that you don't agree with
is not applied you only have a subset of
the rules that you're interested in that
you think are significant for your
situation
and now the how do we actually do this
version number that I was talking about
don't use the maven release plug-in
maven release plug-in I mean it is
actually it does very nice stuff but
it's clunky as hell and not really
suitable for our continuous delivery
environment it drags down a continuous
delivery pipeline makes it hard to
because what you if you're using maven
release and what you have to do is doing
the maven release because you cannot do
this way you can do maven the maven
release but you have to do it as soon as
you go out of the first phase so any
commit doesn't may even release but
that's slow especially if we got one our
tests because you have to do the whole
process and the point is you don't know
if you're going to go right through
because maybe the integration test will
fail so if you don't maven release and
you're not sure that everything's good
you're going to waste a lot of effort
going through that release process if
you're going to fail at the integration
tests if you do a snapshot you gone
through all that effort but then you
have to go and create a version number
and do it again so what we do is
developers work on snapshot version
that's fine but as soon as it kept into
the build pipeline you give it a version
number not with the mobile release
project proce process you just give it a
version number maven versions plug-in
and the version number is effectively
well this is where I do it the two first
two digits are the real version number
then it's just a build counter
once you get your build counter that is
the number that goes through the process
so each version goes through some will
result in binaries maybe some won't if
the tests fail at some point you won't
get a binary if the code coverage is not
sufficient you won't get a binary if
everything is good you will get a binary
if you get a binary then it's good ready
to go into production that's this that's
a theory of continuous delivery so
rather than going through the whole
snapshot up to a certain point then
redoing it all with the maven release
you start off with a version number you
guys would take it through the process
and if it works it works if it doesn't
then you drop the drop that version
number so the key is just being not
really caring about the third digit in
the version number so in practice what
are you going to do when a commit comes
through create a new branch so I do it
with git create a new branch on that
branch you update the version number you
build what works you push that branch
back and deploy the relief candidate and
if it doesn't you just drop the branch
and you're good so this is why this
works brilliantly we've get because it's
very easy just to create a local branch
and then drop it if it fails and no one
will know any any better
so in practice we're going to do use get
create a branch use the Maven versions
plugin so maybe versions plugin is a
very useful plugin which lets you set
the version set the version numbers in
your pom files from the command line
very easy to use then you go through
your normal process to the maven
verifier what not and if it works as I
said you push it back if it doesn't you
drop it so it's actually quite a simple
process and you can add as much of many
controls and can checks and constraints
along the way as you want and also one
thing I like to do is only see a build
pipelines plug-in who knows about the
build pipelines plug-in that few people
so it's a very nice little plugin for
this sort of thing which lets you
visualize a sequence of build jobs and
where particular commits are at in a
particularly in a sequence of build jobs
so now I have a as I sort of promised in
the description there is a live working
version of this and may or may not trust
network what I'm going to do is I'll
take you through the I took some
screenshots of this beforehand so I'll
take you through the screenshots to show
you the highlights and then at the end
we have time I'll show you the real live
version in a browser so this particular
demo fairly arbitrarily so I'm using
gift and Jenkins they're my and tools of
choice for this running sauce labs are
running the acceptance tests web
acceptance test remotely on sauce labs
deploying to artifactory and running the
environment binaries to the application
to a jelastic service so jelastic I
would have used cloudBees because they
have a nicer Jenkins plugin but had some
technical difficulties that's really not
important because the important bits are
the git git and Jenkins here and some
extent the artifact
so where you're actually putting your
binaries but the rest how you actually
deploy you can just go in have to figure
that out for your specific environment
obviously but the general principles
still apply so what do we got in
practice we've got a set of build jobs
an initial build code quality build
which does the PMD and text and so forth
we deploy to test run acceptance tests
if that works will deploy to you a to
run the you the acceptance tests and if
that's all good at some point we can
manually deploy to production so the
deployment of production is a manual
step where the business chooses to
deploy a particular version so that's
the distinction between continuous
delivery and continuous deployment
so the initial build what's special
about the initial build so you will get
our release candidate numbers here
anything else so each build has a
release can a build number that's our
the number that we assigned to it at the
start of the process and that goes
through right through the process now
where since we're using at a factory
here we can actually link to the binary
but we'll see there are two when you're
reusing these binaries there are two
approaches you can you going to deploy
your binary to artifactory on axis or
whatever you choose to use you can
either reuse it from there or if using
Jenkins you can just copy the binary and
reuse it from the from that bill which
is a lot simpler which is what we do
here so that's just the where the
binaries are actually at in our the
factory what else have we got the actual
build number is parameterised so why are
we doing that well we might want to
change that we might be building a
1-point a series of 1.1 builds so we can
just adjust that as we go and the actual
build the last each other is what we're
interested in
here first thing we do when we come into
a build so we use get we check out at
the right one no way that's not the
right one we're creating a new branch
I've got the wrong screenshot it should
be there's a step before that which is
we create a new branch in get using the
interesting bit here as you can see
we've got some dollar major version
number dollar build number so we're
using those parameters to create a new
branch and then the system in the second
phase where and then we'll check out
that branch and work against that branch
so it's actually really simple to do and
once we in that branch we can go and do
my even version set to update the
version number build the binary and then
we use the conditional player plug-in
called the conditional build build step
or something along those lines you know
when you see it conditional build step
plug-in that's the one if it works so if
the build succeeds then we'll go and
commit those these PDS will be online so
it'll be on the Java one site and on the
whacker Leo web site as well and on
SlideShare so these slides will be
around so then you push the branch back
to back to the repository if it work if
it's successful if it's not successful
then just delete the branch so it's
actually quite simple
the trick is creating a branch rather
start assigning a version number
dynamically from the build number so you
notice we used to build ID which is the
ID the variable that Jenkins uses to to
identify the build job
so you can use those variables in the
get statements and then it's quite
simple so then once we've done that what
do we deploy it to artifactory
so here we're using the artifactory
plugin to deploy it there if you're
using Nexus and you just do a maven
deploy curl and deploy then we'll deploy
it to our test environment so here we're
deploying directly the end of this phase
if everything goes well we actually
deploy directly to test you could do
that the separate step as well if you
wanted so here just for completeness
where we were using jelastic so we had
to set that up as maven job
if using cloudBees there's a Jenkins
plug-in which makes it a bit easier to
do there's all if you're deploying to a
internal Tomcat or something like that
there's also the deploy plugin or you
can just use if it's really custom then
you just use some sort of scripting to
do it here the point is you figure out
how to automate the deployment this is
just a nice to have I'm using the build
description setter
to define to go and look through the log
files and figure out what version I'm
building and then put that in the
description of the build so I can easily
see what version is being built
and there this is important archive the
artifacts that you build we're going to
archive them because as I said in this
particular pipeline we're going to reuse
that binary right through the process
we're going to copy it from here we're
not going to get it from our factory
just cuz it's easier to copy it from
here lazy if you copy it from if you get
it from Nexus or outer Factory then what
you would do is you'd take the build
number that we just built created as a
variable pass that into the Maven job as
a parameter and have a parameterize
dependency so variable in your
dependencies so what's - a bit more
complicated and then so here's an next
bit we used a parameterised build job to
trigger the next build step and here
we're passing through this release tag
so we're passing with passing through
the tag that we build version that we're
working on at the moment so that's what
ties it all together
that's what ensures at the next step we
will be working against the same that
the same commute working against the
same branch so right through the
pipeline we create a branch we work
against that branch right till we get
our binary to a way of validating our
binary I had to do this block build when
downstream project is building I had to
do this because you could conceptually
do it differently but in this particular
setup we've got a test environment a UAE
environment and a production environment
when you deploy a version to a test
environment you don't want another
commit coming through and deploying it
to the test environment while your
acceptance tests are running that would
be annoying
if you wanted two things to be really
streamlined then it would be
conceptually not too hard to do if you
actually create a new environment each
time but I don't know whether you'd
really want to do that would depend how
keen you were on streamlining things
so then next stage we move on to the
code quality build so this is where you
do your PMD find votes and so forth and
on the other side of the coin so we
passed in the parameter the release tag
here we're getting the release tag and
we'll go and use that again the get
plug-in is really useful for this
because it's quite easy networking sort
of down here we've got threw a dollar
release tag so we're going to check out
the branch that we're currently working
on and then it's the rest is pretty easy
so deploy to test you just do exactly
the same approach you with one extra
thing we need to get the binary one we
want to deploy so where do we get it
from
we copy use a copy artifacts plug-in so
we copy the binary from the initial
build and then we that's where we it
will just deploy it to the directory
that it came from and from there we
could just do a normal deployment so it
will be in a target directory you can
just run the normal use of normal way
you deploy your jar your war file so
here we're using the jelastic maven
jelastic plugin but that's not really
important the point is you've got your
war file which you've got your binary
that you built originally and then you
do what you want with it
so reusing the same binary which is the
important thing
another interesting bit here now
remember I said use the same test suite
to test each environment so here another
thing you can do with the parameterised
build plug-in is actually effectively
call a build job as opposed to trigger a
build job you call one as part of your
build job so like a sub build job so
here we're actually calling invoking the
acceptance tests
bill job posses in a perimeter so here
at parameter I so we say okay run
against this platform so the parameter
that the acceptance tests platform takes
is the acceptance if your job is the
platform that you want to run it against
and that allows us to do both the
acceptance tests you can test both the
test environment view HD environment the
production environment and so forth so
this is the same build job you've got
one build job that runs acceptance test
passing a parameter and tests different
platforms so there's nothing really
particularly complicated here and the
actual build job we're just running a
set of acceptance tests what are we
doing here so using that platform to
build up the URL but we want to test and
party in the URL that we want to test
against what else do we do yep seen that
and the last thing I want to show you is
and another approach that I took for the
actual deployment into production I just
wanted to show you the build promotion
plug-in so the build promotion plug-in
lets you define actually did we do that
earlier yep here it is here we go
build promotion plug-in lets you define
a way an action that you want to do when
the builder choose a certain status or
when you manually trigger when you
manually say this build is good to
deploy so here we've got a deployed
production promotion we say only when
manually approved so we say this is a
manual to put manual promotion process
and what do we actually do we you write
down the body with the project to build
deploy to production deploy to
production so what that effectively does
is that in any build job so you can go
into a builder band say ok deploy this
version to production click on the
approve and that will actually deploy it
to production and to tie it all together
we're using this build pipeline plug-in
so what the build pipeline plug-in does
is looks at your the structure of your
build jobs and creates a model where you
can actually see the sequence of builds
works that's not perfect it doesn't
handle every situation has been a
trouble joins and things like that but
for a case like that a typical build
pipeline that does a pretty good job so
here we've got the green means A's build
jobs have passed red means we've got
some failing build jobs yellow there's
one in pro in in action at this point in
time and then blue hasn't been done yet
so that gives a nice vision of where the
build pipeline is at
so that's pretty much the the overview
of the process we have four minutes web
so what I think I'll do is open up the
question open the floor to questions yes
because they were friends
what can happen
welcome is when we make a volatile
profits
some of the man
dozen successful
I would prefer to do this with DVCS with
git or mercurial just because it's doing
more streamlined as well because
creating branches in subversion deleting
and whatnot you're actually doing it on
the server so it's clunky are much more
visible so the question of whether
developers are afraid to commit because
they're afraid it goes into production I
don't see that happening that much what
do you do but you're right one of the
advantages of something I get is that
you can obviously work locally do your
commits what I do often I'll just commit
for every unit test that passes I'll do
it I'll commit so I can roll back if I
need to and then when I'm ready to
Porsche whole group those commits
together squash them all together and
that makes it much easier to do
meaningful commit that's one of the big
advantages of something like it
yeah the create new branch is more fir
because you've got your acceptance test
as well as your source code so you want
to make sure everything is synchronized
and everything is working and for order
traceability you want to have that
branch created at some point in time so
you want to create the branch of the
reference and so it could be a tag it's
conceptually it's or like a tag but you
want to create that the start just so
you can have a reference to it the other
questions yep I am very poor it
I am very for but if anyone asked me
I'll come up with all sorts of negative
comments because I don't like people
code coverage is too easy to game it's
too easy to if you tell a team we want
90% code coverage they will give you a
night extent code coverage but it may be
worthless if you work using test-driven
development or behavior driven
development of BDD in general you will
get very high code coverage and if you
get low code coverage that's a
significant danger because something's
going wrong with the process but not
because you're trying to get high code
coverage it's because of the way you're
working so I like to ensure that I have
high code coverage but the only metric
I'm interested in is if the code
coverage is low why is it low and then I
want to know that the tests are of high
quality that's what gives me confidence
not the code coverage itself I'm more
interested in the lack of cocoa agency y
code is not being tested if code is
being exercised by the tests that does
not tell me that it's being effectively
tested only the tests tell me if the
code is being effectively tested so
that's why I'm a little bit me I have
weird contradictory comments on code
coverage yes
I've managed it just like a manage an
external dependency so I can see their
internal for inside the same module
using snapshots anything external you
want to be using proper version numbers
using snapshots against an external
dependency that's kind of dangerous
because it means you can where you can't
do this process but if all teams are
using a process like that then you just
use a latest and greatest release we
updated periodically but you try and
have a bit more control over when you do
your updates just like you do if you're
working with hibernate or our spring or
an external library you can see that
delete binaries coming from other teams
in the same ways you can see there an
external library you don't you manually
do it not really because I'm considering
continuous delivery in the context of
our particular project and the
deliveries cut and the binary is coming
into a project from another team I want
to be able to control what if they're
important enough to be updated each time
then they probably should be part of the
actual project otherwise it's if it's an
external dependency I'd rather manage
them independently that makes sense
yeah that's a good point you do would
want to clean them up periodically or
you could even if that wasn't concerned
and you just do an install rather than
the deploy and you copy it and then you
deploy at the end of the process when
it's all released or you do you can also
promote so without a factory you can
promote binaries from one repository to
another so you'd have a temporary
repository effectively where you could
delete old ones and permanent one but if
that were what I usually do if that was
an issue is I delayed the deploy tasks
until after all the controls are done
the other questions yep
right
yeah
are you actually taking rat
every every commit creates a new build
number so use the version MAME
inversions plug-in to update the build
number you create a local branch if all
the tests pass and you push that branch
to the main repository if the tests fail
you delete the branch yep a many
branches or tags or however you want to
do it you do it with tags as well
tags are actually more like conceptually
you have a tag or a branch for every for
every commit that that actually passes
all the tests that's the principle of
continuous delivery
as in the database side of things you
want the sequel any of the sequel
updates to be part stored in version
control that's the short answer
keeping track of those changes there are
a couple of tools but I haven't come
across a really satisfactory one the
liquid based sort of works but it's a
bit clunky because it's all XML based
the most effective tools are founded
database specific ones to manage change
between versions of the database if you
rely on the automated updates that
hibernate does and whatnot it can be a
little bit dodgy but essentially or you
want to have those all the the database
descriptions in version control as well
somewhere I think we will probably get
kicked out soon so I'm happy to take
questions in the corridor</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>