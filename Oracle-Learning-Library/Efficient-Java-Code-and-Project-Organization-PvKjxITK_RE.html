<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Efficient Java Code and Project Organization | Coder Coacher - Coaching Coders</title><meta content="Efficient Java Code and Project Organization - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Efficient Java Code and Project Organization</b></h2><h5 class="post__date">2013-01-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/PvKjxITK_RE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">a good afternoon or perhaps even good
evening everyone and thanks for being
positive oh I'm supposed to start sorry
about that
good evening everyone and thanks for
being a positive and zealous enough to
be here rather than being out grabbing a
beer or something equally uplifting
welcome to both 63-57 which is a walk
through of efficient code and project
organization my name is Lanna TR illud I
am an architect and developer of j2ee
systems basically have work with Java
and open source since well roughly 95
and we'll do this talk in in four
sections it becomes a bit of a challenge
since the code and the integration will
mostly be in the last part so all the
goodies stuff will be only at the end
but we start by investigating bit of a
problem which I've seen through numerous
projects which is the costly onboarding
process which is a sort of an instance
of an example of the effects of not
using an efficient code and project
organization and I will go through the
tiny bit of usability you actually need
to know to be able to address that
problem and land in the tooling land and
getting ready to organize your code and
your project land at the very end of the
of the talk and following probably the
end of the talk we can have a Q&amp;amp;A
probably outside of this facility right
let's start with the famous this
disclaimer here this is not to talk
about Java programming in depth there
like a gazillion talks outside of this
one that would probably convey
everything you ever wanted
to need to know and then some about Java
I have rather assumed that you know how
to program Java that you've been a
member of multiple projects or at least
a few of them and that you know maven at
least to a degree and for the rest of
you who don't know maven no worries it
will become a bit technical in the end
but I think you'll survive it's not an
in-depth usability engineering
walkthrough either
instead this is a talk aimed at
inspiring you empowering you when you
get home from this session to try to
change and make your workplace a little
better basically
to consider yourselves as developers and
possibly the developers that work with
you as uses to which you have to design
stuff not only users of your system but
yourselves as well you're very important
users of the system and that part of
usability and that part of usability
engineering tends to evaporate with some
desire not so desirable consequences
right let's start with the the problem
at am and since it's rather late in the
afternoon or even early in the evening
let's start with a bit of gymnastics so
hands up those of you who works or have
worked in big projects okay
all of you and hands up those of you who
moved between projects a lot quite all
of you and ok so hands up all of all
those of you who felt that the
introduction you've got to say your
latest project was really great and
you've got the whole thing just by being
at the introduction no no ok and then
the experience did you feel that there
was tooling in your projects that helped
you reduce your need to sit and read
through lots of documents or query lots
of collaborators for the mentoring stuff
was there really good tooling in your
project
well it was actually more than I would
have expected it was like 10 all right
we move on to the second part of the
defining the audience hello dear
audience now who of you studied
usability engineering hands up well a
few of you who of you designed ap is
first of all designed API is using the
principles of usability engineering whew
okay and yeah that would probably be a
bit difficult then who have you used
usability engineering to design your own
build or version control system that
would probably have been rather few of
you considering few of you actually
started it and to take it one step
further who have you setup maven plugins
to define the build of your entire
reactor to give feedback to developers
when the guidelines that you set up as
architects or developers were actually
broken basically when they introduced
dependencies into projects what they
were not really supposed to introduce
them there or wrote code that didn't
quite comply with your check styles like
a handful of you okay you see a bit
disconnect here how many of you worked
in big projects okay enough said
so the problem statement is that
generally introduction and I've seen
this over and over again introduction of
new collaborators into a project is
really costly and it's rather difficult
to find and understand and then apply
the standards which were given in the
introduction which you yourselves just
claimed really didn't help you at all
right and so the phenomenon is sort of
where other standards and when I'm
sitting developing how do I know where
the standards are do they exist
should I search for them in some team
place a wiki should i download them and
by the way does it apply to the
situation I'm currently in
wait a minute I think I'll stop coding
for 15 hours to actually download the
documents read it understand it and then
apply it no that situation doesn't quite
ever occur so the version control
systems generally tend to be structured
for creating a build for defining a
reactor not to assist you or anyone else
understanding so generally the
introduction looks something like this
if we go to the meta level and introduce
the lifecycle of a co worker within the
project welcome to the this glorious new
project dear coworker I am the manager
sorry I am the manager so I have no
humor I will now give you a presentation
of our organization you will get three
hours worth of slides detailing who
everyone that manages parts and
divisions of our organization it's now
thank you so much fast-forward three
hours you are not too much the wiser but
I guarantee it was lots of information
that you didn't quite absorb so we send
you off to the architect or even the
business architect and he or she gives
you a grand product presentation we have
ten products you're working in scrum
team X with product Y for division Z and
by the way they relate in this way to
every system in the whole world and
after that presentation you have a
slight tendency of being a bit dizzy not
really understanding more but being more
dizzy so you're sent away to the scrum
master the scrum team or project manager
depending on how you're organized and
you get the backlog the sprints the
stories and yet another sense of the
reality you're supposed to work in which
doesn't really connect to what you were
just presented right none of these
things actually connect at all it's just
that and they don't connect it to all to
what you're supposed to be doing right
perhaps we're getting there but not
quite from the looks of your face it's
this is really hilarious
I can tell some of you have actually
been through this then starts the very
frustrating face
the learning curve you have to download
stuff from the wiki you have to read
stuff you have to understand it and you
have to pester your co-workers with
questions from everything like beginner
stuff to very complex stuff to arrive at
the productivity phase where you
actually can start doing something but
you know how to do take informed
decisions and so on now this is the
general life cycle if you come into a
professional project how many of you
work with open source projects hand up
grant then you get roughly that you
don't get any presentation whatsoever
you get the wiki or the documentation
and nothing else and sometimes we at
Apache wonder why people have such a
high threshold to actually get in and
start committing stuff right so this is
the problem the learning curve is steep
it's costly wiki's and team places
consists mainly of documents documents
tend to be problematic in that they
consume enormous amounts of times to
produce they're actually difficult to
understand when you read them not to
mention that you never know if they're
actually stale or updated who would you
ask whoever wrote it left the company
three years ago yeah and they're time
consuming to to read did you actually
understand it who are you're supposed to
ask your co-workers and they will be
happy to answer you I'm sure so we need
to somehow to get a stain abilipad piece
here and and while by the way those are
you guys who take pictures of this
ground that you do if you want to just
send me an email and I'll send you a PDF
of this it probably doesn't make too
much sense but you would probably save
some megabytes on your cameras so we
must find some way to reduce the need to
read the documentation because that
increases the development pace on the
project pace and we need to reduce the
number of concepts in a version control
system generally if let's see how many
of you bill
stuff with ants and you have rather few
projects which have huge amounts of
packages and classes in each build hand
up oh my goodness how many of you build
stuff with maven where you have slightly
smaller code bases in each project but
256 projects in in the reactor lovely
from those of you who just the maven
part of you how many of you actually
understood and saw patterns in all of
these projects from day one - that's a
bit doesn't it so it's important to
reduce the number of concepts in a
version control system so it can be
chewed so it can be portioned out to us
all in mouthfuls that will make sense
that we could understand and actually
process and those would have to comply
with a development specification by the
way so having understood a bit of the
problem and it seems almost silly to
walk through it because all of you seems
to sit there and nod smile slightly and
understand this problem we've seen it
200 times before yeah yeah but how do we
rectify this situation there are a few
fairly simple approaches to do this and
some very complex we'll start with a
simple or simplistic ones I should say
we need to apply usability engineering
and the principles of human-computer
interaction to the way we design
projects to the way that we structure
the projects both in terms of builds and
codes and also organization I won't deal
with the organization at all
I'm sure you have managers who have
nothing better to do than dealing with
the organization all day long but I will
deal with a coat because that is such a
powerful means that the version control
system to convey meaning and to convey
semantics so we have to originate from
the human mind and how we learn stuff
and then adhere to the standard design
principles and this requires some basic
knowledge of how we learn stuff and the
design principles and some of usability
engineering now I won't go into much
detail about this
so no worries but the 101 on memory and
learning is something like this the eyes
and ears or whatever the sensors receive
sensory input which sort of stays in
those senses for just an instant it
vanishes almost immediately
thankfully it vanishes to the brain from
the sensory organs when it goes into the
short-term memory and the short-term
memory were active memory depending on
which which school of psychology you
actually work with is a rather
interesting piece of the brain which
stores seven plus minus two is that
commonly accepted definition things now
things is something that is rather
abstract a thing can be everything from
objects on a table there are like seven
things here to two rows or to two groups
of people two things so things in terms
of programmers and version control
systems repose can mean structures of
Bro of projects rather than just one
project or one class all right so the
short-term memory is as it were short so
the information in there stays for a few
seconds but not more and then hopefully
it sort of moves slowly or hopefully
quickly into the long-term memory where
basically an unlimited or sort of
unlimited amount of information can stay
indefinitely now that's the principles
of learning so we have to remember this
with seven plus minus two for the short
time memory whereas design principles of
the standard ones of human-computer
interaction these are but a fraction of
it but they are very obvious when you
think of them and for some reason very
and obvious to apply to everyday life
for us as programmers well let's start
with to visibility what does an object
do if that function is apparent then the
object has a good visibility so a hammer
would work really visible
it's what
handle which sort of invites you to grip
it and then yeah and then you bang on
some something not someone and you could
just consider their rather poor example
of it design to the right there it's a
door handle right and normally you have
got big flat door handles which you're
supposed to sort of they invite you to
push and when the design and the
intuitive way of using the stuff doesn't
really you know go inside but rather go
opposite directions then you get this
door and all you have to have a sign
telling you what to do because obviously
if people would go oh push so not
completely stupid people but a rather
interesting design shall we say so
that's visibility and affordance what
does the object do and how do I use it
consistency repeating yourself is a good
thing in terms of design I use one car
just like I used another car even if you
haven't driven and you know nice new
Lexus like ever and a car is a very
complex piece of machinery I bet you if
you have a driver's license you could
just as easily sit down in that new car
you've never been in before and keep on
driving because of consistency the
steering wheel isn't the same place the
gear shift is well if you have one here
in the United States but it's in the
same place and the pedals do the same
thing consistency the same thing can be
applied to software engineering if we
have a large number of consistent groups
of stuff in a version control system
then we immediately apply the same
thinking over and over again and
basically if we just saw one of those
little pieces of the puzzle then we can
work with all of it without having to
relearn everything so consistency is
important constraints I can only use an
object in a certain way if you got
unleaded fuel no wait a minute if you've
got LED a few you can't put the nozzle
of the thing in in the car because they
want fits so that's a constraint menus
are typical constraints in in software
engineering and the build process in
terms of version control
system is a constraint or can be a
constraint it's very important to get
feedback the build system which doesn't
give you feedback even if you do
something wrong conceptually wrong or
break some of the rules of the
development guidelines is basically
incomplete because use the developer
shouldn't have to read stuff or to
question someone to know that you did
something which didn't comply with the
rules you're supposed to get immediate
feedback so something has to give you
that feedback and check feedback is
important so now your human-computer
interaction experts and you know
everything there is about design
principles right let's start applying
this so if we if we combine usability
engineering with repo structures and
project structures that we normally work
with we won't
frequently up or so is my experience in
components division of entire repos into
components the problems with components
which we sort of try to have in in
groups of seven plus minus two right is
that the the term component is probably
one of the most overloaded terms you
could ever find so bad let's see what I
mean with component now it's starting to
getting interesting software components
are essentially a solidify
solidification of patterns so a
sustainable way to reduce dependency
tangle months it's really important to
ensure that you can sustainably and
controlled in a controlled manner ensure
that you do not wind up into a complete
big ball of yarn the legacy system where
you want to refactor something but if
you touch that little bit you have to
touch everything in the entire system
because it depends on or rather it has
dependencies upon everything which is a
bit of a problem then the refactoring
speed is of course reduced considerably
so we have to devise some kind of
interaction pattern and dependency
pattern to reduce that possibility
we observed dependency control to
enforce that dependency control you're
supposed to only depend upon API
projects and not depend upon
implementations ever okay how do we
enforce that and it's important to
simplify if you have this huge ant repo
where everything is different it's just
packages and classes everywhere they
probably have some structure they
particularly had some structures ten
years ago when the repo was started
right but now the structure sort of
mutated over the years developed a life
of its own getting the privilege to vote
and it's very complex to see which bits
actually go where so we have to use
software components or some such
structure to simplify it okay into the
gist of it so we've developed a
component named X substitute with
caching parsing XML binding your vehicle
something component a component it is a
project maven project and it has a few
projects below it in and I mean below it
as in a File Explorer but within the
version control system right so X would
be a directory and it would have this
slush of of projects below it's a model
an API an implementation of some sort
and integration test and possibly others
if we haven't got a model so there are
no entities for this particular
component I'll refer to it as a library
it's basically something like caching
there's no caching model like you take
anything really the cache so it has no
model it's a library but if you have a
model then it becomes a domain component
because then you try to model that
pieces of the domain within entities in
the model projects right so a component
of this case cache for instance would
hide itself behind below a directory
called cache and then would have a slush
of of projects each of which would would
do it'll play its particular part
to create or to build up this software
component and you can also do things
that is very rarely seen but I really
find these really useful how do I use a
cache then frequently I've set up cache
example projects or parser example
projects or whatever example projects
which basically contains copy and paste
code if you don't know what the cache
does and you have to work with it
quickly you go you open the example
project there are three classes there
showing this typical usage of the cache
so you copy the code and paste it if you
really want to know how the cache works
go into the API and take a look forget
about the implementation you never know
which implementation is going to be
injected anyway so all of the
complexities in the implementation you
just now completely reduced the need for
so this is an example from a project
here where which contains relatively few
sort of almost seven plus minus two but
we're pretty bad at calculus so it's
actually ten projects here but the
components so it's much easier to see
this 10-ish sevenish number of projects
which actually implement components with
the same structure just described below
them then seeing all of those component
projects because then it becomes a huge
list of something you have to make sense
of and it becomes too much for the
short-term memory so you don't drop that
seven plus minus two and it takes time
where's this is much much quicker I'm
interested in the cache okay
open the cache I've got four projects
there grant so if I open up one of those
components the cache in this case
you've got the API there's no domain
model for cash you got the cash example
and you've got two implementations one
obviously implemented with eh cache and
the other one with hazel costs grand now
I know even the implementation types I
don't know to know the exact parts of it
I just need to interact with the API and
by the way I can see how I do that by
going into and copy and pasting code
from the example projects Wow
how much time did I have to spend on
learning the cache now
zip because this thing is kind of easy
to digest for all of us we're
programmers this is easy to comprehend
and those examples doesn't really well
they don't get all that complex and so
we've just cut the learning curve
drastically here if you're new to using
a cache I know kind of silly example but
you get the picture
so the component projects and two
different implementations yeah it's also
very important to reduce dependency
tangle nuts this is one of the things
that really can mock up a project a
product so you got the model product
that's the model project it contains
component entities and and domain
entities which is basically annotated
pojos three and jacks the annotations
and JPA annotations and that the
entities can then transform themselves
into xml and SQL depending on that you
need and then you have to depend on that
so the API needs of course to accept
domain entities as arguments to its
functions and probably omits domain
objects from their functions so the API
has to depend on the model but the model
cannot depend on the API and you got an
implementation which can depend only on
the API and not the reverse way and then
you got the integration tests which can
depend on the implementation to actually
do integration testing the likes of
fitness or whatever you use so you've
got this higher well this rather easy to
understand hierarchy of projects which
works in concert and collaboration to
achieve something in this case well in
this case an X but a cache or something
so this is one of the strategies there
are several of those of course but to
apply usability engineering to your own
you know to your own projects and to
your own everyday work and all of a
sudden you'd probably see a huge boost
in productivity particularly if you have
to enter some area of the project where
you have
been working before now expand that to a
project of 400 developers and you
realize where I am this is very very
cost saving and it's also very efficient
so we'll use these principles to
actually achieve a project structure
which conveys semantic meaning to you
and which facilitates or simplifies our
everyday work all right this doesn't
happen by itself and it certainly
doesn't happen because we have a few
architects who wrote a development
guidebook and threw that on the wiki so
we need to have something to enforce
well we need to have something to
enforce these guidelines and so enter
tooling and now we get to the code a bit
of this session in a while so tooling is
supposed to reduce the need for
documentation enforce if possible and
document if you really have to that's
like right ones run everywhere but no it
isn't really but it that's that the
spirit you can you can repeat try to
enforce it if you really can't enforce
it and if you have to document it for
one reason other than document it so you
can configure all this tooling in one
shared code style project and this one
is supposed to be global so you need a
particular reactor to define the build
where one of the projects is a code
style project where you define things
like configure check style where you
define a lot of plugins or coming to
them shortly
but this is a global dependency and will
be the everywhere used everywhere in
every reactor and the point of it is of
course that that enforces a consistent
development start throughout the
organization and this is a version
controlled definition which is also a
tool usable with every build to enforce
that development guideline not just say
it's a development guideline and through
the document in team place
there are several maven plugins that
exist to facilitate this we'll take a
look at three of them there are there
are gas iliyan so so I'll just take a
look at three of the most important ones
the maven enforcer plug-in which
basically defines it inspects a maven
pub and whatever is done with a maven
dependencies plugins and whatnot and
also external aspects such as JVM
version maven version operative system
worse version or what have you and you
can run checks on it to ensure that your
supposed to run the same JDK you're
supposed to run the same maven version
you're supposed to run whatever and as
we'll see that this is probably the
place where you'll be writing a lot of
custom plugin definitions to enforce
your development guideline to make sure
that you don't have the possibility to
include an incorrect dependency which
would later on
jettison or well threaten the project
the Czech style plug-in goes to the
other level whereas the the the enforcer
plugin took a look at the poem the Czech
style plug-in goes into the code and
make sure you can check various aspects
of the code and the kaabah to our
plug-in in it turn checks for test
coverage so that you have enough
sufficient unit test coverage of your
code alright before I start getting
technical with all these let's see how
many of you have used and configured the
enforcer plugin hands up okay a few of
you good how many of you have configured
and used the Czech style plug-in bit
more and how many of you have used oil
configure the cobertura plug-in roughly
the same all right then I won't skip any
one of them because this there seems to
be a lot of it but I'll go through them
in that's direction on that order
enforcer check style and cobertura and
remember this is an example there are
like a ton more of stuff to to check
so it's really easy to add most of these
plugins to to the build the problem is
that the configuration of all of these
plugins are different from every one of
them so the guy or you who defined the
build cycle and actually the build
process and define how the plugins
should interacts with the code and the
project structure need to know exactly
what all these options stand for so you
need to read the spec sorry no getting
away from it the good thing is only one
person has to do it once and then it
will be applied to everyone so it's just
a snippet of the poem where you define
the plug-in goal so in case of the
enforcer plug-in the goal the relevant
goal is enforce that would actually
start its rule checks and and do the
interaction with a code and the built
and there are quite a few stock rules
which come with the I mean standard
rules that come with the enforcer plugin
like in this case we need to use version
302 or upwards of maven and a certain
variable to find JDK but the important
thing here and this is probably
something that someone needs to do is to
create a set of custom rules these would
be ones define or rather enforcing the
development guidelines you're not
supposed to import implementation
dependencies into you're not supposed to
have dependencies introduced in in
reactor pumps only in pairing ponds and
so on so for each of those you need to
enter a custom rule and I'll show you
shortly how that's done it's not
difficult and then since your custom
rules they are classes so have to be
implemented somewhere and you have to
therefore introduce a dependency to the
project the code style project where you
actually define them all there are quite
a few existing stock rules and I mean
these these are just a few of them there
are quite quite
of them but generally the stock rules
set some kind of exterior boundary they
don't really do anything with your
particular development guideline so you
have to do that yourselves generally and
the process to do this is you create the
code style project that holds your audio
rules and you import the Maven API is
that you require to create these
enforcer rules into the Czech style
project the code style project sorry
and then you implement so one class
holds a particular rule type will show
that shortly and you use just like we
showed this enforcement plugin to apply
your rules in your palms now we took a
look at how to insert the palm just
earlier and we know that we have to
create a project so remains the imports
and what you need to implement this is
the import stuff and you really verbatim
can copy this you need the enforcer API
itself which is the topmost dependency
there and then you need the maven
dependencies so you can do stuff the
import the enforcer plug-in as opposed
to you know dig out stuff from maven and
then use that to to check if you have
dependencies or whatever those classes
are found in the maven integration api's
so what is an enforcer API what's an
enforcer rule well this is the interface
that defines enforcer rule and apart
from the three rather unimportant
methods below this looks like a roughly
like a servlet the execute method
corresponding roughly to a servlets
service method is where maven actually
invokes to check the rule and the
contract is alright it's a void method
so you don't have to return and think
you get this and force a helper thingy
from maven which is the entry point to
maven and then if everything goes well
don't do anything if you find something
that is remiss
Oh a an enforcer rule exception right
this enforcer rule help but thingy is
something you can use to dig out stuff
from maven and for those of you who read
a poem you know that these expressions
actually define variables within maven
so you can actually extract the
corresponding the underlying maven
objects it's sort of like a glorified
hash table right
nothing really strange about it but you
can do a get unfortunately you also have
to cost the objects but no mine that
will probably come naturally so you get
stuff like the artifact ID or all of the
projects and do do things with it and
then you implement your custom rule and
in this case it's a really really tiny
one at last we've come to a portion of
the development guideline saying
project type get project what what's
that well this is something that I put
up as an example because it's very very
useful and something I recommend you to
do this little thing is something that
you definitely have to implement it's an
enum enum czar really good in that they
are very clear with what the valuable
options are in this case it's an enum
defining all the possible project types
and exactly what constitutes a project
in terms of a maven pom so if the maven
reactor encounters a particular poem
which doesn't sort of comply with one of
these definitions then it will break the
built so you always have a well-defined
project type that's the idea now what is
that let's see so it's something that's
really simple in in this case it just
checks group ID as a regular expression
any sorry artifact ID as a regular
expression group ID as a regular
expression and packaging and if I can't
understand if
can't get any of these combinations to
match then it's not a well-defined
project and we should break the built
hmm now this is just a trivial example
but you can see that clearly this is
quite a powerful thing and then you've
got the rather the interesting past
method down here saying get project type
and really doing the whole passing of
the poem and returning eventually a
project type if I don't find one of
these well-defined product types kill
the build all right so there are a
gazillion of these nifty rules to
enforce the development guidelines take
a look at the Maven enforce a plugin
it's really simple but you have to learn
a bit about the Maven IP is to know
things like I don't want to import
certain dependencies okay how do I find
them from this enforcer rule helper and
how do I determine if they are okay or
not but it's not much more than two
methods away and you have the answer so
take a look at it check style more
people had configured and played around
with this so it's not as I'll be a bit
brief of with it just as simple as the
enforcer plug-in to add to the build
reactor in this case the check style
version and it has a dependency upon
yeah the code style project again so
that depended the configuration sorry
for the Czech style plug-in resides in
you can see it over there code style
slash Czech style XML that means you
have the resources here code style Czech
style grant you've got one global Czech
style which will apply to every project
which has code and if the project
doesn't comply with the code style then
check style will break the build nice so
and we just took a look at the codes our
project for instance this is one thing
that has been rather difficult to wipe
out
until we did a trick style rule for it
this rule says it's illegal to have a
parameter return type or a parameter or
a method definition return or argument
to a method to be one of
gregoriancalendar Java util calendar
Java util date or Java util vector
because we want people to use other
classes or other alternatives and this
would break the build in case it was
incorrectly configured nasty yeah but
very efficient so I'll basically skip
the rest of objects style it's easy
enough to do there are hundreds of rules
that you could tweak to really go into
the code and make sure that people don't
format it incorrectly and don't use
incorrect arguments or types and in this
case the last part of it is cobertura
which basically the only really relevant
stuff that could do or does it does two
things it helps you to see the coverage
of unit ists so how big a portion of
your your artifact code is covered by
unit tests right just as you see with
cobertura as with the other plugins it's
just to enter this in the parent pub and
define that it's probably a bad idea to
check cobertura for stuff that isn't in
your reactor so you probably want to to
limit it a bit so that it checks only
your code and you also so you probably
want to exclude stuff that things like
generated code not too much of an idea
to check unit tests for generated code
it doesn't really convey anything will
do anything and then in the bottom
you've got the default rates the branch
rate the line rate which are the two
important things and the fail the halts
on failure which basically says break
the build if the coverage is
insufficient this is really important
otherwise it's just an advisory thingy
and we all know what happens with good
pieces of advice after a few months
particularly when it's really close to
delivery time yeah so there are two
pieces of information to relevant ones
one is line coverage how many percent of
the lines in the artifact code of
coverage are covered by the the unit
tests and the other one is how big a
percent of all execution branches
through the code are covered by the the
unit tests in a in a report from this
plugin you can see basically graphically
rather decently illustrated the
coverages and when you build maven sites
you will get all these reports so it's
very easy for a developer to build these
things locally check it out locally
before committing stuff it's always nice
to have feedback beforehand so it's the
index dot HTML this is a cobertura
report which where you can see the
different coverages for different
packages and if we go into a sample
report it becomes really really clear
which pieces of the code are covered and
which are not so in top of each class
you've got this line and branch coverage
numbers right and to the left side you
can see that there's a well if you've
got eagle eye vision particularly from
in the back you can see that that
particular line was covered 16 times
it's a green number it's okay it's
covered and it's covered 16 times
whereas down here you've got two red
lines one is covered 12 times and the
other one isn't covered at all so this
is one of those things where you tested
one of the if conditions but you didn't
test the other ones so then you always
have to ask yourself when you get
something like this this is a really
good tool did I miss to write the
correct tests all have I written
unused and that well unnecessary really
crap coat should I remove it or should I
increase my tests coverage one or the
other and becomes very clear so if you
mouse over one of these reports you'll
see a bit of an explanation the report
is clever enough to tell you you've only
got 50% coverage here so that's
automatic enforcement and as I said
there are 200 other ways to to to do
this I'll conclude by saying that if you
do this if you have a build process in
your reactor which actually contains
enforcement tools to enforce your
development guidelines then both you
yourselves and the rest of the crew will
probably have a much easier workday so
I'll I have thrown the code of this up
on bit buckets if you want to clone it
but I get so or by mercurial then do so
if you want me to send this presentation
in PDF form just you know come forward
after the presentation and give me your
email address and I'll send it out I
would be really grateful if you could
wait for like a day before cloning stuff
here because I found out that some one
had introduced a bit of a buck no
because it would be really grateful for
it good to do that because it would work
better so there's a proof of concept
turn it send me some feedback and we can
improve it together that's an Apache
license so you don't risk anything by
doing anything right that's it and we're
also spot on time I see
so I guess QA would be in order but
probably outside of this room right all
right thank you so much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>