<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>OpenJDK and the Common VM Interface Project | Coder Coacher - Coaching Coders</title><meta content="OpenJDK and the Common VM Interface Project - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>OpenJDK and the Common VM Interface Project</b></h2><h5 class="post__date">2013-02-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/sk59S4bwmZI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so thank you very much coming to
both 4034 as you can see there's a lot
of people here and we're all dis
participating in this I'm going to try
to talk not too much because I've got a
nice cough and you don't want to have
that so I will let everyone introduce
themselves and I'll run through these
slides but hopefully it'll be
interactive it's above you're supposed
to ask questions and we're supposed to
have the answers sorry excuse me wait
I'll come on ah right so as you've me
you may have gathered there are people
here from Red Hat and from Oracle and
from IBM and from IBM and so there's
only two disclaimers so there's the one
from IBM which is that big and there's
one from Oracle which is that big it's
actually smaller yes sir yes sir all are
yeah but I've made the letters larger so
but basically of course you know
anything you hear here is for
information purposes only etc ok so then
we're going to do a quick soft-shoe
shuffle and I'll let anybody come out to
the speakers I'll do myself first
because I'm here and I'm the second one
so my name is Steve Paul work for IBM
primarily at the moment doing openjdk
work working openjdk on the exporting
project and other bits and pieces so you
posted my name around and I've been
doing Java as I say since before it was
one which is turning out to be a very
long time ago and so that's me I will
hand onto it's just do it in order and
we'll go through that's in the order
that was sitting rather than the orders
on the screen say my name is Neil
Richards I also work in IBM and have
been developing Java SDKs for the last
15 years without any time off for good
behavior I'm also working in openjdk
working on this CV my interface work and
also spending quite a lot of my time
delivering and developing changes in
openjdk 8 and back porting them to open
jdk 7 update stream as well Everywhere's
oh you unless you do is serious you have
to stand up sorry it's all sit down I
make up Michael vid stead I work as JVM
architect in the platform java java
platform group at oracle and
tired I've been working with JVM
technology since back in two thousand
starting on jrockit Derek JVM coming to
our go through the B acquisition and now
working you know um hot spots and
openjdk obviously as well yeah i'm
andrew hughes that has had now been
working on various open source java
things it's about 2,000 for about eight
years old Celia my project i started
before most amount yeah when you open
jdk star before i started red-hot as a
way for us to try and more we had a lot
of JVMs basically that we were using
what was a free java stuff at the time
the new class but when we wandered away
if i make them do it with his new
openjdk stuff the commander so we
started off about well i started often
2008 before starting a traitor now about
Alice just do all sorts of other stuff
stupid openjdk cool so and you just
brought out the fact that we're here
because of him because it's great word
that he did is anyone you were right
about what so what was the motivation
for you doing it Oh basically we had
there was yeah there was a huge variety
beyond 3 m's we had already working with
what was that classified at the time i
open source class very good new class
buff and then this huge mountain of coke
comes long-form sort openjdk and they
all hard trying to figure out how to
work with it so we start looking at what
the vm interface was for that compared
with what we've been using before for
these different VMs and that the one we
had for class back was more maturity
because we had more vm
working with it or not more mature bit
more documented and what we're trying to
weigh in for we will continue okay BEC
simply because we beat out have it out
in the open for years and huge vmware
committee from wee ones that compiled
ahead of time through pure java one's
awesome angel i want to do something
similar voltage it came which is I guess
it just being exposed to men do
housework okay so you start off because
you had a need to try and get multiple
VMs connecting and sharing stuff and IBM
got involved very recently because of
the powerpc up by I export so from our
point of view from an IBM point of view
and you no doubt if you've been
following any of this Judas it in the
press that when I joined IBM joined
OpenJDK one of the things that we said
at the beginning was you know we're here
we're going to work with the community
to make OpenJDK better will work in the
class libraries but we're going to
compete head-on with Oracle in the vm
space and so from that point of view we
then say well actually we would like to
try and get some better definition the
vm interfaces not only so that we can
quietly slip off IAM underneath and pete
hot spot but actually because of the the
benefit for anybody as you'll see you
know the benefit of being out of a new
vm under there is of great to everyone
is the great use to the community so so
we came in and said well we want to help
we want to define this interface and
it's got benefits for us and it's got
benefits for everybody else so I copied
Andrews proposal so I think it's quite
straightforward what we're talking about
during this let's create a documented vm
interface right so it's there to help
lower the barrier for non hotspot VMs to
use OpenJDK class wipers very simple
very straightforward what does it really
mean so if you're there's that the big
idea is there is already interface
between vm on the class libraries and
we'd like to have a nice strong
interface so that you could replace
either component
it's not this is not necessary in a
situation where you take the vm out and
put different vml you may say i have
variations of the same vm or I may have
variations of class libraries that want
to use a vm so its a mix and match
activity so why don't we try and
document the interface so that it's
quite clear what's going on and what the
expected behavior is because I know the
trouble is it's fairly implicit we have
what happens is what happens and
sometimes even the vm developers
themselves don't quite know why does
that but that's the way it is yeah so
let's try and document the interface
let's start to write test cases for this
because that's good helps you discover
the you broken interface you may not
even know existed oh and let's do this
in a way that isn't a restrictive nobody
wants to create TC km j srs or or big
strong specs we want TC case that isn't
the point we're not trying to lock
anybody down what we're trying to do is
make it easy to understand what the
interface is so that if you need to do a
variation of one side or the other it's
just a little bit easier to understand
what's going on reasonable yeah cool so
those this is the the big idea in
pictures so the the little round things
at the bottom with little black things
on top are in fact meant to be academics
they're intervie mortarboards but it's
not clear that's my art so what we'd
like to do is take the on the left
you've got this sort of brownie color
class library which matches the color of
the back here but that was thanking
incidental so you've got this amorphous
class library you have some sense of a
vm right and it's a bit like in many
ways this is very much like the boundary
between the country in the city all
right you know exactly when you're in
the center of the city and you know
exactly when you're in the country but
you're not quite sure where the boundary
is and depending which direction you go
you might be different so that sort of
boundaries a bit wobbly so we'd like to
move towards having better definitions
of
boundary whatever it is let's just start
to draw some lines let's make a few
people happy and then let's move towards
actually eventually having a well-known
interface so what that means is more
than just discovering it it's also
saying in a few places eventually which
is that's a stupid way of doing it let's
make it better this make it clearer and
so eventually we would end up with a lot
more happy people and but then we'll
stop right there is a point where you if
you go too far you end up with massive
specs and you have lots of documentation
that needs to be kept up to date so
again this is a primarily a developer
focus activity we want to make it easy
for open dedicate community members to
go off and do their thing and you know
so if we're not looking to write a book
we're just writing try to get some
documentation and test cases together so
why is this interesting and how do you
benefit so separating the vm from the
class libraries I has a pretty pretty
good thing to do it may not be obvious
but I think you can look at quite a lot
of scenarios and academic ones are very
very obvious set where you've got people
who want to go off and write their own
vm and if they could have if they knew
they could take the class libraries from
OpenJDK and write their little tiny vm
there and they knew what the interfaces
were there to implement and what they
had to do and their test cases for it
and they'd be you know what to do
running around it's it is important and
it's the academics who are the guys who
go off and figure out what the new
things are they're supposed to happen in
the day and they're the guys that go
from leave these things and come back
and say I have this great idea for a vm
that runs a water and it's you know and
you were trying to help them innovate
there's other reasons I mean it's but
it's generally along those lines of
let's get these these make it possible
for people to innovate and collaborate
make it easier to understand what we've
got right and if you've got increased
collaboration and you've got increase
innovation it's good for everybody and
it says his wife
all right so why would you you know
beyond just making easier to understand
it actually helps you tease our
architectural things so you get your
going to get better in you're going to
get better interfaces because you're
going to find unexpected dependencies
you're going to find unexpected areas
that nobody really thought about and
that are historical I think the word is
Croft is the idea it's stuff that's that
you've just you if somebody put it in
there 10 years ago and then suddenly you
found it right and and i can not
specific on this but i can point to many
many examples in the in all the years
i've been doing development where you
sort of open the box and you go what is
that where did that come from you know
when you go back through history and you
realize what it was therefore or so but
that's the thing it's this exploration
understanding going back and figuring
out what happened working out where they
still needed and dealing with it what's
that mostly your own code no I'm yeah
right I'll tell you later yes there is a
limit here so if we can get these other
separation that going then we've also
got the ability to start hiding things
and Stannis you know it's those sort of
thing you wanna interface you can what
the encapsulation can be made better so
you don't need to share this code with
this component right you may have done
it in the past you don't need to do it
so we can work to make it again easier
and actually in many ways that may
actually be beneficial for people like
Oracle who produce in variations for hot
spots even on a day-by-day basis you
know just be our to make things like the
better and just bring clarity to what's
out there now the third point on here is
actually is actually asks all right this
is IBM this is one of the things that we
would like to help so we have lots of
developers the we have vm developers we
have class library developers we would
like to get them involved in openjdk
right but it gets a bit strange when you
sort of descend from the heights of the
class libraries and you get down to the
vm end all right so we have vm
developers the vm developers that we
have are loud
look at the code for hot spot because
we're competing right it's that sort of
thing so when it gets close and we want
to start talking about this relationship
between these classes and these these
this part of the vm it gets complicated
lawyers get involved and things like
that because it's not clear what's going
on or what the behavior is because it's
fluffy so if we can help clear up some
of those issues and believe me they're
not this is a rocket science and we'll
show you the sort of things we're
talking about later it's not rocket
science but it can get that clarity then
from IV end point of view we can get we
can contribute in more places which may
not be much but if we can and it will
probably you know help other people to
do the same as well yes and common
documented interfaces improve
communications between component
providers whoever they work for yes so
you means that the VN team and the class
rugby teams can talk in a more clarified
way they're not going another interface
that does that weird thing you know it's
like no this is that behavior that we've
written down about it doing it doesn't
do that anymore I have a test case
you've broken me right and you don't
want because I tell you the number of
times you end up having conversations
with with one side or the other in those
circumstances and the co no it's meant
to do that no no no this is weird
circumstance and think I know that's
what it meant to do and you go I didn't
know that so will document it and that's
the intention right so other benefits of
increased innovation so we're talking
about evolution of hot spot so as I said
you know academics coming along and
taking hot spot in new directions so if
you can enable more innovation by making
it easier for people to get going by not
having to keep worrying about these
these gray areas then they will they
will produce more stuff and we see this
being something you could do not only
arm for people producing brand-new VMs
but I'm sure there are cases where from
Michael's point of view it just makes
slightly easier even if you said what's
the difference between yesterday's
building today's build on the interface
level you know it's a bit clearer you
know it's the I've changed an interface
that I now know is an interface not I
changed something that I didn't know
you're depending on so you know things
just get better for qiyam hotspot this
is sort of thought of the inverse where
you've got somebody who was take hot
spot in a different way again they now
understand the contract that hot spot
has with the class libraries and if
you've ever looked at the contracts if
you look at the interfaces that you that
the vm puts out like Jay and I and stuff
like that there's only a partial part of
the interface between the vm and the
class libraries there are other
interfaces that are not Jay and I were
there Jane I interfaces but not part of
the jay and i spec and you have to one
of those so if these guys know what that
interfaces then four key hotspot and
doing their own thing again is just a
little bit easier support for multiple
JVMs that'll be things like j9 that
would be really cool yes so if we're in
there right if you've got really have
got j9 and hotspot competing head
forehead which is good for OpenJDK it's
good for everybody to have that sort of
commercial relationship going on in that
battle it just makes it even easier for
us to compete actually and that's good
as well and the final thing which is
sort of a ancillary but obviously
important is that it's just another part
of this carving up the sdk into pieces
and being clear about the component
ization and the lines between those so
you know given where we are with
modularity becoming more important just
just quite in a clearing up the lines
between things is just just another
important piece so all these wonderful
things we could do and how do we plan to
do it well there we are it's quite
straightforward let us discover so
that's taking together all the
information that we have that's looking
at into the looking at particular files
and just starting to document so
discover the interfaces document what we
find and then eventually enhance them
make them cleaner right but as I said
I'm sorry architecture asteroids need
not apply so what that means is pride
or pragmatic solutions we are not trying
to create the best interfaces F up which
I entertain interfaces we have made them
cleaner make the more understandable but
not rewrite them this you want to take
that challenge no no so discovery how
we're going to do this well the first
thing to point out is that obviously the
interface between the variable in class
skybridge already exists but it's fluffy
you know and whose view the person so
the vm teams view of the interface and
the class Toby's view for the interface
and the IBM's were the interface or not
today they're all different so we need
to go out there and start looking for
stuff and there are some of your places
so it's like sprawy exploring a map
looks go looking for the Dragons so you
start where you live and you just keep
moving out so the obvious things are
both versions of our so you're both
versions of JVM 2h why do you have two
versions of jbh Michael so if i remember
correctly there's a few defines in one
of them essentially that we don't want
to have in the on the jdk level so it's
a JVM dependent thing so why do we have
me I think you know it's one of those
files that obviously is publicized in a
weird way and therefore you know we we
don't want to mess up the one that we
use to compile the JDK we has we need
another one to actually compile the JVM
okay and is that documented those
reasons yeah yeah no it's not yeah
that's fine okay right no no exactly
yeah yeah good example so my
interpretation on on there being two is
that one is the contract that the that
the class libraries require to be
provided by the vm and the other is the
contract that BBM provides so 11 needs
to be a subset of the other it's
confusing that they called the same
thing
right yeah so there's just a first step
and then we've got vm specific classes
so you may not realize it but there are
classes that are right down the edge
that are absolutely intrinsic and they
are vm specific what that means is they
would not function using it against a
different vm so we would like to pick
some of those and the boundary between
that class and the vm might be the right
place to draw the line you might say
actually we're little bit of a tweak
this class could be reused or you may
say actually the vm interface is above
that and now that class is part of the
vm interface or part of the vm so to
clarify that there's there's some quite
good document description of or at least
list obviously in the vm code about what
aspects of objects and classes it
reaches into but as a developer in the
class library that tends to be not so
much indication about those classes and
those feel fields in in classes that the
vm relies upon so as a naive class
library developer one might come along
and decide that you know our field could
better be named something else or more
clearly name something else do some
refactoring and then cause a whole heap
of trouble because that happens to be
something that they're the vm relies
upon yeah so getting getting that the
not not only the relationship of what
the vm needs to provide the class
flavors but also other class libraries
need to provide to the vm is it is part
of this yeah valuable yeah I'm work and
that sort of touches on the next one
about JVM dependences and class
libraries so that's unexpected places
where the vm calls back out to the class
libraries you know
and it's just you go what's going on
here and it's just one of those things
you know it's there are there are
reasons why some of the code you want to
use is is in the the class libraries
because it might be written in Java and
you know you've just got those
interfaces so knowing that you've got
that dependency is fairly important then
we've got other items here so like where
the dragons really are so I've listed J
commander late attached late attaches a
big bug bear for us from IBM point of
view because it's the it's this you know
this latest diagnostic thing you the
interface to it from the boss sort of
right the highest I'm review is a java
package may it's a hotspot class name
and then you then get into java hugo
java code then you get into c code and
then you talk to the vm but actually a
lot of the c code you talk to is built
using hotspot c++ headers and things
like that so it blurs very very quickly
so what we'd like to do is go well it's
late attach vm specific in which case
the interface is at the top or is it
actually lower down is it actually you
could take out the hospital the late
attached code and draw out draw a line
and say that bits part the class
libraries that bit spot the vm the
reason that's important and late
attaches a good example is you have to
work out which code you have to
implement so if i could work out from
whether the late attached code in all
its gory detail is stuff that i could
reuse that's great but actually if i if
i doubt i can't reuse it then that's not
so great at least I'd know and there's
some sort of things we want to talk
about and then going even further more
differences so these are just the really
subtle things like as we will put the
signal handling and registration on
there which is about you know it's just
one of those little things is different
let's try and fix it or at least agree
with its but what but suppose should be
happening yeah subtle behavior
differences in JDM specs well again
there's loads of those but we just want
to just pick out the ones that we think
are worth discussing in overtime and fix
them and then our java invocation API or
as to why we put your implication in the
ago and that's an interesting one
because the java invocation api is
actually defined as part of the jni spec
which is which is kind of the part of
the vm behavior that is that is
allegedly defined under by real solid
specification the and it does specify
the behavior to a certain degree but it
doesn't there're there's still enough
space in there for four ambiguities to
force their way in so in particular
there is there is a at the moment a
difference in behavior between a bit
between our two VMs on how options are
handled where if they're passed to the
implication API to create a VM for
options which caused the vm to print out
help information and then and then the
question is over what the behavior is
once it's printed out that help
information so in the IBM vm case it
returns back to the caller of the
invocation api to say the vm hasn't
started and
and there's some indication that hasn't
started because it's printed out to help
help information the hotspot p.m.
currently decides that once it's printed
out information that's a good point to
end the process and calls exit to end
the process and that's kind of that's a
interesting behavior difference if you
are looking to if you're if you're if
you have a process which is calling the
java invocation API as part of some
larger running process obviously that
becomes really important to you because
because unless you're unless you're
adequately fielding and filtering the
options which are being passed into that
invocation then your large process might
might suddenly go away so these over to
vm implementers have you know have earth
are lighted on different solutions or
different approaches in that particular
scenario and so as as we can discover
these things so say that kind of
initiate conversations about how how we
might come to a more common agreed
approach in that in that situation and
and how we might migrate from where each
each implementation is at the moment
towards some or third one yeah to a
George do you correct behavior yes yeah
okay so and then we've got gray areas
but what that really means is other
areas which we haven't thought of ya
okay there are lots of them and you know
their list different sizes but so you
tend to forget to be honest you write
down things and you deal with it and now
that we're coming back to OpenJDK we're
going oh yeah I remember that one area
we talked about that one yeah
ok so I'm 12 this is remind me so i want
to show you the doctors and stuff so we
talked about documentation so that was
the discovery maybe i can make this work
so i guess we should have a few words
about doxygen itself so for our for for
the purpose of documenting the
programmatic interface that the class
library class library relies upon from
the vm there are they fall into a few
categories there is there are the
interfaces which are defined by the
J'naii specification itself but then
beyond that there are extra they're
extra sea level functions which are
provided by the vm to to the class
library code for the SDK and they are
they are contained in or they're defined
in there in the JVM dot H header file
some of those have some amount of sea
level documentation in there most of
them don't and just have just have the
names of the functions that are there so
for those for those interfaces as for
those functions we have chosen to to try
and and create a set of a create
documentation for their current behavior
and we've chosen to use a technology
called oxygen to to create that
documentation such that and oxygen
basically does to see files what javadoc
does to java files and that's what one
the main reasons for choosing doxygen as
the engine is because the the type of
comment markup that you can use you can
use other forms
ford oxygen but one of the forms that
you can use is basically looks exacting
like javadoc and we felt that the
developers in OpenJDK would would wonder
that more than there any alternative so
look ish similar doesn't look quite like
javadoc the yeah I know you mean so this
is the before you know you can tell it's
very good it tells you all sorts of
interesting things like the name of
files and the name of methods and then
if you had documentation in doxygen
style so it is the same as javadoc as
near dog stood style tags that you embed
in the c code yeah in comments in
exactly the same kind of way as a
javadoc it's it's javadoc style comments
which are which you put place alongside
the elements that you want that you want
to document so it's worth pointing out
in the in / 4 case that this that what
we're looking at is the HTML output from
doxygen by just pointing configuring
doxygen run to look at the at the header
files which are in the jar java vm
export directory in the jdk repository
in OpenJDK so and you can see that there
are their foul thousand links for files
and data structures in the frame on the
left and then we're actually focusing in
on the some of the some of the methods
that are defined in the JVM dot H
interface it's actually generated stuff
it's generated entries there for not
only for the things which are in JV mph
but also for the things that are defined
in jay and i dot H because one builds
upon the
so our primary focus is on is on
fleshing out the documentation of JV m
dot H and the methods there we don't
have a real focus on on capturing much
information at this point for the jni
define methods because they're defined
by the J'naii specification they're
better there there you know very well
documented elsewhere but it's it
provides quite a useful mechanism for
actually being able to navigate around
and and understand the under standard
structures and the and the links between
the structures even before you start
fleshing things out with with the you
know Hector extra documentation and
talking of which so I will shave the
second version well I'll just I'll just
speak into the difference there's JVM
register signal at the top and there's
JVM register signal with information I
can't guarantee to the accuracy
information because I didn't add it yeah
so this is this is something like that i
brewed up a few days back so in the case
of jayveer months ago register signal
there was a pre-existing see comment
block in there so i captured that and
incorporated it that's the text which is
in the kind of first paragraph that you
see it soon yeah okay so I current and
then just commenting up on the parameter
types going in and the return type
coming out just as you would with Java
doc and then capturing the information
that you know that is scattered around
the place just on the vm side of the
interface and also in the in the code on
in the class library side of it which
makes use of this interface so i just
like to a quick straw poll how many of
you prefer
this version okay how many of you prefer
this version good thank you right okay
so they switch back so I sort of pretty
much said what he says one neil says
using dachshund generate javadoc style
prey pages proof of concept in the CV my
project that's quite true but it's
almost there yeah I'm still need to
still need permission to actually shove
things directly into the sleep in my
project that's right yes but you can see
when checkout is once you've got this
tool you can start adding stuff in like
annotations and things and it makes it
just easier we can start tracking it
because you've got some documentation
that you can see things getting better
so that's that's basically that's where
we're aiming yeah we're making changes
initially in the CVMA project because we
don't need permission many people to do
that but it's a it's a socialized
socializing thing to basically just get
the people you know get the people who
look after the main line 22 to accept
that what we're doing is is isn't isn't
scary and then accept the changes so at
the moments the changes that we're
looking to make is in the JDK repository
side of things I guess starting out we
weren't really sure whether we might be
making some changes in the in the
hotspot side of things and certainly in
that kind of circumstance it's easier to
float the changes in a in side project
like CBM a rather than trying to argue
them in directly into the into the
hotspot code in the mainstream so the
last thing on the on the list was the
enhancing so I will say a game we don't
expect this is meant to be a radical
thing they say we're not defining a
brand new interface it's enhancing means
clarifying behavior and that's that may
just be just writing the doc it may be
refactoring unexpectedly vm specific
code and that's the likely like you're
saying about late attached there are the
more subtle places where you go there's
a piece of code here that doesn't know
like it's for in specific but actually
is and maybe we can tweak that to to
separate out to just draw the interface
the barrier the boundary between the two
in a slightly different place yeah there
are there are quite probably situations
where code has been provided within
as part of the vm because it
historically has been easiest to provide
it from that place where the code is in
some way architecture or or platform
specific but which doesn't really have
any other any greater justification for
the vm actually needing to understand
about the particular piece of function
that getting provided and in those
situations maybe we can look to think
about splitting this out and providing
it as native libraries under the class
library such that alternate vm implement
implementers or people who want to play
about with with developing the vm kind
of have a have a smaller smaller target
to aim at so you end up with more shared
code across people who are who are yet
different VMs and that the last one
obviously is if we think that we can
have the conversation provider fix as a
bug then then we'll try and do that as
well so okay so just wrapping up to the
output we talk about doxygen so
obviously that's brand-new that doesn't
mean that's the only place we would
write stuff we will be looking to
improve the Javadoc stuff as well
ultimately personally that I'd like to
see is ending up with a document that's
like JVM TI or you know those sorts of
things where it's not that the interface
is listed somewhere in a bit points off
to other stuff just so that it's clear
so that we can go what so sorry says
what's the interface you can always
start here and go reading interface
tests that would be very good if we
could start to build some tests so that
these guys are implementing their own vm
or whatever have some things to just
prove that these at least that level is
is it's working and if you are on the vm
side having some really simple test
cases to show that you've broken
somebody else's behavior or you've
broken dependency then that would be
good there's a list of classes and
headers that make up the interface or on
the edge actually be on to tell people
this stuff here isn't it is part of the
interface if
change one of these you should be
thinking about what you're doing and
what the consequences are and that's
quite useful to you had to question no
not yet we're open to suggestion that's
a bigger question so finally so the Duke
needs you so we are looking for help
because this is a community effort
helped to improve the documentation find
areas that need to review so that's one
of the things is just finding those
areas it helps for people saying IBM's
Jane I works like this and hot spot
looks like this that's fodder we can
look at it and say oh actually acquire
right let's go off and do it I can see
some of this stuff you know feeding back
up the chain one way or the other and
saying why are you different okay fix it
you know and so we might better get some
of the behavior the gratuitous behavior
difference i would ever you know the
fantastic performance improvements but i
mean just that little tweaks yeah we
would like kissing to get people to just
say these sorts of things when I first
hear sound I suggest note implementation
specific behavior you'd like to see
standardized yes so that if that reaches
slightly beyond might reach slightly
beyond saving my itself but is mate is a
related kind of related aspect so
obviously you know part of part of the
behavior of the of the SDK is that is
most well defined I think are things
like the behavior on the Java API
and so therefore the variation in the in
the vm behavior that's that supports
that those functions is likely to be you
know least however you know that there
are other function there are supporting
functions such as which which though
people shouldn't use they reach out and
and use at the moment so you know there
are historical classes under the you
know under the Sun Sun packages that
that we know through customer feedback
people make use of and because they're
not defined by Java you know as Java API
those are areas where sometimes the
variation in behavior between between
the the vm implementation that that
underlies those is there's greater
potential there for for the behavior to
be different now moving forward
certainly when modularity comes on the
scene the there's an even greater risk
of that that those kinds of non-standard
classes that that nevertheless your
application code may be relying upon
will disappear from underneath you and
so it actually makes a lot of sense to
to try and to try and flag up those
those areas of function which aren't
currently provided by their by their
java api but that which but but which
use developers and users of Java are
currently finding useful to flag those
up and to and to try and point them out
and to engage in in openjdk and try and
argue towards those those things being
standardized so it's the it's the non
standard non standard non API is that
that people use that that really know we
should be thinking about collective we
should collectively be thinking about
providing a Java API standardized
version of that and as part of providing
these new standards that will flesh out
you know in the discussions of actually
what the stat what the standard should
look like and how it should get eight
that will flesh out that will flush out
differences in behavior between between
different implementations yep okay so i
think we're Krista time so I should
invite the other members of the the
panel to to say anything they wish to
say other than that like an IBM proposal
so Michael if any of you like today all
right so from my perspective I think
that what you know I I encourage more
documentation i definitely encourage
more testing of api's in general code
you know functionality we have I think
you know the I was the one adding very
late in this presentation the extra
picture with the unhappy faces in the
big cross on top of it I think the
important part for me is really that
there is a point where we have to draw a
line and say that we can't go further
than this because at that point we'll
start you know inhibiting innovation
instead of encouraging it so that that's
kind of the key point from my end is
that I want to have more documentation I
want to have more tests but if we get to
the point where we have a specification
and you know where you know they're
there are boards we have to go through
and voting and what not to make a change
in the FBI
yeah exactly i'm sure you would love
that no i think we all agree there that
that's taking it too far in that case we
have you know we have made you know set
up a barrier for ourselves and for
everybody wanting to work on the
platform so you know we I think we can
improve on what we have today but we
have to be really careful not to take it
too far ya padri yeah well it's to say
is happening because other day this is
what not to see from the start on their
first of all this kind of project and as
a sort long-term go from here be a
cubicle useful as up all the sort vm is
working in the same class like if that
means some of us we have you for people
working with us i preside means all the
people are working to say on those were
working on books on the same one and
that office in works things into the
same class laughing yeah okay in any
questions wolke sorry i can name it I
come out everybody their info please
we believe it
events as well with it string chains and
you fall away from this done as well
right so I think the question is
basically is it a goal in itself to keep
a stable API so that you can take a hot
spot from a let's say later JDK and put
it into an older JDK essentially you
know keep some kind of compatibility
there I think the one of the reasons why
that model came into place to start with
was the fact that the JDK wasn't raised
you know we have jdk six coming out for
five and a half years I think that or
something like that so clearly we still
wanted to keep innovating and pushing
out functionality on the JVM level and
the only vehicle we have to deliver
those features was the jdk six train
with that changing now and jdk 7 j
decades actually coming out you know we
have a regular release schedule for the
data case that's less of an issue that's
that you know recent goes away to some
extent the other thing is that I think
we want people to pick up new versions
of Java so you know part of the reasons
for you know sticking on an older
version or whatever you know we really
want people to pick up the new
functionality get the Pinot the language
features the performance features and
all that and and it's really what you
know we're working hard on maintaining
backwards compatibility in Java from an
application perspective so it shouldn't
really not be a big thing to pick up
newer versions of the data k now so that
all said I also think that there it is
hard to keep you know the innovation up
if you constantly have to maintain a you
know compatible API or you know an
interface to the JDK classes not only
for the same major version of the data k
you're working on but also for you know
a few before the next major version for
example or even for you know 6 and 5 and
14 there are out there today so it's a
trade-off for sure I think you know
again one of the the biggest reasons i
see for that model coming into place at
all was the fact that to dedicate
you know didn't please
in solution enemy
okay right so I mean we have this
problem internally as well pairing out
the inversions with dedicated level
versions of things and I think in
general with chef and points out I think
that's what we need to you know that
that's the problem we need to solve any
way i should say and i think as we solve
that will have removed some of the
barrier of doing what
cops never
a lot of stuff
I think I she just point out where we're
five minutes over so from now on you on
your own time thank you thank you very
much thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>