<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>WebSocket and Java EE: A State of the Union | Coder Coacher - Coaching Coders</title><meta content="WebSocket and Java EE: A State of the Union - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>WebSocket and Java EE: A State of the Union</b></h2><h5 class="post__date">2013-02-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0wfkn0ros0E" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is justin lee i'm currently a
senior software engineer or a senior
software engineer for a square space
I've been doing Java since 96 but more
importantly for our purposes this
morning i am the implementer or the
original I guess someone else does it
now of web sockets port in glassfish
class efficient grizzlies so if you use
the Grizzly web socket API it's my fault
for better for worse so i'm like i said
i met Squarespace now i'm but i'm also
on the web socket jsr expert group
helping out with that so that is without
too much whatever i'm going to go
briefly over why WebSockets without
going too deeply into it because there
are happily there's like a thousand
WebSocket sessions so hopefully most of
us are familiar with it but for those
who aren't i did one at least cover some
of some of the motivations behind it and
so it all makes sense and essentially um
its response to you know HTML HTTP
they've been around forever and we've
kind of shoehorned a whole raft of new
types of applications on top of it that
is never really intended to do there are
certain costs that you pay for doing
things even like ajax and comment and
whatnot on top of HTTP so so web sockets
attempts to address that HTTP is also
stateless because you know as you know
you make one request it comes back and
then the server's done with you yet you
get a session data and you can put stuff
in there but you slept them in and set
yourself and it's getting increasingly
complex our applications have as the
time goes by and HTTP hasn't quite kept
up with everything we want to do so
people started looking at alternatives
it is I don't know if I have it on this
slide or not and it is a web sockets is
built on top of HTTP so your web servers
your router's your gateways it'll all
look like HTTP traffic coming in but
once it makes it through all the rod
owes to the servers it stops being HTTP
um so and there are when people talk
about web sockets there's actually a
number of different components to it
there is a wire protocol which is the
actual bits and bytes on on the wire and
that's handled by the IETF and that was
recently ratified this summer as a
formal specification after several years
of development but there's also the
client side as for at least in the
browser the w3c is managing that
specification I don't think its final
yet but it's stable enough that browsers
most the browsers support it and we'll
see in a second here so probably any
browser you care about now unless you're
an IE fan will have support for it so
there's the JavaScript API and then GSR
356 is an attempt to standardize that
and i was i was talking to Greg Wilkins
who was also on the expert group last
night and the thing I like about this
now I actually pushed for
standardization for a year to when I was
still at Oracle because one thing that I
did want to have happen is if you ever
do comment development and you have to
figure out what platform you wanna work
on are you working on jetty or you're
working on Tom can't you're working on
whatever and you're a common application
then has to change depending what you're
working on and I really wanted to get
web sockets standardized from an EE
perspective so you can at least build
your application once not have to redo
it for everything for everything right
so piggybacks on top of HTTP like I
mentioned it uses the connection
mechanism in the header if you're
familiar with HTTP header negotiation
there's a there's a couple header as you
can send to ask for an upgrade and then
the server can either upgrade it or
reject it if it doesn't know how to
handle it but what WebSockets gives us
is it gives us a nation Chris
bi-directional communication channel
it's full duplex so once it's once it's
open you can keep it open for as long as
you want and both sides are free to send
messages back and forth it is not
request response anymore so like your
traditional servlet model isn't it's not
quite the same because there is you may
not ever have a response when your
request goes out and similarly you may
get a response having never sent
something out asking for and
it does support extensions more or less
it's not as well baked they're still
kind of work in a house I'm not supposed
to work but the most common extensions
are talking about right now there is an
active discussion on multiplexing in in
the the protocol now right now if you
have multiple things going on in your
web browser and you want to open a
WebSocket connection unless you build in
multiplexing yourself each connection
would be its own connection to the
server which is mostly kind of okay but
of course that doesn't scale because you
know you might have eight million
connections coming in at once so
multiplexing will help that and then
there's compression there's actually
compression in the in the and this RFC
as it is now and it's / I think it's per
message and they're looking at per frame
compression which might matter to some
of you guys but the compression scheme
is probably going to change in what the
like the standard compression is but
that should hopefully mostly matter to
people like me who are trying to
implement things like that and it does
have support for sub protocols so if
you're writing an application you can
say I want to open a WebSocket
connection but I want you know I need
the payload to look like this so you
specify you know I want whatever your
protocol might be whether it's chat or
email or kissing for example has JMS
built on top a WebSocket so you can
tunnel all your JMS stuff through
routers and what that can open I'm
getting a bit port and web sockets has
support for saying this is this is what
I want to do okay so on the client and
like I said most browsers now support it
so if you want to start playing with it
chances are your browser is going to be
okay ie9 does not have it 10 I have yes
because it is it is Microsoft and they
have not traditionally played and played
nice with most whether it's CSS or or
whatever but the nine in ten teams do
seem to be a lot more receptive they
figured out it's like we don't own
eighty percent of the market now so we
have to actually care what our users are
telling us and they've actually seemed
to be like really really receptive and
proactive out making sure they're
interoperable with stuff firefox and
chrome had
forever since version 14 I don't even
know what version of Chrome online
anymore i think it's 23 because i just
updates so chances are if you have
chrome it's working so far as had it
since six if in the mobile world it gets
a little spotty ER because those
browsers are kind of on their own
timeline but firefox in chrome both have
it on android the native one does not
yet which i don't quite get because i
would expect the native to be some form
of chrome and then on all your on all
your I things it's getting there I'm 66
might have it I haven't looked at it
since six come out because I just
realized that like a month ago so not
all your clients need to be browsers and
that's the that's the one thing i like
about web sockets is at least in the
protocol level it's not tied to a web
browser environment so you can actually
write clients in java the Grizzly api
actually has a WebSocket client so if
you want to write clients for whatever
reason and there no reason to you might
want to do that so you're the other in
might not be a browser it might be might
not even be java so on the client you
have you have a couple of options you
know you can roll your own there's a
project called atmosphere that we'll
talk a little bit about later if you
haven't seen that it's actually really
really nice it is kind of an abstraction
layer so that whether you're writing a
common application or now websockets you
can write to the atmosphere api on the
server and the client and it figures out
magically what your deployment platform
is and then if you'da plan on grizzly
it'll figure that and wire it up but
your application isn't change because
atmosphere takes care of all those
changes for you and then of course
socket jae suk at i/o if you're a
javascript guy did you all sorts of fun
stuff in socket i/o on the server side
options there's actually that's this
isn't even all of them this is just kind
of a brief spectrum autobahn is actually
kinda nice it's Python audubon is
notable they have a very robust very
thorough testing suite so if you need to
validate your your web socket
implementation audubon will hammer at it
and tell you what's wrong
j WebSocket is out there I don't know a
whole lot about it but it's one of the
earlier ones that I member seeing pop up
causing of course has it and they have
their web socket gateway it's in Nettie
jetty glassfish and grizzly of course
and i mentioned websphere webbot is
built by one of the expert group members
and i don't think it's actually in java
and even though they got here what it is
typically a java guy ethical it's
written in but but we're going to focus
on these today because um these are the
ones that I know and we can't cover
everything so we're going to go over
these and just kind of see we're going
to take a look at each of their api's
and how they differ and then we're going
to end up looking at what the current
state of the the jsr API is and we did
just go into early draft review which
means there's Java Docs and PDF and the
specs so if you're one to figure out
what it is now is the time to download
it and look at it because the API is
still in flux but obviously is a process
goes along the chances of you getting
something tweaks because you don't like
it becomes less and less but that is out
there so and then after that I want to
talk a little bit about us speedy when I
first saw that I just like oh it's
Spidey and I know it's not Spidey but i
like to call it Spidey because it's more
fun but it is speedy is the official
thing so if i call it Spidey I'm not a
total idiot partial one I just like to I
just like to call it speedy because it
just sends more fun and then HTTP 20 and
those those are both broader views of
what basically WebSocket protocol was
meant to fix so grisly in glassfish this
is the one that I built so it's the one
that I love the most I I'm slightly
biased toward it but I try not to be but
here these are the main components you
need to know um haven't even done
comment development on top of glassfish
our grizzly and when I built this I
don't like doing clean room stuff
because you never know what's what makes
sense out in the world but in your head
so I based my API on how the common
engine
so if you've done comment development a
lot of these will look familiar but
there is a WebSocket engine which is
exact what it sounds like and there's a
WebSocket application which is really
where like all your application logic
would would exist there's a web socket
which would be the actual connection
that represents an endpoint on one side
or the other and of course there's a
client and and i added i added the
concept of a WebSocket listener because
I it sounded like a good idea at the
time but as I worked more with API and
built my own applications and whatnot
the listener made less and less sense
but it has has certain possibilities
that you might want to use but i think
the api had evolved to the point where
it was a little bit redundant it was my
problem with it and if you're on
glassfish the last thing you'll need to
get your application going is a servlet
that's not strictly true anymore because
another team somewhere in the bowels of
Oracle is actually starting to work
implementing implementing WebSockets in
the container in a more Java EE as
friendly environment so that actually
there are actually deployment
annotations now that we'll see but all
my examples if you go i have stuff up on
github all my examples you just serve it
because that's how it worked when i
wrote that code two years ago so what
does what does an application look like
this is the list of the interface and
there's a couple of methods not all
these you need to care about but on
these the potential ones create web
socket and if you want you can override
it and for example in when I would write
demos I would subclass create web socket
and under turn some sort of subclass of
web socket and then you can put on
things like if you do in for example
like a chat because everyone writes chat
examples that on that's where you would
store like the username and password for
that particular endpoint any sort of
state that you want to that you want to
save about that particular connection is
how is how you do that there's on
clothes and on connect and those are
just callback method so whenever
whenever WebSocket connection comes in
and you want to do something when it
connects edit to a session or validate
this or that or whatever you would
override on connect and handle that and
the one you actually absolutely have to
is called is application request and
it's admittedly a very upwardly
method them but it's basically where you
would check the URI coming in saying is
this something that this application is
intended to process or not and if you
return true on then the web socket and
hand shaken and such take off in the
load up your application the handshake
you can sub class if you want and most
of you probably will not want to do that
unless you really know the protocol
because that's when it starts to and
there's bit shifting and masking and
weird things to validate that the
requests coming in actually is a
WebSocket connection and most of them
you won't want to do that but some
people want to be able to for example
sim pack cookies or a session IDs or
whatever back to the remote client
whatever might happen to be and you
would do that in a handshake because
that's where that response gets sent
back and then on error is a handler if
you want to do if you want to check
something when an error occurs of course
so this is the the interface in grizzly
to add a little bit of help in building
this interface but it looks basically
the same if you did grizzly 19 so there
are send methods there's pings and pongs
as part of the protocol and those I
don't know that a lot people really care
about most of them are used for like
heartbeats and make sure that are you
still there are you still there but
there are certain spec requirements in
an implementation about pings and pawns
and responses but you can you can hook
into that if you want and you can stream
data back this is a little this is a
little lower level then we'll see once
we get to the jet the jsr API when you
send a WebSocket when you send WebSocket
data on the protocol it will break it up
into frames and those frame size will
vary in that frame that frame size can
actually be changed for you like an
intermediary can come along and say
you're sending this for Meg chunk but I
really only want to deal with 128 k at a
time so it will actually fragment your
message for you and when it gets to the
other end it will come back as fragments
so that's what those methods are and
there's that there's a bit that gets set
when it's the last framing that comes in
and it's a little lower level then I
probably build it now but again it made
sense at the time and we'll see some
better API is coming on and then is
connected that it does exactly what it
sounds like and then here we have actual
call max on the web socket and these
these callbacks are unlike the comics on
the on the application which happened
for anything that happens with with your
conversation these callbacks deal
specifically with this particular end
point so when you get a message on
message will come and there's a couple
of variations string and a byte array
you get a non fragment if you come back
like I said if something had fragmented
your message and it'll it'll show up in
on fragment instead aman message on
clothes when you if you want to handle
detecting the other end drops off for
whatever reason you want to clean up
database connections or file open files
whatever you would do that on ping on
pong or there in case you want to be
able to hook into that and then you can
add WebSocket listeners and remove
listeners if you want and we'll see that
API it actually looks a lot like the
WebSocket itself which is why it's now
it's a little redundant but it's still
there and so this is it's it's not quite
as bad as it looks like but this is how
you would set up if you're doing
straight grizzly code you would create a
WebSocket server you'd give it you know
an address and a port and then implement
these two pet care whatevers this is
actually from a unit test which is I
pulled out of the actual source quartet
of grizzly and because it's a it's small
enough to at least give you a feel for
kind of what's going on this is actually
just part of basically a pain test and
in this case i'm waiting whenever I send
a ping from the client I'm waiting and
then there'll be a latch countdown so I
can check and say yes that ping arrived
and we did a perfect i call on ping and
then everything's done and then the same
thing on the bottom you can see the
client we create one and we do a non
pong because whenever i used in the ping
to the server it's it's required to
return a pong back to you and sometimes
you can actually get a pong lot ever
having sent to ping which is a weird but
it made sense for the working group so
there it is so then you'd start it you'd
connect you don't want every critic line
it doesn't automatically can
you have to call connect and you can
give it a timeout it's like I don't want
I only want to wait at most five seconds
otherwise bail and let's do this and
then of course there's your send ping by
ping payloads are all binary and in this
case we're doing a utf-8 encoding for
that so now Tomcat the tomcat web socket
kind of surprised me when it landed I
was hoping to actually help out with
that but it showed up as a kind of
similar he didn't it was primarily
Tomcat 7 option when it landed and I
forget it was mark I think from the
Tomcat team it was actually they were
hoping that would be motivation for
people to upgrade to seven and get off
six so they can quit supporting things
and then someone went and back ported it
to six so he was he was simultaneously
you know like grateful that someone did
that and a little bummed because he was
really hoping to use that to move people
along so that didn't work out the main
concepts here are they have it's called
stream in round and message inbound and
then w s outbound which basically input
streams output streams and they have a
they also have a website server based
approach in the case of grizzly you only
really need the servlet so it comes up
and then you can say you can register
your your website application with the
engine in their case they actually just
extend servlet which is a subclass of
HTTP servlet but it handles all the
stuff for you and that's their entry
into how you get your website vocational
work in tomcat will see a little bit
about that so the message inbound extend
streaming bound of course and then had
to call backs on binary data and on text
data and they they expose that incoming
data using standard Java i/o interfaces
and and then they the two binary message
byte buffer and text message with the
char buffer and those are callbacks and
then whatever comes in you have to you
know subclass that and then deal with
whatever the message comes in I did byte
arrays when I did brizzly
it in part because I had to have the
same API with grizzly 19 and to try and
keep some sort of fidelity between the
two the byte buffer and char buffer most
people don't work with them unless you
do a lot of niño work you may not have
ever even heard of byte buffer char
buffer they're actually a lot nicer than
then my byte array option because they
can actually wrap a byte array and
return it to you and without by direct
copying in grizzly we do a lot of byte
array copying because we don't use this
approach and so this is actually a bit
nicer memory wise and speed wise than my
approach so w s outbound is basically
the output stream and has it's the same
it's a very familiar interface and then
you you know you have your byte buffers
you are by for us to send you see you
can send a pong but you can't send a
ping with this which kind of hides off
part of the spec I'm not sure it really
matters that much but it's interesting
it's not quite as symmetrical as you'd
expect and then you do the same basic
very kind of obvious methods and you can
actually write a single char which is a
little weird but if you want that's what
you do so here's what they're so that
looks like and they have a class you our
method you can override create web
socket inbound and that's where a lot of
your business logic would would reside
for your application I mean it is a
servlet so there's a do get if you want
to override it doesn't make a whole lot
of sense if you're going to do web
sockets because once your application
gets it there is there is no do get
there's no post there's no head there's
no because it's not https all your verbs
make no sense in a website application
but you can select your sub protocol if
you want protocol negotiation in in web
sockets is it's very loose in fluid if a
WebSocket request comes in says I want
this sub protocol the server actually
responds with you requested any of these
four sub protocols but I don't support
any of them sorry and the server can do
that and it's valid and then the client
has to decide whether or not it still
wants to do what I wants to do so and
here you can select which subcortical
you want to send back
and you can verify the origin there's um
without getting too low level there
there's certain origin verification that
you want to help protect against you
know cross-site scripting all that sort
of stuff so you can do that in there
right so this is what an echo server
would look like they subclass servlet
they create their their message inbound
and it's simply an echo those two really
big numbers on our our buffer sizes it's
from their code and it's just a really
big number for no real apparent reason
so that but this is what it would
actually look like oh its rights to the
buffer size for it because they'll
buffer stuff on the dependent on server
for you so you can set the buffer size
for your text date or binary data here
they have the callbacks on binary
message you get your outbound and you're
out your binary message and then text
pretty straightforward it's just an echo
thing but that's what it would look like
now jetty is also web sockets a servlet
based if you go to their wiki page um
they're a little hand wavy about is like
no one should ever use this stuff use a
framework which i guess is ok but it's a
little bit like never ever use sir what
Directorate directly you should use
something else that abstracts all this
stuff where you it's like what's fine if
that's an option but it you know its web
sockets not that complicated you
implement stuff and so I was a little
spun and see there's like you should
never do this wait for someone to write
a framework but whatever so they have a
handler website at class as well they
actually do something very interesting
which we'll see and then I think that
the jsr actually copied it so they have
a web socket interface but they have
nested interfaces for you know on text
message and binary on frame and on
control so depending on what you want to
do if all you care about is text
messages you just implement on text
message and then that's all you have to
really worry about you don't worry about
sub putting an overriding the on binary
message even though you know you're
never going to get it you still have to
override it because it's abstract for
example there is no java client in jetty
all their documentation
talks about javascript in the browser so
it's nothing really to see there this is
what an example what their handler would
look like in this case they're actually
doing a select on the sub protocol that
comes in and they're creating various
website consultations based on which one
you wanted to do um it's a little a
little messy but that's what a-what do
WebSocket could look like with some
protocols so again here's their this is
their interface they have the standard
on open on clothes like all the other
api's do but then these nested
interfaces they actually are like a
really nice job and I wish I thought of
it of isolating the bits that you care
about if all you're doing is streaming
video for example you don't care about
text messages you never have to worry
about those method methods or for
example if you want if you want a
WebSocket that really all it deals with
our control frames um and there are a
number of specialized frames inside the
inside the protocol specification called
control frames and they do a number of
things we've already talked about ping
and pong those or control frames and
there's a handful of others but if
that's all you care about us implement
on control and then you just process
those and you can kind of ignore
everything else and then on frame is it
it's a kind of a catch-all it's like any
frame that comes in I want to get
notified and now I'll do stuff with it
you have to jump through a few hoops for
that unfortunately which makes sense in
some cases but here's one where they
actually implement the on frame and then
when it comes in they have to check use
of the control frame and so if you want
to get that low level you can I can't
imagine it being terribly useful for
most people but again it exposes that
level of detail if you want in this case
they're looking for think pings that's
what they're looking for but um yeah
that level that level detail is there
and I think that might be the only major
API that exposes that sort of detail if
you want to build your your app that way
change the page which brings us to the
jsr
a game is still under development but we
are since i wrote my slides we went into
EDR um what am I bout to show you is
still actually pretty close there are
some finer details that may not be quite
the same but I tried I tried to clean it
up to make sure it was at least
reasonably um current and the jsr they
have client container and server
container to abstract away the client
and server inputs there is a
configuration class which is kind of
nice because you can set everything on
on one centralized configuration and
pass it in rather than trying to hunt
down on all the different pieces of API
to to choose things and then there's a
concept of a message handler so an
endpoint looks like this there's not a
lot to it this is this is the very
high-level version of the endpoint the
same familiar callbacks so the client
container has this interface it's a very
very verbose API but you can you know
set your buffer sizes if you need me
that you can get all your sessions on
your client if you want and this one
actually exposes extensions as part of
the API this part of the API is actually
probably the most tenuous because the
protocol itself is not as it doesn't
feel like as baked that particular part
of it so the semantics about what it
means to handle extensions and how do
you how do you build your frames and
that part still kind of up in the air um
and extensions are like really low level
there are some if you're familiar at all
with looking at wire protocols there's a
chunk in the in each packet reserved
bits for setting flags like i'm using
this extension of that extension and
then but there's only like four bits so
it gets very complicated if you have too
many extensions the there's not that
much space to tell that you're installed
there but that's the client container
and the server container extends a
client container and adds just one more
published server if you're if you've
done the Grizzly version this would be
the same as right
that what's it called register
application i think or maybe just
register but it's basically inside the
server container it's a way for you to
say to your Iggy container now at this
point this is my application I need to
register it so that you can start
processing request and we'll see I think
we'll see a little bit of what some of
the configuration looks like so the
message Chandler this actually um this
borrows pretty heavily from jetty and
then adds some interesting stuff so
again there's a text message hanger
binary acing binary async binary an
async text that's all it's a little
weird for me but I can I can see where
he's going for but the interesting thing
for me is when he added these decoded
objects when I went to first came up I
was like do we really want to put this
like in the in the API and I wasn't sure
was going to work out but I let you do
some really interesting things for
example if you're sending if you're
sending json back and forth most time
when you get into your application you
don't you don't want the JSON bundle
necessarily sometimes you do a lot of
times you want to be able to say i want
the java version of that JSON object so
you can actually register decoder and
implement this interface so the bottom
you get notified of this incoming packet
frame from the client it's actually
already decoded into something some sort
of semantically meaningful Java object
and so just like a blob of binary data
for example um but i'll let you do that
in a very type safe way because it's all
generic and stuff so it's actually kind
of a nice little feature that I had to
warm up to you can do the on pong if you
want it's curious that no one ever does
the pain but they love the pong all
right so here's a very simple program
what it would look like and the server
container and servlet container or a
client container they're largely well
especially the server planner is largely
kind of placeholder it's intended that
at some point you're you're ee container
whether it's glassfish jboss or or
tomcat really because they support I'm
some of the website of stuff they would
have a meaningful implementation of what
a server container is so there's this
kind of a slug method
like an implementation get me the
container and you get back to noon face
whatever might happen to be so you set
your configuration details in this case
you're saying I want to serve up
anything that starts with / hello and
then the client is very similar as you
can see there at the bottom I don't know
if my now shows up at the bottom you can
see new your iws colon blah blah blah
and web sockets does introduce a new URL
scheme WS for web socket in WSS for
secure web socket it's like HTTP with
two less letters but that's what the URL
would look like and then it connects
with the client configuration so right
so that those will come from whatever
your container might happen to be and
then yeah these this is where all your
logic would be there's a server and a
client and they're both endpoints
there's actually a sub interface called
remote in point that is really where
most of the interesting stuff is and the
configuration stuff I hope I add this
light because there's some interesting
things in the configuration and then you
connect and publish just like that there
are annotations that I don't go over
them I'm that kind of run out of time if
I went into it but you can't just
annotate your class and say I want this
anytime I message comes in i want that
to handle it and will at least see
briefly what they are so this is what a
very simple and server implementation
looked like using the DJ s are you get
your session from the remote in point as
you'll notice which is just a sub sub
interface from an endpoint so you get
the remote end whatever they might
happen to be and then they can send
stuff you add your message handler in
this case we only care about text stuff
so whenever we get it we're just going
to say hey got your message thanks a lot
sorry my voice is really drying or my
throats are dry this mine
the client looks very similar we're only
sending texts so that's all we care
about and in this case we're getting the
remote which is the server end of the
world and this time we're sending oh you
so what's in store there are annotations
where you can hook into various
lifecycle events without having to worry
about implementing this and subclassing
that those are putting new to the spec
glassfish now has support I think for
most of these I don't know that jboss is
working on it but the Oracle developers
have the added advantage of they can
kind of work long as things go along I
don't know that jboss is really that
worried about implementing it until we
get something that's more fully baked so
we have the annotations and then as I
mentioned the encoding API switch um I
do have an example of that so if you
remember this was the simple server
thing it's just a repeat there's nothing
new there but I want to bring it back
for a little reminder and you can add a
custom message receive end pointers what
this one is and it is as you can see
it's it's actually type safe at this
point so when you get on mesh it's
called to you you're no longer getting
texts you're getting whatever custom
message is and I don't know what custom
message is it doesn't matter it gets
wrapped up encoded for your decoded I
guess from the wire and hand it off to
you so you get nice compile time checks
for your API instead of just dealing
with textured byte buffers and then on
an error and there is a decode exception
that comes from that that it doesn't
work it'll throw that you can do for
example this implements encoder and
decoder so if you want to encode text as
it comes and goes you can wrap it up and
kind of whatever you want there is a
method called will decode which is an
awkward name but it much like the is
application request you implement this
method and just check to make sure in
this case that starts with custom
message before you decode it and coming
back out what's what's coming up in the
API is we're still talking about how to
support extension and how do we expose
that in a sane way
um not entirely sure what that will look
like and what that does it does lead to
custom framing and that once you get
down to the the chin of the point in
changing your framing it could kind of
mean anything if you want to encrypt it
before it goes out or if you want to
know bit shift everything in there so
like I said it's already in the API the
discussions are pretty light on it
because we're not entirely sure what's
going on but we are looking we'll have
to look eventually at multiplexing i'm
not sure if it'll make it in ee 7 the
multiplexing part of the api because
it's not part of the wire protocol yet
and it is the IETF that's discussing
multiplexing and there's no telling how
long it will take so it's unlikely that
we'll commit to getting multiplexing in
the 104 web sockets and then of course
compression the the discussions going on
in the working group for that is to be
able to expose custom compression
options so if you if you prefer you know
gzip over act 200 or whatever you can
you just plug it in and use whatever
thing works for you that might make its
way into the API because that is that is
active under a very active discussion
with the working group and I think it's
pretty close to being done so just very
briefly I want to touch on and like what
what future does web sockets have
because one of the concerns that I have
there's um there are now broader
discussions between speedy and Microsoft
has their own HTTP 20 speed and mobility
which will hopefully have a shorter name
and but these are these are competing
looks at if we're going to really
replace HTTP in general what would it
look like WebSockets works on top of
HTTP and everything is golden and it's
it's actually kind of nice these are
looks at a deeper looks I like
fundamentally changing what the wire
protocol it looks like speedy is
actually implemented I think greg was
saying like forty percent of all web
servers support speedy now if you use
google chrome to look at gmail you're
using speedy you're not using it
p but you don't know that because they
hide the URL for you but there's also
HTTP 20 and there's actually two
different versions of what that should
look like Microsoft has our own the
speedy camp has their view of it and
there's yet another group that has their
own whatever these are likely years away
because there's discussions take time
and because everyone wants to have a say
so as far as WebSockets go it's here now
so you can start doing a lot of this
really advanced applications on top of
it now without worrying too much there
are actually examples of running
WebSockets on top of speedy which feels
a little redundant to me but it does let
you offload things like TLS negotiation
in encryption 19 offload that to speedy
and you can just piggyback on top of
that so we'll see how that goes but i
have a feeling those will be years away
because that's a pretty contentious
discussion so if you want to learn more
the actual RFC is there at the top if
you like reading specifications is
actually not bad the the framing diagram
is actually kind of interesting because
there's a lot going on in a very small
space and so if you if you like that
sort of thing it's there there's that's
the length of the jsr is there we are in
early draft review you can download the
javadocs and there's a specification PDF
if you want to read through it and it
kind of explains in more detail about
what's going on and WebSocket dot org is
the w3c site for the javascript part of
the world and they'll talk about and
what's on the EPI there looks like the
last three are you know grizzly Tomcat
Nick lips if you want to look at jetty
if you want to look specifically at
those documentation of those websites
there's a lot more examples there about
what's going on and but they all they
all work today and I was going to
mention something else but i forget what
this and i will i will say just briefly
i want to kind of restate because until
this shows up actually in containers and
you're still left to have to
re-implement it for which our container
in you should actually really take a
look at atmosphere
I was hoping to have some example slides
but I dis run at a time atmosphere will
really abstract most out of way for you
and it has the nice benefit of if you're
on a browser that doesn't have WebSocket
support which is unlikely these days but
it happens it will actually fall back to
comment for you transparently and you'll
never know the difference um so it will
take a lot of the pain out of that and
at least until the jsr actually shows up
on on all the containers you care about
and so that is an option but that is all
I have are we gonna run too short it
didn't talk fast when I'm drying thirsty
um but I'm happy to take any questions
you might have and I will just say
because my company is paying for me to
be here we are hiring so if you wanted
to live in New York um let me know
because we are literally hiring for
everything but I don't make it into
sales pitch so anyways that's all I have
does anyone have any questions I can
answer sure it will ship with EE 7 which
is I think targeted for next summer so I
had one when i submitted this talk i had
the timeline for completion was actually
supposed to Ben this fall so I was
hoping to have a lot more concrete
things to say but then they ship that
all the schedules back like a well well
we'll deal with what we've got now and
it's actually pretty the API is actually
looking pretty good there are a number
of things I see now in the spec that I
can I wish I'd thought of when I was
writing grizzly but I didn't and then
dapi go fix it anyways
still the lingering malaise like I don't
know what okay so what he's asking about
is like what are the security concerns
and there was a guy he wrote a paper and
it made a huge think in both firefox and
I think Chrome's at oh we're out until
you fix this we're just not going to do
it so it kind of sidetracked the whole
evolution the spec for a while but as
soon as you what the problem is under
certain contrived situations the
original Kinect goes through and it
looks like HTTP everything's fine but if
you're going through a proxy for example
the proxy takes everything comes in and
hands it off and normally that's fun but
a malicious developer could could craft
could craft a frame message that looks
like an HTTP request so they get through
fine because it's just you know just hey
forward me on and now once they're in
inside the the proxy they can send a
frame and start redirecting traffic
somewhere else they can basically hijack
the session because now they're in the
firewall so there was some concerns like
well what if they do that what do we do
so so that's when I if you hear about
masking in in the WebSocket
specification that's what that is it's
basically it's a random bit set I forget
how wide I think it's like 16 bits but
for every bite that comes through they
mask it with this mask and they rotate
it through and it's secure in that the
browser's restrict client code from
doing that so I can create whatever I
want I can upload a virus that infects
your whatever from my JavaScript but by
the time I hand it off to the browser
it's going to mask everything so it
shows up as a random jumble of bits and
the at that point the proxy server will
just takes I don't know what that is I'm
just going to keep handing it off and
I'm not going to worry about it but it
prevents people from creating malicious
package that's than hijack your network
infrastructure there was a very long
like you said there's a very long
prolonged public discussion of
got it I think most people were like
it's not really not really a big deal
apparently even his test case was a
little bit contrived to make his point
but it was one of those things where
everyone was freaked out about it enough
that the working group decided had to
address it so if you hear people
complaining about complexity in the spec
that's one of the things because masking
it's a little involved but but for your
for developers it's actually transparent
it's a little bit like working with ssl
no one ever creates a packet and then
manually encrypts all the bits before
handing it off you just hand it off in
the infrastructure takes care of it so
it's there but it never really affects
what you're doing so it's an answer your
question probably there well it's a
little bit like how how do sessions work
and it is it is an into point persistent
connection so once it enters the cluster
and one of the nodes in the network
handles it it's probably going to be
sticky to that one node because it's not
like you can migrate connections around
the cluster but there are options for
that as well there is I believe I
believe King has an option for this
where you actually put an intermediary
inside your network infrastructure so
the connection comes in and it hits here
and then essentially you just proxy it
inside your network and at that point
the connection comes in and you can say
arm I'm going to go to you this time and
we're here to go back over here and you
can do that kind of round robin yourself
or whatever might happen to be but the
protocol itself doesn't address that
because it's like how do you how do you
migrate connections around you know but
anyone else
I you know circuits and stuff because
like mostly you
right that's actually a great question
and I was was chuckling earlier in the
week was like everyone says oh that's a
great question but it actually gets
really tricky because when i first
started developing the Grizzly
implementation there was no masking so I
used a tool called in grep which if you
haven't discovered in grep yet it is
fantastic it's a network grep you can
give it say I want to track everything
on this port that goes happens to go to
this particular host and then everything
goes out and you can kind of see so when
I started developing it I could actually
see I could see the frames come by and I
can see here's these bits and that and
there's my payload and it's like that's
not quite what I wanted and I can tweak
it and fix things and then masking came
along and it's a little bit like trying
to debug and ssl connection at that
point because you normally had hey hello
world but now when you see it it's like
this random jumble of finding some
weren't even asking characters anymore
because it's all masked and it gets very
very tricky I never had like a great
solution for it for me personally I
would like to put a little bit debug in
before masking was applied because I you
know I was in the source couldn't I can
do that if you're looking at on the wire
stuff it gets very tricky because the
masking obscures a lot of it but if you
but that's just the payload if you're
looking at and there's all sorts of
header information all there's various
bits and masks and stuff it you can
actually look at that and that stuff is
all in the clear so if you understand
the wire protocol you can look at that
in kind of make sense of it but your
payload is pretty much a black box
unless you want to like manually unmask
everything on the fly like that it is a
lock word and once yes
the the browser does it masking is that
is weird in that it's one direction the
spec group wasn't terribly concerned
about traffic coming back out through
the proxy because those proxies when it
comes when it comes out of their work
back to the other endpoint the proxies
don't inspect that they just going to
hand it off but coming into the network
the the the proxy is all the
intermediaries they actually inspect the
data coming in because it might be like
oh I need I need to afford this or
forward to that so masking is only one
direction and those maska bits are
determined by the by the browser in this
case and it's actually included when
when you send the packet its then those
masks values are actually included on
the other end so the server can then use
that same mask to unmask it on the back
side and where that becomes more secure
is that client code is never exposed to
what that mask value is they have 0 SE
and zero visibility into what that mask
is going to be and so in your JavaScript
code you would to say web sockets end
and you you'd hand it you know a big
chunk of text and then the the browser
will take care of masking that and it's
completely outside of the control some
you know a hacker isn't won't be able to
get at that particular information to
craft specialized attack packets does it
make sense anything else anyone
one of the one of the goals of
websockets was to piggyback on top of
HTTP so when the initial request comes
in as far as anyone's concerned it's
just HTTP and it literally is you know
you'll have your get / HTTP one dot one
but what's different is there is there's
an upgrade header and there's another
Africa there it's actually a pair of
headers on the initial request so when
it comes in as far as your firewall is
concerned and your routers and whatnot
it's just an HTTP request and then what
happens when when the server comes in
and it sees this request it returns with
a 101 which is a you know basically
telling client okay I heard your request
upgrade the thing I agree let's do this
and then both and at that point both
ends kind of switch over to sending this
framed data back and forth so your
firewall doesn't even know the
difference and then once once that
connection is upgraded it's just sitting
bits back and forth and it's a little
bit like an SSL connection at that point
it doesn't really your fire your fire
will typically doesn't inspect each
packet coming in once once it's been
negotiated and approved on the other
side it just passes a bits back and
forth and that's and that's how it gets
to the firewall and that's actually one
of the perks of websockets is that you
can actually connect through other parts
of the network without having to open
more ports on your on your firewall
because most mighty shops are like I'm
not going to open another port because
they all get freaked out about it so
yeah that makes sense
information and some of the folks like
yeah yeah and that's it that's a great
point you can actually there are certain
intermediaries that have like if a
connection goes on too long the look at
is like what's going on here it's that's
been around too long so I'm just going
to kill it because most HTTP requests of
course you're in and you're out and
you're kind of done and so when they see
one that's been this thing's been open
for four hours I don't know what's going
on I'm just going to kill it you can
actually use the WSS protocol which
basically is an SSL encryption and most
intermediaries they'll look at it and
say it I know it's been open for a week
and a half but it's secure so I'm just
going to leave that one alone you might
you might have to do that if you find
yourself on a network that has
intermediaries that just randomly close
things on you so yes
well it depends on on the on the client
I don't think there's any any hard for
example like with HTTP most most
browsers in force you know like two
connections or five or whatever happen
to be and that's mostly kind of a gentle
gentlemen's agreement on on the client
side there's absolutely no discussion
anywhere that I'm aware of about such
limits for web sockets and so you could
potentially open up boatloads of them
coming out but they are they are much
lighter weight in a lot of ways than
HTTP so that's kind of okay but I the
feeling once multiplexing shows up that
will start seeing kind of more formal
specifications of like how many times
should we actually do this from one user
agent that makes sense did answer your
question you might still be subject to
that and that will vary depending on
what your browser is I haven't run into
an issue of that but then I really
haven't tried to open up 100 connections
from one web page either so
right you might you might try to open up
a dozen of them on your browser will say
wait a second there um that might that
might happen and at that point you'd
want to look at something to multiplex
through that and at least until the
protocol supports it and at that point
you might want to use something like
atmosphere which has multiplexing built
on top of it it does its own
multiplexing logic to route request back
through so you might need something like
that so but on the server side I was
talking to Greg Wilkins last night and
he would ruin some numbers comparing
comedy and web sockets in the number of
concurrent connections on web sockets um
there's like 10 times higher than under
web sockets and the latency was an order
magnitude or an order of magnitude or
two less than then comment and so if you
if you need to open a whole lot of web
socket connections on the server side
you're probably going to be okay because
it is it does really really well on the
server side but it depends on what your
client is so I think we have five
minutes before they kick us out any
other questions no okay well that's it
thank you so much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>