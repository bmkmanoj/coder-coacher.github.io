<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Build Your Own Type System for Fun and Profit | Coder Coacher - Coaching Coders</title><meta content="Build Your Own Type System for Fun and Profit - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Build Your Own Type System for Fun and Profit</b></h2><h5 class="post__date">2013-01-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/6drjjYXKj9c" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">today I want to talk to you about type
checking so but I want to start with a
confession if your program was anything
like me your code is terrible or at
least it's not as good as you would like
it to be so code is full of errors
here's an example in a an Adobe
enterprise system and I've circled the
java.lang.nullpointerexception that you
get when you try to use it but it's not
just websites that are a problem it
happens on phones it happens on embedded
devices lots of other places where we
don't want these sorts of errors to
occur so the fundamental problem here is
that java's type system is too weak it's
great but it doesn't do enough for you
it it prevents all sorts of boneheaded
errors like assigning a string in hello
into an integer but they're all there's
all sorts of code that you can run and
and that you can compile will compile
cleanly and then we'll fail at runtime
so here are three examples on this slide
do people see why this code fails at
runtime how about for the first one
the console make me note for instance
suppose you're running as a nap how
about the second one the empty list it
the empty list is immutable not all
lists are but the empty list is and how
about the third one yeah this one is
actually not going to throw an exception
it's much worse than that it will not it
will fail to throw exception and keep
executing if you have a sequel injection
attack so the good news is that type
systems can prevent all of these if
you're using the right type system it
will reject this code and you'll only be
able to run code that's actually correct
type systems exist to handle null
pointer exceptions unwanted mutations
concurrency errors and lots lots more so
the solve problem in theory the
difficulty is that takes a long time to
transition from theory into practice
we've seen the the rate of releases of
the Java language so I want to tell you
about a different way a way we can
leapfrog that so when you're using a
static type system you run source code
through the compiler which does type
checking and if there any errors every
error indicates above or you wrote the
types incorrectly so you fix those and
change the source code and eventually
you have no errors so you get out and
executable and you can run it and that's
great and what happens when you run it
it crashes so here's here's a different
approach you still have the source code
in the standard compiler and type
checker but you can run a pluggable type
checker in addition we have a tool for
building these called to check our
framework it issues warnings every
warning indicates there's a bug or you
wrote an annotation wrong and for
example if you have a variable my ref
that that's marked is nullable if you
try to dereference that you'll get a
warning because it might fail with a
nullpointerexception at runtime so
eventually but you can always these are
these are its is optional you don't have
to run these if you don't want to but
eventually if you have no warnings you
can then take the executable and run it
and you know that those particular
errors cannot will not happen at runtime
furthermore if there are other
properties you care about you can run as
many of these as you like as many or as
few as you like and you get even more
guarantees so we have this tool called
the checker framework which allows you
to build political type checkers
essentially you can think of it as
plugging a new type checker to the Java
compiler you still use the Java type
system but you get to add more checks if
you want them where you want them it
uses Java sea's standard- processor
argument that's been in Java since Java
5 and there's also integration for tools
like aunt maven and Eclipse and it's
freely available here's how you write
these the the types for these these
pluggable type systems using java's type
annotations java will let you write
annotations anywhere you write a tight
so you can say for instance that
particular query strings untainted it's
not going to be sequel injection or you
can say this is a list not just a list
of strings its list of non null strings
or after you've constructed some object
you could cast it and say it's not going
to be changed anymore the the last
declaration there is a better
declaration of job of the JDK is
built-in unmodifiable list what you
really like to say is not that it
implements list of tea but that it
implements read-only list of read-only
tea you can't modify you can read but
can't modify the list and you can read
but not modify the elements in it these
these new annotations on types are
stored in the class well they're handled
by tools like Java C and Java doc and
it's a built it's this is such a
compelling use case that it's a built-in
part of Java 8 but if you using the
checker framework in you can also use it
today with Java five or six or seven by
just writing them in comments and then
you can remove the comic characters when
you finally upgrade to Java 8 so there's
no reason to delay
so I've told you a little bit about this
notion of pluggable type systems that
helps you eliminate certain types of
errors now I want to talk about some
case studies and will also give you a
demo of the tools in action so we've
we've run type checkers on over 3
million lines of real-world code and
they find real bugs we found hundreds of
use of visible bugs and lots more
instances of of internal errors or code
smells it's actually pretty easy to use
we only had to write on average three
annotations per thousand lines of code
so way less than the cost of writing
generic types for example here are some
examples of the programs that we've run
it on the approach we took with each of
these was we would first write the
annotations then you run the compiler
and you see whether it see what it says
every one you get either indicates
there's a bug in your program or it
indicates you've written the annotations
incorrectly so at that point you fix the
problem and you rerun the compiler
eventually when there are no more
warnings you have a guarantee that
certain errors won't happen at runtime a
certain specific error not that your
code is perfect in every respect let me
give you some examples of type systems
so when you're thinking about a type
system there's three questions you want
to ask yourself what's the runtime
behavior I want to prevent what are the
legal and illegal operations and what
are the types of data if I want to think
about this so let's think about
preventing null pointer exceptions
that's something that a lot of people
are interested in doing we want to
prevent null pointer exception and
what's the the legal operations if
you're dereferencing it should only be a
nominal reference you shouldn't try to
dereference a null value and then we can
divide all the data in your program into
two types there are nominal references
that are guaranteed not to be null and
their noble references that might be no
lore might not be null we're not sure
and those two are related in a type
hierarchy which is exactly like the
standard object oriented type hierarchy
that Java already uses like a string is
a subtype of object similarly non null
object is a subtype of na level object
and then with that the type checking
just works in exactly the way you're
accustomed to let me give you an example
of some of the many bugs we found here
google collections has a class called
for map with default this is it let's
you it's a mapping and if there's a key
missing then it you can use the default
value instead and it has a hash code
classes should have a hash code that
returns the map hash code plus the
default value hashcode and this throws a
nullpointerexception because the default
value can be null and the hashcode
method doesn't look for that doesn't
check for that so we found 9 crashes
like this in google collections alone
and we found that despite the fact that
it has 45,000 tests and two-thirds of
its lines of code or actually tests and
it was already using the find bugs
nullable annotations and find bugs
around cleanly on it issuing no warnings
now you can't blame these people the
Google collections authors have done a
fantastic job but it's a you can't
possibly write all the tests you need to
write a it's much better to let a
machine do that no human can compete
with that sort of thing so a machine is
a great way to complement all the tests
that you've written let me give you an
example of another type system that we
use to find real bugs this is one for
Java signatures so what's the runtime
behavior you want to prevent we don't
want to suffer classnotfoundexception
zat runtime Java has a class for named
method and that takes a so called binary
name turns out Java has three different
representations for a class as a string
so we divide all data into four types
they're unqualified strings sort of
arbitrary strings like hello world
they're fully qualified names like
package outer inner binary names like
package outer dollar enter and fuel
descriptors like L package / outer
dollar inner semicolon and these are all
used in different parts of the JDK and
the JVM and you'd better not mix them up
because if you do bad things happen
here's the type the the hierarchy we
have unqualified strings at the top and
then we have these three other types and
they must be kept separate it's actually
quite important that they be kept
separate in there none no one is a
subtype of the other no one can be used
where the others are supposed to be used
so here's an example of some of the bugs
that we found in the JDK there's a class
named class job line class and it has a
method for name and the chuck if you
read the javadoc it takes as an argument
of string and the Javadoc says that
string is the fully qualified name of
the desired class so let's pass it a
fully qualified name you get a
classnotfoundexception because actually
it shouldn't be a fully qualified name
that's an error in the documentation it
has to be a binary name if you pass it a
fully qualified name that doesn't happen
to be a binary name then the systems not
going to behave properly and you'll
never notice this until you actually
have an inner class if you don't have an
inner class you'll never notice this
until one of your users starts to use it
and then discovers the problem so we
found 11 crashing bugs in OpenJDK and we
found 13 more crashing bugs and
libraries where if you follow the
augmentation your program is going to
fail here's some example annotations we
wrote class top-four name takes a binary
name as an argument a class get name
returns a binary name and plastic get
canonical name returns a fully qualified
name so if you were to write the code
down at the bottom where you get a call
get canonical name and then you try to
call last up for name on it which is
something I've seen real code do then
the type checker will warn you it will
say this is erroneous and will cause you
to rewrite it correctly
right okay so the next type system that
we want to discuss is a regular
expression type system when you use the
regular expression type M utilities in
Java you can get two possible exceptions
you can get a pattern soon takes
exception if the string is malformed and
you can get an index out of bounds
exception if you access a capturing
group that's not within the back legs
question so the legal operations that we
want to distinguish that pattern that
compile is only cold with a string where
we know that the string is a regular
expression so you cannot use an
arbitrary string just regular expression
strings and format to that group you
have the additional constraint that you
know the number of capturing groups you
cannot access a capturing group if
you're not guaranteed that they're
capturing it group exists within the
string so we do this using two
qualifiers the unqualified again to
specify arbitrary strings like hello
world and reg ex for strings that are
guaranteed to be regular expressions
with a certain number of capturing
groups here's some example source code
we get the regular expression from some
user input and then call pattern dr.
pile of it if we do this with the
malformed regular expressions bring
given by the user we can get the pattern
soon takes exception we just don't have
any control about the user input on the
other hand the next step is that we
compile the pattern into the metra it
matches against that string and then we
try to access a group number four we
have no guarantee that group number four
exists within this regular expression
and at one time we might get an index
out of bounds exception so this is a
very brief coach and might look at
efficient to you let's look at a real
world demo of application of an
application that uses regular
expressions so one of the case studies
we did with regular expressions is this
tool called chasey which is a
distributed search engine one of the
features that it provides is very within
the tables that it has and you can
search for string ABC and as this is a
fresh installation
don't find any tables so we get the
message okay there's nothing but what
happens if we enter Miss formed
malformed regulates passion nothing
happens we don't get a error message we
just get a blank table a blank page so
what the server administrator can do is
go into the server log and only in the
server log he finds that it was an
exception and he finds okay there is an
unclothed grouping group here and then
he can start debugging go into the
source code see where the first part of
his code is and he sees that he needs to
go to table why mark line 65 so let's
have a look at that coat and here we
have that exact same pattern you get the
regular expression pattern from the post
so you get it from the user and then he
did some validation he checked whether
it's empty or just a regular expression
that matches any string and otherwise it
just compiled the pattern so now this
throws the pattern exception so what we
did is we set up a tool and with this
case study and compiled it with a
regular expression checker and the
message netiquette is exactly on this
line so you see that the call to pattern
lock compile get this argument and
arbitrary string but pattern that
compile is annotated to only take a
regular expression string so now let's
have a look at how to fix this bug the
fix is quite simple instead of just
always compiling it we have to make sure
that the string that the user provided
actually is a regular expression string
only if it's a regular expression spring
we compile it and then if it's not a
regular expression the output some
readable error message so let's see
whether this type checks now so we stop
JC and we compile it
and now we don't get any other messaging
anymore so this passes the regular
expression chapter so they can be
certain that now we don't have any
exceptions and regular pattern syntax
exceptions in this application anymore
just a second
now it's done and we restart JC and can
go back to the web page and let's reload
that table now if we insert an invalid
regular expression the user gets an
error message so by using the regular
expression chapter the program that was
pointed directly to the line of code
where he needed to do something and
could make the user experience a lot
better so instead of the server
administrator going to the large you get
immediate feedback about what's going on
so the chassis developers were so
excited about the feedback that we gave
them we gave them a total of thirty-five
bug reports that they decided to
integrate these annotations into their
source code and use it in the
development process so in the search
engine you have a lot of regular
expressions so they were very happy
about this feedback
cool so what they seem so far is what is
pluggable type systems and how can the
check the framework help and we've given
you three examples the knowledge check
the signature checker and the regular
expression chapter what we want to do
next is brainstorming with you about
ideas how you could apply this this tool
in for your problems so for this we have
three questions that we want you to ask
yourself what is the runtime behavior
that you want to that you wish to
prevent what are the operations that
should be legal or illegal and what
types of data are there do we have so if
if if anybody has an example of some
runtime error or any other behavior that
you'd like to prevent no we just want to
take those suggestions and we'll put
them up here on some slides Yeah right
there okay great so the that suggestion
is that we want to prevent so what's the
exception that you want to prevent so
this is essentially a locking to a
concurrency type system what's
yeah that's exactly right so the problem
is that you have a lock and you have
some data and you should all only access
the data if you're holding the lock and
if you access the data without holding
lock then you can have race conditions
you can have other terrible things
happen you can get concurrency errors so
so essentially we're trying to prevent
these race conditions so the legal
operations are you can access data if
and only if you're already holding the
lock for it and then what are the types
of data so how would we express a data
property about the things we care about
essentially the you started out with
that by saying you wanted to have this
guarded by annotation so it essentially
says here's a datum and here's the lock
that represents it now for every datum I
know which lock represents it so this is
a great example and it's one that is
distributed with the checker framework
so if you download our tools you can
already use this today so fantastic
other other suggestions yeah
the immutable operations like on a feral
collection
and
I guess
yet so that's another great example the
idea is we want an immutability type
system we want a women have a guarantee
that certain data are not side affected
so some in your program some lists find
mutate other lists you shouldn't be
mutating so the legal operations are you
can mutate a mutable debt you can
side-effect mutable data but you should
never side effect immutable data so
we're going to divide all the data in
your program into either two or three
types depending on how sophisticated you
want your type system to be there's
immutable data that may never be changed
there's mutable data that anyone can
change and then you can out you can
actually refine this which is desirable
in some circumstances for example to
have data that this reference can't
change but that some aliasing reference
could change and that's read-only
right so the read-only can express that
so for instance if you have a suppose
you have a you're holding some data
you're allowed to mutate it you want to
pass it to another routine that routine
has no right to mutate your data if that
routine has its parameter annotated is
read-only you have a guarantee that that
that during the execution of that
routine that routine will not mutate
your data but once its back you still
have every right to mutate your data and
that's different than something that's
completely immutable and can't be
changed by you or by anyone else so you
said it's being captured automatically
oh okay so you're saying okay so the
notion of writing a closure that's going
to capture data outside it is a separate
one and that can be handled as well but
I wasn't talking about that in my
example that's a good point and you know
and that's one of the unit its
subtleties like that that are why you
want to use a real type system you know
you don't want to use something like
fine bugs which helps you find so sorry
that's incorrect you do want to use
something like fine bugs is useful but
if you want to find every problem you
want to use something beyond the
heuristics as well so great example
other other brainstorming other examples
of things that people run into ya in
there in the back a classcastexception
okay so so what we want to do is have a
guarantee that you won't suffer this
exception at runtime so what are the
operations that that you want to permit
or what are the operations you want to
forbid at compile time at cast
yeah so yeah classcastexception sorry
right so it the the Java type system
already lets you do some of this because
it'll uh well the compiler can tell you
this cast is guaranteed to succeed this
cast is guaranteed to fail and some of
them do that some of them don't but you
could actually you could write a
pluggable type checker that would do
those things even if you're a compiler
doesn't and will also track more finally
than the Java type system can what types
something is so for instance suppose you
have a variable that's of type object
and you put a string into it now if you
cast it down to string you know that's
going to succeed java doesn't know
that's going to succeed but it turns out
that our type systems have a feature
called ok so the academics like to call
it flow sensitive type refinement but
you can think of it as do what I mean
that that means it knows what type the
thing is even more finally than the Java
type system even if you haven't read
Eclair dit even if it's the same
variable that's a good example yeah
there and then was someone recently hand
over on the corner no ok then I'll get
you next so ok required parameters so
are you thinking of something related to
varargs because I mean Java makes you
supply all the parameters welcome it on
the on the command line of the program
so basically making sure okay right so
the the example here is suppose we have
a method that takes a bunch of
parameters and we want to make sure that
some of those parameters are definitely
not 0 or definitely not null or
definitely not an empty list yeah so
those are all great type systems and you
know the the null our null pointer type
system will already handle this if you
just mark the parameters at the method
declaration as being non null then
anytime you try to call it if the type
system can't guarantee that value is
non-null it will issue a warning it'll
warn you that there may be a problem and
you can do the same thing with non zero
or with non empty lists or whatever
other constraint you'd like to express
but want to make sure you call it okay
so so here the idea is that you know
what we'd like to do is call a
constructor and then have an object
sometimes life is not that simple what
you need to do is call a constructor
then call a couple more methods and now
you finally have the fully constructed
object so we we can there's a concept
called type state where when you make a
method call something at transition in
in type like you might have files and
files are there open or closed and when
you co file that open it changes from
being close to being open and you're
only allowed to call write or read on it
if it's actually open not on every file
so you can do exactly that same sort of
thing this gentleman here okay so here's
an example of a restriction on data so
you can think of all the strings in the
world but you would like some variables
to only have a string that's in the name
of a method or it's always a zip code or
it's always a validated credit card
number or something like that so you can
do the same thing you can say I have an
annotation that says this is any string
at all and then I have a different
annotation that says this is definitely
a method name or this is definitely a
zip code or it's definitely a credit
card number or it's definitely regular
expression it turns out that that's very
much like our regular expression type
system because they're all the strings
in the world and then there are those
that obey some certain formatting
property so I mean sorry I didn't go
through our methodology right we have a
methodology we ask three questions then
I got so excited I didn't go through the
methodology don't do that so we mean
we've got some data that has some
particular format the legal operations
are you're going to have methods that
are annotated to take only a method name
or only a zip code and the types of data
are either data has that particular
property you know and it could be
nominal or it could be nonzero I mean
these are really just different ways of
expressing the same concept though of
course they're useful in completely
different ways in your program
good yes
right so I don't know if people could
hear that but essentially it was you'd
like to say that certain method calls
will change the state of the object like
changing a closed file to an open file
or changing an empty list to a non-empty
list and this is essentially a type
state yeah exactly thank you very much
so a vernors already got it all up there
um let me see how the time is let's take
at least one more there was a it was did
you have one over there right so you
could do actually put that in the so
sorry to repeat the the comment um what
about having a guarantee that you close
your resources because if you don't
close them you might have a leak and
that could be a performance problem it
could even be a security problem and you
can put that in you can express that in
a similar way in a type state system by
saying by the time I exit the routine I
want the file to be in this particular
state like it to be in the closed state
if control flow is complicated enough
this turns out to be more difficult to
express good so this oh yeah
so it concurrent modification exception
so you could actually fit that into our
existing immutability type systems so
essentially that will say this thing
shouldn't be changed during the scope
and and so the idea is if you're
iterating over some lists or other
collection if you modify out during the
iteration you're going to get a
concurrent modification exception you
know whether that's in multi-threaded
program or a single threaded program
yeah so these are great examples and
they're actually a ton more that verner
will tell us about I always enjoy this
brainstorming about the luck because
it's always great to hear new ideas so
with the checker framework to him in
people with the checker framework we we
deliver a bunch of different type system
some of which that you over you already
mentioned so we have a painting type
system that tracks taint which we need
for sequel injection attacks and things
like that we describe the signature
checker already now the references is
one of the big problems in
object-oriented programming and I think
it's very important to use a type system
like that concurrency came up is one of
the problems that we definitely want to
handle mutability in side effects is a
very common problem you want to be sure
that certain data doesn't get modified
fake enumerations for legacy code is
quite interesting but you have integer
constants and you basically don't have
any guarantee what the range for that
constant is you can introduce your own
data type and say that only these three
different values are valid for this
parameter you don't lose any performance
it's still the primitive type but you
have the additional static guarantees
about your type system through the type
system internationalization has the cool
property that the type system looks into
external file and looks up whether the
internationalization key appears in that
external file so with your type checkers
you can do many things you can look into
external databases see whether the user
ID is in the database things like that
regular expressions we explained and
their fuel from the research side we
have a few more extended type systems
so the final part of our presentation is
how to build your own type system in
this part we want to discuss an
encryption type system this type system
is very simple and we want to prevent
that unencrypted data goes through the
network so we have the distinction
between encrypted strings and
unencrypted slings and the send
operation should only be called with
encrypted strings as arguments the time
privacy for this is quite simple we have
the unqualified swing which can be
arbitrarily again and the encrypted
swings which is a subtype and you cannot
pass an arbitrary string when an
encrypted string is required so the code
that we want to type check is the send
operation that takes an encrypted string
if you pass in encrypted string if the
compiler doesn't warn you about it but
if you pass an arbitrary string and you
don't have a static guarantee that the
string was encrypted you get a warning
the complete type checker for this is
just for lines of code we declare the
annotation type ad encrypted we tell the
type of the Cheka framework that it's a
type modifier and we tell it the subtype
relation to the unqualified string and
then we also expressed to Java what the
syntactic locations for the annotation
so it's not simple to right young type
checker and just make the basic
distinction between two different
separate sets of types they're basically
three parts for a type checker the first
part is what we just saw the track
qualifiers what is the separation of
data that you want in your system the
second part is the qualifying deduction
rules that tell you for each expression
what should the qualifier for this
expression be so if you see a string
literal in your program how do you
decide that it's an encrypted string or
an arbitrary string the third part are
the tide pools which decide what is what
is a legal program and what is it
forbidden program let's have a quick
look at each of them so we just seem
that to declare the type qualifiers and
the higher he we do this reality
collaboratively we have the annotation
type and using meta annotations we
declare that it's a type qualifier and
what the hierarchy between the different
quality
then to declare the implicit qualifiers
we also use a declarative approach we
say that with the particular qualifiers
so here we say for the nullable
qualifier it should apply to whenever
the knowledge will appears in your
program you should use the app nullable
type and we also have other fields in
that annotation so for example whenever
you see travel and white white is always
a nullable type so you can very
fine-grained specify for each expression
in your program what should be the
default annotation and the third part is
the tide pools the Cheka framework
provides the basic implementation for
the this which basically just provides
the subtyping checking for your
qualifier hibachi so once you have the
qualifier he it just gets propagated
through method calls to field
assignments ensuring that this subtyping
relationship always holds at one time
and if you need to you can customize it
so for the knowledge checker if you have
a field access extra death you need to
make sure that the receiver X is not now
and here's the code to do this will in
the type visitor you override the visit
member select which is the method that
handles this and you additionally ensure
that the receiver has a non-null
annotation and if not you raise an error
from the compiler so this is very
flexible very easy to do the declarative
part and all the power from the
imperative part deviously we seen the
signature checker so the signature
checker that separates these different
class name representations and actually
most of the logic for this check is
implemented in declaratively in the
qualifiers so we say that these are all
the difference during the presentations
and using declarative annotations we can
say what strings fall into which
category of which annotations so most of
the logic for this checker is nicely
encapsulated declaratively with the
particular annotations
and okay so what you've just seen is
that it's really easy to do simple
things I mean here's the whole type
checker for the signature strings that
have found that those dozen errors in
the JDK it's also possible to write
sophisticated type checkers so for
instance the null pneus checker it turns
out it's actually tracking three
different varieties of properties at the
same time one is a property of whether a
particular reference is null or not
another is whether each object is
initialized or not and another is for
each map what are the keys that are
absolutely known to already be in it
that that helps it to infer whether a
particular call to map get it can be
guaranteed to return non null so the
checker framework has a number of very
powerful analyses built into it that
every type checker built on it gets to
inherit for free I'm just going to give
you one example which is you can think
of it as local type inference or as flow
sensitive type inference flow sensitive
type refinement so here I have a
variable X and it's declared to be
possibly null and now I have two calls
to X to string same variable same type
you'd think that they might behave the
same way but they shouldn't the first
one you should get a warning about
because it might throw a
nullpointerexception the second one is
guaranteed to be safe because it's
inside a test so our system is that is
able to to change without the user
having to do anything the the type of a
variable from line to line in a sound
way so it doesn't miss any warnings but
it greatly reduces the annotation burden
so this is one among several features of
the checker framework but let you write
less code that let you write fewer
annotations and and make it easier to
use
yes so it also handles and indoors and
try and finally and you know whatever
whatever type of control flow you want
to write it would yes if an or would let
the null slip by would catch it and if I
had if X is not equal to null and x2
string length is greater than 5 it
wouldn't complain about that either
because even though it's in the
conditional it's only going to get
executed if X is known to be non-null
good question there are some other tools
that are packaged up along with the
checker framework there are whole
program type inference tools where you
put a program in and we'll give it back
to you annotated we have tools that will
take annotations and insert them into
source code for you we have annotated
versions of the JDK for each of these
type systems so what we've told you
about is this approach is one valuable
approach to increase in the quality of
your code it's called plentiful type
checking and the checker framework is a
way to build this it's a powerful frame
earth to let you build these pluggable
type checkers it comes with over a dozen
built in checkers that you can use out
of the box and case studies have shown
they found many latent bugs in
real-world programs but if you don't
like those type checkers or if you need
something some other specific property
for your project then it's easy enough
for you to go ahead and write your own
type checker because that's another
thing that check our framework does and
we taught you how to think about type
systems type systems are not scary it
turns out that they're simple if you
know how to ask three simple questions
what's the behavior that you want to
forbid what operations are legal and
what are the types of data so I now I
encourage you you know go out download
this try it improve your code and give
us feedback and we have some time so
it'd be delighted to answer questions
that people might have yeah so
right circle super checkers clarity
there a way to extend
processes the comparative annotation
right so so the question is we've we
shown you a bunch of declarative we've
shown you how to write simple type
checkers declaratively so if you want to
do and it turns out you can do fairly
rich things declaratively but as you get
two more and more interesting type
systems or more and more special cases
then you're going to want to write
procedural code and all of our almost
all of our type checkers actually come
with some written declaratively as much
as we can and then have procedural code
the the so it turns out that if you want
to do interesting stuff declarative
isn't going to hack it but declared is a
great way to get started and it greatly
reduces the amount of code so all of
this stuff can be overridden
procedurally that answer the question
yes so we have a hundred page user
manual most of that is just sort of five
page manuals about each of the type
checkers but we have several chapters at
the end about how to write your own your
own type checker as well question
so the question was what type of license
is distributed under I think it's GPL
which means you can use it however you
want including internally your company
and it might see what the data
okay so the question is here's a
property I want about my code I want to
make sure that everyone who overrides
this class definitely redefines this
method because I don't want them to use
the default implementation that's a
property about this right so and they
have to call the superclass oh if they
do override it they have to call the
superclass okay right they might not
override it but if they do they better
call the superclass so that is not a
property of data of your code that is a
property of the structure of the source
so the checker framework is excellent
for anything that you can express in
terms of your data it is you could write
a checker that would do exactly that
using the checker framework and people
have but there you're not using its
entire power you're just using it to get
access to the AST and then doing pattern
matching against the AST so it's not
good for all problems not good for all
quality problems yep
so you can you can run these on existing
legacy code if you have have no source
code you can write annotations in a
separate file if there's some library
that it uses you need to change the
source code to add the annotations you
do not need to make any other changes to
the source code except that as soon as
you start running the check you're
probably going to find bugs that will
make you want to change the source code
if you already understand the design of
your legacy code it's pretty easy to
write the annotations you know you sort
of know which strings are addresses and
which strings are our social security
numbers and which variables are supposed
to be null if you don't understand the
structure of your legacy code then
you're in for a reverse engineering
nightmare after which you know you can
spend it just a couple moments typing up
what you learned and putting it in the
in the source code as documentation
documentation that won't decay because
it will be automatically checked yeah
great question so here I've shown you
something that looks kind of magic it's
built into the Anolis checker that it
knows it understands X not equal to null
and what that means the question is I
have a utility routine that validates my
sequel or that something is an address
or that kind of thing and the answer is
yes you can annotate that saying please
utilize that for this flow sensitive
type refinement in exactly the same way
as the built-in stuff so that is
possible and we do that in our checkers
yes
yeah so Stefan is entirely correct that
in this particular example if you call
extra string twice in a row you know the
second one is never going to fail either
the first one fails or there's no
failure so I could have put these in the
other order if I'd chosen but yes thank
you yes
the reason i asked an error and so for
belapur eclipse
see your warnings inside a cliff
later on on your right
a mile but
okay so the question is about
integration with external tools and the
concern is that why you just issuing
warnings why aren't you showing errors
these are all serious things I mean so
we have some developers who say to us
you know I'm glad they're warnings
because that means I can you know go
back and actually occasionally I want to
run an experiment and actually just run
the code before I get all the types
perfect and other people say this is so
serious that I never want to run my code
unless it's all perfect and so the fact
that it's warnings will support both of
those I think it's possible to to
convert the warnings into errors if you
like so there is a switch that will
convert turn all of our warnings into
errors and you could choose to use that
you
so the question about integration with
the clips okay so if you look at our
underlying implementation its integrated
with java sea and so it's essentially
using Java sea's a STS Eclipse has a
different compiler and so if you know
and that's unfortunate that I mean well
it's a great compiler it's unfortunate
that it's different so what our Eclipse
plug-in does is it actually runs java
sea under the hood and then exposes
those back as Eclipse warnings and our
Clips plugin is a you know mostly
functional we've had people report that
they're having good success with it we
occasionally get a bug report let us
know how it works for you yes
does the plug in supporting for mental
build I don't think so because it's
calling out to Java Sea I'd have to
check yes
I'm sorry
okay so the question is which java
version does this work with and the
answer is it works with any java version
so job this this idea so compelling that
Java 8 has special syntax to support
this tool java it's not coming out for a
little while yet but you can write them
in comments and now you can compile with
any version of Java your co-workers
won't be disturbed by it but you can
have this extra checking if you use the
checker the the Java Sea that's shipped
with the checker framework does that
answer your question yes
so that's a great question so wow this
is such a fantastic idea why don't we
just put this into java itself why is
this an external tool at all and there
are a couple reasons for this one is
that not everybody wants it another is
that because this is a library that
means everyone can experiment with new
type checkers there are there's there's
actually especially in terms of things
like immutability there's no consensus
in the research community about exactly
what is the precise single best and
perfect type system that everyone should
use so this actually just allows more
flexibility there is a JSR that's now
dormant jsr 305 that wanted to
standardize some of this and you know
hopefully maybe in a future version of
java some of them can be standardized I
do not believe they should all be
standardized because different people
need different things okay well you are
fantastic audience this is a lot of fun
we're around please ask us more
questions and go out and make your code
better thanks
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>