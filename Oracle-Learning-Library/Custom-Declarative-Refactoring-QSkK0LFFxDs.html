<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Custom Declarative Refactoring | Coder Coacher - Coaching Coders</title><meta content="Custom Declarative Refactoring - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Custom Declarative Refactoring</b></h2><h5 class="post__date">2013-01-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/QSkK0LFFxDs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon ladies and gentlemen my
name is sanli Hoda and this is my
colleague in bocce chica we are working
for Oracle on the NetBeans IDE and this
talk is about custom declarative
refactorings basically in the means so
what are we going to cover today we will
talk about some will provide some
overview of custom refactorings in the
NetBeans IDE then we will talk more
specifically about about patterns and
conditions that allow us to define the
year a factor rings then you will cover
some more advanced topics debugging
testing fine-tuning the DF at rings and
so on and at the end we will describe
the how this is all integrated in that
means what Id ways to to invoke the
effort wings in netbeans so let us start
is the motivation for custom
refactorings at all sorry today's ID is
bright some pretty powerful refactorings
rhenium refactoring even if it is like
old and cable it's if to implement it
correctly is is relatively difficult and
there are many more more complex more
more specific effect rings for example
introduce building a factoring or
introduce factory refactoring we can
move classes using a factoring
encapsulate fields and many many more
but still the set of all these
refactorings is very limited to
something that that the ID caters did
what the educators provided
but developers of maybe bigger projects
sometimes need to define the effect
rings just for their project that
doesn't have very very meaning outside
their project sometimes one needs to say
hi in my project I need to convert test
two days and these are not supported by
by the hard-coded refactorings in the
Ides and also if he if he for example
deprecated a metal and change and
provide the new method then maybe
traditional factoring good allow us to
rain a method and change all the all the
occurrences or the cause advance but we
would like to maybe to change the code
gradually maybe defecate a metal and
then we have many external plugins and
we want the maintainers of all these
external plugins to change their code on
their own then then they are like having
time to do that we cannot do that for
them because they're plugins are in
their positives and we maybe even don't
know about about these plugins so what
we will be talking about here is
basically codenamed Japan 30 and it's
let me say tool for custom declarative
refactorings that is integrated into the
net inside EE it defines custom language
that embeds pieces that are very similar
to java and it allows us to do API
structure changes
in a relatively simple a we can also use
this this language to ask a who is
calling this method this I don't know
who is calling this method and a sink
now as the first parameter or as the
second payment and so on or how many
people are doing this and and so on
sorry so let me talk a little bit about
the history of this project in year two
thousand in sun labs a group of
researchers started a project that was
called jackpot at the time and the
charter of this project was to improve
ideas and it will improve the way
developers develop their cold and this
this project included several tools and
one of them was a tool for for was to
Furcal transformation which was based on
st is not on let me say maybe requires
passion it was based on on a sts on
rewriting sts on finding sts and so on
there was there was some cold of some
implantation more like prototype that
that implanted that and rules the
transformation rules could be returned
in either in java or in a custom
language and basically the right model
of all this code transformation to was
adapted by NetBeans inversion 60 so
since that means 60 we could hide
transformations in the way similar to to
what was done in enclosure jackpot the
organ or from the sun labs we could
create code transformation even before
but it worked slightly differently and
what project see project a all
about is it's basically reviving the
language that allows us to define the
code transformations declaratively or
more precisely it allows us to define
near factoring almost a creatively
because we can in some cases rather to
Java and write some conditions in Java
so simpler things can be done fully
declaratively and you say more complex
things sometimes need us to write a
small piece of Java code this this tool
is still based on on the AST s so there
is no like matching of all the actual
textual source code it's based on
matching of STS and this language was
integrated into NetBeans since version 7
dot one and now i will give birth to two
young to show us some basic examples how
this how this language works thank you
so let's do a few examples to show how
this language language can be used for
for various things let's start with API
immigration here is some source code
showing cube usage of some deprecated
methods like utilities load image method
is deprecated and instead of this method
we should use image utilities allowed
image so how to how to do it so we can
go to
a refractor menu to inspect and
transform in this dialogue we can
specify the scope of our transformation
like if we want to perform the
refactoring or transformation on a
current file current package or we can
perform it on all open projects and here
we see that they are already
pre-installed many many transformations
and also some configuration
configuration is a group of single
inspections but now we want to create
our our own transformation so let's do
new we can rename it image 30 TS and we
can edit the script will open it in any
editor so we can write some custom
description so these two in which delete
tease and now i will write the
transformation pattern transformation
pattern has two parts it has a source
pattern anna and a target pattern it is
quite similar to search and replace
feature but the both search patterns and
replace patterns are java specific and
we can use some some special features so
we want to
replace ork open ide you tell utilities
dot load image and variables starts with
door sign resource so this is the source
pattern we can I use a double semicolon
to to to the end of a pattern and now we
can just test this search pattern if it
finds or or occurrences of a load image
so i can go to run and run file this is
just warning that there is no
transformation because i didn't write
any transformation yet so i can invoke
image and you can see that i found two
occurrences of a float image in this
file so this is the source pattern now i
will write a target pattern i want to
replace it with ork open area you tell
image delhi keys
load image and i will use the same
resource so again i will run a script
and you can see that those two
occurrences will be replaced so I can
perform refactoring so you can see that
we we now successfully transformed the
deprecated call with a script and we can
run this script on all our projects and
it will be replaced so let's take a look
at another example for instance here
with the image icon we would like to
replace this new invocation with a
static method call image utilities adult
image to icon so again I will go to a
refactor inspect and transform new
rename image icon will open it so I will
leave empty scriptions it's important
and again I will write a source pattern
it will be a new Java x-wing image icon
image so this is the source pattern so i
can I can test it music run file so now
you can see that there are two
occurrences of new imageicon creation
the first one takes an image as an
argument and the second one takes
strength as an argument what I would
like to replace only those usages with
an image as argument so I need to write
some some condition into the sauce
pattern so conditions can be defined
behind double colon and the competition
is that image is instance of
sure
image so let's test the script
so now you can see that only the version
with with the image as an argument was
found so it looks good so i can write a
target button I want to replace it with
orc open ide you tell which you do it
these image to icon and again I will use
a variable image so i can run file you
can see one occurrence was found and
this is the suggested shall suggested
change so i will not perform the
refactoring right now just
so let's take a look at another example
for instance this one you can see that
in this in this method run under walk
there is a problem what happens if if
this runnable throws an exception the
problem is that this log will be never
unlocked so we would like to detect such
situations and transform the code and
surround the run or surround miss this
piece of code always try finally block
and do unlocking you know finally in
statement so let's create a
transformation script for it again i
will go to inspect and transform and
here we will do walking
there's some description
so let's start with the sauce pattern as
i said before variables start with a
dollar sign and then there is a sun
block of cold so we call it multi
variables and those star we will
describe it later the starts and ends
with door sign so there are real
concerns announced a man's you it
doesn't matter it's just naval variable
and
there is a unlock call and now we need
to define condition that the block needs
to be instance of chakra you tell
concurrent walks walk
so I will try to run this search without
any transformation yet so looks good
and i would like to transform it to lock
then try here we'll go those statements
and in finally block we will do unlock
so I can run a script
so like performed refactoring and you
can see the Duke coat was transformed
and now the situation with vision
exception is properly handled and we can
run such transformation script on whole
our code base ESP the script
nope
and now next example is for instance
with a string equals but this call is
not the most efficient way how to do an
empty check on a string so the most
efficient way is to use GDK 6 method is
empty so i can write again a scrip for
it so reflect or inspect and transform
you and this thing
and I want to replace equals and this
drink drink is instance of java string
and i want to replace it with a string
is empty
so I can run it
it's all it fun 30 currencies so I'm not
going to perform a change right now so
these are some basic examples and now
ions or describe some syntax of of those
patterns yeah I'm sorry I will tie to do
some more a bit more formal description
Oh on how the rules look like and maybe
how they work what's out what's not out
and so on so the basic format of the
file that contains these rules is that
it can contain any number of rules that
I'd something to something else and the
rewrite rule is basically they are
looking for a source pattern and I think
it to one or more or in some cases in on
0 target patterns that that ID that
represent the new code that we want to
see in the in the source code that we
want to transform the original code to
and we can add conditions both to the
source pattern and to the target
patterns and I'm sorry I'm basically for
the for this sauce pattern conditions
this this rule will be completely
ignored if any of these conditions is
false but for the target patterns the
but the target pattern that has all
conditions to the adobe platform and TV
is modern man than the first one will be
peppered by by the system in most cases
now what can be in the in the source
button in the first part before any
conditions we can basically put
draw expressions their statement or
several statements and we can place the
pad time for class variable and metal
and that's about about all that can be
but this is basically covers most most
of Java in fact as we have seen that
there can be variables defined that
stuff is the dollar sign and doing the
matching the ast the part of the AST the
part of the code that is at the place
value variable is used will be bound to
that variable so as we have seen we can
we can use the variable as a surprise
holder for something there are also
multi variables that start and end is
the dollar sign and the multi variables
will consume any number of st nodes the
difference can communicate on this
button on these two patterns this this
first part time will only match such
indications of erasers listed that have
exactly one parameter this other pattern
not match any invocations of array array
surface regardless of how many
parameters they have there is one
important point if the variable is
repeated in the pattern then the engine
itself and the pattern matching engine
that finds the new matches occurrences
of the pattern ensures that the piece of
code that corresponds to the vibe to the
repeated fable is in some reasonable
sense that the same for each of these
occurrences to explain this this more
like in in a linear more understandable
I let us consider this
this declaration of two fields a and B
and and this this and letters at this
pattern which can be described as
assignment to itself like assigning
something assigning value of something
into the same variable and it will not
only find this a sign I into a but it
will also find this assign a to this a
because the meaning of this a and a in
the context maybe maybe or is the same
if this second egg would be a parameter
for a constructor for example then it
would not it would not mark this this
piece of code because the meaning of the
eyes would would be different which is
also the case here in in be assigned to
a where these are not the same variable
so the piece of the code that
corresponds to these two two occurrences
of dollar VAR are not not reasonably the
same I'm sorry there are some let me say
a bit special forms of variables that
deviate from from what we have seen
before for example for statements we
need to to end a variable this semicolon
because otherwise the engine could not
could not understand whether we mean an
expression or a statement in some cases
so if you need a variable that will
match any statement it's it's days and
increases the semicolon variable not
variable matching any number of
statements basically the same as the
dollar sign at the end in in Java there
are some places where some part of the
code or part of the st is
maybe maybe missing or can it can be
missing in the source code for example
the alt section 44 eighth or initializer
for available and in some cases he
actually don't care if there is an out
section for any for now and in that case
is you can use these multi variables and
it will it will mean whether it's there
or not I don't care this this pattern
should match the if so this this pattern
they will match any any if regardless it
if it has all section or not modifiers
are a bit special in in Java because we
can have annotations inside modifiers so
there is a bit special form for
modifiers but if if you use the
multivariable at place maybe would place
many public then it will consume any any
modifiers and any annotations under this
variable there is special form to to
match any number of keys and there are
some more very specific special forms
but it's a probably not not generally
useful now this was about the sauce
pattern part of the rules now let me
talk about the about the conditions part
of the rules and there are basically
three types of conditions in the
language one is defined by the language
itself or what the first kind is defined
by the language itself and these are
instance of an otherwise you'll see them
on the next slide then there are some
hard coded terrifying conditions that
look like nettleton occasions that when
me when we
ride em to the rule but this can be this
a bit different because this I how could
it but but not defined by the language
but defined by the engine itself and
then we can have custom conditions
conditions that can be defined in the in
the profile itself we can say that for
example the sauce pattern matches
matches or must fulfil our conditions by
by joining them based this end and we
can negate the results for the
conditions by by North it's somewhat
similar to java so a bit more about the
language type of conditions there are
the basic most important condition in in
this language is instance of and it
allows us to enforce that expression
bound to the given variable is of
certain type so for example we can look
for calls for of its empty on things and
not own collections we can enforce the
the constraint that the same thing must
be a method of staying for example and
then there is condition otherwise that
is valid only on fixies and it basically
means if there if the conditions for no
other effects are too so there is no
other effects on a target patent that
that would be used then use this this
pattern that that is that is crime to be
used otherwise is this advice condition
and now a bit about the the standard
hard-coded conditions as i said this
look like like method invocations for
example they
a condition that checks that are
variable that corresponds to the element
that corresponds to a variable has some
kind or some modifier so that imagine
you would try the pattern for
double-checked locking for example you
can check whether the field into which
we are assigning is volatile or not for
example that that's one of one of the
usage of this method and these are there
quite a few of these are coded
conditions there are conditions for
pattern matching that allows us to say
that the code that is bound to the
variable contains some some button
contains code that that matches some
some other pattern for example there are
methods that allows us to to inspect
elements effort by a variable that
that's basically the example of has
modifier we can check well where is the
front of events located we can check in
which in which class of an inch package
which is good for example if you are
bridging new API to the old fan you
probably don't want this page to be to
be collected so it can be used to
disable conversion inside inside pages
for example and there are some other
more random checks like if something is
a new lateral and so on and now we
talked about the sauce patterns about
the conditions and now just quickly
about the target patterns about the
parts that tell us how the result should
look like they are basically very
similar to the source patterns the
meaning of variables in indy staggered
patterns is slightly different
because in the target pattern variable
will be replaced this is the original
source code which is different meaning
but it's it's quite natural I think and
there is some special form there is one
special form in the target Italians if
the target pattern is empty the the
occurrence will be removed from from its
pie and whatever the parent is so that
we can for example remove system high
paint lines by simply specifying empty
target pattern and it will remove remove
the call to sustain our print line so
now I give the word back to an to show
you some more demos ok so let's continue
with our example with string I'd like to
show you how to use conditions as in a
target patterns as i said before method
is empty is available since jdk six so
we can hear right the condition that
that this transformation should be used
only if if the project is version six so
source version
these six
and we can use some different
transformation for instance drink zero
this transformation will be used for
older versions so we can use other voice
so i can run the script
so now you see that the version is
empathy is being used so I can go to
project properties and change source
version to jdk 5 now I can involve
script again and you see that here the
other version of transformation script
was used so i will switch it back
okay so next thing I would like to show
you is how to use those empty and the
target patterns and to remove some
pieces of code can be used for instance
for removing some system.out.print lines
which are usually used as some kind of
debugging output so let's write write a
script for it use new remove system aunt
so this source pattern is quite simple
it's just system out print line variable
and we want to rewrite it just empty
string we can use even more patterns in
one file so I can use it to remove also
just prints
so did you mean system add so i'll just
print ok ok out so for system are so we
can see there are also some other
occurrences which will be also removed
so i'm not going to perform the
refactoring but you can see that those
changes or detected so let's go back to
a presentation some more advanced topic
och topics so some more advanced
conditions or do three matches any
contains any and matches with bind
matches na is similar to for instance
string dot matches which takes regular
expression it means that matches any
returns true if pattern exactly matches
are given variable those patterns in
matches na are again those have the same
syntax as a source patterns for for
jackpot transformation so we can use
patterns also in conditions the next
condition is contains any which is
similar to match is a name but it only
returns true if if
variable contain contains as a as a
substring the pattern and matches with
bind allows to use variables from the
patterns back in a in a sauce pattern i
will show you an example how to use it
now here's the source code which has
some conditions you can see in the first
condition that this condition can be
simplified because this condition is
always true so we can detect such
situations and remove the else part
completely and under if statement and
the second condition this one can be
simplified and this false can be removed
so let's try to write the transformation
script for it so we can go to inspect
and transform
simplify if
so we want to simplify a if statement so
if some condition and
else
and now we are interested if a condition
contains true or false so we can simply
use contains any condition this is the
variable from here and you are
interested if it contains one false or
true and then we want to rewrite to just
then part
if much is any condition
through or anything
and we want to simplify it if
now i will use matches with bind
so condition false
and he
so now we can see that this variable is
slightly use here in transformation so I
can run a script
so you can see that this f was
simplified only then statement remains
and here false was removed from from F
because it was redundant so this is
example how to use contains any matches
any and matches is bind Souls these are
those standard built-in conditions but
the these conditions are not powerful
enough to do some special things and
jackpot allows to define your own
conditions which can be defined using
java language and those pieces of code
can be inserted into the jackpot pattern
into angle brackets and ? and the custom
condition is just a method which takes
variable as a parameter and returns a
boolean so let's do some example for
this
now I will not write a transformation
script but just a detection of
thread.sleep call and I'm interested
only in those scores which are invoked
from synchronized context it means
either from synchronized block or from
synchronized method so it means this
call this is innocent harassed method
this call is in a synchronized block
this thread sleep is not in synchronized
block or not in a scene horizon method
this one also is defined in a
synchronized method is not in col denson
Christ context because it's defined in a
in a local class so we don't want to to
find this so let's create a script for
it
when you
sleep
and it's script
can choose some description text so the
basic pattern search pattern is just
thread.sleep and some variable and we
want to use some custom condition so in
synchronized context and we need to pass
a variable on which we want to invoke
this method so you want to use a whole
pattern which was matched so now I will
define custom condition so it needs to
be when method
thanks Lori amble
so now how to detect synchronize context
we will we will iterate up up to the
syntax tree and we will try to detect
synchronized if it is an in a metal
declaration or we want to let X
synchronized as a synchronized block or
we want to detect class level if we are
on a class level and we still didn't
reach a synchronized keyboard so this
call is not in a synchronized context so
we will iterate until the current it's
not know
we will go each iteration one level up
so now we will detect a synchronized
book so we can use again jackpot
patterns to detect it
so the pattern to the tech synchronize
context will be synchronized some work
and some statements
and if we found a synchronized a block
so we returned through now we want to
some type of you
so much is current and now we want to
let act you want to detect method either
so I thought error contains I some
modifiers some type method name and some
arguments games throws
exceptions and then there are some
statements
so this pattern detect method header and
we want to return true if this method
header contains a synchronized keyword
and false otherwise we can use some
utility methods defiers
con games
fire synchronized
so now I need to add some import
and now we need to detect class level
so contain some modifiers there is class
keyboard plus name extends something
components some zinc and some statements
and if you reached a class level so we
can return false
otherwise also we've done for us so
so let's try it
so it found 10 curane's should find also
this one so I probably did some some
typos
here
should be curly bracket
ok
so do both occurrences were orphaned
while the other two were were ignored so
this is how to write write a custom
conditions so let's go back to the
presentation debugging so the NetBeans
IDE also supports some basic debugging
of those scripts that it highlights
those pieces of code which matches the
open matches the script which is open
the editor so I can show it
so
can't revert it back I will open the
script
so this is our first example or first
pattern so now using this icon I can
turn on debugging and now we've got if I
select a pattern in the source code this
highlighted here we can select this one
so the butter is highlighted here
somehow does not work
well doesn't matter
another another part of of creating
scripts is testing so the NetBeans also
supports a testing of those script tests
are undefined in the in the file which
ends with a test a test extension and
they are defined using this double
percentage mark and test case keyboard
then there are comes some some source
code and double percentage mark with
this arrow shows our starts expected
output so i will show how to write a
test
I can create a new file
we'll give it the same name as a as a
pattern
so we were used test case in some name
utilities and
I knew some copy paste
i can simplify it just to use one
transformation
so the IDE immediately immediately
checks the contents of the test so now
it shows that there is incorrect number
of outputs because I didn't write any
output yet so I can copy-paste source
here now the NetBeans claims that the
output is incorrect it is because I
didn't change anything so i can use this
hint just to put actual actual output or
the script and so now test is green
everything is correct and so i can use
this this framework for writing tests
for for my scripts
and now running refactorings so there
are two options how to invoke or
integrate those scraped into the
NetBeans IDE the first 1i already show
this is through refactor and I inspected
transform so you can you can run the
script on several files or several
projects another option is to write a
script into directly into our project
into meta in of grade folder you can put
those scripts there which are specific
to your project and the IDE takes those
crates and use them so all those scripts
I greeted our also here in the meta in
of upgrade folder and the IDE itself
uses it so now this is the here you can
see the empties the right bulb here
shows those transformations you can see
that there are two versions of it the
first version is a diversion I I've
created during this demo the second one
is the pre created one which was already
in the project in meta in upgrade so I
can use those transformations also from
the editor I just can hit enter and
it will rewrite or use the script we
write to the text
those scripts can be also slightly
fine-tuned like it can we can change
display name or or description or you
use separate suppress warning IDs so
so I can hear i can change name for
instance can change the load image can
change also name of our transformation
like change tivities Walt image to image
tivities image
so no
you can see hindle in the tooltip my new
name is the upper one and there is my
description which I just wrote into the
script I can also use suppress warnings
so now if i go back to to the editor
it's too long
I'll try to make it a bit shorter
so I now can use the suppressed warning
so at the suppress warnings in two with
my own ID so the IDE later will ignore
this this call and will not suggest me
to change it so this is for fine-tuning
so these are few more length for if you
are interested in this the first one is
description of the four jackpot patterns
like generally everything with what we
would be presented today can be found
there in a form of documentation the
examples which i present it are
available here anna in a bit bucket so
you can take a look there and download
the mold source so we just presented how
to use our domain specific language to
to create your own transformations and
this feature is part of the Jeanette
beans ide since netbeans 7 dot 1 so if
you go to NetBeans of or can download
this IDE so you can just use it so now
we have time for for your questions
there are any
otherwise I think we are done
you mean our examples or the NetBeans
IDE
our examples are here at bitbucket
okay thank you for listening</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>