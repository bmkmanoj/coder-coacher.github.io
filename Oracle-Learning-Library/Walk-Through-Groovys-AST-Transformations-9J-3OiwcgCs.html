<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Walk Through Groovy's AST Transformations | Coder Coacher - Coaching Coders</title><meta content="Walk Through Groovy's AST Transformations - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Walk Through Groovy's AST Transformations</b></h2><h5 class="post__date">2013-02-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9J-3OiwcgCs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to wall true of groovy ASD
transformations I hope you guys have
enjoyed the keynote yesterday and the
beginning of the talks of this year this
day we have lots and lots of session for
you this week and I hope that you guys
will enjoy this one so based on the
title these will be related to the
groovy language so now I'm gonna ask you
guys how many of you already have some
previous experience with a group
language well most of you do you like it
ok perfect do you like also working with
Java come on guys you do perfect so the
whole point of this session is to show
you soon the tricks that we can apply
from the groovy language on your daily
work but using the Java language you may
see you may have seen across the years
that well sometimes the Java language
can be very verbose and we had to write
a lot and lots of boilerplate code well
turns out the groovy language can help
us reduce that amount of verbosity in
many cases ok a little bit about myself
and why I believe I'm qualified to give
this talk to you guys I'm a Java
developer since the beginning since
James Gosling are the other guys put out
the applets of the dancing Duke and the
nerd boost X yes I was convinced and I
say I'm gonna do that so I learned Java
and then I became a true believer of the
open source projects because I discover
Linux and based on those two things open
source and Java I later discovered
groovy in 2006 next year after because I
was so insistent on saying hey guys this
is broken hey guys this doesn't work for
me hey guys can I fix this
they eventually said you know what let's
give you commit rights and you can
become a member of the groovy
development team and then the year after
that two friends and myself created this
framework called Gryphon which there's
also another talk later and Wednesday
morning that is kind of like a
culmination of all the things that I
like to do groobie and desktop
application development I'm currently
working for canoe is a small company in
Switzerland I actually come from Max
girl so I keep hopping all the way
around across the Atlantic
I also a Java champion which means I
have to work now harder you know in
order to promote the Java and I think
that's all that I want to say about
myself that's the boring stuff now let's
get into the interesting stuff so what
are ast transformations well these are
essentially hooks that you can get
access to when dealing with the compiler
so we know that in order to get rid of
some of the problems of Java's verbosity
or that it doesn't it's not really that
dynamic itself we oftentimes generate a
lot of source code because well we want
to even generate maybe data access
objects or services that are used type
safety and all the properties use the
same their correct type and the correct
name bla bla bla bla bla we end up with
a bloat of all our source code
well worry if and specially when you
want to do a modification of this
generated source code what's the problem
maybe the model is no longer in sync
with what is being compiled and this a
maintenance problem will it wouldn't it
be better if instead of generating
source code we could hook into the
compile process and instruct the
compiler and some special places where
we want some magic to happen in this
magic is create new properties or
generate new methods that follow the
specific convention what convention the
one that is required by your project
itself so and this is precisely what AC
transformation allow us to do there are
two types of AST transformations global
and local what we're going to discuss
today are local seo transformations
because these allow us to specify
exactly where we want these magical
things to happen now this this can be
seen also as enable meta meta
programming at a compile level because
we will be adding new things or we can
we can even remove existing things from
a class at the end
everything will be baked in into the
bytecode which means that once you have
compiled you can load your classes into
your standard Java based project and
your java language and the other Java
compiler things will be able to see
those additions so let's start with the
ones that were available since the HD
transformation progress added I think
that was added back in groovy one six
three or four years ago but then we
added much more angry one seven and
these were part of the initial set that
made things much easier so let's talk
about delegate I know that when you're
making use of an IDE you can select
probably a fill or a method and tell the
ID hey please select generate all the
delegate methods that are related to
this particular type now this again is
source code generation is somebody
decides to add a new method to the type
that you're just delegated to then you
have to instruct again your IDE to
generate that new method right
or if somebody renames this thing or
removes the method well you see the
point right so what we do with this add
delegate annotation is annotate a
particular type in this case is the date
type the Java util date and that's it
when we compile this class the event
class if we look at the compiled
bytecode we will see that it has a new
set of methods those methods come from
the Java util date those methods will be
set time get time after before and all
other public methods that the this type
exposes so if I run this code which
unfortunately I was prepared to do it
live but I had to switch at the last
minute computer so this definitely not
groovy install here so we'll see all the
slides but if you compile this code then
look at the line number seven we
generate a new instance of an event
using what we call the turbo chart pojos
in in groovy
that's just the map notation for setting
properties on it and an online thing we
create another instance of this event
and in line 13 that's where the
interesting thing happens we assert that
the great conf
event is happens before the two GX event
now that b4 method did not exist before
and certainly we did not add it manually
to our event class I took this as
natural from Eclipse and you can see
that the b4 method has an underline on
it because Eclipse doesn't know about
this dynamic things so it assumes that
is going to be added by metaprogramming
well in fact it was added by doing
compile metaprogramming so when I call
this and execute this code then there
shouldn't be any errors if I change this
now to say great comm dot after to G X
and I should get a different section
because what we're doing is that the b4
method on this particular instance is
delegated to the field that we have
defined there the one field of type date
so anything we do there will be sent
directly to the one field is it true
that the one field of the great
confident is after to G X dot when no so
that this is why we get an exception now
the great thing about this is that the a
delegate will work both with concrete
classes and interfaces in the case of
date we have a concrete class but if I
were to delegate to a list then my event
class will gain all the interfaces that
list also has in its hierarchy class yes
there is a question
what are the metaprogramming assumptions
for a delegate for typesafe oh no it
actually does what the anti legate
annotation does is inspect the target
type in this case state look for all the
public methods and public properties and
then add them directly to the compiled
bytecode map there's another castle and
that's a problem with that I don't
having this live coding if I defy define
a public method that matches one of the
methods that I'm about to delegate then
the method that I created is going to be
used instead of the one coming from the
delegate so if I manually define a
before method in the event class that
takes a date as an argument then this
method will be used instead of the one
coming from the data object that is an
important thing because if you happen to
delegate to two different types that
share something in in the superclass the
first delegate that is encounter is
going to add the public method so I
previously this this trick of delegating
to two different lists well the first
list was the only one being affected not
the second one on thought you will see
that the public contract of list was
being fulfilled by this class so the
nice thing about that delegate is that
if you happen to add a new method or
remove a method from the delegate T you
just need to recompile the whole thing
and then you get everything you don't
need to generate source code and again
these additions will be seen from the
Java source point of view as well so the
next transformation I'm going to show is
singleton now I'm assured that most of
you have read the affected Java by Josh
Bloch so what will Josh blog say about
the singleton pattern how many ways are
there to implement the singleton pattern
too many how many of them are correct
just one
it just so happens that the add single
tone AC transformation implements that
particular version so in this case you
can see we annotate the accountmanager
class with add singleton perfect and
then we make use of it now you see in
line 14 that there is an static code I
can manage your dot instance so if you
as you said you're familiar with with
groovy this will be the same thing as
calling I can manage your dad get
instance as static method right and then
we call up and on it if I try to run
this code creating an instant manually
of a care manager doing new account
manager I will get an exception and the
description in deception will say this
class is a singleton so you should
better use this other way to access the
shared instance so the and what that's a
great thing does the the error messages
in groovy are definitely much more
descriptive that what you find in your
plain java the says symbol not found and
that's it all right third one are
immutable so we know that this time of
an age immutability is probably in
everybody's mind what are the rules for
creating an immutable class it could be
the finest final may be all of its
fields must be the final final all of
these types will also be immutable it
should provide a constructor at least
one constructor that will allows to
initialize all the values should provide
probably Gators for all of them no
setters of course and an equal sign hash
code methods that match and and provide
the the real immutable concern so lots
and lots of small rules that you have to
follow and if I were to write this thing
in Java well you can see that the code
exploding even if there's just a handful
of properties but in this case I have
now two classes when there is a mutable
person the first one
and an immutable one then let's create
two instances of the immutable person
notice that I'm creating those two
instances using the same values and
third then we create an immutable / -
immutable persons now when we compare
the immutable ones even if they have the
same values they are distant because the
in this case the not equals operator is
making the comparison just calling the
equals method and turns out they are
definitely different well when you do it
with the immutable versions of the
person class turns out that the equality
holds true because now we are actually
comparing the values now if I try to set
a value for one of these properties of
the immutable person then I get a
different kind of reception read-only
property reception now there is a
particular catches here if instead of
calling person one that name using
property access I call person one dot
set name which we know it's valid groovy
I will get a different inception the
session will be method missing exception
because the added mutable annotation
works by defining properties in a way in
a special way in the Biko so we'll never
add that particular set name method in I
will say the full disclosure I believe
this behaviour is a little bit
surprising because it doesn't matter if
you two
method access or property access you
should get the same exception read-only
property exception so I am not aware of
anybody that is trying to change this
thing in the future but it so happens I
will spec this thing to be just one
particular set of read-only property
exception so there shouldn't be any
further surprises you guys let me know
if you have any questions at any time
I'm happy to answer them so now we get a
little bit more into the runtime aspects
of meta programming Ruby has this notion
of cata
with categories you can apply or add new
methods to types in a restricted space
of time which is just within a block
that's what we see in in lines eight to
ten so I was I have seen some people
making use of categories instead of
doing metaclass manipulation directly
because the whole point of these things
that they are only applied in a specific
portion of your code this particular
example shows you that you can apply new
methods to the interior class now for so
you this may be some kind of a shocker
the integral class in Java we know is
final so how can you extend that you
cannot
but using the runtime metaprogramming
techniques we can add new methods even
to final classes and that's precisely
what we're doing with the interior class
we're adding a new method called pounds
so when we are within the limits of the
usage of this particular category we can
call the pounds method on any integral
if I were to call the pants method
before line eight or after line ten I
will get a runtime exception because the
method is no longer available now
unfortunately for this thing the app
category SD transformation is mostly
used when your client code is skroob
occurred the previous s3 transformation
that I show are perfectly fine if you're
consuming them from Java this one is the
first that you had to be running groovy
in order to make the most of it similar
to category we had mixing and in mixing
notice that the definition of the AC
transformation is not on the class that
defines the new behavior but it's on the
class that receives the behavior in this
case is the class cat and the class dog
what we do initially new method to this
class is very similar to what we did
with the category now on calling it
bouncer and now both cats and dogs
know how to bounce the difference with
add category and mixing is that there is
no longer a limit on when you can make
use of these methods there will always
be active they will always be enabled so
you can call them anywhere you want to
also you inherit all properties
notice that the bouncer class has
defining that properties are property of
name times of type integer and both cat
and duck instances also had that
particular property now we have a graph
and I will say that aircraft was the
first ASD transformation implemented if
it's if either the first of the second
and at this point I would like to say
that the original author or the SD
transformation is sitting right there at
the back of the room if you have further
questions later please ask Diana Ferren
yes thank you very much I will say that
ASD transformation framework is probably
the most important feature added to the
language since one six because it allows
you to extend the capabilities of the
language without introducing changes in
the grammar that is awesome so what a
grab does for you is connect to the
network or maybe a maven repository and
downloads from dependencies for you say
in this particular script that I have
the only thing that I need to run it is
access to the grooving interpreter I
know that you may try to import some
library in this case is JSON live which
for sure it doesn't come bundled with
the groovy distribution so if I don't
add the first line a graph this script
will fail because he will not find the
dependencies but if I put that single
line at the top then the groovy compiler
will say hey and really important's that
mean that is annotated with this thing
and I will see what is inside this a the
short version office of defining the
group the artifact at the
version of some particular dependency
you can use the extended version as well
and go directly to the default
configuration that groobie has and
download it from the network you can
also configure another repository using
add grab result is an RHD transformation
so once it has downloaded and located
that dependency it will put it on the
class pad and then continue the
execution so now magically the jason
groovy builder class will be now
available and the script will work now
this is perfect for distributing
self-contained scripts this is you're
working in a team environment and you
have built a bunch of the scripts that
you want to send to your teammates well
the other team has only have to have
groovy install on their machines and
nothing else
the add graph transformation will make
sure that all the penances will be
downloaded from the right places yes we
have questions yes you can specify
additional the repositories is another
transformation called add grab resolve
from which you can define the URLs of a
local maven repository for example if
you're behind a network behind the
firewall yes this will certainly work by
default we always query the maven
central repo as long as you have a
network access everything should be
peachy then we have add synchronize and
how many of you make use of the
synchronize keyword alongside a method I
know I do guess what we all did it wrong
it's not a good idea to expose to client
code that that particular method is
synchronized because it would be
synchronized on the objects unlock the
preparatory log that every object has
now what we do the with the add
synchronize annotation is generate a new
private lock it is as a matter of fact
an empty object arrived the reason why
it's an empty object arise is because
object arise are serviceable by default
whereas the
object class is not so we are in this
case the My Luck object definition is
not really well defined in this but
that's okay so the line number 7 the to
a staff method will now be synchronized
in a new internal log line number 10
will be synchronized around another log
that we chose defining so these two will
not hit each other we can also apply at
synchronized on static methods so the
the key thing to remember here is that
if you just use at synchronize solely by
itself it will use a new lock that is
always created with the name lock is a
private field in your class or if you
give it a name in the case of my lock
then you can use any other object that
you define that gives you that that
Liberty that freedom so now at lacey
this will work with java as well what we
do in here is annotate in this case a
property whose value may be very
expensive to compute so what we had
there in line number two is a closure
that defines a list of values and then
we invoked a closure what gonna happen
is that as long as item access the
values property of any sneaky instance
the list will never be created has not
been computed but by the time that I do
I get values or use property access to
read the values property then the value
will be assigned to the property and now
from now on that value will be there
what I'm doing in line number 8 and 10
is making sure that I can read a private
field that backs up the lazy SD
transformation so that those are the
gory details just to make sure that if
you copy and paste this thing into the
GUI console or a groovy script then you
see that this thing actually works the
what we see in that line in those lines
8 and 9 is how groovy can read private
fields and have access to private
methods this is great for unit testing
please don't do it in production code
only if necessary but most of times you
don't so what we see in line aid is
making sure that that private field is
has not been initialized at all then we
read the values we make sure that the
the assertion passes and then the next
line we assert that that private field
actually contains something which is
what we define an initial closure boom
there it goes then we have new if I and
I guess that sold you and the audience
have experience with other languages
perhaps Python yeah some Ruby no
JavaScript okay so they're those every
language has its own way to instances
objects or bring them to life in the
case of Python you can let go of the new
keyword altogether and in the case of
Ruby you can obtain the name of the
method after the type so the add new
ePHI transformation allows you to use
both of those two notations why because
it might make sense for a particular DSL
that you're writing the new keyword
might be some kind of a blemish in your
DSL so let's remove it or maybe it makes
more sense to do type dot name so in
this method that we have created bushell
we knew if I on a type which is Apple so
now inside that method I can create
instances of Apple using the standard
Java groovy way new Apple or the Python
way just defined Apple and the arguments
for the constructor in this case is just
empty or do the groovy way Apple dot new
either way will work this will make your
DSL much more compact and perhaps more
readable
and finally we have ad by Neville and
that beatable maybe this is the second
AC transformation ever Britain and if
I'm correct correct me Donald this this
is the first one in grab was a second
the whole point for writing this amazing
st transformation was for making swing
application development much easier this
is the reason when you want to create an
observable beam what are the things that
you have to do or probably inject a
property change support and a lots of
methods are a keychain listener remove
prepetition listen and most importantly
trigger a property chain event whenever
a property by value changes right so
this means bright in a custom setter but
we know that the groovy compiler already
writes custom setter for us so how can
we get into the dynamics of the compiler
to do what we want so that the you can
trigger an event that's precisely why
this thing was work in order to make
that model class an observable class we
only need to annotate it with at
bindable now all that boilerplate code
for instance sharing property change
support adding those additional methods
and firing the property chain event when
a property changes value already baked
in into the bytecode if on the other
hand that what you need is trigger
beatable events then use the add
beatable ast transformation so what you
see in that in inline number eight again
eclipse didn't know that there is a new
method called add profit chain listener
that's why it's underlined and what we
do there is raising a listener that will
count how many times it has been invoked
the on lines 12 and 13 we change the
value twice and then we assert that the
counter was actually hit twice so in
this we can prove that at least the add
property chain listener method is
working and that whenever each end value
of the name property property chain
event
were also fired so yes you can thank
swing for making this amazing addition
to the language now available since
could be 1/8 we have the ad lock
transformation and it's sibling
transformations at Commons at lock for J
and at SL for J the DS series of
transformations will do two things first
if your class that knocks expose a
logger of the particular logging
framework you're targeting then it will
add it for you you have now access to
our property name lock that is of the
right type the second thing is when we
make use of the logging statements in
for severe fatah
warning all those things we have been
told that we can use simple strings but
if we use compound strings or whatever
we want to lock is kind of expensive to
transform into string then we better
make use of Gardena statements so if the
info level is enabled
then we can call log info without any
problems
but if we start to do that in our code
then we'll see lots on all ugly places
where we can lose track of what we are
actually doing just to please the log in
framework to not create the message if
the mellah in the level is not enabled
so that the second thing that these
transformations do is locate those
methods and if they are not guarded by
an if statement that checks for that
particular level it will add it for you
if I inspect the byte code for that log
info I will see an if lock info enabled
then whatever is there because the
argument for this info statement happens
to be a groovy string which is a
compound stiring it may be expensive to
compute this groovy string so the a
string transformation goes to work
so you can hook in any of these for a
login framework there's no problem in
Herrick constructors perhaps the better
usage for this transformation is when
creating custom exception subclasses but
the inherit constructor does for you is
make sure that you're separate that your
subclass has all the separate
constructors coming from your super
classes that's nice I mean this doesn't
prevent you from adding more
constructors just make sure that you
comply with the contract of your
superclass so that's why this particular
my exception which is a subclass of run
time the the whole class body is empty
but I can call I can create instances of
my exception using different constructor
combinations how's that for eliminating
boilerplate code we also have the two
string ast transformation and what this
little guide does is make sure that your
two string implementation is it's kept
nice and tidy there are two modes of
operation if you just annotate a class
to string then when you call it when you
print out an instance you will see
values of all the properties of your
class print it out in the same order
that you define the properties now
sometimes is okay to just see the values
to some other times you would like to
see what are the property names attached
to those values so you can add a new
argument to the two string annotation
include names equals true and then you
will see those things you can see that
the customer class has that particular
setting while the address class does not
if I create an instance of customer and
address and print them out you see that
the customer will print out the names of
the properties alongside the rest
tip values whereas the address class
only prints out the values of its
properties next equals and hashcode this
is related to the ad immutable AC
transformation there are sometimes we
would like to implement a cosign hash
code in in in standard way I know that
the IDE also has a menu option for
generating equals and hashcode what
happens if you add a new property you
change the type or make it new label
right you have to update and regenerate
that code
well with ICCA's equals and hashcode you
don't need to do it because it will
always be regenerated as long as you
recompile your code so we created three
instances of the thin class that has
been annotated with this thing notice
that the first two instances have the
same values where the third one doesn't
then we can now assert that thing 1 and
thing 2 are equal whereas thing one and
thing 3 are not we can also cert that a
hash code or the first two instances are
the same whereas the hash of the first
and the third one are not pretty good I
would say
we also have trouble constructor
what type of constructor does for you is
generate a combination of constructors
for a particular class based on the
different properties that is higher that
it has so you know that
groobie supports default constructor
that takes a map as a means as an
argument this is how we can define
properties on the construct on the
constructor which is quite quite
interesting but what if we wanted to add
constructor that will take arguments in
a series of orders based on the same
order that we define the properties so
if we wanted to define a constructor for
this thing the animal maybe you should
take three arguments the species the
name and the age what if we want to have
a default value for the age then now we
had to define a constructor that only
takes the species at the name and what
if we add more properties right this
thing starts to explode so what the
total constructor will do for us now is
generate of course the empty constructor
a constructor that takes just one
argument it will be the species a
constructor that takes two arguments the
species and the name the order is
important and another constructor double
check the species the name and the age
it will also honor the map constructor
for you so now you have access to five
different constructors so what we see in
line number eight is three different
ways to instantiate an animal instances
so the first one makes use of the 3d map
syntax well the second one calls the
constructor with three arguments and the
third one calls the empty constructor
then we make assertions of the on all
the elements that we have in this list
we ask for the species so if you have
seen groovy expressions groovy path and
your orgy pad where we do with the
animals of species
yes sorry I bring some water
what we're doing there is act as each
element inside the list for these
species properties so that's why we get
dark cat and gall fish then we do the
same for name and age and now you can
notice that on the third instance
because we didn't define any properties
in the constructor we get the default
values it's easy as that and well going
back a little bit we saw equals and
hashcode we saw two a string and we saw
tuple constructor
these are nice things to have in a
well-behaved pojo well you can either
annotate a POJO
with those three transformations or just
use a single one called canonical what
canonical will do is just combine these
three transformations and then you're
done so you want to have a well-behaved
Java Bean that has equals and hashcode a
well printed a pretty printer to string
and as many constructors as you want in
order to create this instance in several
ways AB canonical you're done and all
these additions again let me remind you
are visible to Java language because
seeing the bytecode that's great so if
you have to work with pojos all the time
then just move them to groovy source put
a canonical at the top and don't worry
about it
the javabeans a specification which just
happens to be just a set of guidelines
also defines that when you want to deal
with index of properties the getter and
the setter has to follow a naming
convention and the convention also on
the type of arguments this is what we do
with the add in the exit property AST
transformation we annotate a list whose
name is members so we know that the
compiler would generate that get members
and set members method for us quite
because that is a property of type list
but we will also like to have a set
member that takes an index and the value
of the member that one set and I get
member with an index that's precisely
what the add index property does product
we will add those two new methods for us
so let's create an instance of the ban
object got the band class sorry we
assert that the list is empty then we
add a new member we add a John to it
using the groovy notation for the
operator overloading thank God we have
operator of note in groovy then we call
this new method set members with an
index and the value it will be the
second one in this list and then we make
use of the standard notation for
indexing in a list that is members two
and finally just call the regular add
method on the list so now we have the
four members of the bills we can assert
that the four members would add it in
the right order and if we want to query
which is the fourth member just called
bad bills get members with the index
three and you get wrinkled perfect and
there are of course many more st
transformations that we can explore how
to clone will make sure that your class
implements the cloneable interface and
defines a clone method I believe there
are there is a choice for you to specify
that deep
or a shallow clone up to externalize
will make sure that your class defined
implements the egg turn externalize Abul
interface and defines read object and
bright object conditional interrupt time
and interrupt and thread interrupt these
are very useful when writing the scripts
there may be a time when you're running
in a script and you hit a condition that
makes it just run forever right well
with either of these three in particular
for each one of these scenarios you can
specify a condition when you want to
when you want a loop to break out free
and then continue or if that condition
is a time thing they use a time
interrupt just a timeout and the trend
interval to be honest I haven't really
used it but I know that you can also use
it to just kill out a particular thread
and continue with the following
execution now package scope
how many visibility accessors do we have
in the Java language for correct what we
smithson in groovy is the package
private how do we attain that in Java
language by now specifying a miscibility
accessor but we use that notation to
define groovy properties that's why we
don't have it so what the ad package
scope
annotation does for you is gain back the
package protected access visibility you
can annotate a property or a method or
even a class with package scope and now
that will be packaged private then we
also have with read look and with write
lock these are just nice additions to
inject a read write lock into a class
and call its methods on it and then we
also have add field add field is mostly
used inside the script classes because
when you define a script and inside a
script you put different variables
without putting that type those
variables
are added to the scripts binding a
binding is nothing more than a glorified
map so how is it
computational extensive to access
property in a map versus as accessing a
field in a class yeah certainly because
you are paying the price of a method
call at least one so what the AB feel
annotation does for you is that if
you're putting that in a script instead
of putting that variable into the
binding it will be a feel into the
script class so you're making use a lot
of variables inside a loop inside a
script it's a good idea to put at field
on those variables so now the
computation will be much much faster and
of course there is a static groovy since
we release groovy to do early in this
year well no seven-digit when was it
late June early July
we support now a static type checking in
the groovy language what does this mean
it means that now you can get compile
time errors how you can do that by
annotating classes with the at type
check annotation now I haven't prepared
much material regarding this this
particular thing because I know that
gonna force the project lid of the groov
project we'll be speaking about this
particular feature later
cameraman maybe said tomorrow tomorrow
or Wednesday I'm sorry about that but he
will basically be speaking what is new
about groovy 2.0 and a static type
checking is one of the big themes so he
will be able to give you guys more
insight of what we're doing with static
type checking and in the end what is the
the simplest thing about this thing is
just annotate the curl with this thing
and you're in business there are of
course more SD transformations that were
added to the
groovy language in later editions of
groovy 1/8 and grew it - oh I didn't
find time to actually update those
things but there are other ast
transformations found in other projects
that are related to groovy perhaps you
have heard about Grails the full stack
web application development framework
well Grails has both local and global HD
transformations in Grails one 3x they
had only one transformation identity
this transformation will make sure that
your domain classes will be marked as
such that they will contain fields named
version and ID and that's it
in Grails - oh they haven't changed
their codebase by making lots and lots
of usage of global ast transformations
and now what they do is that the domain
class will have all the meta editions
from ghorm dynamic finders for example
baked right into the by code not just in
meta runtime meta programming so I
mentioned earlier that there are two
types of transformations global and
local glockl require a transformation to
identify the places where we want the
magic to happen a global transformation
is always enabled what happens there is
that if you compile code that may not
require a global transformation the
compiler doesn't care it will still try
to apply it so it's up to us the
implementers of global history star
informations to make sure that if it's
active we are we that it transform only
what really needs to be transformed now
the griffon framework also has a couple
of AST transformations what i have list
there are just the local ones we also
make use of global transformations the
event publisher transformation make sure
that any class can become an event
publisher it Griffin has this notion of
our very lightweight event bus so any
class that is annotated with this thing
will also become a local
eventbus the property listener is just
sugar code on how to add property chain
listeners to a class and the trading
annotation is a really nice one because
this one if you annotate methods you can
also specify what are the trading what
would be the right word for this what
will be the trading environment for this
particular method you can say this
method shoe will always be wrong outside
of the white red or always inside the UI
thread either in a synchronous mode or
synchronous mode or simply just skip it
don't do any trading injection to this
particular method and there are of
course more there are two other
additional models out there one of them
is called ad Skala file I really said
something like oh thank god for having
operator overloading in in groobie turns
out that Scala also has his own version
of operator overloading and it also has
its own conventions for properties and
property access and those two
conventions are not compatible with one
another what adds Calif ID does for you
is it is aware of the GUI conventions
and will generate all the appropriate
methods so that you can call these
things from Scala using idiomatic Scala
so now your groovy code will be seen as
regular scale occurred finally at a bi
code and this is only recommended for
hardcore developers that know how to
deal with bytecode instructions if you
know your way around bytecode
instructions and you know you can write
better bytecode that the compiler say
you want to write a Fibonacci using
plain plain pie codes then create a
method called Fibonacci annotated with
biker and the method body is Michael
instructions so the annotation what it
does is says how you have supplied the
bike of
for me already I will just simply use it
I will trust you that this bike God does
what it's supposed to do and then just
use it quite crazy
some people had theorized before we had
type checked that you could add for
example at Scala or at Java or something
like that
I notate a metal and insert the compiler
hey this particular piece of code
belongs to a different language so now
go and invoke the other compiler and
when that's finished come back and
continue sadly this is not possible why
because every language compiler follows
its own conventions we don't have a
standard framework so that every single
compiler will be able to hook into and
talk to each other.if and this is a very
big if and it will only happen if the
community really wants this if we were
to have a compiler framework and then
these different languages hook into it
will very possible to have an at Scala
annotation in groovy and an at groovy
annotation in Scala and both compilers
talking to each other and compile both
sources in one single compile step now I
know this is just wishful thinking but
I'm hoping that you guys if you guys
want to see this then talk to whatever
people you know that may be interested
in this thing as well and make as much
noise as possible let's make this thing
happen
I think this is pretty much what I have
for you guys too for today if you have
questions I'll be very happy to answer
them
there will be other groovy talks later
in the conference so if you are in if
you are still interested in hearing more
about groovy then just search for any in
the new schedule well thank you very
much
yep
thank you it's a question right here so
the question is it if the slides will be
available yes they will be available
from the j1 content site and I will post
them to a slicer where I have an account
so if you want you can follow my Twitter
account I will to it when it's ready all
right thank you guys keep enjoying the
conference</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>