<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JSR 347, Data Grids, and NoSQL | Coder Coacher - Coaching Coders</title><meta content="JSR 347, Data Grids, and NoSQL - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JSR 347, Data Grids, and NoSQL</b></h2><h5 class="post__date">2013-02-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/W8to5n8WQJY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">how's everyone doing how's how's day one
bin at javaone or rather evening one is
everyone brain fried at this point
exhausted and tired after a toke after
talk yeah you kind of ready to go and
get a beer at this point but you're here
instead good good okay so I'm good to
talk about JSON 347 data business and
I'm actually not going to talk about it
i'm expecting everyone else to talk
about it this is above as i repeat what
i am going to do is I'm going to kind of
give you guys a bit of an introduction
on to it first just so that people who
are new to it new to the subject new to
the jsr so you have a little bit of
context to get started but the bulk of
the next 45 minutes is I want everyone
to be talking right now I will
facilitate that that's what I'm going to
be doing just to kind of set the frame
is everyone familiar with Jace are 347
no okay lots of shaking heads is
everyone familiar with data grids you
know data grids are of a few more
nodding heads that's a bit better so
that's what want to do i'm going to give
you guys a little bit of context before
i get started right a little bit about
me I work for jboss division of red hat
red hats middleweight division I'm the
v-spec lead in JSON 347 and most of the
expert group on Jace are 107 who's sort
of Jace are 107 is he a few hands not
many who is here for the keynote
yesterday for for the technical keynote
who saw that yeah so there was a mention
of Jace r107 very briefly in the keynote
about how it's an important thing in
java ee 7 it is an important thing so
stress or 347 they kind of related and
i'll talk about how they are related but
essentially GSR 107 is a temporary
caching api for java it also applies to
distributed caches again which is very
important for for anything that's that's
going to scale someone and so forth
juice are 347 textures are 107 a few
more steps further and makes it a
datagrid adds a few more aspects to jsr
107 that makes it more tuned for a
distributed they
structure that's in memory across the
grid a little bit more about me i'm lee
the founder of infinite span which is an
open source stated wind project by jboss
it is also a product at red hat which
you can buy support on and there's a
picture of my book which very recently
published if anybody wants a copy of
that by the way we are giving away a few
copies of that book at the Red Hat stand
in pavillion you just go down and some
marketing person will talk to you and
then you can get a copy of that might
scan your badge maybe or something right
if you want an autographed copy if you
can find me looking around i'll happily
sign it for you as well ok so jumping
right into things what our data grids
data grids essentially are an evolution
of distributed caches the whole concept
of taking an in-memory cache of caching
objects we know that this is a fairly
common pattern to boost performance Ryan
everyone's familiar with this right now
there's lots of nods in the audience
cover you guys know about it right a
fairly common expensive data store with
it's a database or a web service or
expensive calculation a very good way to
to boost performance you stick a cache
in front of it makes things a lot faster
for for reads now with your application
itself is distributed a single cash is
not that good you need a distributed
cache a cache that is cluster aware a
cache that knows that there are other
servers in your cluster that might
change your data so you might need to
invalidate your local cache and things
like that so it's a little bit more
complicated than a standalone cash it's
a distributed cache now it's a
well-known pattern like I said it's
proven it's proven to improve
performance and scalability people use
it in front of a database all the time
I'm sure you guys are familiar with this
right you've all used a distributed
cache in some way in front of a database
or something expensive and it is a good
thing it's also because this clustered
by nature you get a few other things for
free as well things like high
availability if a single cash was to go
down for single server was to fail your
application does not go down because it
is distributed by nature your data is
distributed by nature you get high
availability more or less for free right
you also get scalability for free
because it is distributed again
and you have the ability to add more
servers to increase capacity or increase
transactional throughput and things like
that so lots of good things that you get
for free so that's what a datagrid is a
very little bit about infini spanning it
is an open source data grid that's
that's my project again like any other
data grid it is a proven technique to
improve performance when you have a
bottleneck like a database or an
expensive data store but what you've
also seen more recently as people have
also used in finish span as a no sequel
database as well as a key key value
store without a database behind it or
without some sort of slow data store
behind it and just purely keeping things
in memory may be optionally writing
through to disk or something for
persistence if you want to miss Elise
tarts and things like that but primarily
your main data stories in memory and
that's been a very interesting
phenomenon that we've seen happen in
recent times so the finish man is a
fairly mature project at this stage it's
been around for a few years it's got a
very active community both developers
and users contributors people are
extending it and building other
platforms in products and some internal
some embedded all sorts of things with
it as well as people just using it like
normal users would so as long as stuff
going on there it's an interesting
community to be a part of in terms of
standards so far we've talked about two
things Jace r107 I are mentioned very
briefly earlier that's the temporary
caching API for java and i'm on the
expert group for j so I 107 drinks are
107 is an interesting state at the
moment it is almost complete now it's
it's a very old jsr it's been around for
a long time they can tell by the number
it is finally very close to completion
it's going to be a part of java ee 7 as
was mentioned in the the keynote
yesterday and and infinite span is is a
part of that JSON 347 takes that a
little bit further now just give you
guys a very brief overview of 107 107
focuses on temporary caching right it's
got a very simple API of puts and
removes and expiry and a few very simple
things like that
Jase or 107 also supports things like
writing through and persisting to disc
and reading from disc again and all of
that in a very standard platform
independent way so does not matter which
vendors product you're using a little
just working on standard API now one of
the things that 107 bill is 107 does not
particularly define anything to do with
distribution right 107 is designed to
work with a standalone single VM cash as
well as a distributed cache which means
that there's nothing special about it
when it comes to a distributed clustered
system also 107 defines a lot of other
optional features like transactions and
things like that that you do not have to
implement and this is wages are one
other 347 is a little bit different 347
actually extends 107 it adds it starts
at 107 adds a few more things to it and
the few more things to it is what I want
to discuss today with everybody here
what I want to get input from everyone
what they feel is useful what they feel
is not what should these api is look
like like I said this is going to be an
interactive session I'm going to stop
talking very soon and I want everyone
here to start talking right but before
we do that I'm going to talk a little
bit about no sequel as well the reason
why I want to talk about in a sequel is
because there is an overlap between
those sequel and data grids and I want
to kind of you know just express my
ideas around that make sure everyone's
kind of on the same page here before we
start trying to design an API for a
datagrid right so firstly what is no
sequel I mean I I tend to look at no
sequel as an evolution of data storage
in general not not that long ago we had
relational databases with slab
relational databases one of the reasons
why relational databases came about Ryan
was because disk storage is very
expensive right I'm sure your room at
that time we're just trying to get a few
hundred Meg's on a PC was really really
expensive right it was like that and a
part of the reason why database or
released the relational model was
invented it's not the only reason that
part of the reason why was invented was
to save space quite simple space was
expensive you could not get the
100 Gig drives that you can get today
and then put them in your in your laptop
you can do that I mean it was very very
expensive to have space and and the
relational model was built to optimize
for that to save space right networks
were also slow so you couldn't cluster
machines easily and get a lot of space
and a cluster so again you had to
optimize for that who remembers cods
normal forms second normal form turn on
the form people remember it right who
actually uses it today and no actual
people do but but you know you kind of
rethink that a little bit isn't it I
mean is like is that really that
important anymore I mean yes consistency
is important but it does not matter if
UD normalize your data if it means that
you're going to get faster and you can
scale out better it's fine to
denormalize your data now what's the one
time you could not do that you wouldn't
you wouldn't dare dream of d normalizing
your data I mean that just takes so much
space really and it's expensive to do
that I mean today things are different
like I said disks are cheap as we all
know even memory is cheap I mean you can
scoop put your entire database in memory
why bother touching disk at all right so
the world has changed and how
availability is much more important now
than than saving space partly because of
cloud partly because of demand from
users everything from a mobile always on
the world where everyone is always
interacting with most systems you can't
really have down time you have to have
high availability so which means the
systems have to be distributed at this
point and suddenly you have to rethink
the way you store data you can't have a
single database anymore you have to make
sure it's charted and distributed or
something to cope with that the other
interesting aspect that kind of comes
out of this is the relational model it's
not something we really liked right I'm
going to kind of worked we kind of had
to deal with it but let's face it i mean
everyone here's a java programmer right
more or less all right so we'll be like
object-oriented programming yeah that
doesn't quite fit in in tables and
tables are kind of you know it's a weird
weird mix that's why I hibernate exists
hibernates the world's biggest tack
right i mean it is it is very useful ack
it's a very popular project and it works
really well but it is a half
to make an object model fit in a
database in the relational database
that's I mean you know you could kind of
really we have a good chance right now
to fix that to kind of you know actually
make a data store that works with our
programming model so why not look at
that as well so I mean this kind of
where no sequel comes in and this is
like the whole history of no sequel I
mean most no sequel databases out there
most no sequel engines out there are
designed with horizontal scalability in
mind it means that you can actually
scale out using cheap commodity hardware
you don't need to buy big expensive
specialized servers I'm thinking Oracle
Exadata and things like that here well
you can actually spy cheap you know
cheap dell machines and cluster them
together and have the same capacity in
the same performance actually a lot more
so because you can scale even wider than
you can vertically so I mean two things
you scale capacity as well as
performance two very important aspects
when I say when I say performance i'm
talking about servers your your entire
data storage cluster being able to
handle throughput transactions per
second and the other aspect is capacity
to store more and more data terabytes
and petabytes of data right highly
available again like I said it's very
important as we have seen with with
cloud and most business demands today a
lot of no sequel engines support that
along them are distributed so that
really helps as well and of course the
whole flexibility of schema now this has
been this has been a bit of a debate in
point a lot of people tend to use no
sequel because of flexible schema now
why is lexical schema such an
interesting thing well I think it's
interesting because because if you look
at the relational model and relational
databases right how do you how do you
build an application you first start
thinking about data model what are you
going to store what's it going to look
like right and then you start designing
table structures and relationships
between them and then you build your
application on top of that right now
with a lot of what's happening in the
world today with social networks mobile
phones generating data all the time
pushing all sorts of stuff you want to
capture all this data you don't still
know how are you going to use it you've
not decided yet how are you going to use
all this data you want to capture it so
now if you not decided how you go
to use it how are we going to design a
table structure for it well I don't know
I just stole all as a blob I guess but
that's kind of kind of hockey again
isn't it so this is where soft scheme
has become interesting as well I've seen
a lot of people turn to using document
stores for example like couchdb where
you end up having a very soft schema
around your data and you can change that
over time while you're capturing the
attend your not losing data at any given
point you can decide what you want to do
with it later you can still figure
things out on the go and I mean sub
schemas it is it's it's um it's an
interesting two-edged sword because it
means you have to do a lot of validation
in your application and a lot of
translations in your application as well
but at least it means that you your your
data can be flexible you don't have to
think about what you want to do up front
right so all that was about no sequel
now let's have a quick look at the
overlaps between data grids in no sequel
at least in my opinion most stated words
I feel are in memory right there in
memory they're accessed from your Java
Virtual Machine they not accessed over a
socket or anything else and they are
usually optimized for fast low latency
access of data hence the whole thing of
the data structures being in memory you
optionally right through the disk so you
have some form of persistence some form
of permanence of your data whereas no
sequel tends to be Malaga no sequel
engines out there tend to be test out
from the other extreme APL they tend to
be primarily accessed remotely over a
socket a bit like a database a bit like
a JDBC connection they tend to be
optimized for large volume rather than
speed a bit like Hadoop or Cassandra
where you are talking about storing lots
and lots of data as opposed to fast data
this is where the difference between big
data and fast data sort of comes in as
well and also no sequel tends to be
primarily focused on storing things on
disk optionally caching things in memory
as well so there's a lot of overlaps
there that you can see and this is where
this is where I want to open the floor
to discussion I'm sure people in the
room here have have played around with
lots of different no sequel engines
right hands up who who have
who's actually put them in production
who's actually running the reproduction
a few hands up as well right what about
later grids who's actually used data
grids in production again a few hands so
this is should be an interesting
discussion here I want to start talking
about api's for jsr 347 sue I want to
standardize the way data grids look and
feel and the way you interact with them
and just a few pointers over here just
kind of maybe in a few points food for
thought really to start discussing
things like eventual consistency very
popular in the sequel engines the
eventual consistency will require
specific API how does an application
deal with that how does an application
say do a get and then get multiple
versions of something how does it deal
with versions version conflicts how does
the deal with healing so that those
api's we can talk about the other thing
is in asynchronous API again which i
think is interesting because you know
that your grid is distributed you should
be able to do things in an asynchronous
manner you don't necessarily always want
to say to a port or get in the same in
the same thread as your as your
application you might be able to get a
future back on that and work with that
similarly MapReduce how does MapReduce
work again there are lots of MapReduce
API is out there Hadoop doesn't
MapReduce Cassandra does it does it so
yeah hoping the floral discussions come
up as a hand up there unfortunately
there are no roaming microphones here so
I'll repeat your question and no
previous slide sure that one
well you have a positive grade you're
primarily in vm because it's mostly
peer-to-peer right so you're talking to
a pair which is in the same vm as yours
still accessing different from what we
have your salary was really different
machines you're still going yes you are
right but your interaction is with
something in the same vm now in perform
an applications perspective it's fair
enough and we can strike that point off
then I mean this is just it's just
points for discussion really it's
nothing more than that so
I think there is more to than that I
think that the main differentiator for
me you can actually do processing yeah
you can you can do a lot of things on
the operational daily just cash so it's
really about processing the object you
have integrated versus getting and
putting on so that's an interesting
point that you make because a lot of
people would say that that's exactly
what Hadoop does and the dupe is not a
memory right
I mean yeah
yes of course I mean I mean this is not
necessarily a clear line that's drawn
here this is just a few very vague
points like i said in finnish band as
well does MapReduce in-memory it a lot
of projects do that and the lines do
start to blur it's a point in Finnish
band for example can be used both nvm as
well as over a socket as well as a
remote grid so I mean the lines do start
to blur this is just like some very
generalized things that I've seen that
in Adams opens up the discussion really
the session that we had
that whole thing is memories get the
cheaper cheaper so much more yes bigger
is persisting up in every selection
I just did
yeah I completely and that that's very
interesting but at the same time your
memory is getting bigger but data
volumes are getting even bigger on the
flip side so I think there is room for
both for sure and I've seen this a lot
with infinite span where a lot of people
try and put everything in memory and
that's absolutely fine for certain
applications if you are only dealing
with a few hundred gigs of stuff that's
cool the moment you're talking about
petabytes of data remember he's not that
cheap and at that point you really do
want to split off onto disk so you know
well yeah that that's definitely very
valid a very valid approach as well it
says these effective reactors as you
know as far as your operating system and
upwards is concerned it did so big it's
just a disc this is very fast disc as
you see success or still I mean I don't
know what what's symmetric a normal disc
is a thousand times slower than memory
and an SSD is only ten times slower than
memory but it still is ten times slower
than memory yeah
so our difficulties trying to use the
same cache that don't necessary have the
same object model
version of the
so how do you feel with something like
either fast
so there are several ways to do that one
of them reminds me of korva where you
actually ship the object definition with
the data itself that's what Google's
protocol buffers do that's essentially
what Google does for a lot of their
internal data storage on BigTable where
everything really is using using
protocol buffers where you are shipping
the object definition with with your
data with a lot of data grids I know
that your actual marshaling layer it is
pluggable so you can pick and choose
what sort of martial law you use and and
you can actually use protocol buffers in
many cases as well directly so that is
one way to do it but there's a cost
associated with that cuz protocol
buffers are not cheap they're not
cheaper to actually see realize and DC
realize it's a complete pain to actually
have you know your your protocol buffers
compiled in your in your application
it's also a space hog it takes up a lot
more extra space as well but this is
some of the trade-offs you have the
other way to do it is to roll your own I
mean it's it's perfectly fine to say you
just want to have everything as a JSON
object and then decide which bits you
need and don't need and what changes but
again that's got its own drawbacks as
well well effectively what what that is
is something very similar to protocol
buffers it's just their own proprietary
form of protocol buffers it's got the
same costs associated with it
but it does support the relation come
down the modules we have new version of
the classes in your cluster in our grade
and in compliance with multiple the
conversions older versions and still not
lose the facebook it's extremely
important in the large medical
deployments because you cannot cover
them if they have the new commander
quantification not read everything the
same thing yeah the whole point of data
grid is to be highly available as well
so you can't shut it down and change it
yeah but again that's an implementation
detail I don't see how that really fits
in a standard actually interested in
what I guess the purpose of this is hope
session is you said we're going to show
us proposed GSR 247 api's but I was
really going to show the APS because
there aren't any in the state was just
discussing some ideas what it
effectively is is almost all the major
data quit vendors already do all the
things I'm proposing in 347 they all do
some form of querying the next slide
they all do some sort of asynchronous
work some sort of MapReduce or
distributed code execution some former
querying some control over colocation as
to where your data is located the only
difference is they all do it in a
proprietary manner and this discussion
is again which of these can and should
be standardized on regardless of what it
looks like firstly and which of them are
better left to just being proprietary
extensions
mm-hmm there are a couple of no sequel
vendors in the expert group at the
moment who are interested so you've got
there are there people related to
Cassandra there people related to
mongodb who are interested on the more
data grid side of things there are folks
from from grid gain from eh cash from
currents from gemfire sorry hunter 50
spaces who are interested as well so
yeah these are the conversations we've
been having on the spec in the community
and of course lots of independent people
as well and I think that's really
important because I don't want this to
be a vendor driven spec I mean I've been
on many driven specs before and it does
not really serve the purpose of what
people really use what what actual users
want I want this to be quite heavily
influenced by users as well p value one
of the men because i know you don't want
to
involved in serialization what are the
mechanisms if you don't you get some
concepts of indexing Spartans back yes
absolutely absolutely i think that's a
very very important part do you need to
have index in as part of this back in
order before no that's I mean the actual
implementation detail is a different
thing whether it's actually indexed or
with it might even break out into a
MapReduce job or something like that if
it wants to but the point is that what
you're expressing is something that is
like I don't have the keys of what I'm
looking for but I'm looking for these
characteristics in some pieces of data
go and find it for me now naturally that
sounds like an index based search to me
it may not necessarily be an index based
search the way it's implemented right so
yeah sorry is a question
so I could speak up a little bit can't
quite a of it
No
jump
vapi might be similar is it what they're
trying to get something
the point is it's not about the API as
much as about what they did represents
souls problem the database is not very
good at solving which is scale out right
since I gave the API you still have date
that you still want to be able to access
a that but underneath it's very
differently
wish wish right which no sequel database
there is no standard there yeah every
day that lazy different right which
logically there is maybe both
yeah this is why I said there are lots
of overlaps and I think the overlaps are
going to get more and more so as time
progresses as this actually my interest
in this session was from your blog entry
about it where you said that we would
discuss the convergence and divergence
and if you go back to your previous
slide this is a list of divergent and
convergent points as well I mean look at
the last ones over there they actually
make things look very very similar if I
say that a datagrid is primarily memory
and optionally quite stuff to disk
while- construction this room is master
data management technology implement
persistence to be regarded as
what do people think do you call in
Venice banat new sequencing I do does it
implement persistence yes it does very
space it's possible consistent engine
can pick and choose it's not it's not
the same persistence implementation is
Jim fires have no pension fire but yeah
it's not built in persistence no it's a
pluggable thing that we you know I'm
leadership with a couple of our own
implementations but there are a few
different things
well it depends I mean I've seen a lot
of people runs things like that where
you when you bring something up it just
basically gets a copy of data from its
neighbors from his neighboring nodes if
you have big enough for cluster right
absolutely absolutely what if there are
no it's a code start yeah in that case
you do have you do want to rely on
persisting to disk rather than
generating everything again from scratch
or whatever yeah but versioning takes
care of that you can do that with a few
version your data
who the expert groups actually mrs.
pretty much as forming comedy bollocks
they've all expressed interest in it
they will start discussing it in the
case of a mongodb for example what they
are talking about is purely their client
library the Java client library from
being applied with this API so yeah I
mean they then all the Java engine as
you know it's it's sinner
story
p
exactly for whatever characteristics you
expect out of it yeah precisely which
which is why I like I said there is
interest from several of those equal
engines why not a sequel on top of this
can be
because that portability
there are many reasons for that there's
a lot of discussion going on about there
has been our discussion in the past as
well about this one of the biggest
problems with with actually implementing
sequel on top of a no sequel now it's
not just a to insanely no sequel engine
is that is the way you actually store
data you don't have a relational model
under me right now you can hack sequel
and translate that into something like
that but it'll be very very inefficient
I mean it was a very simple query that's
not a big deal you can do it very easily
if it's even a slightly complicated
query it becomes very inefficient
especially when you're talking about
joins about table joins when things are
distributed across different nodes you
need to pull back a lot of data into a
single node and do matches but the worst
thing is you actually don't take
advantage of the actual storage engines
capabilities so let's just say that are
you familiar with it with graph
databases with things like neo4j neo4j
for example is a very good open source
graph database very very useful for
certain types of data and certain types
of relationships you try and implement
no see are you try to implement sequel
on top of that and you are not only is
it inefficient to do anything you're
completely losing the benefit of a graph
database to be able to traverse node
from node to node and linked data
together
more programming real well MapReduce a
sequel are completely different things
you can do similarly on see it's like
well like I said in when you can do a
lot of simple queries easily enough the
moment you go beyond a certain threshold
of complexity it starts to break down no
the release happens remotely as well so
you only get very very tiny subsets
coming back ideally that's what I'm
going because these of sequel also you
can force the conditions
loading law requiring all right I'm
secretly designed to put emulation of
all right with integrated typically have
alter graphs toward some kind of memory
structure typically can understand right
and you can query and you query across
many machines don't really care if those
relationships have it support group so
yes you can have something similar to
where Klaus and I'm not sure about the
other products before clearance does
happen so you can basically have a
sequel alert gets translated into filter
so there are some limitations and you
can't just push them out to individual
nodes well this is the biggest problem I
mean someone did actually contributed a
sequel engine for foreign finished fan
and there were so many limitations to it
oh you can't do this kind of clothes you
can't do that kind of clothes like we
know what it's actually not that useful
at the end of the day you can only the
most trivial things and then what's
what's the point and it's not the
implementation was bad it's not that the
guy was a bad developer who did it I
mean there is a there is a logical
mismatch between that between those
models sequel is designed to run in a
single server it's not designed to run
and many servers
and there are limitations as well you
don't have full sequel 92 I mean it's
fine you have a limited see who but then
for me I think that's actually a
pointless thing to do in that case it
may as well move on to a new model like
I said earlier the relational model
anyway was a hack and you need to use
things like hibernate and whatever in
between yeah we may as well go to a
fully object oriented model at this
point well this is kind of where with
what i mean by querying i mean so that
that that bullet point does not actually
mean sequel or a sequel like language it
could mean anything like you said like
lambdas filters closures to help you
filter your data set to iterate over
your entire you know and again how its
implemented maybe MapReduce and maybe
something who the hell knows what that's
implementation detail but from an epi
perspective what does that look like
absolutely absolutely and to do that in
parallel could be both it could be you
know do some stuff on a remote node some
stuff that's happening on days can you
could do that in parallel as well so
yes it is which is why I find that very
interesting to talk about because if you
50 actually going to try and standardize
on a way to do this it should be
something that is compatible with the
way the GDK is moving as well take care
of that from the API yeah I mean that
might be enough you know it might well
be enough but is it I this again where I
want to open it up to the floor what do
people think what do people who are
using it think is that enough
vomits wise
do that just to be clear data grid we're
not talking about particular today you
can scale yeah I mean you can scale of
terabytes is quite easily scaled into
hundreds of knowledge currently the
benefit of data grid is a small scale
out because it allows you to partition
take hundred machines and basically
spread is Luke make them look like why
think about virtualization get away
around right instead of putting one
machine into many small boxes big
contribution is a make it look like I'm
being honest all right and you can kind
of you know hundreds of course and new
processing in parallel those memories of
course and have very large memory
capacity and then you can do things like
takings to flash right if you have flash
storage you can also post pics and flush
you can upload
right so it doesn't necessarily have to
have everything in memory can cast
significantly large data sets I've seen
some significant large dataset you know
on the other hand you look at something
like homebody be and how scalable this
right if if all you need is to score a
lot of data but you don't do any the
scale yeah I'm always just fine these
two charlotte i mean well i mean sure
what the ladies i mean multiple but used
to have i'm not sure if that's the case
use the cattle over right walk so so so
i mean there are issues there and then
configuring mom I mean data grades all
the ones I've seen so far are very easy
to cluster they just you just fire up
now that they faster the only thing I've
seen in no sequel space it's similar to
that with Rhea Rhea so my point is that
if you have certain system that has a
usable
just for the difficulty one of you
we haven't they're all similar I they
all have proprietary API is at this
point and yeah the reason that's the
purpose of the Jays are trying to
standardize the API is to make it like
like teachers are nigga definitely
worthwhile doing it because there's so
many different api's for so many things
that their preferred conceptually very
similar now some scale better than the
others some can have more storage than
the others yeah they all have different
quality punk but having API that can
capture so therefore the most important
points are and you can use a console
different servers is very beneficial the
question is what what should going yeah
absolutely i mean i know that we can't
cover everything in you know in in a
single buff like this what I really
wanted out of this was to get everyone
interested in involved and and join the
mailing list join the discussions and
then continue the conversation as as we
move forward join the adventure so to
speak yeah I'm sorry by the lambda yes
okay yeah yeah
yes
sometimes I wish yeah well I think
lambdas are a feature that we used to
enjoy the small talk that will cause
block closures and if I think they have
the potential to relieve some class
loading requirements and they definitely
do I mean I mean I've put a Python
background as well and again there's a
lot of cool stuff there that I wished I
had a job for a long time but you know
if I'm getting their ass ap I can see
why those losers being used for queries
I can see them being used and processing
now they can do is pay for a lot of
things don't necessarily need
bounce the sort of a reload the last
rites on a fancier class level scheme
the great game guys
yes tree p ql is something that i
considered for infinite spent
specifically as before before this jsr
as the official way to query in finnish
band i stepped away from that because
I've actually found j PQ el also a
little bit to relational and though yeah
exactly exactly because it is translated
to sequel in the end of the day yeah
syntax just to make
yes as far as possible at your right i
agree with keeping familiarity but
should we be keeping familiarity with
something like JP q 0 which which still
has a lot of which tried to keep
familiarity with sequel and they know
that that same kind of goes backwards oh
do we want to have familiarity with
something new that's going into the JDK
like for example lambda structures which
actually may be better suited for
something like this anyway right I mean
this this is where the discussions open
really I this what I want to invite
everyone to the mailing list you know
talk about it
you're expressing a Brazilian God
expression for here Joe I'll have them
send it into the grid people in writing
sample for 20 years I don't know every
signals in this is for John's illness
this is Charlie you gotta child
developer I find I want you guys to
contribute those use case again this is
a very new chaser so you know start a
lot yet so far it's just vendors and
want to get more users involved
keep creating it's going to take time
with some you know some kind of foreign
language then it's much easier for them
to do things because that's how true
life is going to be whether we like it
or not because moving forward with the
application what we will be applying on
sure yeah and if you stay single people
who are from
now anyway we're just about out of time
we're actually a few minutes late so I'm
going to leave you guys with some URLs
to actually join the spectrum the second
one that's the wiki which has all the
information in 347 including the mailing
lists a Google Group who's been involved
with Jace ours here before and he has
okay I don't wish it solves you've been
you've been involved in but the way I'm
running this is a little bit different
from most of the other Jace ours I'm not
putting any strict requirements on
having to be a part of the JCP and all
that this is I'm an open-source guy I'm
kind of running this in a very similar
style where the entire thing happens in
the open on a Google Group anybody and
everybody is allowed to participate it's
an open group and I really want to hear
the stories the ideas from you know from
not just vendors but users as well so
yeah please please do join right with
that well thank you for listening and I
won't keep you from your beer any longer</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>