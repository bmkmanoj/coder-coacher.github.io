<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Advanced Annotation Processing with JSR 269 | Coder Coacher - Coaching Coders</title><meta content="Advanced Annotation Processing with JSR 269 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Advanced Annotation Processing with JSR 269</b></h2><h5 class="post__date">2013-02-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0hN6XJ69xn4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is jaroslav to LA and I work on
red beans and today I don't want to talk
about netbeans but about a feature which
is part of java since jdk six and i
think it's very powerful and not well
known its away how to enhance your
compiler and i'm basically i believe
that it can do miracles it can improve
api's it can ease usability of your
api's if you create one so i will start
with a general motivation describing why
i'm going to design a specific example
or evolve a sample today then we will do
i'll show you a lot of code snippets
yeah and hopefully we will also have
time for some questions and how play
answers okay some i work on NetBeans IDE
which is a modular system and in modular
systems one issue that you always have
to deal it is registration of certain
functionality if you have support for
java editing c++ editing PHP editing the
individual modules that provide this
functionality need to somehow register
at so the infrastructure knows that
these subsystems are available and can
invoke them at the right time the
classical way how to do a registration
is to have a static method in your class
which is called register provider for
example which the modules can call at
the start up of the application well
this is how we did a registration in
that means ten years ago and it has its
issues so we are not using that anymore
the first problem is that programmers
are really keen on on registering but
they forget to unregister so if you turn
a module on turn it off well the
registration still stays that so this
kind of a symmetry creates a problem the
other thing is and we face that many
time inside of the NetBeans IDE we have
support for various technologies and
every programmer who is working on
certain technology for example UML
things well this is the best feature it
has to always be enabled so at the
beginning on start of the application it
just invokes a lot of registrations
creates registers everywhere does a lot
of initialization code and ID at the end
we find out that only 5% of users are
using uml so what's the point of
registering something so much better
thing than to register something
programmatically is to use some
declarative registration because just
invoking friend code means that the code
will do something nasty to your system
so it's much better to not call the UML
code or PHP code until it is really
needed so what we can do with that we
need to create scalable registration we
need to have a way how to basically
declare that you want to register some
provider and since GDK 6 there is a
class in java.util package called
service loader which is basically used
for this purpose it you can ask the
service loader to load implementation of
certain interface I guess it yeah this
is the example you and what do a service
loader implementation does is that it
goes through the classpath and looks for
text files stored in meta in / services
/ name of the interface you you are
looking for files and read their content
and inside of the of such file there
should be name of the implementation
class then just service loader
instantiates these classes and you can
use them so it's basically a way how to
use how to do some kind of component
injection but compared to spring and
other dependence injection frameworks
you don't need to do all the wiring at
the beginning basically until you need
implementation of certain interface
nothing happens and only when you call
the service loader load it will iterate
through all the implementations well the
only problem with that is that if you
are seeking for one particle
implementation of the interface you
still need to load them all and then
somehow select the right one and that's
not scalable either so I think it's time
to switch to first demo so I'm on one of
the problems that we needed to solve in
netbeans platform and I know that this
is a problem that almost every runtime
container needs to solve osgi sauce the
same issue is the fact that Java allows
you to register a URL handle factory for
processing your own or providing your
own handling of you are a different URL
protocols the problem is that there can
be only one factory and in modular
system well every module can basically
may have a need to provide their own
implementation so we somehow need to
create one generic proxy handle factory
and then delegate to the appropriate
implementation so this is what I'm
trying to do here so first of all I
created a class
urls which registers itself into the as
the stream handle factory and it
registers a global proxy factory so what
do proxy the important method which is
which needs to be implemented is create
URL steam handler and here is the
implementation which which uses the
service loader to seek further for the
four available implementations the font
make the font bigger no let's try Oh
actually this no this neither that's
better okay so here is the usage of
service loader and I'm asking for all
implementation of URL stream handle
factory and then I'm delegating to their
method create URL stream handler and I'm
waiting for the first one which creates
handler forgiven protocol so how to use
that I guess test get protocol so this
is a test that shows a weekend support
geek out protocol and the implementation
of this protocol is here so basically i
create implementation of URL stream
handle factory and well one thing that i
would like to demonstrate today is that
there is a lot of boilerplate code so
basically i need for sorry basically i
need three classes to implement the
functionality I need the URL stream
handle factory I need to implement a
geek-out URL stream handler which
basically just instantiates the URL
connection and then only important
functionality is here that's the URL
connection which really creates the
input stream which people can use when
using the the protocol as demonstrated
here okay and the next thing is the
registration if you want to register
yourself into the service loader
system you need to create a special
metime services file here is it the name
what follows the name of the interface
we are searching for and inside of it
you need to properly type the right name
of your class fuelly qualified name and
well this is too fragile because I've
seen many cases when people make a type
of there so the first thing we would
like to eliminate this and somehow make
the system more robust by using
annotations so let me switch to a
slightly better version of the same
sample and we i'm going to introduce the
first annotation its compile-time
annotation and it's provided by one
netbeans library but it can be used in a
java application its means independent
so gig hi so this is it so this is a
service provider annotation and
basically what it does is it will
generate the meta in services file for
you so if I re compile and run the test
you can look at the generated classes
and inside of metal services you can see
that right now there are two classes to
implementation mention and the first one
is there registered manually and the
second one is basically generated by the
compiler and this is a really good thing
because it basically prevents typos the
name of the duly qualified name of the
class which is in meting services file
is basically derived by compiler and the
compiler will not do any mistakes so
this is our first introduction to
compile time annotations and let me now
talk about
yourself so basically what we are doing
here is trying to create a special
language to express registrations and
special languages are called
domain-specific languages here is
Wikipedia definition and I had a talk
about dsl's together which with rich
anger two years ago and actually the
Wikipedia definition was not good enough
so we needed to somehow create a
classification what a dsl is and so we
can basically talk to each other so we
can have the same workability so the
first classification is about processing
style if you have dsl you can basically
create your own parser read the file and
somehow interpret it so that's external
DSL what you can also do is to store dsl
in our encode the language inside of XML
document and the third processing style
is that you embed the dsl language
inside of other language and that's
exactly that's basically my favorite one
and I will talk about it today then a
rich climb that dsl's can basically be
any general purpose language even during
completes you can basically express any
form of computation for me I rather
think about DSS as declarative languages
that you declare something and something
magical happens for you and the third
way how to differentiate between dsl's
is tooling basically if you create your
own new language then you need to
enhance every IDE to recognize it to
provide syntax coloring to provide code
completion to somehow show the structure
of the of the elements inside of your
language and that's bit of work on the
other hand there are dsl's where the
tooling is standardized for all ids and
that's basically what i will demonstrate
today so here are few dsl examples I
SQL is a perfect language and it's
declarative it's a example of
domain-specific language PostScript apex
is basically the Turing complete
language written by cells Forge where
rich is employed some and then there can
be a lot of XML variants like and or
voice XML xslt and also embedded and
internal ID which is that you somehow
put inside of usually functional
languages like Haskell or even scholar
or Ruby so first think I'd like to touch
is whether it's good to use to embed
your domain specific language into an
XML file it's not on the right side you
can see an example of voice XML return
or which is a domain-specific language
for describing conversations and voice
processing on the left side you see the
same language but written a without XML
so do you why would any user try to type
the XML thing when it's four times
longer and that's the same thing so for
XML you are basically simplifying here
our own life because you will get the
parsing for free but for users that's
really bad choice because you are
complicating what they how they can use
your language here is small example of
how we used XML in netbeans so we were
young and we did a mistake of allowing
registration through XML files and I
cannot count the number of cases when
people make a typo in these
registrations so right now we are moving
away from this XML registrations and
trying to replace that
well done annotations another topic to
touch is the embedded dsl weather
compared to the xml stuff embedded ESL's
may not be that bad the example on the
right top corner is basically bacchus on
our forum or describing expressions in
almost any language and when you compare
it to the bottom sample which is written
in scala it's not that different
basically it can be it it it has one to
one mapping and moreover not only that
you get parsing for free but you also
get into interpretation for free so not
only you define what the how to pass the
language but here you can see that it
also knows that plus means to some two
numbers and multiplications to multiply
two numbers so embedded dsl's are not
that bad I think just well I'd like to
use embedded dsl's inside of java and
well java is not that flexible as scala
that allows you to hook in different
operators and change basically the
complete semantics of the language so
the question is how we could use Java to
be a good language for domain-specific
embedded domain-specific languages and
the answer is a notation processors and
basically hooking up into the Java
compiler so let's see how we can rewrite
our example with the URL registrations
to be more scalable
using compile-time annotation processors
check out the revision annotation okay
so the first thing to do when you want
to create your own annotation processor
you need to create a notation so here is
the example and I'll make the font
bigger okay the thing that I like to
point out is the retention policy
basically this annotation is available
only in source file and as soon as a
class file is generated it's going to be
discarded that basically means you
cannot do any processing during runtime
the processing needs to happen during
compile time and to achieve that we need
to create annotation partition but first
of all let me show you the usage of the
annotation so basically we still have
our old coat URL stream handle factory
but instead of registering using the
service provider a notation we register
using the new annotation and specify the
protocol what we will do is basically
modify our generic global proxy implant
factory to seek in protocols and instead
of reading meta in I need to scroll it
instead of reading the Mitanni services
using the service loader we will read
some files which are generated in our
location and encode the name of the
protocol this will basically guarantee
that as soon as someone is using certain
protocol we will load the right
implementation and no other one so now
the question is how this file is going
to be generated and for that we need the
annotation processor which is here and I
so first thing when you write your own
ovation processor you need to register
it
so Java Sea will find it again the
registration or the Java Sea is using
service loader to find all annotation
processors and so you need to register
it by creating metimes services file oh
yeah I'm sorry is it possible to change
the size of the phone yeah I don't know
formatting fun some colors thank you
monospaced 14 all languages so 24 no 18
mmm-hmm yeah I think it should be better
so the Java compiler will read the meta
in services and find our registered
annotation processors I'm doing the
registration using the our annotation
that generates the file then you need to
specify the fury qualified name of the
annotation you want to process which is
done here and then the only missing
piece is basically the process method so
during compilation java sea well if it
finds the annotation you are interested
in it will call you this method and hear
what you can do is to find all elements
inside of the compiled code which have
which are annotated with this annotation
you can get the annotation ask for
values that are in the annotation so we
can get the protocol and then basically
we can create the file and write the
fuel qualified name of our of the
element which is computed here on this
line we can write the funeral qualified
name in that so that's it basically it's
not it's not complicated writing
annotation processors is relatively
trivial
so what we achieved we defined our
domain specific language with a special
day to register URL protocols we made it
scalable so we wrote only the important
only the implementation which we really
need and we prevented typos by
generating the files the supporting
files by the annotation processor we
basically eliminate a lot of errors
still some errors can happen so for
example what we need is we need to be
sure that the class that is annotated by
the protocol is public and has a public
constructor so so because the service
loader won't instantiate classes which
are not public and don't have public
constructor so let's switch to another
version
constructor check ok this is it ok here
is it so basically what you can do you
can inspect the elements that your
annotations are attached to so I can
basically asked for modifiers of my
class and verify if it's public or not
and if it's not I can generate an error
and the error will be basically reported
by the Java Sea so let's try it I will
remove the public key word here and try
to compile it ok and it is basically the
error generated by our annotation
purchaser and it looks like a classical
error created by Java Sea and it's
emitted during compilation so by doing
this you can basically prevent or detect
mistakes early and even tell users
what's wrong instead of throwing
exception during runtime you can
basically give them instructions so
right now I fixed the class and if i
compile it again it it compiles and the
tests are executed ok
so the jsr 269 basically specifies a
model and gives you access to classes
packages methods and fields you don't
have access to the actual body of
methods to the code so that's beyond the
scope of this jsr but still even by
inspecting the structure of your sources
you can do a a lot of things simplify
source code so then the thing that we
did so far is detecting errors and
having a scale registration but if we
look back at the class I will do code
fault expand expand all so basically the
only important line is specification of
the protocol and the way how we create
the input stream so we need free lines
or the user wants to write three lines
of code and instead of that we have 80
so I will now try to show you how
annotation processors can simplify this
code ok so let's switch to another
version
you are a collection yeah that's okay so
ciao okay so this is the improved
version which basically eliminates the
two classes which we had there
previously so instead of implementing
URL stream handler factory and urs URL
handler we just implement the connection
urlconnection and we register this
connection are using the same annotation
and what we just needed to do is to
improve the global proxy factory to find
out search in protocols yeah but the
instance is of type URL stream handle
factory or if it's if it's the URL
connection and if it's the connection
then we create the handler a generic
handler for the user which just uses the
reflection to instantiate the you are
your implementation of URL connection
please notice that we are basically
using a constructor which has one URL
argument and again we should warn the
user that we need a constructor that URL
argument and that's that again can be
done inside of the inside of the
processor well I would hope so one so
here is the detection so basically right
now i am i'm inside of the processor i
can get a representation of URL stream
handle factory class and URL connection
class as a type and then i can ask
whether my element is basically
assignable into this class or into the
other class and based on that i can
generate something different okay so
this is the chick is not okay so right
now we managed to simplify the code a
date
the next level when writing annotation
purchasers is not to just generate some
resource files but also generate a java
java classes or java source files so the
Java Sea basically execute your
annotation purchasers and in case your
processor generates some new Java class
it will rerun the compilation once again
and compile the newly generated class
and you can do tricks with that for
example you can have a class which
extends a class that doesn't exist and
will be generated in the by the
annotation processors during the
compilation but that's not what I'm
going to demonstrate right now I should
mention that basically you cannot change
existing classes or existing code you
can only generate new ones so the jsr
269 is not that flexible as
transformation in groovy or project
lombok for example but still we can do a
lot of things with that so another demo
follows it check out the revision hat so
this is the most the final version of
our code well it should be it's not
let's try that once again
select so the most recent version okay
check out so basically this is the final
simplification of the of the user API so
I mentioned that the user basically
wants to write three lines of code and
well we managed to be basically managed
to achieve it so what we did is we
change the url particular registration
to be applicable not only two types and
our classes but also to method so right
now I can associate the annotation with
a method and the method basically takes
the URL increase the input stream which
is all that we wanted to do so now the
question is how we can register this
method into the system so it's um so
basically it can be used by the generic
proxy factory and we know that the
generic proxy factory and generic URL
stream factory is basically loading
classes so what we are going to do we
are about to modify the annotation
processor to basically generate a
wrapper around a metal so here as soon
as I find out that the annotation is
attached to a method I will generate a
class next to the class in the in the
same package and basically the class
will imply will extend the URL
connection and then call our static
method so we are and the nice thing is
that i'm using the same annotation on
the generated class as well so in the
first round the annotation processor
will generate this class and in the
subsequent round really recompile this
class and annotation processor will
create registration in metal / URLs so
now I
i would like to show you the code the
generated code so okay
glasses best classes meta in services
URLs so here is the registration that we
wanted to have and somewhere here should
be the generated class so basically this
is the Java class that was generated by
the by the annotation processor code
Falls expand all yeah so here is
basically the call to the static method
so the problem with jsr 269 is that it
was not designed for incremental
compilation it works really well if you
do a clean built of your project however
if you have if you are inside of the IDE
then usually the IDE and you change a
single class then the ID basically
reparse is just a single class and
writing annotation processors that are
ready for for working in this
incremental mode is not really easy but
it can be done and I think they are
using this these compile time
annotations a lot inside of NetBeans and
we were relatively inventive in what in
generating a lot of different things and
as a result I think the NetBeans IDE is
relatively good in supporting even the
incremental mode inside and giving you a
sense and information about your files
that are basically generated by the
annotation processors so here is an
example of an annotation which we are
using in netbeans I need to find it
messages and okay did it this is this is
it messages so this is this is the
annotation so you probably know that
when you want to do a localization then
you store you have a resource bundle and
probably you have properties files next
next to your source code and it's a pain
in the India's to reference a key in a
resource bundle and make sure that the
reference from inside of the source code
is always correct with the
key inside of the bundle so what we did
we decided that we want to specify the
keys or specify the content of bundle
properties inside of the java source
code so we created this annotation which
basically says okay this put this key
into a bundle properties file and this
is the value that you will get but and
the annotation purchaser is basically
going to generate the bundle file but
not only that it will also generate a
bundle of Java file and the bundle dot
Java file has a methods to obtain the
particular keys and if the key has a
parameter then the generated method will
have the appropriate number of
parameters so what I can do right now is
to modify the definition to have two
parameters and you can see that the ID
immediately detected that the method is
not there that I should basically
provide another another argument again
if you are interested in this annotation
it should be easily usable in any java
application yeah and i would like to
repeat that getting this done was very
tricky because basically we are
generating a single bundle Java file for
every class in a package and that means
if you change a single class and at new
bundle keys there the processor
basically needs to update the file are
correctly in incremental mode and that
was not easy okay so that's basically
the whole example that you are else that
I created and right now I like to return
back to the topic of dsl's so I
mentioned two years ago we had API
design versus D s
design shootout and I was afraid I'm
going to lose because it but I think ap
is in Java cannot be as powerful as I
don't for example accessing a database
in apex or for example in Ruby on Rails
and basically you can write a code and
obtain a content of your database and
consume it immediately in Java we
usually have to use java persistence api
that will force us to define entity
classes and then make sure that the
structure of the entity classes is
correct with the structure of database
so I said okay let's try to change it
let's use annotations to give you a live
view of edit of a database so here is a
little demo I guess I'm going to close
all the classes collapse the project and
then live DB that's basically the
example so i should have a database
running on my computer which contains a
one table called h and it has two fields
name is of type string h is and
numbering ok and here is wow yeah ok
here is a usage of annotation that i
created so basically it says ok connect
to the database perform this query and
create a class in this package called H
that will represent the content of the
database and do well ok and here is a
test which shows how how this can be
used so basically the generated class
will have a query method static query
method which returns a list of results
and then each of the result basically
has
field representing a column in the
database and you can see that basically
these columns or these fields have
proper types so you always know whether
H is integer or string and you can
basically directly access it so now
let's try to modify the table by adding
a new column so let's at field of type
boolean and now we should in the con
completion it should immediately see all
the free fields and we don't because we
need to some hotel the IDE to refresh so
what I'm going to do is to just modify
this file which uses the annotation
which basically told you ID now please
three parts and if I written back to the
to the test now we basically see that we
have the H class has been regenerated
and now it has three fields and there is
the good filled with type bling ok so I
think that this shows how powerful the
annotation processing can be I don't
think that this kind of annotation
should be used in production it's just
for sample purposes and actually when I
think about annotation processors I
believe that they are the easiest way
how to extend functionality of any IDE
which is jazz up to 69 compliant because
not only you can hook into the
compilation but each annotation
processor has a special method called
get completions and this method is
supposed to be called by the IDE so okay
so first of all because annotations are
part of the Java language you get code
completion for free you get javadoc you
get information about fields and subject
this is basically for free but you can
also hook in and provide special code
completion either static so for example
I know that the Kaveri should be SQL
select so if i press ctrl space the ID
talks to the annotation processor and
ask what could be the suggested
completion here and I can also create a
dynamic completion which basically
connect to the database and gives me a
list of tables so to demonstrate that I
will create a new table column okay so
now there are two tables in the database
and when I cause when I press ctrl space
really the annotation processor connects
to the database finds out that there are
two tables and offers me come completion
you should probably look at the
implementation of the live DB processor
and again that's it's not that
complicated so what it does it finds
again it when you write your annotation
processor the best way to do is to copy
copy the code from somewhere because all
of them are basically the same you find
all the elements which are annotated
with your annotation you get information
from the annotation and then we are
going to create a Java file here we
connect to the database find information
about about the structure of the
database and then we generate the class
header we generate fields and then we
generate the query method and it's
basically all and for the completions
the method is this is the method which
is called by the IDE
so the method is called get completions
and you basically get a similar
information to show you know where the
completion has been invoked and based on
that you can basically either select a
return completion statically like in
this case or again connect to the
database and list all the tables tables
that are there
so if you remember the horrible example
with XML layer file we are basically
trying to get rid of that and replace
all its usages by annotation processors
so we enhance our api's so they contain
so they have new annotation processors
and compile time annotations and they
basically generate the later file so we
are fuelling backward compatible with
the original XML layer XML file
structure but our AP is our not now much
more usable and prevent user errors
during compilation oh I think you have
six minutes so here are a few slides
about evolution of annotations so um
yeah I am interested in API design and
so far I was basically designing just
libraries with annotation purchasers
it's slightly different because the
contact the contract with the user of
the API is not happening during
execution it's happening during
compilation so for example what you can
do is you can have still the same
annotation and just changed the
annotation processor in subsequent
version of your API and generate more
effective code or something else so the
user just by recompiling they'll get
better behavior without changing
anything often it happens that people
need to enhance existing annotations and
that's possible because annotations have
default values so you can basically add
new attributes to annotations and
specify default values so whatever used
to compile before the compile again
that's one version or one way how you
can extend the semantics of your
annotations the other one is to
introduce
annotations and then basically annotate
the same element with more annotations
that provide some special meaning slight
problem is versioning of a compiler the
GSR does not specify ave how the
processor can communicate with the
compiler and request some most recent
version or say okay this is broken java
see that i'm not going to run with so
this is slightly programmatic
problematic it would be good to have a
very hard for annotation processors to
really specify the least the minimum
version of java sea they can run it
and annotations cannot inherit from each
other so basically you cannot create a
hierarchical structure of annotations so
rather than that you probably need to
use composition so here is an example
that basic that v is something that we
have in netbeans if you want to register
an action you basically use multiple
annotations and then there is a
processor which tries to process them
both all the problem there is you
somehow need a way for other modules
that at new annotation to also hook into
the processing class so for that what we
are trying to use is basically annotate
the annotation with metal an operation
so we know that by when this annotation
is present you should also invoke some
special purchaser class to generate
something some additional information
and that's basically basically all I'd
like to stress that we all meet dsl's
basically all the time when you are
about to choose ready to write your own
parser or base your dsl on XML then I'd
like to advocate using of annotation
processors because they are well
integrated into the Java language and
basically we'll get tooling for free in
every Java jsr 269 compatible ID and as
we see during the example annotation
processors can basically eliminate a lot
of boilerplate code and they are joy to
use so because the NetBeans team is very
interested in compile in Java Sea in
annotation processors we have submitted
few other sessions tutorial and even
hands-on lab so here is the list and I
will around their hands on lap on first
day and basically we will go through the
same example as we went through today
just people will be able to code their
own annotation purchasers and I should
also mention that i will have managed to
publish a book about api paradoxes which
includes also one paradox about the life
database annotation and the book should
be available by end of this week so if
you are interested in you can you can
get it and that's basically all if you
have questions it's time to ask
yes yes
ok so the observation was that here in
the fine fine fine during the usage of
messages annotation what what is it oh
here so basically the annotation is
about or the processor for this
annotation is about to generate bundle
file so during the first round of
compilation basically the compilation of
this file has to fail because the bundle
is not available so I will try to
recompile it and let's inspect the error
messages oh the output is surprisingly
surprisingly empty so basically I think
at least I saw it in when we used this
annotation inside of NetBeans modules
probably we have more verbose mode for
photo compilation the Java Sea really
emits the error in the first round and
then just start again and it succeeds
for the second completion yes yes it
retires the compilation of failed files
and it does it only if a new Java file
is generated our device it makes no
sense another question
okay so your question is or you would
like me to compare compile-time
annotations and runtime annotations so I
think one of the biggest weaknesses of
runtime annotations is that you need to
inspect for presence of these
annotations during runtime and that's
not useful for the NetBeans IDE it might
be useful for server because start of a
server is not that is not something that
is done too frequently definitely not in
production but for the NetBeans IDE if
we had to go through 1000 of jar files
and load order glasses and on every
start and try to find out where certain
annotations are used it would be a major
really huge problem for the staff up
time so if it compile time annotations
we basically put the load of analyzing
the presence of those annotations into
the compile time and we generate the
layer xml file which then can be read
much more easily
ok so how different is the way to
process compile-time annotations and
runtime annotations so basically if you
want to access information about
annotations during runtime you are using
reflection API and then for each method
for each class you can get instance of
the annotation and do something with it
if you want to do it during compile time
that then the reflection API is of no
use you need to use the jsr to 269 api
which is packaged in java x package lets
me show the imports so here is it so
this is basically the Andy and this so
these are the AP is that you need to use
during anyone want to hack into the
compiler also the this API provides
slightly more information I would guess
you can for example access names of
parameters which during runtime they are
they are gone that is new jsr to make
them available in the in the class file
so okay
there
but
oh I don't know
okay so the question is how V in
netbeans hint the user that this method
or this class should be annotated with
some annotation and actually if we do it
with Wizards we have the benefit of
having AI de so if you decide to create
a new file somewhere I like I probably
don't have the NetBeans project here but
I can try it new so we have a lot of
wizards and basically it will generate
the skeleton code including all the
annotations so then it's much easier for
the user to know that the annotation
should be used and also annotations
provide a nice way for tuve editing so
the visitor generates the code but then
it's hard for the for the visit to
regenerate the code with annotations
this is basically much easier because
users can really tweak the parameters of
annotations and modify them but another
benefit
yeah yeah that's true you can even you
define your validation processor you can
say that supported annotation types is a
star and in such case this annotation
processor will be invoked on every
compilation which includes your jar file
in a compilation to a spa and then you
can basically go through all the classes
and say okay no use of this annotation
that's a problem you should use it dear
user
ah I so the question was whether i can
create an endless compilation I think
you can and Jace are is not going to
deal with that at all it will just run
forever another question
I i use har codex hard-coded string
you
okay so the question is whether i can
recommend a dead plating engine instead
of hard-coding the code here so in
netbeans views freemarker by default for
for generating templates but not for
annotation purchasers the annotation
processor features hard code all the
time so it's it's not that bad I guess
it works relative that issue that you
cannot have a notation purchaser
depending on other jars oh so if I
wanted to use freemarker to generate to
generate the code then people would need
to include the free market a templating
library on the compilation path as well
obviously and less dependencies is
probably better so another reason why
not to use any templating engine it
depends how complicated code to generate
usually we are generating simple simple
code and often we are not generating
code at all we have we are usually
generating the layer XML file and
actually for that we have a special
subclass of annotation purchaser court
layer generating a notation processor
which has a builder like interface so
you don't have to deal with generating
XML you basically use a builder so
that's probably answer to a question I
guess it's time to finish so thank you
for your attention
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>