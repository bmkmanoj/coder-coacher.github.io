<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Using Instrumentation to Find Vulnerabilities in Java EE Applications | Coder Coacher - Coaching Coders</title><meta content="Using Instrumentation to Find Vulnerabilities in Java EE Applications - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Using Instrumentation to Find Vulnerabilities in Java EE Applications</b></h2><h5 class="post__date">2013-01-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/WgnckN5xmIE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thanks for fighting your way over to the
remote facility my name is Jeff Williams
this is our shantu beers yagi and today
we're going to talk about some of the
security research we've done using the
Java instrumentation API to enable
automated vulnerability detection in
Java EE apps so we think we've made a
pretty interesting breakthrough here and
we're really excited to share it with
you so you may have noticed we hooked up
a live tweeting system here so we're
going to use the hash tag pound I asked
that's i AST that stands for interactive
application security testing and that's
Gartner's name for what we do what this
this kind of testing is called I asked
so don't be shy please go ahead and you
know tweet during the talk if you want
ask your questions or comments we
encourage it so you guys have probably
heard of anonymous and lull sec but what
interests me about these groups and may
you may not have heard in the news
because it doesn't get reported much is
that these groups are chaotic their
leader list but I think what's
interesting to me is that they're
actually set out to do good that's you
know they're driving motivation i
believe is for good and let me tell you
a little story so this is geo hot george
hotz he's the guy who jailbroke the
playstation he also did a jailbreak on
the iphone absolutely brilliant guy
despite the haircut and when he did that
when he broke the PlayStation Sony's
lawyers came after him and it pissed off
the internet so these groups anonymous
lovesick they started attacking Sony to
get back and sort of defend this guy
because the you know they were sort of
defending the freedom to use computers
in the way that you want and that next
year Sony got hacked 19 times mostly
with sequel injection they took down the
PlayStation Network they cause a lot of
damage it cost him at least a minimum of
119 million dollars but the there's a
lot of difficulty measuring the
customers probably a lot more
so what's going on here you don't have
to be a big financial organization to
get hacked this is not about credit
cards and money this is I think about
you know if you do something to piss off
the internet they'll target you and a
number of companies like well we
mentioned Sony but Fox and Nintendo and
PBS all found out the hard way so I
actually agree with anonymous in one way
the internet is way less secure than it
needs to be so our Shannon I've done a
ton of penetration and testing
penetration testing and code of view
over the last 10 years aspect looks at
roughly 5 million lines of code every
month for security holes and these are
numbers from last year you can see the
different categories here and the number
of vulnerabilities we found on average
we uncovered 23.2 vulnerabilities in
applications that are probably just like
yours written by some very smart
developers so these numbers are
incredibly disappointing to me actually
10 years ago I wrote the OS top 10 and
when I wrote it I had this idea that in
a few years we'd start to get on top of
those problems and we can move on to
like the next 10 and so on and we'd
improve the industry are going to have
this floor the race but unfortunately
it's 10 years later and we're still
finding exactly the same kinds of flaws
in the same kinds of apps and in fact I
think it's getting a lot worse you know
in some ways that will talk about if
you're still skeptical check out the
verizon data breach investigation report
these guys go in after breaches and
investigate all the details of exactly
what happened it's very well-regarded
study and what they found last year
study is that of the 381 breaches that
they investigated only five of them were
patchable meaning that they could have
been stopped if the organization had
been up to date on all the patches so
that means under that's an interesting
finding right that means that even if
you had the best firewalls best IDs is
the best patch management the best
hardening this virus scanning in the
world 376 funds out of 381 you still get
hacked and what this means is that you
have to do your security protections in
your code so what's what's the problem I
wrestle with this a lot I think
something's going wrong so who here
loves working with security folks right
well say security hasn't always been
great to work with and I think sort of
in a nutshell like security hasn't
figured out how to work with real
software development projects very well
like we're not compatible in some way so
we end up trying to force security on
projects and it's not right we
desperately need an automated way to
find security holes accurately and and
usefully that you guys can integrate in
your development processes and you know
solve this as part of the normal
development process so to give you an
idea I mean it sounds like an easy thing
right well we'll write a total skin for
sequel injection or something and we'll
we'll fix them unfortunately it turns
out to be really pretty difficult and so
just as my way of analogy what I wanted
to put out for you is imagine that
someone asked you to write a program
that would find all the loopholes in the
US tax code it's about that level of
complexity to find vulnerabilities in a
three million line of code out the tax
code is about 3.4 million lines of tax
code so it's an interesting challenging
problem let's look at what it might take
to build a tool like that so first we
gotta look at the tools that are out
there so there's really two classes of
existing tools static tools and dynamic
tools static tools look at source code
and they scan through the source code
they parse it they build a model and
they analyze the model for
vulnerabilities the problem is that the
static tools don't have access to the
environment or the runtime data or a lot
of other details about the libraries and
the frameworks that you're using and so
they make a lot of mistakes and they
don't get particularly good coverage
dynamic tools work a little differently
they sort of scan you're running
application and a colleague of mine
described it this way he said doing
dynamic scanning is
like trying to find problems in the
water heater by staring through the
showerhead and it's a little bit like
that you only really light up that that
front part of the application you know
most of the UI you don't get good access
to the back end stuff the details and
it's all that dark code or a lot of
vulnerabilities live so we need an
approach that will light up the whole
app right that will illuminate all the
code so that we can find vulnerabilities
so let's let's look at what a
vulnerability actually looks like in
order to help us design this this tool
that we're going to build to find these
vulnerabilities this is the crustacean
this is a sequel injection example from
a wasp and it's pretty standard here you
see that the username and password are
getting concatenated into a query and
then that gets sent to the sequel
database in that statement done execute
and if the attacker sends in bad values
for either the username or password then
they'll then they'll be able to inject
and change the meaning of that query but
this isn't enough to decide whether this
is a vulnerability or not the problem is
you don't know where that username and
password came from it might have come
from a request it might have come from
something else you don't know and you
don't know the path that have followed
did it go through validation did it go
through some kind of encoding and did it
get manipulated in some way in order to
understand the vulnerability you've got
to see that whole path through the
application right so I think of a
vulnerability as a series of events not
just a point like not like one line of
code it's better to think of a
vulnerability as that's sort of a path
through your application and so here's
an example where you know that that
first circle up at the top left think of
that as like request I get parameter and
then maybe this thing goes through some
string of pens and some validation maybe
it gets put into a data bean maybe it
gets stored in the session maybe gets
serialized and rehydrated and eventually
there's a vulnerability but you have to
see the whole path
and in order to really determine whether
it's a vulnerability you need to know
whether it's that you need to have view
into the control flow and the data flow
and the runtime data and then you can
decide whether it very accurately
whether it's a volar ability so let's
let's stretch that line out let's just
take that complicated path and put it
into a straight line and think of just a
straight line series of events because
it will make it makes it a little easier
to think about a vulnerability when we
look at it so here's a full
vulnerability trace it starts at what we
call a source that's where we get a
parameter out of the HTTP request and
now we've got a piece of tainted data or
untrusted data and you can see that it
flows through the application it might
go through some data flow operations and
some control operations like you know
here's a regex and on down until
eventually we hit it what we call it
trigger this is in this case it's the
sequel exec and you can see our
untrusted data flowed through the
application now if we can see this then
we have super good confidence that this
is a real vulnerability so we know
exactly this there's a problem super
complicated applications make this
really tricky this is part of an HTTP
request that was generated by google web
toolkit and it's a serialized data
structure it's actually pretty
complicated these some of these fields
refer to other fields so you can't just
edit this you know we used to have tools
like web scarab from oh us where we
could edit an HTTP request and do some
testing but with these kind of data
structures we can't do that anymore you
can't just edit this now you need an
actual sort of a plug-in to parse this
and change it and then resubmit it so
penetration testing this is made
penetration testing considerably harder
and that's not the only problem so
here's some of the challenges almost
every advance in software development
recently has made it much more difficult
to do security work so on the static
analysis side that just the size and
complexity of apps has made things much
hard
or the use of lots of libraries and
frameworks as made static analysis much
more difficult because you have to teach
them about that using pointcuts building
custom security controls and doing you
know 100 pushes to prod a day makes our
work much much more difficult and on the
the dynamic side it's even worse so
we're seeing applications now that send
lots of requests really fast we can't
intercept them and modify them we're
seeing web services and other other
types of data structures that have
complex authentication processes that we
can't figure out see a lot of serialized
objects and lately we've even seen you
know mobile apps and html5 WebSocket
apps that there are no tools for in fact
there are no tools on the market that
will solve any of these challenges we're
currently at about you know 2002 web
technology level in our ability to test
stuff and the apps are rapidly advancing
past that so I look at all this and look
at all the trends and I get really
frustrated and I i just hit bottom so I
give up
a little blue good so we didn't really
give up um we were happy with the
automation that existed because we were
been working in this space for a long
time trying to use the automation that's
there and it's just it wasn't great for
a lot of reasons so in a smarter person
probably would have picked a much easier
problem to work on but we we did what we
did so a lot of biotech companies are
figuring out the best way to figure out
what's going on in the human body is to
put a sensor into it and measure it and
so that's what we see here this is a
sensor of the size of a grain of rice it
gets implanted in your arm and then you
have this external rfid reader that
reads that sensor and monitors your
glucose levels so people diabetes don't
have to do the finger prick thing all
the time so you know this is the future
and you know this whole conference is
about making job of the future right and
so what if we could have this same kind
of setup for the JVM what if the JVM had
a bunch of sensors in it that we could
monitor from the outside and you know
the JVM could report its own security
weaknesses or report weaknesses in the
apps that run on the JVM before they
ever reached the field so if we want to
capture all the details you know all the
events that could lead to
vulnerabilities then you know then if we
could take those take those events and
use the application normally right
install sensors into those events that
Jeff mentioned and then feed them all
into a central brain or rules engine
it's possible that we could use that
rules engine that's getting feeds from
all these sensors to detect vulnerable
combinations of those sensor events so
imagine a you know untrusted piece of
data gets retrieved by the application
and then later that same value is used
in a sequel call well that that's pretty
easy right that's a sequel injection
vulnerability so that's very easy to
model when we think like that and so
that's the future that we want to get to
so you know if weeks just you know let's
take let's imagine what those sensors
that we would install look like so this
is a fake Tomcat class you know that
that implements the servlet requests
spec so you know what if we could just
you know in the get parameter call which
retrieves a piece of untrusted data from
the user we then a little sensor that
has a call back to some brain that says
track this object you know this object
is untrusted and then later you know
deep within the the JDBC library we do
the same thing in execute query this is
the the trigger that Jeff talked about
this is the end event you know before we
execute the query we check if the object
is tracked and then if it is tracked
we've got that source to sync model now
right with a sensor when the data came
in and we have the sensor when it's used
in a dangerous API call and so we should
be able to detect security
vulnerabilities this way so how are we
going to weave those sensors in you know
instrumentation is the general idea that
you're at a code to a binary runtime so
how are we going to do that well you
could add calls to source code but this
doesn't help the problem of all the
developers out there adding sensors to
their own code that's probably not going
to work for scalability reasons plus a
lot of the events don't happen in your
code right when you get a request
parameter that could be deep in the
spring stack or when you're executing a
sequel call that could be deep in the
you know hibernate or whatever your is
so in an AOP is the same issue you know
that this the point cuts are not where
your code is and again if you had to
write pointcuts for everything it's not
going to scale to every developer in the
world so if you technically if you
wanted to you could bootstrap Java
classes or you could bootstrap hot
library classes or you could just modify
all the classes in our tea jar or
whatever but this is really invasive and
nobody's going to want to do that so of
course we're going to end up at the Java
instrumentation API so the job
instrumentation API is awesome a couple
years ago Jeff was doing research in
kind of throwing away os-level rootkits
because there's a lot of stuff they're
going on and
working to build / kit into a java
application and i was doing some work on
hacking java applets and so both of us
were using the instrumentation api for
this distinct research projects and it
wasn't we were done with those that we
thought why don't we use these to try to
solve this problem so the job of
instrumentation avi is awesome it's like
one of my favorite things about the Java
environment um so it's pretty simple you
package your code into a jar and then
you do javed a sheet java agent equals
your jar and then your your your code
from that jar gets executed before the
main class of whatever the program is so
your pre main method that you override
is given everything you need to change
classes you can change the behavior of
classes you you can add code to methods
you can't add members or take away
members and you can't add or remove
methods and if anybody hears from the
Java instrumentation team we'd really
love to be able to add numbers so
there's there's two way of two ways of
actually changing classes the first way
is called using transformers and that's
what a lot of framework people tend to
use so that means you're just another
step in the creation of a class when a
class gets loaded you register a
transformer with the JVM and the JVM
comes to you every time a class is
loaded and says hey here's some bytecode
do what it do do to it whatever you want
to do with it and give me the result so
that's that's great because you don't
miss any events when you do it like that
you know before the first time that the
class is executed you can change the
method behavior but then there's another
way of doing it with with an API called
redefined classes where you can just say
here's the class and here's the bytecode
this is how it works now and you can
tell the JVM it'll change the bytecode
it'll do it it kind of immediately so
you can be in line with the class loader
or you can just asynchronously just call
for it so like I said we can change
method behavior and so it it took us
about a year of building test cases and
working on some bugs before we got to a
point where we said holy crap we can
actually track data in the JVM so you as
you can see in these test cases these
are relatively
contrived scenarios where your or
purposely come make it difficult to
track a piece of data as I move
throughout the function so we bake 16
for Bay 64 encode the data we substring
the data we replace all and we do a
bunch of weird stuff to try to lose the
the tracking but we're still able to do
it so like I said it took us about a
year until be after this really happy
place where Wow data comes in we can
track it as it goes through its normal
operations and then we can see it when
it gets used in dangerous stuff so we've
got a lot of 20 from layer wall says
nice work guys you just reinvented tape
mode well Larry it's a bit snarky but
you're actually incorrect but you're on
the right track so taint mode introduced
in Perl maybe somewhere else before that
was all about just tagging the input
data that came from the user and so if
ever got to a sensitive API will just
blow up but as the the commercial space
for the tools those guys still can't
figure out the treating data is either
untrusted or trusted is not enough it's
far too binary the quickest way to lose
a developer's trust is to report
problems in security tools that aren't
problems so we need to think a little
bit harder about about that so this is a
this is bird ringing this is a i'm not
sure why people do this but the point is
when a bird comes into these these setup
cages in this ecosystem you get the bird
you take the tags off the bird and you
read what taxis are already on him and
then you put your own new tags on so you
can say this bird's name was Jim he
appeared hungry at this time you know he
looks a little sick or whatever so you
can kind of keep track of the bird as it
flows through these gates in your in
your ecosystem in your forest so we can
do the same thing in the JVM with data
you see when data comes into the JVM
it's not just like you know there's a
variable here and it bounces through the
system by itself when a piece of data
comes in it usually gets substring and
replace old and
one of those things each one of those
operations creates a new string because
strings are immutable so you end up with
like one piece of data shattering into a
million different strings so being able
to track all those strings is is super
important and so the the tagging kind of
helps us keep track of what what is
happening to the individual fragments of
that original data as it moves through
the system so here's an example of of
that so you know this is the the trace
that Jeff talked about right the series
of events so our sensors have sent these
events to the central rule engine the
brain and the brain has correlated them
all and said okay well this path now
looks like it might be vulnerability so
let's look at it so the first thing that
we see is the first tag that comes in is
user input because the data came from a
request get parameter call and then you
know the data is appended to something
and then the data goes through a regex
and so we say well that can have limited
characters we tagged it with limited
characters because it went through this
top Frederick's right so now we can make
be a little smarter with our decisions
about that data and you know is it
really being used dangerously because
it's already been validated so then
there's a replace all and then perhaps
most importantly for this slide is the
data went through an escape for sequel
method which makes it so not possible to
sneak a sequel injection attack through
this through this API so that's why we
tagged it with escaped so now the
trigger is going to look at that so
normally this would fire off of finding
and say we found a sequel injection
vulnerability but because it's gone
through this API although the string
itself is tracked now because as part of
it is is untrusted it's got the tag that
says escape so it's not going to be
reported as a vulnerability so another
neat thing we can do a really not sure
we've really invest in this feature like
it's it's for far beyond what's
necessary to prove problems but we
actually thought to be cool to highlight
which individual bits of a string are
the tainted bits or the untrusted bits
so when we when the parameter first
comes in we just have the three letters
fo
and then we do some string manipulation
and as you can see as it goes through
the the flows through the propagation
events we can see that we're only
keeping track of the pieces that are
actually tainted so then if you if I can
hand this to a developer now and he sees
the sequel call it's super easy for him
to understand her her to understand what
happened here they see the original
piece of data they see how was you know
mocked with by the jvm the libraries etc
and then they can see that it was using
a sequel call so it's easy to easy to
prove so if you've ever had the
unpleasant experience of working with
the static analysis tool or dynamic
analysis tool you've you've probably
seen the render to these problems where
if you're given a static analysis result
where they say you have sequel injection
on this line and you fix it it's really
hard to actually reproduce the issue
because you don't know how to execute
that code path right because the static
analysis tools they simulate the runtime
execution of your code but they don't
really do it so they don't know how
really the starting point to get to that
they don't know whether you came through
the web or you came through a web
service or they don't know what the
starting point is so they just tell you
here's the line good luck so it's
difficult to reproduce and test your fix
and make sure your fixed didn't break
anything because of that so then if you
ever have a dynamic skin you you kind of
have the reverse problem right they give
you URL that they were able to execute
some blind sequel injection through but
then you don't know where in the code
that matches up and if it's a sequel
injection problem then you don't know I
mean it could be in several queries and
if that's deep within your ORM I mean
who knows you know how to figure out
where the problem actually is so I keep
using sequel injection here because I
think everybody's super familiar with
that but I want to encourage you to
think there's a ton of vulnerabilities
that you know you can have in your web
apps but that one really seems to
connect with people so with an is
technology like contrast which is the
one that were that we're talking about
today you can actually get both of those
things right because at any time the the
contrast brain can create a stack trace
and figure out how we got to
we are right so you can get the the line
of lines of code that cause of this
event to occur and also because contrast
is in the JVM it can look in a
threadlocal and say what's the current
HTTP request so what we have here on the
left is the lines of code I know it's
pretty small probably hard to read but
it shows you the lines of code where
these events are happening you know we
got our parameter user and the value of
shrimp and then it goes through some
stuff and there's another parameter that
it's retrieved public share and then at
the end those two pieces of data are
written to the browser without any kind
of encoding or sanitization or anything
and that's what a cross-site scripting
vulnerability looks like so we give you
the lines of code here and we give you
the runtime data so that it's easy to
understand and reproduce here's the
stuff here and then you know like I said
before you know we don't have the
weakness of choosing one of the other we
can actually see both because we're in
the JVM so this is the HTTP request that
caused the cross-site scripting issue to
occur and as you can see here Shemp and
public share are in there so there's
even this little button here replay
request in window where you can just
click the button it will reissue that
HTTP request in your browser for you if
you want to further exploit it or you
want to just exercise that code path you
can do that quite easily so after all
this testing and I've discrete I built
this great UI and I was really happy
with it Jeff was still skeptical so so
this is really exciting right we've got
it we went from a theoretical approach
like we thought we could pull some
really cool security information out of
the running application and we
implemented it use Java instrumentation
API to get that data out and then we
made it work right so now we've got the
real traces coming out of real live
applications and you don't have to do
any real security testing to get this to
happen right you just use the apps
sensors fire and you get this this data
out but there's still some questions
around you know what how accurate is
this thing and what kind of coverage are
we really getting so aspect doesn't work
for the NSA we're headquartered in
Columbia Maryland in or right down the
street from Fort Meade and so we know
there's a group up there called the
Center for assured software and their
whole mission in life is to help
government organizations use security
tools and they put together a test suite
for static analysis tools they built
13,800 test cases to test static
analysis tools to see if they really
work and each test case has a true
vulnerability and then a number of false
alarms to try to trick the tool in order
to pass the test case you have to find
the flaw and not go for the false alarms
right so the existing static analysis
tools don't do very well against so the
NSA's published their results you can
download the paper about this but
altogether all they took all the major
static analysis tools on the market and
together all those tools only past
fifteen percent of this test suite so
they weren't doing very well but we
decided hey you know we can do we could
just run those test cases with contrast
installed and then look at the results
to see how we did and so we did that we
passed seventy-four percent of the test
cases with no false alarms at all so we
feel like we've done something really
interesting here like we feel like we've
made a real advance over the state of
the art and when we looked at it we
thought hey let's let's filter out just
those from you know off top ten kinds of
security tests you know just the ones
like the web flaws that we typically
deal with and from those we're passing
99% of that now that doesn't mean
contrast is perfect okay i want to tell
you this test suite right so the the
test suite five it's pretty simple it's
not like real code right that all those
13,000 test cases they don't look like
real code they're actually they sort of
they took all the sources and all the
sinks and kind of automatically cross
multiply them to generate those test
cases so it's actually it's surprising
to me that the static analysis tools
didn't do better against this but still
I think there's there's good reason to
believe
we're on to something here right we've
got a new technique and more information
is leading us to make better findings so
we also wanted to look at you know so
what's the range of vulnerabilities that
we can find I know there's a lot of
companies out there that claim that they
can solve the OS top 10 right run this
tool you'll be compliant with the top 10
and it's always been really frustrating
to me because I know what's in the
Austin we feel like we're doing
something we're getting really actually
pretty good coverage over the AWS top 10
we're not finding one instance of one
vulnerability in one of these categories
we're actually sort of covering the
whole category now we can't find
everything there are still some things
that are outside the scope of I asked
right things about the environment like
if you're going through a web app
firewall or something that's protecting
your app like we're never access to that
information so we can't make judgments
based on that but we think we're getting
good coverage over the Austin and then a
bunch of other things as well I wanted
to talk about a couple in in particular
here I wanted to show you our rule set
for this is our rule for a strong
encryption now this is you know it's a
simple rule the way we write it we have
a simple XML format and we want to build
a community around this I'll talk a
little more about that but we want you
know the community to work on these
rules are making it open but this is a
rule for using a bad crypto algorithm
and you can see here it's the call to
cipher I get instance here and we look
at the first parameter which is this
this data and this says it has to be
either Triple DES or AES ok so now this
is an interesting rule that neither
static analysis or dynamic analysis can
find right static analysis can't find
this because it's a runtime parameter
that Triple DES value might have come
out of a properties file or out of a
config xml or a database or something
and so it doesn't exist in the static
app so static analysis can't find it
dynamic analysis can't find this because
it's the shower head problem right
you're stuck looking at the front
or when that this choice of algorithm is
probably way deep in the bowels of your
application somewhere so we can do these
interesting rules that I think would be
very difficult in other ways our rules
drive two things actually the rules
drive where to put the sensors in the
application so all you have to do is
when you add a rule it'll automatically
know where to put the sensors to enforce
that rule so it's all rule driven and
the other thing is that the rules also
have the vulnerabilities in them so it
tells the pattern to look for in those
events here's a rule for sequel
injection this also very simple in this
case we're looking at statement executes
call and what this says is this says
that the first parameter if it's tracked
meaning it contains any untrusted data
within it somewhere then oh and it
hasn't gone through the escape for
sequel control then it's a vulnerability
and we need to report it so it's a very
powerful way of specifying this this
this will handle all the different
database drivers that are out there
which we know to instrument anything
that implements sequel statement
executes so we'll find all of those so I
think we're really just scratching the
surface here of what we can do with I
asked security analysis there's a ton of
information inside the JVM that we can
now access because of the Java
instrumentation API and we can make
security a lot better a lot more
compatible for real developers I wanted
to point out one other thing that we
thought of that would that's a cool
feature that we can do so last year or
early this year actually we did a study
I guess this January we did a study
where we looked at the libraries that
are that are people are downloading and
using in their applications now as
everybody's here sure that their
libraries are completely up to date it's
probably not and we've got evidence to
prove it so we did a study with we
partnered with sonatype and we went and
asked them for some data about downloads
we looked at 113 million downloads from
60,000 different companies of
top 31 Java libraries actually was 20 of
the top libraries and frameworks and
then we looked at 11 security focused
libraries because we're interested in
that and what we found was a little
disturbing so over twenty-five percent
of that 113 million downloads that's you
know 29 million downloads were libraries
that had known vulnerabilities so that
means a researcher out there had
published a vulnerability against that
version of the library and no one did
anything about it right you're still
don't downloading old vulnerable
versions of struts 128 some old version
of spring some of these vulnerabilities
are devastating some of them if you're
just using the library then you're
pretty much vulnerable to complete
takeover but yeah there's huge amounts
of downloads of these if you look at
there it says GWT had vulnerabilities
and there were 17 over 17 million
downloads of the vulnerable versions of
GWT to exposes your site so we thought
hey you know that's that's an
interesting statistic right probably a
lot of vulnerable apps out there that
have downloaded this this code and used
it there's a paper about this if you're
interested in more details on on this
but we thought hey we can look at what
libraries get loaded at runtime and get
information about them so with with our
I asked engine it plugs in it watches
libraries get loaded we do a sha-1 hash
of the library itself and then we look
it up in our database and we figure out
what version it is and we report back to
you hey you're using a version from 2005
so I think we got the commons library
there from 2005 the latest version was
in 2010 and it's you know several major
versions out of date and we give you a
letter grade on that stuff so I think
it's an interesting way to get you know
good information out of the JVM about
the security of your applications so
what i zoom back and I think about this
approach I think about how it might
change our industry and how am I change
software development
I really start thinking about more like
you know New Relic and AppDynamics the
way their performance tools work you
just plug in their engine you run your
app as usual and you get this grave
dashboard that says we're all your
performance problems are well security
can work that way too we can get away
from the annual pen test with the crappy
PDF report that's out of date the second
it hits paper we can move away from that
we can have an environment where you
guys get real real results from your
real running app continuously real-time
and automatic automated without
involving a lot of security experts
doing a lot of crazy penetration testing
so we're excited you know I think our
Shan and I neither of us want to find
anymore sequel injection or cross-site
scripting we're done with that and so we
need what we want to get past that I
think we'd rather work on really hard
security problems things like access
control and identity systems that are
actually really complicated and really
deserves some attention but this is the
future that we're trying to look at I
did mention we're trying to build a
community platform arshan and I are both
heavy contributors to OS we've both run
a number of open source projects and
libraries and so we want to try to build
community around this idea of automated
security testing within a running
application so we've got our open rule
language we've got a REST API that you
can pull this information back in your
bug tracking system and so on so we're
actually committed to openness on this
so we really want to want to encourage
that I think we're really looking to
advance the state of the art here and
get the internet more secure so if you
have any questions please stop by we've
got a booth set up at with 5205 you can
try it if you want you can sign up
there's I got a QR code if you want to
go to contrast security com you can
create an account and try it for
yourself for free if you come by the
booth there's you know there's a white
paper there's typical stuff but if you
sign up for an account will put you in
on drawing for a macbook air
and I'm obligated to point out that we
are hiring so this is an interesting
project that we're we think deserves a
lot of good attention so thanks for your
time I'd love to open it up to questions
if anybody has any thoughts or comments
yeah yes it's an excellent question it's
a little tough to measure because it
depends on your application a little bit
if you're doing huge numbers of crazy
string operations the performance that's
a little more but in general we've seen
you know two or three percent
performance hit on round trip time so
it's not terrible we just we actually
want to contract from Air Force room
labs to improve performance and it was
terrible now it's much better because we
did some amazing things to make this to
optimize this we put a lot of work into
it we would talk about that offline but
we did a lot of cool things to make it
much much faster yeah
oh that's a great question so you know
where to run the engine isn't is an
awesome question right so you could run
it in production but we're not really
encouraging that I think most people
will want to run it in dev or test
environments so you know depending it
depends on your setup right you there
may be some organizations that need to
run in part because they don't have a
Denver test right they just bought a
product and they need to run it there
but there's some cool things that happen
if you run it in endeavor test if you've
got a bunch of developers and they all
run with this then when they get the
results they all come together in this
team server and you can filter down to
the results that are just applicable to
the code you're looking at so it's
unlike the the PDF model where you get
everybody's vulnerabilities you could
just see a view of the results that you
know just what you hid in your testing
cases but I don't think most folks would
just want to run it in in dev and test
and maybe you only put it in you know a
couple year test servers or if you've
got a load balanced environment maybe
you just put on one of the instances so
there's a lot of different options here
but you know the engine just just works
you can drop it in on as many instances
of the app as you want and they all
report together to pull together that
well which brings one another point that
I think is kind of cool a lot of
organizations struggle to know what apps
they have out there you know I think
City Bank has our jpmc has like fifteen
thousand applications right so they
might not know if you put an agent like
this on each of your app servers it can
just report back not only what apps you
have but a bunch of metadata about each
app right how big is it what libraries
is it using what back end connections
does it make you know what databases is
it talking to so there's you know you
can pull together an application
portfolio real time that's really
accurate so good question
we do almost all of our work is with
banks a large financials
yeah it's a good it's an excellent
question and I think it's going to
change so currently most financials have
a small application security team and
then lots of development groups all over
the place and the the app security team
they go visiting right visit your
project and you go through a view and
then you pass and you fix some holes and
then you go to the next one and and
they're getting overwhelmed the volume
is just ridiculous I mean one app has
turned into five right we got you know
used to get just one servlet based app
to test and now it's you've got that
you've got that plus you've got the
mobile apps you've got an Android one
and iPhone one you got the web service
interface you got the rich html5 thing
so it gets really complicated for these
teams they're getting overwhelmed for
all the reasons that I mentioned and so
I think it's going to change I want I
want them to do this right drop in an
agent on those apps pull together a
dashboard you know maybe the security
team helps review that or maybe the
development team can just take this
information and fix the problems and
that small security team can focus on
more strategic things let's focus on
getting a really good implement
implementation of a validation api out
to all the development teams like they
can focus on interesting hard problems
and not just chasing XSS all the time so
I think it's going to change it has to
change actually it because where the
path Ron just doesn't scale at all but
that's a different talk yeah
yeah so I remember Arshad said to launch
the agent you just add that dash Java
agent flag to when you launch the vm so
when you do this in an app server it's
frequently it's just an environment
variable that you set are like Java ops
and you said dash java agent equals
contrast out jar and that's enough then
you just launch your app server as
normal you've run your app you use it as
normal you don't have to do anything
different but under the hood contrast is
watching and if it sees a vulnerability
it'll just report that out to the
dashboard so it really is just that easy
i encourage you to stop by the booth and
you'll get a feel for it because it
really is just that easy you can install
it in 30 seconds exact same jvm yep i
think it interesting tip into that this
yep is um that just on a whim you know
we've been focusing on java ee but then
we ran it on a scala and it just worked
like we didn't even we didn't do
anything like cuz uh you know it's all
the JVM right it's all by code and you
know what's amazing is you know all
these languages are moving to the JVM
and you know we want to be able to
support all of them and it isn't turning
out to be much work to do that because
under the hood you know it's all the
same by code so scallop people should
should take note yeah
I think so you know it's a good question
so a lot of organizations their initial
sort of knee-jerk reaction is we need to
do security testing on all our external
facing apps right but if you think about
it the internal apps are often the ones
that safeguard the most sensitive assets
the financials the intellectual property
that you know all the really sensitive
stuff is internal at and so I would say
at least half of the work that we do is
on internal apps for organizations
already I absolutely think this is the
right thing to do for internal apps you
know an external apps it really you know
I think it's a bad strategy to focus on
just external facing apps especially
when every one of you has a browser that
connects to the internet and your
intranet at the same time well that's
like a zillion gateways between the bad
guys and your internal apps right so one
of them is going to get knocked over and
then you've got a problem yeah
yeah I mean yeah you did install it
however many app servers you're running
on that server you would put this in all
of them it's you install it once in an
app server though if you have 10 apps
running on the app server you just have
to put it in once right yeah if what one
per JVM so you just enable it in your
launch configuration for I don't know I
haven't done it but it's probably the
st. it's probably the same two percent
per JVM yeah yeah I think I think it
should go you know it's funny all the
business people we talked to they like
yeah let's run it in prod and we're like
you know we want it to run in Devon in
Devon test because the performance
impact is not as important there and you
get the vulnerabilities earlier like why
would you wait until you're already
exploitable to find the vulnerabilities
only found a month earlier and so if you
had ten JPM's on one server first of all
I'd like to buy that hardware and then
you know I'd really I'd probably want to
focus on you know maybe like think about
what your threats are and maybe just
strategically place the agent on
whatever JVM you think is facing the
most external or facing the biggest
threat yeah
it's currently the ruleset is geared
towards web apps right but the agent
itself you could actually install it in
you know any kind of anything that runs
on the JVM but you might have to create
different rules for what whatever kind
of security attack you wanted to try to
detect secret vulnerability so did you
have some in mind mm-hmm cool so well
the exercise would be to do some threat
modeling and think about what kinds of
vulnerabilities are in that environment
and then designed some rules to make
sure that your code doesn't have any of
those and you know you saw the rules
it's not tremendously difficult to to
figure out what's what's interesting is
that probably half of the rules are the
half that you need like the things like
sequel injection because a lot of those
times the threats on the server don't
change but maybe how the data gets into
the system how you know how we recognize
what untrusted data is coming from that
stack that's just the part you need to
figure out and then everything else will
just work magically so I gotta share a
little story real quick my son is 14
he's learning to he wants to get java
certified and he's really mad that I'm
here because he wanted to attend but I
asked him to try it that's just I even
seen it at all I just said no go to go
to contrast security com create an
account download the engine put it in
your little web app he built a little
web app for a school and and try it and
so about half an hour later he came back
and he said daddy I had some
vulnerabilities he found six cross-site
scripting holes and two sequel injection
holds and he fixed them with the
information available in half an hour
and came back so I was psyched about
that sorry so there's a couple question
color questions yeah
applications
so we have a set of default rules that
the contrast comes with and it's pretty
extensive it covers all those top 10
ones that I looked at but you know maybe
you want to track credit card numbers
through to make sure that no credit card
numbers ever end up in any log files
right so you could define sources you
could say hey these three api's produce
credit card numbers right you get it out
of the database or whatever and then
contrast will track those credit cards
through the application and you could
define triggers for credit cards you
could say all the log interfaces should
never get credit card numbers and so if
you set up the sources and those
triggers then it'll just work and you'll
have many of your findings about credit
card numbers yeah they're centralized in
the server so that you can manage them
you know across all your apps like if
you wanted to say hey we only use it yes
okay great we've pushed that rule out to
everybody but they could download it to
the engine when the engine starts up it
reaches back to the server and pulls
down the latest rules so that way you
can manage them in a you know across
your whole organization but they load
locally so at so so as we make rule
updates and stuff the next time your jvm
starts up it'll just get the latest
rules and you don't have to think about
it yeah there's so we have we have the
engine which is actually really small
that the engine is the agent jar file
it's less than it's less than a megabyte
and it sends the findings out to a
standard sort of server that it collects
all the findings and gives you a
dashboard and all that kind of stuff
yeah it's ours yeah but yeah you can
yeah exactly
how many frameworks that I mentioned 0
in the in these libraries these these
things so we've used it on a bunch of
these I don't have the exact list but
we've we've used it on applications that
use a lot of these different frameworks
the harder thing for us is that we're
we're in the process of vetting it out
on different app servers it generally it
just works but some app servers do weird
things with those GI and class loading
and stuff that we have to work around so
we're in the process of certifying it
for a bunch of different app servers but
you know it's good on glassfish jboss
tomcat little and some others I have the
exact list case we're working to certify
it on Webster anybody wants to help us
certify on websphere we'd love some help
because we need we need an environment
to test it in we can do it right now if
you've got on your laptop any other
questions
there's there's a SAS piece that runs in
a secure data center and you login to
your dashboard there just like the way
that you know AppDynamics our new relic
work you just it just all the data goes
there over a secure connection and it's
all super mutually authenticated and so
on and then you just log in and you get
your dashboard lot yeah well I hope you
guys stop by the booth and check it out
it's fun to play with I mean it really
is you know you just load it play around
with your app for a while and then you
go and you've got vollmer abilities
there so please come check it out it's
in the hilton and its booth 5205 nice to
see your mind we have one more question
oh yeah yeah please
right
yeah I see what you're saying yeah so we
do have some support for its not
clustered first of all but we try to put
in some magic like you know if you have
the right if there's a certain like you
know entity annotation on your class if
it goes through a setter then we'll
always know that the getter returns
untrusted data so we do some magic to
try to like detect that kind of stuff
but it's definitely not complete I'd say
all right we haven't talked about it
actually here we'll have to see how much
how much that's really a problem for
relapse we little feedback so excellent
thanks everyone thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>