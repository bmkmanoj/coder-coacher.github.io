<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Dare to Compile Your Code with -Xlint:all -Werror | Coder Coacher - Coaching Coders</title><meta content="Dare to Compile Your Code with -Xlint:all -Werror - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Dare to Compile Your Code with -Xlint:all -Werror</b></h2><h5 class="post__date">2013-01-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tgFpv1fPC2I" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good option everybody my name is kuchi
Hofstra and I reckon the JDK core
libraries team and this is to it marks
my colleague the same team and we're
going to talk about essentially warnings
today okay before I start on yeah sure
how many of y'all have idea about minus
excellent all minus W error on the slide
okay some of you don't perfect audience
so minus X and all is an option that you
sent to the Java C compiler to ask it to
let you know of any warnings that your
code has and minus W error tells the
compiler that if there's any warning
flag it is an error and don't compile my
code given that how many of you will be
ready to take up this challenge I hope
it's very few so that you know I can
talk and lecture here okay so yeah I'm
not going to talk about this kind of
warning so what are we going to talk
about today well first of all I'm going
to try to motivate you all so that
you'll stay away can actually listen to
me and I'm going to talk about why you
should pay attention to some of the
warnings that Java Sea tells you about
after that I'm going to talk about a
little about you know what kind of
warnings Java Sea NL's what are their
importance and I talked about a little
more in detail about some of the more
common ones then I'm going to talk about
what happened when we in jdk development
took up that challenge that i was
talking about and what did we see in our
own code you know before we ask everyone
else to fix the warnings so I'm going to
talk about that and then some more
complicated warnings and some more
complicated scenarios that you might
come across if you are trying to fix
mornings before concluding I'll talk
about how you should not fix your
warnings but we'll get to that so to
start off why are warnings important
well let's take a step back yr compile
is important well you know compilers
besides compiling your code it's also
the first line of defense that you have
against anything questionable or
suspicious going on in your code so if
you're using any deprecated methods
which are not safe to use if you're
using any question of the constructs or
even if you have some kind of error that
is crept into your code because of you
know we are all human beings so we all
make errors yeah the compiler is going
to let you know about these so when the
compiler is very sure about what you're
doing is wrong if it can prove it it
gives you an error but then there are
situations when the compiler is not able
to prove it but then it's a little
suspicious about what it's what you're
doing and that is when it will let you
know that you know hey there's probably
something wrong going on why don't you
check it and it communicates to you by
our warning so for example you know if
you use a if you declare a list of
string say lyst a then the compile is
very sure that what you need to put into
the list is a string and what you get
out of the list is a string so it should
be stored in a string so you know if
you're doing something else like adding
a number there or something like that
then the kampala can flag and error but
then if you're using a row type instead
of you know a generic list of string
then the compiler has no freakin clue
about what you were supposed to put into
it and if you're doing something you
know suspicious over there the compiler
is going to give you a warning in that
case also you know if you start fixing
your warnings you will see that most of
it is probably noise but many times it
will help you find out about potential
bugs or prevent future bugs it Wilkie
you'll see that if you keep fixing your
warnings you get cleaner code and which
is also safe
so you know i have a small code snippet
over there which switches on sale
integer bank balance and it prints out
you know different statements depending
on the value of bank balance but then
you see you have a missing break
statement here well we all know that we
should put a break statement over there
but you know we all have done that
mistake up not putting that break
statement but had the developer paid
attention to the warning that Java Sea
generates in this case he would have you
know avoided this pitfall also the
especially the Java C compiler lets you
know about any new language features
that are available to for you to use and
then it Flags any kind of deprecated
usage that you're doing so you know ten
years ago are in prehistoric times if
you are dealing with a you know list of
strings then probably you would use a
vector to get your strings who knows
what's there in the vector you would
animate through it you would do cause
and then you would return another vector
who knows what's there in it but now
you're probably going to write something
like this where you have a list of
string all and you look at it and right
away you know it's a list of string and
you know you do whatever processing
you're doing inside it and what you
return is a list of string so this is
much safer I hope I've motivated y'all
enough because it's all down slope from
now and only going to talk about
warnings so moving on just to give you
an idea about how you get to know about
warnings say you have a simple code
snippet where I have a class pool with a
method M which declares a list LST and
you know it assigns a new arraylist to
it and then it's it adds a simple string
to it if you run jealousy on this the
compiler is going to tell you that hey
you know something unsafe is going on
over here why don't you check with you
know some compiler flag- excellent
unchecked okay I go a step forward I
use- excellent
and the compiler tells me okay you're
using to raw types list an aerialist its
best in your best interest that you
don't use it and you're probably doing
some unsafe operation when you are
adding a string to it now I know most of
you probably don't use you know the
command line java see most of the ids
have some kind of an option to enable
the Java Sea warning specifically for
example in that means you can go to your
options hints and then enable standard
Java see warnings over there and once
you do that netbeans is going to show
you those a light bulb and a warning
sign and you hover on that and then you
get to know what the warning is this is
a list of the lint mornings that
jealousy gives you so lint warnings is
basically anything suspicious going on
in your code you have you know finally
which tells you if you're finally block
is not going to end properly you have
dibs zero if you're doing a division by
zero and so on these three specifically
unchecked in raw tysons you get it when
you're using generic so when you're not
using generics and cast is kind of
related to them so i'll be talking about
them later on before that i'll be
talking about these four static
deprecation cereal and fall through
because in our experience they are the
more commonly ones that you see false
hope so when you get a fall through
warning if you're using a switch case
block and your case is not terminated by
either return statement or it does not
throw a new exception or you don't have
a break statement over there you are
going to get a fall through warning from
the java c compiler why does java sea
communicate about this to you with a
warning because most of the times you
know it's a programming error sometimes
you want your logic to fall through to
the next case but most of the times we
miss you know inserting a statement over
that
so you know I have just a simple example
if you know val value of val is one we
do something value of two value is 2 we
do something else otherwise we do
something default and since we don't
have a break statement right after
whatever we do in case one we're going
to get a warning over there there is one
location though when the compiler
doesn't give you a warning that is when
a case is not followed by any code and
you simply fall through to the next case
because you know this is a common
practice used by developers to group
multiple values into a single case so
that is why this is not filed as not
flagged as a warning now you'll you'll
feel that you know oh this is a simple
thing probably you know this won't harm
me this looks harmless but let's look at
an example where things might get wrong
might go wrong so we are switching on
and probably an integer val and then if
its case if its value is zero we call
the method through an exception whose
job is to throw a new you know
customized exception if its case one we
do some normal processing for default we
do some default processing now what
might go wrong here I mean of course
there's a fall through warning there but
then what might go wrong the logic well
know what might happen is if you
override throw an exception there's no
guarantee that whoever overrides throw
an exception will be throwing an error
over there so you know in that case what
happens is your logic religious fall
through to case one a cleaner way of
doing this would be you know you throw
an exception over there probably get an
exception from another method that's
fine but you actually throw that
exception over there you don't get the
fall through warning and you're
guaranteed that even if someone over
writes that method then he will have to
return an exception over there yep yeah
if you if you say its final then it's a
different yeah moving on deprecation
most of us know we get a reputation
warning when we are using a deprecated
method deprecated class or a deprecated
field usually these are unsafe to use
that is why the language tells you you
know don't use these or if you go
usually if you go to the javadoc of
these deprecated methods you will
recommend to you you know what other
methods you can use in the in the place
of these methods just for coverage some
examples thread dot suspend tread that
stop thread that resume are all
deprecated because thread dot suspenders
inherently deadlock prone if you're not
using thread dots spin then what do you
use thread would resume on and thread
that stop leaves your program in an
inconsistent state however so if you use
them you get application warnings but if
you've used your use if your application
is designed to use them the only way to
get rid of them is by restructuring your
application string that get bytes
datainputstream dot read lines and some
red line are some other examples where
the conversion between bites and
characters are not properly handled here
so if you do use them and if you're
using ASCII you're fine but otherwise
your data might be corrupted static very
simple this warning is issued when you
use when you call a static method by
using a reference to an instance of the
class instead of the class name itself
so if you see the example we have a
class static demo and which has a static
method do not call with instance and you
go ahead and you call it with the
instance demo you get a static warning
over there what you're supposed to do is
call it with the name of the class like
the last line there
well this also kind of looks harmless
but let's see let's look at an example
how you know this can cause errors and
logic so we have a class foo and it has
a static member value you know static
function set value which basically sets
the sets value to whatever parameter you
pass and you have another method get
value which returns value to you now
someone starts calling this with an
instance variable look that met out the
class like you know foo 1 equal to new
foo foo to equal to new foo and then he
calls who and let's add value to first
who when the boutots add value to second
and once he calls who and that get value
he's probably expecting that it's going
to return first to him however since
it's a static member and those are
static methods you get second right
because value is set to second because
it's a static method so you know you
might just be surprised by what you get
back zero so this warning is issued when
you have a class which implements
serializable and you have not declared a
serial version you ID for that class now
why why is it so important to declare a
serial version you ID so when you are
serializing what happens is say you have
a sender which see realizes an object
before sending it to the receiver and
you know the receiver will receive the
object deserialize it and do whatever it
wants to do with it so when the Sun is
see realizing the object what it's going
to do is it's going to pack into the
object the class file version that it's
using you know perhaps something like
8742 to blah blah whatever the number is
there and it's going to pack it into the
object before sending this object to the
receiver now once the receiver receives
the object it's going to DC realize it
I'm in the prom while in the process of
DC realizing it it's going to check that
the serial the class
motion that the receiver is using is the
same as a classified version that is
packed into the object if it is not it's
going to give you an invalid class
exception and cereal or should you ID is
essentially this class file version
that's packed into the object right now
in case you don't declare a serial
version you ID in your serializable
class the compiler is going to generate
a default one for you however it's
discouraged to use that default value
because even with you know changes that
are perhaps a knock use that you feel
are not you know that great or important
your serial version your ID will change
in surprising manners and you know
you'll get invalid class exceptions you
know you'll be surprised by what you see
basically what we do when we see you
know such warnings we use the silver
tool it's there in your JDK bin for you
to use and you can use that with the
earliest class file version that you
want to be compatible with and then it's
going to give you an appropriate serial
version for you to include in your class
moving on what happened when we took up
the challenge outset so around one and a
half years back we thought that we will
see how we are doing with warnings
ourselves and just to give you a
background I'm just talking about the
JDK depository an hour in OpenJDK it
majorly deals with the core libraries
there are around 8200 java files and we
are only talking about java warnings
over here we're not talking about you
know native code see warnings and
they're on to points6 millions of code
there and the compiler that we use was
java sea and we enabled all warnings and
we got 13,500 warnings well yeah we were
surprised as well and so this is a
distribution of the kind of warnings
that we saw you know this raw types
uncheck deprecation cereal
static fall through and a small number
of other warnings and if it's not
blatant enough yet yes there are 71 not
three percent of them are raw types and
unchecked right so why do we have so
many warnings in our own code are we
sloppy programmers here we don't care
what we are doing you know we just write
code well turns out no so if you if you
analyze it we try to analyze it so what
happens is you know the language changes
the platform that we are using it
changes it gives you new features and to
take you make use of those features we
change our API as well and then once you
change your you know even you all
probably it will change your API just
like we do and once you change your API
you need to change the implementation as
well and when these three things don't
go hand in hand you will have 13,500
warnings so like for an example before
java 5 java version fight we've actually
had no warnings but then in java 5
generics was added some most of our API
were updated to use generics but then
the implementation was not and then on
top of that we started generating
mandatory unchecked warnings so as to
help people with their code my creation
so you know in the same code nothing has
changed probably some API updated we
have you know several new warnings now
cobian return types were also added in
Java 5 what are covariant return dates I
will come back to it in some time but
then we also again updated some of our
API to take advantage of this and then
you know the implementation was probably
not updated to take care of that and
then we have we had several of redundant
cast warnings because of that java 7
expanded on linty mornings so if you use
java 6 you don't get raw types warnings
if you use Java 7 you same code you
start getting raw types mornings so you
know nothing has changed the code is
same but we have so many additional
warnings right now
so we are trying to fix these warnings
and we I spoke some of the examples that
I spoke about before our from what we
came across and how we solve those
problems and i'll be talking about some
of the examples in genetics that we came
across just to give you a background if
you have a code of this kind something
similar to we saw in few slides not back
you have a list LST and you are
assigning a new arraylist to it you you
are adding a simple you know string to
it Duke and then you're just retrieving
back the string that you added just
before this line and you're casting it
to string now this the first line will
give your raw types warning it'll
actually give you to write x warnings
will list a naturalist and the second
line will give you an unchecked warning
now a row x morning is straightforward
it's given to you when you are using a
row types instead of you know a generic
type that you can use when is an
unchecked one and given an unchecked
warning is given to you when neither the
compiler nor the Java Virtual Machine
can guarantee the type safety of the
operation that is when you get an
unchecked warning so how do we fix it we
try to you know add generics we say a
list of string LST equal to new
arraylist we use a brand-new dymond
operator and then we add you to it and
guess what we have added some more
warnings now we get redundant cos
warnings so we take away 500 warnings
and then we add 300 to it and then you
have to go and worried about how to
remove them so the correct way to do it
would be you know remove that cast over
there because you don't need that cast
anymore it's redundant and this this is
what we are aiming for so this is the
cleaner this is cleaner and safer code
that you get to ok that was easy Oh next
one ok in the next example we consider
two libraries library a and library be
um a has nothing to do with BB has
nothing to do with a except that be
sends a list of string 28 we just you
know imagining a scenario here now how
does we do it it probably you know
instantiates an object a and then it
creates an aerialist and then you know
it calls a method send list to send that
list now be clearly is not using
generics and the the developer at a
suddenly has probably listened to my
talk and has returned back and it's
motivated to remove warnings so he wants
to use generics now now what does he do
well you know he one option he has
changed everything to generics that's
fine but what about this method send
list how does he deal with that he could
he could change the parameter to not you
take a row type anymore and you know
stop taking a generic type but then we
will start getting a lot of unchecked I
warnings in that case so probably it
doesn't want that to happen so the key
points here is a only a nose that what
it's going to get from B is a list of
string it does not want to change the
argument of send list for code
compatibility reasons and so a basically
needs a method which is going to take a
row type and is going to give back a
generic type a generic list string so
what a means is a method of this kind we
have the method name probably is
converter auto genetic it takes a row
type it converts it internally into a
list of string and it returns it back
how what what what is a good way of
doing this kind of a conversion is what
we're trying to talk about here so one
way to do it is you assign Liz 02 list
of wildcards that allows you to go
through each of the elements of list 0 1
by 1 and check that all of them are
instances of string if not you
to a classcastexception right away
because you know you are anyway only
going to accept a list of string once
you do that you can cast it to a list of
string now so you can cause the list
file card to a list of string now this
line will generate an unchecked warning
however at this point of time you are
more intelligent than the compiler the
compiler has no idea about you know what
list 0 contains but you have made sure
that list 0 contains only instances of
string so this cast here is perfectly
legal there's nothing wrong with it and
in such scenarios it's okay to suppress
that warning so even if the compiler is
giving you a warning you know okay this
there's nothing unsafe going on here all
I have is a list of string and you can
go ahead and suppress the warning over
there okay moving on next example this
is another thing we came across where
you have to convert a set of question
extensity to a set of tea now the first
attempt you'll be tempted to just assign
it to set of tea will this work no why
well generics are invariant so set of
tea is not a super type of set of
question extensity so this line here is
going to give you a compile-time error
the next attempt the next instinct would
be casted right so you have set of
question extensity set 0 and you cast it
to set of tea and assign it to you know
set of tea this is going to give you an
unchecked warning and now we are going
to see why we get that unchecked warning
so just to recap what are we trying to
do here we are trying to convert a set
of wildcard extensity to a set of tea
and how are we trying to do it we are
trying to cast it to set of tea now
what's the problem here let's let's look
at an example there's a method print
integers which
takes a set of integers and argument and
it's it's basically supposed to print
out you know all the all the elements of
that said that we pass through it ok now
we assign set argh which is the set of
integer that we've received to a set of
question extends number so what you have
here so set zero and so this is at zero
and that said zero is basically
equivalent right Saudi here is number
right so what so I'm just trying to make
it you know very people into that so
that it's easier for y'all to understand
and then what we do what what we're
doing what we're trying to do is cast it
to a set of novel so now what we have is
set to is a set of number but set 2 is
nothing but set arc right however now
that's said to is a set of number it's
perfectly legal for you to add a double
to it because you double is a double is
a number so what have you done you have
polluted the same so you know I am
hunting out this this set over here but
you could have just returned this set
and whoever has passed that set to you
has no idea that you've added a double
to it probably he assumes you have
returned a set of integer he tries to
you know loop through each of the
element 1 2 3 4 and then suddenly moon
you have one not 0 and you get a
classcastexception so that is why that
cast over there is unsafe to is unsafe
for you to do and so you get an
unchecked warning over there but you
know the problem that crept in in the
previous example is that you were
modifying the set later on however if
you're very sure that you don't have to
modify the set later on this is a safer
way to do it you can call there's a
method unmodifiable set in collections
and you can just pass said 0 to it and
what unmodifiable said does is it
converts it's good it gives you an
unmodifiable view of a set of question
extensity which you pass it and it
returns you a set of tea so you can do
something
like this and but then you know you
cannot pollute set 3 anymore because you
cannot change it cobalion returns and
cows warnings so a few slides back I
told you all that I'm going to get back
to co-parent returns so say we have a
class coup and so I'm trying to explain
what Kobe into tonsils here so say we
have a class fool with a method get me
which returns back a food to you you
have another class bar which extends to
now before Java five any method of food
that bar overrides the return type had
to be exactly the same as the supertype
hat but java five onwards the return
type can be a specialization of the
return type that the supertype has so in
this example a bar is overriding get me
but it's not returning a foo like food
as its returning a bar and this is legal
because bar is basically a
specialization of foo so Java five
onwards this feature was added to the
language how did that lead to a number
of redundant Cass let's look at another
example so we have a class foo which
implements cloneable now cloneable the
cloneable interface has a method called
you know clone which returns back an
object so if any class was implementing
that interface then if it was overriding
clone it had to return an object and if
you were if you happen to use that
method clone then you would have to cast
it back to the object you'd have to down
cast it however once cobian returns were
Abbott we updated some of our API and we
updated it to something like this so now
clone instead of returning object starts
returning foo which is perfectly okay
because who basically extends from
object right so what happens is this
cast now becomes
redundant so you have a few update your
API and you don't remove that cause you
have a number of on sorry cast
exceptions because of redundant Cass so
what you need to do is you know even
remove that car over there cloning Ares
also you know cobian return types were
all were all supplied for cloning Ares
so you know if you have an existing airy
and you know we have an existing array
which is an integer airy and then you
try to clone it before Java five you
would have to cast it to an integer
array what you would get back is an
object adding however ja five onwards
you do not need to you do not need to do
that cost because what you get back is
an integer array so here you know even
the API did not change just the platform
the language changed and again we
started getting additional cast
exceptions okay I'm done with my
examples but so we've been working with
for like one and a half years to reduce
those 13,500 warnings and well it's not
anyone's full-time job but you know we
put in some oz and then we have a lot of
community effort as well and we brought
on that number to 7133 which is around
forty seven percent reduction and you're
working towards zero but the
distribution has not changed a lot it's
still unchecked in raw types still
dominate okay how not to go up your
warnings then sometimes you know you're
very confident about what you're doing
you know you know you you're very sure
about what you're doing you don't care
about warnings and all you want is the
compiler should just shut up somehow
right well good news you have two
options to do that but what we tell you
is used in with caution because you know
it it might just lead to something
untoward for example you can use Express
warnings so this is an annotation that
you can use in your code to suppress any
particular kind of warning so what you
say is say if you're very sure that you
know a fall through is supposed to
happen it's not a human error that has
crept in then you can do an ad suppress
warnings fall through now this obviously
does not solve the root cause right the
reason for the warning is still there
but when accessory you should apply it
to the smallest reasonable scope of call
that you can find essentially because it
will also suppress any future warnings
that you know that piece of code will be
might have been giving you so to make
sense of what I'm talking about we
talked about this method a few slides
back convert raw too generic where we
were converting a row type to a generic
type and then we said that this cast
there at the bottom before returning the
list is perfectly legal because we have
done all kinds of check and we're sure
that's a list of string now so this is
the kind of warning that you should
suppress because you're very sure that
no there's no problem here and where do
you suppress the warning well you have a
couple of choices you could obviously
suppress this i suppress it over the
entire class please don't do that you
can suppress it on the method but the
problem here is say you know tomorrow
some other developer comes in and he
starts adding an integer tool is zero
before doing any kinds of check you know
that'll lead to a classcastexception so
the the better thing to do would be
suppressed warning right on that line
over there because you can suppress
warning on a declaration um- excellent
job
no no only on declarations if you don't
want to change your code at all and you
know you want to just suppress one kind
of warning and you basically want to
reduce the noise that you know the
compiler is getting to you say for sure
let's say you have a an application
where you've used deprecation deprecated
methods all over and you are very sure
you're not going to change that you're
not going to remove the application
warnings but you want to see all the
other ones that your code is giving so
what you're trying to do is reduce noise
over here so this is another option that
you can give to the compiler you can see
something like minus excellent all-
deprecation so what the compiler what
what you're telling the compiler is give
me all the warnings except deprecation
and this also you know just like the
price warnings this also does not solve
the root cause so you should use it with
caution only when you're very sure of
what you're doing okay so just to wrap
it up this is all the material I had but
just to wrap it up I would like to say
you know some some some people write
code just for temporary use and you know
they don't want to put an effort to
maintain that code however most of us
want our code to be used over a long
period of time and you know in that case
you should put in some effort strumenti
in your code the language or the
platform that you're using to write your
code will involve with time and it's a
good idea to also let your code evolve
along with that and the compiler knows a
lot about your code it probably knows
much more than you think and it's trying
to communicate to you via these warnings
so you know don't be afraid to listen to
it and go and fix your warnings thank
you
questions yeah conditioner
so are you seeing that a few instead of
using raw types if you say list of
string LSD equal to new arraylist then
you have some performance implications
is that what you see oh the
conversion you say Oh what you saying is
that method yeah well in anything
there's there's trade-offs right so if
you want your code to be type safe but
you're dealing with raw types the
question is is there performance
implication and running through the
contents of the list and doing into the
subjects well of course yeah there's
extra work right so there's trade-off
here you know for many things maybe that
doesn't matter if you're dealing with
millions of lists or million you know
list with millions of items doing checks
on them maybe it's not worth it but then
you run the risk of somebody passing in
something erroneous and you're getting a
random classcastexception in the middle
of your library so so that's the
trade-off yeah so so you know there's
there's a you know it's basically safety
versus performance and it kind of
recapitulates the old java you know when
C programmers went to Java it's like
what do you mean java does ray bounds
checking we can't do that right so you
know so it's a little bit of that over
again right so but it's a trade-off that
you have to make if it's worthwhile or
not to make that kind of change other
questions
we appear of curiosity predation so
interface has no choice although the
money comes back it's just weapon and
one thing jumped or or something like
that and so severely have to work but
using here at all
oh yeah so the question was about you
haven't you have an interface that's
deprecated and you have an
implementation of that and that throws a
bunch of deprecation warnings and yeah I
don't know exactly what the case is
there yeah we need to grind through that
and you know deprecation is deprecation
is a tough one and there's a bunch of
things in the examples we showed of
deprecation are ones i think that really
should be deprecation because you can
you know there are semantic problems
with that stuff there are a bunch of
other things in the JDK that were
deprecated for not very good reasons and
they're just irritating so you know it's
a bunch of trade-offs right in that case
you might decide to say all right
excellent all- deprecation because you
know you know i mean you could go
through a bunch of extra work and
refactoring again there's trade-offs
there do you want to you want to do that
work in order to gain some you know some
or little benefit to do once what was he
doesn't know that yep okay well so you
you ok so the question was on serial
version UID and whether it encourages
you do the wrong thing by by not having
okay so if you if you if you let the
compiler automatically generate the
serial version UID and then you change
your class the serial version you ID
will will also change and maybe maybe
that's something you would like but okay
well hang on okay so he says it is okay
in your case if it is then then then you
go ahead make that decision but but but
the issue is if the the serial version
you ID will will change in surprising
circumstances
since if you add a getter method that
doesn't change the cereal that doesn't
change a serialized form of the class
but it does change the serial version
your ID so now you've introduced an
incompatibility in your serialization
for no reason whatsoever so okay well
there's a okay so so okay so then yeah
so the next question is well if I just
add a getter method why should that
change the serial of your new ID of the
class and there's a there's very long
discussion which I think I owe a blog
posts on this but serial version you ID
is not the wire format of the serial is
a serialized form of object instances it
is actually intended to be a serial
number of the actual class
implementation version and the way they
did that was to get as much public
information through reflection as they
could and then hash that all together
and so the idea was that if any any
possible change to a class could be an
incompatibility and so the serial
version new ID would change and so the
other part of it is if you do declare a
serial version UID and you want to
remain compatible then what you have to
do is make newer versions of the class
be prepared for changes to the serial
format so yes so if you add a new field
it might be null or if you remove a
field then information might get lost so
there's okay maybe maybe we need to do a
serial version compatibility talk at
javaone next year Oh thumbs up from that
okay all right all right get ready for
drama one next year I give you an answer
to that get an intern ask him to do it
then the next new hire ask him to do it
the next you are asked him to do it and
the legacy continues see it's a good way
to learn the code yeah actually so what
Curt she said is true we hired a summer
in
turn and we had a bunch of project so
the sidemen so so Kurt she is a
relatively new employee on the team and
so so sorry they let me go through the
history historically we knew there was a
problem with warnings and it's like what
are we going to do about that right so
one so last summer we hired an intern
and we had a variety of projects to do
and one of them I was you know figure
out something to do with these warnings
and that's what he did so great guy
named Sasha bulgakov from Caltech did
really great work so he knocked off a
couple thousand warning single-handedly
and then we hired coochie and she's a
tow for your next project you know get
to know the code base clean up some more
warnings and so in fact we hired
somebody else and we assigned warnings
to him as well and so I was having a
conversation with somebody this morning
as well which was it's like Hollis
drudge work of cleaning up warnings it
turns out there is a surprising number
of interesting and very very subtle
technical issues with some of these
warnings and so it's it's actually it's
actually got legs so and actually we had
management support for this too because
the JDK is a as you know it's a very
it's an old code base but it's a very
very long live code base this is not
something we're going to throw away next
year so so you know as maintain errs of
it it's you know it's in our own
interest to keep it up-to-date and fresh
and so you know that's this has been a
long-standing issue of you know what are
we going to do about these what so we
started to do something about it we got
some interesting results well well
they're up imagine you said look it's
been a lot of overtime dollars or we
just say you know the codes working
quite well it doesn't take that long to
fix those warnings I would say yeah yeah
I mean you cannot do all of 14,000 and
you know one day of course but nowadays
IDs are pretty sophisticated they help
you a lot so it doesn't take that long
to fix those warnings i would say that
personally having worked on them
yeah Susan post of the warning because
of the language or lambda um we don't
have any plan as of yet but I am NOT you
know if any new mornings that are going
to come in I'm I'm not aware of of any
new warnings now there are I talked to
the lambda guys a lot since I do work on
lambda as well and there are there are
some cases where if you write a lambda
in a particular way and I can't do
overload resolution in exactly that it
has come up say okay in that case issue
a warning but that would be only a new
code that actually uses lambdas so I'm
not aware of any any new features that
would be added that would cause new
warnings to occur in old code and that
that's that's the pathology that
happened in Java 5 but you know there's
always that possibility that didn't well
that yeah that happened a bunch in Java
7 yeah yeah what was it there was the
yeah and in fact well there's so there's
something we didn't talk about today but
the the auto closeable interface that
was added in support of try with
resources in Java 7 there are certain
usages of that that will cause warnings
to be emitted and it seems like a
sensible thing at the time and I
discussed this with Joe Darcy who is the
spec lead on it and he discussed it with
the ex Rick group and they said well
okay you know we don't know what to do
about this will add a compiler warning
okay well so we're doing the warnings
clean up we're looking at this we're
saying well there's actually nothing
that can be done about this morning
therefore it's a useless warning so so
I'm actually this hasn't played out yet
but my recommendations actually take out
the warning from the compiler so there
may be things like that an eight but but
now there were sensitized warnings you
know and we talked to the compiler guys
were pretty close to them so
not going to go adding warnings
gratuitously or anything like that on us
so I'll tell you what getting rid of the
warnings is not a big deal but I guess
if I sit for three hours I have done it
up you know knocking off 500 warnings is
not a big deal but the deal and what
what comes in is you know everyone is
very because it's everyone uses this you
know our coal library so much everyone
is very concerned about code
compatibility so when we go for core
reviews it it takes a lot of time but
you know it's distributed so I'm not
doing the code of you to three other
people are doing a code review and they
tell me you know i don't think it crept
into my working hours as such i could do
it you know offline at home on a weekend
yeah so it's not going to happen
overnight you know it's been one and a
half years but we have only got gotten
rid of 6,000 one is there around seven
thousand still there it's going to be a
gradual process it won't happen
overnight but what I would say is around
500 mornings whoever's knocking it off
will take three or four hours and then
go to view and everything together will
be another 45 hours a day if you just
take number of us it takes a long time
because people do it you know during
their free time and so on
that each of those going to set one
substantial that's ninety five percent
production
I tried to know of everything we go
class whites and package wise but then
there are times when you know people
likes to what will tell me don't do this
leave it yeah they're a bunch of edge
cases in that basically question was
saying you know there's 8020 rule so
it's pretty easy to knock off eighty
percent but then there's the remaining
twenty the remaining nineteen percent
that are harder and then there's
remaining 1% that are that are
intractable and and yeah that's true
there's some in some really weird
special cases and so there's this
generics case that that's really hairy
where we ended up casting something
through a raw type and saying okay we'll
just do that and and just just have put
ad suppress warnings there so and that's
the thing right so so first of all
there's no requirement that we get rid
of absolutely every single last one so
they're probably a few warnings we've
left in there because you know I don't
wanna I don't wanna garbage up the code
because I actually think this is a
compiler bug there I think they're two
cases of that or something like that and
then you know and then there's there
some other ones where yeah we do use
suppress warnings but quite judiciously
while
yeah alright well I'm not going to try
to repeat the scenario there but yeah
yeah that's what is trained like I think
those hard ones the five person that you
point out that is where you learn if you
have the time so so anyway so just to
just to try to recap that so that the
audience member had a scenario where
he's using generics of this type or that
type and I think there's some things you
actually cannot represent in the generic
type cyst and yeah so when you do that
you're going to make a cast and it is
going to get a generic morning one thing
I would want to point thing to there's
over the years the java.lang.class class
has sprouted a number of interesting
cast conversion methods that will like
if you load a class dynamically from
somewhere you can say you know as
instance of or subclass of and it will
actually return something that is at the
proper generic type and so sometimes if
you if you or another technique is to
pass a a dot class literal along with it
and then you can use the casting stuff
and maybe you guys try that out
but but sometimes sometimes if you if
you use those techniques you can
actually really work with the generic
type system and in the solution will
just pop out but if not yeah you would
have to go through a type sore suppress
the warnings or something like that so
just don't waste too much time on it
because because these things do exist
yep so on top of warnings there's all
there's the checkers framework for the
hi mode do you is a life technology as
being honest part of your saying a
burger
now this oh so no so this this effort is
just about warnings the question was
about other static analysis tools like
find bugs and then the checkers
framework which is based on some new
annotation work going on at jsr 30 a and
that's so the checkers framework is very
interesting but that's that still sort
of work in progress but the intent of
that is to introduce new annotation
types where you can you can add meta
information about your code that will be
checked by an outside framework and
that's very interesting work and so we
are doing I mean so other folks like in
the languages team are working on that
very interesting work but it's kind of
you know we're sort of on the trailing
edge of stuff here we're cleaning up old
code as opposed to you know working on
new infrastructure yeah well so so a so
one of the problems is with the the
annotations that are are we going to be
used by by these new checking frameworks
I don't think they've really been
clearly defined yet so I mean a typical
one that's been kicked around is at not
null so i want to say i want to make
sure that this this is never null and
that would be a good thing but it's not
declared anywhere in the JDK and we
don't actually want to start using it
because it to use it we have to put it
into the JDK but it's not defined yet so
you know but but eventually yeah I think
this is something that we're going to
want to do is to go you know when when
this stuff comes out we're going to go
go on and want to want to add those kind
of annotations and then clean up clean
up any issues that arise from it and I
suspect there will be that because the
checkers framework is all new and
experimental and a research project and
they're going to want to run it on to
run it over real code at some point and
we're probably going to you know real
code is actually expose bugs in it so I
think it's a different effort but I
think it'll be very interesting one and
I'm sure there will be some effort put
into that over the next couple years so
suppose you will be in when you're
boring you decide that supporting an
opti thanks baby maybe your code is good
what a reason again what you have to
procedure
besides staying at express going to let
other people build it that this code is
really good so if we are adding a not
suppress warning we add a comment there
it's it's a standard rule that we kind
of fun to describe why I'm adding that
surprise funny we just don't go and her
that's a Pressman that's the only
procedure we have I think I hear it's
nothing formal I think we're time yep
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>