<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Code Inspection with the javac | Coder Coacher - Coaching Coders</title><meta content="Code Inspection with the javac - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Code Inspection with the javac</b></h2><h5 class="post__date">2013-02-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/bwv2gZ62MpA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome on our tutorial session code
inspection with the Java Sea my name is
Jana chika and this is en la hora we are
NetBeans engineers working for Oracle
now let's go through this mandatory
slide today we will talk about parsing
we will talk about Java C Java model we
will talk about compilation about about
invoking Java C compiler and we will
talk about our experience with using
Java C as a parser in we have this
experience with the NetBeans IDE when we
use Java model for refactoring features
and for editor completion and so on when
you are looking for a good Java model
there are several options or general two
options you can create your own model or
you can use some existing models and
parsers so why not use Java C Java C is
well tested not only through Java
compatibility kit but also by millions
of Java developers each language
improvement or a language change is
immediately propagated into the Java Sea
and it is used by some products like
NetBeans IDE or checker framework today
we will do a lot of coding this is a
tutorial session so we have only few
slides but we
do a lot of coding today the source is
available at bitbucket so you can
download the source and code with us we
will use Java Sea from JDK 7 and for
some examples also from GDK 8 and we
will use also some recruited stuff which
is available on a on a bit bucket and
now I will do a quick introduction to
Java C model it has three main parts the
first part is Java C element these are
defined in the package Java X dot Lang
wrote moral element it murrells classes
methods variables type parameters
packages and formal parameters it has 1
2 n mapping to the source code it means
that each method or each class in a
source code as some element in java c
model and this part of john morrel goes
only to the level of method declarations
it does not go into method bodies the
second part of the model is a type
system which models type mirrors it is
defined in a package Java X dot one dot
model the type and Java types are for
instance int type or void type null type
or Java util list of of strings
one type element for instance can have
several type mirrors so type element is
for instance generate a list and it it
can have several type mirrors mirrors
like java.util a list of integers or
Java little list of strings and so on
utility methods for working with
elements and tight mirrors are in a
package Java X dot planet model would
you tell the third part of Java C model
are trees which models ASP and we will
talk about it later in our presentation
now let's do first demo Thank You Ann
for interaction can you hear me from the
speakers please yeah thank you so the
first example we'll be using just the
elements and type mirrors nothing more
and we will basically write an
annotation processor because that
because annotation processors let me say
implicitly get get access to two
elements and and types only and the
example will be on on final annotation
and what what does it do or like it's an
example annotation so what do we want it
to do let us imagine you have an
interface like this final interface and
we want just one class to implement this
interface anyone can call call methods
on this interface that's fine for us
anyone can test for the interface is
also fine for us but there should be
just one class that will be that will
implement the interface so the advantage
of such final interface is that we can
safely add methods to it because
the control also the implementer of the
interface so in practice we want to
annotate this final interface with an
annotation like like this saying that
only this fun interface in Rakas can
imply it is the allowed implementer of
the interface so this this is the
develop implement implement and there is
another class that place to find this
interface and we want to prevent this
ideally we want to even to produce an
error and not not allow discuss to
compile at all so let us create an
annotation processor that will do
exactly this and so when one is creating
an annotation processor we we typically
extend the upset processor then we need
to say on which annotations we we want
to be called but we want to be called on
this on this class to check whether it
it's allowed to implant the interface or
not and this class doesn't itself have
any Intel annotations so we we will say
that that this annotation processor
should be called on on any on any class
which is which is basically done through
this to the star but we also need to
register this this annotation processor
into my type sign into meta in services
so that each other see knows how to find
it and for that I will I will use a
special annotation that comes from
NetBeans that will automatically
generate the the ante in in metal-metal
services for us I the resulting meta
analysis later but it else has
simply registering any any class for any
API type into intimate analysis so that
it can be loaded for example by service
loader and the annotation processors if
he if he implant upset processor the
only method that we really need to fail
is the process method which will be
called when compiling some services and
in this method we need to let me say go
through all the classes that are being
compiled and we will do that by by going
through the route elements like this
first of all to be to be on the safe
side we will check that the element we
have is it's a class and if it's not a
class we will simply skip reprocessing
completely and now what what we have in
in the variable E is basically this car
model for this class and now we need to
inspect all the interfaces it implements
to see if the interfaces themselves have
the final annotation and verify whether
the constraint placed by the final
annotation is fulfilled or not so to get
access to the to the super interfaces of
a class we need to cast to an type
element so I will do just that
and then give a loops through all the
super interfaces of the of the class he
have
yes yeah okay please if if something is
not clear or something case so please
tell me and I will try to like fix that
or explain it more thank you
now what we have if you look if you look
at this apparent emphasis of a class we
see that we don't have any elements we
have tight mirror and the reason is that
we can have class we can ask us a we can
have class a that implements list of
things like this this discuss the super
interface or the the super type of I is
not just list its list of things and to
model this exactly we actually need the
tight mirror so this is why we get the
tight mirrors as the super interfaces of
the class and now we will need to go
from the type from the tight mirror to
an element and we can do that through
utility class which is in standard suite
third method in in a standard utility
class called types that can let me say
convert from tight metals to elements if
if there is an element for the given
type metal so we all do this here this
is our super interface element and let
me okay
let me wrap this this way now we all
need to look at the at the annotations
for the super interface element whether
there is the final annotation or not to
China constrains for that we could we
could use this get annotation method
which which takes the annotation class
but we won't do that because I thought
we we can do that inside annotation
processor and it works in most cases
then we will go into into modeling and
into into working these the t's it may
be let me say wrong to actually load
some class for for the annotation so
instead of that I have prepared utility
method that will that will look up
annotation by name so like the model of
the annotation in in the Java C model
this basically all all this this method
does is it iterates through these get
annotation mirrors and finds the one
that models annotation of the given name
and returns the the annotation mirror
for the annotation the annotation mirror
is basically the model of the dick of
the usage of the annotation so
I didn't do it like this so now if if
there is no final annotation on the
element then we can continue to to
another to another super interphase and
I need to fix this to actually place
that the super interface and now at this
at this point in the code we positively
know that the class we are compiling
right now is implanting an interface and
that interface is annotative is the
final annotation and the last thing that
we need to check is whether the current
class is adult implementer of of the
interface and to do that we need to
check we need to check whether the
current class is listed here as as the
alt implant or not and I will use
another utility method to get the value
of the attribute of the annotation from
the from the annotation mirror and it
will be in in this case we will get we
will get an array of tight mirrors
modeling the the classes that are in the
in the annotation usage so allow that
implementers
and now the last thing either do we go
through these a lot in planters and
check whether the current class is among
them or not so a very very simple very
simple loop and again use use the s
element okay
yes sorry I I always forget is that fine
yeah thank you so and let me close this
and you should this should give us more
space we have we have the class that we
are processing here and we will see if
if it's it's any of the allowed
implementers so we will again use this
this s element method that converts
titles to elements like this and if
two few buckets if it is that then then
the current class is Alton planter of
this interface and and everything is
cool so we will just we will just
continue checking this with other super
interfaces but if we are not all Tim
Permenter which is basically if you get
to this to this point then we need to
produce an error and we can do that by
using the message error and sending a
message to this message of off type
error and we need to produce some some
tags and I will cheat a little bit and
copy the text from somewhere so that so
that later we have the correct text here
and the text basic or the error
basically says you cannot implement the
super interface because because the
current class is the class that is that
will get this error is not it's it's all
to implement so yeah this is this is
basically all the code that should do
the checking
we just need to return a value from from
the process method and we will return
false because that means that we didn't
consume any any annotation that other
annotation processors should still be on
on on the given class and now let me
build this project and if I will go go
into the into the implementer I will get
this error saying hey you cannot
implement that and even even if I try to
build this project I will again get
I will again get a compression error and
the code simply won't compile but the
altimeter is fine it has no notable no
trouble implanting the interface now for
for writing code like this we could we
could in theory check manually whether
we are writing the correct thing or not
but it's very easy to write automated
tests for verifiers annotation
processors and so on like this so I have
I have written some tests for this for
this tutorial and the test for this
final rule is here I handed to see if if
the implantation is correct so the
implantation is is correct and let me
now explain a bit the test framework so
that in the next example we can we can
like use it more easily
sorryi the example project that is the
final interface intruder has the project
with the annotation processor on its
class path of processor pass at at which
point it the Juris evil will find the
annotation processors I guess that in
meta-analysis which I promised to show
and did and so far and random so let me
let me first show how the how the
annotation processor is a guest
registered inside let's imagine belt
belt jaw we have inside directory meta
in slash services we have file whose
name is is the fully qualified name of
an API class in this case derives
annotation processing processor which
contains the fully qualified names of
the actual implementers of that API in
in this case our final rule it's yeah
and the Java C will look it up from here
yeah okay let me go to the to the test
test framework it this is a very very
simple test framework for testing
annotation processors and others similar
other similar let me say verifiers we
take we take some some class true test
called start start a builder on it and
then we specify some some input files so
in this case we are specifying the test
input file that implants an IP I
interface
and an API input file that is the actual
interface that is not allowed to be
implemented at all let me say that we
want to run some rule and we say hey
verify that the warnings provided by
this by this in this case annotation
processor match this image these
warnings so pardon this is this is
basically all for this first example
which is mostly on the elements and and
tight mirrors and very simple annotation
processors are there any questions on
this okay so I will have a sip of water
and I will continue so now let me switch
to the third piece of the of the Java C
model the probably most interesting plan
and that I did the STPs and this desire
desire is a defined in concerns of
Stream package these this s/t like
obviously models the the whole source
tree including matter bodies and and
everything inside the source code and
the ast nodes have attached elements and
and tight mirrors that somehow
correspond to that to that st node we'll
see an example an example later the
quite a few Terra T's for working with
the ast in the Utah package and probably
the most important man is the piece
utility class which allows us to map a
nest or get the the element and type
mirror from a nasty note and allows us
also to go back from an element to the
SD know that that declares that element
in the ASD but for to get the t's
utility class work in the exact same way
as we will use it here it requires small
non-standard extension which will
hopefully show like so let me let me
show you an example of the is TP as
produced by by Josie and how it's
attributed or how are the elements and
type type metals attached to it so let
us consider we have a variable L which
is of type list of strings and then we
have expression I'll get 0 which
basically means get the very first item
from the list so this is the empty ast
at the very top here we have the method
invocation the method call itself here
we have the parent it's it's a simple
integer and here here if we have this l
dot cat and it it split into into two
parts in the ast 1 1 is the let me say
dog gate and 1 is the variable L so that
if if one gets used used to this that
the model is very neat and and very
simple and when Java C attributes this T
and tries to attach the correct types
and elements to it and tries to resolve
which exact method we are calling here
from from list it starts with the Miss D
parameters so it sees that the
there is just one parameter which is an
integer literal so it's of type int and
everything is simple oh sorry and then
it then it goes this way down and looks
at this identifier and tries to look up
in the current scope what was the
meaning of L and it finds out that the
meaning of L is this Mario L then it
looks hey I have this variable L what
what is the type of this variable so it
gets that it finds out that its lists of
strings and after that it it asks a
question I have a list of things I am
calling a method get on this list of
strings that takes one parameter of type
int which method I am calling and it
finds out that we are calling the method
gate with this one parameter of type
integer of type end actually this this
process of resolving the exact method
that is being called is not very trivial
it's pretty complex in especially since
Java 5 it's not not not really something
that one could type in two minutes
and as the last step processing this
this T we now we now know that we are
calling a method get on on list and we
need to find out what's the return type
so that we can for example in the same
way attribute some some nasty note above
above this current run and we will find
that the return type of this method in
this particular case is staying so I
would like to ask if there is any
question on the SD ok please
I am pretty sure they are in the tools
jar saying six and I am using seven in
this in these in these examples yeah it
it's like it's it's not it's not
standard API at the same level as Java X
something but we are using it in in
NetBeans for better long time to implant
basically all features but it's like
it's it's not it's not at the same level
of stability as Java X something now
some some may be asserted facts about
about the ISPs the STS in in Java C are
just from the root to leaves there are
links just from from top to bottom
there are implicitly no links from leaf
- who - the hood so you monk we cannot
go up up the ast and if we need to go at
some point up the st we need to keep
something that is called t path and it
keeps all the st nodes from the root to
- whatever
st note we have and you can go up this
this three paths of a lake that there
are two important utility classes for
terrorizing the the ast going through
let me say all all s denotes the tree
scanner which doesn't keep the currently
path and the tip a scanner which
actually keeps the three paths that
corresponds to the current st node
similar visitor scanner pattern can be
used also for terrorizing
element but it's maybe not note that not
not use that much of them sorry
now what we will be coding later is VL
code some checkers and verifier that
will that will check that some condition
is is too or false and these checkers
can sometimes be on on code that is that
is not a valid Java and for example for
me it's inside inside the NetBeans
editor most of the features ran on
whatever code is there right now which
is typically not a valid Java Val you
are typing typing the code and in such
cases the model itself can be a little
bit like Miss a surprising or the data
in the model can be sometimes something
else that that one would expect so it's
good to code defensively I will try to
do that here but in some cases it may
not be defensive enough even what I will
do in this session in particular it's
good to check for nails in in various
places especially for in what we get
from please get element and please get
time error and we should check what are
the kinds of elements and and type
matters we should not expect that well
like for example if you have a class and
be look at at its superclass we would
expect that a superclass of a class is
again a class right but it's only two if
we are not looking at Java rank object
because there is no superclass of Java
rank object so as as long as we want to
handle all all the situation's we
need to actually check what is the the
super class of the class here processing
right now and handle cases where the
super class is not a real class but then
it's something different so now let me
do a coding example of how the how we
can use the a STS and for that we will
use another annotation which when it
will be placed on a variable or a it
will mean that the variable should only
contain valid regular expressions and we
will check whether if the variable is
initialized but it is or it is not a
valid regular expression so for example
here we have a variable called pattern
we claim that it should contain only
valid regular regular expressions but we
are initializing it to something that is
surely not a valid regular expression so
now we will write a checker that will
test and produce warning for the
situation and I evil need to cheat a
little bit more to see what should be
the name
and now to avoid some complexities with
trying to get please from annotation
processors and so on we will use a
framework that that is skated in this
project on the side and that defines an
interface called rule which basically
will give us some context and completion
unity which represents the root of the
ast for for one file and the analysis
context is somewhat similar to what is
the processing environment inside inside
annotation processors so now we have
chosen this one now we have we are
called we have an ast root that
corresponds to the file we are
processing right now and we need to go
through it and find out that there are
variables that have X Records annotation
that are initialized to something that
is not X so let us start with something
simple and sorry we will need we will
need to go through the whole whole file
so let us do it like this in in this in
in this example we will modify this code
later and now this this tip a scanner
will go through the whole ast and there
are methods for each kind that the ast
for
each kind of ast nodes and we can
override these methods and they will be
called when then for each st note of
that specific kind so for variables
Fievel over 8 visit viable metal which
will be called on all places or on all
the creations of a variable and now we
need to check whether the variable has
has the records annotation and it has
initializer and initializer is a
constant thing of and invaded the
constants Inc is a vertex regular
expression or not so first let us check
whether there is the records annotation
and for that we will get the element
that models this variable in the element
board and for that we will use the trees
that we will in in this case get from
the analysis context which shields us
from some complexities is getting
getting getting the STS and so on and we
will use the get element method which
gets us the element that is attached to
this to this s/t know until pass the
current key path to it and it's not
final ok now we will use the find
annotation utility we seen before to
check whether there is the brackets
annotation text annotation
and if there is this well written
something different than now so we will
continue continue with our check-in here
now we need to see if this if this
variable has an initializer that is like
simple one simple case that we can use
and let me do that on Corrado in this
particular case if it's if it would be a
compile-time constant we could get it
also from the element hey the value but
we won't depend on whether the variable
is or is not a compile-time constant and
we will actually pull the constant value
from from the the ast so if the variable
P has some some initializer then we are
going to do something and for for now we
will simply ask not whether it has an
initializer but also whether it is of
kind that is thing literal but what I
should point out here is that each each
of the st node or the st nodes have a
method called get kind which returns us
which exact kind of the st node we are
holding right now and string literals
are of kind thing right arrow that is
understandable and so from from here we
can we can simply pull up with the crowd
the value of the constant so
I can do that like this I don't know
what's happening it should it should
show me that it should can be cast it or
should be cast it Oh No ah sorry wrong
stream character hello yes think later
please sorry I am I am tired
okay Maya projects I am very tired it's
it's a little T that that models any
earnest any literals including literals
and integers and so on so we have this
letter T we get the value of all the
literal which is think in this case and
now we will abuse the records pattern in
in in Java to validate if it's a valid
if it's a valid tag or expression
if it's not we will produce produce some
warning and for this for this I I won't
use exactly the messenger that is used
by antigen processors because it only
allows us to add warning on on elements
or annotations that are annotating an
element I will use a different method
inside the three suit articles that
allows us to attach an error to any any
ast node we need so in this case you'll
produce a warning I will cheat a little
bit more and okay in in this case I
don't need to really see that much we
can we can simply use the description of
the pattern syntax expression we will
add the warning to the variable
initializer and in in this case we also
need to say from which file the three
that we want to annotate this the
warning comes from that is our that is
the root of the ast and over format this
differently so that it can be seen so
here we are checking whether whether the
constant is a valid regular expression
or not and here we will paint some
warning and I have some tests for that
so let me check if at least some of them
are passing so some of them are passing
some of them are not which is fine
because these these tests test much much
more than than just this simple case
that we implemented so far so let me and
just this method just this one test
method that basically corresponds to
this to this example test class and the
test passes so our checkup actually
produces the correct learning at the
correct place and now we can play some
more this these days produce fix fix
some more of these tests to to see to
see how to use the ast some more so in
this case we are we don't have exactly
the exactly the literal in in the
variable initializer we are airing some
compile time constant
so at this point what we need is to look
up the meaning of this death mask
variable get its value and check whether
whether its regular expression or not
and to do this I will actually create a
method from this from this forget
getting the constant
so I'm afraid I've only to modify it a
little bit because we will need even in
the context in the future we don't need
it right now to get to get the value of
all the year lateral but even knitted in
the future and now basically what you
need to do is to go through various
kinds that the initializer can have and
and I solve them and I will do one more
one more change here and that is I will
use just a tea
just a tea and we'll pass the
initializer to this method from here
which will allow us to took to go echoes
ever in this in this method and we will
go by by kinds doing doing whatever is
necessary
I've already named this to expression so
if in case you have we see a string
hotel we already know what we should do
we should just pull out the value out of
the out of the string literal if you are
seeing and identify or a member select
which basically means something dot
something and we can handle this
together without without any any real
difference
we've only go even to go from the
current place to an element and for that
we basically need to call get these on
please get element and for that means we
need a path so mean
changed the expression to pass anyway
and the pass class has a method called
get leaf which will return us the last
element in the tree path and we will
need to pass the correct path to our get
constant get constant men taught like
this
so now we can look up we can look up the
element that is being covered at the
current place in in the ISD whatever
that is and if if that element is it's
not now this is this is the defensive
coding and if it happens to be a field
because competent concerns must be
filled then we will pull out the
constant value from it so compile time
constant and the the element kind for
for four fields is variable element we
will use this variable element staff and
it has this constant value method which
returns the compile time constant value
for that given given field if there is
any and now if if the compile time
constant is string then we can simply
return eight and we are done if it if
the element effort here is not a field
for whatever reason if it's now if the
compile time constant is not if there is
no compile-time constant value in in the
field if it's not a strain for example
it can be field of type int we will
simply say I found nothing and if the
kind of the expression we are looking at
is it's not recognized by this method we
will again say that before nothing and
we need meaning this this check check
method to validate that there is
that the constant is not now so I will
just add add a guard no check here and
we no longer need this test whether the
initializer is sitting right there or so
we will deal with that and now okay and
now we will test run this test to see if
we out it well yeah we we are actually
going from the we are actually getting
the value of this of this def mask
constant now we can go on this is this
example and check hey if we have
basically static compile-time constant
stain and a link it to another static
compile time constants think that the
result is again compile-time constant so
we probably should handle also cases
light like this one and we can enhance
this this get constant method relatively
easily the kind for for the for the plus
operator is is pass and we basically get
the value for the left part of the okay
sorry and the and the type of the is T
that models plus is binary so we will
take a binary tree from the expression
and we will take the value of the left
part of the left part of the operator of
the expression and the high part see if
they are both non now and combine them
as needed so we all call this get
constant again
we need to divide this tea pass to get
to get the element obviously they see a
mistake here we need to cast the leaf of
all the three paths and we will put the
left operand there we will do that the
same for the right of parent and if this
if both of the the right and left let's
say constants are known now we will
combine them like this and this should
fix this this test for us okay it did
not
which is
a bit surprising to me so at least he
can we can test debugging to see what's
wrong
okay so we are getting this the correct
binary te we are getting the correct
left part and we didn't get the correct
ID back because he got an exception that
that is cool so let me try to the back
one more and after that we if you don't
find the problem we will probably need
to move to some other part I am sorry
for this
it's I made a mistake here I have a pre
pass and I am trying to cast it directly
to a three instead of getting the leaf
node of the tree it's pretty common
mistake I guess we should create a
special warning for this one because it
happens maybe right often and now we see
this this works at least as as at least
as intended and now we could go go this
more of these examples checking in in
this in the case of this test we are
basically calling a method this constant
thing and we would like to check whether
parameter
mark is the hacker sanitation is is a
valid package than Nana method is called
but let me let me skip skip this example
you could spend maybe ten minutes on it
so let let me show you let me show you a
different example which is
i-i think mark cool but it's still
manipulation of the of the st
manipulation of the source code or
choking the source code it's still no
graphics let us let us consider this
this variable list of stings and here we
are removing a staying firm it which is
fine list of things contains typically
contains things so it's fine to him in
first thing for me but on this place we
are actually trying to him long from the
rest of things and there shouldn't be
any longs in in such list but this is
not not really compile time error
because you can you can pass if we look
up the decoration of the remove method
inside layers we will find out that he
can pass any object into it so from the
compiler perspective this is absolutely
fine but from the developer perspective
it's something at least change and so
NetBeans produces the this morning and
we can tie to right the this morning
right goes through the suit st and right
the same morning
but
like one more one more thing before
before really really going going into
that in in this in this raucous fool
inside the the analyze file metal vrk
tink anonymous inner class and doing a
lot of stuff inside inside the metal
which not only doesn't look really nice
on the projector but it's also not not
nice when when one is reading the code
so maybe maybe we could make it simpler
to write the rule by K think maybe
abstract rule that they'll extend the
tip a scanner for us and
and implement the rule for us and it
will it will basically say hey go go
through the whole AST on myself and so I
need to do it in the opposite way and we
will be passing the contacts as the
parameter to the scanner and using using
this let me say infrastructure like
abstract rule we can you can make this
collection this check referred for the
not not very nice culture nor even think
easier at least a bit so now we want to
be called on on this on this piece of
code which is a method invocation so we
will already visit method invocation
method and first of all this method will
be called on on every method invocation
in the whole service and we need to find
only those method invocations that are
actually mapping to collection remove
and to make that simpler I have another
utility method that allows us to
describe the metal signature like in
this case we are looking for Java for
metal to move in Java total collection
that takes one parameter of type object
and
I would like to rename this and it will
it will return us the element for for
this method which is which is executable
element and now we will see if the
method invocation we are looking at
right now is is really method that that
corresponds to this to this collection
remove so I will use this the piece
mapping again is out too much too much
talking and I check whether the element
is it's not now and whether the element
is is method the elements also have have
kinds so we can check what kind of
element we are seeing and in this case
we are checking for for method element
and the element right now represents the
model element for the method that is
being called in the actual source code
and we need to check whether the method
that is being called overrides the the
Java Java util collection remove method
and the overrides relation should also
ensure that it's the same method if if
needed and for that there is there is a
utility method inside the Java C api's
on the the elements utility class that
checks whether one method overheads and
other so we would like to see if L
overrides the the remove method from
Java collection
and we need to say also compared to
which type to which type and I I will do
something relatively simple here which
is days there are some little twists in
yy1 allama van method can can or can
override another method in some context
and not in a not not in other but we
won't even go into this much deeper
because it's it's a bit esoteric problem
so now this is a reasonably valid check
for if the el method that we are
currently calling overrides the jolt or
Cochin remove method and if it does then
we need to do some more some more
checking and this is the point where it
gets a bit a bit more difficult let me
let me switch back to this to this
example how do we how do we find out
what is the correct what is the correct
types that can appear in the list of
strings we could in a very complex very
tears the the type here hey and map DD
the real type arguments to the formal
type arguments and so on but there is
much much simpler way to do that we can
basically look at the add method and
look at the parameter that takes the add
method in this particular case and check
whether whatever we pass into the remove
metal match is the type that can be
passed into the add method and that's
that's it
it's
it can be done in this relatively simple
way and to that we will use this result
method utility again that is created for
this talk we will just change it to look
for the at method and now we will use a
really cool do it this way and now we
will use a really cool thing in the Java
Sea model and that is this as member of
method and it basically allows us to say
hey this this add method is declared
somewhere in an interface to our
collection and we are holding and we are
calling it on on an expression that is
of type in our case a list of things
give me the correct type of the method
give me the the correct parameters for
the method and return type by already
the real tie deformer type arguments are
substituted with the correct values but
for that we need to look up on what we
are on what variable we are calling the
remove method so let me do it here the
method invocation tree has this method
select which basically represents this
this part of the ast it's everything
before before the opening bracket and if
that and I I will do
something simple here because we don't
we don't need the type of this we
actually need the type of this this part
of the tree so if if the if the method
we are calling is represented by
something dot remove we will take the
type of something from from the from the
T and I will do it like this
it's
and now we were just we were just asked
the the Java Sea to give us give us the
type which is traditionally the the type
on which a method is called is called
side it's it's used everywhere in Jersey
so basically what what we what we need
to get here is to get a type mirror for
further for this this part of of the
source basically
so
I'm missing a semicolon here I guess I
want to look like this so basically we
are looking up the type of of the the
expression here as part of this of this
if statement I I will check if it's not
null if there is something in there and
if if it represents a type that that
corresponds to to a class or to an
interface which means if it's a declared
type declare types is declare type is
for example list of things or a list of
numbers
other types may be for example primitive
kinds which is integral or so and so on
now we will use this site
this sorry this
sorry I
well actually actually do mean in in the
in the parameter here I
okay let me let me show you the
debugging stuff in NetBeans where he can
inspect the trees so we can actually
look look this up exactly so this this
this method invocation here has one
parameter which is of type long little
and it's it's type two primitive type
long but when the Java C is resolving
the which method is being called called
here at this point it does the boxing
unboxing so it knows that this
particular method that we are invoking
at this place is a move that takes
object
I'm not sure if that is like
sorry I I don't really get it
like can you give me an example
okay for checking better whether to
check whether the data type that we are
removing matches the type that can be
inside the collection we will use method
or utility method that is called is
assignable and it actually checks
whether the value can be assigned into
into a variable of an of the type so
what what that what that utility method
does is it checks whether we can assign
this value into into this variable or
into like the type of of the of the
variable L and it also does the correct
boxing unboxing for us it will be next
step the right in in a minute or so so
the Java C will do this disk inversion
for us even in in this case I believe of
course it will check the cells level and
in 1.4 you couldn't do that so it it
wouldn't allow the conversion and would
and we would know that these types are
not not convertible in in in this sense
for so 7.4
okay so now we have now we have
something that models B basically that
that is able to tell us which is this
what was the type of this parameter to
do the atma toad so there is a tight
mirror that that models types of methods
and that is called the executable type
so that is what we all get in in this
case from this as member of this member
of methought it will let let me show it
as member of method will take the
element for for this at method and
replace this type parameter Eve is the
real type for the for this this list of
strings so now we can look up the the
type of the first parameter from the
executable type like this and its first
emitter at parameter and now we need to
look look at the the actual type that we
are passing due to the remove method so
it's what we have there is similar to
what we have seen a few times already
and we basically need to take the type
of the first parameter
I will format it so that it's more
visible so we are preparing for to get
to get the the elements and and take
notes from the STD need to know the
whole path from the root to the actual
SD node so we need to create this three
path at a time and then we simply pull
out the type for the given SD node and
now
the utility method I talked about we can
simply check whether we can assign a tap
an expression of a type into a variable
of another type and is this it
sustainable method and in this case
in this case we are asking whether the
actual type can be assigned to the first
to the okay at method parameter and if
it can't be then we are probably doing
something something strange so so if if
it seems that we may be doing something
something strange we will we will report
warning and I guess I don't need to
okay I named name the class and is the
wrong name
I went to a name it so that I can have
tests on it but not now I I need to to
take the the correct warning that we
should produce and it basically says
that the actual parameter type is
somehow strange and that it should be
assignable to the add method parameter
like this and I wanted to hook up the
the root of the St here as well so let
me make this smaller so this should
probably work and Taiwan to the name
rename the Google because because the
the test name doesn't doesn't match the
the name of discussant so it would be
difficult to hang the test now the test
should match the class and let me let me
uncomment be D tests and let us say on
some simple on like this one and they
didn't pass that's great
and yeah okay sorry I always forget
about that that test expects that vivo
actually past just the parameter not not
the whole invocation of the metal job
but just the the violating parameter
that the warning will be on the
violating planet I'm sorry for this so
now it should be better yeah so this way
we actually checked whether whether in
this case when we are removing a plane
object from a list of things that that
he produced warning for this and yeah we
can test for example by this test that
we are not warning about the correct
invocations so the test is passing and
now quite a few quite some okay there
are some other tests but I will probably
skip doing doing refining the rule to
work is them to to give us time for
other other stuff but first let me ask
is that part with the is assignable
clear or okay
now III won't ride this now but there
are two things to note for this for this
this approach we are taking in in
analyzing the source code and for this
particular cultural human fool the first
is that in the current concept each rule
with Iran goes through the whole AST and
if he will have like two hundreds of
them each of them they'll go through the
whole AST again and again and this is
probably not going to perform very well
so for more production like environment
you'd probably want to say that this
rule is interested only in these kinds
of AST so that it would be called only
on these kinds of st and there will be
just one one car that would go through
the st and cordials at the correct
places and for this particular case what
what's important to note is that this
this method invocation method is called
for absolutely every method invocation
in the source file so if we if we do
something inefficient in in this method
which frankly we do because we are
solving this method for each method
invocation and so on we are going to
slow down the processing law so we for
real world we would need to take some
care other checks to make it faster or
what we are doing in NetBeans in that
means we can specify some patterns and
the the like processing of the rule
would be called only on st knows that
who fit that pattern which make it which
makes it much faster and much harder for
the rules to slow down other parts of
the system and I hope you will get to
this get to this later but we don't have
that that much time for later right now
so now let me so far we have seen how to
how to work is the ast is on a few
simple examples and now let me talk
about how to actually get this this ast
attributed and so on and also how the
Java Sea itself processes the the source
file so basically as a compiler that
produces some executable code st has
Java C sorry it has two parts it has
some front end that analyzes the Java
source code if you will and a back-end
that actually produces the class files
and for us most important already is the
front end because it produces the
attributed SD and the the front end part
consists of several several phases that
come one after one after another and
basically there are two big front end
phases money spars which takes the
source code as let me say characters and
case the ast for them it does the
lexical analysis and K and then passes
the source code and kate's and ast for
that and then there is an a nice face
that goes through the ast and attaches
all of these elements and types to the
ast
and this analyze phase has some smaller
sub phases inside it the first Center it
basically finds out what classes are in
the source code what metals are in the
source code and so on and creates the
element models for 4 DS then there is
attributes a phase which goes through
the whole AST and attaches the elements
and types on all places ourselves voyage
methods are called at specific places
and so on and then there is flow which
doesn't really change the ast but
produces compile time errors for
definite assignment if you have for
example assigning to a final variable or
if a final variable is not initialized
it that ID unreachable code so if you if
you hide something after a turn it it'll
tell us that he can't do that and so on
and not completely all but most of the
errors that comparator my house that I
reported by Java C reported when the
flow phase ends the reason why I
organize devices in this in this way is
that using the common source api's we
can call paths and a nice independently
but we can't really run the just the
enter and not the attribute and get get
the key results
we make call pass and analyze and get
attributed ast and just quickly through
the backend phases of the compiler that
actually produced the class was the
bytecode there is trans types face that
step style type information from the ast
so after the trans types face there are
no less of things there are just lists
there are no
no classes that take dipyramidal just
classes then there is Laurel which
basically converts the current 1.6
source code into I think 1.1 source code
stepping for each for each loops
since 1.5 you can you can do post and
pairing command on Germanic integers so
it's also removed by by the
slaughterface and basically they're
allowing efface prepares AST to be
simply painted into into a byte code and
then there is a face that actually takes
the simplified ice-t and dumps the the
byte code in into a class file now let
us see how we can invoke Java see how we
can invoke the compiler so one option is
to use Jasmine 99 which allows us to
construct a compiler to be some
parameters let it analyze some files
that it K testis attribute them and even
compile the code I mean produce and
actually produce actual class files but
it only allows us to create a new tool
to to analyze source code or or if we
need that produce the class files it
doesn't allow us to actually plug
ourselves into into an existing call of
a Java C on the other hand we can use
annotation processors to actually plug
into into learning Java C that someone
else started we didn't we just plug into
it it's good for example if you need to
auto generate called the generator for
the meta
of services stations that I was using is
is also written as as an annotation
processor that generates the NP it
allows us to check some consents and
actually stop the completion if an
annotation processor APIs and error the
compression were stopped so it allows us
to to stop the compression and not allow
some code to compile but there are some
problems is getting let me say this with
annotation processors I am when we have
seen the faces the Josephus's the
annotation processors in Java C I ran
after the interface which is the surface
of analyzed and at that point the is TS
are not fully felt with this oles
attribute and to actually get the
attribute 8 st for from an annotation
processor one needs it currently can be
done only in very recent GDK 8 and by
various and I mean something that is in
the GDK ITI repository since about last
week so it hopefully it will be possible
to get the attributed s decrease in JDK
8 this is not not possible in JDK 7 so
now let let me just quickly show you how
to invoke how to invoke the the Java C
using JSON 199 it's not not really
difficult basically
can closed Wow I cost too much can cause
this basically the use the tool provider
Factory and ask and to ask it to give us
a Java compiler tool and once we have it
we create a task that actually does some
compression or some parsing and we can
pass some some parameters to this
indicating this task which and the at
least these options here that I am
passing 2 to 8 while constructing it
basically match parameters that we are
that we can pass to Java C so if there
is something that you can pass to Java C
you can simply pass it as an option to
this to this get task metal let me know
or let me point out this this parameter
which is non-standard but keeps the end
positions for T's because normally Java
C doesn't keep the end positions of
teeth it just keeps the start position
of a tree so with this parameter it
keeps also D and positions and violating
the task from the from the compiler to
the pass we pass files that should be
analyzed parsed or compiled to it and
then we can we can simply call a parse
method which will do the pass face the
analyze method which will fail the the
ast is with all the attributes and then
in this case we are analyzing we are
analyzing the
the ast is running running our rules on
them and okay
I I need to peek what exactly test I I
have prepared here okay I forgot one
more thing and that is register this
records pool using using the service
provider so that the interest that you
can look it up it's fine for the test
because it tests just called this rule
regardless if it's registered somewhere
but but the infrastructure that that
really rely on like from the command
line the rules it needs the hopes to be
a guest at and now I will hand this
project which will run this this main
method invoke basically invoked the Java
Sea through the one I should 199 api's
pass and analyze the test source code
for for the records and propose any
warnings that the rule reports at least
that it should do that and as you can
see this is this is the warning that
that reports the rule we created some
time ago so it can be very hard through
this through it the rule is a standby by
this tool that is based on just $7.99
api's I just just show you how this can
be done in the very recent JDK 8 in from
and what I hope will be possible this
release GLK I
that is I have an annotation processor
and inside its process method I register
something that is called task process
task Krishna and this task listener is
then called after after each of these
compile phases and before each of these
companies Kampala phases and so when
when the finished method is called
meaning after the analyze phase we will
we have PFD attributed sts and we can
hand hand the rules and I I will use
okay I won't want actually write this I
will just show you in in like five
minutes at most how the collection
remove staff can be done in NetBeans
it's basically very very similar to what
we have seen already and we have we have
an infrastructure that is like
enhancement of of the simple one that we
used in this this talk it uses pattern
matching or it allows us to use pattern
matching so this this computer learning
method will only be called on
invocations of of remove method of which
a volatile collection it won't be that
this method won't be invoked on on any
other method invocation which basically
means that if this method is slow it
won't slow down the whole process of
analyzing the file and as there are a
lot of call a lot of calls to collection
hidden in the source code
and inside inside this day's method it's
basically very very similar to what we
have done with the plain Java C it
checks whether the actual and expected
type assignable or not it's not not
different and yeah and this at the top
there is registration in into the
NetBeans system that defines this
culture him as a burning inside NetBeans
and the real world burning burning
provider that provides the warning that
we have seen in the in the editor is a
bit more complex but not that much it's
very very similar to the one we have
here so this this is pretty close to
some possibly code from the from the
real world I I will just before ending I
I will shortly say what we have like
explained what we have seen on the
example inside NetBeans views the GRC in
to provide warnings and code completion
and and everything we have two ways to
get to two types of tasks that access
the data from Java C via for grant asks
which like get the data as soon as
possible synchronously and we have began
tasks that background tasks which
produce the warnings for example and
this I ran after for example change in
the editor on the background than days
let me say time to to to Randy's inside
NetBeans we have also some additional
features in the model
for example Javadoc at this time and to
be polite st based model for writing and
basically they be in saints are burning
providers and it's more or less what we
have seen in the example the example for
the netbeans collection remove and III
think important part is that it can use
pattern matching to improve performance
and to simplify writing of these
warnings and now not let me conclude the
tutorial Java C is not only a compiler
we can use it as a library to model Java
source code it's used by NetBeans and
and others so it tells us to verify that
some constraints that we add to that are
not defined by the language but that he
had a fulfill in some cases we can't
even stop the compilation if if the
constraint is not fulfilled and just to
drag you to to be following tutorial we
in like 40 minutes we'll have tutorial
here about decorative light to write the
checkers in NetBeans which is good for
some simple simplier staff but for more
complex stuff which includes the
collection remove runs turns to use the
the Joey api's because the declarative
way in ended means cannot cannot express
such such constraint so now if you have
any questions I will try to answer them
at peace
do you mean dooming the domain cars yes
yes
No Oh like in seven I don't know about
about a very better way but in eight it
hopefully or hopefully it will be
possible to to get the attributed st
form from the annotation processor so
that you could plug into the Josie using
the annotation processor which would
mean that that this are all established
this Josiah ninety-nine wouldn't be
necessary at all right okay thank you
the inside annotation processors bots in
the Roland environment
root elements it can be either from
source or from class file depending or
how how the Java Sea was involved but
it's more typical I think that this is
originating in the source files like
though I think that the most typical
usage of Java see is that it processes
it processes that the source file you
one can really specify classes on on the
on the command line of Java C and it's
very handy annotation processors and
give them the elements for these classes
but I don't think this is very typical
and this that task assigned a staff this
this really gets called only only for
STS that and that must all get in a
source file ok thank you thank you for
question please
yeah day in the presentation I say I'm
confused about what's up and yet there
is a project on bitbucket and in the
download section there is a zip file
that basically corresponds to to what I
was using here and in there is a
repository and in the in the tank of
this repository there also deals
implemented so that one can really see
how how the implantation can look like
to fulfill to all the tests to pass
basically okay so any other question
I'll thank you to attend it to the store</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>