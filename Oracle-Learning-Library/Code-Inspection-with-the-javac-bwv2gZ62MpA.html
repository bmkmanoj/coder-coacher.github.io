<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Code Inspection with the javac | Coder Coacher - Coaching Coders</title><meta content="Code Inspection with the javac - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Code Inspection with the javac</b></h2><h5 class="post__date">2013-02-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/bwv2gZ62MpA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome on our tutorial session code
inspection with the Java Sea my name is
Jana chica and this is en la hora we are
NetBeans engineers working for Rico now
let's go through this mandatory slide
today we will talk about parsing we will
talk about Java C Java model we will
talk about compilation about about
invoking Java C compiler and we will
talk about our experience with using
Java Sea as a parser in we have this
experience with the NetBeans IDE when we
use Java model for refactoring features
and for editor completion and so on when
you are looking for a good java model
there are several options or general I
two options you can create your own
model or you can use some existing
models and parsers so why not use Java C
Java Sea is well tested not only through
java compatibility Kate but also by
millions of Java developers each
language improvement or a language
change is immediately propagated into
the Java Sea and it is used by some
products like NetBeans IDE or a checker
framework today we will do a lot of
coding this is a tutorial session so we
have only few slides but we
a lot of coding today the source is
available at a bit bucket so you can
download the source and code with us we
will use Java Sea from jdk 7 and for
some examples also from GD k 8 and we
will use also some recruited stuff which
is available on a on a bit bucket and
now I will do a quick introduction to
iasi model it has three main parts the
first part is Java Sea element these are
defined in the package java x dot
longwood moral element it murrells
classes methods variables type
parameters packages and formal
parameters it has 1 to n mapping to the
source code it means that each method or
each class in a source code has some
element in Java Sea model and this part
of your model goes only to the level of
method declarations it does not go into
method bodies the second part of the
model is a type system which models type
mirrors it is defined in a package java
x 22 on good model the type and java
types are for instance in type or void
type null type or java.util.list of
strings one type element for instance
can have several type mirrors so type
element is for instance avoid the list
and it it can have several type mirrors
mirrors like Java util a list of
integers or Java little list of strings
and so utility methods for working with
elements and type mirrors are in a
package Java x dot plan would model loot
you till the third part of Java Sea
model or trees which models ast and we
will talk about it later in our
presentation now let's do first demo
Thank You Anne for interaction can you
hear me from the speakers please yeah
thank you so the first example will be
using just the elements and type mirrors
nothing more and we will basically write
an annotation processor because that's
because annotation processors let me say
implicitly get get access to two
elements and types only and the example
will be on on final annotation and what
what does it do or like it's an example
annotation so what do we want it to do
let us imagine you have an interface
like this final interface and we want
just one cost to implement this
interface anyone can call call methods
on this interface that's fine for us
anyone can test for the interface it's
also fun for us but there should be just
one class that will be that will
implement the interface so the advantage
of such fine interface is that we can
safely add methods to it
because we control also the implementer
of the interface so impact is we want to
to annotate this final interface with an
annotation like like this saying that
only this fun interface employ class can
imply it is the allowed implementer of
the interface so this this is the
developed implementer implant oh and
there is another class that place to
find this interface and we want to
prevent this ideally we want to even to
produce an error and not not allow
discuss to compile at all so let us
create an annotation processor that will
do exactly days and so when one is
creating an annotation processor we we
typically extend the upside processor
then we need to say on which annotations
we we want to be called but we want to
be called on this on this class to check
whether it's allowed to implant the
interface or not and this car doesn't
itself have any Intel annotations so we
we will say that that this annotation
processor should be called on any on any
class which is which is basically done
through this to the star but AB we also
need to register this this annotation
processor into my type sign into meta in
services so that Java Sea knows how to
find it and for that I will I will use a
special annotation that comes from
netbeans that are automatically generate
the NP in in metal metem services for us
I i will show you to the resulting
meta-analysis later but
it allows us simply registering any NA
class for any API type into into
meta-analysis so that it can be loaded
for example by service loader and the
annotation processors if he if he
implant upside processor the only method
that we really need to fail is the
process method which will be called then
compiling some success and in this
method we need to let me say go through
all the classes that are being compiled
and we will do that by by going through
the root elements like this first of all
to be to be on the safe side we will
check that the element we have is it's a
class and if it's not a class we will
simply skip the processing completely
and now what what we have in in the
variable in is basically this car model
for this class and now we need to
inspect all the interfaces it implements
to see if the interfaces themselves have
the final annotation and verify whether
the constraint placed by the final
annotation is fulfilled or not so to get
access to the to the Super interfaces of
a class we need to cast to an type
element so I will do just that and then
give a loops through all the super
interfaces of of
of the class you have yes okay please if
if something is not clear or something
Kaesong please tell me and I will try to
like fix that or explain it more thank
you now what we have if you look if you
look at the super interfaces of of a
class we see that we don't have any
elements you have type mirror and the
reason is that we can have class we can
has class a we can have class a that
implements list of things like this disk
discuss the super interface or the the
super type of a is not just list its
list of things and to model this exactly
we actually need the type mirror so this
is why we get the type mirrors as the
super interfaces of the class and now we
will need to to go from the type from
the type mirror to an element and we can
do that through a utility class which is
in standard suite that method in in a
standard utility class called types that
can let me say convert from tight metals
two elements if if there is an element
for the given type metal so we all do
this here this is our super interface
element and let me okay let me grab this
this way now we all need to look at the
addy annotations for the super interface
element whether there is the final
tation or not to touch ID constrains for
that we could we could use this get
annotation method which which takes the
annotation class but we won't do that
because I thought we we can do that
inside annotation processor and it works
in most cases when we will go into into
modeling and into into working this the
tease it may be let me say wrong to
actually load some class for for the
annotation so instead of that I have
prepared utility method that will that
will look up annotation by name so like
the model of the annotation in in the
Java Sea model and this basically all
all this this method does is it iterates
through these get annotation mirrors and
finds the van that models annotation of
the given name and patterns the
annotation mirror for the annotation the
annotation mirror is basically the model
of the dick of the usage of the
annotation so
I didn't do it like this so now if if
there is no final annotation on the
element then we can continue to to
another to another super interface and I
need to fix this to actually let the
super interface and now at this at this
point in the code we positively know
that the class we are compiling right
now is implanting an interface and that
interface is an attractive is the final
rotation and the last thing that we need
to check is whether the current class is
alt implementer of of the interface and
to do that we need to check we need to
check whether the current class is
listed here as as the Alton planter or
not and i will use another utility
method to get the value of the attribute
of the annotation from the from the
annotation mirror and it will be in this
case we will get we will get an array of
type mirrors modeling the classes that
are in the in the annotation usage so
allow that implementers
and now the last think either do we will
go through these are out in planters and
check whether the current class is among
them or not so very very simple very
simple loop and deal again use use the S
element okay yes sorry I always forget
is that fine yeah thank you so and let
me close this and you should this should
give us more space we have we have the
class that we are purchasing here and we
will see if if it's any of the allowed
implementers so we will again use this
this as element method that converts
typing errors two elements like this and
if coops
too few packets if it is that then then
the current class is Alton planter of
this interface and and everything is
cool so we were just we will just
continue checking this with other super
interfaces but if we are not altimeter
which is basically if you get to this to
this point then we need to produce an
error and we can do that by using the
messager and sending a message to this
message of earth type error and we need
to produce some some tags and I will
cheat a little bit and copy the text
from somewhere so that so that later we
have the correct text here and the text
basic or the error basically says you
cannot implement the super interface
because because the current class is the
class that is that that will get this
error is not it's it's all Tim plement
oh so yeah this is this is basically all
the code that should do the checking we
just need to return a value from from
the protest method and we will return
false because that means that we didn't
consume any any annotation that other
annotation processor should still be on
on under the given class and now let me
build this project and if I will go go
into the into the implementer I will get
this error saying hey you cannot
implement that and even even if I try to
build this project again get
I will again get a compression error and
the code simply won't compile but the
Alton planter is fine it has no notable
no trouble implanting the interface now
for for writing code like this we could
we could in theory check manually better
we are writing the correct thing or not
but it's very easy to write automated
tests for for verifiers annotation
processors and so on like this so I have
I have hit on some tests for this for
this tutorial and the test for this
final rule is here I handed to see if if
the implantation is correct so the
implantation is is correct and let me
now explain a bit the test framework so
that in the next example we can we can
like use it more easily
sorry I the example project that is the
final interface intruder has the project
with the annotation processor on its
class path of processor pass at at which
point it the juris evil will find the
annotation processors registered in
meta-analysis which I promised to show
and did and so far and random so let me
let me first show how the how the
annotation processor is a guest
registered inside let's imagine belt
belt jar we have inside directory metal
/ services BF file whose name is is the
fully qualified name of an API cars in
this case jhalak sanitation processing
processor which contains the fully
qualified names of the actual
implementers of that API in in this case
of our final rule it should yep and the
Java Sea will look it up from here yeah
okay let me go to the to the test test
framework it this is a very very simple
test framework for testing annotation
processors and others similar other
similar let me say verifiers we take we
take some-some class true test call
start start a builder on it and then we
specify some some input files so in this
case we are specifying the test input
file that implants an API interface
and an an API input file that is the
actual interface that is not allowed to
be implemented at all let me say that we
want to run some rule and we say hey
verify that the warnings provided by
this by this in this case annotation
processor match this image this
morning's so by them this is this is
basically all for this first example
which is mostly on the elements and type
makers and very simple annotation
processors are there any questions on
this ok so i will have a sip of water
and i will continue
so now let me switch to the third piece
of the of the Java Sea model the pearly
most interesting plan and that I das TPS
and desire desire is a defined in come
some sixty package these this st like
obviously models the whole sault ste
including metal bodies and everything
inside the source code and the AST nodes
have attached elements and and type
mirrors that somehow correspond to that
to that st note we'll see an example an
example later there are quite a few
utilities for working with the IST in
the utah package and probably the most
important man is the piece utility class
which allows us to map a nest or get the
the element and type mirror from a nasty
note and allows it us also to go back
from an element to the st know that that
declares the data element in the asd but
for to get the piece utility class work
in the exact same way as we will use it
here it requires small non-standard
extension which will hopefully show like
so let me let me show you an example of
the is TP as produced by by josie and
how it's attributed or how are the
elements and type type mirrors attached
to it so let us consider we have a
variable l which is of type list of
strings and then you have expression
I'll get zero which basically means get
the
the very first item from the list so
this is the empty IST at the very top
here we have the method invocation the
method call itself here we have the
perimeter it's a simple integer and here
here if you have this a lot get and it
split in two into two parts in the ast 1
1 is the let me say don't get and one is
the variable L so that if one gets used
used to this that the model is very neat
and and very simple and when iasi at
abused SP and place to attach the
correct types and elements to it and
tries to resolve which exact method we
are calling here from from list it
starts with the RISD parameters so it
sees that the time that is just one
parameter which is an integer later
he'll so it's of type int and everything
is simple oh sorry and then it be then
it goes this way down and looks at this
identifier and tries to look up in the
current scope what was the meaning of L
and it finds out that the meaning of l
is this very LOL then it looks hey I
have this variable l what's what is the
type of this variable so it gets that it
finds out that its list of strings and
after that it it asks a question I have
a list of things I am calling a method
get on on this list of things that takes
one parameter of type int which method I
am calling and it finds out that we are
calling the method get with this one
parameter of type integer of type in
actually this this process of resolving
the exact matter that is being called is
not very table it's pretty complex in
especially since Java five it's not not
not really something that one could type
in two minutes and as the last step
processing this this P we now we now
know that the are calling a method get
on unless and we need to find out what's
the return type so that we can for
example in the same way attribute some
some st note above above this current
one and we will find that the return
type of this method in this particular
case is staying so i would like to ask
if there is any question on the SD okay
please
I am pretty sure they are in the tools
jar since six and i am using seven in
this in this in these examples yeah it
it's like it's not it's not standard API
at the same level as Java X something
but we are using it in netbeans for beta
long time to implant basically all
features but it's like it's not it's not
at the same level of stability as Java X
something now some some may be asserted
facts about about the ISPs the st's in
in Java Sea are just from the root to
leaves that there are links just from
from top to bottom there are implicitly
no links from leaf to who to the root so
you bunk we cannot go up up the st and
if you need to go at some point up the
STD need to keep something that is
called p path and it keeps all the st
notes from the route 22 whatever st note
we have and we can go up this this three
paths available that there are two
important utility classes for
terrorizing the AST going through let me
say all all s denotes the tree scanner
which doesn't keep the current three
paths and the tip a scanner which
actually keeps the three paths that that
corresponds to the current st note
similar visitor scanner pattern can be
used also for terrorizing element but
it's maybe not note that not not use
that much of them yeah sorry now what we
will be coding later is vivo code some
checkers and verifier that will that
will check that some condition is is to
or false and these checkers can
sometimes be on on code that is that is
not a valid java and for example a for
me it's inside inside the NetBeans
editor most of the features ran on
whatever code is there right now which
is typically not a valid jolla value are
typing typing the code and in such cases
the model itself can be a little bit let
me say surprising or the data in the
model can be sometimes something else
that that one would expect so it's good
to code defensively i will try to do
that here but in some cases it may not
be defensive enough even what i will do
in this session in particular it's good
to check for now in in various places
especially for in what we get from
please get element and please get a
mirror and we should check what are the
kinds of elements and and type metals we
should not expect that like for example
if you have a class and we look at at
its superclass we would expect that a
superclass of a class is again a class
right but it's only two if we are not
looking at junk object because there is
no superclass of java.lang.object
so as as long as we want to handle all
the situations we need to actually check
what is the the super class of the class
here processing right now and handle
cases where the super class is not a
real class that then it's something
different so now let me do a coding
example of how D how we can use the ASDs
and for that we will use another
annotation which when it will be placed
on a variable or a it will mean that the
variable should only contain valid
regular expressions and we will check
whether if the available is initialized
that it is or it is not a valid regular
expression so for example here we have a
variable called pattern we claim that it
should contain only valid regular
regular expressions but we are
initializing it to something that is
surely not a valid regular expression so
now we will write a checker that will
test and produce warning for the
situation and tie evil need to cheat a
little bit more to see what should be
the name
you
and now to avoid some complexities with
trying to get please from annotation
processors and so on we will use a
framework that that is skated in this
project on the side and that defines an
interface called rule which basically
will give us some context and completion
unity which represents the root of the
st 441 file and the analysis context is
somewhat similar to what is the
processing environment inside inside
annotation processes so now we have
chosen this one now we have we are
called via we have an IST route that
corresponds to the file we are
processing right now and we need to go
through it and find out that there are
variables that have records records
annotation that are initialized to
something that is no tax so let us start
with something simple and oh sorry we
will need we will need to go through the
whole whole file so let us do it like
this in this in this example we will
modify this code later and now this this
tip a scanner will go through the whole
AST and there are methods for each kind
that the AST for each kind of st nodes
and we can override these methods and
they will be called when then for each
st note of that
cific kind so four variables Fievel
override visit viable method which will
be called on all places or on all the
creations of of a variable and now we
need to check whether the variable has
has the record sanitation and that it
has initializer and initializer is a
constant staying off and invaded the
concern sink is a vertex regular
expression or not so first let us check
whether there is the record sanitation
and for that we will get the element
that models this variable in the element
vault and for that we will use the trees
that we will in this case get from the
analysis context which shields us from
some complexities is getting getting
getting d dsds and so on and we will use
the get element method which gets us the
element that is attached to this to this
st know until pass the current key path
to it and it's not final okay now we
will use the find annotation utility we
seen before to check out the dyes de
Vaca x notation decades a notation and
if there is this will return something
different than now so we will continue
continue with our check in here now we
need to to see if this if disabled has
an initializer that is like simple one
simple case that we can use and let me
do that auntie rattle in this particular
case if it's if it would be a compile
time constant we could get it also from
the element here hey the value but we
won't depend on whether the variable is
or is not a compile time constant and we
will actually pull the constant value
from from the is T so if the variable P
has some some initializer then we are
going to do something and for for now we
will simply ask not whether it has an
initializer but also whether it is of
kind that is string literal but what I
should point out here is that each each
of the SD note or the st nodes have a
method called get kind which returns us
which exact kind of the st node V we are
holding right now and think right arrows
are of kind think right arrow that is
probably understandable and so from from
here we can we can simply pull up the
absurd proud the value of the constant
so
I can do that like this I don't know
what's happening it should it should
show me that it should can be cashed it
or should be casted Oh No ah sorry wrong
stream critter hell yes think letter T
sorry I am I am tired okay I I
approaches I am very tired it's it's a
little tea that that models na na na
literals including caterers and integer
terrors and so on so we have this set
healthy we get the value of the retail
which is think in this case and now we
will abuse the vaca X button in in Java
to validate if it's a valid if it's a
veritable expression and
if it's not we will produce produce some
warning and for this for this I I won't
use exactly the message of that is used
by annotation processors because it only
allows us to add warning on on elements
or annotations that that are annotating
an alanine i will use a different method
inside the pre-suit articles that allows
us to attach an error to any nasd note
we need so in this case you'll produce a
warning I will cheat a little bit more
and ok in this case I don't need to
really cheated much we can we can simply
use the description of the patterns in
taxi expression we will add the warning
to the variable initializer and in this
case he also need to save from which
file the three that we want to annotate
is the warning comes from that is our
that is the root of the ast and I've
affirmed at this differently so that it
can be seen so here we are checking
whether the constant is a very regular
expression or not and here we will paint
some warning and I have some tests for
that so let me check if at least some of
them are passing so some of them are
passing some of them are not which is
fine
because these these tests test much much
more than than just this simple case
that we implemented so far so let me
just this method just this one test
method that basically corresponds to
this to this example test class and the
test passes so I'll check up actually
produce the correct learning at the
correct place and now we can play some
more with these days produce fix fix
some more of these tests to to see to
see how to use the ast some more so in
this case we are we don't have exactly
the exactly the literal in in the
variable initializer we are F aying some
compile time constant so at this point
what we need is to look up the meaning
of this def mask diable get its value
and check whether whether its regular
expression or no and to do this I will
actually create a method from this from
this for forget getting the constant
yeah so I'm afraid I will need to modify
it a little bit because we will need
even in the context in the future we
don't need it right now to get to get
the value of all the year later hell but
even eat it in the future and now
basically what what you need to do is to
go through various kinds that the
initializer can have and resolve them
and I will do one more one more change
here and that is I values just a tea
just a tea and we'll pass the
initializer to this method from here
which will allow us to talk to go echoes
every in this in this method and we will
go bye-bye kinds doing doing whatever is
necessary by varying these two
expressions so if in case you have we
see a string literal we already know
what we should do we should just pull
out the value out of the out of the
string literal if you are seeing and
identify or a member select which
basically means something got something
and we can handle this together without
without any any real difference we've
only go we don't need to go from the
current place to an element and for that
we basically need to call get these on
please get element and for that minute
we need a pass so mean
change the expression to pass anyway and
the past class has a method called get
leaf which will return us the last
element in the three paths and we will
need to pass the correct path to our get
constant get constant methought like
this
so now we can look up we can look up the
element that is being covered at the
current place in in the IST whatever
that is and if if that element is not
now this is this is the defensive coding
and if it happens to be a field because
comparten concerns must be filled then
we will pull out the constant value from
it so compile time constant and the
element kind 444 fields is variable
element we will use this variable
element staff and it has this constant
value method which returns the compile
time constant value for that given given
field if there is any and now if if the
compile time constant is staying then we
can simply return eight and we are done
if it if the element afraid here is not
a field for whatever reason if it's now
if the compile time constant is not if
there is no compile time constant value
in in the field if it's not a staying
for example it can be field of type int
we will simply say I default nothing and
if the kind of the excursion we are
looking at is it's not recognized by
this method we will again say that
before nothing and we need meaning this
this check check method to validate the
dairy's that the constant is
is not now so I will just add a de garde
no check here and we no longer need this
test whether the initializer is sitting
right there or so we were dealing death
and now okay and now we will test run
this test to see if be out it well yeah
we we are actually going from the we
actually getting the value of this of
this def mask constant now we can go on
this is this example and check hey if we
have basically the static compile time
constant stain and I linked it to
another static compile-time concerns
saying that the result is again compile
time constant so we probably should
handle also cases like like this one and
we can enhance this there's get constant
method relatively easily the kind for
for the for the plus operator is is pass
and we basically get the value for the
left part of the oh okay sorry and the
and the type of the ist that models plus
is binary so we will take a binary tree
from the expression and we will take the
value of the left part of the left part
of the operator of the expression and
the ipad see if they are both not now
and combine them as needed so we all
call this get constant again in
to provide this cheap ass to get to get
the element obviously they see a mistake
here you need to cast the leaf of all
the three paths and we will put the left
upper hand there we will do that the
same for the right apparent and if this
if both of the the right hand left let's
say constants are no now we will combine
them like this and this should fix this
this test for us okay it did not
which is
a bit surprising to me so at least he
can we can test debugging to see what's
wrong ok so we are getting this the
correct binary PE we are getting the
correct left part and we didn't get the
correct right back because you got an
exception that that is cool so let me
try to the back one more and after that
we if you don't find the problem we all
carry need to move to some other part I
am sorry for this it's ah I made a
mistake here I have a pre pass and I am
trying to cast it directly to a tree in
sight of getting the leaf node of the
tree it's pretty common mistake I guess
we should create a special warning for
this one because it happens maybe right
oh fun and now we see this this works at
least us as at least as intended and now
we could go go this more of these
examples checking in this in the case of
this test we are basically calling a
method this constant thing and we would
like to check whether diameter mark is
the record sanitation is it's a valid
package than nanda method is called but
let me let me skip skip this example you
could spend maybe 10 minutes on it so
let let me show you let me show you a
different example which is
I I think mark cool but it's still
manipulation of the of the st
manipulation of the source code or
checking the source code it's still no
graphics let us let us consider this
this variable list of strings and here
we are removing a staying firm it which
is fine list of strings contains
typically contains things so it's fine
to him first thing for me but on this
place we are actually trying to remove
long from the rest of things and there
shouldn't be any Long's in such lists
but this is not not really compile-time
error because you can you can pass if we
look up the decoration of the remove
method inside layers we will find out
that he can pass any object into it so
from the compiler perspective this is
absolutely fine but from the developer
perspective it's something at least
change and so netbeans produces the this
morning and we can't I to write this
morning like go through the suit st and
write the same warning
but
like
one more one more thing before before
really really going going into that in
in this in this hex fuel inside the
analyze file metal drk think anonymous
inner class and doing a lot of stuff
inside inside the metal which not only
doesn't look really nice on the
projector but it's also not not nice
when when one is reading the code so
maybe maybe we could make it simpler to
write the rule by cating maybe abstract
tool that will extend out the tip a
scanner for us and
and implement the rule for us and it
will it will basically say hey go go
through the whole AST on myself and
sorry i need to do it in the opposite
way and we will be passing the context
as the parameter to the scanner and
using using this let me say
infrastructure like abstract rule we can
can make this collection this dis
checker folder for the not not very nice
coaching him think easier at least a bit
so now we want to be called on on this
on this piece of code which is a method
invocation so we will already visit
method invocation method and first of
all this method will be called on on
every method invocation in the whole
servers and we need to find only those
metal in locations that are actually
mapping to collection remove and to make
that simpler I have another utility
method that allows us to describe the
method signature like in this case we
are looking for Java for metal to move
in Joey total collection that takes one
parameter of type object and
i would like to rename this and it will
it will return us the element for for
this method which is which is executable
element and now we will see if the metal
team equation we are looking at right
now is is really method that that
corresponds to this to this collection
remove so I will use this piece mapping
again is out too much too much talking
and I will check whether the element is
it's not now and whether the element is
is method the elements also have have
kinds so we can check what kind of
element we are seeing and in this case
we are checking for for method element
and the el element right now represents
the model of the element for the method
that is being called in the actual
source code and we need to check whether
the metal that is being called overrides
the the joy java.util.collection remove
method and the overrides valuation
should also ensure that it's the same
method if if needed and for that there
is there is a utility method inside the
Java Sea api's on the the elements
utility class that checks whether one
method overheads another so we would
like to see if L overrides the the
remove metal from Joe tor collection
and we need to say also compared to
which type to which type and I I will do
something relatively simple here which
is days there are some little twists in
yy1 allama van method can can or can
override another method in some context
and not in a knot not in other but we
won't we won't go into this much deeper
because it it's a bit esoteric problem
so now this is a reasonable a valid
check for if if the l method that we are
currently calling overrides the jaw a
little collection remove metal and if it
does then we need to do some more summer
checking and this is the point where it
gets a bit a bit more difficult let me
let me switch back to this to this
example how do we how do we find out
what is the correct what is the correct
type that can appear in the list of
strings we could in a very complex very
traders the d-type hair hey and map DD
the real type arguments to the formal
type arguments and so on but there is
much much simpler way to do that we can
basically look at the add method and
look at the parameter that takes the
atma taught in this particular case and
check whether whatever we pass into the
hem of metal matches the type that can
be passed into the add method and that's
that's it it's
it can be done in this relatively simple
way and to that we will use this vessel
of metal you 30 again that is created
for this talk we will just change it to
look for the at metal and now we will
use a really cool do it this way and now
we will use a really cool thing in the
Java Sea model and that is this s member
of method and it basically allows us to
say hey this this Edna told is declared
somewhere in an interface water
collection and we are holding and we are
calling it on on an expression that is
of type in our case list of things give
me the correct type of the method give
me the the correct parameters for the
method and return type by already the
real Thai deformer type arguments are
substituted with the correct values but
for that we need to look up on what we
are on what variable we are calling the
remove method so let me do it here the
method invocation pre has this method
select which basically represents this
part of the AST it's everything before
before the opening bracket and if that
and i will do
something simpler here because we don't
we don't need the type of this we
actually need the type of this this part
of the tree so if if the if the method
we are calling is represented by
something dot remove we will take the
type of something from from the from the
tea and I will do it like this it's
and now we were just we were just ask
the the Java Sea to give us give us the
type which is traditionally the type on
which a method is called is called side
it's it's used everywhere in Jersey so
basically what we what we need to get
here is to get a type mirror for further
for this this part of of the servers
basically
so
I'm missing a semicolon here I guess I
want to wait like this so basically we
are looking up the type of of the
expression here but as part of this of
this if statement I I will check if it's
not now if there is something in there
and if it represents a type that
corresponds to to a class or to an
interface which means if it's a declared
type declare types is the car type is
for example list of things or a list of
numbers other types may be for example
primitive kinds which is integral or so
and so on now we will use this site
this so this sorry I
suppose that they have a really took
affirmative with it distinguish between
terminal
well actually actually do mean in in the
in the parameter here I
okay let me let me show you that a
debugging stuff in netbeans where you
can inspect the trees so we can actually
look look this up exactly so this this
this method invocation here has one
parameter which is of type long title
and it's it's typed to primitive type
long but when the Java Sea is resolving
which method is being called called here
at this at this point it does the boxing
unboxing so it knows that this
particular method that we are invoking
at this place it's a move that takes
object
I'm not sure if that is like
sorry I I don't harrogate it like can
you give me an example
okay if for checking better whether to
check whether the data type that we are
removing matches the type that can be
inside the collection we will use metal
or utility method that is called is
assignable and it actually checks
whether the value can be assigned into
into a variable of the type so what that
what that utility method does is it
checks whether we can assign this value
into into this variable or into like the
type of of the of the variable l and it
also does the correct boxing unboxing
for us it will be next step the right in
in a minute or so so the Java Sea will
they'll do this disk inversion for us
even in this case I believe of course it
will check the source level and in one
dot for you couldn't do that so it
wouldn't allow the conversion and wood
and we would know that the types are not
not convertible in in this sense for
south olive and Otto
okay so now we have now we have
something that models be basically that
that is is able to tell us which is this
what was the type of this parameter 2 to
the add method so that there is a type
mirror that that models types of methods
and that is called the executable type
so that is what we all get in this case
from this as member of this member of
methought it will let let me show it the
S member of method will take the element
for for this at metode and replace this
type parameter Eve is the real type for
the four days this list of strings so
now we can look up the type of the first
parameter from the executable type like
this and its first a meter or at
perimeter and now we need to look look
at the the actual type that you are
passing due to the remove metal so it's
what we have very similar to what we
have seen a few times already
and we basically need to take the type
of the first parameter I go format it so
that it's more visible so we are
preparing for two to get to get the
elements and and type miles from the STV
need to know the whole path from the
root to the actual SD node so we need to
K this three paths at a time and then we
simply pull out the type for the given
st node and now the utility method i
talked about we can simply check whether
we can assign atop an expression of a
type into a variable of another type and
is this it sustainable method and in
this case
in this case we are asking whether the
actual type can be assigned to the first
talk to the ok at method parameter and
if it can't be then we are probably
doing something something strange so so
if if it seems that we may be doing
something something strange we will give
a report learning and I guess I don't
need to
okay I named named the class in is the
wrong name they went to a name it so
that I can have tests on it but not now
I i need to to take the the correct
warning that we should produce and it it
basically says that the actual parameter
type is somehow strange and that it
should be assignable to the add method
parameter
like this and I wanted to hook up the
the root of the st here as well so let
me make this smaller so this should
probably work and take on to the name
rename the google because because the
the test name doesn't doesn't match the
the name of discussant so it would be
difficult to hang the test now the test
should match the class and let me let me
uncomment DD tests and let us send some
simple on like this one and they didn't
pass that's great
and yeah okay sorry I always forget
about that the test expects that we will
actually passed just the parameter not
not the whole invocation of the metal
job but just the violating parameter
that the warning will be on the
violating planet I'm sorry for this so
now it should be better yeah so this way
we actually checked whether whether in
this case when we are removing applying
object from a list of things that that
he produces warning for this and yeah we
can test for example by this test that
we are not warning about the correct
invocations so the test is passing and
now quite a few quite some okay there
are some other tests but I will probably
skip doing doing refining the rule to
work with them to to give us time for
other other stuff but first let me ask
is that part is d is assignable clear or
okay
now I I won't write this now but there
are two things to note for this for this
this approach we are taking in analyzing
the source code and for this particular
collection him fool the first is that in
the current concept each will be V Ron
goes through the hull st and if you will
have like two hundreds of them each of
them will go through the whole ASD again
and again and this is probably not going
to perform very well so for more
production like environment you'd
probably want to say that this rule is
interested only in these kinds of st so
that it would be called only on these
kinds of st and there will be just one
one car that would go through the st and
cordials at the correct places and for
this particular case what what's
important to note is that this this
method invocation method is called for
absolutely every method invocation in
the source file so if we if we do
something inefficient in this method
which frankly we do because we are
solving this method for each method
invocation and so on we are going to
slow down the processing law so we for
real world we would need to take some
care order the checks to make it faster
or what we are doing in netbeans in that
means we can specify some patterns and
the
the like processing of the rule would be
called only on st knows that fit that
pattern which make it which makes it
much faster and much harder for the
rules to slow down other parts of the
system and i hope you will get to this
get to this later but we don't have that
that much time for later right now so
now let me so far we have seen how to
how to work is the ASDs on a few simple
examples and now let me talk about how
to actually get this this is t
attributed and so on and also how the
Java Sea itself process is the source
file so basically as a vague compiler
that produces some executable code st
has java sea so it has two parts it has
some front-end that analyzes the java
source code if you will and a back-end
that actually produces the class files
and for us most important rd it is the
front end because it produces the
attributed st and the front end part
consists of several several phases that
turn one after one after another and
basically there are two big front end
phases money sparse which takes the
source code as let me see characters and
case the AST for them it does the
lexical analysis and k and then passes
the source code and kate's and AST for
that and then there is an a nice face
that goes through the AST and attaches
all of these elements and types to the
d and this analyzed face has some
smaller sub faces inside it the vs.
enter it basically finds out what
classes are in the source code what
metals are in the source code and so on
and Kate's the element models for for DS
then there is attributes of phase which
goes through the whole st and attaches
the elements and types on all places he
solves voyage methods are called at
specific places and so on and then there
is flow which doesn't really change the
AST but produces compile-time errors for
definite assignment if you have for
example assigning to a final variable or
if a final variable is not initialized
it detects unreachable code so if you
are if you hide something after a turn
it'll tell us that he can't do that and
so on and not completely all but most of
the errors that compared to my house
that I reported by Java Sea are reported
when the flow faith ends the reason why
I organize devices in this in this way
is that using the Khamsin source api's
we can call pass and a nice
independently but we can't really run
the just the enter and not the attribute
and get get the results we may call pass
and analyze and get attributed st and
just quickly through the back end faces
of the compiler that actually produced
the class files the bytecode there is
trans types face that stapes type
information from the AST so after the
trans types face there are no less of
things they're just lists there are no
no classes that take type parameter
largest classes then there is level
which basically converts the current one
dot six source code into I think one dot
one source code stepping for each for
each loops since 1 dot five you can you
can do post and paying command on junk
integer so it's also removed by this
lower face and basically they're
allowing face papers st to be simply
painted into into a bytecode and then
there is a face that actually takes the
simplified st and dumps the bytecode in
into a class file now let us see how we
can invoke Java see how we can invoke
the compiler so one option is to use
JSON 199 which allows us to construct a
compiler to be some parameters let it
analyze some files let it k testis
attribute them and even compile the code
I mean produce and actually produce
actual class files but it only allows us
to create a new tool to to analyze
source code or or if we need that
produce the classes it doesn't allow us
to actually plug ourselves into into an
existing call of a java sea on the other
hand we can use annotation processors to
actually plug into into a hanning java
see that someone else started we didn't
you just plug into it it's good for
example if you need to auto-generate
called the generator for the meta
services Vega stations that i was using
is it's also written as as an annotation
processor that generates the NP it
allows us to check some concerns and
actually stop the completion if an
annotation processor efforts and error
the completion verse top so it allows us
to to stop the completion and not allow
some code to compile but there some
problems is getting let me say this this
annotation processors I am when we have
seen the faces the jersey faces the
annotation processors in Java Sea I ran
after the interface which is the surface
of analyze and at that point the ASDs
are not fully filled with this all these
attributes and to actually get the
attributed st4 from an annotation
processor one needs it currently can be
done only in very recent GDK eight and
by the recent i mean something that is
in the GDK ITI repository since about
last week so it hopefully it will be
possible to get the attributed stps in
jdk 8 this is not not possible in GD k 7
so now let me just quickly show you how
how to invoke how to invoke the the Java
Sea using josiah 199 it's not not really
difficult basically
can close wow I close too much can cause
this basically we use a tool provider
factory and ask and we ask it to give us
a Java compiler tool and once we have it
we create a task that actually does some
compression or some parsing and we can
pass some some parameters to this
negating this task bitch okay and the at
least these options here that I am
passing 228 while constructing it
basically match parameters that we are
that we can pass to Java Sea so if there
is something that you can pass to Java
Sea you can simply pass it as an option
to this to this get task metal let me
note or let me point out this this
parameter which is non-standard but
keeps the end positions for tease
because normally jealousy doesn't keep
the end positions of teeth it just keeps
the start position of a tree so with
this parameter it keeps also d end
positions and violating the task from
the from the compiler to the pass we
pass files that should be analyzed
parsed or compiled to it and then we can
we can simply call box method which will
do the parfaits the analyze method which
will fail the the ASDs with all the
attributes and then in this case we are
analyzing we are analyzing the
the ASDs running running our rules on
them and okay
I I need to peek what exactly test I I
have prepared here okay I forgot one
more thing and that is register dis
records pool using using the service
provider so that the interest that you
can look it up it's fine for the test
because it has just called this rule
regardless if it's registered somewhere
but but the infrastructure that that
really belong on like from the command
line tools it needs the hopes to be
registered and now I will run this
project which will run this this man
metal invoke basically invoked the Java
Sea through the 192 the 199 api's pass
and analyze the test source code for for
the records and pre port any warnings
that the rule reports at least that it
should do that and as you can see this
is this is the warning that that reports
the rule we created some time ago so it
can be really hard through this so it
the rule is a sound bite by this tool
that is based on just seven ninety-nine
api's I just just show you how this can
be done in the very recent jdk 8 info
and what I hope will be possible this
release glk I that is I have an
annotation processor and inside its
process method
register something that is called task
process task listener and this task
listener is then called after after each
of these compiled phases and before each
of these companies days kampala phases
and so when when the finished method is
called meaning after the analyzed face
we will we have BFD attributed sts and
we can hand and the rules and I i will
use ok I won't won't actually write this
I will just show you in like five
minutes at most how the collection
remove staff can be done in netbeans
it's basically very very similar to what
we have seen already and VF BF an
infrastructure that is like enhancement
of the simple wonder that we used in
this this talk it uses pattern matching
or it allows us to use pattern matching
so this this computer learning method
will only be called on invocations of
remove method of which I Valtor
collection it won't be this method won't
be invoked on on any other method
invocation which basically means that if
this method is slow it won't slow down
the whole process of analyzing the file
unless there are a lot of call a lot of
calls to collection remove in the source
code and inside inside this this method
it's basically very very similar to what
we have done with the plane
java see it checks whether the actual
and expected type assignable or not it's
not not very different and there and
this ad at the top dice registration
into the NetBeans this time that defines
this collection remove as a burning
inside NetBeans and the real world
burning or burning provider that
provides the warning that we have seen
in the india deter is a bit more complex
but not that much it's very very similar
to the one we have here so this this is
pretty close to some possibly code from
the from the real world I I will just
before ending I I will shortly say what
we have like explained what we have seen
on the example inside NetBeans use the
Java Sea in 22 polite warnings and code
completion and and everything we have
two ways to get to two types of tasks
that access the data from Java Sea via
foreground tasks which like get the data
as soon as possible synchronously and we
have began task that background tasks
which produce the warnings for example
and this I ran after for example change
in the editor on the background than
days let me say time to to to randy's
inside 19 CF also some additional
features in the model for example Java
doc at this time and to be polite st
based model for writing and basically in
the beam Saints are learning providers
and
it's more or less what we have seen in
the example the example for the NetBeans
collection hey move and I I think
important part is that it can use
pattern matching to improve performance
and to simplify writing of these
warnings and now let let me conclude the
tutorial jealousy is not only a compiler
we can use it as a library to model java
source code it's used by NetBeans and
and others so it allows us to verify
that some constraints that we add to
that I know defined by the language but
that he add our fulfilled in some cases
you can't even stop the compilation if
if the constraint is not fulfilled and
just to drag you to to be following
tutorial the in like 40 minutes will
have to tell hear about decorative light
to write the checkers in netbeans which
is good for some simple simplier staff
but for more complex stuff which
includes the collection remove vance
Eternals to use the jersey AP is because
the declarative way in in that means
cannot cannot express such such
constraint so now if you have any
questions I will try to answer them at
peace
do you mean do mean the domain cars yes
yes
no oh like in seven I don't know about
about a very better way but in eight it
hopefully or hopefully will be possible
to to get the attributed st film from
the annotation processor so that you
could plug into the Josie using the
annotation processor which would mean
that that this are all established this
Josiah 99 wouldn't be necessary at all
right okay thank you
the inside annotation processors bots in
the world environment root elements it
can be either from source from class
file depending or how how the Java Sea
was involved but it's more typical I
think that these originate in the source
files like though I think that the most
typical usage of Java Sea is that it
processes it processes the source file
you one can really specify classes on on
the on the command line of Java Sea and
it will hand the annotation processors
and give them the elements for these
classes but I don't think this is very
typical and vis that task assigned a
staff this this really gets called only
only for sts that and that must forget
in a source file okay thank you thank
you for a question please
yeah day in the presentation I say I'm
confused about what's up and yet there
is a project on bitbucket and in the
download section days a zip file that
basically corresponds to to what i was
using here and in there is a repository
and in the in the tank of this
repository that also deals implemented
so that one can really see how how the
implantation can look like to fulfill
240 test to pass basically okay so any
other question I'll thank you to attend
it to the stars</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>