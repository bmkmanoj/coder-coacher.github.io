<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Make Your Clients Richer: JavaFX and the NetBeans Platform | Coder Coacher - Coaching Coders</title><meta content="Make Your Clients Richer: JavaFX and the NetBeans Platform - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Make Your Clients Richer: JavaFX and the NetBeans Platform</b></h2><h5 class="post__date">2013-02-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/o71rPQ7GSwc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay my name is Paul Anderson and this
is Gayle Anderson and welcome to our
tutorial make your clients richer JavaFX
and the NetBeans platform now this is
our website and first thing we'll do is
we'll tell you a little bit about
ourself here okay who are we well we're
a training company first and foremost
here we do training courses for
government and private industry and we
specifically do training courses in
programming languages of course Java and
we do courses in beginning job as well
as advanced Java and advanced job Java
topics - we also have courses on Java EE
and web and we also teach Java FX we
also Gil and I've also spent some time
here at previous Java 1 conferences
doing hands-on labs which is a different
format than what we're going to do today
because this is actually a tutorial and
so that means that instead of us
preparing a lab that someone goes in on
a computer and goes through some steps
which is what we've done previously
we're going to kind of conduct this more
like what we do when we do training
courses and companies and that will be
we'll be teaching you some nice concepts
here for how to use Java FX and the
NetBeans platform together to design
rich client application and and then
we'll also pick some time to teach you a
little bit about how we did that and
then we'll have a big program that we'll
be going through a real program that you
can see and you can see how all this
works ok we're also Java authors Gale
and I have actually written seven books
and the last few books that we've
written have all been on Java and the
most recent one that we have written is
essential Java effects with so we've
been in a job effects early on in the
game here and we did that when the
JavaFX was a scripting language because
that's the way it was when it first came
out and of course Java FX has evolved
now into a set of api's that you can now
add to any java application which makes
it a lot more flexible and it means that
you can take your java applications and
even
your swing components and you can add
JavaFX effects to them and that's what
we're going to do today with the
NetBeans platform besides doing training
courses and books I've also got a live
lesson video that just came out this
year and if any of you guys are on
Safari and subscribers to that you can
find that I did it on Java reflection
and I noticed that by the way that the
last book on Java reflection was written
almost five years ago so I thought that
it would be good to bring everybody up
to speed on the latest parts of that API
as well and then what we're doing at the
end of this year and next year is we're
currently writing a book on the NetBeans
platform which we are going to be
publishing next year okay so let's get
started here's our agenda but before we
do that I'd like to ask everybody in the
audience how many people here are
currently using the NetBeans platform ok
excellent
all right good for you guys you know we
weren't sure how many folks we're going
to be here you know there's a
distinction now for you folks that
aren't using it there's a big
distinction between the IDE the NetBeans
IDE and the NetBeans platform API and
what we're going to be doing is we're
going to be showing you how to use Java
effects with the NetBeans platform API
and if you don't know about the NetBeans
platform then we'll tell you about it
today and we'll give you an overview and
we'll explain to you what's going on
with the code and if you do know the
NetBeans platform then you get to see
some new things with Java effects and
how you can use Java effects effectively
in a in an FP ins platform application
ok so the first thing we're going to do
oh and then I should ask you also how
many people here are using Java effects
or starting to learn it ok good you
should be doing that
you know there's a lot of effort on
Oracle's part right now to you know to
promote job effects and to show people
that you know it's a better alternative
to swing and we're not it you know it's
not about giving up your swing code it's
about you know working with these things
together and learning Java effects which
gives you a much richer client
application that you can do on the
desktop okay so that's great so what
here's our agenda the first thing we're
going to do is we're going to bring up
our application which is the smartphone
data application we call this the SDA
and this is something that deal and I
put together to demonstrate to people
how they could use the NetBeans platform
window
infrastructure to handle the window
operations that you want for a
sophisticated application and then
support that with both swing and Java
effects together
so you're going to see all three of
those working together in a real program
which we call the SDA and I'm going to
demo that in a couple minutes after we
do that we'll then go back to these
slides and we'll talk about the NetBeans
platform we'll give everybody an
overview of that that doesn't know about
it
and for those of you that do you know
this will be probably familiar to you
and then what we want to do which will
even be new for some of you NetBeans
platform folks is that we're going to
show you how to from scratch build a
NetBeans platform application and add
Java effects content to it so we'll do
that then after that I want to get into
Java FX integration and show you some of
the things that we implemented in the
SDA and so we'll talk about observable
lists properties and bindings we'll show
you how to use swing and Java effects
together will then talk about the
importance of F XML in job effects and
why you want to design with it and then
we'll talk about how to embed Java
effects in top components which is the
basic window of a NetBeans platform app
and then the SDA is you're going to see
here in a minute is going to make
extensive use of Java effects charts
okay really cool looking charts and
we'll show you how that's all integrated
and then we'll wrap things up here with
QA now and yeah and then get right
Gilda's reminded me to tell you
that there's a lot of you'll be able to
get the source code to the sta along
with some smaller demo examples that
we'll be showing you and all of this
will be available on our website this
afternoon which the websites on the on
the first slide there so you guys will
get all of the code and we'll bring that
all up this afternoon okay so we've got
you know this is going to be interesting
to do two hours here we'll see how
everybody does in an hour but you know
we might we might get up and stretch our
legs or something out or not we'll see
okay so let's go to the SDA that's what
Gail is going to bring up right now and
what we have here is a NetBeans platform
application where we have our our main
program coming up here which is the
sample table model and let me tell you a
little bit about what we did here we
went to the web and we found some
publicly accessible data that represents
sales as units sold in millions for
companies from 2008 to 2011 and so we
organized that into a table and then we
decided to use Java effects charts to
show people how to analyze that data so
let's have Gail click on the run icon
right now and run this project and we'll
show you what it looks like now the
first thing that you'll see when she
runs this is a custom splash screen
which is actually going to be there it
is one of the charts because you can do
custom splash screens very easily in in
in the NetBeans platform and this is
what our SDA looks like these are all
JavaFX charts that you're seeing in all
of these groups here and then down at
the bottom here this is a Java J table
swing component okay so we have swing
component J table down here in this
window and then we have JavaFX charts
everywhere else that you see here okay
all right so we'll begin by showing you
going through some of these charts right
here the charts of course allow you to
look at the data and view it and analyze
it in different ways so we've grouped
the the nine JavaFX
arts into these three groups that you
see here we'll start with the left group
so what you're seeing on the left here
first is a horizontal bar chart and then
if Gail clicks on the second tab you'll
see a pie chart in the middle group we
have several charts we have a vertical
bar chart we have a stacked bar chart we
have a bubble chart and we finally we
have a stacked area chart and in the
right group over to the right we have a
line chart a scatter chart and an area
chart okay now before we start
interacting with this application let's
show you guys what some of the window
operations that the NetBeans platform
provides because remember the NetBeans
platform is managing all of these
windows for us we're not we didn't have
to write any code to do that the
NetBeans platform is doing all these
windows and managing them for us okay
all right let's select the bubble chart
and what gail is going to do is
right-click on the tab there and select
float and what that does now is it
detaches the bubble chart from the
others
so gail can move it around she can
resize it she can maximize it and then
take it back to its original size we're
writing no code to do this that beans
platform's taking care of all of these
window operations that you're seeing
here now we can easily put it back into
the group by just docking it and all
these are windows all these are NetBeans
platform window operations that make
this very very easy to do as a developer
by the way you can also right click on
the bubble chart there and select float
and dock and you can do a whole group
too and move it around just the way the
way we showed you now in the SDA the
NetBeans platform also allows you to put
together a top-level menu bar so it's
Gail Scrolls through some of those there
you have complete control over some of
these things that you want to do
let's look at the window one right now
and what you can see now is a list of
all the charts so what you can do here
is select a specific chart and view its
window you can also close a
No and then reopen it again through the
file menu just by its name again all
being done here by the NetBeans platform
AP is up on the above the charts is a
toolbar too and of course we added the
one on the left there that's going to be
the save chart she'll talk about a
little bit later okay let's look at the
organization of this application now as
far as its project and files go okay
alright so Gale is going to bring back
the project here what you want to guys
want to look at now is what's on the
left and Gayle is going to expand that
node for you okay in the NetBeans
platform it's all about modules and the
smartphone data app has modules
representing each one of the nine JavaFX
charts you see a chart utilities module
a core module and there's the JavaFX
runtime which has to be part of this
project and then underneath that is the
smartphone data API module now getting a
little more detail in this the
smartphone data API module manages the
table data that's in the bottom window
that's the swing component the core
module is is the one that contains the
NetBeans platform top component and we
have a top component for each one of the
windows that you saw there and that's
displaying the swing J table and then
the chart utilities module is containing
the code to save charts to the file
system which I told you guys we talked
about a little bit later okay let's go
up and expand the bar chart now we'll go
back to will go up here gail is going to
expand the source code for the bar chart
and we'll look at the source files that
are there okay what you see is the top
component code
remember that's what's you know managing
the window for us for each one of the
charts a controller that you'll see
later on when we look at the code and a
very important F XML file for scene
graph layout and I'll have a lot more to
tell you all about that later when we
look and see how we can do our scene
graph layouts for our components using F
XML instead of creating a
components as objects and calling
setters and getters to configure them
and I think you'll like the approach
that we'll see there this organization
that we have here that you want to take
a look at is good because it keeps the
JavaFX and it's declarative code
separate from the NetBeans platform
window code makes it easier to manage
and easier to maintain the other reason
we've set it up this way was because it
helps you identify areas of your code
where thread safety is crucial and this
is important because it as you're going
to see in a little while swing and Java
effects are executing in different
threads so you have need to pay
attention to that we'll show you how
that works a little bit later on the
other chart modules are set up the same
way with similar naming conventions for
their top components and controller and
so forth okay let's interact with the
chart now show you what we can do with
it so we'll go back to the SDA here it
is okay we mentioned already that down
below in the bottom window here is a
swing J table okay and all entries in
this table are editable so Galle is
going to modify an entry in the table
right now and when she does that the
charts will all modify and change
they'll all update themselves okay you
notice that the pie chart the bar chart
and the line chart that you all see here
they all updated themselves
automatically but so did the rest of the
charts to either it's not visible right
now this is all being done with JavaFX
animation and it allows components to
update themselves automatically and
we'll show you how we did that a little
bit later on in this talk today the
other thing that I don't know if you
noticed or not but if gail takes the
mouse and moves it up there on the y
axis the y axis actually recalibrated
itself to when we when the bar rose by
the animation and once again you know
all of that is being taken care of by
these JavaFX components
we're just specifying the binding that
makes that happen and it all takes care
of itself
the other thing that's interesting is
that all the pie wedges move to even
though we only changed one value and if
you click if gail clicks on the reload
data button right now all the charts
the table go back to its original data
now let's show you some of the job
effects effects in the STA
so the first thing we'll do and gales
going to float this for you here so so
let's look at the pie chart first okay
okay now you might have noticed there's
a little drop-down list for you up there
so what first thing we'll do when Gale
gets this bigger so we can see yeah
there we go we're just making it bigger
yeah the resolution is is kind of weird
on this thing so we're just floating
these things for you again you know
notice how easy it is to do that in the
NetBeans platform
okay gales going to go up to the
ListView now and click on these years
remember we've got 2008 through 2012
year so the pie chart automatically
updates itself and and shows us you know
what what the percentages are for the
companies let's go to 2009 right now and
then show you another JavaFX feature
here gale is going to select a wedge
right now and what we do is we animate
that wedge by moving it with a
transition and at the same time it has a
drop shadow around it so you know if
you're talking to somebody about RAM or
Nokia or whatever you can emphasize the
fact that that's what you're talking
about and did you notice that there's a
percentage label up at the top there
that says that you know rims percent
value in that pie chart is 21 percent
now if Gail clicks anywhere else out
there in the background watch the label
it fades away and the drop shadow
disappears and we're going to show you
how we did all this this is all job
effects gives you a very nice-looking
user experience here and now now what
we'll do is we'll go to the bar chart
and show you some of the effects that we
did there okay so this is the bar chart
representing the same data now just in a
different way
so if gail clicks on one of the bars
what we do is we tell you what its value
is and notice that that's rotated there
and if gail clicks on a bar notice that
the number is showing up in white for
dark colored bars and darker
or here's another one this light and if
she goes back to a lighter bar like the
green one right one of the green one
right there
then it'll be black so you know we're
looking at what we have there to
customize that and to be able to to be
able to display it appropriately the
same thing is true with the horizontal
bar chart - you want to show that so
here's the horizontal bar chart and Gael
is going to make that float it and make
that one a little bit bigger - and the
same we have the same effects here too
right if you click on a bar a bar there
it's going to display the value only now
it's horizontal right now we did
something interesting with the bubble
chart so let's go look at that one here
it is
okay if you click on a bubble we make it
rotate and we also print out the unit
sales up at the top there and Gail can
click on another one too and these are
interesting Java effects transition
effects in fact the rotating bubble that
you're seeing right now is done with a
JavaFX
scale transition and if you go back to
the pie chart yes you'll have to move
over there if you go back to the pie
chart and move a wedge right there
that's being done with a JavaFX
translate transition and finally when
she clicks out there in the background
and the label fades out that's being
done with a Java effects fade transition
now the way we did all that was we
designed job FX custom binding objects
we're going to show you how we did that
a little bit later it star okay a couple
other things to show you and then we'll
get we'll get into this if you want to
save a chart to a file we put this into
the system you can select a chart and
then you can go up to the toolbar at the
top where the save is and if you click
on that you'll see a save file dialog
appear and which will allow you to save
the chart image to a file and you can do
the same thing by going up to the top
menu bar there and use the file tab to
do it as well and then the other thing
that we put in was the ability to print
charts to your printer so once again
Gail can go down and say right-click on
say the pie chart here and say that she
wants to print that so she can
right-click on that tab
oh there you go yeah
and then she can also go up here and
select print and notice that we capture
the image of the selected chart for you
to see and then you can click on print
and oh by the way this is one line of
code to do this in the top component so
that was cool we we were happy about
that okay so this finishes up our demo
we wanted to show this demo to you
initially because this will give us
something to work with and what we're
going to do now is we're going to take
you through a road map of all the things
we did to create a rich client
application like this and then we'll
break it up into its pieces and show you
what we did and along the way we're
going to do some simpler little demo
programs to get some basic concepts
across and then we'll go back into the
SDA look at the code and show you how we
did all of these things
okay so what we'll do next now is we
want to talk about the NetBeans platform
we want to give everybody an overview of
that and then after we do that we'll
talk about how we can construct a basic
application from scratch and add job
effects content to a top component all
right now for those of you that don't
haven't seen or heard of the NetBeans
platform before I mean almost everybody
knows about the NetBeans IDE which by
the way is written with the NetBeans
platform api's but the NetBeans platform
API is are a very very extensive set of
a system that's really we think worth
learning it's a swing based rich client
framework all written with swing
components where the UI components are
implemented with the swing toolkit and
then there's a runtime container that
gives you a minimal set of modules that
manage the modular architecture and the
plugins that the net beam that NetBeans
platform provides there's also a window
system very sophisticated with a window
manager you saw that when Gale was
moving the windows around after she
undocked them and we were able to resize
them and everything else and modules
that are make up the modular
architecture of the NetBeans platform is
a key concept here because the module is
really an encapsulated set of classes in
java packages and one of the big things
about the NetBeans platform are its
plugins okay which can a plug-in can be
consists of more than one module but
modules can be added at runtime and the
api's that come with NetBeans platform
an extensive set of those that are all
modules that you can use in your in your
system and the NetBeans platform also
provides a way to register and lookup
services and capabilities now why would
you want to use it well
I hope that our demo got your interest
on that because if someone didn't know
that we were using the NetBeans platform
they would think that we were pretty
impressive GUI programmers right I think
it goes without saying that you know the
NetBeans platform gives modular and
extendable has a very sophisticated
window manager we already mentioned an
extent
have set of api's but it has more than
that it has a service infrastructure and
the ability to hook into lifestyle
management so you can actually control a
lot of what happens when events occur in
the NetBeans platform and before the
platform does something you can do
something before that and after it and
these are life cycle type type things
that are very very granular and lets you
do a lot of of your custom work there
and I think that it goes without saying
that what the NetBeans platform does is
it reduces development time because you
don't have to worry about all the
plumbing that's required for the windows
operations that that people expect to
work when you're using a desktop app the
NetBeans platform is also
platform-independent
and don't forget there's a real active
community that's that's going on with
the NetBeans platform and that's a good
thing and oh and then Burton why
language do you want to stand up your
curtain so everybody can see you
yeah he didn't stand up very tall but
there he is yeah yeah Burton runs a blog
that he blogs daily on the NetBeans he's
the evangelist for the NetBeans platform
and and feel free to talk to Girton you
know after our talk or whatever to find
out more about how you can learn about
the NetBeans platform because there's
training courses and a lot of really
cool things that you can do to get up to
speed in it ok as far as the
architecture goes we mentioned the fact
that we have a very sophisticated
modular architecture here a collection
of related classes where one module can
expose its public interfaces and then
other one or more modules can set up
dependencies to these and we're going to
show you how that works when we go
through the wizards that come up and
you'll see that the whole design behind
the NetBeans platform is it's loosely
coupled and because of that it makes it
very easy to install and uninstall
plug-ins and configure the system at
runtime the distribution for the
NetBeans platform gives you all of these
things it's quite extensive I mean you
have everything from you know windows
systems and lookup and file system you
have api's for nodes
property sheets and explorer dialogues
actions UI utilities it's a lot to learn
but there's a lot there too and a lot of
it will really help you out in terms of
putting the other sophisticated
application with this platform ok the
runtime containers talk a little bit
more about that
the runtime container in the NetBeans
platform's job is to load modules
dynamically as they are needed and it
can have the ability to unload install
uninstall modules at run run time and it
also has bootstrap capabilities startup
modules file system api x' lookup and
utility api's so it's there to to help
you and it's going to take care of a lot
of the runtime issues that you don't
have to worry about and the NetBeans
platform also has a family of class
loaders that you can use the module
class loader will load most of the
classes that you need and then there's a
system one that will load resources
outside of the modules that you have in
your system and then the of course have
accessible to the the original the
default class loader which you can
always use to load resources out of your
class path let's talk a little bit more
about modules the concept of
dependencies is very very big in the
NetBeans platform this is a contract
between two modules where the first
module declares it explicitly exposes
its package and then another module sets
a dependency on that and says that I
need to access those packages to do
something to work in tandem with that
other module this is not unlike working
with interfaces in Java right where you
implement an interface you override a
method and then you're working you're
implementing a contract at that point
but very often the client that is using
that contract doesn't have any idea
what's going on behind the scenes
because it's decoupled another big
concept with an FBS platform is just
look up capability this allows you to
community set up communication between
modules and you have global lookup to
look up implementations directly and you
have an instance contact content to look
up
vacations when when needed one more time
here's a little diagram we put together
just to show you and we're going to
demonstrate this in a few minutes here
about how dependencies are set up in the
NetBeans platform once again this is a
contract between two modules so if
module B is going to depend on module a
then module a will declare its packages
public and you do that through a wizard
and then module B will set a dependency
on module a and you'll do that through a
wizard and there's no accidental
dependencies that happen here it's a
very clear arrangement where you set
that up and that enforces I know the
correct dependencies and again makes the
loose coupling which is what really
makes NetBeans platform so nice we
mentioned top components I was telling
you a little bit more detail about what
a top component is a top component
extends J component so that means it's
you know it's part of swing it's the
basic unit of display and it's
integrated into the Window System of the
NetBeans platform and you can configure
your top components to be Singleton's or
non Singleton's if you want to and of
course top components have built in code
that will allow you to dock and undock
minimize and maximize and even slide and
you can set it up so that you can open
up a top component at startup or not you
can have it persist so that if you if
you close an application your
application to bring it back up the
windows will persist across the clothes
and come back up into the state they
were in and there's a rich set of
annotations that you'll see with top
components that really let you configure
them any way you want okay
so we went over the overview now what I
think you'll find interesting the first
thing we want to do is we want to show
you actually how to build a NetBeans
platform application very simple one
from scratch ok and we're going to go
through these six steps right now we're
when we're all done we're going to have
a NetBeans platform application with a
with a top component that has JavaFX
content in it so what we're going to do
now is leave the notes
go back to NetBeans and we're going to
go through these six steps so first
danke
okay we're ready all right so we're you
know we're going to start from scratch
Gail's cleared out everything in
NetBeans and we're going to go through
these six steps now and show you how to
build a NetBeans platform application
with Java FX content okay step number
one will be to create a NetBeans
platform application so Gale we'll go up
to the file top menu here and select new
project and this will bring up a wizard
that you see where she'll select the
NetBeans modules and then select
NetBeans platform application and then
she'll name it and what it will name a
demo app right and the location is
already preset so she can click on
finish now what happens here is that we
have a skeletal NetBeans application now
with no modules but it's ready to to be
configured with more modules and that's
the the next thing that we're going to
do actually the next thing we want to do
though in step two is we want to add the
JavaFX runtime library because this
NetBeans application is going to require
that so here's the deal
applications that contain job effects
have to include a special jar file that
is in the jdk distribution and the name
of this is j fxrt jar so what we're
going to do is we're going to have to
add a this jar file to this NetBeans
application as what we call a wrap to
library now a wrap library is a library
that converts converted to a NetBeans
platform module so the jar file can be
integrated into the runtime container of
the NetBeans platform
okay so let's create this wrapped
library now with the Java effects
runtime so what gail is going to do is
right click on modules and then select
add new library this will bring up a
wizard and then Gale will browse well
you browse to your JDK distribution as
we're showing there and there it is
right there that's the JFX artie runtime
jar that has to be wrapped and added to
this project so we'll go ahead and do
that we'll select it and then we'll go
through
give it a name so you're going to call
this JavaFX runtime and then we'll
accept the rest of the defaults click
Next and then the last thing we have to
do is put in a code base name and gales
going to put in jf xrt same name as it
is for the jar file and now we can click
finish now when the wizard completes
what you'll see on the left over there
in the project view is is a new is a new
module under the modules folder and this
of course is it's called Java FX runtime
that's the name that Gael gave it so
let's right-click that and go down to
properties and select API versioning and
what you can see down here the Galle can
scroll through here is a list of public
packages and what we're going to do is
scroll down to the one that we created
yeah oh yeah we haven't we haven't done
that yet that's right so these packages
are available right so we'll just we'll
just tell you about that right now and
then we're going to create it and then
show you how to access that
ok so let's close this window and go to
step three okay now step three is to
create a new module and we'll do that
because this module is going to hold the
JavaFX content so on our demo app
application let's right click on modules
and select add new
and when NetBeans will bring up the new
module wizard so Galle is going to put
in a name and we're going to call it
demo module and the project location and
folder defaults are fine so we'll click
Next and again we have to specify a code
base name and a unique one so we'll put
in or demo demo module and we'll keep
the rest of the defaults and click
finish and now over in the project view
you'll now see two modules out there are
an application that correspond to what
we're building here all right now
remember we talked about how important
dependencies were when
have these public packages exposed so
step four now is going to be to add a
module dependency and we'll do that in
the following way
so we'll expand the demo module project
and right click on libraries and select
add module dependency okay
and here you see a dialog that contains
all the modules in this application now
we can scroll down and find the there it
is the JavaFX runtime that's the module
that we created so we'll make this
accessible right and when we click OK if
we expand the libraries node now over in
the project view you'll see the JavaFX
runtime module appear and there it is ok
step 5 there are only six steps here
right we're on step 5 now the next thing
we need to do is create a window and
this is called a top component so let's
add a window to our application now and
we'll go to demo module and under source
packages we'll select row right-click
select new and then window there we go
and now we're in the new window wizard
and here you get to specify how you want
to configure your window so the first
thing that we'll do is we'll click on
the window position and make it editor
which is going to basically put it in
the middle and then there's a whole list
of checkboxes here that you can select
that will configure your window and
we'll go we'll just click the first one
open on application start and what this
does is it generates as you'll see in a
minute a bunch of annotations that then
we'll configure the window and install
it into the system the remaining options
there were just limiting the windows
behavior and we'll leave all those
unselected ok so now we just have to put
in a class name prefix so Galle is going
to type in demo and this will appear in
the names of all of our Java class files
so you'll see the word demo prepended
there and now we're ready to click
finish and bingo we have a top component
notice it shows up in
the design view on the right there's the
name demo top component there and if we
compiled and ran this right now would be
very interesting would be a blank window
so what we want to do now that's going
to be interesting is we're going to put
Java effects content in here because and
we can do that because we have the the
wrapped library there that we can use so
that'll be the the sixth step now is to
add Java effects content yeah I will
okay so let's click let's let's click on
the source button now and take a look at
what we have remember NetBeans generated
this top component for us so one of the
things that you see here are annotations
down below that correspond to the
choices that we made when we went
through the wizard and part of what you
see in there was editor in line 23 right
there that's the one we've specified
with the checkbox open it starred up
equals true and this is all generated
for you by the net now by the NetBeans
platform wizards but it these
annotations will configure the window
and then you can do what you want with
it okay now down in line 36 is the
constructor for the demo top component
and right now it's not going to do
anything except set a tooltip so what
we're going to do is replace this now
with some Java effects code so Gale has
a window open at this point she's going
to go to now and this is some Java
effects code so what we're going to do
is we're going to copy this and paste it
into our constructor code here she's
doing that now so here it comes and
we're going to get red lines right
because these these classes and things
are not I haven't been imported so let's
fix that first let's say I'll
right-click and say fix imports and we
have to be a little bit careful here
because and when you do this in the
NetBeans platform you're using Java
effects don't just click OK take a close
look and make sure that you're getting
all the correct imports as scale Scrolls
down here you'll see that when she gets
to the rectangle that's not the right
one
we don't want the AWT rectangle if she
clicks on the arrow there you'll see
that the one we want is the the one in
the JavaFX scene there so that's the
right one we want and now we can click
on the okay the rest of them are fine
and now all the red lines will go away
now don't worry about this JavaFX code
right now basically all we're doing here
as you can see is in create scene is
we're creating a stack pane we create a
drop shadow effect we then we create a
rectangle and then down below we set up
a text component and we just put in a
little hello greeting message there
hello from Java FX and then the rest of
this code is going to set it all up but
notice that this Java FX code is inside
of the top component and it's inside the
NetBeans platform application ok let's
go ahead and build this and we'll have
there's a splash screen and there it is
so we have a top component now and same
thing Gale can maximize it move it
around float it that's what top
components do right and everything
rescales itself appropriately and it's
not too exciting but you know this is a
very simple little hello message in Java
effects with a little drop shadow and so
forth but what we did here was we showed
you guys how to go through these six
steps to create a NetBeans platform
application with Java effects content ok
gales going to leave
let's see gales going to go back to the
slides now so we'll give her a time to
do that
and we'll move on to the next subject in
the agenda so next slide okay so we are
ready to move now to the next subject
which is Java effects integration and so
we want to do now is we want to go
through and teach you guys a little bit
about what properties and bindings and
so forth so you can see and learn a
little bit about how you do these things
in Java effects and then once you learn
that will go into the SDA and we'll see
how we did some of these things that you
saw in the demo so let's start with
observable lists this is a very cool
thing in job effects the ability to use
the observable list interface so that
you can you you can use part of the
collections from from Java effects there
are special collections that that manage
observable lists and what these things
do is they add notifications for
registered listeners so if you guys have
ever done pub/sub type things or maybe
you implement an interface and override
methods to to do notifications and
registered listeners you don't have to
do any of that
JavaFX has this all built in to the
observable list so when you do these
things and you use properties you have
less code to write and yet you know
pub/sub type things are being
implemented for you now the reason why
you want to use observable lists from
java effects is because it makes it
really easy to synchronize your UI list
controls with list data and to
synchronize the model with with your UI
components themselves and it hides all
of the registering and listeners and
event note occation event notifications
that you normally have to do hides all
that so that's that's a good thing now a
fundamental concept behind what we're
what we're doing in the SDA which is
binding is to use what's called JavaFX
properties and JavaFX properties are
very very similar to javabean components
except that they're observable okay
which means that you know there's
registered listeners and event handlers
that you can attach
automatically and the reason why you
want to use properties is because they
encapsulate data with invent delivery
and they can be used with binding
expressions and all the Java effects
controls provide properties for you that
you can use I always tell people that
Java FX properties are like Java
properties on steroids because you know
instead of having a Java field and then
having setters and getters that will
configure an object that is that it's
referenced by that field you can use
Java FX properties and have all of that
wha done for you
now binding is really the secret behind
why how we are doing all those fancy
things in the STA
so let's talk a little bit about that
now what's binding binding lets you take
properties and have them participate in
dependencies with other property values
and the reason why we want to do that is
because it's a natural fit for UI
controls that we can now synchronize
with their model data so for doing MVC
it's a lot of you know about in terms of
doing GUI designs we have a model and we
have the view and a big part of what we
have to do in swing is we have to make
sure that these things are synchronized
and what we can do in Java effects is
going to use binding mechanisms to have
that done for us
so what binding gives you in Java
effects is the ability to avoid writing
event handlers and listeners it's a lot
more concise and it's less error-prone
so bottom line is you want to use
binding because it'll simplify your life
and it will make your development tasks
a lot easier ok so let's learn since
this is a tutorial now we're going to
teach you a little bit about the binding
strategies that are available to you in
Java FEX and here they are you have four
choices that that you can do and we're
going to demonstrate these for you now
simple bind bi-directional bind affluent
API a library of api's that you can use
and then of course custom binding which
is what you would do if none of the
other if you can't use a fluent API or
do anything in a simple way the concepts
are that simple binding is
a updating a property when it when a
property that's dependent on that
changes and this is a one way change
update you know so it's just one way but
if you need to have it in both
directions you can have set up a
bi-directional binding and that would be
a two way change update and we'll have
some examples of these coming up when
you see them in a few minutes you can
also bind properties to compute values
using built in binding expressions and
this is called the fluent API in Java
FEX and we'll show you some examples of
that coming up and then when you just
have to have it your own way because
there's no another way to do it you can
specify your own custom binder and then
you have a lot of power here you can
specify property dependencies and
arrange to have callbacks to a compute
method where you can do whatever you
have to do okay so lets show you some
examples of these binding strategies now
and here's our approach we're going to
take a small different program now a
simple one or we can teach you these
different binding strategies and then
after you learn those we'll then go into
the SDA and show you how we were doing
them because I think it'll be easier for
you a lot of you to see that when we do
that
okay so Galle is going to bring up a
different program now remember this
program will be available in the
download so you can get this program too
and this is just a plain Java effects
project this is not a NetBeans platform
this is one that we wrote to show you
some of the binding strategies so gills
expanded the source code now and then
what we'll do is we'll go ahead and run
this and we'll show you what it is
remember this is not a NetBeans platform
application now this is just a
standalone java FX program okay here it
is this little program is designed to
teach you how binding how the binding
strategies work in in Java effects at
the top we have a couple sliders the one
on the left is an adjusting a fill color
where you have a label for a color
underneath it cadet blue of course is
what you're seeing right now the right
slider is adjusting the size and we have
a number that appears there with one
digit to the right of the decimal point
and then down below which is where we're
going to start we have a button on the
left
text field in the middle and a label on
the right and right now what gales going
to do is she's going to go in and type
in a different word here and notice that
she types in Turtles the label is
updating automatically as soon as she
hits a key this is all being done with
binding so we're going to teach you that
first and then when Gale clicks on the
reset word button both the label and the
text field is going to be updated
automatically again that's going to be
doing binding as well okay so let's go
see let's let's not do the sliders right
now let's just go down actually I think
we do yeah I think we will show you this
slider right here and what does this do
when Gale moves the slider you'll see
the colors change in both the rectangle
on the circle down below and did you
notice that the labels changing as well
see how it's going from corn silk here
to crimson and cyan so this is all being
done with binding so as Gale moves the
slider both the cuff the fill color
that's being used to fill in the colors
for the shapes the circle on the
rectangle is happening as well as of a
knit the label that's being shown there
okay Ellie let me show you how easy this
is if you haven't seen these binding
things yet in Java effects because it
works out pretty well yeah so let's go
back to the slides and we'll show you
how this works and I think this will be
easier to see on the slides rather than
go into code because some of you folks
in the back might not be able to see it
as well okay let's start with you need
directional binding that's the first
finding strategy in Java effects and
what we're going to do is we're going to
work with a the label that you saw you
know that how the dolphin's word on it
and what we're going to do here is we're
going to bind the label text property to
a string property not a string but a
string property and a string property is
a is a servable JavaFX type that holds a
string but it's observable okay so here
we go string property word equals new
string property dolphins okay
just like creating a string in Java
except for using a string property
instead here it is one line of code word
labeled dot text property dot bind word
now and that will make it so that when
Gaeltacht types in something well what
happens is when the string property word
changes the word labels text property
automatically updates so think about
this as setters and getters being done
for you behind the scenes by somebody
else and event listeners right because
there's event listeners that are going
on here as well let's look at the other
example where we have the color fill
happening with the circle and the
rectangle in one line of code here we're
saying that let's bind the circle fill
property to the rectangle fill property
and what this means is is that when the
rectangle fill property changes the
circles fill property will update all
right this is a unidirectional load
notation now right so it just goes in
one direction but this explains both of
the things that we just showed you here
so that you know these things will
change automatically for you really in
one line of code now the other
interesting thing about unidirectional
binding is it's not possible for you to
assign to any bound properties yourself
for example you cannot assign a value
directly to a word labels text property
or a circles fill property okay because
it has to go through the binding
mechanism to update that let's look at
bi-directional binding now
bi-directional binding looks like this
I'm going to repeat the same two lines
that we had before string property
equals new string property dolphins word
label text property bind word and we
already saw that and what happens once
again here is that when word changes
word label updates what we can do now is
a bi-directional bind between the text
field
that's what Gail was typing into and the
word itself which is the same word that
you see up above this is going to be in
both directions now for the binding okay
so when gail typed in the word
Myrtle's right with bi-directional
binding when the text field input
changed as she type things in the string
property word updated right that's what
this says
but because the word updated then this
binder kicks in and that will change the
label as well if you have two things
going on here all with just the simple
code where the labels are being updated
as the text field is being changed now
that was in the direction of typing in
something in the text field remember and
recall that gayle clicked on the reset
button when Cale clicked on the reset
button we updated the string property
word so when we updated the word then
the text field input will change so you
saw the text field input go back to
dolphins and then because of the word
changed once again the word label will
also update all of this is happening as
you saw it with us writing just these
simple lines of code and this is what
the power of Java effects binding and
there's a lot of stuff going on behind
the scenes here right but we don't have
to be writing a lot of that code and
that's the whole point so yeah so so
what we'll do now is we'll go back to
the program and before we get into the
other bindings we want to show you the
other slider that we have so Galle is
going to bring back the not that one
right now you want to bring back the
binding demo one yeah there we go okay
so you know once again we we use this
example down here and the left scroller
up above to demonstrate uni-directional
binding and bi-directional binding now
to show you the other binding strategies
let's work with the other slider
now when gale moves this slider two
things are going on three things
actually right
the rectangle and the circle are
expanding and contracting and you can
see the number changing automatically as
well and this is all being done by
binding with just a few lines of code
okay so let's go show you how we do that
so we'll go back to the slides
okay here is the code in Java effects
that binds the rectangle height let's
just talk about the rectangle now same
thing for the circle right but you could
see that as Gael moved the slider
you know the rectangle enlarged and then
got smaller right find the rectangle
height property to the slider value
times 4 and what we did was we threw the
x 4 in there is a scaling factor right
so we just you know grow bigger and so
it would be really small we could make
it grow bigger like that well it turns
out that we can use the fluent API in
Java FX for this because there's a
multiply method that you can call to
multiply the value of a property with
some other expression that you have so
basically what this says right here this
one line of code that you see right here
is specifying that when the value
property of the size slider changes will
update the rectangles height property
with the sliders value times 4 using the
fluent API method called multiply okay
and that's where the multiply comes in
over there and of course if you look
this up in the API reference guide
you'll see multiply add subtract divide
so anytime you need to do any kinds of
scaling things with properties that
you're updating like this you can use
the fluent API and it's very convenient
once again one line of code there to
bind the slider value to changing the
height property of the rectangle and
then of course it's rendered and
everything for you the other thing that
you saw was that the label was changing
as well so and Gale moved the slider not
only was the rectangle getting bigger
and bigger right but the label was also
changing as well so this is another
example of a fluent API this one line of
code right here takes the size binds the
label text property to the slider value
and formats it did you notice that you
said one digit to the right of the
decimal point there so specifically what
this bind statement does is it when the
value property of the
slider changes will update the labels
text property by converting the sliders
value to a formatted string that would
be one digit to the right of the decimal
point and to do that we'll call the
fluent API method as string and we'll
give it a formatting you know dot 1f
right there so that that label will be
showing up with a number and one digit
to the right of the decimal point
again one line of code to render and
change that label as the slider is
moving okay now the only one left is the
custom one and this is the one that
we're using in that program to modify
the color names that you see because
when gale move the slider the color
slider you saw the color names come up
corn blue corn silk right to do that we
wrote a custom binder and this is the
fourth strategy that you have in Java
fix binding and you use this because you
know the fluent API is quite extensive
right but it can't do everything for you
and very often you'll have objects that
have to change and you'll have to do
that yourself so let's show you how to
build and create a custom binding object
and we'll call this custom binding
object color name binding okay and the
idea with our bind down here is the same
idea right bind the label text property
to color name binding and that means
that when the color name binding object
changes the color labels text property
will update the same exact concept as
before except that what we're binding to
in the argument here is a custom binding
object so what is this custom binding
object color name binding is something
we made up it's not in a Java FX API so
let's go see here it is color name
binding and the first thing that you
notice is that it's type is string
binding and string binding is a Java FX
type where the color name binding object
must be a string binding type because
what a string binding
does is it gives you in this when you
and you implement it this way is it
gives you the ability to return back a
string type where it's needed so this is
how your custom binder works when you
can't use the fluent API s or any of the
others what you do is you new your
string binding object and you give it
the name color name binding and then in
the constructor you call super bind to
provide the dependency and in this
example what we're doing is we're saying
that when the value property of the
color slider changes then this compute
value method will be called so what we
do is you override this method and that
will be a callback now so when once
again when the value property changes in
the color slider when Gil is moving it
we will have this routine this method
right here being called and then we can
do anything in here right okay so what
we're doing here is you know we have an
array we won't show you the code but we
have an array of color names in there
right that's what color names is it's an
array so you see the square brackets
right here so all we have to do is go
out to the color sliders value property
and get its value convert it to an
integer index into the array and return
back a string and so that is what you
saw with this custom binder when Gail
was moving the slider and you saw the
label change with the color name okay so
those are the four binding strategies
the JavaFX gives you we used a very
simple program here to demonstrate those
so the next thing we're going to do now
is go into the STA right you know the
big program we showed you here and we're
going to go into the pie chart
controller code first and now when you
see some of these binding expressions on
they won't look Greek to you you know
you can see them you know look familiar
to you because we went through some of
these binding strategies okay
so gail is going to go into the pie
chart controller code now and there we
go and make it a little bit bigger so
let's scroll down to about line 90 here
and again what a lot of you probably
want to do is study this code
get a chance right and so I'm going to
point out some things to you and we're
not going to have time to go through all
of things here but in line 91 there is
an example of a custom binder where the
chart title changes when the title the
title property of the chart changes when
you change the chart of the title so
this chart title that you see there
inside the bind is a custom binding
object so if gale Scrolls up here a
little bit you will see what we just
talked about in fact it's string binding
right so in the constructor for the
custom the custom binding object we call
super bind to get a column the year that
would be you know when Gale select
something from the you know for the year
on the in the pie chart and then because
that's bound to the chart property
compute value will be called and then
what we do is we go out and we get the
title we get the title from and the year
from from the table and then we create a
string and return it back and that's
what you see and she's going to show you
that right now she this is the title she
there's the title so when she selects
2008 it updates
she and that's that custom binding opps
yeah that's exactly what it's doing
right there okay
okay let's go down scroll down to line
about two twelve I think it is and we'll
show you another one again you can look
at these on your own there we go
remember when the percent label changes
when when you select a wedge right so
what we do here in line to 12 is we are
binding the labels text property to a
custom object called percent binding so
let's go up to the percent binding there
it is in line 188 looks like and what's
interesting in here is that you can call
super bind more than once this is
interesting right look at line 188 we
have a for loop there where we're going
through and binding you know all of the
wedges setting up binding dependencies
on each one of the pie wedges so we
actually have a for loop there in the
constructor that's successfully calling
super dot bind for each one of the pie
wedges it's an interesting technique
that means that if any of the pie wedges
change because of the bind then the
compute value will be called and then
what we do in the compute values of
course is we calculate the percentage
for for that that wedge and then we can
display that as you see up in the in the
label again a good example of custom
custom binding objects now in the pie
chart now we could also go into the bar
chart controller and we could do that
but for time purposes we're going to
move on here and what we're doing in
there was we made up custom binding
objects that rotates the labels position
remember when the you know that came up
in the in the bar there and so we have
custom binding objects to take care of
all that too okay so let's go back to
the notes and move on to the next
subject swing and Java effects how do
you make them work together what's the
plan and what do you need to know and
there's some interesting things to talk
about here so let's do that
again we're going to be talking about
this now in in the NetBeans platform
application okay that what makes this
all work so nicely is a very nice swing
component called jfx panel we call this
the magic of jfx panel this is the
package that it lives in and it allows
you to embed JavaFX content into a swing
app so once again you know job effects
is not all about giving up your swing
code it's about making you know keeping
your swing components there but adding
JavaFX effects the interesting thing
about jfx panel is as soon as you knew
it as soon as you create an instance of
it it'll start up the JavaFX runtime
which as we're going to discover isn't
as a thread that you need to know about
so it starts up as soon as you create an
instance of jfx panel and then any input
or focus events are forwarded
automatically to the scene graph so you
don't have to worry about those being
intercepted by swing here's an example
where you create a swing jframe call it
my app then create a jfx panel okay as
soon as you do this now the JavaFX
applications thread starts up and then
all you have to do is what you normally
do in swing is add the JFX panel to the
frame and you're ready to go now you
know there's more to do that with this
with top components but you get the idea
it's all it's all very simple and that's
the way it should be all right now let's
talk about some of the thread issues
because this is important and we
certainly learned a lot when we wrote
this program swing components as you
guys all know are all created and
updated on the EDT the event dispatch
thread and that's well known to swing
developers who work with gooeys and
probably all of you know about that
here's the interesting thing when you
work in Java effects components there is
a separate thread separate from the EDT
and it's called the Java FX application
thread and you need to you know go
through you need to be aware of the fact
that there is a separate thread with
Java effects when you have these two
working together
and we're going to show you the
scenarios typical scenarios now that you
could use to have that happen so here
they are there's three of them you're
probably more scenarios than these but
these are the three that we'll talk
about and they are the following the
first scenario
JavaFX event updates swing component
that happens when you need to update a
swing component because an event has
happened with Java effects the second
scenario is the opposite okay swing
event updates something in the Java
effects scene graph this is because
something you know something happened in
swing and we need to update something in
Java effects and the third scenario is a
very advanced one where you have to
specify synchronization and basically
this is a special case of the second
scenario where timing is involved and
here you have to wait wait for changes
in the Java effects scene graph to
complete and we actually ran into this
with when we are implementing saving the
file charts we actually had some timing
involved between the two threads and
we're going to show you what we did here
to solve that okay so let's learn how
each one of these three scenarios would
work okay and this one is the simplest
one because a lot of you are familiar
with this right this is the basic idea
behind updating swing data in with the
EDT and this is what you would do if a
change in JavaFX data required you to
update something on the swing side so
what you do here is that you wrap your
code and a runnable object you call
swing utilities dot invoke later and
then you override a run method and
inside the run method that's where you
would change your swing data and that
would ensure that that would be done on
the EDT and a lot of you are familiar
with that because the swing utilities
dot invoke later is well known to swing
developers all right now here's the new
one this is the the JavaFX thread okay
this is the opposite of what we just
said a change in swing data ok requires
you to update
JavaFX
data isn't this exactly what we're doing
in the SD a what happened when Gayle
went down to the table the swing J table
and updated an entry we didn't we have
to update the JavaFX charts this is this
scenario right here by the way the first
scenario we don't use in the SD a but
this one we use with all of the charts
right so notice that this is platform
dot run later it's the same exact
concept that we have with with the swing
thread except that this is the java
application thread platform dot run
later it's the same approach you knew a
runnable override run and you change the
JavaFX data so if you go into our code
where you see the updates being done for
the charts when a table entry changes in
swing this is what this is what you'll
see and in fact we're going to show you
that right now
okay so we're in the pie chart right
yeah we're in the back in the pie chart
because that's the one of the simpler
ones to look at here oh yeah yep okay so
there we go down in line 120 it's
actually started line 110 there's the
table changed this is what happens when
Gayle made a change in the J table of
Swing J table this was a callback to
this routine here table changed and so
after we go and we gather the data that
we need from the table we then down in
line 120 have to update the pie chart so
there's the call to platform dot run
later and we've got a comment in there
dan JavaFX application thread update the
scene graph and Java effects and there
is the set pie value which is going to
change the pie chart that is being done
inside of the application the java
application thread
and I think well I think we'll skip over
the bar chart they're the same the same
thing would happen in the bar chart as
well and you can look that up on your
own when you need to all right now this
one was was a tough one right this was
the special case of the last scenario
where we have to synchronize where the
JavaFX thread what happened to us here
was you can see that this method is
getting an image called buffered image
remember when we demoed the fact that we
could save a chart and we have to go out
and get that chart this is the method
that's being called to do that what's
interesting though is is that we have to
do this we have to go through the
controller and call get image in the
java application thread that requires
that you call platform dot run later to
do that but here's the deal the platform
got run later returns immediately so
there's a timing issue because we can't
just return the image on the swing side
we have to wait for the JavaFX
application thread to complete before we
can return the image so what we're doing
here and I won't go into all the details
but we're using the Java concurrency API
a countdown latch so what we do is we
set a countdown latch to one and then we
we go and we we go to get the Gammage
out in the java application thread and
down here if this code gets there before
this completes you see the latch dot
await that will suspend at that point
and we will wait until the java
application thread is finished and the
great thing about the countdown latch is
you just count it down and a finally
block and then that will make us return
from the wait and then we know that the
java application thread finished and
then we can return the image back
so there are thread issues that you have
to work with when you're doing bindings
and in working you know with job effects
and swing together but we have organized
these into some scenarios that are
fairly easy to have to follow okay let's
go back to we're back in the notes here
and we're ready to move on to the next
subject using F XML so we want to show
you guys some things about that too
so let's do
now I don't know how much you know about
FX ml but this is an XML language that's
used to describe you is what we're
trying to get away from here with job
effects is kind of the old way of doing
things which was that you create a
component with new and then you use
setters and getters to configure it and
that's all fine and dandy when you build
a GUI but eventually you know there's
going to be changes that have to be made
and that means that you have to go into
the Java code and you have to find it
and change it and recompile the idea
behind FX ml is that you take what's
called a declarative approach to your
GUI designs by using xml to specify your
layout and then you separate the layout
of your UI from the java code that
controls it ok so this is a classical
MVC design approach where we can use
annotations for the UI elements which
you'll see in a minute when we look at
the code and then you can use CSS to
style you know your components which is
also separate from the Java code and you
can use F XML and CSS together or you
can use F XML without CSS or vice-versa
you can use CSS without F XML but you
know you want to use this because it
reduces the Java code it separates the
presentation view from the business
logic and it's a lot easier to visualize
the scene graph structure you know
declaratively than it is to go and wade
through java code the other thing that i
want to tell you guys about is that
there's also a new tool relatively new
tool that's come out and Java FX called
scene builder and this allows you to do
drag and drop
so that you can build your gooeys very
quickly with palettes and you can drag
and drop components and the interesting
thing about the scene builder is it
generates F XML so it would be good for
you to to learn about that when you can
okay let's bring up the pie chart again
once again here and we're going to look
at two files here
the pie chart F XML file first and then
we'll look at the Java controller code
that works with it so let's bring up the
FX ml code first there it is
yeah get rid of that there you go there
we go okay now we don't have much going
on here right I mean it's it's pretty
simple we have a stack pane and inside
of a stack pane we have a pie chart we
have a ListView write the drop down for
the years and then we have a label
however you know with this kind of
declarative layout you could very easily
put together more complicated UIs
and we don't have a complicated UI here
but this is what we'll what we have now
the things to notice in here our
configuration is done by simple
assignment statements max height equals
60 math max width equals 60
you know we're configuring the ListView
component here we're configuring the
label down below with a font size making
it bold these are all styles that we do
here the other thing that you want to
look at is that in the tags for like pie
chart you see an ID their ID equals
chart and then we have one for the label
and we have one for the ListView these
correspond to the fields in the Java
class that is the object that's
controlling that and the other thing you
want to notice in line 14 is the FX
controller tag with that says that the
Java code that works with this XML file
is called pie chart controller so let's
have Gail go to that right now and then
you'll see how that works with this F
XML file and we need to go to the top
here there we are okay now the first
thing you notice is that when you build
a controller that's going to work with F
XML you need to implement the
initializer belen tur face okay and then
that will force you to override the
initialize method down there in line 65
and then of course what you'll want to
do is is create your component at that
point we're going to call create pie
chart and what you notice now up above
that are the F XML annotations and
what's happening is those annotations
are causing the F XML file to be read
and then Java reflection is creating the
objects for you and can
figuring them all you have to do is
annotate those in your java code and the
actual configuration of this components
is not in this java code see it's
separated so obviously you know this is
a good thing because your java code is
not littered with a lot of configuration
stuff for your components and this is
how they how they work together ok so
the next subject that we want to look at
in our agenda is setting up Java FX in
top components again top components of
course in an NetBeans platform app so
let's take a look at that
ok now you remember that we did this a
little bit earlier we talked about jfx
panel the magic of jfx panel that's the
starting point for using jfx with swing
so when you create a jfx panel object
you have a handle to something that you
can use and also it starts the JavaFX
application thread as we talked about
and what you can do with a with an fx
panel is you can add it to your window
and you could specify a border layout
you can do all the things that you can
do in Java swing and then of course when
you want to create the scene you will
want to always do that in the java
application thread so that's where the
platform got run later shows up and
you've already seen this right but
there's something else in here that's
very important and that would be what's
in the middle platform dot set implicit
exit false this turned out to be very
important when we were developing the
STA
because of the following reason this
call is important because what it does
when you call it and you set its
argument to false is it keeps the JavaFX
runtime alive when the last window with
JavaFX content is closed so what we
noticed that before we learned about
this was when we didn't do this when we
closed some of the job a window that had
JavaFX content in it and we tried to
reopen it it came up
we don't know what's going on so we
research this out and and found this so
it's pretty important so once again you
know you want to have this set up
somewhere in your code when you're using
Java effects and swing together because
then when you close a top component or
when you close a window that has JavaFX
content in it and you want to bring it
back it will keep the JavaFX application
thread alive for you okay let's look at
create scene now on the next slide and
this is just some stuff that's out of
the SD a to show you how to load the F
XML file as a resource it also shows you
a little bit about how the F XML loader
works how it sets the location and set
the route and then set the scene with
the route and then here is getting an
access to the controller and remember we
talked about the PI controller because
the PI control pie chart controller
works with the pie chart dot F XML file
with the annotations and this just gives
you some code that you'll see in the STA
that sets that all up okay so now we're
ready to talk about JavaFX charts so
that's the next thing that will that
will do here and we're you know we've
got a lot of stuff to show you here so
let's go through some of these things
and see what we can tell you about and
once again since this is a tutorial you
know we're going to go ahead and show
you how we did some of these charts in
the SDA and we'll also learn about using
the charts in Java FX as well okay so to
start with there's a hierarchy in Java
FX that looks like this and we could
have you know drawn it as a tree but
there's an abstract class called chart
at the top and underneath it you can
have a pie chart or a family of what we
call XY charts okay and the pie chart of
course is separate because it doesn't
deal with XY concepts but all of the
other charts that you saw that we're
running in separate windows in our SDA
application are all what we call XY
charts and that would be the bar chart
stacked bar chart area
chart and everything that you see here
okay so let's talk about the pie chart
well let's talk about JavaFX charts in
general first okay and give you some
general ideas about what you can do with
them here first of all all of the charts
use observable lists okay so that means
that you know you can use binding and
and and then properties everything that
we showed you earlier in this talk that
also means that you have event handlers
for special effects and you saw some of
those special effects that we did drop
shadows and animations and things like
that now XY charts have a concept of the
data being ordered in a series okay in
fact XY chart series is something that
you would use on your XY axes for these
charts so on the STA remember we had
four years right between 2008 and 2012
and then we had six series in each year
representing the six companies that you
saw in the data the chart data itself is
XY chart data for the XY charts and pie
chart data for pie charts XY chart data
holds the data for an individual data
point in a in an XY chart and pie chart
data holds the data for o pie wedge okay
and remember that observable list will
let charts respond easily to changes in
the data and redraw their nodes as
required okay now when you work with
charts you'll have to work with category
axis and number access and category axis
is what you use that renders labels as
strings and number axis will render data
as numbers some XY charts require a
category axis for one axis and a number
axis for the other so we've got that
listed for you when when we look at some
of the individual charts later on other
XY charts require number axis for both X
and y axis so you'll have to you know
refer to some of the API reference
guides too
figure that out and of course there are
some books out there and JavaFX that
tell you this stuff too now to make your
charts look nice you're going to want to
configure some settings so notice that
there's api's to manipulate the label of
the axis its position lower bound upper
bound and even down to a granular level
where you can do tick marks tick units
specify gaps and custom for matters so
there's quite a bit that you can do here
and you can make some of these charts
look really nice when you do this
remember that the visual effects are all
there with drop shadows you can
manipulate the opacity and so forth and
it applies to all the charts alright
start with a pie chart and give you a
little more detail about how you would
create one and once again what we're
going to do here is a little tutorial
right we're going to show you how to
create a very simple pie chart not in a
NetBeans application but just in a
standalone JavaFX program and then after
we do that we'll go into the SDA and
then you can recognize what we did in
there in a more complicated program
first of all why is a pie chart useful
well it's because it's all about pie
slices with colors right but the big
deal about pie charts as you know is
they're showing percentages of a whole
okay and so you can analyze data instead
of looking at a bunch of numbers in a
table you can look at percentages and
you can learn more about who's a bigger
part of the pie or who's a smaller part
of the pie and of course the pie slices
are proportional to the data values and
what the pie chart does is it calculates
those percentages for you so you don't
have to do that all right now when you
work with pie charts in JavaFX um you'll
work with pie chart data which stores
the name of your spice of your slice and
its associated value and when a pie
chart is rendered its rendered clockwise
by default
specifically it starts rendering drawing
at zero degrees which is three o'clock
on the clock and then each successive
slice is drawn in a clockwise direction
however if you don't that's the default
right I mean if you want to draw them in
a totally different way counterclockwise
or start in
you know in a random way or anything
like that there are api's that will
allow you to configure both the starting
position and the drawing direction in
the SDA the company name and is the is
the name in the pie chart and the value
is the number of units sold in that year
for that company okay let's give you a
little example right now we're not going
to actually run this example because
it's very simple it shows you how to set
up a pie chart and at the end of these
of this code will give you a screenshot
to show you what it looks like again
this is not a NetBeans platform
application this is a very simple
standalone JavaFX program it just
teaches you how to build a pie chart
okay first thing you want to do is
create an observable list we'll call it
PI data notice it's generic so inside
the arrows we'll put in pie chart data
because that's what the type would be
again observable list can be used with
other types of XY charts because it's
generic and then we'll just create an
observable ArrayList that's empty and
obviously the next thing that we want to
do is add pie chart data and we can do
that in the following way and what Gil
and I did was since the Olympics just
happened right this summer
we just took some metal counts for these
four countries the US China Russia and
UK and we just made a pie chart about it
and we have more than that right but
these are the ones that will show you in
the slide here okay all right so all you
have to do is create a pie chart data
element here's the label and the value
the label is a string and the value is a
number because that's required by a pie
chart and you create the data and then
add it to the PI data observable list so
here are the first four and there's a
few more but that's all you have to see
there okay this is easy you have to
create a pie chart element so we'll just
create it with the constructor and then
we'll populate it with the observable
ArrayList called pie data so now it's
populated with all the pie chart data
and then to set the title we just call a
setter with our pie chart object and we
put in a string that says these are the
Olympic medals that were
in London of this year and when you
compile and run this program this is
what it looks like you see the legend
down below where we actually you know we
actually have seven countries right from
well the US through Japan and then we
have an others category and all of that
is done for you by the job by the pie
chart you know it draws a legend for you
and specifies the colors but you can you
know you can specify what colors you
want to you can see that US starts at
three o'clock right and then it's going
to be rendered counterclockwise just
like we said and there's the title at
the top Olympic medals London 2012
so this pie chart has seven seven wedges
okay so now that you've seen how a pie
chart can be built in a very simple
JavaFX program let's go now into the STA
and point to you in the code where again
you know encouraging you guys to take a
look at our code when you get a chance
and you'll see a lot of what you we just
talked about down here so let's go down
to line about 69 or 70
well 69 is going to be create the pie
chart right and so after we set up a
stack pane actually after we know I'm
sorry after the first thing we do in the
create pie chart is we're going to call
get pie chart data in line 72 there it
is right there and that is going to
create the pie chart so let's go and
look at that right now okay so down
let's see there we go right there there
there it is in line 135 get pie chart
data for a particular column that we
have in now this is the STA now right so
this is going to have you know be
different than the program you just saw
and as you look at this code you'll see
that we're doing kind of the same thing
we're building an observable ArrayList
and we are getting values out of the
table and adding it to the observable
ArrayList and then we're going through
and creating the PI values yeah right
there and from the table
and the other thing that we're doing in
here is you can see in line 136 we say
if PC data equals null then do do this
code here else do the other code you
know what's happening here is that the
first time that this is called we create
the observable ArrayList and populate it
with the pie chart data items and then
successive calls that can happen when
you click on a year right and you have
to change the pie chart replace that's
what this code does down here the Gaels
selecting successive calls where you
change the year repopulate replace the
pie chart data items with the new values
from the table thing and that's why it
animates when you change because it's of
the binding and we showed you how to do
that okay let's talk about bar charts
now and you know we're not going to go
through all of the charts here in detail
but the pie chart and the bar chart are
the ones that are kind of used the most
out there so we thought we'd spend a
little bit of time here talking to you
about that first of all why would you
use bar charts well it's a different
concept than pie charts it displays
discrete data and you can see the
relative differences between category
series and the nice part about JavaFX is
that you have vertical bar charts and
then you have horizontal bar charts but
by the way bar charts require category
axis remember we said that some of these
XY charts did so we've got that in the
notes for you here and the interesting
thing about horizontal bar charts is
that because it's horizontal your eye
draws a vertical line down and so you
tend to read it left to right and so
horizontal bar charts are really good
for showing people you know where
relative lengths are and emphasizing
who's got you know more discreet data
than than others now generics is used
here with you know with these things so
bar charts series is now generically set
up for XY charts where this is the X and
this is the Y so on the x axis is going
to be a string that's category axis and
on the y axis is going to be a number
and so that's when all these XY charts
you know that's what you have to specify
there okay we're going to do the same
thing we're going to go back to the
Olympic medal count program and we're
going to do a bar chart for that so you
can see how that's done and then once
you learn how to do this then we'll go
into the SDA and you'll be able to
recognize what we're doing in there okay
now this is a little more complicated
than a pie chart because we have the
concept of a series okay so the first
thing we'll do though is will create the
bar chart by creating the axis category
axis and number access and then we
create the bar chart by specifying the
generics so that the bar charts x-axis
is a string type and the y-axis is a
number type after we do that we do the
same thing we did in the pie chart we
set the title Olympic medal count we set
the label of the x-axis to year we set
the label for the y-axis to medal count
now XY charts have series now you don't
have to have a series in a bar chart but
you often do and we do have one in this
example and also in the SDA so we're
going to create a three series here well
we have we have a series for each
country right but we're only we're
showing you just these here once again
it's going to be XY chart series
generics and it's important to get the
the types the same so so string and
number in all of these XY chart series
right you have to agree with the bar
chart declaration that we showed you on
the previous slide and we have three
series here one for us one for China and
one for Russia that we're going to show
in this bar chart the next thing we have
to do is after we create the series we
have to add it to the bar chart so we're
going to call get data with series 1
series 2 and series 3 I'm just going to
show series 1 here and this is where we
actually specify what the XY chart data
is so you'll see that the string is
going to be the year that would be 2008
or 2
and 12 and then the number is going to
be the number of metals the same thing
we had in the pie chart so we're showing
you how to do that with series one and
the same code would be for series 2 and
series 3 and once we've created those
the last step is to add the series to
the actual bar chart and so we do that
for series 1 and we do the same thing
for series 2 and series 3 okay so when
you compile and run this program
this is what it's going to look like two
years right 2008 2012 and three series
for each one of those of those years and
this is a vertical bar chart with an
Olympic medal count title at the top and
once again the bar chart is going to
render the legend for you down below you
can control the colors too by the way
the defaults look pretty good actually
but you know you have complete control
over changing these things if you want
to and you can use CSS to do that right
okay so just like we did with the pie
chart now now that you've learned how to
do a bar chart let's go back into the
sta now and show you how we did that so
gales going to bring up the bar chart
controller code now and as she goes down
to about 74 75 it's the same thing we
have create bar chart that's being done
in the scene graph for our java effects
after we go and set the alignment and
you know get the ticket units set up
down below then we go down to line 85
and there's the get bar chart data
that's the method that's going to create
the bar chart for us and then we can set
that to in our chart so let's scroll
down to to that and there it is get par
chart data and doesn't it look similar
right I mean once you start working with
some of these charts you know it's not
too bad there's going to be an
observable ArrayList which is going to
be you know we did you're creating there
from it's a static method in the FX
collections class and then we just set
up a for loop over the number of rows in
our table and the number of columns and
we create a series right here the new XY
chart series and then we add the series
then we
create the bar chart data in the middle
here and then at the bottom we add the
series to the bar chart so it's very
very similar to what we did with the
Olympic medal count it's just that
you're seeing it now with real data from
a table okay so the other thing that we
thought we talked about here on in in
the time that we have left here we have
about seven minutes left before we can
go to Q&amp;amp;A here we thought we'd show you
some how we did some of the animations
that you saw right we're you know like
the labels faded out and the pie wedge
moved so we'll give you some general
ideas of how we did that as well because
that's a big part of the STA and and a
big part of what JavaFX brings to the
table okay so these are transitions
they're all high-level transition high
level animations where you're changing
one or more node properties over time
and when you work with the transition in
Java effects you specify a specific node
and a duration and then you use
interpolator options where your choices
are these here and what linear means is
it's the default and that means that the
animation is applied at a constant rate
ease-in and ease-out
our animations where ease in is where
it's slower at the beginning and ease
out is where it's slower at the end and
then if you say ease both then you can
get animations slower on both ends this
is really easy to do and the rendering
is all done for you on it makes a very
nice-looking animation for you the other
thing is in the STA we have used these
all of these transitions and I mentioned
these earlier the fade translate and
scale and there's also a parallel one to
we'll all talk about all these fairly
quickly here so you can see that so I
just want to give you guys a little bit
of code here to show you how easy it is
in java effects to do these kinds of
animations a fade transition allows you
to change the opacity property and
opacity of 0 is completely transparent
which means it's not
and one is completely okay opaque so in
the example we make up a fade transition
called ft and we specify that the
duration of the fade is going to be 15
hundred milliseconds which is 1.5
seconds and we're going to do the fade
transition on a number label which you
saw on the STA
and then we do the ease out on the
interpolator so we just make a call to
that and then we set the opacity value
to zero which means at the end of the
fade it'll be completely transparent and
then to start the animation you just say
a play or play from start that's all you
have to do to do this JavaFX api's take
care of everything else that you see
there let's look at the translate the
translate transition is used to
translate the X&amp;amp;Y properties that was
used in the bar chart where you saw the
labels that were appearing inside the
bars and they were fading in and out too
but that's that was what we just talked
about and the pie wedge is two so this
is what this looks like
it's a translate transition in Java
effects where you set up the duration
again for 1 and 1/2 milliseconds for a
particular node now that you get from
somewhere and then once you have this
translate transition then you can set
the increments that you want to do for
the translate and of course this is
what's making the pie wedge move you
know this is all we had to do to get the
pie wedge to move and come back there's
more to it than that but this was
basically all we had to do to set it up
and the speed in which it moves is based
on the new X and the new Y so you set
those so that's visually pleasing to the
eye and then you just call play and we
and there's more code than this because
you know we set it up so that it goes
out and it comes back and you can set it
up to be continuous or you can do it
just out and back once and total control
you know just all api's here that you
can make to do that so that's basically
the how we basically without the
translate transition to work and then
the parallel one is very interesting
this is where you can group multiple
transitions together and actually have
Java effects do them in parallel you can
do them sequentially which means that
you can actually have animation be
follow a and then have C follow B or you
could have all three animations a B and
C all happening at once very easy to do
that you just make up a parallel
transition object and populate it with
what you want to go in parallel and then
play it
JavaFX takes care of all the animations
that you see there yeah okay
at the end of these slides I'm just
going to have Gail go through these
really quick here I'm just going to
point these to you remember these slides
will all be online for you guys so you
can look at them why you scatter charts
working with them and a little bit about
some examples there so this is good
right because as you look at these
things they tell you why you want to use
them to tell you what you need to know
for example a line chart you can use
number axis for both X or Y and then
this is what we do in the STA and then
let's here's the area chart why you use
it and what you need to know and then
the next one is the horizontal bar chart
very similar to the two the vertical one
not too much different there and then
the stacked bar chart requires category
access there's a few rules here about
that as well and then the next one is
the stacked area chart and then the last
one I think is the bubble the bubble
chart and the bubble chart has an
interesting argument that you can use to
control the size of the bubbles and
bubble charts are kind of cool and what
you can do with that as well
okay so
let's go to the last slide okay great
now to wrap this up I'd like to say a
few things about in summary about what
we tried to do here and again I said
this the beginning I want to reiterate
it again we feel quite strongly that
using Java FX and the NetBeans platform
together is really a good way to go if
you want to get a rich client experience
on a desktop application you don't want
to be concerned a lot with all the
plumbing that you have to do to manage
the windows the way that people expect
them to be it's a lot of work to do that
a lot of you guys have probably done
that
JavaFX makes a swing type based code
look better there's a lot of things you
can do there and you and we showed you
that you can have swing and JavaFX
working together right but the NetBeans
platform is also a good piece of the
puzzle here for getting to this rich
client application kind of where we want
to go with that because the NetBeans
platform handles all of the window
managing details that that you can use
so there's a learning curve to learning
of the NetBeans platform but it's well
worth your time and if you use the
NetBeans platform to create the backbone
of your desktop application and then you
take your swing components that you're
all familiar with and you put as much
Java effects in there or as little as
you want you're going to have something
on the client side that's going to be
very easy to work with very easy to
manage and very easy to enhance okay all
right so here's our email addresses we'd
like to hear from you guys if you have
any questions those are our addresses on
Twitter as well remember that the source
code for both the complete smartphone
data app that we talked to you as long
as the other small little standalone
Java effects downloads that we showed
you are all going to be available this
afternoon on our website which is ASG
teach comm and then you can go out
you'll be able to go out this afternoon
and pull in this zip file where you'll
be able to
everything you have there and take a
look at what we've done and you know
there's a lot of good stuff in here to
learn about okay so we're looking good
on time here I think that we can wrap
this up and we'll take some some QA if
anybody wants to ask any questions and
if not thanks for coming and we'll see
you another time thanks a lot
so we don't we don't have any
microphones here dewy dude for anybody
okay but both yell out so and if you
don't want to stand that's okay but just
talk loud
on incorporating Zelda
I've heard them talk about that but I
don't know that time I don't know the
road man yeah kirtan you want to say
something about that
actually
yeah yeah this afternoon he's going to
do that okay but no you're absolutely
right and you're not the first person
that's asked about that so you know this
is you know and this is a good thing
because I think that the the NetBeans
platform folks have figured out that you
know Java FEX is is good for the
platform and Java FX is needs that beans
platform - as an infrastructure right so
you know these two things are going to
play together I think pretty well
another question here yeah yeah I think
you did need bi-directional binding
because you can change because of the
reset button you can change the word
that was the model the string property
and then you can also change it down
below in the text field and you cannot
sign directly to a property if it's the
target of a bind so that's why
bi-directional binding would be required
there but I can go yeah let's bring up
the slide so we can show you that we'll
say it again
right you know what slide that is I
don't see how do I go to the Saudis
because of the back
we're having two ways right yes correct
right so if you took away the reset
button yep
well we wanted to show the fact that you
could do it to it yeah now you're
obviously right about that if we didn't
have the reset button we would we could
have done it with a unidirectional blind
but because you type something in the
text field
it changes the the word property yeah
right right good good question in the
back there what kind of a chart um you
have you know talk to the controls
people in the JavaFX platform you know I
actually don't know but let's see his
I've been asked that question because I
know what Gantt charts are and of course
JavaFX has opened up you know Pandora's
box now with the charts right I mean
this is just going to be the start of a
whole bunch of great stuff because we've
never had charts you know open source
and free from swing right so yeah I've
been asked about Gantt charts and I've
been asked about some other specific
charts too so I'm sure there's going to
be more of them coming but you should
ask that Jonna trolls team Jonathan
Giles is someone you could talk about on
that don't tell him we said said that
though okay anything else any other
questions yeah
um I don't
you know my answer to that would be the
ensemble right the ensemble have you
gone to the JavaFX page and looked at
the ensemble okay it'll blow your mind
right when you go to the ensemble you'll
actually see all of the effects that can
be done in small little windows and when
you'll click on it you know it'll demo
the effect for you it'll give you the
source code and that program is exactly
what you asked for it it's written in
Java effects so it's a real world
program that shows you all the amazing
things you can do with Java effects so I
would say that would be a very good
example of a real-world
Java FX application there mm-hmm
yes I think it has a software backup but
it does use as much of the hardware as
it can the 3d though the 3d does require
you know hardware support because when
you go to ensemble I I clicked on some
of those examples and it said you don't
you need a 3d chip and that would be
OpenGL would be involved there too but
but the system itself doesn't for the 2d
doesn't require that yes
I would use 2.2 because anything before
that if you want to use it with the
NetBeans platform it doesn't support
that set implicit exit false you have to
jerry-rig a dummy application that I
mean a dummy scene graph that never goes
away and it there's a couple of other
methods that we use grabbing the
snapshot of the scene graph that it
didn't have so I wouldn't use anything
earlier than two point two and recommend
using the most recent as it comes out
okay anything else anybody else okay
thanks for coming you guys and enjoy the
show and we'll see you around</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>