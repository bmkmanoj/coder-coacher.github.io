<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>From User Story to Automated Integration Test via DSL | Coder Coacher - Coaching Coders</title><meta content="From User Story to Automated Integration Test via DSL - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>From User Story to Automated Integration Test via DSL</b></h2><h5 class="post__date">2013-01-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/mmc6zSs7h64" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">when I proposed this talk to Java one
they said they needed heavy hitters at
the end I was like dsl's and integration
testing can't go wrong with that so gave
me the second last slot at the
conference so not quite number one but I
guess a lot of you are here because
you're interested in integration testing
probably a lot of you are here because
you're interested in domain-specific
languages for me the integrate the
integration testing part of it is what
drove my interest in domain-specific
languages and the reason is that that a
hundred percent of all of your
production bugs should have been caught
in your own testing there's there isn't
a case where something happened in
production that you couldn't couldn't
have foreseen and I think that a lot of
the problem with with finding bugs and
production is that we don't even
understand the test we have some
organizations do do better coverage some
others but oftentimes we don't even
understand the coverage that we do have
so using a dsl is meant to get us closer
to writing better tests and
understanding what we have being more
complete in our testing so we'll start
out with an example user story and a
test that goes with it a dsl test and
we'll talk about domain-specific
languages kind of at a high level in
general and then we'll go back talk
about why integration testing with a dsl
is a good fit and will actually talk a
little bit a little bit about how to
create your own DSL so let's say we have
this web application called snobby tunes
it's an exclusive online music store and
let's take a user story so a typical
user story as a subscriber to snobby
tunes I want to find and purchase cool
songs so that I can basically impress my
friends so that's the idea and that's
the that's the user demographic we're
going forward snobby tunes the key part
here is that we want to find and
purchase cool songs so if we were going
to model that in an integration testing
dsl it could be as simple as this where
we have
the three the three verbs here the three
actions are connecting I'm sorry the
main ones are login search and purchase
there's one pre action that we have to
do of course and that's connecting up to
the application but this test
encapsulate that previous user story
then we're doing it in four lines of
code looks like five because of the
wrapping and the only other the only
other things that we want to do in an
integration test after we after we
execute a feature of the application
under test is to do some verifications
so here we see a few more lines in our
integration test and what we're doing is
we're just doing some verifications in
this case we're verifying that the songs
were downloaded to our hard drive and
it's the right number of files and and
that the tracks are correct or the first
track is correct anyway it's that simple
so the whole rest of the presentation
will be using examples in this kind of
domain-specific language and remember
that this is where you can get to for
for your application could be a web
application client server could be rest
could be soap you can you can get to
this point in your own application so if
that was if the last example was too
long for you we could we can make it
even shorter because remember this is
our language this is something that
we've written so here we're going to
initialize snobby tunes in one line it's
going to know what to do it's going to
be done inside the code the connection
the initialization the login and we go
right to our search you notice that also
we have 22 verifications on one line
there's no reason why we couldn't also
have three it's all up to you when
you're designing your your domain
specific language it's up to you again
search purchase and verify so taking a
step back let's talk about
domain-specific languages in general I
think you probably know all this by now
a few years ago domain-specific
languages were new a lot of people
haven't heard of them by now you
probably have domain refers to your
business it's a business domain and the
way it differs from a general-purpose
language is that your domain specific
language is meant to model the entities
you're in your real-world business case
and we do this today with
object-oriented programming we all do
this you know we we implement a user
class and account class things like that
things that model the real world based
on our business domain but now we're
talking about limiting a language to
only those constructs so general purpose
domains allow you to do any kind of
programming domain-specific languages
are are meant to be simpler and meant to
deal with the business problem in a
direct manner now you've seen you've
seen domain-specific languages whether
you know it or not I mean reg ex SQL
could be considered a domain-specific
language we have some around testing
already particularly with Ruby but for
our purposes as up application
developers we want to look at why
integration testing is such a good fit
for a domain-specific language but
before we get there we have to talk
about language barriers and what what we
mean is we all have intentions when we
sit down to write a program or when
we're communicating with our business
folks we all have different intentions
we have to make ourselves clear and so
for any given problem there is an
appropriate language sometimes we have
to write it ourselves so because
domain-specific languages pull out the
important facts with business domain
they make they open up to a broader
audience the understand the intentions
and the understanding that we have as
developers and we'll show some examples
as we go but the most important point is
that in a domain-specific language the
program should read the way we talk to
one another we don't talk to one another
in four loops so I always have to put a
picture of my dog in my presentations
and I the reason she's in here is
because you know there are many times
where I'm talking to her you know I tell
her not to dig in the yard or I tell her
to see how stay down or
don't open the oven when it's hot and
she just doesn't understand me and
that's oftentimes how we all feel when
when we're dealing with non-technical
people we want to pull them into this by
making in a making integration testing
part of the non-technical workflow as
well so in the same way that a
programmer doesn't talk to the computer
and directly in ones and zeros a
programmer will go through some sort of
higher-level general general purpose
language in order to communicate with
the computer we also have a similar kind
of thing going on when we involve the
business people this is not a slam on
business people I just know that there
can't be any here especially the last
day of a technical conference so so what
ends up happening is we were we talked
about intention here the the business
person the non-technical stakeholder has
to communicate their vision for what
they want the product to be the
developer has to do the translation
higher-level language down to the ones
and zeros and neither and neither the
developer nor the the non-technical
person can go directly to the computer
and we know that this guy can't even get
to the higher-level language so it's all
about translations of intention but
imagine if we had a common language for
everybody so with it with a
domain-specific language focused on
integration testing you can now share
that language with this guy because he
can read this he can understand that no
one no one familiar with the business
domain would have any trouble
understanding a test written like this
which means you can get him involved
earlier and I would go so far as
depending on how much you like or
dislike your business person you know
you could have them write these for you
you could have them participate in
behavior driven development or
test-driven development by having them
express themselves in tests upfront and
you can develop you can develop your
code against their tests and there's
nothing revolutionary about
about automating integration tests so
today if you have automated integration
tests and you're not running your own
domain specific language you're doing
something like like this you're doing it
all in in code probably in Java code and
you're going to decompose the common
functions into into separate classes
separate packages separate you know
methods like connect you're going to
have somewhere login somewhere search
somewhere you're going to pull those
things all together in some sort of Java
code that's going to execute your tests
all we're talking about is going up one
layer on this side so we go we can we
can go right we can replace huge amounts
of Java code with with this and the
invitations are still the same
underlying it underlying it can be the
exact same Java code you had in your in
your existing integration tests so why
is it that integration testing is such a
great fit well as we've already seen by
simplifying things down to very clear
statements with very very specific verbs
and nouns we've opened up our language
to an audience that isn't technical and
we can get feedback from those people
and and when you when you go about
looking at an integration test that's
written in pure Java and I'm sure you
guys have been through this it's the
same as going through your application
code you have to understand what the
test is doing at a very fine level and
you're jumping all around in your IDE
how is this Login working who's you
could have to developers writing the
same kind of test in two different ways
because neither one is aware of the
other there's no common shared framework
that kind of thing so you could very
easily miss that it missed that a test
is doing something incorrectly and the
more Java code you have in your test the
more likely it is that your your you
haven't a bug in your testing code so
what we wanted something easy to write
it easy to read it makes it makes
getting getting you from zero to full
integration test coverage ten times
easier and I don't think that's an
exaggeration
and because it's so easy and because you
do it so fast it actually saves money in
the end so we're going to take on
another user story so in this case as an
administrator of snobby tunes I want to
terminate users who don't fit my
demographic and because we have to
maintain our reputation as the coolest
place to get our music so again this is
going to look very similar to the last
one it's very very few lines we're just
going to connect log in and search one
thing that's different here is that here
we're making a database a call to the
database to verify account termination
so by the way this was going to be
Justin Bieber but then I saw him play
drums you know that guy can actually
that he can actually play the drums so I
figured well we'll give it to Lady gaga
but in this case what's what's what's
important here is that here we're going
to the database and you know my earlier
statements about being able to write
test cases for non-technical people I
think that that's that's important
that's important and that's the top part
the bottom part here you may want to get
a little technical it all depends on who
your audience is and it all depends on
how you might want to divide the writing
of your tests as well we could get even
more technical and instead of hiding SQL
behind this invocation here verify
account termination we could expose it
directly through the language if we if
we chose to we could go we could go with
a means that that allows the the test
writer to execute any arbitrary SQL put
the value into a local variable for the
script and then make an assertion about
the value of that variable the power is
up to you so if you're if you are
considering writing a domain-specific
language for your integration testing
you really need to think about who's
going to be using it it's always going
to be technical people technical
technical folks are going to be the ones
maintaining it they're going to be the
ones with the most understanding of the
application itself but you also want
business people you want people
non-technical people to be able to look
at it too it also helps it could be a
technical person who's new to your
project and that's where you have to do
a balance between the business side of
things and the technical side of things
as we as we showed in the last example
direct access to ask you out that's kind
of technical hiding it behind a
statement verify account termination
non-technical so you have to decide
about that what parts do you want to
make explicit what in what things you
want to make inputs it you also want to
make it easy to read I mean I think
we've all learned a few computer
languages in our time and some have
simpler syntax than others and we know
that they're forbidding barriers to
entry on noisy loud or complicated
grammars and we don't need that in a
testing domain-specific language I would
say that the best way to actually go
about it is to start with an example
test and we started with one of the very
beginning of this of this talk start
with the end goal and then you can work
backwards from there say this is how I
wanted to be now I'm going to make it
happen and it's always going to take a
few times to get it right the most
important things though are striving for
readability and getting rid of all
extraneous grammar and all extreme
extraneous syntax and the reason is if
you don't you end up with something like
this this mess is too big to fit on a
slide and have it be legible and what
this mess is is it's a syntax tree for
c++ which means on any node you have all
these options of where you can go like
if you if you start with this you know
you can only go to these spaces
afterwards but then when I say space I'm
talking about actual grammar in the code
so here's here's a detail of that it's
just a mess and it takes a long time to
learn and that's another reason why so
many programs are hard to understand
hard to debug so let's start with the
clean syntax you've seen a couple of
examples in this talk already using this
format so what we're going to do is
we're going to say if a line starts with
two colons we're going to define a
target followed by an action
followed by parameters and then the only
other the only other the only other rule
you have to learn if you want to write
in this language is that you can use a
single colon as a shortcut where you
don't have to repeat the target the
language will assume that's it's the
previous target being reused again so
you just specify the next action and
whatever parameters that next action
needs so what this will look like is
exactly what we've seen before double
colon it's it's it's meant for the
parser to understand what's coming next
we have the single Colin's say to the to
the parser repeat use the last target
and here are our targets we have only
two in the script and the actions and
the only other thing is the parameters
you can see that some of the parameters
are name value pairs some have more than
one name value pairs separated vehicle
abaya pipe those are all very simple
rules and we can have our actions
actually understand what they want past
what they're expecting to be passed to
them so we can use different formats if
we want I wouldn't recommend it but
you're seeing a couple things here so if
you think that that's too verbose or you
want something else you know here are
some other options the first three they
look they look pretty much the same you
know the first one the third one doesn't
use Colin's okay that's fine if you get
too abstract I mean sorry if you get too
if you're worried too much about
verbosity where login is too long of a
word you're going to lose some users it
might be a little bit easier when you
use shortcuts like this but you also end
up with you know cryptic unix-like
commands and you know the insiders will
know what L means no one else will so
you don't want to go too far in that
direction you know in something like
this it might look great in a test but
then now you're asking your users to
understand that okay and that sign means
I want to log in a user and that's just
an extraneous bit an extraneous ruled
that I don't think you need people to to
to learn I think if you stick with a
consistent format all the way through
you're going to be you're going to be
doing a service to your users now
another nice thing about integration
testing with the domain-specific
language is you're able to do positive
and negative testing almost
declaratively and that's something you
you can't do when you automate your
integration test and your whole test is
written in Java and we'll see some will
see a little bit we'll see a few
examples of what I mean there another
nice thing assertions across channels DB
file system message queues whatever
they're made absolutely explicit anyone
looking at an integration test like that
will understand how the application is
supposed to behave and that's one of the
purposes of good tests it's to have
people understand what's expected of the
system we don't want to make a
domain-specific language that works with
product a but but won't work at all with
the product beast we have to invent a
new one for product be some of the
principles we've covered so far in the
examples where you have separate actions
allow you to capture a demain specific
language platform onto which you can
drop any product in any kind of terms
that make sense for that business domain
a couple other nice things you know you
might want to have it have your language
understand be able to run scripts from
different sources even incorporate
different language scripts in a
different language into your application
it's actually not that hard to do we'll
talk about that in a bit in the same way
you can drop groovy right into a Java
program and have it be dynamic you could
do the same thing with your domain
specific language and as far as
branching you know honestly I think if
you're writing a domain-specific
language for integration testing you
probably don't need branching you want
your test to be deterministic you know
if you have branching especially if you
have ifs and that kind of thing and that
means you're not certain of the outcome
you're not certain of how you stage your
data we generally don't want tests to be
like that a few other concerns you know
whether it's compiled or interpreted you
probably want to write your own compiler
so you probably go with interpreted you
also want to give really
really good run time feedback you don't
want people who develop new actions
against your language to be flummoxed by
failures that they don't understand
because it's something wrong with your
platform or some some contract not being
met which also means that you have to
decide what what kinds of things you
want to put into your domain specific
language implicitly and what extension
points you want to have exposed exposed
for people who want to write their own
essentially business models on top of
your scripting language and finally you
know you really need good job good job
adducts good documentation to to get
people to adopt it and understand it and
use it so the last point here is about
jsr two to three and we'll just cover
this really quickly this is basically
the contract between a Java JVM and a
scripting language and it's codified and
223 and what it means is that your java
application can share context with a
program written in a scripting language
that's dropped into it and the way it
does this is through six classes and six
interfaces defined in the jb m i don't
know how many of you have ever tried
this or you ever seen it but what it
boils down to is a factory that produces
engines and the engines are able to
understand scripts of a certain language
so there will be a groovy engine via a
ruby engine whatever javascript engine
if you're interested you could email me
or you could look at the at the spec for
it's actually it's it's it's it's quite
a nice feature and one of the nice
things about it is it allows you because
you're sharing context between a script
and a java application into which the
script is embedded you're passing
variables back and forth between the two
it also means that by the same contract
you can run a groovy script that sharing
context variables all that kind of thing
with a JavaScript script running in that
same application interfaces are exactly
the same and why that's important for
for our case is because you know
you want to make in order to increase
your adoption of your of your own
integration testing scripting language
you might want to allow people to drop
some groovy into your into their script
stuff like that it's really not hard to
do and another reason why it's not hard
to do is that we have some really really
good tooling these days we didn't have
two years ago five years ago antler will
will parse even complex grammars like
the C++ example we saw X text allows you
to expose your language and an IDE in
Eclipse it looks really nice they're a
bunch of other things up here I believe
that all the presentations will be
online after this so you don't to copy
this down I will point out the last two
are primarily Ruby and they both have to
do with testing and and that's one thing
we're where we as Java developers are a
little bit behind the if you've ever
done a rube who hears done a ruby on
rails app ok a few people you know how
their generators make everything so easy
you tell to generate your MA it's going
to generate your model your your your
controller and you get you know get all
this database access for free just it's
it's almost like a domain-specific
language because it's it's convention
based in it's meant to make things easy
everything should be easy simple and
direct and we shouldn't have to repeat
ourselves same exact principles apply
for your integration tests and key i'll
just talk about a couple of these
because they're interesting cucumber a
domain-specific language for testing
ruby allows you to do this kind of thing
so if we have a feature of our
application that allows us to add two
numbers together we can do that we can
do testing of that feature in cucumber
with something like this you can see you
write it out in English full English
with variable substitutions in here and
then we just provide different data
points that can go in there and has
anyone looked at j unit theories a new
thing theories good yeah it's
a lot like that j unit theories allow
you to provide a bunch of data input
separate from your test but but held
with the test and it will consecutively
execute your test with those with those
data points it's pretty nice r-spec it's
a little bit different the principle is
the same again you can see that in both
cucumber and an R Spec what we're going
for is something that's legible to
humans in there and there's a good
reason why you know we need to
understand our own tests so with
cucumber and with our spec you are
limited in certain ways your they're
really really good for testing
applications that do some things but
they're not going to be good at
applications to do other things for
instance like message queuing or
checking a database or things like that
they're not going to be as good at that
and that's one of the reasons why if you
write your own if you write your own
domain specific language then you can
provide as much flexibility as you want
you don't want to go down a road where
we don't have an equivalent of cucumber
for java let's say we did you want to go
down a road where half your tests are in
cucumber and then you realize what i
need to go validate some xml or check
check some fields in the database and do
joins and and and a tool doesn't support
it so then half your tests can't be in
cucumber and they're in you know
straight ruby or straight java i guess
is our example so writing your own gives
you the flexibility to do anything you
want which means all of your bases are
covered from the beginning to the end
another another really nice thing about
writing your own application is you can
do something something like something
what i'm about to show you with literals
so a literal is is anything that you
want to just drop into a test without
interpretation so looking at this
picture you know maybe you think this
looks like like my dog you saw earlier
here's a tail here's a face really look
at this what this is is those are
highlighting
all the places where we're doing
escaping we're taking what beautifully
formatted XML with the right
indentations and we're turning it into
something like this and I'm sure that
all of us have written automated tests
where we have to define you know
stretches of stretches of texts
especially XML or something and it's
ugly it's horrible it's an impossible
it's impossible to understand what we
can do is we can do something like this
so again we're going to we're going to
follow the the old model that we had for
our language and we're defining and a
target and inaction and we're going to
just let's say it's it's it's a web
services and it's soap-based it's not
rest but you know close enough actually
soap is a great a great great example
because it's so noisy any XML where you
have your to define your name spaces and
stuff like that it's going to be a mess
but here what if what have we done what
we've done is we've said we've initiated
a target with an action so we've gotten
it ready to accept web services commands
and it's smart enough to understand okay
I'm just sorry I have testing web
services that means i have to send xml
that means i'm going to be getting XML
back so you can just drop in a literal
right here and it's going to say oh I
reached the end the next statement
actually involves an action well I know
what I'm going to do I'm going to
package whatever this was and send it
over my connection that I made in the
first step you don't have to
declaratively do that you know it'll
just it can just handle it for you of
course that's a that's a choice you make
in your dsl construction did you put on
that the first colon in front of
envelope 00 because the line doesn't
start with the colon it has the
something else in front of it that's a
good point yeah if you ever did need to
send free text like this and it did
start with a call and then maybe would
be in the same boat of having to escape
but but that kind of thing so and we
actually at verisign we actually do
tests like this we have XM
client server applications and we needed
an easy way to to send commands through
there and we we have a way of allowing
you to drop stuff right in we also have
a way of allowing you to construct the
construct these commands which are
boilerplate anyway that's what XML is
its boilerplate the only information
that changes the only information that's
important is like found somewhere in the
middle of it so what we can do is we
could we could construct this through an
action here just pass in a couple of the
important key bits of data plug them
into the boilerplate and we're done so
this is what we're talking about when we
say literals support and what you get
also with that is a really nice easy way
to corrupt your data because you need to
do negative testing as well so in this
case that what I've done is changed the
the element declaration here just you
know made it made it look like a typo so
it's actually wrong on two counts first
of all it's not it's not schema valid
because this element type doesn't exist
and secondly it's unbalanced there
Morrow's here than there are here so
there are a couple problems here and now
what we're doing is we're verifying that
the response is different and by the way
you'll you'll notice that just as we had
the language itself be smart enough to
automatically send this off to a server
and get it back it's also going to hold
on to the response and apply you know
future verify statements against the
last response so what you have is a very
very compact way of expressing a
contract between the client and server
here now maybe the data corruption maybe
you don't want to have 50 million cases
where you go in and manually edit your
edit your text why don't you have the
language do it for you why don't you
make it native part of your of your of
your platform so here it's a lot like
the last one only now we're going to
have an action called corrupt we're
going to say oh on this element which is
the artist which can be found here what
we want to do is we want to inject some
carrom some invalid characters into the
name and bam resend it
it is smart enough because it knew what
command sent the last time knows what to
send this time corrupted version of it
I'll be it and verify the response make
sure it has the response we need so
these are the kinds of things that you
can do when you write your own language
and there's so much so much prettier
than if you if you had to do something
like this in Java code directly now
maybe maybe doing one corruption isn't
enough maybe maybe what you need to do
maybe you have a need where either you
don't trust the system or you just want
to pound it with bad data and see how it
reacts you could do something like like
this so here's our here's the last
basically the last slide showed you we
we verify a correct response we corrupt
an element and we verify that it's bad
why not do something like this why not
add a record action again this is a
script so record just means put whatever
whatever direct text comes after it into
memory and then send it back through the
the parser when when I tell you to so
we're going to record a scenario and a
call it corrupted artist we're going to
do those those three steps and we're
going to tell it to repeat and that's
how simple it is and if you I know I
know as engineers you're imagining what
the what the interpreter what the code
on the back side is going to look like
you can pretty much get this for free if
you're writing a scripting language
because all you're doing is you're
capturing this text and you're going
back you're storing it in a hashmap
probably under a key of corrupted artist
you're going to pull it back in the
memory and repeat it when you get to the
repeat I mean it's that simple I think
that most of us here hear the phrase
write your own language and it's
daunting and we'd be scared to attempt
it it's not I'm telling you it's it's
really not but but it's not it's not
always easy and there are some some
technical reasons and some business
reasons why you might get pushed back on
this
you know if you don't do it right then
then you will have spent time writing a
language that then cannot be reused on
your next project or your next project
and that's that's going to make
everybody mad and if you do write your
own language you are going to be asking
other people to learn it so you want to
keep it simple and and you won't get you
won't get business support you won't get
management support if they if it's going
to take a long time for you to write or
for people to learn but you know you can
always make the case it's a legitimate
case and it's the same case you'd make
for any kind of automated testing it's
going to require an investment up front
but it's going to more than pay for
itself in productivity and in quality so
once you have your your domain specific
language for doing your tests and let's
go back to an example we saw before you
what you want to do is you want to keep
in mind okay i have i have a language i
have a great language for this but but i
still need to adhere to good testing
practices good testing principles just
because you have a good language doesn't
mean you can't do the wrong thing with
it so in this case we saw we we saw this
before we probably weren't thinking
about it too much but if I ask you now
to take a look at this test and tell me
what things might be wrong with it you
might start to pick up on some things
for instance we have hard-coded
environment variable right there in the
test well that's not that's not going to
be good we're making assumptions about
what data are are already there that's
just the bad practice in testing we're
assuming that this user exists with that
password what happens if Lady Gaga
suddenly Biggio goes becomes punk rock
and she's no longer uncool to our
demographic you know what what happens
here what happens behind the scenes when
you connect to a database if nothing is
explicit here
could be that inside the handler for
this action in this target the handler
has some hard coded database connection
information on it and that would be bad
the final thing is you know you you now
have this specific user left in a
terminated state well that's not going
to be good for if this test ever runs
again it's not going to be good if any
other tests are using this user so again
you want to keep good sensible testing
principles in mind when you're writing
your tests and what we end up doing is
we end up adding to our language to
support the kind of externalities that
we want to capture remove from our tests
themselves so so what we'll do is we'll
make make our test item potent will
externalize those configurations we'll
have the test stage the data that it
needs and clean up after itself and as a
side effect of externalizing the
environment information we also have a
test that we can run over and over again
against different environments without
changing the test at all all we do is
change its configuration so one thing we
could do is we could introduce this
notion of variables and chances are your
language going to is going to need
exactly one way to define a variable one
way to capture a variable in this case
we're going to use dollar sign brackets
that's familiar to most of us for from
ants and other things so here what we've
done is we've captured the environment
variables where to connect to what user
to use stuff like that directly we are
going to externalize the URL into a
config file we're going to create a user
that we're then going to reuse here the
one other thing that I'll mention here
is that chances are because it's a
testing language and because the test
need to be idempotent the only other
thing you need apart from what I've
described so far is some sort of
universal unique ID generator you know
because that's really handy for tests
and you can't make your test out
impotent without it
so there we go that's that's all there
is when they interpret or see something
like this it's just going to look up the
value in a hashmap and drop it drop it
right there as as a literal into the
text and do its interpretation so
therefore every reference to pop fan is
going to be the same here now we in
these examples we've talked about
targets and actions well the reason I
think it's important to show you that
model is because I think it's a good
model and it allows for the kind of
extensibility that you want from your
from your testing language so that means
that you could have a developer on a
separate project right a target that
knows how to connect to a message queue
or knows how to connect to their their
own application or whatever the grammar
of the tests never changes it's all
still the colon the double colon the
colon and variables defined it's the
same way but but you allow extensibility
so that your language isn't obsolete
when your product changes most of the
stuff we've we just covered the one
thing about allowing corporation of
other scripts and other languages again
like I said if you follow the jsr two to
three spec that's been supported in Java
since Java 6 it's absolutely not a
problem you you pretty much get it for
free so you could drop groovy into into
your own language just in the middle of
one of your scripts and then the cleanup
stuff you know you definitely want to
have some sort of way to clean up a test
that aborts in the middle and why this
all is so important why why is it that
we want to automate our integration
testing the main thing is we want to
find problems as soon as we can we want
to automate everything that we can we
want to be alerted to problems without
having to lift a finger someone checks
in bad code I want an email it tells me
I got a problem and the reason we can do
this so easily now is because we have so
many continuous integration tools I'm
sure I'm sure many of us use Jenkins or
teamcity or bamboo all of that refers
all that refers to the the eye and
integration which is about integration
testing deployment and testing so one
thing you would want to do when you run
your domain specific language
integration test is you want to provide
some hook some hook back to the tool so
the tool recognize oh this was a test i
was running and it failed and you know
that means i'll you know you might want
to just wrap your tests and j unit have
j unit executes one of your your scripts
your integration scripts have j unit run
it and if it doesn't exit with a zero
that means that it failed we report it
through j unit every tool we have every
continuous integration tool we have
knows about j unit you get that for free
and you do want to distinguish between
logical errors and runtime errors that
gets back to the whole point of when you
write a platform when you write a
language platform you have to give good
debug messages you have to let the
writer of the test know whether it's his
problem or whether it's some tactical
grammatical problem or it's a problem in
in that his test didn't satisfy certain
verifications it was making so to sum up
you know the qualities of a good
language are that they're simple to read
and easy to use they if you're writing
your platform you have to give good good
real-time feedback you just you just
can't get away with doing anything less
and when it comes to documentation
that's essentially your contract with
any future user of of your platform any
future user of your domain specific
language because you're not going to
always be there to talk to them so you
need good documentation that lets them
know how to use the the beautiful thing
that you built and that's about it we
have some time for questions if anyone
has any questions
so it was kind of a skunkworks prob
project and I would say the basis of it
was a month and a half including like
time over Christmas holiday and and that
was that was starting not even
understanding that it was I was writing
a language it was just kind of like wow
I need to automate these tests because
right now I can I can't I don't know how
these people are doing it but I know I
can't stand to do copy paste into a into
a telnet session to get a server
response so yeah what it was really not
that it should be so much this was in
2004 2004 when I started it yeah it was
before any of the jsr stuff or anything
any other questions sure
job oh the question was what platform oh
no no again yes and that's and as you
saw okay so we all know this is true
engineers are lazy that's why we that's
what we automate everything we can
that's why we come up with that's why we
worry programs to do things we don't
want to do more than once and that's why
the grammar and this one ended up being
so simple was because I didn't want to
write a complicated parser and so yeah
if I had to do it today if I had to do
it today I'd probably take a similar
attack and I should I showed you a slide
mention antler probably a lot of you are
familiar with antler if you're into
domain-specific languages so you do have
options that will make things easier
maybe that's kind of the gist of your
question yeah we have a lot of good
tools today that weren't available then
but you know if you if you find yourself
relying on too many tools just to get
your language done you might be making
your language harder than it needs to be
any other questions you guys ready to go
huh all right well thanks so much for
coming appreciate it
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>