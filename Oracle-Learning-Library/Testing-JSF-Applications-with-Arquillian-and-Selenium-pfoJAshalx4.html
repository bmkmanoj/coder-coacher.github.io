<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Testing JSF Applications with Arquillian and Selenium | Coder Coacher - Coaching Coders</title><meta content="Testing JSF Applications with Arquillian and Selenium - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Testing JSF Applications with Arquillian and Selenium</b></h2><h5 class="post__date">2013-01-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/pfoJAshalx4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to the session testing JSF
applications with our Kilian and
selenium can you hear me okay is the mic
working out and me as well
cool so today we're going to start with
a brief review of back end testing
testing the application that runs in the
server then we're going to look at
testing our front end our rear GUI code
specifically our JSF applications with
selenium and the tools that are Killian
provides to help us do that so who are
we I'm Brian Leatham I'm the work at Red
Hat rich faces project lead and I'm I'm
Lincoln Baxter I'm the JBoss Forge
project lead we both represent Red Hat
on the JSF 2.2 eg so if you have any
questions about JSF and Red Hat JBoss
please grab us at any point ask your
question so where you're presenting on
these tools as users of the tools use
these and the rich basis project to test
our core components test sample
applications as I want to give a moment
to call out the the people behind these
great tools and let you know who they
are so eventually we have some of them
in the room right here
how's luck Knutson is the project lead
of arquillian so just to get a feel for
the audience figure out who you guys are
how many in the room are JSF developers
right JSF applications excellent that's
great and how many are using our Kilian
to do testing currently testing up their
back-end all right okay
and about selenium is anyone using
selenium to test their web applications
all right good show so we'll talk
briefly about back-end testing there's
been lots of other sessions at job 1
this week that have covered this but
we'll use it to set the set the level
where arquillian comes into our testing
or projects so we're all familiar with
testing our back-end logic writing unit
tests is a common way to write to test
our back-end logic or server-side logic
this is unit tests are really easy to
write when the logic is self-contained
and we can write a unit test that given
a set of input we can test the output of
our function we can take this a step
further by mocking objects and mocking
layers in our application but the one of
the driving goals behind arquillian is
that we want to focus on writing real
tests we want to test our code in
container and this way when we go to
production will have no surprises
because our tests our tests are going to
demonstrate that our code works in the
container as we wanted to in production
when we take a mocking approach to
testing if we're not careful we can end
up in a sit in a state where we're
testing our mocks and not testing our
application itself so this is where our
Kilian comes in arquillian brings the
container to the test when we write our
tests we're going to create what we we
home micro deployments so small bundles
of our application isolating the pieces
that we want to test and that particular
test that we're writing
we're going to deploy that to the
container or our Kilian is going to do
that for us and we're going to run our
tests in container
so with that brief introduction we'll
get into a simple example of a a
back-end test we're going to follow the
greeter test which is if any of you have
looked at the arquillian guides it's one
of the first guides you come to
demonstrates how to write a simple test
of CDI injection so here's the the beam
that we want to test it's the greeter
beam it's going to build of a phrase
using a phrase builder helper object
we're going to inject this phrase
builder in the constructor so you can
see already that as soon as we bring
injection into our test sorry injection
into our business logic we either have
to mock this injection to get the clap
to be able to test the class or run it
in container so with the arquillian
approach we run it in container we'll
resolve the the injection and be able to
run our tests so just a quick look at
the phrase builder what it does so we
can we know what is going to happen when
it runs it's just going to return a
string saying hello including a
parameter that we pass so the test
itself
to see the yeah so the test is small I'm
going to zoom in on the relevant pieces
can you see that test the the exploded
part if you guys if you guys want to
squeeze down that might help
we have if anyone's having trouble
seeing the screen they want to take a
minute to move over I can give you a
chance to do that so here's our test
it's a it looks essentially like a wreck
well it is a regular j-unit test but
where you've annotated it with this run
with arquillian class so that is going
to signal the signal to our Killian that
we wanted to enrich this class and
deploy it to the to the server so so
what is run in container me so what is
running container me threw me a curve
ball Lincoln so we are instead of just
running this unit test in our IDE and
our local JVM where the tests going to
run we would have to we would not be
able to perform the dependency injection
if I ran in our on our desktop
environment we probably wouldn't have
liked JSF running or like the database
or any of that stuff either right that's
right so we're going to create an
archive that we're going to deploy on
our server that our killing is going to
deploy a server for us it's going to run
the test and has cert the assertion and
the server
it's not my laptop okay so run with our
Killian is the the piece that triggers
that and gets our test to run in the
server so that deployment that we're
going to deploy to the server is what we
specify with this ad deployment
annotation we're going to use the
shrink-wrap project to create what we
call the micro deployment it's going to
be in this case a jar archive that is
going to contain just the class that we
want to test which is the greeter and
phrase builder classes there's gonna be
the only classes present in this bar and
we also are going to include a beans dot
XML file - to activate CDI and that's a
and the benefit of this is that we can
really selectively pick the pieces of
the application that we want to test so
you don't have to you know push
everything up which could result in a
longer test time you don't have to worry
about you can actually this is this is
real integration testing you can pick
the components that you want to
integrate together and then run your
tests on them you could also push the
entire application up if you want and do
like full end-to-end blackbox testing
which we'll show you a little bit later
but this is this is why we say this is
real integration testing all right so
being a micro point is going to deploy
quickly we'll run our test and we'll
keep our test execution time down so
here we can see we're using how to
inject and our test itself because this
test is run in our end container that
injection will be resolved and we'll be
able to use the injected reader beam
with its and JME dependencies or its
injections in turn resolved and so
finally we come to the to the test
itself annotated with the J unit at Ted
claw at test class we want to call
creator dot create greeting Earthling
and insert that the result is hello
earth one and this is the really
familiar part I mean this is just a
JUnit test when you get right down to it
we have this deployment method but
that's it I mean now we're just doing
real normal testing writing the the
normal J unit stuff that we're used to
so it's talking a bit more about the
magic behind this how we get our Killian
involved if all we're writing is that J
unit test is it really just that run
with class that that is bringing our
Killian and yeah essentially that's it
we have to make sure the dependencies
are there in place in our pond XML we're
using J unit to run the test that part's
already taken care of and we have to
have our deployment cane container
specified we can deploy to any number of
containers JBoss GlassFish tomcat
websphere like right so not really a
resin so not only gonna need a lot can
you choose the pieces of the application
that you want to integrate you can also
choose the runtime that you want to test
them on so if you know you're going into
production on like web logic or JBoss KS
or something like that you can just
deploy that container verify that all
your code actually runs on that
container in the environment where
you're going to going to be running it
so when I'm fine there's initially in
our Killian XML file where we can
optionally can optionally configure our
deployment container not not a
requirement out of the box so taking a
look at what the palm looks like you can
see we have the dependency for the JBoss
AS a container using the manage
container in this palm example and we
also specify the dependency on the the
server protocol and so they may have
tested so manage container means that
we're actually going to be starting up
in a separate instance of jail SAS and
then running the test on that right
right
our Killians getting all that for us
that's right so this is this is one way
to configure our Kilian you can just
copy and paste this stuff into your plan
file but there's also plugin for JBoss
Forge which will let you set up our
Killian and configure the container
it'll even download set up the pom file
to download JBoss ASO you don't even
have to put it on your disk it'll just
do this automatically as part of the
build and that's a plug-in for J bus
forge that was written by Paul Baker and
it's just it lets you do all of this set
up in like one line just you know set up
our Killian enter you're done is
everyone familiar with JBoss Forge and I
mean how many people have heard of day
bus for sure
so the plugins for 4h deftly help out
when it comes to writing or killing in
tests so with that let's look at this
demo running so here we have that same
greeter test that we were looking at
before and we see we have the arquillian
annotation this tells the j-unit how we
want to run this test and our deployment
method where we select our greeter class
that we're going to package up into the
micro deployment and then push out to
the server down here we're going to
inject the greeter into our test and
then we're going to assert that it
behaves as we expect it to so we'll go
ahead and run this test just going to
click here run as Jane a test and if
everything goes well we should see a
green bar green bar green bar and if we
look over the console we can see that
we've actually had a test war deployment
here the deployment was then shut down
and unemployed and arquillians clean to
clean everything up for us this is JBoss
as7
yes
you essentially layer
Oh
is there an easy way to turn that book
I know everything I need to bless
right right so yeah it does a can get
complex particularly depending on how
your application is structured if if
your application is structured into nice
tight modules and according to a nice
clean architecture you can put that
together quite nicely the shrink-wrap
provides some additional tools to make
that easier to build up that archive you
can add a package at a time for instance
at all the classes in a package we also
have support for maven dependency
resolvers so you can include libraries
and other libraries or if you have your
own logic bundled in jar files you can
but when it comes down to it I mean
writing tests is as much writing code as
anything else and if you have a complex
system it's going to be a little more
complicated to set up your test suite
but it's it's certainly something that
that's not not difficult if you just
take a little time and work through it
right so if you still have associations
between objects you need to worry about
that but it definitely encourages you to
think about your design as well this is
this we're going to we'll get to this
some briefly at the end when we can talk
about some some tips for writing
performing tests this is using at the
remote connector so the palm example I
showed on the page used to manage
container so this particular example is
using a remote content connectors so the
application server is already over
you're running already started we just
deployed around the tests yep we don't
have to deal with the startup shutdown
time ever tests so it's one of the
things that we can do to improve the
turnaround time on running these and
container tests yeah right
well-tested container because that's
where to run
but if I'm that's actually different
seems the
right so we're going to have various
stages of testing we're going to have
that this is sort of targeting you know
the unit testing our my class is doing
what I think they're going to do and
we're going to have additional layers of
testing integration testing functional
testing where we're going to want to
make sure that the the system behaves as
it wants to this right so what we're
showing you right now is integration
testing and we'll get to blackbox
testing joint ads um
okay so with that that covers what we're
going to talk about for back-end testing
and now we're going to talk about
testing the front-end the GUI portion of
our application so getting to what you
were you're at the point you just raised
actually we have here a graphic of the
ideal pyramid of test coverage our
applications before they go into
production should ideally have a large
number of automated unit tests as we go
up the pyramid the number of tests we
have decrease as we are increasing the
complexity of our tests and finally
before we we deploy we're going to have
some some has certain amount of manual
testing but hopefully this is a small
amount of manual testing because we're
confident and the test coverage that we
have throughout the different layers of
this this test cover this test coverage
pyramid unfortunately this is the ideal
and reality it tends to look more like
the ice cream cone of test coverage we
have a small number of unit tests and a
large number of manual tests before we
go into production and part of the
problem is here is it's hard to automate
the GUI tests the the GUI test that we
write end up being fragile hard to
maintain so we don't do them we end up
relying on manual tests so we're going
to see today some tools that are going
to help us do that so how can we
increase our automatic test coverage we
want we could write unit tests to test
our GUI code but no you know yes I would
say that would take lots of mocks and
it's a number of mocks I'm instead we
want to take their achillion approach
and focus on real tests so writing real
tests involves testing and real browsers
and there's a lot of real browsers to
test them this is where selenium comes
in selenium automates browsers that's
what his job is with selenium 2 we have
the webdriver API that gives us a
unified API for writing our tests
against all browsers it even covers HTML
units so we can write headless tests
which are ideal for running in a CI
environment
so let's take a brief look at the
selenium an API itself a one key class
with selenium the selenium 2 is the just
before I get into I just wanted to say
we're going to focus on selenium 2
selenium 1 had a different API with
selenium 2 we've introduced the
webdriver API and that's going to the
focus what we're talking about today so
with the webdriver class it's the class
that represents the web browser that
allows us to manipulate the real browser
running in our desktop environment from
the from our java code from our tests
some key methods to point out are yet to
perform a get call and load a page and
find element that lets us find an
element on the page the find element
takes a by argument that lets us look
for an element by ID by CSS class by
XPath by just about any selector you can
think of very very rich api what we get
back from that find element is the web
element class and this represents an
HTML element on the page so a particular
bit of the Dom and then we want to
manipulate those bits of the those HTML
elements those web elements to interact
with the page so we can do things like
clicking on the elements send keys
allows us to put input into these
elements we can get text to retrieve the
value in these elements and it also
supports the find by or the find element
by method so we can find children
elements from it
so as an example of what it would have
looks like using the selenium webdriver
API to look up a web element here we're
using the driver find element by ID
username to find a Dom element with the
ID username and then we in our tests we
can manipulate that ID those
alternatively the find by annotation we
can use here we can annotate a web
element with the find by annotation to
find the same element by the ID username
too with plain selenium without our
Killian involved we have to use the page
factory edit elements to resolve those
annotations so we'll see how our Cillian
helps remove some of that plumbing code
shortly another great tool with selenium
is the selenium IDE so this is a plug-in
we can put it in our browser and then we
can record tests as it records our
interaction with the application so we
can fire up in our browser we can file
up a fire the selenium ID click the
record button and it this is like it
records a macro of everything you click
on everything you type in and it gives
us the Java code and that's done so we
can just put that right in our test so
here's so let's let's look at an example
of this here we have the the JBoss
kitchen sink QuickStart application so
this is a sample application cut out by
the JTF project at JBoss so the JBoss
developer framework it's meant to show
you how you can run or write and run a
Java EE application using the JBoss
implementations of the standard so a
full-featured crud application this is
the kitchen sink application shahboz
kitchen sink and you can find all of
this at J busted org slash JDF or slash
developer one of those two
prior to me so we're going to test this
application we have it we're going to
look at running just a selenium test
we're going to skip the arquillian
deployment for now so this is going to
be running on open ship in the cloud and
we're going to use selenium to connect
to that running application in the cloud
and assert some state so this would be
for example you know if you have like a
test region where you push all of your
code up to and then execute you know
lots of manual tests on you could
actually push that up to your test
region and then have this battery of
automated selenium tests to go through
and try to automate a lot of that manual
process so here's an example the
selenium IDE after I recorded a test you
can see the the command and the first
column their open weight per page type
type type click verify text so that is
the what the selenium IDE recorded as I
was interacting with the application
then from this this goobie tool we were
able to export java code here's the Java
code exported from the selenium IDE
that's well we'll go through in a minute
I'll zoom in on the text so it's too
small to see right now but just to
demonstrate that we get Java code out of
this lenio my D so then we can take that
Java code put it in our unit test and
have an easy way to author tests without
having to manually type it all up so if
we look at what's in this test there's
no more killing involved here this is
just a plain Java class or J unit test
in this case I'm using selenium so we
use the app before annotation on a
method we have to instantiate the
browser ourselves and load the page in
this case it's kitchen-sink - rich faces
are each cloud com it's a deployed
application on the cloud here's the test
itself so this is what spit out by this
lenio mighty see it corresponds to the
to the lines and the selenium ID window
recording our interaction with the test
so you can see the final assertion we
assert equals
I am Leatham to the get text from a
table element we'll see what that looks
like it is going to run in a minute
and finally we have the after test we
have to tear down our test and make sure
that we shut down our browser with the
driver quit call so this is how you can
write tests using just selenium and you
can see that there's a certain amount of
boilerplate involved instantiating the
browser starting it up shutting it down
we want to get rid of that before we do
let's take a look at a demo of the
selenium example so here we have the
selenium test and you can see this time
we're not using arquillian we don't have
the run by annotation we don't have a
deployment method all we're going to do
is set up selenium we're going to get a
handle to our webdriver
and then execute that battery of command
that's going to result in our test
assertion down here so we'll go ahead
and run this when I was Jenna test and
written upon my sari so we see the
browser start up here it goes ahead and
fills in our information submits and
when we come back we have our assertion
we could have actually also set a
breakpoint here and we could have steps
through our test case as it was running
and it would have paused the browser and
all that good stuff right so that's a
question in the back
go ahead the question is what's the
browser support for selenium IDE I think
it might just be Firefox but the tests
that are Kanyon can you answer the
question
yeah yeah weird we're not going to use
slam ITM right yeah it has the there's
the Firefox plug-in but then what it
does is it writes Java code to the
webdriver API you can then run that test
against an arbitrary container so we're
going to look at how we're not not going
to want to use slam ID because selenium
can give us some problems particularly
when you use a selenium ID the tests
that authors do not have enough extract
abstraction and they're highly
repetitive so we notice in that Java
code that was generated where's it I'll
go back you go wait I have it in right
here
I've been zoomed in okay so you can see
that we're doing driver dot find element
by ID we not we had not only have to go
through our applications our views our
JSF use and make sure we assign
everything an ID being a JSF application
as we start changing the parents around
that ID is going to change this is
really fragile as soon as we change our
JSF page this this kind of lookup is
going to fail and we're going to always
find ourselves updating our tests a
matter of changing application just much
better so with just plain selenium we're
going to have a mains problem we want to
be able to better up automate our
client-side testing and the way we've
automated server-side testing so I want
to be able to just deploy the app run
the tests and be sure that those tests
are going to be resilient to change so
we've already got the container life
site lifecycle managed text isn't lining
up there so arquillian has got covered
for us to start up and shut down at the
container
and peace that's not on can you switch
to that yeah we'll just leave it running
on that one this one go to Lyman issue
so yeah arquillian has us starting up
shutting down the container creating the
testable archive and deploying the
application but what about the client
lifecycle how can we achieve some better
automation on that this is where the
arquillians extensions are going to come
into play we're going to talk about
these extensions I'll just cover them
very briefly right now before we get
into them the first one we're going to
talk about is our Killian drone so our
Killian drone brings the browser to the
test the way our Killian brings the
content container to the test it's going
to automate the lifecycle of the browser
in our tests arquillian graphene is
going to integrate selenium with our
arquillian tests and allow us to write
selenium tests the arquillian way and
we're going to talk about our Killian
warp which is particularly interesting
for JSF applications because it allows
us to test run a test on both sides of
the request we can in a single test we
can have an assertion on the client an
assertion in the server so our Killian
drone first rqx tench we're going to
talk about its job is to manage the
browser lifecycle our Killian drone your
are we running off this one now okay
sorry
so our Killian drone integrates with
selenium the webdriver API and with the
arquillian graphene extension which
we'll talk about later which allows us
to interact with selenium so with our
Killian drone we can get an instance of
the browser the webdriver class in our
test using a drone annotation so in our
test class we put at drone we're going
to have a browser there available for us
to chose to to use in our test and we
don't have to deal with the lifecycle
ourselves and the before or after test
method calls additionally this will work
seeing them seamlessly with the selenium
server
when we want to invoke museum server in
our test which gives us a already
running browser that we can use across
multiple tests to save that browser
startup shutdown time we won't have to
change our tests our Kilian phone will
work with that for us and finally
another advantage using the a drone
annotation is I have a snippet here from
the arquillians XML file file where we
can configure what browser we're using
so here we have the extension with the
qualifier web driver we say that for the
browser capabilities we want to use
Chrome so when that's in the our team
and XML drom is going to inject an
instance of the Chrome browser for us to
run our test we want to change that to
Firefox or HTML unit we will run that
browser for our tests so this is done
through XML configuration sure I know
what means exactly the opposite so we
create one test use writing to the
webdriver API and then in the
configuration of our test when we run
the test we specify which browser we
want to run those tests against and
we're actually going to do that using
maven profiles so you can just kick off
the build kick off your tests using you
know one profile on the command line or
in your ID you know another one another
one and just run off you can run them
all right in sequence so we can use use
the maven build to do a text
substitution in the arquillian XML file
and so by activating different jumping
the gun a bit here but by activating the
invading different maven profiles we'll
be able to run our tests against
different browsers so it's it's writing
less tests and targeting multiple
browsers
um yeah yeah enter and explore the
question is can you can you target
different versions of ie yeah I can't
answer that offhand you know I was like
if
right alright so yeah so the answer to
sum up is you can do it but you have to
target a system that has the particular
version of ie installed right yeah
yet have that
right so the machine that has selenium
on it needs to have the particular
version of Internet Explorer that you
want to run against thanks for that
thank you
passed away
you have a conditional based on so the
right so that that is possible there's a
number ways of doing that we can have
them in separate tests or we can
activate the tests independently we can
maybe we can go about go over that after
the session if it'll be all right
that all right okay so the idea is by
injecting the the browser and externally
configuring which one we want to run
with we can achieve this this idea of
separation of concerns where the
developer can focus on writing the tests
and our QA team can focus on automating
the tests so we'll do a quick example of
a Google grown test it's a very simple
example it's just going to demonstrate
the add your own injection it's going to
inject a browser connect to Google and
verified that the browser's indeed
looking at the Google page so this is
the test here we inject the drone
browser with a drone we use the browser
go to google.com and then we want to
look for a particular span that contains
the tax Google search corresponds to the
Google search budget button and then
assert that the number of elements found
there is greater than zero
well nowhere on the Google page so here
is our Google drone test again we're
going back to using that Kilian so we
need our run with annotation in this
case we're not doing a deployment we're
just going to inject our web driver so
that we get a handle on the browser and
then we're going to open up Google like
Brian said find a few elements and then
make an assertion so let's go ahead and
run this
then we should see the browser pop up go
to Google and we get a green bar screen
bye alright so demo time here we go so
now we're going to talk about the next
extension on our list or Killian
graphene which lights us right are
selenium tests our Killian style so with
graphene one one of its big feet had a
number of features one of its big
features was the graphene selenium clasp
which gave us a tight safe selenium
clasp for selenium 1 we're not talking
about selenium 1 today we're talking
about selenium 2 and the webdriver API
so we're not gonna be talking about this
today no rather we're going to talk
about graphene 2 and the of the features
that introduce to writing our selenium
tests that give us more injection allow
us to inject more test resources into
our tests and to do some additional
layers of abstraction that help us write
more robust tests and then gives us some
additional extension points where we can
test more things I'd like to add that
this is very safe injection by the way
we probably would not be using this
technique actually over working so the
first thing we're going to talk about is
some very various page abstractions so
when capsulated on melons behind a
custom api so the various more you talk
about comes from the selenium project
itself is the idea of page objects with
page objects we can provide a class that
encapsulate the behavior of page it
hides some of the nitty-gritty details
of the Dom in our tests so from the the
selenium website here's an example for a
login page this is an object that that
does the the element lookup using the
find element method but exposes the
result of those lookups it's a
higher-level API so this login page is
going to give us the method login has so
we can log in with a particular username
username string and password we're going
to write our tests using this log in as
method rather than doing these element
lookups within the test this is going to
make our test easier to read easier to
maintain if we have this in a number of
places when we need to change which Dom
elements we use on the lookup page those
re the log in page we only have to
change it in one place additionally you
can see that this result of this log at
login has method returns a new home page
so we'll actually map so the expected
navigation you can imagine writing a
fluent test and are using this API so in
order to use page objects we have to use
the selenium provided page factory class
to initialize the elements this is again
the kind of life cycle thing that we're
going to be able to automate with
graphing so with graphine page extension
because the graphene test enriches the
test through as an archaeon extension it
manages the page Factory for us so we
can get a page reference using the app
page annotation not have to instantiate
it ourselves and not having to
initialize it using the page Factory in
a similar manner well we can use the I
find by annotation to look up web
elements and graphene will resolve those
for us we won't have to use the same
page Factory we saw earlier to
instantiate those web elements so this
is how graphene gives us gives us more
injection and allows us to write less
boilerplate in our code so graphene
takes the idea of page objects one step
further and we introduced the idea of
page fragments the idea here is instead
of encapsulating an entire page we can
apps and calculate the fragment of a
page this is going to map very well to
our JSF applications we can create a
page fragment that corresponds to a JSF
component and then we can write our
tests to the API of that page fragment
rather than to the Dom of the component
itself one thing where we're currently
working on the rich basis project is
shipping page fragments with our
components so that as we make a change
to the Dom underlying RJ
Ceph component we will ship the
corresponding updated page fragment you
use that page fragment in your test and
you won't even notice the the underlying
Dom has changed and this is a huge
improvement I mean because without these
page fragments you would have to go find
all of the individual you know
identifier for these components and just
providing this out-of-the-box is really
I think a great a great value add for
rich faces because now it's not just
that much easier to test what you've got
you know build your app with rich faces
you've got all of those fragments to
just wire together in your tests like
you were saying putting your tests
together can be difficult so anything we
can do to reduce that pain we think is
really important so not only are we
going to use the the component provided
page fragments but you can easily author
page fragments yourself so let's look at
the early exit yeah
extraction for the win we have a single
place as Lincoln was saying a single
place to update the webdriver code when
the underlying Dom changes right so
we'll get to an example of that shortly
I just want to cover a few more graphene
api's first so quite often when we write
our client-side tests we find that we
have to wait the we have to wait for the
the the client the browser to community
to the server sometimes you have to wait
for the server to communicate to a
database not everything happens
instantaneously and as the client code
tries to progress it can get ahead of
where the browser state is your test
will fail so in the simplest case we can
throw in some thread dot sleeps and
allow the browser to progress before we
try and retrieve the next Dom object or
assert some state the problem with the
thread dot sleep approach is you end up
having to create conservative wait
periods here we're waiting two seconds
for something to happen if it happens
within half a second you're going to
keep waiting the full two seconds or
that to happen and as you're running a
battery of these tests you know this
starts to add up over time you're
wasting half a second here you know a
second and a half over there you got 200
tests now you're just take half an hour
to run and it's just really not
efficient so selenium provides the
webdriver weight class to help us with
this it's a it's a great utility we can
create a new webdriver weight object we
passed
a parameter of the webdriver object
corresponding to our browser and then a
default maximum timeout
so that will wait no longer than 10 I
would not remember what the unit is
there may be seconds so that that will
be the maximum time oh but it's going to
trigger advancement according to the
until until when the expected condition
defined here is met so here we're going
to wait until the expected condition of
a particular element of ID dynamic my
dynamic element being present when the
page is updated with that element the
test will proceed do we want more
boilerplate no right we have so here we
have a an anonymous inner class several
lines of code to be able to do this wait
so graafian provides us and simple wait
helpers to help us work here we have
some essentially using the same approach
but with default different default
timeouts we have a wait GUI
where you're waiting for a short-lived
action to occur typically when you're
waiting for a client-side operation we
need Jax waits for a longer time for
example waiting for an AJAX update to
come back from the server and we have
wait model which is a kind of have a
maximum time a longer maximum time out
for when you're for instance doing a
database update so just some examples of
using these wait helper usages or using
these wait helpers using the wait model
approach here we're saying we're
starting with looking up an element by
ID button and then we want to wait until
that element or a that element has a
child ID that is visible the next line
we want to look and make sure that that
element does not contain some text blah
blah blah and the similar variations on
that another approach to waiting that a
graphing gives us is what's called
request cards and so request cards just
wait for either an HTTP or an xhr an
ajax request to complete so in here in
the usage that we see we see guard HTTP
button click
that's going to block progression of the
test until the HTTP request initiated by
that button click returns so it's a very
concise and powerful way to write your
tests and have them wait on the the
server response before proceeding so it
works a example of some usage of the
request cards here we inject a couple of
buttons one that's going to trigger an
HTTP request one that's going to trigger
an ajax request
sorry too fast and then we can guard on
those buttons um and execute the click
action and now I assume that you know we
don't have any imports here I assume
these are static imports that you've set
up oh yeah sorry I should have the
graphene dot guard HTTP there you can do
a static import on the graphene class to
keep your test code more concise all the
the sample for this these codes is is on
github I'll give you a link at the end
of the talk that you can download these
these tests look at the code look at how
the tests are structured and run them
yourselves another utility graphene
gives us is is the idea of JavaScript
interfaces so with if we create a Java
interface and we annotate it with an add
JavaScript annotation we can provide a
JavaScript implementation of a Java
interface and invoke this JavaScript
from our test so this this turns out to
be a pretty powerful technique to
interact with your tests to interact
with the JavaScript inside the browser
of your running test if you come across
a use case that isn't provided by with
selenium so we'll look at a simple
example of using the JavaScript
interface to manipulate the Dom we're
going to fire up Google n Google again
we're picking on Google today we're
going to demonstrate some bi-directional
communication so here we see background
Java is an interface where we use the
add JavaScript annotation to define the
JavaScript handle
that we want to use in the Dom to
manipulate the test so in this case is a
JavaScript my background the interface
background has a set background and a
get background method
so with these we're going to see how we
can send a value from our j-unit test
into the into the browser to manipulate
the background color and we're going to
see how we've been retrieve available
value using javascript to an assert on
that value and our j-unit test so here
we see the javascript implementation of
this Java interface the my background
global object implements the set
background and get background functions
so here's the test that uses that
JavaScript interface again we use drone
to inject the browser I didn't do that
right you want to write him sure yeah so
again we're using using drone to inject
the browser we're going to use our again
our Killian LUN with annotation so that
we tell j-unit how to bootstrap this
test then we're going to print some
print some of the state of the browser
by accessing the actual javascript
object and then we're going to use our
naive sleep to do the waiting for our
client-side operation and run the test
so you should see Google pop up here
actually and we're going to we're going
to hack into Google and change the color
of the background
which google there's read google and
we're done
so thinking if you can pull up the the
test output will see the retrieve values
of the google background so here are the
retrieved values just so the people in
the back can see this I'm going to pull
it up to the front here to the top so
the background color is nothing which
defaults to white obviously and then we
change it to red and then back to white
so here we're using a JavaScript method
to inspect to the Dom in the middle of
the test and return the value into the
into the test so we can use that for
complex assertions right pretty pretty
powerful technique in my opinion right
so I'll briefly mention one last feature
of graphene is page extensions so with
page extensions we can set up these
JavaScript interfaces to be
automatically injected in our tests it's
a little bit complicated setup it's not
a common use case to use them you have
to implement an interface register an
extension if this is something you find
you need to do happen to have a look at
the docs it's well documented and final
word on all this setup well the the
JavaScript interface and page extensions
is what we use to implement the request
guard feature we talked about earlier
skip interceptors so we have an example
of using graphing here on our login
screen so here we have a username and
password we need to log in on the page
we can look at a pair of examples just a
word about the deployment this is a
pattern you're going to want to use in
your Killian test yourself when you have
a number of tests that are going to use
the same deployment the bigger we have a
number of tests that are you can use the
same same appointment we tend to put
them in a single class and access them
through a static method and then and all
the tests I need to use this deployment
we can retrieve this this shrink-wrap
deployment
build on it by adding additional classes
it gives us a common base to work on
brick around keeps our to the business
of creating these shrimp rock archives
simpler so the test itself we're going
to look at the graphene test of this
login page we run with the arquillian
class as usual here we can see the
deployment we're just going to return
the result of that static call to our
deployments class keep keeping our test
code dry here we see you see a series of
of injections to get our browser and the
web elements we want to look at and then
we run the tests we want to find or take
the web element username send the input
keys demo and the login click link and
we're actually going to skip this demo
we're running out of time so so this is
not using any of the page abstractions
we talked about this is the end of test
code itself we are looking up the
elements by ID and green bar
green bar I ran oh you ran it real quick
ok nice so we can do the same thing if
we create a page fragment for the login
screen so now we move into a class
called login fragment we move these same
find by annotations to find the elements
and then we expose an API set username
set password and click that is going to
delegate to those web elements so when
we write our tests now we use the at
find buy annotation to inject the login
fragment rather than injecting the
individual web elements and now our test
is executing against that API so login
form set username login form set
password login form click you can see
now when you change achieved a certain
amount of robustness if we change the
underlying Dom API we update that page
fragment we are no longer going to have
to change this test or any other test
that uses that API we are going to
update our page fragment any test that
is rights to that API is going to make
p.m. stay stable and so you could think
of if the job that the promise of Java
is write once run everywhere the promise
of this setup is right once test
everywhere
so we have a demo with this I'm skipping
the demos at this point cuz I really
want to get into work before we
completely run out of time Greenberg
green bar worked excellent
so the last extension to talk about is
our Killian work our Killian work allows
us to test on both sides of the request
our Killian work will enrich the client
request with a test to run on the server
so not only are we going to assert a
client state we're going to serialize a
test send it to the server and run it on
the server and then our Killian will
enrich the response that comes back the
server with the results of the test just
a word this is not the official a
Killian warp logo there it's a very new
project currently in an alpha two stage
I just threw this this logo of the drone
spaceship coming out of a Mariel warp
tube for those of you familiar with
Super Mario Brothers so maybe you've
heard a JSF unit it's a the old way of
testing JSF applications what we're
calling it the old way it only runs
against htmlunit you can't test against
real browsers and you can only assert
state at the end of the JSF lifecycle
after the render response phase and it
only works with JSF artifacts you can't
use any CDI EJB spring what-have-you
with JSF unit so warp is the new way has
a number advantages it works with
selenium so we can use any HTTP client
and it contests the entire JSF lifecycle
we can assert state at arbitrary points
throughout the JSF life cycle we can
test any injectable resource CDI EJB any
framework we already have a warp
extension for spring has been
contributed to the project still in its
infancy but it's there so here's a warp
example again picking on our login page
so in addition to the run with our
Killian class we have to annotate this
is a work test we create the deployment
using our static deployment but here we
have to we have to change the beans dot
emits XML file so we have to remove the
beans out of XML file we used in all our
other tests we put a new one and the
reason for this we're still trying to
work out a more seamless way of doing it
but we're going to put these test
classes on the server and
weld is going to try and resolve the
dependency injection on the server when
it gets there it gets confused so we put
a beam XML file and that says ignore
these test classes when they get to the
server where we'll be cleaning that up
in the next alpha stages so we similarly
have our annotations to inject the
browser inject the login frame and
fragment that we're going to code
against and here's the test we have we
load the page using the browser get call
and then we execute a new client action
login form set user name this is this
part inside the client action is going
to run on the client this is exactly the
same as we saw on the graphene test
earlier the new bit is at the end we
call verify new check user name pardon
me check user name is a class that's
going to have an assertion that we want
to run on the server that's going to get
serialize and sent to the server
finally ever assertion that we contain
that that we can find a browser list
element with a text welcome so let's
look at what that check user name is
it's a server assertion that runs on the
server in container so we can use the
app inject annotation here we're
injecting this credentials object and
then we can say we can set our
assertions throughout the JSF lifecycle
so we can say before the update model
value phase we want to assert that the
credentials username is null then we can
say after update model values we want to
serve that credentials that you get
username is demo part of it
so here we can see we're asserting on
the server that the login action has
worked we've updated our backing beam
with the value as expected from the
browser
so we have a dummy with that skip that
combo I think we have example do we yeah
does anyone know how we run for time we
have four minutes left okay quick run so
right so if we go ahead we take a look
in a warp test our Killian Herculean
that class is our runner I'm just gonna
because I've been wanting to show you
guys this all day I'm actually going to
debug this test and show that we can
step through this real quick so debug as
jaina test and if our server we're
running in debug mode we could actually
debug both sides at the same time which
is really cool so here's login to JSF
and we hit our breakpoint I lost my code
but we can see that we're we're sorry
about that we're now broken and we can
step through line by line wide if you go
to the ground at this point you'll see
the browsers waiting yep just sitting
here waiting for us and that's handy too
you can in the middle of the test set a
breakpoint in the job and he can go
using the browser web tools inspect the
Dom elements interact JavaScript did you
finish that degree oh I was I was off
while I was talking Tory and I lost J
unit
to go it's nothing like running Eclipse
in a 1024 resolution there we go login
page test green bar oh yeah green bar
okay so I'm going to end with some
mentions on best practices for reducing
your development time turning around a
couple questions along that theme today
first is we want to use a remote
container
it's arquillian has a capability using a
managed container firing up the
container every time before running the
test suite but as you're developing
doing a quick turnaround on writing your
tests you're going to find that waiting
for the server to start up is a bit
cumbersome cumbersome good weird so use
a remote container the server is always
running we just deploy to it and remove
the deployment second yeah and you can
use a reusable browser session so look
at the selenium server from project that
allows us to reuse a browser between
tests now save the time of starting up
and shutting down the browser finally be
go not finally but beat also be sure to
use string rack micro deployments it can
be pretty tempting to just take your
entire application archive deploy it and
write your on your test against that but
you're going to notice it's going to
take too long to deploy you're not going
to be able to write as many tests not
going to end up running as many tests
but take the time to be able to parcel
out just the classes the pieces that you
need to create a micro deployment and
improve your test turnaround time there
and lastly you can look at the
arquillians a rebel extension this lets
you redeploy a war to the server the j
rebel way where it's only going to
deploy the changes and so you can really
quickly achieve improvements in your
deployment turnaround between your
shrink-ray archives has you run between
different tests and it is this the end
absolutely not
this is hopefully the beginning of your
TF testing adventure with our Killian
selenium graphene webdriver you know all
this good stuff we've been showing you
right now so it's Creative Commons
presentation these friendly people let
me use the graphics in my presentation
give credit to them here's some
additional resources where you can look
sample code is on github slash belief um
it's actually called testing JSF not
graphene test and finally it's a little
late now but these are the other
achillion sessions at JavaOne if you
haven't checked for any of them are
still not run be sure to check them out
and some links to how to stay in the
loop project websites for both are
Killian and rich faces guess I could
have put forage up here as well JBoss
forge forward slash forged feel free to
come and speak to us anytime throughout
the rest of the comments we want to know
any more of this</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>