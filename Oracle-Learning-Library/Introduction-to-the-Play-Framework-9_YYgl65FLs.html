<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Introduction to the Play Framework | Coder Coacher - Coaching Coders</title><meta content="Introduction to the Play Framework - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Introduction to the Play Framework</b></h2><h5 class="post__date">2013-01-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9_YYgl65FLs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right welcome everyone thanks for
coming thanks for being here so early in
the morning hope you had a fun night
last night with whatever you did
so I'm James Ward I'm on the Java team
at Heroku and this is an introduction to
play framework
who here is used play for ever before ok
awesome
good so for those of you that have used
it this is definitely going to be an
introduction I'm going to do some live
coding and go through kind of the the
basics but for those of you new to it
should be should fit really well in the
live coding it's going to be like you
know actual real-deal live coding and
massive pair programming so it's early
it's going to hopefully get our brains
moving and when I make coding mistakes
you can let me know so let's start out
by talking about some some trends in web
applications if you're at the web
framework smackdown you probably heard
me talk about these but for those of you
that weren't let's go through them so I
think there's there's four major trends
that are changing how we build our web
applications and play framework is
really about creating a new web
framework that embraces these new models
of how we build our web applications so
the first one is this move from
synchronous and blocking to asynchronous
and non blocking and why this is
important is traditionally our web
applications have been request response
request response the problem with that
approach is that we always have a stale
copy of the data on the client and this
creates a problem for many different
scenarios and so what we want to do is
have a more efficient way of pushing
data out to the client in real time and
the reason why we haven't seen this
rapid we haven't seen this used in a lot
of web applications we see it in things
like google docs we see it in awesome
applications like Trello this just that
the client should always have the latest
data right it should be fed to it
automatically in real time doing this in
a scalable way has traditionally been
very hard especially on the JVM because
a lot of the Java web application
frameworks and containers they have a
thread per connection
limitation and so what this means is
that we can only support you know maybe
200 300 maybe more depending on how much
RAM you want to throw it something that
many concurrent connections on a box and
so we could do comment and have some
different ways to deal with this really
what we were going to get to is
WebSockets and the ability to push
things whenever we want and not have
this thread per connection barrier and
so Java ni o and then libraries like
Nettie on top of that help us get around
this and of course Play Framework is all
built around the ability to do
asynchronous requests and not have the
thread per connection limit and being
able to do WebSockets as well the next
one is a move from server-side rendering
to a client-server model and this really
started with Ajax but now is is really
going on to the next level we're really
beginning to build web applications in a
totally new way well I guess it's not
totally new we've kind of been doing it
this way for a long time back in the old
days of client-server where we have a
distinct separation between the client
and the server
everything about the UI happens on the
client there's a way to contact to
connect from the client to the server in
the new world we're not connecting
straight to a database usually we're
going through some restful api layer
usually talking JSON to the server and
then that API could be reused across
mobile clients across API consumers
across web applications so this is the
the new way of building web applications
it supports scalability which is the
next one so the next one is this moved
from vertical scalability where we just
try to throw more RAM and faster
hardware at something until it works to
to being able to scale horizontally just
add more nodes when we need them and to
do this we need a stateless web
framework and Play Framework is a
stateless web framework if we do need to
have state across request in an
application we need to actually put that
in an external tier external to the web
tier so see yeah so that's how Play
Framework handles scalability and then
the next one kind of related to a lot of
these is
this move from what's an API or maybe
even you know soap back in the day to
thinking about api's first and building
applications by starting with the AP is
that you want to expose on the back end
and then letting people build UIs on top
of that whether they're mobile or web
applications built with JavaScript but
thinking about our API is first so Play
Framework is is really well catered to
addressing all four of these new trends
that are changing how we build web
applications so let's talk about a
little bit what is Play Framework
actually so this is their definition on
their website mine is just a little bit
simpler lightweight stateless web
friendly and for highly scalable
applications so that's really the most
important parts of it so this is kind of
a snapshot of the major components of
play framework with Play Framework we
can write our code in Scala or in Java
Play Framework two they actually rebuilt
the whole core of play framework in
Scala so underneath the covers play
framework is all built in Scala but as a
developer using play framework we can
write our code in Java or Scala if we're
writing the template server-side
templates then the default template
includes that we use when in our code in
our server-side templates is Scala
but they have modules where you can plug
in other templating language as well so
you can plug in groovy or Scalia or
others and then play framework also
built on top of akka so akka is at the
core of how Play Framework handles all
of its concurrency and so then you can
also as a developer use akka either from
Java or from Scala and hook into the
whole akka system their support for
WebSockets I mentioned that asynchronous
IO and then play for mark two I switched
the build system from being a custom
build system to using the Scala build
tool SBT and so now everything that you
do through the command line all the
dependency stuff in Play Framework all
that stuff happens through SBT so real
quick my top ten favorite features I'm
going to go through these but you're
actually going to see all these once we
get into
LiveCode so first thing is that it's
simple I love the simplicity of play
framework it's it's not it doesn't have
you know all the the features that like
something's been around for a long time
has select APIs tree and JSF you know
these things have very very wonderful
and exhaustive component systems to
build your applications Play Framework
really stays pretty lean and then you
need to decide things like how do I
build my my UI from components if you
want to do that then second one is
declarative URL routing we'll see that
in a few minutes automatic class
reloading this is probably one of the
things that that is most immediately
wonderful for most java web application
developers we'll see what that looks
like in a few minutes sure nothing are
stateless and then Scala or Java support
great testing support I'm going to show
you some of the testing stuff JPA e-beam
support assist allows us to do
relational database persistence they
also have modules that will allow you to
easily connect to no sequel systems like
MongoDB or others and then niño through
Neddie ni o is what allows us to get
away from that thread per connection
limit and so all of play frameworks
requests are handled through n io so
this allows it to take a thread that's
been given to a connection and when that
connection is idle it can actually
reclaim the thread use it for somebody
else
and then as soon as that connection
needs to send data then it can give the
thread back so this is a really
efficient way it allows us to scale much
more easily the next one is the asset
compiler the asset compiler is really
what enables us to have a great workflow
when we're building these client-server
web applications it allows us to compile
CoffeeScript in JavaScript and less and
I'll talk more about that later
and then last of course because Heroku
is awesome
we can instantly deploy Play Framework
applications to Heroku and we'll see
that at the end ok so let's just dive
right into some some real live stuff
here so I'm going to get started
building a new play framework
application from start so I'm going to
hop out here
what I've done to get to the point where
I'm going to start is I've gone to play
for a morgue I've downloaded the play
framework zip file and extracted the zip
file and where that extracted to you is
let me show you in my play 20.4 is the
latest into this directory so this is
just the contents of that zip file there
you'll see that in here is this play
executable also played out that if
you're on Windows and then I've added
that play command to my path so that was
all the setup that I had to do to get
started with play so now I can just run
that play command so I can say play new
and create a new play application so
we'll call this one foo bar I'm going to
create a little application that's going
to let me to track the best bars around
Java one so we'll call it foo bar and
then I can choose I'm choosing not the
language that I'm going to program in
because I can use either at any time
what I'm actually choosing here is the
template application that I start with
so I'm going to start with a java
application and so now what I have is a
foo bar directory so this now contains
my play application if we look in here
we'll see there's a couple directories
we'll see more of the structure in a
minute but I'm going to be using
IntelliJ there's also great Eclipse
support so let's actually do the
IntelliJ file so I just run play idea
and this will generate my IntelliJ
project stubs and so there's support for
your eclipse or you can also just use VI
VI is my own personal favorite IDE it
works great as an IDE for play framework
but just so that we can navigate through
the code a little bit easier we'll use
intelligent ok so I've got my project
created so let's go open it here in
IntelliJ and that's in my desktop and
then foo bar so while that's opening up
let's actually start up the play server
so play comes with its own server
that's the nettie server so you don't
usually create this into a war file and
deploy into a container most of the
world has decided that that's a bad way
to deploy web applications that it's
better to
have your container or have your thing
that is handling HTTP requests actually
just be part of your application and so
that's what play does it has its own
nettie server so to start that we just
run play twiddle run the twiddle run
what that does you can also just do play
run the twiddle run it will actually
watch the files in my project for
changes and whenever those files change
it will automatically recompile them if
you do it without the twiddle then it
will not recompile until you actually
hit reload in your browser so so for me
it's a little bit easier to do twiddle
run because then by the time I get to my
browser and hit refresh my changes have
already been recompiled okay so I'm up
and running on port 9000 so let's just
go up to the browser and load localhost
9000 so now it's going to compile the
the files in my project and then it will
display the documentation for how to get
started with play so all you have to do
to get start with play is download the
play zip create a new application play
run and now you get the documentation
I'll tell you where to go from there so
great my application is ready let's go
check out what this looks like here in
IntelliJ so there's a few things let's
walk through the pieces of this
application I just made a request to
slash so play has this declarative
routing where it's income for out we say
alright we need to to map these HTTP
requests to some code that's going to
get executed to handle the requests and
so the routes file is where we do that
and play is really it's not trying to
hide the HTTP protocol from us it's
trying to work with the HTTP protocol
it's really directly exposing the HTTP
verbs the HPP pass and so that we're not
fighting against the HTTP protocol and
this allows us to have pretty URLs it
allows us to work better in a stateless
way so here's our routes file you'll see
that we're handling a get request to
slash and that's going to controller's
application and then calling the the
index method so let's go find that so
app is actually our main source
directory here and
then inside here we have a controllers
package and then an application class so
this application class it extends
controller and then we'll see in here
that it has this public static result or
index method that returns a result and
what this method is doing is it's saying
returning ok ok is actually status code
200 so again they're not trying to hide
the HTTP protocol HTTP protocol from us
they're trying to help us work with the
HTTP protocol and so we're returning ok
and then we're calling index dot render
and passing it at a string so where that
comes from is this is our templates our
server-side templates so if we look in
the views directory we'll see that
there's this index khalid HTML and this
is our template that's actually being
called so our templates are getting
compiled down into into code and then
you'll see that the first line here is
the parameter that this template takes
so we're taking a parameter of string
and then we're calling another template
here main we'll see that the code for
that one is in main scala HTML and so
this is where the the basics of our HTML
page come from this one takes two
parameters a title and a content block
you'll see the title is getting used for
the title of the page content is getting
shoved into the body so now if we look
back here at index dot solid HTML this
is actually that main template but
taking two parameters the first
parameter is the title and then the
second parameter is the body so then in
the body we're again using another class
the play to welcome template and this is
what's actually displaying the the
documentation when we went to localhost
9000 is this this play to welcome so
that's that's really all the that's
there for this application we'll start
making some changes to this so you can
see how all this works so first let's
remove the the play to welcome message
and just display the message there so I
just go back to my browser and hit
refresh and automatically play his
recompile my changes and I'm seeing them
there so but we can also do that for our
controller so if we go back into our
controller here and we make a change to
the string that's getting passed in
let's say hello Java one and save and
then reload and there we go we see that
change so automatically the Java code is
getting recompiled you don't have to do
the whole rebuild war files redeploy
restart tomcat kind of stuff just gets
automatically recompiled for you okay
one other thing I wanted to point out
here is that this method here is static
this method that we're calling in this
controller is a static method and you
know we're taught that static methods
are bad because they're not testable and
and so forth but here we're using static
methods for a very important reason I
don't think they necessarily technically
had to be static but play framework
really wants you to think about this
controller as being a stateless object
because the HTTP protocol itself is
stateless you make one request you get a
response you make another request you
get a response there's no connection
between those requests what we've done
in a lot of web frameworks is we've
we've kind of simulated state by passing
a cookie with each request and then
having a session store and so Play
Framework shows all right that's that's
not part of HTTP itself so let's not
make the developer think that that's the
way the HTTP works so instead they say
alright these are static methods there
is no state between requests if you need
state between requests you you need to
do that in an external data store so if
you want a really fast data store use
memcache and then have an external
memcache service that you can use across
multiple instances that's that would
give you a place to store state across
request ok and just because it's static
doesn't mean it's not testable we'll
talk about testing later but there is
great testing support for testing all
this stuff the controller methods and
everything ok so we've got our basics
let's go make a quick little tweak to
the routes file just so you can see how
that works I've got my routes file I'm
going to just add in a new route so I'm
going to add in a route for /foo whoops
/foo and save and then all I have to do
is go to my browser of course and go to
slash foo and you'll see that the same
thing of course works so I can go in and
change my routes it's getting recompiled
underneath the covers
for me whenever I make changes just like
my Java code and my templates and
everything else so so that's the routes
file and how we make changes there so
let's hop back and see where we are so
we've created our new application we've
gone through the routes and the basics
there we've gone through our controllers
and our views so now let's hop into
testing and talk a little bit about
testing so the testing in Play Framework
2 is based on j-unit and it supports a
variety of different ways to do tests so
you know we're used to having maybe one
way to test our web applications using
selenium play framework they've done a
really good job of letting us do tests
in a number of different ways we can do
unit tests with mocks so they did a
great job of creating these like mock
applications and mock requests that we
can use to to do testing and then we can
do functional tests we can actually test
our templates we can test our
controllers we can test our routes file
we can test we can actually start up a
Play server and do actual integration
tests against that server we can do UI
tests with selenium so there's a really
wide range of ways that we can test our
play applications so let's take a look
at a simple example here for for how we
would do a test and I'm going to copy
and paste this part let's create a new
test so I'm going to create in my
project a new folder named test and
let's create a new Java class called
application test and then let's just
paste in that boilerplate stuff there so
now I can write some tests so let's go
see what test we will write so first
let's let's just test that route so we
created that new route flash foo let's
create a quick little test that will
test that route so I'm just going to
copy and paste this one in and here we
go we've got a test again using the
g-unit annotations there and we're going
to say route M call we're going to
create a new fake request we're going to
use the get HTTP verb and we're going to
give it this path to slash foo
and then I can do my tests on the the
result that I get back and so I'm going
to just test
hey assert that the result is not null
right okay so we've got our test let's
run it and make sure that it passes so
to do that we can just run play test so
this will run all of the tests for my
application and and it will compile them
and we'll see the output here so we see
that all right great
we had one test and it passed cool
there's another way to run the test
which is what I do a lot when I'm doing
play development is I run play twiddle
test and just like the play twittle run
what happens is it will just it'll run
the test and then it will sit there and
wait until I make changes to files and
as soon as I make some changes to any
files it'll recompile the changes and
then rerun all the tests so let's let's
give that a try let's let's go and
actually let's break our test here let's
remove let's change this route to food
ok and save and then we should see its
recompiling and now it should rerun our
tests and hopefully our tests will now
fail once we've recompiled so there we
go we got our failure because that
result was was null ok cool let's go fix
that so our tests are not failing we
don't want to break the build ok ok so
so that's a basic test of a route
there's a lot more that we can test we
can test controllers so there's really
great support for being able to to to
call basically your controller method so
this is what we'd be doing is saying
call an action and we tell it which
method we want to test in the controller
and then it's going to return a result
as if we made that actual request like
we were doing before and then we can
test all sorts of things on that we can
test the status code we can test the
content type we can test the char set
the we can actually test the contents of
what comes back in that result so this
gives us a really great way to test our
actual controller logic without having
to start up a server without having to
go through all that overhead we can test
templates directly so because
the templates are compiled into code I
can just call that index dot render
method the same method that I was
calling from inside my controller and I
can just call it directly and then get
content this content object back and
then I can do tests on that content
object so many different levels of
testing and then we could go beyond this
as well we can start up there's a way to
start up a local server and do tests
against that there's a way to use
selenium to do actual UI tests as well
so lots of different ways to do our
tests in play framework I was saying
last night at the web framework
Smackdown that I'd always heard that TDD
was a good thing to do but it always
felt like it was it wasn't really doing
much for me because there's a lot of
overhead and most frameworks to actually
do TDD play firmer because the first
time where I've actually done TDD
because because it's actually helping me
be more productive and write code faster
so I've been really pleased with the
testing support and play ok so now let's
talk about database persistence so play
framework in Java we use eb n-- as the
way to do relational database
persistence
so even is kind of like JPA you'll see a
lot of similarities it's play for mark 1
was using hibernate and JPA underneath
the covers now I'm play from R 2 they
switch to eb n-- but pretty similar
programming models we still use the JPA
annotations one of the really nice
things that play does for us that i saw
is actually going to be in the JPA 2.1 I
think jjp a 2.1 spec now is it gives us
these versioned
sequel scripts and these are really
important what we want to do continuous
delivery of our application is this
ability to have version scripts that
allow us to move from one version of a
database schema to another and so if
you're doing production applications you
probably are having to do this possibly
by hand play framework just has this
concept of database evolutions just
built into it so it makes it very easy
to do so let's actually check out how we
would do some persistence and into a
database here so first we need to
configure a few things in our
application there's a central place in
play to configure the application it's
in the application
comp file and if we go down we can see
where we set up our database
configuration so I'm going to say all
right for my default data source use
just h2 the in-memory database and then
I'm going to tell I beam to say all
right look for your your models look for
your eb nasa's in the models package
okay so that's the first step is to do
the configuration now we want to
actually create a model so to do that
let's go in here and create a new java
class this is going to be models dot bar
so remember i'm storing my list of
favorite bars so this class bar will
extend model and this will be the play
DB DB model class and then I'm going to
annotate this class with at entity so
this will be the the JPA at entity so
let's import that now in here I'm going
to use a ID again the JPA a ID for the
primary key and then let's do public
string and we'll give it an ID and then
let's do a public string for name okay
you'll see that I'm not doing the getter
and setter thing if you want to do
getters and setters that's up to you I
prefer usually just to do straight
properties because underneath the covers
it's going to do the getters and setters
for me but you don't have to do them if
you don't want to okay and you can
always start with public properties and
then switch to getters and setters if
you want okay so I've got my model let's
go just reload this application so we
reload the app we'll see that play
framework says hey I noticed that you
have a new version of your database
schema and I am asking you do you want
to change your database to go up to this
new version and it's even telling me
what the sequel that it's going to run
is so it's creating table bar with
column ID and name and primary key and
setting up a sequence I say all right
apply this script so there we go so now
my database is in a consistent state but
let's see what actually kind of happened
underneath the covers here you'll see
that this new directory just appeared in
my comp directory it's evolution slash
default and so this is where all of my
versions of my sequel are kept
and so this one this first version is
auto-created for me so this takes my my
being my model definitions creates the
first version of my schema for me
consecutive versions the ones after this
I'm going to have to manage manually so
I would create two dots equal and every
one of these has an ups part of the
script and a downs part of the script so
the ups are how do I get up to this
version downs or how do I get down from
that version okay so you'll see that the
downs in this case is just dropping the
table so that's what it's actually doing
to do the evolutions is these versioned
scripts for for the database sequel okay
so we've got our B in we've got our
configuration we could even write a test
to test this model so there's a way you
can run a mock database and in-memory
database they can say alright you know a
running fake application now that should
say bar in this case but you get the
idea it's I can test the model actually
with a in-memory database so this is all
just integrated into the testing stuff
you already saw okay so we can test that
model so we've got our model now we want
to have a way to add new bars and so
what we need to do is take an HTTP
request with some parameters and then
create a new bar from that so to do that
Play Framework has this thing called
forms forms are really the way that we
map from HTTP request objects to the
actual value object in code and then we
have that that happens in the controller
in the view side in our server-side
template there's some helper tags that
we can use that will help us create
forms if we want to use those as well so
let's build out a little UI that will
allow us to add new bars so first let's
go and add a new controller method here
so in our application let's create a new
public static result and this one will
be called add bar and then what we want
to do is we want to get the request and
in create a form
so I'm going to say a form of Barre
class just bar there and we'll import
that and this will be my form this is
going to be equal to I'm going to create
a new form here's where I do bar dot
class and then I'm going to say bind
from result or request so I'm going to
bind the data that's coming in from the
request into this form and let's import
that bar there we go
so let's get to me in my form the form
is also where I apply my validation
logic so if I need to validate some
input coming in I would do that in a
form and I'll show you some code for
that in a minute
and then to get the value object out
what I do is I say let's get my bar so
I'm going to say bar equals form dot get
so this gets me my bar and then because
I'm I've extended that model class in my
bar there's a few convenience methods on
this thing so I can just say bar dot
save save my bar into the database and
so now it's saved now I could do
whatever I want with the UI in this case
when the bar gets saved I'm just going
to do a redirect so I'm going to return
a redirect and I could I could give it
just a string URL to redirect to but one
of the really cool things that played us
with the routes file is because that
routes file is being compiled it's also
compiling a reverse routing table so I
can have type safety for for all of my
anywhere I use URLs I can have type
safety there so I'm never going to
actually hard code URLs into my code I'm
going to instead use the reverse routing
so that if I go and refactor my URLs
it's going to automatically change
everything in my application ok so let's
do that redirect so this is going to be
the routes application dot index so I'm
going to redirect to the index page ok
so I've got my ad bar method in my
controller now I need a way to expose
this method so I go to my routes file
and I'm going to add a new post handler
so this time it's going to accept the
post HTTP verb and I'm going to do it
for the slash bars path one thing to
mention about the pass here is
you can do some parameter substitution
and all sorts of fun things with the
bread jacks and stuff in these paths so
to build like restful style URLs you can
do that very easily in this case I'm
just in the simple stuff okay
so we've got the application controller
and I'm going to call the ad bar method
on that okay so I've got my route now
the next thing to do is create a simple
little HTML UI that allows me to to
actually add bars and call that thing so
let's go into our index dot scala HTML
and here i'm going to use the helper
there's a helper class here helper dot
form to create a new form and i'm going
to set the action equal to and again I
don't want to use a hard-coded route
here hard-coded URL I want to use the
reverse routing so I'm going to say this
is going to be coming from routes
application dot add bar okay and then
inside this form I'm going to add in
here an input we'll give it a name of
name if I look at my bar has this name
parameter so this is how the form object
knows how to bind a request parameter to
a field in a value object is just
through naming we can override that if
we don't like the default but we'll
stick with the default so my input is
name and then I have an input type
submit okay so that's my form so let's
go try it out let's go back to the
browser and let's go to just back to the
index method here so I've got my form
let's try to add in a new bar and submit
I think that that worked so I hit submit
and it redirected back to the index page
so I didn't get an error so that's
that's a good thing it appears that it
saved this new bar into the database so
we'll see if that's actually working in
a little bit but that's how we can
create the the form that map's the
request parameters the the UI through
the form helpers and set up a route to
handle the post request okay okay so
next up let's we've got our we've
created our route we've done our view so
that's all good so next up let's create
a way to get our ball
hours out of the database and I'm going
to do this more in that client-server
fashion where I'm going to get the data
out is JSON and then I'm going to use
JavaScript on the client to actually
request to make that request underneath
the covers to get the JSON and then
display the data so to use JSON it's
it's very simple let's go back to our
application controller here and create a
new controller method so I'm going to
make public static again returns a
result this one is going to be called
get bars and now I need to get all of my
bars out of the database so eben has
pretty cool way to do finders so what
I'm going to do is I'm going to say all
right I need a list of bar let's import
java.util list and that's going to be
equal to a new model dot finder and then
IntelliJ for some reason doesn't like
the the syntax here so let's clean that
up okay the first parameter of model dot
finder is the primary key type so this
is going to be string class the second
one is going to be the actual value
object type so that's going to be bar
dot class and then I can just call dot
all to do a fine bye all I can also of
course set up finders that will do more
complex queries and there's a lot of
different ways to do that very JPA ish
okay so I've got my bars now I want to
take these bars and I want to return
them as Jason so what I'm going to do is
I'm going to say return okay so status
code 200 everything's okay and now I can
return the actual Jason so I can just
say to Jason and give it that list of
bars now I do need to import this so
let's go import static import method
there we go okay now last thing to do to
get this working is set up a new route
so let's go here and copy that one this
time it's going to be a get handler for
slash bars and it's going to call get
bars okay
okay save and let's go to slash bars and
now the moment of truth did my bar save
if we see some Jason there we go yep so
it worked so now it's just returning my
list of bars as serialize Jason okay so
I've got my Jason let's go let's go test
and make sure that this is
all working well so let's go add in a
new bar called foo and then go to slash
bars now we see both of those bars are
there okay okay so we've got the jason
that's great so the next thing we want
to do is have some client-side code that
makes your request to get this JSON and
then renders the bars on the page and
I've one of the things I really like
about play framework is this new asset
compiler what it does is it takes you
can do JavaScript CoffeeScript or less
and you can actually kind of make it
part of your source code even though
it's running on the client side you
actually deal with it and work with it
like like it's normal source code so
it'll actually compile the CoffeeScript
into JavaScript it'll auto minify
javascript it will run JavaScript
through the Google closure JavaScript
compiler to tell you if you have any
syntax errors in your JavaScript so so
this is makes this experience of
building out a client-server type of
application very nice because I'm
working in the same environment getting
the same experience for both my
server-side code and my client-side code
so I guess I haven't even showed this
part yet but if for some reason I make a
coding error in my in my code and I go
back and hit refresh play is going to
tell me about the this coding error so
we see the the compliation there in the
browser the we would see the same type
of error if I made a mistake in my
CoffeeScript or JavaScript so it's all
integrated and whether it's compiling
the client-side code or the server-side
code it all works the same okay so let's
go fix that okay oh and this this
message is cool it actually tells us
like line number and stuff so it's it's
really a great way to diagnose our
coding problems I'm using a IDE so
usually I don't see the compilers in my
browser because I've already discovered
them quick question yeah yeah that only
happens in development mode good point
so this only happens when I'm running
locally in development mode when I run
this in production mode the user would
just see err something and then it would
actually log out the details of the heir
in the log boat but the
you end-user would would never in
production mode see that air good good
question thanks for the clarification
okay so let's write some CoffeeScript so
CoffeeScript if you're not familiar with
it it is it is a way to write JavaScript
it is kind of this new cool thing what
it does is it compiles down into
JavaScript and it adds some nice
syntactic sugar and cleans up a lot of
the the nastiness of JavaScript so to
create a new compiled something that
will be compiled what I'm going to do is
create a new package and this is going
to be called assets dot Java scripts so
that's my package and now I'm just going
to put my CoffeeScript my JavaScript my
less put all that in this directory and
less less is like CoffeeScript for CSS
so it's a language that compiles down
into into CSS okay so now let's create a
new file I'm going to call this index
dot coffee so index coffee now this is
my CoffeeScript so I'm going to write
some CoffeeScript I'm using jQuery here
to actually make this request this Ajax
request to get that Jason I'm going to
use jQuery to to then render the the
objects that I get back on the page so
jQuery the way that we call that is with
the dollar sign and then the way we do a
callback is with this this arrow and so
what I'm doing is I'm saying alright
jQuery when the page is ready call this
code Jake
CoffeeScript uses whitespace as a way to
to do our blocks so what I'm going to do
is I'm going to say all right jQuery now
when the page is ready make a request to
slash bars now you'll notice that I am
hard-coding a URL here because this code
is actually not going to go through the
same compiler that the server-side
templates are going through there is a
way to actually take your reverse routes
and put them into a page in a JavaScript
variable in a server-side template so I
couldn't go that route but it takes a
few more steps so I'm just going to do
it the quick and easy way and just put
the URL in there for now and then I need
a callback function so the callback
function takes a parameter called data
and what I'm saying is are
I'm getting back some data this is going
to be my array of my bars so now I need
to iterate through this data so I'm
going to call the jQuery dot H and say
all right for each of these things call
this callback function so the callback
function takes two parameters and index
and then the the actual object and then
in this for each of these what I want to
do is I want to render each bar on the
page so what I'm going to do is go back
to my index page here and I'm just going
to add a little placeholder here I'm
going to put in a ul give it an ID of
bars and now back in our CoffeeScript
what I'm going to do is I'm going to say
all right jQuery find that bars ul so
that so that's the way the in jQuery
that we do a find in the the page for
this element with the idea of bars and
now I'm going to say append into that
thing a new list item so I'm going to
create a new list item and I'm going to
set the text on that list item to bar
dot name so if we look at our j8 our
Jason let's go back here and look at our
JSON we'll see that there's a bar
parameter or a name parameter on each
bar so that's how I'm getting this bar
dot name is just saying all right the
name parameter on each bar put that into
a list item so very simple let's let's
give it a try
did I do everything right oh no oh
forgot one stuff okay so I've got my
CoffeeScript but I need to actually load
this this into my page now so so to do
that we need to go back into our index
page and what I'm going to do let's take
out that message for now I'm going to
add in a new script and set the the
source of the script now the source
means the single quotes a little bit
prettier the source there's a way to
actually again get a reverse route to
the place where I can get this index
compiled index CoffeeScript file from so
what I'm going to do is I'm going to say
dot assets are sorry assets dot or sorry
not that routes assets dot at and now
I'm going to tell it which file I want
to get so I'm going to say get me the
Java scripts slash index dot min
dot J s okay and then let's close that
tag so what's actually happening is Play
Framework when it compiles that index
coffee it's actually creating the index
J s and the index min dot J's files so
it's creating those for me it's putting
those into a location where it can get
these static assets from so these are
compiled when the play compiler runs so
if I save that go back to the page and
hit refresh then once everything
compiles there we go so now I see my
form and I see my very ugly UL with my
to list items in it which are each of my
bars and of course I can go in and and
add add a new one in Joe's bar right so
when I do that submit its of course
doing a page refresh it's doing the post
and then redirecting back to the index
page but once this page loads it's
loading that compiled coffee script
making the the Ajax request for the JSON
and then rendering each of those
elements into the UL okay while they're
kind of moving parts in there but I
wanted to show you the the kind of
different ways that you can do things in
play framework you can just do all
server-side templating and not have any
Ajax and jQuery or you can go the other
direction completely and do everything
on the client side and use the asset
compiler do CoffeeScript and less and
all that kind of stuff or you can do
some mash of both so I think it's nice
that that that whole kind of spectrum of
options okay so that's the client side
so now a quick a little bit about form
validation to do form validation all we
have to do is add a constraint to our
model so we say at constraints and then
put the constraint on there so we could
say it's required has to be a phone
number or whatever we want to do for the
constraints and then in our controller
instead of just doing form dot get like
I was doing what I do is I check to see
does the form have any validation errors
if so then do something maybe we want to
re-render the form with the actual
errors displayed in the form and there's
some if you're using the helper
functions for forms in the server-side
templates then it makes it really easy
to render like required you
missing fields those sorts of things and
then if if everything's okay then I
would just do the normal form dot get
pull the value object out do the save
and that sort of thing so a formative
validation is also very easy okay so
we've got our application it looks
awesome and we could of course take this
to the next level and make it look way
better but this is kind of developer art
at this point but now we want to deploy
this application and so we're going to
get this application production ready
and then deploy it on the cloud with
Heroku so to do that one thing is I'm
going to be using Postgres as my
database on the cloud so I need to come
in and add a new dependency into my
application so if I go into the project
build dot scala and then application dot
build here what I can do is I can i can
put dependencies in here so this is
using SBT syntax for defining
dependencies you can of course add any
dependencies that are in maven central
or in the type safe repo here so we've
got our dependency for Postgres then I
need to do one other thing I need to
tell my application that when it starts
up to run in production mode and use
this production Postgres database as as
the database to run under you'll see
here that what I'm going to do is I'm
going to create a new file called a proc
file so let's actually just go create
that so new file called proc file so the
proc file is something that Heroku uses
to tell Heroku what what command to run
on the system to start up this process
so if we go back and look here let's
just copy and paste this in so this is
saying that for the web process run this
command target slash start you may be
wondering where does target slash start
come from if you from the command line
run play space stage what that does is
it compiles the whole application into a
version of the application that can be
run in production mode and a part of
that compile process it creates a script
which is target slash start that sets up
the class path and starts the Play
server in production mode and then we
can pass some additional parameters
we're going to tell what port to listen
on using an environment variable we're
going to tell it to apply the database
evolutions automatically we're going to
tell it to you
the Postgres driver tilt the the
database URL to use there from an
environment variable and give it Java
ops okay so that's my proc file so now
we're production ready we're ready to go
so what we want to do is is deploy on
the cloud with Heroku so I'm going to
walk through this real quick and then
I'll jump back and explain a little bit
about what Heroku is but basically a
short story Peru is a place to run your
JVM and other applications on the cloud
so let's to do this what we need to do
is create a new git repository so one of
the ways to deploy to Heroku is that you
put your stuff into a git repository and
so let's do that we have we've created
our git repository now let's add our
files to the git repository so I'm going
to add in here everything whoops
dot so let's see what's being added so
we look in here and we see alright I've
got my proc file I've got my index
coffee I've got my controller my model
I've got my templates I've got my comp
file my evolutions my routes and the SBT
build stuff there and then I've got just
the default static assets and I've even
got my tests so all that stuff does in
my get repository so let's commit it so
just say commit minus Emin it so now
everything is in a git repository and
now I'm ready to go up to Heroku but I
need to tell her oku all right create a
new application for me on the cloud so
to do that one way is through the
command line I can say create a new
application so I've already logged in I
already ran Heroku log in from the
command line so it logged me in and so
now when I run Heroku creatin knows who
I am and it's now creating a
provisioning a new application for me on
the cloud so an application has an HTTP
endpoint and I can of course put my own
domain name at this as well and it has a
get endpoint so now to upload my
application to Heroku and run it on a
cloud all that I have to do is upload my
git repository up to the git repository
on Heroku so let's do that
I say git push Heroku master so Heroku
is the name for this git remote and then
mastery is the branch that I want to
push so now this will push up my source
code up to Heroku and this is just one
way to deploy you can also do war
deployment and stuff you'll see that
that upload
happen very quick so just 38k to upload
because i didn't have to take all the
dependencies and and pull them down to
my machine and then upload everything up
to Heroku I'm just uploading the source
but now Heroku is actually running the
SBT build on this project it's running
that stage tasks that's going to create
that target target start script and and
then deploy out onto what we call it
dinos is the place where the
applications run so it's going to take a
minute to resolve all the dependencies
luckily this is running on the cloud so
that's happening pretty fast but it will
take a minute to to actually run through
and resolve all the dependencies and
then compile my application and then
deploy my application the big long
compile with all the dependency
resolution that just happens the first
time subsequent deploys don't take as
long as it won't after we download all
its dependencies okay so a quick little
intro to to Heroku while that's while
that's working so Heroku it's a cloud
application platform platform as a
service provides a place to run Java and
Scala and Play Framework apps and nodejs
and Python and Ruby all that stuff on
the cloud and then we have this concept
called add ons so anything you want to
do kind of external to your application
tier happens through an add-on so the
Postgres database when I created my
application I got automatically
allocated a Postgres database that's
just a Heroku add-on we also have
add-ons for like MongoDB for neo4j for
for all sorts of different no sequel
options memcache for other relational
databases like my sequel so lots of
different options that you can do for
persistence through through add-ons so
I've showed the the way to deploy
applications through git we also have an
eclipse plugin we have or deployment you
can find out a lot more about that at
hurricane accomplice Java if you're
interested in the other options also if
you want to be able to follow these
steps on your own
there's tutorials on the Play for in the
Play Framework documentation on how to
do what I just showed okay so let's see
how we're doing should be almost done
compiling and deploying application
compiled okay great so SBT is run so now
what it's doing is it's saying hey I saw
that you declared a process type on
web great it's created a slug file the
slug file is all of the dependencies
that my application needs it's all my
compiled code so everything that my
application needs to run goes into the
slug file and then it deploys this
application out onto this domain so if I
go to the pure ocean 1497 domain there
then it should start up my play up and
then we'll be running up on the clot so
this is you know live on the cloud
anybody could go to this URL and start
using my application that starts up go
go play frame or go so we'll see if that
that loads in a second
so again this is that name pure ocean
that's just a default name you can of
course point your own domain name at
this as well hey there we go okay
there's my app again I didn't I just
started with a fresh Postgres database
so it doesn't have my data so let's
let's go make sure everything is working
let's go add in a new one cool so
everything's working on the club okay so
that's your quick intro to Heroku let's
go back here and I wanted to leave a lot
of time for questions but before we go
into questions if you want to walk
through in detail like everything that I
just did I created this thing called
play tutorial you can find it on my
github and it's just step-by-step
everything that I just did and it goes
through a lot more of the testing stuff
as well it goes through the Heroku
deployment so check that out
and then the Play Framework
documentation is really good as well so
those are great learning resources if
you want to get started ok questions
about anything I through that so
hopefully you'll find that tutorial
useful any questions yeah
it's all configured but is that okay
yeah so ii do like URL substitution what
I would do is let's create just just
create like a new route so I'd say all
right get slash bars slash let's say ID
is it tell our sign Boop
I'm forgetting the syntax now I think
it's dollar sign ID might be wrong about
that anybody know totally spacing it
anyways what this allows us to do is
take a parameter like this so let's say
we want to do like get bar here then we
can put in the ID there so this would
take that variable and substitute it
from the URL and pass it into the
controller as as a parameter this this
always is string parameter so we would
always pass in string parameters and
then we can parse those into to whatever
I think there might be some auto parsing
into like numbers but it's I don't think
it's dollar sign
totally spacing it's not star a main oh
it's totally spaced it semicolon that's
what it is that's what it is
no not semi colon colon that's what it
is : there it is okay so that allows us
to substitute one part of the URL so
then we could do like /id
slash something else the the star down
here takes everything right and then we
can also do reject reg X's here so we
could say we only want this to be able
to contain lowercase letters right so we
can put in pretty complex expressions
there we could take other parameters
after this so we could say like : foo
right and then we'd have a food
parameter that we could add into the
arguments for for our method call okay
yeah so that's how that works
yeah another question
ah yes
good yeah so I didn't go into the
asynchronous bit but there's actually
great documentation if you go to local
host at documentation annotation this is
your local documentation and if you go
into like play for Java developers then
we can see the async stuff in here so
they have really good documentation here
the way that it works is there's a few
different options one I can I can make
instead of returning just a result from
a controller call I can return a promise
of a result and so this allows me to to
not block in that call in that
controller call until the promise is is
fulfilled so that's one way to do it
and you can see some code for for how we
do that here there's there's this async
result which we can return a promise of
result then if we want to do streaming
there's a few different ways to do that
as well the WebSockets one is also
documented in here comet sockets we can
do comment sockets so I would check out
the documentation on that there's so
lots of different ways to do it
depending on how you want to implement
it on the client side is really what
this is all about so many different
options if you do the asynchronous one
the browser will actually just sit there
and wait wait until the response comes
back but that won't be consuming a
thread on the server because as long as
you're not blocking in in your
controller as long as you've actually
you're actually on a on a future and
akka so you can do that you can do long
pulling with the comet support yeah okay
other questions yeah go ahead
yeah we've got a number of very large
production play applications running on
Heroku today
I if you go to success dot Heroku comm
we document some of them I don't know if
we say in particular what technologies
they're using there but BS success I
hear calm goes through some of those
okay let's see okay two more minutes any
other questions about anything
yeah good yeah that's a good question so
the persistence options are a bit
different with plate two in Scala so the
default persistence when you're doing
Scala is called a norm it stands for a
norm is not an ORM and so they've kind
of taken this approach that the default
in Scala is kind of bare bones and and
then you write your sequel there's not
all the assistance in creating models
and that sort of thing for you in that
case I have another tutorial that's
played to with Scala and squirrel which
squirrel is a Scala ORM and makes it
really easy to do this type of
programming against a relational
database and then there's other
persistence options as well I've used
MongoDB with Scala and that works really
well as well but but the default in
Scala is enorm as far as what the
benefits are one way or another I think
it's up to you which which language you
prefer to write in there there are
things where like writing highly
concurrent code is going to be a lot
easier in Scala than in Java so that may
be a benefit for you to write your
controllers in Scala yeah okay one last
question
any other questions yeah
the sorry what is it
oh yeah yeah yeah for sure so many
people deploy the play applications on
their own stuff the the deployment
process wouldn't be obviously get push
it would be some other method of doing
deployment so checking out of a CI
server and we're pushing from a CI
server to a production server but yeah
definitely there's a lot of options for
that it's documented well in the Play
documentation for how you run in
production environments Heroku or others
okay
I hope that was useful thanks for coming
I'll be around if you have any other
questions Thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>