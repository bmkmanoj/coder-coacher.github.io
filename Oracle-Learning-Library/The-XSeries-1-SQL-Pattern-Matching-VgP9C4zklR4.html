<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The X-Series - 1 - SQL Pattern Matching | Coder Coacher - Coaching Coders</title><meta content="The X-Series - 1 - SQL Pattern Matching - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The X-Series - 1 - SQL Pattern Matching</b></h2><h5 class="post__date">2015-02-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/VgP9C4zklR4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi my name is Keith I am part of the
data warehouse product management team
at Oracle and today I'd like to talk to
you about using sequel for pattern
matching and we have three good reasons
why sequel is the best language for you
to use for doing speaker Pat matching in
your projects firstly it's rich we have
a very extensive language that allows
you to get access to lots of different
data sources it's simple so if you're
already using some of our analytical
sequel functions you will recognize the
new syntax that we've added to help you
do sequel pattern matching and most
importantly it allows you to make rapid
changes to your code to sue new business
requirements that come in from your
users so how do we do all this well
first of all probably the key part for
doing sequel pattern matching obviously
is getting access to your data now those
of you that are using oracle database
particularly 12c know that we support a
rich set of data types but in addition
to those for a lot of pattern matching
use cases you probably want to go out to
other data sources and pull some
information in from there so if we look
at a lot of big data use cases today we
see data sitting in no sequel databases
we see data sitting on Hadoop and we'd
like to obviously be able to access that
bring all that together into our Oracle
database and be able to use sequel
against it and we've added some
extensions to our external table
function so if you look at that today in
12c you'll see some important new
keywords and the two most important
keywords that are going to be interest
to you for sickle pattern matching are
things like Oracle hive as a data source
and Oracle HDFS as a data source
and these will get you access to hive
tables that is sitting on your Hadoop
cluster and also JSON style and JSON
type documents sitting on your Hadoop
cluster when we go out and grab these
types of new types of data sources
you've already done a lot of work
setting those up in terms of collecting
metadata and information about how the
data structured and stored and will
leverage as much of that as we can to
help you build the external table
command that then allows you to get
access to that once you have access to
these new data sources of course now you
get the opportunity to run sequel over
all of your data which gives you this
whole new rich simple agile language for
doing pattern matching over big data so
pattern matching we've added a new
syntax and you command into the 12c
database it's called match recognized as
you can see here and it allows us to do
a number of things so it allows us to
take a data set and logically divided it
up so that an order the data so that we
can look for in search for patterns
within that data set and we search for
those patterns using regular expressions
and for those of you that are used to
doing pattern matching with languages
such as perl etc you'll be very familiar
with the syntax that we've added to help
you define and specify the types of
patterns that you're searching for it's
an extension really of our regular
expressions that we currently have today
and although regular expressions are
limited to specific use cases within a
column the advantage of platen matching
with match recognizes that we can now
search across columns across rows and
backwards and forwards within our data
set so we have tremendous capability
here to be able to search for various
types of pens so let's give you an
example here this is probably the best
way to explain it let's say we have a
business requirement
we're a bank and we need to look for
suspicious money transfers and we have
regulations obviously that we need to
meet for this and let's say we want to
look for three or more small transfers
within a 30-day window and then after
that we're looking for a large transfer
of say over a million dollars within 10
days of the last small one so we're
looking for the small ones that are
obviously testing the system to see
whether we are looking for a pattern and
then a large transfer out of funds to
another account and obviously we want to
pick up on each of those pick up the
transfer dates and the amount of money
that's involved so how do we do that
well here you'll see that we have a
table you can see the time the date of
each entry we have the account name we
have the event whether it's a deposit a
transfer or withdrawal and we have the
amount that's going into or out of our
account so what we're looking for as you
can see here what we'd like to be able
to identify is these three small
transfers that have occurred in the last
30 days so they're our initial flag if
you like to say that something
suspicious potentially could be about to
happen here and sure enough at the end
as you can see here this last transfer
within 10 days we see a million dollars
going out of our account and being
transferred somewhere else so that's the
pattern that we're looking for so how
how would we code for that well we've
taken existing syntax that you are
probably already already familiar with
if you've used our analytical sequel
functions and we've added that into and
built around that a new clause called
match recognize which you see here so
we're now going to build this up in four
simple stages so the first stage is we
obviously need to group the data by in
this case firstly our user ID so we want
to look at all of John's transaction
then we want to order those in time so
we can go through them in sequence and
start to establish this 30-day intend a
rule so we have our partition by and our
order by clause that allows us if you
like to then search for and find the
pattern next part step 2 we need to
establish what the pattern is how we
going to actually find these events and
we do this using elements such as x + 3
and brackets and these mean specific
things so the x is the event that I'm
looking for so that's going to group
together my three transfers the three
here says tells me that I'm looking for
three occurrences or at least three
occurrences of these events the next
part is that i'm looking for this large
transfer and the large transfer i'm
going to identify with variable Y so now
we have X that's going to occur three
times or at least three times and we
have y which is my big transfer but what
exactly does that mean if we describe X
we would say that we need an amount
which we pull from the table the data
source and we need that to be less than
2,000 pounds and from the first time
that we establish an event where we're
transferring data to the last time where
we find that we're transferring a small
amount that difference has got to be
less than 30 days and that's what you
see here in the syntax that you're
seeing on the screen here now we have
established the first part of X we can
establish why and as you can see here y
is an event where the value is greater
than a million dollars or equal to a
million dollars so that now establishes
my patternist
I'm going to search for my data what I'm
looking for and what each element
actually is and of course when we're
looking for that final transfer it needs
to be within 10 days of the sliced or
the smallest transfer so we're looking
across boundaries here and this is where
we get the richness of the syntax
allowing us to move backwards and
forwards in our data set now having
established pattern we now want to
understand what it is that we're going
to return to our users what pieces of
information does the business need from
us to pull out of this pattern and we
want to find the first element the first
time when we find a transfer we want to
find the last time we find a transfer
and we want to find the largest amount
to establish exactly how much it was
that was transferred out as part of this
large final transfer and you can see
here the x time and the y time and the y
amount point to our variables that we
established earlier as part of our
pattern and define statements and point
us into specific rows and columns within
our data set then the last part the sort
of final step we have is controlling the
amount of information that we return
obviously we can tell the users a lot of
detail about what they're going to see
within the pattern or we can just give
them a summary reports here's the plan
that we found and here's the high-level
summary information that we found and in
this case we're actually going to give
them quite detailed information so we're
going to go for as you see here one row
for each match
now we've got all of the information
we've captured it we determine what
we're going to output to our business
users we can include those elements into
our select statement to return to our
users either into our business
intelligence tool or our sequel
developer or whatever it is that our
application might be that's running this
command so you can see here using those
of you that are familiar with sequel
that are familiar with our analytical
sequel functions will recognize a lot of
the commands and syntax that we're using
so hopefully there's not too much that
is new there to you and one of the key
benefits of moving this inside the
Oracle database is and using sequel is
that it's very very easy to change this
so if we take this money transfer
example again and now let's say the
business comes back to us and says well
actually the requirements have changed
what we actually need to find now is
have the transfers being two different
accounts is it not just going to one
person are we doing a lot of the smaller
transfers to lots of different accounts
so it's less obvious that the big
transfer is actually going to occur so
we'd now like you to check to see who's
actually on the receiving end of the
small accounts because maybe they're
important to us as well as well as the
person who gets the big transfer so how
would we go about making those changes
in a lot of cases with other languages
that could be a quite complex and
lengthy process to go through but
because we're using sequel it's
relatively easy for us to do so if we
look at our data set now you'll see that
it's changed and we've inherited a new
column so now our data set tells us
who's receiving the information and we
can see here that we've got a number of
different people receiving small amounts
of money from our account and those are
still occurring within 30 days but
we want to make sure that of all of
those small transactions that come
through that the sons less than 20k and
maybe that that 20k has some
significance to it from a fraud point of
view maybe that's a legal requirement
and then of course we see the final big
transfer here going to Tim that occurs
within 10 days at the last small
transfer so how do we update our sequel
statement to cope with these new changes
so you see most of the syntax here I've
already filled in we've used and seen
this in the previous slides what we need
to do is make some very simple changes
so we just add a new line in here that
says I need to check who's received the
money and was it different to the person
who received the last small transfer so
I'm looking at the previous ex transfer
to and comparing that with my current ex
transferred too so that takes care of my
first change that I need to make and I
also now need to make some additional
changes to my Y element here to check
that the sum for all of my small
transfers is less than 20,000 so you can
see here that this is actually taken us
very little time to make what is
probably quite a significant business
change to our code and it's still very
readable it's still very simple if we
took this to the business users and said
is this the syntax is this there the
requirement that you're looking forward
to this meet the legal requirements that
you have to deal with now it's very easy
for them to understand it so moving your
pattern matching inside the Oracle
database making advantage of sequel
gives you three key benefits you can now
access lots of different data sources so
you can access to your Oracle database
you get access to data sitting on Hadoop
you can even access data sitting in no
sequel database bring those all together
access them with sequel using a simple
syntax with our match recognized clause
which is based on elements syntax that
you've already seen and used with
analytical sequel but most importantly
where your pattern requirements change
and evolve over time it's very easy to
go back in and make those changes and
take on new business requirements and
push those requirements back to the
business users in a much much quicker
time frame I hope this has helped you
understand how we can make your life
easier with sequel pattern matching
thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>