<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Beautiful REST + JSON APIs with JAX-RS and Jersey | Coder Coacher - Coaching Coders</title><meta content="Beautiful REST + JSON APIs with JAX-RS and Jersey - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Beautiful REST + JSON APIs with JAX-RS and Jersey</b></h2><h5 class="post__date">2013-02-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/sVvL12BnIyQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so thanks for coming my name is les
Haslett I'm the CTO of storm path I'm
feeling a little under the weather today
so I'm doing my best to project if if
anybody can't hear anything please let
me know or I'll repeat what I said or
and I'll repeat questions that are asked
before we get started just let you know
a little bit about storm path we're a
cloud hosted Identity Management and
access control service so we really
focus on user management I'm sure you
everyone here probably heard about what
happened to LinkedIn and Yahoo and a lot
of these other companies over the last
few months French national bank actually
had a password password problem
yesterday so it's a real significant
problem for building cloud services and
securing users we are a cloud SAS that
automates all that stuff for your
applications we provide users security
workflows like forgot password account
verification email verification locking
unlocking password reset and of course
we provide us a lot of developer tools
and SDKs that wrap our REST API so if
you're interested in this stuff and/or
you're building a cloud-based or
internet publicly facing application
definitely give us a try it's free for
everyone to get started and we solve a
lot of the nitty-gritty that apparently
a lot of companies are having problems
with lately so today I'm going to cover
a couple things this this is sort of a
tutorial workshop and it's I'm breaking
it down into really two parts the first
half I'm really going to spend on rest
fundamentals and rest design principles
rest is an architectural style it's not
a specification and because of that
there's a lot of different
interpretations about how rest should
work and so the first half of the
presentation is really going to be about
design in de-facto best practices that
we've researched and accumulated and
implemented after looking at many many
different rest api is over the last 18
months and so this is really a
consolidation or condensation of what we
consider to be best practices and then
after we cover those best practices and
design issues the last half of the
presentation will actually be showing
you how to implement those techniques
using jax-rs and specifically with the
Jersey framework it's kind of hard to
see but these are
some of the design issues we're going to
be talking about you don't need to worry
about them right now I'll cover them in
detail as we go over them and then again
well we'll start focusing on some code
in the latter half it will be available
online we've uploaded it through the
Oracle channels already and we just had
another another upload happen just five
minutes ago so it should be available
shortly so why restau there's a lot of
people this room so why is everyone
interested in rest and rest paradigms
well doctor Roy fielding the sort of the
inventor of the paradigm in his thesis
really quoted six reasons why rest is
important and should be important in
designing scalable architectures the
first one he listed is actually
scalability and by this I don't mean
performance you know the ability to
handle hundreds of thousands of requests
scalability here really means a large
interconnected network of machines and
or you know third-party heterogeneous
systems being able to communicate with
each other and scale can be reached in
size or in quantity because of a common
kind of architectural approach
generality is that because of the way
rest is defined in HTTP verbs
specifically it can cover a vast
majority of systems system interaction
use cases so it's very general in its in
its approach and how it deals with data
transfer and data manipulation
independence you know one system can be
completely independent of another
latency is something very fundamental to
rest architectures in the form or
addressed in the form of caching and
it's something that a lot of people
don't talk about with rest but it's very
very important in understanding the rest
pairs that paradigm caching is critical
to how how rest scales security there's
because it piggy backs to the HTTP
specification there is built-in security
techniques to keep rest architecture
secure and finally encapsulation a rest
architecture or the parts of a system
that are exposed over arrest
architectures can be dramatically
different than the underlying or backing
systems that that they sit on top of so
it allows you to encapsulate more you
know concrete or even more difficult
details
behind something that's more general so
you get a lot of flexibility and having
this this decoupling so these are the
six primary reasons excuse me why why
that dr. fielding focuses on his thesis
be how many people here heard or seen
this acronym before okay about half so
hade OAS is something that's often
referred to quite a bit in the context
of rest and this this these letters say
for hypermedia as the engine of
application state and that's really a
big mouthful but all it really means
well most of it what it means is when a
system interacts with another rest-based
system it doesn't need any information
beyond the initial request in order to
figure out how to continue to interact
with that system so everything that's
necessary from data formats to parsing
rules to data types they're all
encapsulated after or based on the first
request and then from there more
information can be found out as
necessary which is really important for
auto discovery or
self discovery of other third-party
services a lot of people view this is a
further restriction on the general rest
principles and rest architectures but
you'll see a lot of people who are
really in the interests bring this up
quite a bit because this is one of the
cleanest ways to go about implementing
rest it's not the only way so if you see
this just keep that in mind so rest rest
is easy right everybody's doing rest
it's piece of cake and there's you seen
the ton of services show up um it's not
it's not really the case like it's easy
to consume for clients I typically it's
it's the data payloads or XML or JSON
and that those are fairly ubiquitous
these days and clients can interact with
that data relatively easily but for the
servers or for providers it's really
freakin hard to get this stuff right as
I said before rest is an architectural
style it's not a specification and so
there's you know 6 or 1/2 dozen of the
other ways of accomplishing you know a
lot of things that don't really need to
be replicated so a lot of what we're
going to talk about today are techniques
and what I consider de facto best
practices
based on our research but if you
restrict these use cases down to simpler
ways of doing things
rest can be easy if you file follow some
guidelines and so again a lot of what
we're going to talk about today is is
guidelines on how to implement good
quality arrest services the first half
of the presentation I will explain storm
paths domain so as a identity and cloud
service we focus a lot on what we
identifies applications directories like
LDAP and Active Directory accounts which
are identities within directories groups
you know the associations between these
things and workflows of how how these
entities are related with each other how
they're changed in workflows so I think
these are things that most people are
fairly you know familiar with almost
every application to some extent has a
concept of a user may be groups and so
it's it's a fairly simple domain that we
can that we can all kind of settle on as
we talk about these things so first off
I want talk about fundamentals I'm going
to bring up the word resource a lot in
the context of rest in this presentation
and I want to be very clear here a
resource from the rest perspective is
basically a noun it's a thing it's not a
verb so things like dog or cat or
document or person or user or group
right these are all nouns they represent
things and these things can be
transferred or representations of those
things can be transferred rather and the
more coarse-grained they are the better
one of the key points and rest
architectures is that you don't always
know how your clients are going to react
to data in the format of your data so if
you keep your data core screen and
present a lot of information your
clients can implement in and manipulate
things and react to things in ways that
you could never envision in 4c so the
more coarse-grained the more data that
you represent in coarse-grained manner
the better it is for longevity of your
rest api's so changes that happen in the
future that you can't foresee today are
easily or more easily handled rather if
your data is coarse-grained and it you
know this is a good architectural style
for use case scalability so if I want to
create a user
or delete an application right these are
crud kind of behaviors that are fairly
easily mapped to rest and it's a good
basis for that kind of architectural
style we'll also talk about how you can
do behaviors too
yes so sure so the question is going to
give an example of coarse-grained vs.
fine-grain and so being a Java
conference you know a coarse-grained
method excuse me a fine-grained method
might be you know if I have a user
service and I want to say user service
dot set user name and it takes in the
user ID and it takes in the user name
right it's very very fine-grained it's
targeted specifically at that attribute
and that attribute only the problem
arises is what if you want to change
their first name or their last name with
your postal address or you know whatever
any of the information about the user
now said you've got to create more
methods to support that as opposed to a
single fine grain or coarse-grained
approach which maybe just takes any user
and it's just a single update method
call any number of manipulations on the
user object can occur but the the
backing service still be performs the
exact same way regardless of how many or
what types of property need to be set so
that's a pretty good example of
coarse-grained versus fine grain and
actually here's a good example of fine
grained attempts at our REST API so what
if I had you know a URL or URI that says
you know let me get an account or maybe
I can post and create a directory or
update a group or verify an account
email address right basically what this
is is there is a URI per action that's
being defined here and while this might
seem kind of intuitive depending on the
on the background that you have the
problem is is that once your use case to
start to expand you might see stuff like
this or maybe I want to create or search
for groups by name or find groups by
directory or verify key account email
addresses by token you know this can
explode very quickly if you try to do
the the fine-grained approach and for
those that are familiar with you know
older RPC based approaches this really
starts to smell like you know an older
RPC mechanism
if you've ever had to support one of
those in the past you know that this
doesn't scale well and you end up having
a lot of code to maintain and test and
try to fix or take care of for bug fixes
so this really smells like old RPC don't
do this when you're designing rest api's
instead we really do want to keep it
simple and by that we go to a coarse
coarse-grained approach so
and when I say coarse brain there's
really only fundamentally two different
types of resources that you'll ever have
to deal with when working with a
coarse-grained REST API the first is a
collection resource which itself
contains other resources and then there
is what we call an instance resource
which is a single instance of a
particular datatype so an account or a
group or a directory that represents one
and only one thing and these are really
the only two things that you have to
worry about when you're designing rest
api s and you can you can represent
relationships and stuff themselves as
their own entity we'll talk about
relationships in a little while but
initially these are the only two things
you really have to worry about so what
do I mean by a collection resource so in
this example we have a slash
applications endpoint and if somebody
were to visit this URI it should return
a resource that that represented a
collection of application instances
notice here that the URI is plural it's
not singular so it's not slash
application and the reason why is it is
a it's a little more intuitive to go to
a plural based endpoint that represents
multiple things so if you keep these in
the plural it's a little more intuitive
to consumers of your REST API they kind
of already understand what they're going
to get back before they even access the
API but what about a particular instance
so in this example we are accessing a
particular instance of an application
below the applications base URI and so
this allows us to further restrict the
type of data that we get back within
that collection in this case we're
returning only the application with ID
a1 b2 c3
so that's it there's are only only these
these two types of things that you have
to worry about when you're creating your
data models or your models for your rest
resources
what about behavior though right we've
just talked about the mountains the
things that you can interact with how do
I interact with or change data or change
state or interact with those resources
and of course the answer for arrests is
that arrests piggybacks the existing
HTTP specification methods for behavior
so there's there's get put post elite
and head right these are parts of the
HTTP standard for the types of methods
that can be interacted with with an HTTP
server it's also patch which we won't
really talk about today it's kind of
going through an RFC process it's not
it's not fully standardized yet but
these are the ones that people when they
in existing REST API is today these are
the ones that you'll see most of the
time how many people in this room
believe that these represent a
one-to-one correspondence with crud
create read update delete okay we decent
amount people um the answer is that that
can be true but they're not always a
direct one-to-one correspondence you can
you can model create read update delete
based on post put get in delete but I'll
give you some scenarios where it's not a
clear one-to-one correlation
certain methods can be used for multiple
behaviors and it's credibly important to
understand the distinction between these
when you're exposing the REST API to
clients because these behaviors are sort
of defined as de facto standards and you
want to adhere to them to make sure that
everybody consumes API is the same way
there's a lot of violators but by the
way on the web I won't mention any names
but there's a lot of people that do not
adhere to this and it causes significant
problems for people that expect this to
be the case so what will will cover the
methods as you might expect get delete
and head are really actually one-to-one
correspondence with read and delete a
head it just gives back metadata
information won't actually return a
resource representation but get really
does return you know it reads a resource
until it actually does delete
so these are these are straightforward
what's not so obvious though it's post
and put can both be used for create and
update and we'll talk about how that's
possible right now so you can use put
for creating resources if the identifier
is already known by the client
performing the put so in this case we
have put slash application slash client
specified ID in this case if the client
wants to specify their own identifier
for an application they can do that and
the server is expected to use that
identifier as the identifier that it
saves it in in the system so this is
actually create scenarios and put
totally legal but put can also be used
for update this is the thing that people
most associate with put in that when I
place data at this or when I post or put
data to this particular URI endpoint you
know I need to specify collection of
name value pairs or or whatever that
representation is so you know in this
example same value pairs because we're
using JSON but one of the key things to
remember though is that put by
specification is idempotent an
idempotent operation is is any operation
that could be performed one or multiple
times and result in the same server
state right it's incredibly important to
recognize here that idem potency as a
property for HTTP has nothing to do with
the client you know a client might
execute an operation five times if it
fails the third time and not the first
two it still might be identical on the
server and identity here is really about
the server state not the client state
but the key point here is that put has
to be identity which means you have to
send the entire resources representation
in its entirety whenever you do a put it
cannot be a partial representation so in
this example if I'm doing a put for
application this implies that the only
two properties that an application has
is a name and description and the reason
why is that I can't put name on what
request one and then just description on
request two and expect the server state
to be identical after those two requests
it breaks the rule of I didn't see but
if I put the data in the entire
representation in every single time that
I actually eat that request I can be as
I can be assured that the server state
will be the same really really important
put has to be identity it has to be the
entire representation of the resource
but that's not necessarily true of post
so how can post be used for create and
update so post is typically used for
creating things based on a parent
resource or a parent collection so in
this case I am posting an applicant
applications representation to the slash
applications endpoint and what this is
really telling the server that is that
hey I'm sending you data I want you to
create a brand new application instance
that's owned or you know a child to the
applications collection resource and the
server can respond with 201 created and
the location header is set to the fully
qualified href of that resource that was
just created on the server one of the
things that's interesting is because
post does not have to be ident
you can send in partial representations
of objects or resources so in this came
in this case we're setting the name but
not the description and that's
completely legal because post is sort of
the one off in the HTTP specification
for methods it post really means a
server directive or a server processing
directive and that the server can do
whatever the heck it wants to during a
post there's no architectural limitation
on what happens during a post so you
have the freedom to put in full or
partial representations as you see fit
it also has implications for caching
because because it's not ident it's not
cashable by proxy servers or caching
servers um we'll talk about that
performance implications with caching a
little bit later but so you can send
partial representations and probably one
of the most important parts of the slide
is that you don't want to send back a
200 ok after this executions you you
want to send back a tool 1 and you and
you definitely need to set the location
header to indicate to the client not
only have I created the resource but
here is its fully qualified unique
identifier that allows you to get access
to it later if you want to so always set
your location headers in fact we'll
later on when when Jersey and the Jersey
framework when you create responses in
Jersey it takes in the location as one
of its one of its main arguments when it
creates a response knowing that you've
created an entity so this is the best
practice definitely stick to it it's
really important for for portability
across API so so that was great let's
talk about post as an update so in this
case we're we're sending data to the
server via post and we're sending it to
that resources specific URI endpoint and
here we are sending a partial
representation and again we're allowed
to do that because post does not have to
be identity' so this could be beneficial
depending on your API and how you offer
it to your clients maybe the data is
significantly large or maybe it's
complex and you and you only want to or
you want to provide a feature for your
customers or they only need to specify
the data that they feel has changed if
you have bandwidth limits on services
for example this can be very beneficial
because if your resources are
potentially large the client only needs
to send over a small amount of data to
indicate what has changed as opposed to
sending over the entire resource
representation which might eat against
their bandwidth quota so this can be
very nice to support depending on your
on your use cases for your customers um
yes yes so the question is when you set
posts create use posts create you set a
location header what's the advantage of
the location header the real advantage
is that there's not really a notion of
an ID in the rest world or in the HTTP
world you know a knight an ID like a 1 B
1 or a 1 B 2 C 3 that's really specific
to the implementation of my service IDs
in the rest of the web world are really
URLs right if I want to link from one
page to another and a website or if I
want to link from one resource to
another the URL or the URI is the the
unit of measure by which you you
interact with and link information and
so by sending this in
information back you're saying hey this
is the fully qualified unique resource
identifier for this resource and we'll
talk a little bit later how this is
better than just sending the raw IDs
because you can use cool things like
HTTP redirects if this ever changes you
know it affords you a lot of power and
flexibility where as a raw ID does not
so yeah so for a put you don't need a
location header because yes yes you
don't need the location header in a-put
because you already know the location of
it when you send in the data to begin
with right so this helps the client
understand where it resides if you
already know it there's no need to put
it in the in the headers again
so again post is an update it's not
idempotent you can send partial data 200
OKs or perfectly fine because it's an
update and you already have the fully
qualified URI recover that it's not
attempted what about media types this is
something that comes up a lot when you
talk about rest and it's actually fairly
fairly important really important
actually to rest and how rest scales a
media type is really a format
specification associated with a
collection of parsing rules so a client
a rest client can look at a media type
and based on how that media type is
defined it knows this is the format of
the data as well as how I know how to
process it how media types are
identified or specified it's completely
outside the realm of rest there's a
number of ways to do this this is media
types Rin or registered ia na so if you
have a formal media type you wanna
register you can go talk to Ayane
otherwise you can use internal internal
media types to your heart's content but
the reason why they're important is
because they are the identifier of the
format of how the data is transferred
between client and server
so both client-server need to agree or
at least understand the same media types
in order for data to be
legitimately so both parties understand
the data and the way the client
specifies to the server the kind of
content it wants to receive back is via
the accept header so when a client sends
a request into the server it will set
the accept header with a comma delimited
list of the media types that it can
support typically ordered in the order
in which it wishes to receive the format
or the data back so in this presentation
you'll see our accept headers and our
content type headers our application
slash JSON which is the most common
media type for JSON representation and
then of course on a response the server
needs to set the content type header to
tell the client you know the data that
I'm sending back is the media type of
foo or whatever it is so ideally the
accept and the content header will will
be equal so that the data can be
transferred in a format both parties
wish to receive and communicate they
don't have to be though you know maybe
the client says I accept both JSON and
plain text in the server if it doesn't
accept plain text or excuse me JSON
maybe it can send plain text back and
then the client would be expected to
know how to process it there's multiple
representations of how or how you can
specify content types our media types
rather the first is the most common one
that we see all the time is application
slash JSON this just indicates that is a
generic JSON document with no additional
information that it gives you any kind
of insight into what type of JSON
document it is or what kind of
properties exist for example you can
specify custom media types and actually
Roy fielding states that the the the
heart and soul of rest architectures is
hyper media basically linking between
resources and media types and so you can
you can have a tremendous wealth of
flexibility and how data is exchanged
based on how you link to resources as
well as how you represent media types so
on the second example here application
slash foo + JSON is a qualifier that
says this is not only a JSON document
but it's a JSON document according to
whatever the foo specification is and so
that can potentially give the client
more information that says not
is it a JSON document but I know that I
have to look for these five properties
and that they do XY and Z you can
further restrict via via parameters on
after a semicolon so for example food
plus JSON semicolon application is an
additional restriction on what type of
the Foo JSON document it is B you can do
name value pairs via ampersand similar
to query parameters so you get a lot of
flexibility in being able to actually
specify exactly the type of content
that's going to come back from the
server most of the time people the real
rest purists say that you should have
media types custom media types for all
of your data because it's the quote
unquote true way to do this things that
being said a more pragmatic approach is
really to start off with application
slash JSON and then as you have time why
does it make sense to your project and
organization then you actually define
these media types and their parsing
rules for clients so examples of um I
can I mean I haven't really baked it
into this particular presentation but I
guess we can talk about that I guess I'm
the second half when we can indicate how
that can happen so okay so those are
really the fundamentals media types the
methods and we'll talk about some some
URR some rest api design issues sorry so
the base URI apologies what looks better
of these two you know well if you're a
customer for rest service which of these
two would you prefer to use and what
would make easier sense or more sense
right yeah I mean everybody says it's
the top one right and so this is a minor
point it's not required right the bottom
you are URL could be a rest endpoint the
point is is that if you're going to make
your REST API easily accessible to
customers and your clients and you want
to facilitate and make their lives as
easy as possible choose a very simple
URI and it'll make them happy and the
more things that you do like this the
more adoption you're going to get on
your REST API and the easier it is it's
going to be for cost
or sport and whatever but things like
this you know really focus on intuition
and trying to make things more intuitive
for your customer so we recommend going
the top approach it's not mandate but
we've seen better results with with
people who think about these kind of
things for their customers an
interesting question we get sometimes is
you know if I access this URI or URL
from a browser as well as a rest line or
command line client what happens a
number of things can happen you can you
can return JSON specifically to the
browser all right Ari to the command
line client because you know it may be
it sets that as an accept header
maybe the browser specifies a whole
bunch of things and so if it accepts
HTML and JSON maybe you show them a full
web page of that of that data that's a
completely viable approach depending on
what what the accept header is we have
chosen it storm path to have the JSON
data shown in both scenarios so even if
you hit it with a browser it still shows
you a JSON document not HTML the reason
why we do that is again for for
simplicity ease of use for developers as
developers are tinkering around with
your API and they're trying to test
things out they're going to want to see
what the data looks like not some HTML
page because maybe they're debugging
something and they want to see the
structure of the content um so our
recommendation is that you you make the
the URL return the same data type
regardless of the client again you have
to you have to respect the accept header
but given multiple options return JSON
and all times versioning this this is a
particular this is particularly
interesting topic and rest because
there's a lot of a lot of debate about
this right now you know if I've got
version one of my API in version two of
my API how do I support that for clients
how do I represent that there's really
two kind of techniques here the first is
that you actually embed the version URI
into your URL our excuse me the version
number into your URL the other is that
you make it a configurable property of
the media type that is configured by the
client so a client if you're using the
URL it's obvious right you just go to
that URL and you get back and everything
that's that stems from that URL down is
going to return version ones
representation
the data format the media type approach
is actually more elegant in that the
client can specify what version that
they want and so what this means is that
the URLs or the URIs rather for these
the rest resources never change over
time
or they don't have to change over time
around and that the client gets to
choose the format version that it wants
to receive so maybe in version 1 there's
a resource that has five properties but
in version 2 maybe one of those
properties has been deleted you don't
want to remove that that fifth property
or at least it's invisible but you don't
want to remove that fifth property
because it might break existing clients
but the the more up-to-date clients the
version two clients can say that no I
understand that you've hidden that and
then I don't need to process it so give
me a version two of that particular JSON
document or that JSON resource if you go
the media and the media type approach by
the way is what fielding and most of the
rest community recommend as a best
practice because it scales better right
you can have any number of versions your
you are eyes don't have to change your
server code can can can easily
distinguish based on version what kind
of data to return whereas the URL being
embedded or hard-coded into the URL is a
little difficult to get around you can
use techniques like HTTP redirect so
that if you change versions and you want
to force a client to go to a different
representation there's ways to get
around that the reason why I bring up
the top one is it seems to be the one
that from a pragmatic approach that
makes this makes most sense to a lot of
developers understanding media types and
versioning of media types as well as how
to change your client code to parse
different versions of data based on a
version number tends to be fairly
difficult and complex for most
developers like you got to think a lot
of the developers consuming these things
or kids right out of high school or
college they might not know about these
more in-depth techniques so the top one
tends to be the one that seems to be
dominating a lot of the public rest
api's and then you can duplicate
functionality by adding a slash v2 or
slash v3 you know as your versions
increase and maybe they return the same
representation but your client never has
to worry about that so it tends to be
easier to use on the top one the bottom
one is considered the best practice
so it's really up to you depending on
your client's needs and your customers
there's there's more complexity with the
bottom one but there's there's pros and
cons of both approaches yes/no so one of
the interesting things about the well
well the client needs to change when it
starts I'm sorry yeah the quite the
question is did the client need to
change on the version numbers change
right and the answer is yes like
ultimately the client needs to know how
to process that version but a benefit of
the v1 or a note encoding in the media
type is that the client can choose when
they want to upgrade so maybe an
existing library or an SDK only knows
how to speak or use version one
resources that code never has to change
as long as the server continues to
support that version exactly the
existing clients do not need to change
but it makes it a lot easier for clients
like for example what if you program
URIs into your code for some reason
right you're you are is never have to
change in your code if you're using the
media type version approach so it
depends on how this has but this is a
better impact to clients on the media
type approach whereas the the top one
forces the change no matter what but
it's easy to use yes yep yeah um if
there's the URL absolutely so you know
the caching server has no knowledge of
versions right so it you know v1 and v2
the same resource will be considered
separate resources by the caching server
the media type approach I believe it's
up to the caching server so and I think
they're caching servers allow you
configure whether or not this will
invalidate a cache interest entry based
on a version but though the top one
forces an invalidation so oh yeah so we
just talked about this again you can
specify custom parameters via ampersands
so we typically you know advised to go
application JSON and then use the custom
media type approach when you have time
oh one thing I want to bring up is this
notion of camelcase
so when you represent resources in JSON
specifically and you're sending data
back and forth JSON stands for
JavaScript object notation so you want
to make sure that the data represented
in your payload uses JavaScript
conventions so instead of having a for
underscore each or you know give an
underscore name use camel casing it's
what the JavaScript convention is and
not only that but this is also directly
portable with any JavaScript based user
interfaces that might need to consume
this information so because it's a
convention many JavaScript UIs can just
use these properties directly from the
rest payload without having to convert
it into a format that's easy for them to
use so common for Ruby unconventional
for JavaScript stick with the JavaScript
notation consistency helps integration
what about dates time stamps it's
interesting because there's a lot of
ways that I've seen people represent
dates and times and their rest api's and
it's a little a little interesting to me
because there's already standard and
there's been a standard for decades so
iso 8601 and it's a time date time stamp
format if you keep all of your time
stamps in 8601 representation it will be
much much easier to deal with over time
libraries are now how to support this on
both JavaScript side and most rest
frameworks like for example jackson when
it processes JSON knows how to parse
these already we also like to recommend
to represent all times in Zulu or UTC
and the reason why is because typically
for most REST API s are especially
publicly exposed ones you have clients
from all over the world and so it's a
lot harder to try to support and/or
calculate times and representations of
times depending on where the client
might exist if everything is done in UTC
universal time coordinated time then it
works the same way for every client and
then they can you know what choose to
represent those times in a different
format based on where they might
so we've seen a lot of problems with
time stamp representations being non UTC
like for example a lot of databases like
my sequel in specific do not do very
well at all with with maintaining time
stamps in the database so if you have
UTC from the database all the way up it
will it will greatly simplify your code
it makes things easier for the client
cuz they always know what to expect so
stick with 86 I want it if you can
there's not a not a lot of reasons to
diverge from it so href one of the
things that's really really critical to
hop to art rest architectures in general
is this notion of distributed hypermedia
and that that really just means
resources that have references to other
resources and even across systems and
heterogeneous systems third parties this
is the real one of the probably the most
powerful thing about rest architectures
is that you can reference data no matter
where it might reside based on a tress
and so we like to suggest that every
accessible resource has a unique URL
every single one that you that you serve
from your REST API as a resource should
have a unique URL and this effectively
as you know we had a question before
replaces the notion of an ID an IDs IDs
still exist but they're really internal
to your service and they're opaque to
the client so while they might see an ID
they might not know how it functions or
why it exists because the the ID of the
record for the client is really the href
property and so we advocate that you you
put an hrf property well first of all
there's there's any number of ways to
represent HR FS and links to other
objects in JSON and there's a lot of
competing kind of techniques and
standards or semi standards that are
going on right now we recommend putting
it as a top-level property in the object
and we believe it to be critical for how
objects or resources are linked and I'll
show you a really specific use case of
where this is particularly elegant so we
always like to make sure that that
there's always an href so no matter what
resource you're looking at the client
can always assume that it no
how to get back to that data what's the
question
yes so this would not be so the question
is is this one has a version embedded in
the URL but what if you are using the
media type approach how do you how do
you represent that and the answer it
would be it's more likely you would have
another property that specifies the
media type so that they know how to how
to look at it again that's up to the
media type right you can specify what
the properties are and you can you know
how to parse it accordingly
so the response body sometimes we have
questions about this like when should
there be a response body with get it's
kind of obvious right if I'm getting a
resource I I want the body back no
matter what so that's kind of obvious
but what about post so if I send data
into the server should the response be
that exact same resource that spit right
back out to me like I just gave it to
you why are you sending it back to me is
that necessary there is a lot of it
simplifies code to a great degree for
the client if it knows to expect a
resource every time it sends a request
so if I'm sending in you know maybe a a
user object or use a resource and I only
change the username and I know that the
data that comes back is sort of the
freshest or most accurate or version of
that user resource then it means I can
change whatever I might have locally to
represent what the server just head back
and so we kind of feel that although
it's not necessarily necessary that it's
it's a good convenience and most
resources aren't large enough to the
point where this would cause any
problems that being said this would be a
problem for example if you're say
posting a video right if you post a
video you don't want to spent send the
video right back out in the client right
it's a lot of data it's not necessary so
use prudence and judgment as necessary
but we finally that simplifies a lot of
client-side code or client-side SDKs
because they always know that they have
the most recent version locally you can
also if you want to support a query
parameter like underscore body equals
false that allows the client to control
whether or not they want this
again remember if you have a quota
limited API for example maybe you don't
want to send the data back because it
eats against the client quota so you
could add control parameters to your
query string to allow that to turn on or
off or not content negotiation so we
talked about this a little bit already
on the the default way for a client to
get back the data it wants us to
definitely use the accept header and
this is the expected and conventional
way to do it and it's actually part of
the specification this is where most
people do it
and again header values are common to
limited in the order of preference that
the client wishes to receive that format
but there is something that's also
convenient for maybe rest clients that
are a little older or may not be able to
support headers for whatever reason
excuse me and that's setting the you
know the INR registered suffix or
extension for that media type as part of
the actual uri directly so in this you
know in this example you see that the
first the same resource on the server
but the representation is different one
is a JSON representation the others a
CSV representation and if somebody does
this this will conventionally always
override the accept header so if they
specify both you always choose the one
because the URL is the most URI is the
most relevant part of the request so you
you use that and defer to the accept
header if that's not specified so how do
we handle linking so again this is one
of the most important parts of REST API
S right hypermedia is paramount
according to fielding and linking is
fundamental to scalability and again
here I'm not talking about performance
I'm talking about the ability of the
data to be used by heterogeneous systems
in many different contexts right that's
the kind of scale that we're talking
about but how do we do this you know
it's kind of tricky in JSON XML already
has this built into and one of its
specifications and it's got a w3c
standard called X link that actually
standardizes how references to other
resources are in code
in xml jason has no such concept right
again this is one of the the things that
are being heavily debated on it on the
net right now but because there's no
standard for it how should we do it so
in this example I've got an account
resource it's an account it's an
instance of a particular account and
I've got some data you know I've got the
HRF which is the global identifier I've
got a given name surname maybe some
other properties and then there's this
directory property then not for example
in store pass API
this tells the caller the directory to
which that account belongs directory is
a container of accounts so how do we
reference the directory so before we
were talking about the href property
this is where we start we feel that it
starts to kind of show some of its
elegance so while this is a little
different in XML XML has a relation
attribute arielle right you can do a RAL
equals whatever and the relation is
really describing the type of
relationship that's kind of already
implicit in JSON like the property name
itself is the relation and so it's it's
it's implied that for directory if it's
got a single property which is itself a
complex object and that object has a
single HRF property then you know that
for that that property where you were to
go in order to get that actual data
representation so this is this is how
we're doing linking an RS to API and
we'll actually show a technique called
entity expansion a little bit later that
makes this even more elegant
so we've researched probably eight or
nine different ways of representing
links and we decided on this one after a
lot of internal debate and recent
research and we found that this actually
is one of the most elegant ways and it
scales really really well
and I'll show how in just a second so
this is this is an instance to a
particular directory or sorry a
reference to a particular directory the
same can be true for collections so it's
the same account and instead of the
directory maybe I want to find out what
groups that the account belongs to and
so in this case I've got a groups
property and it itself is an href
to the fully qualified unique identifier
of the group collection remember before
we're talking about there's there's
really two kinds of resources there's an
instance resource and a collection
resource this is just a link to the
collection resource itself whereas the
the directory one was a link to an
instance resource so reference expansion
this isn't it
whoa I didn't it's kind of weird maybe I
got static or something um yeah
question so the question is is in the
URI for the for the group's property
we've chosen to nest groups under
accounts right as opposed to why weren't
the groups represented as their own
top-level kind of collection right um
and the answer is is we do both actually
in the storm path system right so groups
as a top-level concept represents all
groups for your particular tenant every
group that's in the system because we
feel that without any additional
qualifier groups is generic and
therefore the representation should be
generic and then it's every single group
this groups this URI here will return a
collection resource that represents only
the groups for that particular account
so so reference expansion this is also
called entity expansion or link
expansion on the net so I showed you
before you know we have an account and
we showed you a link to the directory
but what if for I don't know bandwidth
reasons or network overhead or just for
simplicity I wanted both the account in
its directory in a single request how
would you do this we and all the
research that we did we found that one
of the most elegant ways to handle this
and flexible ways is to support and
expand directive as a query parameter
and so in this case we're getting the
same account resource
but we've set expand equals directory
and that's a directive to the server
that when the resource is returned that
not only is all the accounts name value
pairs returned but I also want you to
return the directory and I also want you
to expand the directory in its entirety
so I don't have to go back to the server
to get the directory this is really
valuable especially for a lot of user
interfaces because you can customize
what your UI screens look like based on
directives to the server so you don't
have to have multiple round-trip
requests and it will actually improve
performance quite a bit yes a question
now it's not a standard um this is we've
seen this technique used in other api's
to certain extent I can't remember if we
came up with the expand word or not this
is the thing that made the most sense to
us so we went with it we also have the
ability like an our API expand equals
star and that says expand every single
property or expand equals directory
comma groups and it says only expand
those two properties within the account
so the server you get a lot of power for
the client based on what the server is
willing to support I should also note
here that it's actually really important
to note for caching purposes query
parameters are taken into account for
caching servers and so while this
represents the same resource on the
server the query sorry the request
without the query in the request with
the query are considered two separate
resources by the caching server even
though they really represent the same
source under the hood so just keep that
in mind for caching roles if that's
important to you guys or whatever your
domain is yes
right so the question is how do you
support or potentially handle multiple
nesting levels so for example maybe I
want the account and its directory and
also from within the directory
I want the applications that are
associated with that directory you know
how do I get all of that data
essentially a tree and the answer is is
that it's really up to the server as to
how many levels you go deep because the
more levels you go the higher
performance penalty you're going to
incur depending on the data source um
the way we do it is kind of based on
parentheses so you can say expand equals
directory open paren applications comma
whatever and that gives a list of things
so you we've kind of built up this
expression grammar if you will that
allows a server to know how much data to
pull back but it's at the server's
description discretion rather as to how
or what endpoints support this level of
nesting right it's not necessarily
arbitrary for the client the server has
to be aware of it
so in the code that we have to show
today I do not show that particular use
case because to do a demo in an hour to
write that level of grammar parser would
be very very difficult but maybe you
know maybe we can post something up on
the github project that we have you know
in the future so the github project that
we're going to demonstrate does not have
that but it shows more a more simplified
version of what that might look like so
we'll show that a little bit later so
this is a again we call this resource
expansion it could be very powerful
depending on what the client wants and
again that the server doesn't
necessarily know what the client wants
so it should support depending on your
your performance requirements you know
certain level of these depending on the
rest resource yes so if I do a get on
just accounts are you mean the one
particular account the default response
for us is the bare minimum
representation of that object so here
you see that we have the object in all
of its properties and then links to any
of its oh ok so it depends so the
question is is what if I just did get on
slash accounts and I don't have any
qualifier you return every single
account and the answer is that it
depends on the server depends on the URL
like on your end point what we do is we
default to a collection resource that
has a maximum limit of 25 items and so
the or actually it's a little more
complicated that we actually do a
redirect to a URL that represents that
collection resource because if you were
to actually satisfy slash accounts you
would expect to get every single account
back in the entire system for us that
could be Millions right and so we don't
actually support that operation we
default to a paginate ADRA's
yeah and we'll talk about pagination a
little bit
so I just explained how to get an object
in it's an additional data for its
relationships how do what if I only want
to return back a little bit of data and
again maybe because of bandwidth reasons
or what have you or very concrete
specific use cases you only want to
return certain amount of data back
you could also support a fields query
parameter that tells that allows the
client to only return or only receive
the data that they actually care about
instead of the entire resource
representation I'm not saying this
technique needs to be supported by
everybody it can make sense depending on
the problem domain so maybe this would
be useful so in this case I would return
an account object with only with only
three properties the given name the
surname and the directory and here with
the parentheses you see that the
directories name is expanded as well so
you can kind of mix and match expansion
and restriction to give you back a very
customized view of what you want yes can
you return a collection and you mean
just get the accounts or properties
within each account yes so the question
is can I get in a collection for the
elements in that collection can I get
back certain elements or certain
properties on those individual elements
and the answer is yes it depends on your
parsing rules and what kind of parsing
techniques you support but if we had an
expand parameter and we specified
directory and then we said fields equals
you know x y&amp;amp;z then for each directory
element in that collection it would only
have those three properties so again
it's up to your your parsing rules and
what you want to support from a
performance perspective so pagination
it's kind of segue into that question
how you support pagination so every
collection resource we feel should
support query parameters that specify an
offset which is your starting position
in the overall list as well as a limit
parameter
which specifies the maximum number of
elements to return in the collection so
if I were to go to slash applications /
offset 50 equals limit 25 that means I
want to show the page starting at a 50th
element but show me no more than 25
items so here's an example of what what
it might look like if I go to the group
resource or sir groups for an account
and then I would list the items
collection no more than 25 because
that's the limit we also do something
for the hade OAS kind of acronym we
provide first next last in previous
links as well and the reason why is
because the consumer of this end point
doesn't with if you look at this
response in this response only the
consumer doesn't know how to pick up any
of those your eyes and chop off a piece
and stick in the offset in in the limit
parameter it doesn't know how to do that
stuff
you could via a media-type specify that
hey if there's an offset in the limit
parameter look for the base href and
then you know you can use that base href
and then specify these two query
parameters the media type actually would
specify those parsing rules but if they
don't know that they still have
properties that they can use to actually
go get other pages in the collection how
you structure your pages and whether or
not they're sequential or first/last you
know it's completely up to you
this is just one technique yeah yes
sorry yeah so the question is is in this
case we have a previous field which has
which is null because there's no
previous pages in the in the query
result set and so if that's the case why
not just leave the property off right
and the reason why we choose not to do
that is because it has been my
experience especially I wrote a lot of
the SDKs that wrap our API s and our
SDKs and even the JavaScript clients
it's more difficult for them because
they have to see does this property
exists or not so there's a lot of
conditional branching that just doesn't
need to be there as opposed to it's
always there I'm always going to check
it if it's null then I know that I'm at
the beginning of the result set so the
less I figure what they call the the
there's a statistic the computational
complexity of branching the less that
you have that the less bugs that are
introduced the easier it is to build and
test against so we we try to return the
data all the time to make sure that they
don't have to do a bunch of FL checks in
their code so this is the first
representation that we've seen of what a
what a collection resource looks like
and you might have noticed a bunch of
times I've been calling this a
collection resource not just a
collection and the reason why is that if
you look at this it itself is its own
resource and it just happens to
encompass a collection of items right so
instead of returning a JSON array right
Open bracket close bracket with a bunch
of items inside of it itself has a bunch
of properties and then it has an
internal items collection so the whole
thing is and is a resource first and
foremost just happens to contain more
resources via the items collection are
the items property inside inside the
resource so that's why we always say
collection resource versus instance
resources because they're both resources
first whether or not they have children
is another story yes yes so the question
is can you restrict or should you
restrict the limit size so if they say
the limits
million they want a million responses
back yes in our code we actually have a
maximum amount so while the limits
defaults to 25 we might go up to say 500
you know but we won't allow anything
beyond that I'm sorry
parameter validation yes absolutely yeah
so we actually we don't even validate it
we just say give me the you know math
max of whatever our maxes and whatever
map that min of whatever ours is and
whatever they specified yes so so the
question is isn't it better in this case
to fail because if you're using caching
and one has a prairie perimeter for a
million in the other has two million
then it's you know I think it depends on
your use case they're both considered
separate resources in the cache because
the query parameters are different so if
that has no adverse effect on your
client then there's nothing wrong with
it like it really depends on the problem
that mean maybe that would cause a
problem for input validation for some
services that had to have strict kind of
Terms of Service but for ours for
example we have no such restriction
because it doesn't hurt anything then
again I mean oh one of the other things
is because we're a security service in
the cloud everything that we do is over
SSL so unfortunately even though I doubt
caching we can't really use it because
everything goes through SSL on our
servers because we have support things
like PCI compliance and other things so
to that end we go through a great deal
of caching work on our end behind the
web server to alleviate a lot of this
pain yes actually no the question is the
HRF here is relative and it's not really
it's really an ellipsis dot dot dot just
to so I could fit it on one slide and
our API all the HR FS are always 100%
qualified and the reason why is we want
the client to be able to take that
property and execute a request
immediately with no problems yes
so the question is why not put the links
inside the headers right it's a good
question it's a valid approach the
question of whether or not you support
multiple or custom headers versus
properties for us really came down to at
the end of the day is it's it's it's
it's more intuitive and easy to use for
most developers like if I don't have a
special rest client then and all I have
is a browser I want to be able to see
everything I can do immediately but
without having to you know use curl if I
don't have to if I don't have it on that
box or whatever so that's really it the
of it one of the other things too is
that for the client we wanted all of the
relevant data for response to always be
in in the body so they didn't have to
look anywhere else and then simplifies
programming techniques is you don't have
to check multiple places it's always in
the data set that's respond it's always
in the payload it's not necessary but we
did that of convenience and and we found
that people liked that
so yes have I looked at RFC 5545 is
alright right right right yes I have
seen that one um in it it's interesting
I think I don't think there's I think
it's a good good technique the point of
that RFC I think is really to
standardize on a technique for
pagination and barring any other de
facto standard I think it's fine there's
no what's interesting to note here about
pagination can get really tricky if you
guys have a no sequel back store right
you can't use database cursors you know
on certain no sequel data stores or
actually most so how do you represent
pagination um and that's a tricky
problem you know there's ways to do it
where you actually chunk up the data
where you actually duplicate data and
say there's 25 in this bucket and 25 of
the next you have to invalidate those
entries as records or
dated so it can be kind of hairy
depending on your data store but that's
way outside the bounds of this of this
presentation so I won't really talk
about that here yes so when you when
you're querying the group do you
implicitly sort the items this question
we it depends on the item collection so
for example certain items in our data
store are lists right and so they have
an input and inherent ordering to them
already and those would be returned in
the order that they're stored you can
specify ordering based on query
parameters and that's the way that we
would recommend it but the difficulty
there is again if you're if if you
adhere to the hae e OAS type of
mentality you would essentially need a
link for each one of those sorting
options because the client doesn't know
how to construct a query so you need to
have a link that says these are all of
your sorting options and that's actually
maybe not that bad maybe you you have
data and there's five or ten fields it
could be sortable you just have ten
additional links in the payload it's not
that much extra data to support but
again that's a restriction on rest
architectures you can still be restful
without h80 OAS kind of techniques but
the purists like to stick to that yes
without implicit sorting the offset does
not make sense
oh yes es es yes yes you're actually
right sorry our queries that we execute
on our back end always have sorting
enabled because of the sort of because
of the offset and limit issues we don't
necessarily expose that to the client
depending on the resource some of them
might be sortable so in this case the
items just happen to come back in the
same order at all times even though on
the back end we have a query that does
specify Orion but it's not exposed to
the rest API client you guys are also
see when we start dealing with code
we tend to use linked hashmaps a lot in
our Java code to represent JSON payloads
because they do retain order and while
it's not required actually JSON
specifies that order is not guaranteed
we find it to be convenient for clients
that might want to rely on that behavior
or but the way information to present in
the browser is a little easier or more
aesthetically easier to consume by the
developer question XS D right really
good question so the question is before
we're talking about custom media types
and a media type is a data format and a
set of parsing rules associated with
that format so if the data payload was
XML how do you specify the media types
parsing descriptions you know typically
in the XML world you fall back on an X
SD to do that or as in JSON there's not
anything really like that in the
unfortunate answer to that is that there
are no techniques that are widely
accepted it's like we've seen media type
parsing rules is literally you know a
proposal for an RFC that says you look
for this before you look for that before
you look for that it's literally an
algorithm drawn-out in human readable
text that you have code that implements
there's also I think a an effort for
JSON schema which allows you to write
schema definitions in JSON it's kind of
funny because you know it's like XML
already has that down pat what while
you're reinventing the wheel that being
said the media type definition in this
parsing rules are completely orthogonal
to the actual representation so it's
it's totally within the realm of
possibility and maybe even you know
advocated that that is defined as excess
D whereas the JSON is the payload but
there there is no spec and there's no
widely acceptable standard of how to do
that so many to many this is the
question we get
that seems to cause a lot of questions
and confusion if I've got an account and
it has many groups and I've got a group
that can contain many accounts how do I
represent that in a restful
representation so for us each one of
those mappings is itself its own
resource so we have this group
membership concept that actually retains
a link to both of those entities and
while our internal data model and the
back-end system may not necessarily be
identical or have a one-to-one
correlation the rest resource
representation does represent it as its
own entity so here's an example if you
access the group memberships with a
unique ID you'll get back again it has
its own href its own global unique
identifier and then it itself has two
links to the things that it's
correlating a benefit here is that in
addition to just referencing the account
in the group you can represent a lot
more information like maybe who is
responsible for associating these two
things or the time that it was created
or what was the last time this
relationship was updated there's any
other amount of metadata you can
represent in the back-end system can be
represented via this membership mapping
and so in the account resource you'll
actually see that we represent groups
and group memberships as two separate
links because maybe in some context or
some scenarios the client doesn't care
about that additional metadata all it
cares about is giving me but just back
the groups or some context that might
say you know what not only do I want to
see the group memberships are what
groups that they're in but I also want
to see who created those groups you know
or what time that those things were
created and so two links are part of the
account resource the client gets to
choose the granularity or the scope of
the data that they want to see so it
also helps for backwards compatibility
so for example maybe you didn't have a
group membership concept in your data
model you know you only had a direct
association with groups you can add a
group members
Linklater when you introduce that
concept and it doesn't break the
existing functionality built on top of
that that link are that the the groups
link oh one thing I should note on
versioning is we only increment version
numbers when there would be a backwards
incompatible change and so for rest
resources we will add properties all day
long to our resources without
incrementing the version number because
it doesn't change what the client
expects to see what's that
yeah we're not taking anything away from
the client so I'm going to break their
current functionality so we will add
things but we will not remove things
without without incrementing a version
number I guess the other thing I forgot
to mention on the versions is that it
should be noted that versions are they
should be fairly coarse grained right
you shouldn't be incrementing version
numbers in your API is much at all so
you shouldn't have version 1.1 and 1.5
and 1.12 and 1.24 right those things
should change so so infrequently that
that whole based integers are should be
more than sufficient if you have like
version 23 that might be a problem
because then it's requiring clients to
change too much oh right right right
right yeah and that's because the the
question is you know the crew membership
URL looks a little strange and that it's
got a query parameter not you know a
child reference and the reason why it
for us group memberships are a top-level
concept right they can represent all
groups across all directories across all
accounts and so we're limiting the scope
of their query results to be based on
that particular account in that account
only
yes exactly
errors this is this is actually a really
cool topic and it seems to be something
that's fairly overlooked at a lot of
rest api's
the point with errors that I want to
convey is that you really want to be as
descriptive as possible you want to give
as much information as you possibly can
to whoever's consuming your REST API
developers are your customers whether
its internal or external the happier
they are and the easier that they can
debug problems the more likely they are
to continue to use your service and be
happy customers and maybe you know refer
you to other other people so you want to
make this as painless as possible like
one of the one of the biggest things
that will turn a developer away from
your service if your commercial is if
they're having problems integrating and
so the more information you can give
them the better so what do I mean by
that so for example here we're sending a
post to the directory's endpoint but I'm
creating a new new directory and I'm
calling it the Avengers directory and in
this case Avengers already exists in the
system and so the response is actually a
409 conflict to indicate that there's a
conflicting resource already on the
system what is that thing its term sorry
ah it's the game the cable sorry guys I
will not move um
don't know so when we show a rest error
we show a bunch of information one is
the status which is yeah that's fine I
can use a podium I'm not touching his
wife
maybe not maybe it is me maybe I got too
much static said okay yeah okay static
electricity check check
yeah thank you yep no static so okay you
guys hear me back there thank you
appreciate it okay so we want to we want
to give them a lot of information and so
in in in keeping with the theme of
keeping as much information possible in
the payload we actually have a bunch of
properties that come back during an
error the first is the status code it's
the same as the HTTP status code they
don't have to go to a header if they
don't want to to figure out what's going
on and also could be used you know if
you generate a report
you know the informations there it's
easy we also have this notion of an
internal code which is a further
extension on top of the status and the
reason why we do that is that I think
with the 400 the 4x X error codes in
HTTP they think there's only 15 or 17 of
them and eight in the 500s there's only
six so 500 through 506 and that's really
a maximum of what 23 odd kind of error
codes to indicate a whole wide range of
things that might have gone wrong and so
we also produce or provide at times a
code that gives you even more
information as to why something failed
that that can be used you know by a
programmatic client to further provide
more information to why something failed
in this case the property that failed or
that caused the failure was the name
property on the directory resource
here's the message and the message for
us is something directly exposed to a
custom application end user so the
developer can actually take this message
property and if they're building a JSON
based application for example show it
directly to their own and
user right and that's a really nice
convenience for people consuming your
API is because they don't have to worry
about how do I show information to end
users in a way that makes sense
so the message property is a concise
fairly clear human readable message that
can be shown to basically anyone and the
developer message further gives you
additional information as to why
something might have failed that's
relevant for a developer only so if they
see this in their in their stack trace
for example they can actually get more
information beyond just out 409 to
figure out why something failed and then
finally one of the most important things
is we have a more info property that
gives you a fully qualified link to that
particular error code and you know I
can't take credit for this by the way
the Twilio guys I think kind of really
spearheaded this approach in their own
API but the beauty of the more info
property is that if you link to a page
that you host you can do all sorts of
things right you can have a forum on
there you can have you know you know
chat now help me fix stuff or here's a
whole bunch of information as to why
this occurred right you have a
tremendous amount of information that
you have at your disposal for for your
customer that can really help them
through the problem and the more the
more resources you have at their
disposal the more likely they are to
stay with you as a customer so you have
a lot of power and flexibility here this
is a really clean way of supporting
errors yes is it a convention to prefix
code with what oh is it a convention to
prefix the code with status um it's up
to you this is actually not a message
and error response that we would return
from our API I just threw it up there
because it made sense and or at least it
made sense to me at the time that I was
writing the slide but that being said I
think it could be a good idea if you
have multiple reasons why something
would conflict I don't see any reason
why you couldn't just extend beyond that
if if the HTTP status codes that exist
are already a good delineator on
segmenting your errors then I think that
would be a good idea if they're not a
good segmentation of your particular
error conditions then probably not yeah
absolutely so I think
could you ever invent a new status no no
no no now yeah only if the HTTP spec is
refined right for us at least the code
or the status here always reflects that
reflects the HTTP status code the code
is really where you have freedom to do
whatever you want okay I'm going to kind
of fly through this a little bit more so
we can actually look at some code
examples so we'll talk about security
one of the interesting things about
security for HTTP and rest is you know
people advocate as a stateless platform
or paradigm so that really means you
know trying to keep sessions or avoid
sessions at all costs if you can and
what that usually translates into for
secure services is that every request
that comes into your system is going to
be authenticated somehow it's also
important to authorize based on resource
content not the URL and the reason why
is URLs can change over time right you
have the Freedom and the Liberty as a
rest designer especially as your REST
API matures and maybe certain parts are
decommissioned you can use HTTP
redirects to move users from one URL to
another if the resources changed um so
you don't necessarily want to authorize
based on that you want to authorize
based on the actual resource content
itself yes so the question is are you
using temporary or permanent redirects
all of ours are temporary because we
don't know at least yet as to the
longevity of a particular move if you're
going to authenticate users we recommend
that you use you know there's a couple
approaches one is you use an existing
protocol so there's a f100 a out there
there's a auth - I should kind of point
out Oh F - is sort of a misnomer it's it
is the next version in the specification
process but it's not actually
necessarily more secure than Oh F 1 dot
o a I off - sort of they kind of by
press bypass the authentication step by
forcing things to go over SSL and then
using a bearer token for the remainder
of communication over
for each breast call that goes through
the system O'Laughlin dodo a can
actually authenticate the headers and
the payload and every single request
it's actually very very secure if you
have to you can use HTTP basic
authentication but never ever use in any
scenario other than HTTP I should always
be over SSL no matter what
another approach and this is kind of one
that we do at storm path is you can
create your own custom authentication
scheme this is specifically supporting
the authorization header and the HTTP
specification only do this if you really
really really know what you're doing
because if you create a custom
authentication scheme and you're not a
security or crypto expert you can have
significant holes without you knowing
about it we're security guys that storm
paths and so we do have our own
authentication scheme it's very similar
to Amazon's
version 4 of their authentication scheme
ours we believe a little more secure
because we use a nonce technique to
prevent replay attacks but sort of
outside the scope of this presentation
but the point is if you create a custom
scheme the problem with that is it's not
standard and it's not necessarily widely
adopted so if you do that make sure you
have SDK clients that you build and you
distribute that will implement that
authentication scheme automatically for
your customers so they don't have to
worry about all the crazy crypto that is
necessary again I only do this if you
really know what you're doing in you're
comfortable with it
and unfortunately it's a whole new
presentation but you should always use
API keys instead of usernames and
passwords if you use a new username and
password for your API and the user
changes their password any client using
the eastern and password pair now no
longer works right it's very very
brittle API keys can also be rotated
over time they can be decommissioned if
if they might have been compromised
there's a lot of really good benefits
for using API keys so we recommend using
API keys and not username passwords that
are directly tied to a user account so
we've seen the schemes I'm going to kind
of fly through the rest of this stuff
yes question
authorised authorised based on a
resource content show an example of that
um it's kind of hard so I guess I should
say that uh in addition to this stuff
that I do for storm path I'm also the
PMC chair of Apache Shiro which is the
apache foundations security framework
and apache has very specific ways of
doing this or Shiro has very unique
techniques of doing this you can do it
differently with spring security you can
do it differently with Jazze there's a
lot of different ways to do that so it's
kind of hard to come up with an example
that that kind of applies to everyone
what I was really saying is that URL or
security techniques or authorization
restrictions based on just the URL name
it's probably fairly brittle because if
that ever changes for any reason your
security policy might break as opposed
to saying you know I'm restricting this
resource which is document ID 1 2 3 and
you restrict the resource not based on
the URL but the actual content and that
largely dependent upon your security
framework so yeah it's what you're
serving as opposed to how it's called
right that that's the real key takeaway
authentication schemes I the server will
issue a dub-dub-dub authenticate header
and the client responds with the payload
that's expected or the header value
that's expected for that particular
scheme you'll see OAuth you'll see basic
you'll see digest you'll see you know
storm paths custom one this is the the
handshake that's required for
authentication and HTTP so Wow
one thing that's kind of important to
drive home is the differences between
401 and 403 these are sort of
unfortunate right 401 often unauthorized
as they speak spec specifies it really
means unauthenticated not necessarily
unauthorized it means that you need
valid credentials in order for you to
continue on to this resource and 403
forbidden really means unauthorized like
you do not have permit 8 yes I
understand your credentials but you
still don't have permission to access
resource so those are the differences
between 401 403 they're important to
understand especially in the context of
security api's api keys you know I
talked about them a little bit because
they can be a lot more complex they have
a higher entropy so the entropy space
for API keys is much much larger than
your typical 8 to 13 character passwords
so therefore they're harder to break
assuming you're using salting techniques
and stuff efficiently again if you've
reset a password and your API keys or
based on passwords now of your API
clients break that had that password in
you can kind of reduce exposure so for
example in storm path if you use an API
key to access our service you download
that API key to your filesystem and it's
stored securely there we don't ever
advocate copying and pasting keys into
code and you know everything should be
external to the codebase so you can kind
of get exploited exposure based on API
keys where copying and pasting values
might not be a good idea if you have
questions about this stuff you know let
me know after the presentation IDs I had
mentioned before they should be opaque
they should kind of be globally unique
as you move to more no sequel types of
systems these days when you can't have
global unique identifiers you know time
base uu IDs are a good technique
anything that can be globally and unique
we recommend that you avoid sequential
numbers the first reason is really from
a contention issue if you're in a
clustered distributed API service you've
got multiple web servers and you have
them all trying to access or create IDs
at the same time you could have a
contention issue right if they're all
trying you basically have to have a
single source for that identifier our
single single number or sequence
generator that could be a point of
contention depending on the load that
you get on your system it can also be
used as a technique and fussing
is a technique where maybe I see URL
ends in slash 23 and then I try slash 24
in this last 25 to see if I get access
to information you want to just
eliminate that possibility up front your
API still should be secured based on the
identifier or the content of that of
that data
but this just helps eliminate certain
attack vectors you you IDs we is
something internally called URL 64 which
is basically a 64 it's similar to base64
but it doesn't contain any reserved
character so you can actually exist
inside of URLs so anyway good IDs how do
you do method overrides sometimes this
is asked by people to have to support
older HTTP clients that don't support
maybe delete or put you can specify a
method query parameter and basically
what this does is you know you can set
up a for example a servlet filter that
just inspects this and changes the the
method to post or put a delete instead
of post if you do overwriting are
overloading from delete or put should
always be based on post because it's
identity and the server can can it's
legal to do this it's not legal to
override it via put caching currency
control HP has a specific as part of the
spec has this notion of etags and an e
tag is really a unique version number
and so what's beneficial about this is
if your response has an e-tag the client
can send a response later our request
later to saying you know give me that
data if if there's something different
than this version number that I'm
sending you and so if it hasn't changed
on the server the server can return 304
not modified with no body content it's a
lot more efficient to do this and you
don't have as much data going over the
wire so clients proxy servers they can
support this technique so if you support
unique version numbers in your resources
on the server you can support a more
efficient caching infrastructure again
for us everything is over SSL so we
can't really utilize this as well but we
can use the e tag as a mechanism to
trigger our own caching on the backend
maintenance so once your arrest API
comes more mature over time use
redirects it's part of the spec client
should be expected to handle them if you
want to move a URL pattern you know from
slash accounts to slash tenants slash
accounts or something like that
you
should be allowed to do that as an
architect and clients should be expected
to handle redirects accordingly you can
create an abstraction layer so you can
have basically a set of controllers that
support version 1 and maybe they
redirect a version 2 or internally they
call functions for the version 2
controllers you can use these techniques
to mitigate change to existing clients
or reduce the impact of change to
existing clients and then finally use
welder flowing media types if you can
okay
any questions on the stuff before we
start looking at some code
so the question is is using a rest
increase the number of tables in your
database schema for example excuse me so
what is what is kind of the
yeah you can do that I mean there's with
identity you can you can leverage puts
especially gets and of course the you
know the not modified or you can send to
a for 304 not modified those can be used
to support asynchronous api's but the
point from the web servers perspective
is that has to give a response based on
its current statement that it knows
about when it responds to that
particular caller so it doesn't really
care whether or not the client as they
sink or not the client for async
environments has to adapt to it to
integrate with these patterns yes so we
didn't cover localization the question
is how do you guys handle it or have you
given localization much thought and the
answer is we currently don't address
localization in other words we just
regurgitate the data as it comes in to
us
however on messages our error codes
those will be localized for for whatever
they'll based on the locale header that
comes in on the request yes
so any have I experienced or found any
query patterns or query mechanisms for
rest-based API acquiring a domain mount
no not really I mean it's interesting in
that the only querying that we really
hear about on on boards and forums and
stuff has to deal with how do you handle
query parameters in your REST API you
know is it considered cashable or not
cash flow like does it affect the state
of the resource or not there's no
standard querying mechanisms of how to
represent or query for information so
the way we handle it is the query
parameters are truly we feel as
directives to the server on how to
handle certain things and we use query
parameters as a syntax that will then in
turn trigger certain query operations on
our back-end so but there's no custom
API or or syntax that's standardized at
all it's there's no effort even that
I've seen that standardizes something
like that core data open data yeah not
that I'm aware of
doesn't mean it doesn't exist I just
haven't seen it yet so maybe they have a
solution for that I'm not sure though
okay so yeah ah that's a really good
question so if there are actions other
than create read update delete how do
you handle them with a REST API and the
way we handle it it's a really good
question because it does arise in
certain scenarios we actually simulate a
resource based approach for certain
behaviors or actions that don't map
directly to crud a really good example
is that because we're an identity
service you can log in users against our
system so you actually send in you know
credentials over SSL to us and we will
authenticate the end user for your
application
you're not really creating or reading or
updating or anything in the traditional
sense but what we do is we actually
modeled that as an auth
occasional alright this goes back to the
beginning or everything in rest should
be a noun and so really an
authentication attempt is a behavior
it's an action being taken against the
system
it doesn't necessarily translate
directly to crud that you would see for
a directory order account but it's a
behavior being taken and we modelled
that as a noun and so we call that an
authentication attempt and so when you
authenticate a user our system you're
actually posting to the authentication
attempts endpoint and it creates a new
resource on the server and that it just
returns you you know a link to the
account that was successfully
authenticated and so we have we have
used some techniques to to simulate noun
based approaches to behaviors and um
it's it aid no it is it will be saved to
the system and it's only accessible to
certain people depending on querying
reports for who have secured access to
that data it wasn't like that when we
first created it though after it became
a resource we realized it could be
utilized for a lot of other things and
that actually drove our API to be a
little more resource based and our API
was better because of it so if you can
do those kind of things I think it'll
simplify how you represent those things
to end-users and and it'll kind of
illuminate certain things in your API
where there might have been holes or
gaps that you could you could fill in so
all right we're going to take a look at
some code um we unfortunately don't have
a whole lot of time so we won't be able
to do step-by-step but I'll show you the
basically the finished product of what
this simple demo app looks like you can
all go to to github our storm path
github area and check out that or clone
the to do is Jersey repository and what
it is it's a very simple to do
application you know whether or not I
clean the garage or picked up something
from the store and you can create and
add to dues and you can delete them
let's let's take a look at and see how
that how that looks from a code
perspective the question is is can I fit
on the screen
you guys that's probably a little a
little hard to see in the back so one of
the first things about jerseys you know
this is this is a pom project we're
using the latest stable version of
Jersey 1.4 or excuse me 1.1 for and so
all I've done because this is this is a
web-based project using a servlet
container it's not a standalone server
using the Grizzly servlet engine for
example but we're using the latest able
version and these are the only the only
two dependencies that are necessary for
the project so you can you know they're
available maven central they're easy to
access and just we're using SL f4j as
the logging API there's nothing really
complex about it so once these two
dependencies are in place the first
thing you want to do is setup actually
me close this project web dot XML and in
this case we're just using a servlet
mapping and so we've got jerzees servlet
container servlet and we're telling it
to scan a set of packages that we
specify that contain all of our jax-rs
annotations or excuse me
they contain classes that are themselves
annotated with jax-rs annotations and so
in this case we've got two packages
we've got a generic controller package
which is where all of our rest
controllers exist and we've got an
infrastructural package that you know
it's called dot Jersey in the in the in
the package hierarchy that contains some
meta kind of infrastructural components
that Jersey needs to make things work
yes
yes so the question is is Jersey
specified Jersey allows you to specify
an application class and inside that
application class you can specify all
the rest resources that you want to
support do you recommend that over the
package scanning a technique I have no
recommendation it's whatever you guys
prefer we at storm path like using the
package approach because everything is
just picked up automatically we tend to
prefer the lower friction techniques
even if it might you know expose
something that's not 100% finished we
kind of resolve those issues and user
acceptance testing make sure that stuff
that shouldn't be exposed as not we tend
to automate things where we can so we
like the packaged approach but I don't
have a particular recommendation so in
also because this is we're focusing on
JSON here we've specified in an it per
m2 this servlet saying that we really
want to utilize
pojo mapping for for objects that are
transmitted to and from the server and
this is really necessary if you're using
JSON if you're using XML and Jack's be I
don't think this is required but it's
definitely required if you're using
Jackson for JSON so turn on this init
program and in here we've got a we're
just mapping all requests to the to do
servlet we I could specify /v 1 for
example but in the simple demo I didn't
so basically this this particular web
app services only rest requests and
nothing else so that's it that's the
only thing you need in order to get the
stuff up and running inside of your web
app is to define the servlet specify the
JSON object are the pojo mapping feature
and you're good to go
you'll see in the the packages here
remember I told you guys I had an
infrastructural package for Jersey I'll
show you what what those components look
like so the first one I did is I'm
customizing Jackson here thanks man so
Jersey provides this provider annotation
that allows you to provide multiple
implementations of sort of
infrastructural hooks into the Jersey
framework and in this case my provider
is going to resolve an object a Jackson
object mapper in the app the context for
Jersey and all I'm doing here is I'm
customizing the object Mak mapper that
will be used at runtime by default the
object mapper for Jackson doesn't assume
any particular time zone or a timestamp
format and also it will not indent
output or prettyprint
is what people like to call this and so
from for this simple demo app I wanted
to see the output in the browser pretty
printed as well as there's the ISO 8601
timezone format so I'm just telling
Jackson every time it sees a date I want
you to print it out in ISO 8601 UTC
formatted date so there's the only 2 2
customizations I've made to Jackson to
adhere to the stuff that we talked about
earlier in the presentation so this
provider will make sure that that
Jackson mechanism is used and not the
default the other infrastructurally ated
this is a bit nasty you guys will
definitely want to check this out on on
the github project but this is I
actually wrote a blog article about this
unfortunately was in the context of
spring but the same concepts apply here
is that Jersey has an interesting
mechanism to take an exception and
represent or return or set the proper
error header to the client but remember
before I was showing you guys how we
want error messages to be very detailed
and have a lot of information and so
this exception mapper that I created is
also as you can see annotated as a
provider component and when Jersey
starts up it says oh this is an
exception mapper I mean anytime a
throwable occurs from anywhere I'm going
to hand it off to this exception mapper
and the exception mapper is going to
render the response and so what that
allows us to do is based on any
exception that occurs at runtime whether
Jerzy throws it or we throw it or
whatever it allows us to take this and
translates it
into this custom object called a rest
error this is something that I created
again there's a blog article on our page
if you want to see how it functions but
it takes the object and it spits out a
rest error object that encompasses those
five or six properties that we showed
you on the rest response write the code
the status message the developer message
and so whenever an exception is thrown
it will catch it and then it just places
the status code based on the air sets
the media type to JSON and it translates
it to a map object so Jackson can handle
it easily I'll actually show you an
example of what this looks like in a
second like will actually fire up the
server so you can see what the errors
look like but this applies for all
throwables and so there's a lot more
infrastructure stuff here on how it
resolves errors at runtime one of the
things that might be interesting to you
guys if you use this by the way
everything here including the
infrastructural components is all apache
licensed so you guys can go home clone
it use it take it you know do whatever
you want to do with it Apache is very
business friendly the way this works
actually is this guy at startup will
read a properties file that I defined
and what the way this works is it based
on the class of the exception or any
part of that class or the classes
hierarchy it will return it says the
status code you can also specify the
application specific code you can say
that the message that I want to be
specified is the exception message
there's any number of parameters here
that allow you to customize exactly what
that payload looks like in a very short
succinct kind of definition format so
here I say anytime an illegal argument
exception or validation exception comes
up I want to throw a 400 yes
where's the call for what storm path so
storm path we're not I'm not
demonstrating storm path in this little
the demo for Jersey yeah no yeah so we
have our own dress SDK and stuff that
that is you could drop into any java app
or Clojure or whatever that yeah this is
plain vanilla just a jersey app and
you're writing it from scratch for the
first time this error mapping technique
though is custom to what we've done in
the past based on our work and again
it's open source you guys can use it the
reason why we do this is because we
found in practice that the jersey
exception mechanism they have this
notion of I think it's called a web
application exception and it takes in
the HTTP error code that should be set
as a server response we found that to be
too tightly coupled to the concept of
the web so for example you know if
you're using hybrid 8 and hibernate
throws on you know an object not found
exception right that has nothing to do
with the web but using this technique I
can actually enter in that exception
here and translate it to a value a
valuable error message payload that will
be sent back from the REST API so the
rest api has no knowledge of you know
tier specific exceptions with the jersey
approach you actually have to catch
those and translate them into a jersey
specific exception or subclass and we
found that to be too tightly coupled as
a technique or as an approach this way
allows us to support any exception
regardless of the tier that comes from
runtime or not exactly exactly so you
can actually pull in error from the
message exception like that's what this
this underscore is the special token
that says the message property of the
JSON payload use it as the exception one
but other things for like authentication
exceptions we won't do that will
actually override that as you can see
here you know in specify on manual one
and although this doesn't it doesn't
work in my code sample that I have here
the one that we use will actually do a
translation based on locale so it'll be
like a token that gets translated to a
language specific error message so
that's all I want to cover from the
infrastructural stuff again you guys can
look
you can use the code this is very very
useful in production apps and it's nice
because you can get a full list of all
the problems or errors that might occur
in your app and you can react to them
accordingly and then of course down here
is the catch-all if the bubbles up in
the chain and we hit the root throwable
just return to a 500 server error yes
does the examples show how hade OS is
implemented um it does to a certain
degree so for example like you know
we've got it to do so let me let me
cover the the segmentation actually on
how how this app is structured and then
we can kind of dig into some of that
stuff so it's kind of hard to see it I
wonder if I can zoom in on this part
maybe not nope anyway at the basis of to
do application or to do base package and
under that there's controller we diverge
a little bit from the typical Jersey
approach where Jersey uses the word
resource as the suffix for the class
name like to do resource or user
resource we diverge from that paradigm
we like to think of these more as
controllers and the resources are the
actual data that's transmitted back and
forth so you'll see in here you'll see a
base controller you'll see it a to do
controller and these are the controllers
that actually service the request and
inhalable responses and the resources in
this case a to do resource encompasses
the data that's going to be sent back as
a JSON payload I should kind of note
here that you'll see our resource object
extends link and this is a class that we
created that extends link hash map and
the idea here is that for a given
resource it's always got a fully
qualified based path and there's always
an entity in the system that represents
that that resource so this is similar to
how most enterprise applications are
developed today there's you know
typically a base entity class that has
an ID
then you have a subclass maybe you to do
which subclasses entity typically these
things are mapped to JPA or hibernate
based kind of persistence strategies
these things kind of represent what you
would interact with from a business
service and so we have as you might
expect a to do service or you can get to
do is you can get them by ID you can
save you can delete and this one in in
essence interact with your back-end via
daos or whatever technique you usually
use to interact with a datastore the
idea here though in kind of the meat of
this is that our to do controller is
sort of your bridge from the Jersey
world into the rest of your businesses
services so there's a to do service has
no notion or understanding of Jersey I
it's something it's core to your
business API but your controller is the
thing that interacts with that service
and will let me smooth this over
interacts with your service and then
will either return a collection resource
right we mentioned collection versus
instant resources in this case a simple
get 2/2 dues will return the collection
resource and the collection resource as
you might expect supports the notion of
limits and offsets right these are
definitely more simplified than than
what is used in a typical production
system probably gives you an idea of how
you can represent these things what I
did want to point out is both the
collection resource class in the regular
resource class to do resource they both
extend link and all link does this
provides that common href property right
because an href is common to every type
of resource that we offer whether it's
collection or an instance and so by sub
classing the link even though it might
seem a little counterintuitive we get to
support that that base property and then
add in those additional properties as is
necessary for that particular type of
resource so going back to the to use
controller that's that's the list
shows a collection resource here I'm
showing you a very simple version of an
expand query parameter right whether or
not I want to expand the to do the the
user or not or expand it to do in its
entirety so if I want to expand these
lists that are returned each element in
the collection will be fully expanded
otherwise it'll just be a link that's in
the items list right naturally this
would translate into a more complicated
mechanism using a query language or or a
grammar that you can use to either turn
on or off certain features but this at
the very high level shows you the kind
of logic here is the the create method
so it's work in this case we're doing a
post to the slash - duze link you know
we're saving the to do we're creating a
resource which again subclasses link and
then calls this common method in the
parent which is what Jersey uses to set
the location header remember before
we're talking about 201 responses need a
location header when you specify the
created URI it will set the location
header automatically this is the payload
and then you build the response and then
Jersey will excuse me pass it off to
Jackson which translates it into a JSON
object so all of our controllers kind of
extend from this base controller concept
there's the two controller yes
so the question is J box has a rest easy
project how does that fit into here um I
could be wrong here but my estimation
rest easy and Jackson or rest easy and
Jersey and spring rest are all kind of
competing frameworks you kind of just
pick which one makes the most sense to
you based on your background based on
your knowledge there are pros and cons
to both like there are certain things
that Jackson does her Jersey Jersey does
that are a little bit nicer than Springs
but Springs on the other hand can give
you more power depending on certain
scenarios it's really based on your
background like that's that's really the
only difference yeah
yeah that's true yeah but that's the one
thing I forgot to announce like if you
look at the class here the the package
is Java ax WS o RS right
these are specification specific
annotations so if your container arrests
easy spring Jersey supports these
imitations that shouldn't matter so I
should be able to take this code and
deploy it on top of spring it should
just work here's an example of
interacting with a particular instance
resource and so in this case I'm using
post to update data typically updates
can be done like remember I said before
post you can support both partial and
full updates for the demo I just kind of
hacked it out and and and said if the
data is applied only them am I going to
apply it to the underlying data model
but typically we rely on a framework to
automate this to determine if data
exists and if it does set the property
that allows you to set one or multiple
properties depending on the payload
here's a here's a delete example and I
can actually you know I'll show you real
quick I'm going to fire up what time I
have left man I don't know how the I
guess I have to change the
let me see something here
anyway the servers running you see does
that work
nope it didn't work
let me see I don't know if you a side
note you guys might find this
interesting how many people here have
heard of HTTP ie you guys know what this
is we've got one guy he does this is
pretty cool it's basically a curl clone
but it's way easier to use and it
defaults or assumes JSON by default and
it color codes everything it's just a
lot easier to use so as a side note you
might want to take a look it's called
HTTP ie it's based on Python but you can
solve very easily it's since essentially
a curl replacement it makes testing what
rest services really really easy the
question is how do I get out of this I
want full screen on this thing but I've
never done that on the terminal before
oh come and enter thank you thank you
thank you you can't really see it well
but I just issued a post to the the to
do resource and it created a brand new
one and kind of going back to our notion
of H ATO is the user reference for the
user that created the to do is included
in in the link included as a link
property right and so if I want to find
out who that user is all I have to do is
literally copy and paste this URL hit it
in a browser and now I see the user and
that kind of back and forth linking to
resources what works for up let me see
if I can execute HP post localhost:8080
- duze actually let me do it get
so give me collection resource back
right HRF here's the items the limit the
offset and the items has a link to it so
if I actually copy and paste that link
and I do ACP get then I actually get
back the resource and itself has a link
back to the user so all the techniques
that we've talked about are covered in
the source code it's available under
apache license on github feel free to
check it out clone it i have my contact
info here if you guys need to get in
touch with me you can hit me on twitter
at el hazlewood you can also mute less
at storm pat calm if you have any
questions about how the stuff was set up
any of the code any of the techniques
involved and of course storm path is
free for all developers to use you can
try it out if you're curious about it
but if you don't to be another LinkedIn
check us out</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>