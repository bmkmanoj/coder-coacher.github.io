<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Continuous Enterprise Development: Case Studies in Java EE Integration Testing | Coder Coacher - Coaching Coders</title><meta content="Continuous Enterprise Development: Case Studies in Java EE Integration Testing - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Continuous Enterprise Development: Case Studies in Java EE Integration Testing</b></h2><h5 class="post__date">2013-02-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/7HN_jIN4wPU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm ultra excited for this talk truly
truly excited because in the past we've
done these things and we've done the
Java ones and the dev oxes and they're
all fun and we normally try and preach
to try and preach a line of
accessibility and simplicity and when
you're doing that sometimes the message
can come off is a little bit soft so
while we've really appreciated the
people that have appreciated our types
of talks we sometimes get feedback that
maybe we're glazing over something or
it's not as complex as it can be into
this particular talk we're going to dig
into what we believe are kind of the
warts of the EE platform it's not
necessarily the it's not an infallible
thing by any stretch of the imagination
and it can be difficult to develop on in
some ways it's gotten a lot better over
the years but we're going to show some
of the cases today that we feel are both
difficult to develop and to test and
we'll try and show you why we believe
that testing isn't some other thing that
you do separate to development it's
should really be central to your process
and when it become central to your
process it actually does make it easier
to develop and you save so much time
over the long run at least that's my
experience and that could be because I'm
a very slow coder to begin with so
testing the stuff isn't going to add all
that much for me my name is Andrew
revenger I'm a senior software engineer
with jboss I've worked on the
application server for a few years
lately I've gone more into usability
type projects joined with my colleague
ashlock doutzen who's joining us from
Oslo also a JBoss engineer and the lead
of the arquillian platform which will be
looking at and a little bit today so I
think you know we should get through
some of the more conceptual stuff first
just so that we're all on board and then
we're going to try and do as many of
these demos as we can but again we're
not going to rush through any of the
demos to be able to fit them all I think
we'll just try and
feel it out and make sure that we're
testing all the cases we want and if you
have questions or concerns or anything
related to like shout them out because
the feedback helps us this talk mirrors
a book that we're writing and we want
the book to be reflecting what the real
user use cases are and honestly like the
inspiration for all that has been the
feedback we've gotten over the years so
we'll kick in reasons to not tests or
some of our preconceptions about testing
include that it's too hard or that it's
too slow and it takes up way too much
time and most importantly that it's not
fun honestly things can be hard time
consuming and slow but if they're fun
you're going to do them in your spare
time anyway and what we really need to
do is is enable this to be a much more
enjoyable experience for us all so one
of our friends and community
contributors Jeremy Jeremy Norris came
up with a quote which is it's like I
wanted to steal it but I think he wrote
it somewhere publicly so I like we got
to attributing it to him somehow and
what he said is the purpose of automated
testing is to enable change verifying
correctness is just a nice side effect
and when I start to think about this I
think about maybe the the six weeks that
I worked with with corel here over
completely refactoring an API and the
implementation as well and continually
rebasing it top of current work and what
we did was reported the test suite into
the new stuff so we had functionally
equivalent coverage and then squashed it
all into like one big mega commit or at
least one mega push i think it was still
many commits but they all went in at the
same time and we like pushed it tested
it and release it all in the same day
and the reason that we were able to put
in this like 5,000 line change all at
once without any fear of breaking like
existing functions is because we had a
decent test week to begin with that was
going to give us coverage and we kind of
knew like all right this stuff is all
apparently still working so I mean let's
let's go right ahead testing is
development
or it should be I think if you're doing
it right a lot of people will talk about
test-driven development comes from the
agile community and before that from
extreme programming and a lot of people
say that with the test driven
development you know you step out your
API and then you write your tests and
then you develop I'm actually not going
to advocate for that specifically I
think whatever your process is being an
iterative or be it test first or you
know even if you just want to put
everything in place first and then make
sure that you got your coverage later
whatever works for you I say as long as
it's when it goes into the code base it
all goes in together and you've got
coverage to ensure that it works then
great this is for a few reasons I'll
hang on this slide for a second this is
for a few reasons one is yes it's for
the coverage it's also it makes you a
user of your API and the second you
start to write tests and you the
developer not like someone else in QA
whose job is to just do testing that's
it's really not Q a job you as the
developer write tests for the api's that
you're writing you immediately get a
sense of how it's being used is it too
verbose is it clear is it concise does
it make sense and a lot of times you
don't see that until you actually start
to type things in and see the IDE
autocomplete it or pop-up advice and and
these things can be really helpful in
informing your decisions in doing your
software design we talk about testing
will talk about a few different types
there's acceptance testing this is kind
of a business level thing where you've
got business requirements and so you'll
write like really high level tests to
show that you can meet those business
requirements and they're generally
accepted by the people who were demand
in the business requirements so you
might have something like really really
high level user can create a new account
and it sends an email and registers
everyone in the database right I'd be
like an acceptance test there is
compatibility testing to make sure that
yeah maybe you've got two different
pieces of software and they need to
interoperate you know between contracts
maybe just got two versions of the same
thing in the shrink-wrap project I have
had
tests for wire compatibility that ensure
that the wire protocol is forward
compatible as forwards compatible let me
do serialization over the network I want
to make sure that it's forward and
backwards compatible so that when we put
new fields in it doesn't break older
versions that are of the same major
release version we have functional tests
again kind of high level the like in the
middle there I mean I generally don't
label things necessarily as functional a
lot of people do they'll go functional
system and they cut them up really small
in terms of where the responsibility
begins and ends I'm definitely not that
strict when it comes to my definitions
there's black box testing which is so
named because say you're testing some
sort of an object from the outside then
what you do is you send the request in
and you get some sort of a response back
and that's when you begin and then you
don't know anything that's going on
inside of the box conversely there's
white box testing where maybe you do
have access to the internals of this
thing you can see it a more fine grained
level what's going on on the inside and
kind of look at those internals to make
sure that they're all working is
expected to one isn't necessarily better
than the other they just have different
needs and purposes so if you're doing
maybe a web service and it's like a
restful service probably want a black
box thing to chest the endpoints and the
client requests make sure you get the
response that's all you care about is a
client but if you're doing something
that maybe is interacting with the
container like we'll see in a little bit
might be able to want to like muck
around to the internals in here and
switch up the configs to intercept the
transaction or interact with an entity
manager or something so that your test
can test things that wouldn't ordinarily
be able to do that's very important so
we'll see that grey box is a term that I
believe we've come up with I believe
it's a sucks actually maybe not well no
one wants to take credit for that one
it's kind of as the name implies a
combination of black box of mike box
where
you're starting off from the outside but
you're going to inject something inside
it's going to be able to receive stuff
and then when it comes back out again
you'll see the response so it's a nice
hybrid model I believe that's something
that we're doing first or we've
identified I'm not exactly sure we'll
have to see there's regression testing
which will make sure that you know once
you have bugs in place you fix those
bugs you make a test case for the bug
and that test is now in place to make
sure it doesn't regress back to the
previous state there's smoke test smoke
tests aren't really tests in and of
themselves a smoke test is a subset a
smoke test is usually a smoke test suite
and the smoke test suite is a subset of
probably a larger test suite so in jboss
application server used to have like
thousands of tests and you couldn't
possibly run them all on your machine
before you committed so what we used to
do was run a series of smoke tests it
was like a sampling of like 50 tests
that would test they need to be the web
layer Jam pass just some stuff to make
sure that I at least the components were
like kind of hooked in together and they
say where there's smoke there's fire
which means that if any one of these
things fail probably you've got like a
real serious systemic last systemic
level problem going on and there's also
like load stress and performance testing
which is as the name implies it putting
your system under load seeing how it
handles that and you can do all sorts of
great things from that because you're
not really doing assertions on those
tests nearly as much as you are placing
stress upon your environment to see how
it performs but also more importantly
how it scales and how you can predict
usage pattern so you know if you've got
some sort of a problem where you start
to add users and it's great at ten and a
hundred and a thousand but then it
starts to like really degrade in
performance you know you've got some
sort of a geometric problem and you got
to solve that to make it you know maybe
a linear but much better a constant time
or linear rhythmic type of a thing I'm
sorry a logarithmic type of good thing
then your rhythmic would be just right
on the year so at the smallest level of
testing we have is the unit test we're
all familiar with this anyone
and unit testing anyone unit testing
java ee stuff anyone like how how ru
unit testing your java ee components in
the black shirt
boo so he's got many layers he's trying
to isolate the logic as much as possible
this is great and java ee you know
starting at ee five became a pojo
component model to try and encourage us
to be doing these types of things you
know in Prior versions of EE it was yes
I'm sorry oh why want to talk
specifically about java ee unitech what
do i define is unit testing oh i define
unit testing usually as a single API
call it's at the lowest level and that's
a general rule of thumb i go into
integration when it deals with the
interaction of two or more components I
unit test my hash codes and equals
methods on all my value objects all the
time because the okay sure yeah right
you say the word unit as if unit is some
sort of standard measurement like a unit
is any arbitrary amount so again I don't
I when it comes to most of my software
development practices I don't strictly
adhere to very much as a guideline I say
an API call but more generally speaking
I say use your head if you're
interacting with two or more components
then you're definitely dealing with an
integration point between two if this is
really an isolated case you said
isolated then yeah that in my mind would
be a perfect candidate for a unit test
does that help to answer your question
okay
the second part of that was why do I
speak to it in the context of Java EE
the reason I speak to that in the
context of Java EE specifically is for
just the reason you mentioned which is
the use of monks Java EE is a component
model and as a component model it lets
us do very complex things in very simple
ways but there are side effects we're
still doing very complex things we're
just letting a container give us
services that enable to do it in a much
more efficient way so we're doing
services like injection transactions
security and when you use mocks or you
instantiate an ejb as a pojo got news
for you that's just a pojo it's just a
regular object and you're neglecting
most of the runtime environment so if
you're only doing unit testing or you're
only testing your enterprise components
as objects then you're missing a large
portion of the picture coverage in your
running app comes from the full
complement of all the byte code that's
in the machine it's being executed not
from just the bits that you write and
this is a very important distinction so
this brings us to the unit test now
right bring this to the integration test
now where we say all right look we've
got many things that all need to
integrate with one another and we've
also got to integrate with a container
and the problem with integrating with a
container historically has been that
containers are kind of cumbersome to
work with you've got to do your own test
setup you got to do your own test
harness it takes a tremendous amount of
time and knowledge to be able to
integrate these things and put them out
together it usually leads to best folk
solutions to like put this all up it's
just very messy right so what we tried
to do is give you tools that are going
to enable you to have all the benefits
of a full scale integration test but
make it look read and write like a unit
test and that's been going to enable
this we've all seen this term continuous
integration what does it mean to you you
awesome because I actually don't know
and I was hoping someone would help me
out here
yes that's a really good yeah that's a
really good elevator pitch for
continuous integration there are a few
tenants that go on here that are I think
I think they were first laid out by Kent
back in his book extreme programming
they were definitely adopted later as
part of the agile manifesto with you
know Kent Beck and Fowler and ward
cunningham and those guys and continuous
integration is about yeah having having
a source code repository it's about
having a build server that's going to
build these things I think when the
paper was first written it mentioned
something like nightly builds or
whatever but you know since then we've
gotten much better with our
infrastructure and we can now kind of do
tests on every commit jboss application
server now works based off topic
branches and get so that every commit we
make is made to some fresh branch that's
isolated from all the other main line
development and then what we do is we
run all the tests on just that branch
with just that change and if it passes
then we will then promote that commits
into the main line we've got a lot of
people contributing and all working on
this so to have that process automated
automation is key here to you get this
kind of continuous integration solution
so it's really the merger of having
source control and a build system that's
centralized and a way of handling the
changes emerging them all together it's
it's a workflow okay but it all stems on
the fact that there are tests written in
the first place otherwise you've just
got a really brilliant system put in
place that will run nothing see I
memorized the slides I'll probably
automated deployment actually is a new
is a newer is a newer tenant here not
originally in there but you know we've
now got the ability to do automated
deployment into the cloud from some sort
of a trigger maybe a git push or
something else so continuous development
is the name of the book it's me ox
lockets our colleague dan allen you may
know him from scene team
fame and he had also written a seaman
action a very popular book from Manning
and we've kind of come across all right
we've got a little bit more than this
picture of continuous integration we
really need to be stressing this
continuous development it's not about
testing it's not only about integration
yes it's about all these things but we
also need to be enabling people
especially in Java EE to develop java ee
code in a testable fashion and it's not
the easiest thing in the world to do
especially since a lot of it's largely
left untouched by the specifications and
because of that there's no kind of like
rules to the road for how to go forward
so we said we would write the book yes
we're going to write it about the
technologies that enable this but it's
really going to be focused on the use
cases and the use cases are some of the
things that we're going to see today I
have got to hurry up through these
slides so we can go see them our
philosophy is generally this tests
should be portable to any supported
container by that I mean if you are
running CDI test you should be able to
run it in any CDI container be it weld
or open web beams or I don't even know
what else test should be executable both
from the IDE in the build shouldn't take
separate steps shouldn't take separate
custom plugins or anything to be able to
execute these things we've already got j
unit runners and test ng runners and
they're supported by ant and nathan and
like every ide under the sun they've
kind of become standards so we can like
piggy back upon that type of adoption
and we don't have to like provide our
own plugins and we don't have to impose
any new stuff like a build system upon
you you can just kind of choose whatever
you got three the platform should extend
and integrate existing test frameworks I
kind of hinted that with jr. and test ng
thing these are test frameworks they
work really well they give you a life
cycle for your tests so if we can
piggyback on top of that life cycle and
now give them some services and support
we're in great shape the demo app is one
that is running right now we're going to
come back to it but if you would just
come in and you haven't yet like check
this out you can go in line and put some
data in there and
we'll see it in a little bit for your
reference the book and the URL are here
I think we can just dive into examples
at this point yeah okay so the first
example will show is probably the most
popular question that we get how do you
deal with persistent data you know it's
like I'm sorry yeah we have entity
objects and JPA and starting an EE 6
we've got bean validation spec led by
our buddy Emmanuel Bernard who i believe
just gave it to talk on it or if giving
one pretty soon anyway p invalidations
pretty awesome it allows you to annotate
on your beans a single entry point say
this is an email address or this has to
follow some regex or it's got to be a
number larger than X or it's got a not
be null you know and this this one
definition is going to be picked up by
some of the disparity technologies
within the EE platform and your view
layer is going to know about it so
you'll be able to validate on the view
and if you've got some sort of a
JavaScript d thing that generates stuff
it'll be able to be picked up on it and
validate on the client side definitely
be validated by hibernate which is going
to might generate your schema and it'll
actually put the constraint on your on
your domain so you've got like the same
type of restriction at many levels but
only one place to put it that's real
nice for keeping track of things because
we don't like to rewrite things all the
time so we talked a little bit about
this unit testing thing and we can argue
whether this is really a unit test or
integration test because yes it's
integrating in with hibernate validator
and yes it's got a couple of objects in
play but it's not integrating with like
a true back-end container what we're
doing is we're manually going to take
our entity and manually bootstrap
hibernate validator and run the checks
on it and this is a dead simple j unit
test class with nothing special about it
there's a before method which is going
to execute once per test method
then there's the test methods and it's
going to go and run so this is our
entity you'll see that the entity has a
series of being validation annotations
on it on top name name cannot be null
the duration and not being all sessions
have to be valid so we'll just run the
test and we'll see how quickly that goes
right pretty cool unit tests also
typically classified as being ultra fast
this in our estimation is a great
example of a unit test and again you can
come down on me for saying it's really
an integration test but like for the
purposes of this discussion it's
definitely much more unit than some of
the stuff that we're going to see in a
little bit unit tests it should be fast
they should have like minimal
dependencies and this in our estimation
is a great example of the unit tests
because it fulfills the contract and it
doesn't involve too many other players
and it keeps things fairly componentized
and isolated the reason we don't like
mocks is because when you test using a
mock you change the environment there's
a scientific principle that says you
cannot observe without affecting the
environment and with a mock man you're
really affecting it because you're
injecting like test only logic in there
just to stub out some sort of a method
like if you want to do mocking on a JMS
topic or connection Q or something like
you've actually got to like get a whole
mock object to get that stuff because
they're not directly you can't
instantiate them by spec their
interfaces and there's abstract classes
you've gotta fill them out in some sort
of a fake thing you're relying heavily
upon your mock implementation so in that
case we say yeah you absolutely need to
be integrating in with a container same
thing here with our data model right so
now we've you know we've checked here
that our validations are you know that
they're in place and that some junior
programmer can't come in and
accidentally remove that not null check
or whatever it's not going to like mess
up our world and we'll get real quick
feedback but let's go dig a little
deeper we're going to deal with some
actual data that works on this entity
and in this case data is really only
kind of it's only helpful to interact
with data if we've got like a data set
of like known data that we want to
validate against for our test method in
other words we're probably going to want
to like pre populate the database with
something useful that's known or return
it to a known state we might want to
keep the changes afterwards or we might
not want to but in any case we don't
want to do a whole bunch of setup so
anyone not yet familiar with our Killian
okay half half of us here I'm going to
give you the like the real Cliff Notes
version our Killian is a test platform
it enables you to write your integration
tests as you may write your unit tests
it is a component model for testing much
like Java EE is a component model for
your business logic and it uses a lot of
the same standards you can inject things
into your test most importantly what
this is going to do is it's going to
delegate this runtime out it's going to
get this deployment by the deployment
annotation that becomes your deployment
not a real bar not a real jar not a real
ear it's the result of this deployment
method it's going to deploy that into
the server a real server and it's going
to then start to execute the tests
against that server inside of the server
white box and then return us the results
okay so for all intents and purposes our
Killian is going to be the thing that
enables us to integrate with everything
else without writing any code that's its
job additionally we have an art ilion
extension called the arquillian
persistence extension and what this does
is it enables us to put these
annotations on top of the test methods
let's say using data set and they're
going to take a gamble file the animals
simplified data format that allows you
to put a whole bunch of data in place
what this is going to do is interact
with the database throw that stuff in
there before the testing and then when
you go do your tests you can actually
validate against the data you would put
in there and like run assertions to make
sure that things are hooked up correctly
we've got different options for what to
do with the
data afterwards we can either leave it
in place or we can say you know we're
gonna do we're going to use transaction
rollbacks and we'll say okay start a
transaction run the test and then let
the container automatically set rollback
only on the transaction so the
transaction rolls back without an error
but rolls back and then any of the
changes you make in the test and during
the pre population here are like thrown
away they never make it into the
database because of the isolation of the
environment and and like nothing is
affected outside of the test environment
here so we can run this test as well as
anyone yet not seen jboss application
server seven well kind of seen it all
right a s7 is fast it's like seriously
fast and when I think of where we were
just a couple years ago and we were
doing these demos it's amazing because
we can deploy this we can run this any
time I guess and as we said earlier we
wanted to be able to run tests strictly
from the build tool or from the IDE or
whatever with no other extensions or
anything so we just want to go run as J
unit tests and have it all work you got
some ports open already yeah doesn't
excuse the fact that like when we have
running servers you can't like boot up
to and have them share report
unfortunately I haven't figured out how
to hack around that yet to applications
shearing apart but when you run the
thing you'll see that you know will will
connect in fire up to the container
we're going to take this test class
throw it into the container run its
tests do the data population and report
everything back to us so this is going
to go into enable you to yes do your
testing but do it with some real data
and get a sense of how this may act when
you've got like your database in an
expected state and it relieves you of
the it relieves you of the task of
having to like maybe execute a script
beforehand or after hand makes your
whole thing simply we're all on board
with this it's not conceptually
difficult I can move on who
well off oh yeah and right as we say
it's integrated in with the IDE we
didn't do anything special here run as J
unit and that's it and everything else
is abstracted for you right so this is
going to be a chapter in the book
dealing with data and you know we'll go
further in depth will start in on our
next example which to me is like one of
the most amazing things there's so much
going on in this tiny bit of code that
it's unbelievable and it's a real
testament ox ox work and to Carrell's
and like the whole arquillian community
a whole bunch of other guys over in the
QA department or the quality engineering
huy department at jboss these QE guys
are amazing by the way like they they
work on our supported products and
they're heavy users of our stuff and
recently they've become very involved in
the developer community of the upstream
as well so like a lot of these testing
projects are are fueled by them and
their requirements which is exactly how
it should work like we're not relying
upon our Kiwi department to like just
write tests for us and run them and
manage the Jenkins environment like
they're they're defining what testing
should be so they're true engineer
that's awesome anyway this example here
it's going to use the view layer thing
Ashlock might be better off better
equipped to start rapping about this one
right so it goes a bit of um up on the
idea of continuous development involved
because when when you think about an
integration testing you kind of have to
have or when you're doing the Big Bang
type of integration testing you have
your full application done and then then
you start doing to do the integration
testing and with continuous development
you go the idea is to continuously also
do the integration testing and to be
able to do that you will need to be able
to expect out subsets of your
application as as you're developing it
and with it with the help of shrink wrap
and a couple of the new features in
inner Killian and within the Java EE
specs itself you can start to isolate
the different levels so in this case we
have in the original jsf component it is
expecting there to be a entity that is
coming up from the database but the
genius app component itself it's not the
or does not touch that that entity it
says it's just looking for for something
to provide the current complex object
and somewhere else someone defines how
to produce that current conference
object so that allows us within the
tesco to create our own fate producer of
this so we're skipping the point the the
actual producer who will fetch the
entity from the database and we're
placing it in our test appointment with
a producer who can take an argument that
we have had given it so we start to run
through what this test is gonna do where
the purpose is the deployment where
we're packaging down our conference
beans and n djs that component itself
but we're also adding then the testing
test conference producer we're using
selenium here to to poke as the remote
HTML input output and since arquillian
is the one controlling the deployment
and controlling the server it also knows
where this thing is deployed like
darkening can inject back the URL to the
web content that allows you to not have
to care about if this is running in a
test server on a staging server and if
we have left it at this we would have
been doing what any was talking about
saying the black box testing we're just
poking it at the remote apic but there
is a a extension to our Kilian is called
warp and what that does is it lets you
during a normal HTTP request you can
piggyback server objects as well that
will be executed within the life cycle
of the HTTP request so this is the work
bit so when we're doing a a driver get
on the client side work will then take
you back this set up conference object
that we feed with our specific entity
that we say we want we want to to have
this view render and then when then hit
what when that hits the server before
the servlet or before our jsf request
starts where then takeley producing that
entity that someone else rich me to
produce and so when the the actual JSF
page is it executed in the server the
the the object coming from the from the
client side is available to the JSF and
it would just render it as if it came
from the full integration so now we're
separating just the view layer out to
tested so we're creating a hair on the
client side the the conference object
we're setting the values executing it
and verifying the output one more step
of this test is that when you use normal
using selenium you are stuck with doing
all the idea the idea or fetch element
by ID or by CSS and all those rules and
they kind of become very ill
maintainable after a while so you have
the JSF components on the server side
but on the client side when you're
testing it it's not any nice API you
have a bunch of strange rules so a sub
our another sub project of our Killian
is the ddr killing graphing which is a
wrapper around webdriver and it if
you're familiar with
they're sending in page objects this
takes it to the component level so this
is fragments within a page can then be
handled in the same fashion as a as a
web sort of page object we're saying it
somewhere in this page that we're
calling there will be a element will be
an element with ID conference and we're
going to inject and populate for you the
object object so we have a nice view to
a nice API on the s side to to interact
with these become reusable test
components so if you have the same
component spread across multiple
multiple test cases this will typically
and contain things like get list or next
to previous depending on what kind of
component disappear and you then just
have to change that those specific
statements in the components instead of
having to go and and update that across
all the tests if the HTML or hit the
backing HTML with work change alright so
we're creating the conference object on
the client side we are executing the URL
to push it the objects being created on
the server side and when it comes back
we're interacting with the page object
that API for these for the output if we
just run this now as is again it's just
this info run as a unit test
the it doesn't look necessarily but very
can see but if we start to do some break
points here to see what's going on that
should be on the client side and this
point on this side one day deeper so now
we're about to call the URL and warp in
the background and now add it up the set
up conference server object to to the
URL so that will be piggy piggy back on
that request we're coming in from the
dome I can see that all coming in from
the jba dundee the remote run runner in
eclipse in the next breakpoint we are
actually inside the the the server of
the HTTP he requests on the observer and
at that point you could have we in here
you can do things before and after
servlet you can do it within the
different life cycles of jsf so before
render have to render and all different
steps and you can do similar like you
can do in a test case you can hair
inject your each bees or you can inject
yours CDI beans and operate as if you
are part of this the same component
model as your your for yourself that's a
pretty neat little trick so here we're
really getting into the gray box testing
that we were talking about or where I
mean what there's an amazing amount of
things going on here it's it's
initiating a client request if sending
it off to the server it's intercepting
at the servlet level inside the server
and telling the view layer and use this
data model
instead the data model that the client
provided and then when the server
renders it back out the client then
grabs the full response analyzes it and
sees that the view layer stuff is in
expected form I'm sorry here oh thanks
we're intercepting where we've done it
the view layer and now there are even
tools to parse it out so you don't have
to parse out the ridiculous HTML you've
got it in like an object model format
that looks and feels much friendlier so
this is like my favorite example I think
I've ever seen ever in in a demo because
there's just the level of control we
have like we're kind of mocking the data
model but we're not mocking it in a fake
way you know what I mean and.and you do
kind of get some separation here you
don't need to go all the way to the
database you can like very quickly just
see what the page will look like if you
gave it different types of data you know
like what if you've got a user that's
got a ridiculous name from some country
that has ridiculously long names or
something doesn't wrap too long or
doesn't whatever and you know because
you're plugged into selenium you don't
like to pull out but there you could
take screenshots and do whatever you
want so this is a cool example to me I
think probably we should move on do that
yeah uh the words it's on everyone's
mind lately or at least we're now sick
of um is cloud yeah I was sick of cloud
before cloud before it was cool yeah but
then I started using it and it's awesome
and I don't know there should be like by
mon cloud car just bi-monthly cloud
conventions all the time because it's
just it's that cool um here's what I do
with cloud I'm a
belapur I consider myself fairly
technically capable and I used to have
this like server i paid like a few
hundred dollars for and it's a nice
machine that runs kind of fast and i was
running my own build servers on it
because i wanted access to my own
jenkins i was using it like for my own
applications and it was just a good
testing grounds for stuff and like i
just kind of like happen to notice over
the like the course of a year and a half
that like I had just like slowly started
to migrate my own applications off this
thing until I realized I was just like
running a big fan in my apartment that
wasn't doing anything anymore because
I've moved everything off because it was
easier I didn't have to like SSH in and
deploy my app so everything was just
like i git commit and it was all done I
wasn't setting anything up anymore so
from Red Hat we have this open shift has
anyone heard of open shift yet the open
shift is real cool and I'm saying this
not because I work for Jay Boston Red
Hat and not because I've got like any
special pull with that community I mean
I signed up just like anybody else and
they gave me free instances to use just
like anybody else and it's it's just
it's given me a tremendous benefit in my
projects we actually run the jenkins
servers over on cloudbees Bobby's great
too they've got like this they give you
like a master instance and you put all
your jobs in there and then when I do a
git push it'll like send it off to one
of the slaves and so I get that nice
continuous integration like through them
and they provide that to me as well and
that's awesome Bobby's prequel to but so
now we've got like our applications on
the cloud the demo app that we saw
earlier that we linked you to by the way
I saw some of the comments and they're
not all friendly but you get the
refreshness we have I can't read the
screen how am I supposed to see that
well I walked right up that's how I read
it but we'll take your feedback again
all the content is like on the blog a
love
the Hat hate the Hat all right that's
that's good okay um and there's more
entries to actually the more on the next
page in it door handle to be open shift
is one letter away from the nasty type
of all right um so we've got this app
it's running up there that that app was
kind of like generated by Forge it's
actually like a continuation of the
application that we had in our talk on
Monday and it'd be cool to interact with
this again we say with testing you want
to be testing in an environment that's
as close as possible to your production
server so like you know if you're
running a s 7 11 on your production then
you should probably be testing with a s
7 11 locally but there are going to be
environment differences there's like
hardware that's different whatever let's
say your production server is on
openshift or it is on the cloud then
it's really cheap to like make an exact
clone of that same environment and use
it as a staging server or because
they're so cheap use it as your own
personal staging server you know if
you've got some sort of a problem may be
there have been times that I've been
developing and there's stuff that i can
only duplicate in production or on my
staging server and digging in there to
figure out what's going on is not always
easy so we're going to show you how
three things that you can do to interact
with that will actually show you one and
we'll talk about the other two because
the other two just kind of their open
ship the network dependent and they're
going to burn too much time and we get a
move on other things so the first one is
what I call a cheap trick and that's not
a burn cheap tricks are great they're
cheap meaning that they're easy and
they're quick and their tricks because
like they're really effective and they
look pretty impressive and they do a lot
of good without a lot of effort so even
if you do know openshift maybe you
didn't know that there are a couple
things we can do to make working with it
easy here this is jboss developer studio
and it comes with an open shift
again and once you've hooked up to your
openshift instance you can right click
on it and there's an option called open
shift oh well it depends on which server
if you're on the server's pad it says
open shifts here you can do a straight
to we could activate port forwarding on
our machine pretty easily what port
forwarding is going to do is it just
going to say like all right anytime we
access the local ports on our local
machine just like send that off to our
open shift instance and make it look and
make it look like we're hitting
localhost but really the port forward is
going to take over and we're going to
hit open ship so that's easy we don't
have to like plug in our remote URL to
like make a connection or anything we'll
just say open ship right another thing
we can do here so the microfiber let's
show the market file open ship works
with a series of marker files and so the
way this whole thing works is you have
your repository and in the repository is
a directory called dot openshift and if
you look inside there there's a file
called open ship two markers now by
default this java 7 marker will come in
there and that'll say hey Ron is seven
with Java 7 it's not in there it'll go
with java 6 there's a readme which will
tell you about the different market
files that are supported one of them is
one that's not in there by default is
called enabled J PDA does anyone know
what this is do it like this is a yeah
it's like it since this is a standard
Java Runtime switch in the Oracle Java
Runtime where you can open a port on
you'll let the JVM open up a port and
that port is used for remote debugging
so you can attach a debugger right like
through there I think we're also used to
like doing debugging through our IDEs
and whatever we don't kind of gotten out
of a habit of manually saying when the
JVM starts up to like open up a debug
port but you can and by enabling this
option it just kind of instructs
openshift to say alright when you start
up the app enable enable
and open up a debugging for and because
we've got port forward and we're going
to be able to get at it through
localhost 8787 so at this point all
we've got to do in our IDE is go to the
option that says remote java application
and give it the host which is going to
be localhost because we have our port
forwarding on and give it the port 8787
which is where it's listening and if
debug so at this point now we've got
like the app out there it's running on
openshift it's on the cloud and we've
attached a debugger to it so we can
actually hit that instance and put in
put into it and hit debuggers and it'll
wait out on the cloud for us just like
it were if it were local but there's
another side effect that we can do here
which is a notion of hot swapping anyone
familiar with hot topic yeah hot bhabhi
not something we may be traditionally do
in like a standard debugging environment
or maybe you do and sometimes will
notice like things disconnect and they
don't hot swapping has its limitations
well first it's feature the feature is
that when you're connected in through a
debugging environment you can replace
code and you can change business logic
it has a lot of restrictions the
researchers are you cannot change the
structure of any of the class files at
all you can't change you can't like add
or subtract method you can't add new
classes and expect them to go in they
can't change class hierarchies that kind
of stuff but if your structure is
already in place then yeah all of your
local method variables and any type of
your business logic in there you can
change that as the thing is actually
running so while we're connected here
maybe let's do that we have okay waiting
oh it's waiting again it's a remote
connection so like take a couple seconds
and we're connected in oh and you'll see
you're connected because you get the
stack trace you're going to get the the
not the stack trace you get the running
threads your thread view and if you were
to put a breakpoint in any of those
threads then you would get you would get
the stack the frame the call stack right
we've all seen this before so we've got
our our page which is our feedback
entities remotely
up there which we've seen why don't we
show that will show the page again
remind people what they wrote this is
not all complimentary actually so maybe
what we'll do is go back into the IDE
and see what it looks like if this is a
little bit more positive so you know
well you can just go directly into our
entity and we'll find the place where
the entity replies out what the feedback
is and we're just going to say that
everyone agrees that this is so cool and
the second we hit save it will hot swap
into the remote instance you have a null
check in there that's the side effects
walk dinner I well we definitely broke
it so that's you know something change
well I may have actually forgotten the
business object that it was involved in
return this fever equals all knew it
should have changed something right
before the presentation stuff um but you
get the point yeah I mean we clearly
swapped something in it if I like we're
to like delete that and it puts it back
in place there it is
well we're changing stuff I forget
exactly what the logic is I put in here
to make this whole example work but it
is pretty cool I think we can all agree
on that what's up oh that was the first
problem that's why I look good why we
would happen no yeah it but yeah if you
just do that then like it breaks the
whole life like breaks a whole new layer
for some reason for some reason oh boy
yet and I'm listen I honestly don't know
what's wrong with but that's fine this
is fire terrible this is the Mars this
is the Mars rover crashing and wasting
millions and millions of dollars is
someone changed something right before
they tries to squeeze in one lap feature
because it'd be real cool right so this
is one way of interacting with a cloud
and I promise you it works and I've put
an error in my business logic here and
you can blame me for that but i think we
very clearly Illustrated that yes you
can attach a remote debugger you can get
your break points you can swap in your
code changes and you'll see them
reflected on the remote instance
including the bugs that you introduced
you will then put on the remote instance
so we can all agree that that's pretty
cool and like pandering to the audience
is always like one of my favorite things
today but the two other ways to interact
with the cloud that we've got for you
one of them is to do as we said before
this continuous integration environment
and I think we've prompted them we got
five minutes one of them is to have this
continuous integration environment so
openshift also has a Jenkins available
cartridge and what you can do is you can
log in I'm sorry you make the cartridge
and then push any changes to your app
they'll be tested by Jenkins and then
you just you set up a set of call
triggers and say like all right if the
build succeeds now automatically push
this to staging or if the build succeeds
automatically push it to production so
now you've like fully automated your
chain here so that you like
you can really get that incremental
development all the way to production
just by like putting in a gift push
having a feature branch check out if
that thing passes going to staging and
just like all the way along the change
all the way along the chain get these
continual improvements without the big
bang release cycle or without having to
like manually intervene and again that's
all enabled by having confidence enough
in your test suite that says alright if
the test suite passes this thing is good
to go no I want to look at it I want to
click through it I want to see it with
my own eyes about confidence you invest
week you can go to production and that's
enabled by really putting testing at the
core of your development philosophy
that's the second thing you can do with
that third thing you can do is use our
killian just as we did to deploy to a
local jboss AF server here use our
killian to deploy to an open shift
server and now you've got the ability to
have your local tests and a local
packaging unit deploy the packaging unit
remotely on openshift and then run the
tests there in that environment shut it
down a report back to you locally so
instead of using a local jboss AS
environment use the J box is environment
up there but you know get the results
back and that's the third thing that you
can do and that's the are Killian
openshift container and there's links to
that in the blog accompanying this talk
as well we've got a couple other
examples that were also in in the
abstract and we've done what I feared we
would which was kind of get into this I
want to leave some time for you to ask
questions or interact or tell us where
we think we fell short on the examples
or early anything so you can just kind
of shout it out Yeah right I'm sorry
yeah what's your backing server yeah
is it's a s7 it's glassfish I mean and
how quickly is glass efficient deploying
your stuff and starting up and stuff
okay that means it our Killians not
going to make glassfish faster no as it
is a the suite level will start and stop
the container the test class level will
issue a deployment and each test method
will operate on the same deployment so
if you have 300 tests in one test class
then yeah it's all going to be one
deployment test ssssss undo boy yes
right not for each test method and again
if you use like slimmer faster servers
and that helps you out to go ahead to
make a deployment beyond a sweet it's
our number one request for the arc alien
project and we yeah we've got it slated
we can't do it without some major API
changes so it's it's will absolutely be
in two point oh and hawks we've been we
talked about this kind of all the time
and it just it's about our planning for
120 is going to come and when he wants
to like you know break the 10 API
essentially yeah yeah I understand yeah
we wanted we wanted to couple the events
handling that happens from the like test
lifecycle and give you greater control
over what happens when yes I mean I got
I got your next sure what's
yeah what's the external provider yeah
yeah I mean so like mops is kind of an
overloaded term something that I've seen
is like look if for instance in Java EE
a lot of this stuff is coming through a
data source right so maybe they've got
like maybe some Oracle database you
don't have access to because of the
licensing fees or whatever and that's
what they run in production but you want
to test against it your contract isn't
necessarily with an Oracle database it's
probably like with a data source or some
abstraction layer so I would try and
find that abstraction layer and then
fill it is something else so in other
words like mock that data store but find
and find a good place to have that
abstraction oh it's an API you got to
mock the back end you gotta mop you put
them off the backend API you got to have
some sort of a service yeah i mean if
you've got an api contract to fill and
that's where your view ends then yeah
you absolutely it unless you've got
access to the back and container we we
can't give it to you like we can we can
help you get over that gap quicker but
if there's nothing there to get to I
don't think what you're asking for is
conceptually possible to help with
mocking makito framework for you know
object mocking will stay here and do
questions we've also got these cards
with some links and stuff anyone needs
to head out you can grab one but we'll
still take questions I mean whatever you
want oh thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>