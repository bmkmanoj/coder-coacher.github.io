<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>OpenJDK Penrose Project BOF | Coder Coacher - Coaching Coders</title><meta content="OpenJDK Penrose Project BOF - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>OpenJDK Penrose Project BOF</b></h2><h5 class="post__date">2013-01-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Vl6H2HTufIU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">and welcome to the Penrose both now
they've give us a huge room so folks
look like this had a crowd in a little
bit over this place so we're not talking
to ya the full side of an empty room so
it's come silly or on this side little
bit please not all that enables to
direct the conversation at to you so my
name's Tim Ellison I work at IBM and we
enjoy today by David Pasha whose works
at red hat and is the intention today is
to give you some oversight of the work
that's happening in the Penrose project
a little bit of background some of the
the roadmap for the work that we intend
to do in penrose and a little demo of
the code that we've got working so far
so I figured it would be good to start
with a little level setting I'm talking
about modularity in general now some of
you may be attending this already
understanding things to do with virtue
saw and osgi and those sorts of
modularity technologies so I'll cover
that you know pretty quickly they will
go on and talk about Penrose in
particular so what do I mean by module
and a module system so yeah hopefully
not a contentious statements but modules
are an important concept in software
engineering and we use the modules
themselves to be able to decompose the
large complex systems that we're trying
to develop down into coherence well
understood areas of functionality and
once we have these areas of
functionality we can compose modules
back together again into software
assemblies not necessarily the same ones
that we compose of course and if you a
few building reusable modules you
them into new types of system but as
well as decomposing problems the modules
themselves are also a mechanism by which
you can distribute your code out to your
end users and they have some capability
and functionality over and above the
sort of built-in functionality the
modules themselves can be used for
birthing and configuration management of
your application that's the module the
module system I took module system
that's the framework that that is used
to manage all of those modules in your
system so the module system itself will
be responsible for deploying modules out
onto people's systems and any lifecycle
its associated with the module
installing it bringing it up tipping it
down releasing its on that's
responsibility of the module system
itself and by interacting with the
module system you get to have this high
level of abstraction of how your
application is working and deploying
then you get from just program directly
in life in that the java language
so there's kind of a little bit deeper
into modules the module is this unit of
encapsulation that's I referred to
earlier and if you look at the Java
language today he already has two
different types of modularity inability
commerce we've got classes and we've got
packages now as the classes allow you to
specify fields and methods and there are
language constructs its and they will
need to specify the scope of visibility
for fields and methods as defined by
classes and similarly for packages as
well okay so classes appear in packages
resources are associated with packages
and that's all very well I'm good so
there's a certain level of modularity
that we already get in the Java language
today the issue is that neither classes
or packages are the correct unit for
deploying your application and that's
because classes are generally too small
a unit of functionality to be useful to
distribute independently of other
classes or the very tightly coupled in
terms of implementation dependency with
with other classes and it similarly
packages now you would typically have a
collection of packages together a good
together to make up an interesting area
of functionality so of course the way
people distribute these areas of
functionality today is through jar file
so what classes were packaged jar file
to industry those as parts of
functionality of applications the
problem is that the jar file itself
doesn't have the characteristics of that
use very capsulation writer in the
runtime the jar file itself is not
something which is tangible to the
application
so the modularity in Java is addressing
bringing these two things together and
it's the use of encapsulation and the
deployable unit in a module so when
we're designing modules these are sorts
of characteristics are looking for the
module itself should be highly coherent
meaning that the functionality in there
should be self standing and well
described a very loosely coupled with
other modules because the intention is
that if you do design your modules in a
loosely coupled fashion than you you're
you're not dragging down lots of modules
to achieve a particular area of
functionality right each one kind of
stands alone by itself it should be very
explicit about what it's providing to
other modules I want it depends on for
the modules so how those well-defined
api's between modules allows you not
only to have these local assemblies in
these components and but also allows you
to to replace individual implementations
with a strong degree of
understanding what is required to fully
replace that module so there's less an
ambiguity that you're going to break
something and if you're you have a
well-defined in space in and out of
modules that's all well and good that
allows us to yeah we've got concept of
modules we've got the concepts of the
module system and we print a system down
into these deployable modules but why is
that interesting if we're going to try
modularize the GRE itself well it's
interesting because at the moment the
the GRE is this large blob that sits on
your disk and which doesn't have a lot
of information about your application
and what features of functional areas of
the JRE will be used by your application
and so in general the jury assumes you
know when it's delivered to you if
sumption is that you could use any part
of the wide gamut of SC functionality
now when your application is lonely
that's all sitting through class loaders
but the download time for the whole GRE
and the time it takes to start up the
JRE is directly proportional to the
number of types but those classes have
to go around and collect for all the
structures are delivered BRE and when
you look at how a GRE is delivered an
example here is in a 1.7 windows build
you're looking at about 20,000 classes
in the base GRE itself and
decide have depicted here the typical
class path that you get on Windows RT
jar you'll recognize as being the one
that contains the vast majority of the
api's and the implementation types for
java well when you break apart RTR cause
you should zip format index itself is
one megabyte right so there's a lot of
work required just to search for and
find a particular time again on the
assumption that your application could
be using any of those types and in the
sort of a simple case that index in a
linear search through a very large
number of entries to find the particular
classic you're referencing from your
application now yeah there once it
extended this blue cross paths with all
your application jars as well it becomes
a very large search base for your
application but for the system to look
through to find types of good you're
referencing now of course people do play
tricks and implementation to ensure that
we try and minimize those things with
the general problem exists that class
loading as to bring in the device from
disk and then start setting those
classes constitutes a very large part of
the overall start of time for your
the other main area courses this
dependency management so here's an
example is sure I'm hooking people were
kind of recognized as often described as
jar health and what you try to walk John
hell arises when you end up with
potential conflicts in dependences so
assume that i have an application and
it's dependent upon two different jar
files and thought at foo version to jar
and bar version to jar but my dependency
the food version to jar itself which
could be a third party library one of it
depends on bar and two different version
5 version 1 now when i launched java
today and i specify the classpath you
know i'm going to specify a class at foo
vision to and bar version see but where
do i put barbers in one if i put it
after my dependencies then obviously i
win this application in terms of you i
get type slowly from version to the bar
however if i switch that around and put
food version tues dependencies first
then when I come to load those types
I'll be thinking of the version 1 and so
there isn't really a correct way I can
order those two that's going to satisfy
my requirements unlike dependencies
requirements
I also mentioned about this sort of
current units of encapsulation that we
have in terms of public/private
protected and default visibility well if
the area of functionality is defined by
these modules right this is collections
of types and packages what I would
really like to have is a level of
visibility which is just we're in the
module and you know there are many
places that you'll see packages these
types have been declared public because
they have to be reached from other
packages but that's only an
implementation type that requires that
level of access and convention dictates
that you don't referencing very calm
some packages even if they're declared
as public because they're there for part
of the implementation of that functional
unit and however the language and have
any mechanism which allows you to
enforce that and so you end up with
applications we do hardcode you some of
these internal dependencies and cause
that restricts the like the library's
evolution oriented with these sort of de
facto standard API is people use them
quite expect accessible
um
you can go ahead and ask question arrows
finest
the trail
yes so the question was oh I guess the
the observation was there are all the
cool things there in those internal
implementation types and is it not a
problem to do so as well and yes yeah I
think as I say that there are some
things which there are there and have
become de facto API to the problem is as
an implementer you don't know who has
that level of dependency on you and the
only safe way really to do through
specified interfaces and so good i guess
examples are i think of the encoding
decoding one that's recently coming for
Phase 64 I'll see ya base64 is an
example right of 1 which everybody kind
of has reached into in the past two to
use that functionality because it was a
veil in the AP is that is now being
brought into supported api's and I must
not sort to do it registered to lobby
for those things to eat expose that
really counts and of course the other
advantage of having modules at the ER
even itself is that you have the ability
to diversion control and modules and you
can have different implementations of
modules running simultaneously that's
like kind of sharing you want me to be
to example earlier but also different
implementations that target different
characteristics such as you know the
mobile versus the big mainframe system
and so on
so you say the ability to have different
persons that that that almost suggests
the ability to convert
in the same running to the end so kind
of that my life do not is what i meant
to you well excellent that so hope hold
that thought right this is a desirable
characteristic so that was not talking
about criminals and modularity in
general and all it is he okay it's down
into into some of these projects are
addressing this kind of space so project
jigsaw okay I'm going to assume that
people are generally familiar with
jigsaw OpenJDK his goal is to define the
the simple module system for java and it
started up like targeting the JRE itself
although i think you know it's been it's
been accepted that a simple module
system for java application developers
would also be useful because you're
using the same mechanism right not not
just the jury but ramifications in
general is a good thing so jsr and will
be proposed and to make this a standard
characteristic and but of course you
know jigsaw has a difficult task because
we have lots of api out there already
which can't easily be changed and so
you're trying to structure these large
area of class libraries into different
functional areas after the fact and
that's always of course a lot more
difficult because not only does the
implementation reach out and you do have
a fighting chance of raining in the
implementation but saw the api is also
have very strange dependencies across
and different functional boundaries
jigsaw is changing the Java language so
you'll be able to have this sort of this
module info Java which is the way that
you specify a module and its
dependencies that is a simple example a
kind of running short on time so in a
skip past the details of the example but
that's how metadata looks in jigsaw to
describe a module and is penalty okay
osgi is an existing module system which
has been around for many years and it
has a very rich modularity story that
has dependencies down to individual
package level as well as module level
dependencies and it has beyond that lots
of standards around offering services as
a higher level than the application and
it is heavily used at the moment now
osgi doesn't change the Java language
itself it puts its module information
into the manifest and this in the metal
part of the jar file and similar kind of
concepts but the syntax is different and
in particular you've got the import
package and export package
osgi way so one of the main goals of the
module system is to resolve the
dependencies between the various modules
are going to make up your system and
ideally you want to avoid that class
five hell of specifying which gr file
comes first on the cross paths by being
able to build the information directly
into the jar file that says when I start
to load of classes from this jar take a
look at the metadata to see what its
dependencies are and then you only
search down that jazz dependencies to
find the types which will resolve for
that particular area of functionality
and the problem is i guess it's rehab
time of electrons it to demonstrate you
use it you end up solving class part
hell and good find yourself in module
health certain free and because osgi has
one way of resolving dependencies it
does this at a very early stage during
the run time so the modules themselves
have got a life cycle and that life
cycle is executed at run time you start
your application through an osgi
framework it looks at the modules and it
starts to do that resolution of the
metadata and get a coherent set of
classes for your application to run and
it may determine early on in the life
cycle that it cannot build a coherent
set of classes decision
have jigsaw is going to be slightly
different in that it has module level
dependency resolution during
installation phase one all right so
that's also background iveco introduced
modularity and chickasaw an osgi have
not only took about petrol so let me do
that so the observation really is that
yeah both osgi and Penrose are here to
stay and while it may be portrayed as a
war between module systems that's really
not true what we're here to do is to
ensure that modularity whether it's
jigsaw or osgi or both work well
together okay osgi is well established
or law systems running osgi it's a very
rich module system as mentioned before
goes all the way up through services and
so on jigsaw is a key part of the java
platform modularity story that's going
to be around so project hen roses goal
is to fulfill one of the requirements
that the jigsaw of a specified which is
interoperability with the existing
module system
and to do that we've kind of had had to
pick an interesting way of structuring
the projects if you show up at openjdk
you take all of the project Penrose
you'll see we've almost kind of got two
projects running side by side down and I
explained that structure a little bit
because we need to work with osgi
developers and jigsaw developers and
we've ended up with some people who are
contributing to the equinox project for
example which is representation to osgi
who don't want to be studying jigsaw
code and ending up contributing some
changes that they've recognized in
jigsaw into effort ox because the whole
governance model around echinops is
different to the whole governance model
and around the jigsaw and likewise in
the other direction so we don't want any
opportunities for misunderstanding or
people's career knee up in the wrong
place we have a main code repository
which is cloned from jigsaw and that's
where we can make modifications to
jigsaw try out new ideas and contribute
our code back up through jigsaw into the
main SE purpose and then we have a
second code repository which is there
just for hetero specific tools and demos
and so on and then we have two different
mailing lists we have the penrose
developer mailing list which is for
discussions around how we would like to
change jigsaw and all the implication of
jigsaw means for osgi and vice versa you
know and then we have a Penrose discuss
mailing list which is where we don't
discuss the implementation details of
jigsaw and that's all we welcome the
osgi guys for contributing to other
projects to come and have a design level
discussions and so by doing that we can
enable the full communication channel
backwards and forwards
by ensuring that people maintain a foot
in the correct campus of speaking now
this is taking place in penrose discuss
at the moment what we dearly want to see
of course if the jsr created as soon as
we can so that there is specification
level discussion of the design
discussions and take place in an expert
groups in the JTP in the way that
charming only evolved so here's our
technical roadmap for Penrose this is
the goals that we set for ourselves and
the project was established and the
first one is just toleration rights just
ensuring that nothing that happens in
jigsaw will end up breaking the
framework that already exists in HD I so
a modularized JRE should still provide
all the functionality to osgi ajay needs
to run this module system if it's a kind
of separate isolated module system
shopping centers and it only works first
wait right if there's anything it
certainly gets hidden by my jigsaw
modularity or show dependent upon movie
to go back and make changes to keep osgi
the second goal is getting
interoperability for here you know I I
showed earlier how the module metadata
information for jigsaw is stored in a
different place and looks different to
the module metadata information which is
still at osgi and that's kind of strange
but all the tooling and things around
modularity it makes sense if those are
are represented in a similar way right
so we can just right set of tools and
have operations which acts on modules
whether it's for osgi or is the juice
Nassau spot of the the goal of the
jigsaw I talk ability was there moving
on from that right once we've got that
level of interoperability at the
metadata level what we want to do is for
osgi to be able to exploit some of the
jigsaw functionality so given that
jigsaw has yeah the ability to define
functional areas for the JRE it sure
would be nice if those functional areas
were split up in a way which enables the
osgi capabilities to use just the levels
of functionality that it needed so we
weren't dragging in on necessarily
different areas and different modules
and and then three pluses have surface
scale of a top ability would be a full
level of interoperate so you can take
individual modules and it can just be
dropped into as GI orozco modulus
dropped into jigsaw and they just won
the second thing so that's a quick
overview of where Penrose is goals are
and the roadmap I'm going to hand over
to David to talk about what we actually
managed to achieve right yeah I'm going
to try and go through the technical
things that have been done in penrose up
until now and so on the Toleration level
of things is basically the first goal on
that Tim slide and there's two things
that were shown to work the first one
was basically running the oci TCK tests
on a jigsaw enabled runtime and that
pretty much worked and the second one
was and create a modular demo that
Cameron both with oh she I as well as
well as with jigsaw and I can show
later on so those two things are about
toleration there's no no integration yet
on this level but at least you know
we've got to that point and before we go
before I'm going to look at level one I
just want to talk a little bit about it
at the module information in jigsaw
itself and you know we're going to
compare that to happen to how that's
done in penrose which is a little bit
different so in jigsaw the modular
information is in a module in photo job
I file a team show that earlier on which
gets compiled into a module in photo to
class file which is yeah in the ultimate
jar file you get a binary major data in
this file so so there are a number of
issues with that and first of all it's
currently not possible to extend it so
the where did the Java language
describes how does java file Luke's
there are other module systems and
indeed sometimes tools that might want
to put extra metadata in in this file
and and currently that's not possible
and it's going to be you know whether or
not they were planning to do it or not
it's not going to be easy and secondly a
binary file is not very easy to read you
need a tool to be able to make any sense
out of it if you are another module
system like osgi want to read it you
probably end up writing a class file
reader which is not really you know the
best idea in the world I would think and
also it will make things and make things
harder to troubleshoot and because let's
say you're running in a production
system something doesn't work and if you
are not able to you know currently with
with osgi you can open up these jar
files and you know just use a simple
text reader a zip file reader and a text
reader to see what a modulator that is
if you need a special tool to be able to
interpret that that's all might not even
be
available on your production system so
and the goal here is to create a
readable and easily parsed meta data
format that is extensible and this is
exactly what we did in penrose we are
proposing a modular photo/jason instead
of modeling photo job Anna and personal
description on mailing list initially
we're leaning towards xml and but xml is
not so sexy anymore so people prefer
Jason and so that's what we did and we
implemented module info using a Jason
meta data and it gives great
extensibility it's a text file format so
it's easy to read for humans and it's
also easy to read for tools because
there's Jason parsers available you know
everywhere they're very easy to obtain
and the only the only thing is some
people are saying over the performance
of reading a text file isn't great well
I don't think that's a valid point
because you can easily catch your own
binary binary representation of these
files as soon as you install the module
in the system so you only read the text
files once and probably not even at
runtime you read them probably at
install time and if you want you can
catch your own representation so I think
that that point is covered as well so
let's have a quick look and at what it
looks like and you can see them
side-by-side here on your left hand side
you can see am willing photo to Java
file as you can find them a jigsaw and
on the right hand side you can see the
JSON file and obviously first thing
you'll see is that the JSON file is a
little bit more for both and you know
structure is it did you know amount of
text is definitely larger and what what
you get for that is extensibility and
the ability to parts of the web
standards at our firm and as I mentioned
the other difference is that in the jar
file injection you get these binary file
words in penrose the same JSON file is
used both a development time as well as
a trip line so the jar file contains a
plain text file as well
okay and the demos that are in penrose
show this they don't contain what you
need for the java they contain these
Jason files and as I said they also show
that they can work on both under oci and
Jenna policy however they don't they
still have that meta data duplicated
soda there's no oci there's no ocean
framework yet that can read the Jason
and make the data so that's something
that they need to work on and that
brings this brings me to this the to do
list and what we need to do is we need
to and this is basically on the road map
i think there's people are planning to
work on this in the relatively near
future and we need to extend an osgi
framework probably equinox so that it
can load Java Sea modules natively and
understand their meta data and we need
to define additions to that make the
data so that we can express additional
makes it out information use for our GI
and as you can see in this slide that
can easily be done with Jason no she
likes you version your packages and you
can just add on in Zoe and we need to
define all of the things that are extra
that ocio it needs and finally I think
the last thing if we want to try and
improve is that you can you can wire to
existing jazzy module so let's say
there's a module's install the java sea
and then you're running an out chef
framework on top of it that OSHA
framework might want to import a package
from a module that is running outside of
it I think that's what also a possible
okay the Jade there's a demo shortly but
I just want to hand it back to Tim for
the last slide okay
yeah so we'll look at some running code
in a moment I just want you two to leave
with a little message here but the first
one really is please stop using those
internal a few weeks it's going to make
life very difficult when we move to
module world and I think everybody is
committed that in in java SE we do need
to get to a modular runtime so you will
be broken so at some point so so so we
need help off those impaired plantation
classes and you know in general be very
modest about the api's that that you use
now this should become easier with the
compact profiles are being proposed for
se but but in general you know today
when you present it with the long list
of Java doc packages and types it's it's
often easy to go up and find if the
listener handler stuffers in the swing
package and decide to reuse up your
application which is have any form of
other than a UI dependency and yeah in a
in a module world you'll suffer because
we'll end up building a dependency on
the whole UI framework because of your
reference whereas if you can be a lot
more modest about your dependencies
something possible to have a much
smaller JRE download available if you
need a modularity story before java nine
then the only answer at the moment
really is an osgi and with penrose
intention is to ensure that oh it's GI
will continue to work beyond the
overnight and if you need the sorts of
behavior over and above the the simple
modularity
if you are looking to get up into
enterprise characteristics of services
and sort yes it may be may be easier to
start on earth GI story and continue to
scale up higher but I think there is
there is mileage in ensuring that we
have a module system all the way down to
the GRE and everyone's computer making
that work so that's why we really want
to see this jsr created to get the
module system well defined with input
from everybody please an expert in the
space and capable of contributing to it
and if you do share similar goals you
have kindred spirit please Shelby
openjdk we're very liberal in terms of
commit rice and that's sort of things
that used to play around in the code
base and fires for those ideas and David
going to show some of things that people
have done already yeah i'm just going to
show quick demo here and so first of all
this is very straightforward them what
is the java to GD mode it's part of a
standard Java Sea distribution this is
basically more generalized and it runs
both under ticks all modules as well as
on their o CI modules so the first thing
I just want to quickly show is that if
you look at the module info files you
see that they're all the JSON files and
just to you know even idea what
they look like you know that's pretty
much as it wasn't the end of
presentation it's er yeah it's it's
adjacent file that declares what is
exported it gives the modular name and
aversion and it clears its its
dependencies so let's see how this runs
under actually I wouldn't say jigsaw
it's more like Penrose because we we
modify the behavior but the script is
called realistic so and um just to show
what it does had to prove that it
doesn't be useful I'm not sure if
everybody concedes call it up a little
bit it simply invokes the Germans L in
command which basically declares the
repository and then it specifies the
module that is being run so clearly the
chicks our way of operating things let's
read that
there's the demo and it works as normal
and we're not going back to the OC I way
running it it's the same demo it for it
is written from the same location
actually but this time an equinox is
being a started so let's do that to
prove that it works there we go exactly
the same obviously and so you know it's
just a proof that you can actually
already right a modular application it
works in both cases and the second em I
had was actually didn't prepare it
specifically for this presentation but
so it's probably interesting to show and
it goes towards the point that he made
earlier and while jigsaw create modules
and it attempts to solve the classpath
hell or the jar health problem the
dependency module in jigsaw is specific
in that it it is very well it's actually
explicit in terms of one of the pen so
I'd say this module is module a it
depends on module B but what is in those
modules is really not a declared as part
of that dependency and this means you
can still end up in module help
effectively because and this is what I
can show here you can create an
application where two modules have em
where am I and there might be two
modules that export the same class but
when you're requiring it you don't
mention anything about the class you
just mentioned the module so let's see
if we've got module eight its exports
class X and what will be the experts
classic the same class X with a
different version of it and then maybe
you have another module the juice is the
first one and get a third module
that uses the second the second version
and then when they try to communicate to
still get problems and this is one thing
that would like to show here and oh she
is as a solution to this which is quite
nice so um okay so here's the here's the
X class this is version 2 and here's the
version 1 of it right so and I've got a
module a here it's an executable module
that basically doesn't do X so when I
run that on its own it works fine let's
do that run module a if I read that it
basically works it instantiates accident
it can invoke on it now let's look at
module B and let's look at its meta data
first
so what you'll be has declared a
dependency or modulate and on the second
version of that of the library that
contains eggs alright so that's and then
what it does is if it in its class it
basically gets an extra may and then
tries to evoke the methods that the
second version of that library have
declared so that's clearly not possible
and if you run this you will see and
let's run it run module you will see
that it gets too if you see the
Baltimore surface is visible for
everyone I get to the first line of my
class right I'm getting to hear that's
fine and I've put in a print a red line
so that it waits so now when I press
ENTER I get a linkage error so this is
basically module help because it's the
problem still unsolved the nice thing
about our CI is 0 CI although it does
support the same type dependencies oh
she I people generally don't recommend
it it's the required bundle type model
oh she I people say well if you really
really want it you can use it but we
wouldn't recommend it o Shahi people
would generally work with package
exports and package imports and the
clear versions around that and I can
show that this actually solves this
problem in oceanic credit here a
parallel projects where there's two
versions of library they both you know
export the same you know structure two
versions of the class X and and the
interesting piece here is that in this
meta data the first library it actually
puts version 1.00 it declares that as
the exporter's version and in the second
one it says this version is exported at
one but one now the setup is exactly the
same and accept that the dependence
for the a modulus it says I require
package live between version 1 up until
two so this is kind of OSHA I called
semantic versioning if you break the API
you increase your major version so as
long as you stay within the major
version one should work so that's what
it declares and the second module
declares here it declares the dependency
or module a and it also says I need this
limp package f from version one at one
because it needs this new API so when I
run this and I've got to run framework
set up one that contains both versions
of the library it actually works because
the ocean is all relevant it's it is too
so there's no exception here it just
works and that's because the ocean
resolver takes all these constraints
into clouds and says okay modular a
requires something between version 100
and to module B requires something
between one of them one and two I have
both versions i think but i can create a
class space that is consistent with
although requirements so it does that
before we started and that's basically
why this one works here and i can also
show that if I am i running out of tiny
hours it's 100 go just just the one
thing if i run without this library it
fails laughs and here i got an exception
straight when i invoke it and it
basically says mortal to end up be
resolved so it's basically tells you
straight off the bat Raburn and going
into the class and getting a linkage
error you know straight off just happens
when you're starting off that is in
cannot so that's that's the demo for
today thank you so it's just a summer I
so if we've looked at why modules are
importance we looked at jigsaw and an
osgi and the role of Pedro's projects in
a try and bring these two worlds
together that the experience of people
have had trying to modularize large
applications and how we're going to push
that right down into the GRE itself here
are photos links for more information
and for participation in the project
thank you much very much for staying a
little bit later than that than was
scheduled your attention and I think
we'll just take questions privately at
the end yeah well we're not just kicks
out that's right Oh your figure 4
questions at you I don't know if anyone
has a quick question really we can
circulate
the relative
Oh
looks like this one more time I need
it's it's not a quick question I would
think that the model injects a little
different than what oh she I has been
using at least in the past and jigsaw
seems to be focused to works a
repository of modules so basically it's
just like a dotnet assembly effectively
so basically you have a big repository
that contains everything and then you
start it off from one entry point and
whereas so you still need to be able to
you still need to make sure that
whatever the Installer that you use
installs all the bundles that are all
the modules that you need what the setup
is a little bit different and so i'm not
sure i think at some point i think it
could be so very installer that that
knows what your dependencies are and
what I'm not quite sure if that's the
right answer quicker this chicks have
been
here
yes I believe it is both external but
also local as well for make sure that
you can preload modules into your
repository and intensity to run straight
out the repository but yet there will be
a download location chemo there is a
jigsaw bonfire tomorrow sorry I think so
yeah yeah tomorrow sometime and you have
to do anything all right okay thank you
very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>