<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Enterprise Application Integration Patterns for Java EE Cloud Applications | Coder Coacher - Coaching Coders</title><meta content="Enterprise Application Integration Patterns for Java EE Cloud Applications - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Enterprise Application Integration Patterns for Java EE Cloud Applications</b></h2><h5 class="post__date">2013-01-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/6HdvKeX2n-M" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">the objectives of the targets to give
you a basic knowledge of enterprise
application integration patterns show
you a little bit about how to implement
these and number three years benefits
and shortcomings of enterprise
application integration patterns in the
cloud
so as I said welcome everybody my name
is Alexander hoisin Feld
I work as a senior consultant for
software development at cyber Con in
Germany and also doing freelance
consulting and workshops mainly in the
area of enterprise application
integration yeah my name is my name is
Stefan Reuter and I work as a freelance
and software architect also in Germany
mainly doing business in the finance and
logistics industry during our consulting
jobs we often have concerns about
enterprise application integration and
when we go to our customers they say of
course we do an enterprise application
integration as we got a solar product or
business process modeling and/or an ESB
but actually nobody really concerned
looking at the whole space enterprise
application integration so our target
when doing the proposal was handling the
bus around enterprise application
integration getting your on track what
actually is enterprise application
integration and how you can benefit from
the many the many software projects out
there
yeah the patterns actually provide you
with an option to just put in some
structure into that fuzzy thing that is
that Enterprise integrate application
integration is about so you probably
heard lots of words a lot of lots of
concepts defined differently by
different vendors
the the patterns will actually provide
you a kind of structure that allows you
to make sense of that and also compare
the approaches of several vendors
several stacks to not drift into theory
too much and to keep up strong
connection to practice which shows a
real live example of one of our
customers its logistics service provider
who integrates many business partner
systems with his own system and we were
actually referring to this demo that's
this real life scenario often in the in
the process of this presentation because
most of the of the common concerns when
dealing with enterprise application
integration are built into this scenario
so actually what I want to say if the
application is running for five years
now in production we got in there about
three years ago when they had some
concerns about performance and I have to
say that this application is running
about two and a half years now based on
enterprise integration patterns using
spring integration so to get started
most people read the Wikipedia entry on
the definition of enterprise application
integration it basically basically says
that enterprise application is a way to
connect the set of enterprise computer
applications well this is actually quite
interest so if you're gonna find out
about enterprise application integration
at all the the Kapila entry is a good
starting point the set of computer
applications it's very often also called
information silos right like a big ERP
systems like SRP my AARP or something
our customer relationship management
like Siegel for example
yeah and in enterprise application in
that sense also means that you get a
complete stack because usually you have
a vendor l sells your CRM system or cell
Co and ERP system and you get all their
interpretation of what to use for int
equation of what you use as a database
and so you come up with two totally
different stacks that now you have to
integrate in basic you can you can
divide enterprise application
integration into two common parts it's
actually linking information silos via
mediation meaning explicitly connecting
two or more applications by adopting
their interfaces and transform data
between them right that's actually if
you say I need to connect my CRM system
to the ERP system explicitly that is
mediation the other form will be
Federation Federation actually is
providing access for external
applications like you build a common API
around this so the external application
doesn't have to doesn't have to adopt
the the API of your CRM and your ERP but
has a common API to integrate yeah so if
you're using like customer integration
with two systems then using Federation
would mean that by providing an external
API you would just update both systems
transparently to the user and by using
mediation it would mean that the two
systems would some all talk to each
other to replicate the data so you would
update it in one system that is leading
the data and then
would be replicated to the other system
and which one you choose actually
depends on a lot of factors usually you
will just use a mix and for different
use cases a different mix is actually
what we chose for our real-life scenario
as you can see we have the Federation
used as providing a ref service for the
external business partner system and we
also use mediation to integrate the
order management system of the logistics
service provider with the system of the
for water so to summarise it again
linking information sealers be a
mediation or Federation is enterprise
application integration and to quote
Martin Fowler on that who with others
wrote a book in 2003 various
technologies have been around for
enterprise application integration and
actually the Aston Cronus messaging is
really the best practice to do it
so is there actually a real-life example
of enterprise application integration
with let's say a synchronous messaging
well yeah obviously if you imagine a
reliable postal service as every
application has its main mailbox
just to give you a short idea about what
the benefits of using messaging is well
if you if you change your infrastructure
to a synchronous messaging you receive a
couple of benefits like first of all
message based communication allows
decoupling and not only decoupling of
applications but also the decoupling of
components or even services yeah you can
draw this as deep as you like and
decouple whatever kind you need and
decoupling also gives gives great
benefits and scaling if you think of
sorry if you think of you you divide
your your processes into small steps and
decouple these so they don't know about
each other you can easily scale one of
these steps right where you're going
back to that right in a few minutes so
another thing I like to point out here
is variable timing and throttling
meaning that through the answerin Kronus
messaging you can really let every
application work at its pace you know
that means you don't have to have to
spend a lot of effort to increase
performance on some applications you
just can scale them up or yeah do do a
little throttling and you're very
flexible on this point yeah usually am
this timing and throttling comes into
use when you have systems that have
different characteristics we're getting
how many load they can handle say for
example if you have a banking
application where you have quite
performant front end for end users to do
the banking stuff with um and ER rather
rather slow back-end system that does
all the the the data management and the
accounting the
usually it you need some some kind of
mechanism in place to protect the back
end system from the front end system so
if you have lots of users in the front
end system you don't want them to bring
your back end system down or to lead to
performance degradation there so by
using messaging you can't just limit the
rate of messages that are sent to the
backend system and so to actually slow
down the front-end system and the users
maybe even to refuse service to with
some of them and just show them a
message try again later or something
like that just to protect the backend
system and that that's what comes for
free when using messaging because you
have those messages and the message
stream and you can just apply your
policies there so next time is some
reliable communication this is also very
important because if you're using
something like HTTP or in an arrest
world for actually connecting systems
then you have to make sure it within
your application that the messages or
that the data and the function calls are
actually delivered to the system if the
system is not there if you receive an
error or whatever or the network is down
then you may have to retry it until the
system actually accepts it with
messaging that's quite different because
you just fire and forget the message and
the infrastructure takes care to
redeliver
or to delivery when the system comes
back into operation
okay when thinking about patterns you
first of all think about the design
patterns book by Erich gamma just give
me a little a handsome who knows about
the book who read it who used it okay
it's getting less and less okay okay but
the interesting thing is that I bet that
most of you even if you didn't raise
your hands now if I haven't used it have
used patterns even if you didn't read
the book if you didn't know about it
because it's so prevalent and that even
many classes within the JDK or many
frameworks are actually built across
built around those patterns so this is
the same with the enterprise integration
patterns even if you don't know about
them even if you haven't actually
applied them then you probably have used
some kind of products or some kind of
software that actually applies them
right enterprise integration patterns is
a book by a Gregor hoppy and Bobby Wolfe
it's definitely the reference on
patterns in in terms of a synchronous
messaging and some also call it the
Bible of a a I so if you haven't read
this or a bought you copy
I can really advise you to to do this
because um it's also it's not only a
great lecture but also as I said
reference to to look up certain things
yeah and and the common structure and
naming convention so if you're talking
to other people about concepts in the
enterprise integration world than just
using the names of the patterns in the
in the patterns book helps you
communicate with different groups with
people with different backgrounds
because that's just one concept and one
name right and actually the names in the
book are also widely spread across the
mediation frameworks we're going to talk
about now as it's good for their theory
but how to use enterprise application
integration patterns for example in your
Java EE application well actually there
are multiple approaches first of all you
can do it yourself by leveraging ap is
like JMS or jax-rs but a word on
do-it-yourself
is know when to stop when things getting
too complex then maintenance gets too
complex and there's always a person
become a bill right after you has to
understand what you did and that's when
actually you should use a mediation
framework like Apache channel or spring
integration they provide a great
collection of implementations for
certain patterns reference from the book
of enterprise application integration
patterns and they make it completely
easy to integrate applications no matter
what size yeah you can actually make use
of them and if you are only using very
small parts of this so if you only have
to integrate with say one or two systems
then you can just make use of such a
framework and use it not as a main
structure for your application but just
use it instead of playing HTTP calls or
something like that so we'll show you an
example later on and how to actually
integrate in your application and then
and so you will benefit from this very
early on yeah to provide you with some
of the names of the common eai patterns
we just chose to sum which we want to
introduce to you first of all a definite
lecture for everyone is adapters
adapters main purpose is actually to
turn custom data into message and then
we have pipes and filters also coming
Hertz come and hurt pattern we have the
Rooter which is really commonly used a
splitter and an aggregator that's from
our point of view the main components
the main patterns you should know about
there's also reference on the on the
slides which will provide the link later
into the enterprise application
integration patterns book which also has
a website you can read on it about more
patterns if you like and I could I would
really give you the advice to have a
look at this website it's great so with
all with all the the samples we try to
stay in our real life scenario meaning
we chose the domain model of this
logistic service provider and we speak
of orders in terms of purchase order we
speak out a logistic system or for water
system and we speak of or the items like
you choose a picking item in the
warehouse or something that's our domain
model for the upcoming samples okay so
let's say start with the adapters we
have inbound adapters and outbound
adapters so depending on where the data
is actually leaving your system or is
entering your system with every
application you have a specific
interface and that
it's basically twofold so on one end you
have the data that is coming in that
defines what is inside the message what
is inside the payload and you have
different channels or transports through
which you can accept the data and the
adapters are basically about the
transport so you have one adapter for
air transport that you're using to
either receive or send out data so one
example is using FTP on your help on the
FTP inbound adapter if you're receiving
files through FTP or an FTP outbound
adapter if you are sending fast we have
to be other examples here are live at
affordable for what is system so they
have soap interface web service
interface secured with WSOC so that you
can track data there that's in their
systems who the forwarded system would
have an inbound adapter for that soap
stuff and the logistic system would have
an outbound adapter to actually call it
are the examples are these a forwarded
system that sends the email
notifications so this is just an
outbound adapter and there won't even be
a corresponding inbound adapter
somewhere because the emails are for for
human beings so they will just receive
it at their email client okay to give
you a visual reference representation of
this pattern we chose the diagram which
is also published on the enterprise
application integration patterns website
you can actually see that the main
purpose as I said of the channel adapter
is to adopt the applications interface
and create a message which can then be
sent through message channel right
that's actually the main purpose and to
keep things simple it shouldn't do more
right it shouldn't do like let's say
adapt the interface and do a
transformation that's this special step
it's just an adapter
the next scenario would be pipes and
filters as you said a cell saw the
message channel this is actually called
a pipe like you know from from UNIX you
can pipe the output of different
commands to to the next command using
the pipe the pipe command right this is
actually the same pattern here pipes and
filters are used to decouple the
processing meaning you have a seemingly
complex scenario like that one here and
D couplet and divided into simple steps
so it becomes that symbol that it's
really to to get into that at the first
look yeah we had we had the the purpose
of an incoming purchase order to the
system and our look is the logistic
service provider needed to check whether
the the message was encrypted correctly
he wanted to know whether it's a known
customer meaning the customer was
authenticated provides correct
authentication and he also wanted to
make sure that the incoming message is
in the duplicate of another order he
already received and to visualize these
steps we actually provided three
different filters like the decryption
the authentication and a D dub
none of these filters knows about each
other you could easily switch them
around to have a different order like
first of all authenticate and then
decrypt or something like this if the
authentication information is somewhat
in the header or something that's that's
what I said about decoupling you could
easily tune in to some different step
here it's no problem at all it's simple
you can easily get this what it means at
the first glance when you see it
so to summarize it actually decoupling
means in our point of view easier
maintenance reusability and
exchangeability of the different steps
to use yep okay but the commercialism
and what these these pipes are about so
whether they are about when they are
like Jamis cues or something like that
and actually the name pipes and filters
is is quite abstract for a reason so I'm
using Jay Matthews there would be one
option but not the only one that really
depends on your requirements if you have
a pipes and filters and snippet like
this that we are there then using JMS
cues would be a bit heavy weight because
you would just grab the message from JMS
decrypted and write it back
so in that case you would use single or
simple in-memory pipes so that these
things are just connected but it's a
matter of configuration to just switch
that to using JMS queues and you can use
quite a lot of different implementations
for these pipes
so these non-functional properties that
are talked about like throttling they
can also be applied to those pipes or
even the delay so you can say okay I
want to have a delay that has an
additional property to just delay the
messages by saying 10 minutes or so
yes so you can use this in just one JVM
or you can use it distributed than you
would have to use Gemma's keys
yep you know one thing regarding the
decoupling of course you have it
decouples when you deploy it and when
you build it but you can also very
easily test it because you can actually
use them in isolation so you can have
just one of these filters like the
decrypt thing and write a unit test for
all possible input that that can be
accepted and then you have one of these
filters available on your on your
toolbox that you can use to build
applications later on Christmas well
this is a product so no it's not a
product it's basically a concept but
it's implemented by different products
one of them being apache camel the other
spring integration and more and more of
the commercial eai things also have a
look at the patterns and use that to
provide those bricks the question was if
this is like an ESB yes but the ESB is
just one implementation of this and
usually you cannot write integrated
within your own applications so that's
the best difference the thing is about
the mediation frameworks they are really
lightweight yes if you have an ESB a
fully blown enterprise service bus it's
it's a separate application but you can
use these patterns inside of your
application right to to decouple your
programming logic and that's actually
the main benefit you don't have to use a
separate product which which has to be
bought first of all but you can do a
very lightweight decoupling by using
this mediation framework in terms of
the development but you could as I said
the couple services inside your
application it doesn't depend on whether
it's the same application the same JVM
you can do whatever you like it's this
is just a concept and the implementation
of the mediation framework gives you
totally freedom how you would like to to
integrate it into your job is the best
thing I guess just just see how it works
just have a look at a short demo then
you'll also see the difference between
using it within your application or
using a separate product separately
deploy it like in the ESB
alright to give you short insight how
spring integration works with this we
decided to do a gateway sample a gateway
is basically an adapter which also
receives data back but it's part of your
application so most most of our
customers have to fear well if I use a
spring integration gateway my
application is tightly coupled to spring
integration and that's actually what we
wanted to show you that it's not on
actually with apache camel it's
basically the same so just have to get
the sampler over there
there it is
it's an 800 by 600 resolution just to
have a look at the example letting the
the namespace definition just at the top
of the page this is our complete example
right you have a definition of these of
this gateway or so um first of all
spring integration provides an own
namespace for your configuration of
these of the of the routes so-called
some College spring integration flow and
Apache cam let's call the root so what
you call it's actually the page over
your believed a left to you it starts
with these with the with the Gateway
which says well the Gateway is actually
of a type of a service interface really
meaning a Java interface we see this in
a sample in a minute it says by default
go to sent my message send my data to
this channel and receive data back on
this channel the sample actually says
well I need to get some data in and if
everything is fine the data goes through
then I don't want to see it again but if
it's blocked by a filter
remember the filter pattern then I want
to get them a message back yeah that's
the non matching and matching message
channel and this is simply what the what
the filter does so you go from this
channel right over here to the channel
definition it's the input channel for
this filter and the filter says well if
everything goes fine and the expression
matches send it to the output channel
the message sent a message to the output
channel if not the sky discard the
message and sent it to the non matching
message channel
do not confuse you too much the demo
uses an expression based filter it's
simply a spring expression language
which just looks it's the is there a
payload and the message which does the
question mark here and does it contain
the word sample context and content so
if it doesn't it's sent to the
non-matching massive channel if it does
it's sent to the matching message
channel and that's actually all you need
to do you can you could easily provide
your own filter your custom filter you
could use like XPath filter you could
whatever it it is really spring to
creation has many implementations for a
common filter in common come based
things you really want to want to try
out this there's a documentation link
already in our presentation so if you
choose to use this go with the
documentation and actually you can can
also ask questions to us to the spring
integration guys same with the camera
guys Yambol you can see here what you
can see there is and that you actually
mixing things that are provided by the
framework that are available out of the
box like the filter with the expression
and and things that you wrote on your
own like the output adapter down there
where you just put in the name of a
class and a method and then this is
called by the framework so this is
usually how it works you got a lot of
filters and adapters and gateways from
the framework that you can use right
away like for all common protocols and
stuff or transformation like access el
transformations and stuff like that and
that's for free basically it's well
tested and you can use it but if you
have any special needs any special
system that needs for data in a special
format or that has a special transport
and you can
build your own implementation of that
and just hook it into the framework and
for you to see that the framework isn't
in your way
I'd actually open this class it's a it's
a really simple beam and with the
configuration here you say use the beam
my external system adapt and call the
send data method and if you just go into
this class you see but actually is just
plain nothing so your your application
code your business logic could be here
just a simple system out to show you
that spring integration doesn't actually
get in your way at all
so use a mediation framework whatever
and I really advise you to to use this
kind of pattern with each implementation
cuz actually don't want to depend on the
messaging framework right your
application should be decoupled from
this I'll show you actually the call of
the Gateway and we wrote a simple test
actually two tests you get this you get
the interface the implementation of the
interface through dependency injection
so if we have a look at the custom
gateway it's really a plain Java
interface there's nothing in it except
for the method method declaration and
you just say well I'll give me an
instance of it and a spring integration
creates a proxy for you which actually
has the configuration you saw in the XML
file and you can use it like this simply
send whatever string you want to to put
there and it takes care of it for you
right and you get back the string can do
assertions can can use it in your
further business logic doesn't really
get in your way on the code you here see
here we provide later a link to github
where you can download the samples and
have a look
this
okay so Amex pennon we want to look at
is a message Rooter that's actually a
kind of conditional thing they can use
whatever expression are the feature of a
message to decide which way to go so one
example is a product type that we're
using an odd logistics application so
that you can make a difference based on
that or based on the bit on the payment
method if it's a credit card and use one
direction and if it's a direct debit and
use another provider or stuff like that
just conditional logic that's what it
looks like in the other pictures there's
pictures and those icons are also part
of the book so that gives you one visual
representation that is the same across
all all vendors and across all the
implementations of those those patterns
and as you see have an message that is
coming through a filter right in the
example you have a queue it could be any
channel any pipe then you have a message
Rooter that decides where to put the
message and the either goes out into out
q1 or q2 depending on on the logic
important thing is here that the
patterns put a strong focus on having
one responsibility or filter so you have
a message fruity then the only thing
that the massive Rooter does is to
decide which way to go
there is no transformation of the
message there's nothing else happens so
you have the same message that you had
in q1 after the Rooter either in out q1
or an out q2
and of course the logic can be quite
expensive depending on on what you're
doing there may involve external data or
whatever but the message route that just
has this single responsibility so the
transformer as you know my from the word
transforms data it's it's single purpose
just to adopt data model from one
application and turn it into the data
model of something else in our example
if you need to get customer data from
the ERP system to the CRM we had a
different data model in both
applications meaning of the fields had
different semantics like there there
wasn't the first name and last name
field and the European so we had to
combine it when we gather when we turned
data from the serum to the ERP and
things like that actually the the
diagram we're going to show you seems
quite complex but with you if you think
of it really does only transformation
have a look have a second look at it and
find out what it does
I think definitely at the second let's
you know what it does it simply gets its
configuration data from a metadata
repository meaning whatever repository
database or is something like a service
so it's a great example of what you can
actually do with these patterns right
the implementation depends on you
depends on the framework whatever you
want to do with it but it simply does
nothing more than translation of the
data you gave it the other steps from
Weatherbury before this or coming off
this don't know nothing about
translation and they don't care because
it's not their purpose
yeah and again there you also have quite
a large set of pre-built transformers so
I already told you about XSL
transformation and stuff like that or to
convert an object to Jason
representation or all those things that
can be done once and then configured
they're usually part of the frameworks
so that often you can go away without
implementing your own transformer which
is using one and configuring it so that
it does what you want another pattern
commonly used is definitely the splitter
in our example it splits a CSV file to
process each line separately and you can
see an example of this in about a minute
it's really really commonly used to just
nothing more than just take the take the
expression you configured and split the
message by this expression right you
know this is all from your programming
language this is the way a business to
patent you choose in your mediation
framework meaning your integration right
this you got the the order item which
which isn't actually in order position
of the purchase order think about you
got different a different items physical
or non-physical like a service or
something and you want to process them
separately that's the way to go yeah and
as we are in the mess in a messaging
world and that means that you just have
these three or however how much ever
items you get and they are just new
separate messages that will be processed
a synchronously and in parallel so now
you can have one order with all those
items in there you split it you process
them in parallel and then you have to
get them back and aggregate them back
into one message that you can finally
return that's the next pattern that's
actually the aggregator there's used to
collect all messages that belong
together and put them back into one
message that's usually done by I'm
having some kind of header or whatever
the messaging system uses to identify
the messages that belong to the same
original message if you think of terms
of our domain model if you have an order
position it certainly has a reference to
their number to the order it it belongs
to that is actually the example here if
you have an inventory item you combine
this into an inventory order so you have
a completed or the state across all the
different items in your order
yeah okay so that leads us to our next
demo where we'll show you how to deal
with this CSV files that are then split
and aggregated finally
let me just see I think we got it here
it's of course further more complex
scenario so the configuration is much
more detailed but try to document
documented so everyone gets it actually
that's the version coming right out of
the get repository so the documentation
is in there so even the the developers
of the logistics service provider really
know what the heck this thing is doing
there so let me get into there the
scenario is you you got a CSV file and
this can be this can contain a different
types of data and meaning um you have a
directory where there are separate CSV
files one for let's say services of a
warehouse like restructuring your your
locations of the of the of the products
and the pickings when you send an order
out right these are different different
files and you have to identify MFA if
they go into the same directory and that
is basically what we do here we define
the known headers to just import the
correct data so we go here with a
inbound file adapter meaning this is the
implementation of spring integration to
actually watch one folder on your file
system and you can configure it to
actually import all files or just files
matching a certain pattern in this case
we said well if this directory doesn't
exist yes please create it and the
prevent duplicate feature is a feature
of screen integration where it actually
recognizes file names it already
imported so if the same file goes in an
their time it won't import it again then
we have configured a polar meaning the
directory gets polled every 10,000
milliseconds so when the file is going
gonna imported its inside gets inside
the incoming ABR file Channel and it's
then forwarded to file the string
transformer that's common implementation
of spring integration meaning you have a
file input stream and need to transform
it into a string so can use it so you
can use it in your application code
right you don't know actually what what
the content of the file is which you
simply try to convert it into a string
using a certain chart set and then you
can deal with it not having to deal with
a file input stream or something yeah of
course that's only possible if you have
these in memory file in memory pipes
because there you are actually using
Java objects whatever you want it can be
even a file object or whatever so that
wouldn't be possible if you were using a
JMS at that point then we've this yeah
we have an implementation of the Rueter
which actually picks that CSV headers
mapping from above
you know we defined the the CSV headers
as a map via configuration and it simply
picks it here and says well the message
you you get split it split the split the
line endings and then check whether
whether the heading the first line
matches this expression meaning the the
value is C here right so if the value of
the first line for the file
we're actually the CSD header is placed
matches the CSV header for services go
send the message the service imports
shell if it matches the CSV headers for
pickings go sign it
the picking import channel if it doesn't
match anything go send it to the
unresolvable AVR input channel that's
basically all and if you ask me it's I
think it's really understandable you can
extend it whatever for whatever CSV
header or whatever you get into there so
you can you are really flexible in what
your infrastructure logic and
integration logic really does yeah
okay the question is whether we
differentiate here or the mediation
framework differentiate between unknown
file format or a real error like this is
something we can't at all deal with like
when the right like when you when you
transfer try to transform it into a
string and just blows up right
every mediation framework I know has a
certain error channel that is a channel
where messages get sent if they blow up
if they just don't get through the
through the root you you defined for
them the spring integration has a narrow
channel which you can adopt and then
sort out what kind of error happened
there you can send it to a JMS queue to
have another system look at it whatever
you like there's one ERA channel but you
can have a different different adoption
from there so you just have to have to
configure it like you get the messages
from the error channel and then route
them to whatever you like yeah so you
can even have a look here and we have it
right there the unresolvable
ABR input channel is right here we're at
an interceptor so that we do some
something addition ever want to invoke
some some custom logic right now we're
only logging it and then here we're just
routing it back to the aro channel so
that the general error handling occurs
right this is another this is actually
another implementation which is which is
quite common the interceptors every
channel can have an interceptor and you
can do whatever you like you can rule it
to logging you can say well I need to
get a certain information out and send
it to system B or whatever so if
something goes outside let's say in a
separate thread you choose the
Interceptor
okay yeah then let's go back to the to
the splitter stuff yeah
okay so question is and how do we handle
this if we have not one instance of the
application running but multiple within
a cluster so how do we prevent the the
message from being processed multiple
times well the answer is that in this
case you will use JMS add one in of
these pipes usually right in front and
you will have one instance that actually
watches the input directory and that
uses a JMS channel and a JMS queue as
its first pipe and then your
transactionally safe and then you can
have as many instances as you want to
just watch the JMS queue and you get all
the properties of JMS that they are only
delivered once yeah but that's yeah
we've seen this and usually we the first
step to do is just put it from
unreliable input source into JMS so we
also do this with HTTP your one endpoint
may that may even run in the cluster but
the first thing we do is put it into JMS
so that we are safe and if you receive a
file put it into a mask knowing yourself
cases God used people take care of yeah
actually the thing is the the the file
system integration we did with these
with a logistic service provider if you
remember the chart there was a business
partner system sending data via FTP and
just putting it down in some directory
and that's actually what we implemented
there
okay
so here's the scenario again so I'm
actually behind the FTP server it's a
small instance of an application which
just reads the the files from from the
file system and put it put it put some
into a JMS Channel right actually if you
have a transactional storage system you
could do the same right just depends on
the transaction so if you have a look at
the real life scenario within the cloud
and we see that this can mostly also run
in the cloud but we have a few gotchas
that we have to that we have to take
care of and that may be one of the
instances where it's actually much
easier if you're running your own dai
stack based on the framework and the
patterns compared to an ESB because that
would be quite happy to just put it into
the cloud so if you have a look at our
application again an embassy a number of
things that we must take care of in the
cloud we have to adopt for the specific
environment there and so we have a
limited number of i/o ok advice usually
you can't use the file system as a
reliable source of input well you
shouldn't do in normal enterprise
application but often that's how it
works but in the cloud there often has
no file system that you can rely on most
ports are closed so usually we'll have
to resort to HTTP or something like that
in to accept data and to output ATAR and
you need usually specific endpoints for
the services that are provided as part
of the cloud infrastructure so there
might not be a JMS implementation but if
you lot take Amazon and you have simple
queuing service or something like that
but you can rely on
but that's something you can easily add
to the framework or most of the things
for at least for the common McLeod
providers are already there so you have
input and output inbound and outbound
adapters for some vacuuming service and
for s3 and all those things that you
will find in a come on cloud so the
message is really clear sometimes it's
hard to integrate legacy systems into
the cloud but it's doable with
enterprise application integration and
that's actually what what we wanted to
send you as a message because sometimes
it seems hard to have a an application
depending on FTP or something like this
but if you really focus on decoupling
and slicing the steps really needed you
can just say well these two steps I'm
doing before the cloud and then
everything else goes into the cloud and
if you and if you go back to our sampler
here I actually except for the FTP
server thing the green box is running in
the cloud so the last the last advice we
need to give you keep an eye on traffic
and network i/o if you sing a sync
between your applications this is really
a serious issue in our eyes ok time for
Q&amp;amp;A so feel free to ask questions yes
please
um currently I don't know what sorry
the question was if there are any Goods
adapt what the a decent patterns for the
the adaption of what kind of application
yeah yeah actually I don't know of a
pattern to do these kind of calls right
now but actually is doable any further
questions
sorry yeah I'm just have a look at the
get up right
we haven't QR code for you so the thing
is if you like what you saw just follow
us on Twitter please if you didn't like
give us the chance to get better and
provide feedback eg via github issues
it's also good huh yeah so everything
you need is on github
at this URL so just get the get the QR
code going and you're there okay every
time thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>