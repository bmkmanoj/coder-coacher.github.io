<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Designing Java EE Applications in the Age of CDI | Coder Coacher - Coaching Coders</title><meta content="Designing Java EE Applications in the Age of CDI - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Designing Java EE Applications in the Age of CDI</b></h2><h5 class="post__date">2013-01-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/MwKlASN5g2s" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so good afternoon everyone so now we're
going to talking to you a little bit
about designing Joffe applications in
the age of CDI so my name is michael
nesmith of santos' i've have been
working with java for a few years now
have been involved with a few a couple
of j-stars especially being validation
in the date and time jsr and i have
given a few other talks here at JavaOne
and other other event and contributed to
a few open source projects good
afternoon to everybody so my name is
Michelle Bastian I've been working with
the Java platform for more than nine
years and I have been helping with some
open source projects mainly NetBeans and
actually I'm part of the NetBeans doing
team and I have spoken at some Brazilian
conferences just you have and the
developers conference so what you're
going to cover here is first we're going
to do a very quick CGI crash course that
it's not supposed to take much more than
five minutes to get everyone on the same
page in the case that you don't know CDI
at all then we are actually going to
explore a lot more about CDI unique
features the things that we really think
that you can explore you can use in your
application and there are hard to
achieve in other race then we're going
to have two cool demos that will show
how you can apply these specific
features that we're going to explore in
to the practical stuff stuff that we
have done at the project we have worked
on then we will also have time for some
Q&amp;amp;A Q&amp;amp;A hopefully right yeah so Michelle
is going to start with the crash course
just before that how many of you are
already used CDI okay so it's around
half so yeah so you're doing your head
you have some work so CDI is a
specification the GS are $2.99 and the
reference implementation is the project
well it's a open source project that is
under
the projects in umbrella and its use it
in the most application servers in the
world so this is a little quote from
world specification where it's highlight
the the main target the main goal of the
CGI specification that is loose coupling
and Stroke typing right and but how how
we can achieve this so to inject AB in
the CGI specification use the inject
annotation so here in this simple code
we are injecting injection an instance
of the greeting being using the
annotation but sometimes we need to
filter or to disambiguate the injection
point we have we can have more than one
greeting implementation so we can use
qualifiers to achieve this so for
example in this sample we are saying
that we want the informal implementation
so we have the same interface or the
same basic class but the implementation
is different and to define a qualifier
so we just create write an annotation
like this we use in Martin this notation
is the qualifier annotation the
qualifier notation is defined by the CGI
specification so another interesting
feature of CDI is that we can define a
name for our being so we can use
expression language in some view
frameworks for example JSF that is the
second part the second sample here so we
are using the page mode reference that's
the name of the pilot of our being page
mode and you can access all the
properties and methods define it in this
beam right and I think it's a really
cool feature that when we need or we
have so
being that it especially in salvation
for example for bees that have the
default constructor or that has a single
implementation of the beam so we can
just inject as I show in the first slide
but when we have some bins for example
locale being around other things that
mean specialization we need more
parameters initializer we need to create
bins that needs to achieve a go in the
injection point we need to use the
producer methods to create special
beings and not just to create but we can
define different metadata for this bin
so we can define a modern name or a
default name actually or a default
qualifier even a different scope for the
instantiated being and another thing
that it's important to make clear is
that CGI is not active or enabled when
you deploy your project so to activate
CGI we need the beam XML file it should
be available in the methyls folder for a
jar file or in the web beef folder for a
war file this specific file could be
really empty with zero bytes or we can
use this to configure some things some
another features of CGI for example
interceptors our qualifiers should be
define it there in this file so so now
we we filmed the basics of CDI and a CDI
has been available for a while and what
our experience has shared that people
really usually when they talk to the
developers they don't see what if there
is a big difference between CDI in order
to eye technologies like spring you know
so what we're going to show you here now
is what really makes CDI Excel and
can help you to design your application
a different way and then we are going to
show two cool things that we did with
these very specific these very specific
features that we are going to discuss
now so that you can also have some ideas
that maybe start thinking about how to
better use CDI so these are basically
some of the features that we think that
are important the way that you can clean
cleanly combine scopes in CDI the city I
event system the fact that you can
really achieve a lot of what we would do
with AOP frameworks route right without
any restriction regarding interfaces and
we are going to show one very specific
feature it is decorators that they've
been proved to be really useful and
really type safe in your projects we are
going to show also how the access to
injection point information can help you
design things in a very clever way even
make a compile time compile time safe
injection which is one of our or our
demos and finally we are going to talk
about portable extensions that we use
for our second demo that you can also
use as you develop your own frameworks
so one one good thing about CIS
injection is resolved when the container
boots in the sense that all the premises
have to be resolved at the time that you
start your container you have to have
either one single implementation with
the default constructor of the being or
you have to have a producer method but
the way that cd-i works it it actually
is it's actually clever enough to
dispatch things dynamically so this
means that in a class like the system
class there is Mark there as application
scoped I can inject your session scoped
pin or a request scoped beam and at the
time of the call this is who is going to
get to dispatch to the right thing right
so this is a like this is really a proxy
you know so if you have for instance a
request scoped being right and you call
a method on your application you're
going to have access to the beam that is
bound to that particular request
that started the call right so you don't
have to pass a let's all flew to to to
your application scope it beans no or
just create class you hold the
parameters so this is something that
really helps you to achieve clean code
right one thing you forgot to say we
actually have there is a hashtag if you
want to tweet about it it's H of CDI
right right right there
below this light and these scopes you
can actually create scope several
frameworks like the same framework or my
face is Cody they have specific scopes
and now there is a very cool project in
case you don't know which is like the
merge of seam and encoded they are all
merging towards Apache Delta spike right
so this is going to be at the home of
CGI X Asians in in always so you can
also create your own scope that might
make sense in your applications maybe
maybe you have a very specific
environment so that when you switch the
environments you want to control it as a
scope it's possible for you to extend
these scopes and you have this same the
same proximity available for you by
default so the right being will be
available there at the right time as
long as you follow the specification
right another another thing is usually
when we have to work with events maybe
like for instance when the user logs in
in your application you need maybe to
save some all this information you need
to cache some information so there are
several things you need to do usually
the only way that we can achieve this is
to write a listener interface right into
register and more maybe to create
different classes for the different
events that might might happen when the
user logins when the user logs out of
the application or create a type and
rule for this kind of thing CGI has a
different system that at first with just
information in this slide just seemed
like a different approach but it's it's
a it certainly works much better with
the Java EE technologies as we're going
to show in the in the other slides so
how do you actually build a listener for
a event in CDI as
in this to snippets you know the only
thing you need to do is to add a method
to any city I enabled Bing which is
basically anything that you have in a
jar file with the beans XML file there
you just create that method and you add
an observes qualifier for the method
parameter right so whenever an event
regarding a document is fired for the
first case you are going to be notified
no matter what event in this case
because it's also qualified additionally
as any which is the default qualifier
for even two observers in CGI but maybe
you only care about when a document is
updated so you just need to add another
qualifier this is these are potato
qualifiers actually a custom qualifier
is not same thing in CGI but that's the
way that you are able to distinguish
between different events the good thing
about qualifiers is that CGI's makes
them reusable throughout your
application so you can you can use them
for several things you could reuse the
same qualifier for other entities in
your own code but you also can use it to
have interceptors and other stuff that
we are going to explain a little bit
later all right so I showed you how you
can actually receive listen to this
event but how how is this is this event
fired right in the first place so it
almost also works with in fact injection
so basically you just inject an event
and you type it with the type that you
want you to create your event about and
whenever you need to fire it you simply
call event fire with an instance with
for the type so it's it's very simple
right but maybe you want to fire an
ending this case right the first
listener the first observer method in
the previous slide is going to be invoke
the second is not because this event
doesn't say that the document was
updated right so how can you say that
the document was updated for instance
you simply apply the qualifier to the
injection point as well right so in this
case when you fire the event both of the
observer methods that we showed before
to be invoked are going to be called
because the first one said that it's
interested in any event regarding
document right there is also an API in
events that allows you to dynamically
apply the qualifiers which is a little
bit it's way more advanced and then we
can cover in the time of our
presentation right but there are other
things about the event system that makes
it better than the listeners than
regular listeners one of them is the
concept of conditional observers so what
are conditional observers by default
maybe if you have an observer method but
the being the being that the class's
method hasn't been injected that didn't
it didn't match an injection point so
far so what the CGI container is going
to do is it's going to create an
instance of your being gist in order to
fire the event which might be what you
want or not so there is this idea of
conditional observers in which you can
say that you only want to receive this
event if there is already an instance of
your being for for the right context in
which the event took place so if the
instance hasn't been created you didn't
need to inject it anywhere so the event
is simply going to be ignore so ignored
so this can be useful in some scenarios
so the even system of CGI gives you a
very great control about details
including something very important in
Java which is the transactional behavior
right of your observers so maybe you
want the the you want your listener or
your observer method to be considered
part of the transact the transaction in
such a way that if it froze a runtime
exception you want to roll back the
transaction that initiated the event
right but maybe it's not the case may be
like in a you know in an auditing system
we we might just need to collect
failures of successes of invocation and
we don't really want you to influence
the outcome
of the transaction because of the
auditing the logging code that we have
so we can declare our observer method as
an after failure or after success by
default this is what we expect most of
the time which is 4:40 observer method
to be part of the transactional part of
the transaction that is taking place
you'll be able to roll it back in case
it fails but you have all these options
so the even system is not only powerful
but it's very well integrated with the
whole Java Java EE specification another
thing is how far CGI allows you to go
regarding regarding AOP right
interceptors are something common that
many frameworks have even HP have has
interceptors of it sounds but CDI also
comes with a different concept that
might prove to be really cool with even
more typesafe which is decorators that
we are going we are going to show in the
next few slides as well and the good
thing is it's all configurable so so
that it can be predictable interceptors
and decorators they are not enabled by
default and to enable them you have to
declare them in the beans XML file that
these interceptors and these decorators
they should be applied to this module
and the order in which you declare them
is the order that they are going to be
applied so this is external
configuration because maybe somebody is
going to ship some some interceptors
general-purpose interceptors and
decorators and you have your own so you
can really arrange them so that they
work well together interceptors how the
how our interceptor is implemented by
CGI so first you need to to annotate an
annotation which is very common thing
now not only CGI but other
specifications like being validation and
so forth you need to annotate one of
your patients with the interceptor
binding annotation so this is the first
step then what you do is
you create a second class which is
actually our interceptor that you
annotate both with interceptor and the
annotation recreated before which is
secure and then we have an around invoke
this is also not very very different
from what you have you need to be except
for for a few details then you annotate
it with around invoke and this method is
going to be to be called for all points
that are affected by the security ssin
and then we can do whatever we want we
might might manage security as as we
need we might actually call the method
and the the other interceptors that are
applied to it or maybe we just want to
throw an exception or something like
this right so how can we apply this
interceptor to a class which is annotate
a method then only that particular
method place order is going to be
intercepted or we might imitate the
whole class then all of its methods are
going to be intercepted but then there
are decorators decorators are a very
very novelty feature of CGI that that is
very interesting this is not the best
example that we could come up with
actually but but but it's increasing in
the sense that it's way more typesafe
and it allows you to have fine grain
control about exactly which calls you
want to to intercept in a very type safe
way so how does this a decorator works
first you annotate it with a decorator
then you need to either implement the
interface so it's very tightly coupled
to certain components in your code right
so you have to either implement an
interface that you that you're that
you're being implement or you have to
extend it right and then you are going
to inject the real implementation that's
how you're going to have access to it by
injecting a delegate right so you use
this annotation that is part of select
CGI add delegates and the type of of the
variable that gets this annotation has
to be the same time the same type
that we are implementing or extending in
this case lager which we put this other
qualifier there any because here
qualifiers are actually in the whole
city I specifically modifiers are always
taken into account so maybe if we have a
logger that is qualified with something
else if we don't put any this this
decorator is not going to be applied to
it because the DI considers it to be a
very specific logger but here if we say
that we actually want to decorate any
logger
then all loggers no matter what
qualifiers they have they are going to
be decorated with our implementation and
then one cool thing is that we maybe we
just want to do one thing with one
particular method of a being right of
all beings of a type so then we can
simply override the method and for all
the other methods it will work as always
it will cause to call them the other
method the straight but for that
particular method we can capture it and
like in this example I simply add the
timestamp right it's which something's
silly just to demonstrate the technology
itself but you can do really
sophisticated things with decorators
these the kind of things that we would
use point cuts for right in a in a NOP
framework so you're able to do this in a
very type safe way so that maybe if you
change the interface or all your your
decorate is going to fail at compile
time which is different when we work
with AUP we usually only figure out in
real time that mout configuration has
changed and not everything that we
wanted is is is being intercepted
anymore or it's off to being intercepted
and so forth right so one thing that we
actually probably the only thing that we
like the most and that we see most
potentially is the fact that you have
access to injection point information
right so let me go straight to the to
the code sample here so this this is
actually the first snippet is actually
taken from the CD ice pack and it's
funny enough something's really
to do spring for instance so one thing
that we usually do when we have loggers
and is maybe - we want to create a
logger in the second example we can
rerun to create a lotta from a log
factory right that we want to pass some
class dot class that's how usually we
create loggers in Java code right but
how could you reject this if for each
injection point you need to create it
differently based on the class being
injected right so using CGI on your
producer method you can add a special
parameter that you can actually producer
which is injection point so injection
point is going to give you the
information about that particular place
where your beam is going to be put right
so then you are able by calling get
member we are going to actually get
reference in a reflection to the logger
field we are able to get the declarant
class and to pass the name of some class
for this particular logger when it's
injected there so we actually can
examine the whole environment where our
being is going to be used in order to
produce specific instances or maybe even
to the nine section maybe you use this
as a way of enforcing a design pattern
in our application so that we can throw
an exception saying that what you're
trying to do here in this component
you're not supposed to inject this type
of being for instance you can do this
with CGI so this brings many
possibilities there are many clever ways
in which we can use this feature now
probably the most confusing part but the
most powerful feature of CGI is that CGI
has kind of its own reflection and it's
actually more yeah actually the fair
comparison would be the instrumentation
framework that was added to Java 5 in
which you can get the class loading of
the VM and you can actually manipulate
bytecode before the class is defined by
the JVM so CGI allows you to do
something very similar you are able to
participate in the process that CGI
calls beam discovery in which it's going
to read all the metadata of your
application and it's going to decide
what interceptor should be applied
to being or which implementations are
available which brings our actual city I
beans in which ones are not so here we
have an example so how does an extension
works first you have to actually
implement extension we're going to show
an example with portable extensions to
you so first you have to implement an
extension which is just a marker
interface it doesn't pass any methods on
it right and then you can add several
observer methods that there are able to
capture specific information specific
map information of the CGI framework so
here in this example we are observing
the process annotated type event which
happens when a versity I finds a bin
that contains annotations so maybe we
have this 30 party jar right that has
some beings available but the guy that
designed those this framework this
library didn't think that we wanted to
use them directly from JSF for instance
so the beans are not annotated as named
right so I cannot directly annotate them
if they are in binary form so one thing
you can do and here actually the code
inside this demo mode is the disputer
construction is is being done with code
from syncs order that makes it easier to
read on CTI 1.1 they are actually going
to have something very very similar to
this because it's it's not something
that you worked really hard when they
design the first version now people are
building extensions and it's kind of a
pain to write all the code to do this so
in sync we've seen solder we can create
an annotated type builder copy all the
annotations from the original class and
then add another annotation which is
named so also so that comes with the
name of the literal that allows you to
put named in in beans and with this we
change the annotated type to contain now
named as well so we can actually
transform the metadata that the CGI
container sees so that we can create
frameworks that inject things in CGI
applications so this is a very powerful
use so another observer that we have
here that we actually use in our demo
you can also see all the places where in
action takes place so that's what
process injection target is about you
get access to all the injection points
in the application all places where you
have at inject and you can do things
with it what kind of things we had one
idea that we're going to show you here
but there are several events for nearly
every type of math information in CGI
whenever an interceptor is found
whenever qualifier is found so that you
can manipulate this metadata you can vet
vet oh this metadata as well you can say
okay for some reason this guy put this
class along with this job and now CDI is
able to see it and it's messing up my
environment I want to hide this class
from the CDI container you can actually
suppress it right so it allows you to do
all kinds of manipulation in the
low-level of CGI so it's it's a very
cool thing so now let's put it all
together so Michelle is going to show
you the first demo of the things that we
have discussed so far okay so the first
thing we want to show you is I think
most people here use JPA
or hibernate or this kind of or or mark
or area tools so how you create a name
it we do for example so we use the
entity manager reference and just pass
or you form a string so actually the
creation of a name of the query it is
not safe why not because for example the
developer could just type a wrong name
of the the name of the query so the the
code will compile of course we don't
have any validation during the compile
time you'll be able to build your war
file and deploy that so we we just see
the the problem when we run the
application so we will face this on
runtime error or during the test
automated test or when in the worst case
when it's in already in the production
so how I can
make it better so our idea was not just
fix that issue but make the type of
query type safe how we can do that so we
imagine where a scenario when we can
inform the query name so we will inject
there here directly the type of query ok
and the second sample we will inject
informing it directly the name so for
the first sample we created a convention
where the name of the query that will be
created will be the type here it's
customer plus dot and the name of the
member find out so for this first
injection point we will inject the query
name customer dot find out for the
second one we will inject customer dot
find by name
so using this feature it's more type
safe because we avoid to use too much
shrink right and what that made possible
with annotation processors we can
validate this during the compile time so
if you are using for example NetBeans
that it integrates with annotation
process we can have these errors this
warnings in the editor so you see that
even before you save your file you see
that you are making some mistake here or
you know that you need to create the
named query or your try using a run name
for example in this first one we just
misses the last L and this one we miss
it da so NetBeans are saying that is not
define it but if you change that for
example editor with not integrate with
annotation processors you will find that
when you compile your project so now we
have a type safe type of query which use
not too much string and its can rise
raise errors in compile time so
it is really powerful and helpful when
they are developing so we don't have we
have white they were doing running
running time grunt I'm sorry
so how I achieve this I'll show you some
code now so we have a lot of a lot of
Navy queries here and now is the sample
I showed I showed you so we have two
injection points here to type it queries
one with the name it will define it
another one without that and we use it
in the method so we are injecting or
type it query just calling it this
method and this one is G is just JP a
code simple like that so how we can do
this in CGI so the first thing is that
NetBeans show you that he this is an
injection point so we used producer
methods to create type adequate e
because we can analyze the injection
point and get the odd information to
create this type of query so how you do
that
we just access the injection point that
you can see here leader is mobile we are
analyzing how to find our method in the
index class which is the first one so we
get the parameterize the type of the
method and the member sorry and the the
actual type argument here which is if
you see here the product class so we get
actually the type using generics here so
the first thing we look is it is if the
the member is annotated with if the
queen name annotation is present in that
member the first in the
first case it's not so we were just
beaut create that string here
automatically in this method getting the
field name which is find out so
analyzing the param parameterize type we
can have the we can get the simple name
okay
here we can get the simple name of the
class that is product we add the dot
string plus the name of the field which
is find also we have here product dot
find out pretty right so we execute that
and here we just create call the the
method for the JPA
API which is create the name include
soap the name it query we created that
this product dot file will be created
and injected in that injection point now
the CDI are analyzing the customers feud
which is the second one and have the
query name annotation so in in this case
it will execute the first part it's
similar so we have the parent time here
but in this time we have the queen name
annotation present so we just get this
time the value define it in the
annotation which is customer not find
all okay so and we call entity manager
the created creating a media query
method in the entity manager didn't use
this name so if we execute that and we
go to our browser so what we have here I
just have a sample database which search
for all those things and we have a
genius F page that shows that and so
that's the first part we have injected
defined our method what's cool but for
instance if I came here and change that
for fine Oh see we have
error in that means even my father's not
save it so it's a me find out it's not
present if I'm looking for in the
product the entity I don't have that I
just have with double well so the same
thing happened if I compile that if
everything goes well let's hope it
doesn't failure so here you are we have
that in the compile time we have let's
see if I have some I don't have zoom
here sorry
so but the ever is here and actually it
goes to the correct the right line and
the code and we can fix that
so okay we have some extra time a little
bit so let's see how we do the
processors so it's a standard ok
processor that we can use since Java SE
6 and we do Chris the phone oh yeah
ok so what what we do here it's a simple
code okay just analyze it's do a similar
work that we do in the CDI we the first
thing is get lookup for all nailed we do
have in the system ok analyzing the name
it query
it's a JP a notation so we get all the
queries after that we look for the query
name annotation and look if it exists or
not so if it's not define it we just
write here an error or if the the field
is not annotated with the query name
annotation we just look out and do some
work here to get the name of the field
and the type of the field and raise the
error again this time at the compilation
time so in this sample we have typesafe
nama queries and it's compile time safe
too
the developers will be really more
productive in this case so what he used
in this particular sample use dependency
injection right we use producer method
that used the access to the injection
points that's the really cool feature in
the CGI because you can analyze where
you want to inject that field so we can
create beans that will really fit in
that particular case that's the the
point here we can analyze everything in
a typesafe way what's the point of the
cd-i so now I'm going to show you a
second demo that will hopefully work not
that yours work I don't want to look MIT
so when you start working a lot with CGI
you if you start developing your own
components usually in the application
server for instance you might have good
support for monitoring your HIV
components right but maybe if we start
to write in CDI components or CGI beings
a lot because we are now exploring CDI
how can we have access to some basic
monitoring features right or to see
what's going on in our application using
the same monitoring technology so the
second example that we're going to show
you here with portable extensions it
actually creates JMX any beings on the
fly based on the metadata found in the
bins covered process does everybody
knows what j max is or not in beans
right okay so that that's what we're
going to show you to show you here so if
you look at the application on J console
with the code that I'm going to show you
and hopefully live it's going to work
right we can see how many maybe some
some some information like how many
qualifiers we have there
how many interceptors will be able also
to collect some information per
qualifier as you can see on the three
nodes on the left so there we have all
qualifiers that we have available in our
system then we can see how many beings
are tasted with it how many injection
points are met by these qualifiers but
also we have
matrix right that is actually these are
metrics are actually in nanoseconds
which we used here for measuring so we
can also do some things very similar
that exists in in several application
servers which is exposing information
about each component in the system so
here we have the index pin right in the
bins node on the left then we have all
the methods that are exposed by this
beam then we have some metrics on how
well they are performing on real time
right with something that you might have
a GPS and now you want to have you is
your CGI components so how can we how
can we actually do this right so if we
go back here to the ID stop GlassFish is
the mouth working on this one okay it's
the mouth
I don't know the address okay so stop
GlassFish first here and I'm going to to
run our our second demo which is the
deport these CDI portable extensions
demo right so we're going to run it in
GlassFish and what we have in this demo
let me all right yeah it's going to
deploy really fast hopefully so so we're
starting GlassFish here we have here one
one class which is yeah it's opening so
we have this very very simple user
interface because as you can see that's
what we make a life for right as
designers that's what we Excel it so we
have this very ugly page in which you
can type a username and then we have two
types of greetings I'm going to show the
code before so me about have two
username for Michelle and okay there's
not part of the demo right it's just
that his computer likes it and suggest
his name by default right in them as we
click here it's going to show me two
kinds of greetings I'm going to call it
a few times so that we can see something
more interesting in je console right so
let me open je console first and hope it
works it worked
let's connect to the GlassFish process
there is running and if I go here to
Jane the damn beings I have a city I
demo node right if I if I expand this
node I have here the the monitoring that
we added and then we have all the beings
that we have in our in our application
right and then we have some metrics so
maybe for the the get message method we
can see there I invoked it 12 times
right because actually JSF also invokes
it a couple a couple of times as well
and then we have for the formal greeting
have some metrics of how long how long
it took right and I'm going to show you
the code so that you can actually match
the code so what I'm saying here so if
we go back to to NetBeans okay if you go
back to Jeanette things here we have
this classes we created an index
component which is being used by the
index page in which you inject this
tubing is destroyed kinds of greetings
for which we show the qualifier already
there's a enfermo qualifier at the
beginning at the talk right and and then
here we have the two implementations
right the the regular greeting and we
also we also have the informal greeting
if you notice it - because it was way
too fast and we also didn't want to
write much code we resorted to thread
slip to make it take a while and of
course the formal greeting is faster
right
it only takes three and then sex and up
five okay so and and then we actually
use here a qualifier to say that this
was the formal greeting in on the other
side okay yeah it didn't increase the
font size thanks Michelle is it good
enough yeah much better
right okay let me just solve them for
for you guys that were sitting in the
back and puddin couldn't read because of
my stupidity okay so now now everybody
can read this okay so in this case we
were able here to to actually collect
some metrics about the invocation of
those pins but we also provided here an
overview an overview and being that show
us how many interceptors are deployed
our CSS how many in our system
how many qualifiers are there and we
created one note per qualifier that has
more information so far it is for the
informal qualifier we see here that we
only have one annotated Bing and one
injection point but this is not the
interesting part the interesting part is
how did we achieve this right so if we
go back here to to NetBeans there is
this other model module of extensions
right so we have here for instance the
the geography oh the overview extension
right so what what we have to do is
first we have to implement extension
right which is the Fox Enterprise inject
SBI extension which is just a marker
interface then we have here some
observer methods right the first the
first one is here process annotated type
so for all types what what we did is we
collected the annotations we loop
through them and then we checked using
the beam manager right so the beam
manager is like this mainly Oracle in
CGI that tells you everything that you
need to know you can access all the bins
through it and this is another thing
that we only showed here in the demo we
did include in the slides which is for
any being that you can inject both in
producing methods and in observer
methyls like this you can declare a
parameter right that of this type in a
CD I say butch injected so if CGI knows
how to create a beam manager you can
declare a parameter as a be manager in a
producer method or in an observer method
which is what we did here right so CDI
is just injecting the the be manager for
us and then we can ask them
if this imitation is a qualifier right
there are several tensions in the system
there are not qualifiers if it is then
we we put it in a map and then we say
that ok we found another being that uses
this qualifier if it is also used as an
interceptor binding limitation we we add
it right also we we as we showed in one
of the slides we collect all the
injection points to see in how many
injection points a qualifier is being
used we could actually have all this
information to show in some kind of
report about the life the behavior of
the live application how many injections
actually took place of a particular
being for some reason and then the final
step the final event
one of the final vents that are there is
fired by CDI during the discovery
process is the the after deployment
validation so once all the deployment is
done then we actually create our array
me being with the name that we saw has
there there we collected the qualifiers
count the number of interceptors we
registered and then we also register all
the qualifier me beings that were
created for each qualifier and since
that we want to be good since citizens
in the jmx environment we also observed
the before shuts down event there is
fired you it might be fired before
applications redeployed for instance
right so there will be a before shitao
event then we wait to start over again
so what we do we unregister all the
beings that we created so that redeploy
can works cleanly there is no leak right
so with this we were able to create you
to show you to create the demo that we
just showed you there's just one more
step in configuration here when we're
using extensions there is important to
highlight is that you have to go to
methane into the methane folder and to
create this is the the de standard for
declaring a service in since Java c6
rights is not something specific to CDI
you create the services folder and they
don't have to create a file there is
named after the interface you're
providing you're providing an
implementation for in this case
extension so both of our extensions are
register here right this is the fully
qualified name we didn't we didn't want
to use more fancy or standard packages
so just call that mgg because again and
so this is the other this is the other
extension that we actually did this
extension is the one that deploys its
deploying the the interceptor binding
for each method call so that we can
instrument the method code and see how
long it takes so this demo also yeah
we're kind of running out of time this
this demo also shows how you can add an
interceptor from an extension in this
case for all beings we could have chosen
some of them based on a patent or or a
need so what have we have we showed here
so here we use dependency injection
producer fields portable extensions
callback events and interceptors and
some jmx technologies so what's what's
the point of is this whole table I think
that by now
you saw that CDI is more than a simple
dependency injection framework it has
very powerful unique features like
access to injection points information
you have this wonderful event system and
this very powerful portal extensions
feature that allows you to create to to
really develop creative type safe
solutions so there is this whole world
to be explored that's why we said that
it's a new rear end eh of CDI so keep in
mind that you have all this power at
hand when we were writing a Java EE 6
application long words in that you can
do all this kind of cool stuff so maybe
if you have some questions so here is
our contact our contact information in
the last nine line actually you have the
github project that contains all the
codes that we showed you here so you can
actually download it right now I think
we used Apache right the patch license
for the demo yeah yeah so please take
the code into wherever you want with it
except serenus or path
right yeah that's it that's it so any
questions yeah that's interesting one of
them when they first developed weld
which basically what you have available
in most environment
except for websphere which is always
different anyway but for instance when
we first developed weld weld followed
the specification very closely but
performance was really bad even if you
didn't do all of this you know it had
many memory leaks now it's been quite a
while it's been three years they have
been working really hard on this but
there is always overhead if you had even
if you had a regular interceptor to an
AGP it's going to take some time if you
if you add a portable extension you're
only going to to influence how long your
application takes to boot up because the
portable extension overhead is only
applied to that specific part right but
that's a main inch of a code you have to
profile it to see what's going to happen
now now the overhead of the system
classes itself of weld is well lower
than they used to be so actually the
code that we use is called we have
written for for other projects we just
had to rewrite it from scratch so that
now you can take it into wherever you
want of it okay so we actually have real
codes using code that is at least very
similar similar to this and it's working
hey sorry I couldn't speak a little bit
louder still can't hear you yeah you can
actually actually what we did is very we
almost did this right yeah I almost did
is this what is extension does is is
exactly this right this this particular
extension that we showed it's capturing
your all types in this
there are annotated right there is a
there is another step before in which
you can actually create a say that a
being that has some annotations has
annotations should then get to this step
you know and then it can dynamically
deploy an interceptor as we showed here
so maybe if you have a class that has no
annotations at all that is not even
considered as the i-beam because it
doesn't has a default constructor which
is one of the requirements right you can
through the extension say that yes now
this class is a pin you can create a
representation of it and then you can
intercept the calls for any any class in
the system actually so so in this sample
actually we do that with we did this
every method never being okay
it's intercepted and that metadata the
the time it takes to execute is it show
in the in the a me being DJ console so
here we did that intercept all methods
of our CDI beans that's what we did here
in this yes you can maybe maybe if you
have classes that are supposed to be
built with like they have static
factories so they are not going to work
out of the box of CGI so you can say you
can inform the CDI system during the
disc are to the discovery process by
just capturing one of the events and say
that now this this is a being that I
would like to add to the system it can
be constructed by just invoking this
method so you you can actually add
anything to to the CD Isis and this
happens a lot of Java C classes like
look how lock out doesn't doesn't have a
different constructor you're supposed to
actually call a static factory to get
the default locale and even the DJ's are
three three ten classes they are
supposed to be to be built using also
static factors but but I expect that as
people use CGI more the
particular aspects of cd-i that people
are not using much yet that many of
these these classes they are probably
going to be listed there as as classes
there are available already for CDI
because it's a very standard way of
exposing them so it makes no sense for
people to be building this same kind of
code all the time and that's also I did
there is the Apache Delta spike project
that already makes several of these
common classes available for the CDI
environment anyone else yeah yeah sa GB
basically if if if Jeffrey started
breeding written right now if CGI came
first
probably we wouldn't have all these
different notations as we have now
because city I was only added after
right after we added annotations to
toffee so all these other entities like
persistent context and all daily came
with Java e5 then came the idea of
standardizing CGI that actually came
from from JBoss table same and Google
juice right so it's kind of the mix of
what both of them had but it they have
refined it so it really has to do with
when it was added to the platform you
know it if you are using Java EE 6 they
are kind of interchangeable sometimes
there are a few differences you really
have to read the Java EE specification
to see what are the difference but they
usually work the same in their only
reason they are there really is because
there was no CGI before when the
magician was created so that's right
there
anywhere else No so basically that's it
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>