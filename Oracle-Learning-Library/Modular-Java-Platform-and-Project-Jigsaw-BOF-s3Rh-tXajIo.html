<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Modular Java Platform and Project Jigsaw BOF | Coder Coacher - Coaching Coders</title><meta content="Modular Java Platform and Project Jigsaw BOF - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Modular Java Platform and Project Jigsaw BOF</b></h2><h5 class="post__date">2013-01-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/s3Rh-tXajIo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay it's four-thirty welcome to part
two of the jigsaw extravaganza here at
javaone 2012 here with me tonight are
Alex Buckley drop a language
specification through I have no idea
just the spirit of it it's great why not
mandy chung jdk hacker extraordinaire
and me and me your humble host so an
hour and a half ago did the jigsaw talk
this is Q&amp;amp;A hopefully you were all at
the talk I don't intend to repeat the
talk right now you can catch the video
in a week or something so this is a Q&amp;amp;A
buff are there any q's will try to
provide some a's
and other classes they're bringing no
other God what is the most regularity of
similar to what we have a job now and so
we get my keys big number hot choice you
can see that not really caused by the
code but just by the it clear what your
fantasies because tom
and you know thank you you talked about
the giant hundreds of thousands of many
cases on that going to be the same is
just that they're not
so let me see if I can summarize this so
I think you're asking roughly well you
know are we going to go from Jar hell to
module hell because the especially if
things are if modules aren't decomposed
at the right level aren't you're going
to wind in pulling in a bunch of stuff
that you might not need and and it'll
still take up a lot of space and it'll
still be really how much to deal with
it's true that if modules aren't
decomposed well you could still be
dragging around a lot of baggage you
don't need but remember the big reason
that jar hell is Jar hell is that
there's no structure to the classpath
well there is a structure but it's
trivial right the classpath is a
sequence of jar files and we ask when
you ask the vm go find me the class
named ABC it starts at the first jar
file and asks is ABC in here no it goes
for the next one's ABC in here no it
keeps going until the end and and the
really hellish part of it comes when you
have three different versions of say
comments logging on the classpath and
each version added some stuff and the
earlier version is first so if you go to
you go use one of the older commons
logging classes and it really mean to
pick on comments logging but I am I
admit it you got to find one of the
earlier comments logged in classes
you'll get it out of Commons logging 10
but then if your if your program uses a
Commons logging class from a later
version then well I won't find it there
I won't find it any other jar files
it'll find it in you know Commons
logging version 5 down at the end of the
class path and those two classes are
probably not going to work properly
together that's jar hell and with the
module system we get out of that because
there are there are explicit dependences
you have an actual module graph a class
can only see the other classes that it's
supposed to see not accidental stuff
that happens to be laying around on the
classpath
does that answer your question you have
to like this hope that information about
actual dependencies in the code like
important device could be analyzed to
find out your dependencies and I know
that reflection
big problem but that they make the heck
well sure my part part part of the art
of designing a modular system is it was
very much like the art of designing a
good set of classes you need to figure
out you know which sets of methods and
state to store into which classes if you
have a sensible class structure you know
it's the same it's the same thing in
modules and it's it's not something that
can be done automatically automatically
we can certainly provide tools just as
there are tools to help you structure
sets of classes there can be tools that
will help you structure sets of modules
by doing by showing you the the actual
class level dependences across them but
there's no there's no magic bullet that
says oh well we'll just have instead of
installing modules they're just
installed you know class by class and
something like that interested it's too
granular it wouldn't it would be very
hard to make make work do that please
because I I guess to follow I'm guessing
at what what you're asking about their
there's two types of creative he'll
decide the immersion conflict issue
there one one of which is
if you were to say load all the classes
literally at once for the module and if
you need them down recursively which of
course you're not going to do I assume
no bruh however the other is say if you
have an applet today when you don't have
what you have jar indexing and you even
though you're and you have a classpath
declare in those jars typically and so
even though this jar depending on five
other jars when you're doing a class
woke up it doesn't load it over the
network unless the jar index tells us
that your classes in there so if you
would extend that same notion to modules
you wouldn't actually have to go grab
the module Lessman tell you actually
discover that you are going to use a
class from within that particular
modules you can do more lazy loading on
cases like yeah so it's actually not one
of our goals to support fully module
fully the fully lazy module loading the
applet case is one of the few actual
compelling use cases there so if if and
if and when we create a modular notion
of applet it will require that you you
download and install everything before
the applet runs but you know the applet
model well how interesting is that in
this day and age hard to tell yeah
picture that
will there be an introspection or Ruth
yes yeah there will be reflective
support we have this in the jigsaw
prototype if you if you get an object
you can ask for its class you get a
class you can ask for its module you
know from from there you can find out a
variety of other interesting things yeah
it's it's an enhancement of the existing
reflection API framework
press bus
two
wichita
bye
and
very
right so we try to summarize it he did
with in the classpath world if you have
two classes with the same the same flow
if I name on the classpath and sometimes
you have to go do hackery and open
explicit jar files to figure out which
jar file didn't come from or which orgo
get the correct copy out of the correct
jar file amongst the consistency checks
that were that we do in the jigsaw
prototype is we don't allow that so if
you if you if if module a depending on
module be in module C and and both B and
C try to export a class of the same name
the resolver says dragged in no it fails
when you install the modules it doesn't
even get to starting starting your
application you can't even install in it
in well client classes don't have
version the modules do it but in so in
in the city you know in the
straightforward simple uses in with with
what we've done that jigsaw prototype so
far you cannot have more than one
version of module with the same name you
know and in most cases that's perfectly
adequate as I said it in answer to a
question that in in the previous session
session if you're if you build a
classpath application and you have two
different versions of the same jar file
in the classpath that's a bug you might
not know what your system might actually
run fine for years but eventually you
will find out and it will be a bug now
it is important in in cases where you
have you know dynamic containers that
need to load things you know the
application server nitey or something to
be able to in a controlled way load up
something that that might depend on you
know some other version of the XML
parser than the one that the app server
came it came with built-in and so when
you know we will we will figure out a
way to support that we know how to do it
we just
prototype to get so that that'll be
there but you know if you're writing a
straightforward application it's almost
always a bug to have multiple versions
of the same thing involved yeah
all the files all the causes
we were calling
little bit like a self-contained job
do do do I envision having a tool that
would allow you to take it to take them
out let me give you have to get this
right take a module figure out all its
dependences and suck all of that stuff
into one giant module that it's it's an
interesting question you know it
wouldn't be hard to do that one of the
tricky things that there is what would
you call the result because if either if
the original module is called foo and
then you did the static linking thing do
you call that food well no you call a
food plus plus ya know they're there i
could certainly envision uses for that
kind of thing it wouldn't be wouldn't be
hard to write and and i suspect that if
it weren't available as part of the
system somebody else would write up or
five other people would read it
yep it reads the
increase best so
yeah they're there
option
from I don't have a problem that
yeah so
so I understand the desire for this kind
of tool and certainly fat jars or
something that well they're kind of
gross but they can be useful today I
would like to think that once we have
actual modules with actual dependences
the temptation to do that kind of static
linking will be far far less because you
can just use tools like j mod and a
remote repository and it just it just
won't be a problem you you go to install
foo and the rest of the stuff comes down
automatically and gets linked up there's
there's no compelling advantage to do
static linking at ahead of time in the
way that we do with the fat jars I mean
that we fat jars are a useful hack today
because they help deal with some of the
pain of the classpath
can you maybe you can compress a
self-contained module a little bit
better I don't know I tend to doubt it
unless your models are really really
small pack 200 does a really good job
with without a lot of data
all there
why
yeah that would be that would be one use
kissed another one in her whoever who's
next I don't know earlier you mentioned
classpath boat module a lot of those
lines you mentioned that delegation is
going to change and I guess one question
I have with regards of that is 900 at a
time I agree you have what version of
library in your entire application you
have the container issue of course but
creating containers for a moment
sometimes you'll run into a neat
for one little milk of your application
with that LSG i used some old version of
library you can easily get around that
with the custom class loader URL
classloader today please ignore the
broader one so forth are such kind of
still work I I suspect a similar trick
will work there thinking we would like
to make once we have the container
support worked out you know and I would
like it to be the case that if you need
to do something like that with a little
bit of reflective code you can you know
set up a constrained environment here's
that you know ancient version of Xerxes
that I absolutely I can't do without and
have the right things link up to it
support of body loading and your Thank
You diction
and I mean
providing extension points
I'm not sure where your question is that
a question or comment
what no well yes enough so so eclipse is
is a canonical great example of a highly
dynamic system it uses osgi and it
really exploits osg is the ocean eyes
ability to have things come and go you
know dynamically at any time and loading
and unloading and lifecycle events and
all that stuff the module system that we
are you know a module system for the
Java platform doesn't need to be most
sophisticated because most applications
don't need that amount of sophistication
at the same time a module system to
modularize the platform itself needs
some things that systems like OS tree I
don't provide so the the plant the plant
is to be able to support osgi on top of
objects aw and this is this is the the
Penrose project that i mentioned on on
the slide full of urls where they're
looking at in fact there's nobbut over
there they're looking at ways to make
sure that I know I resolver can hook up
the jigsaw and so that you can have an
osgi bundle that expresses dependences
on things that are actually wind up
being jigsaw models at runtime you could
have an osgi bundle that says you know
requires you know java TLS at some
version and and everything gets licked
up in the right way so no we're not
we're not trying to replace any of that
because well there's no reason to if you
need that there's there's a great
existing framework called osgi that you
can use we're doing some some
lower-level plumbing that will be able
to support osgi and also also support
applications that are simpler than
application servers and I des which most
applications are
libraries called if we thought about
handling native libraries for jni well
since we've used it to modular as the
jdk yes we have dealt with native code
jamin file can have native code in it it
can have native commands resources other
stuff so yeah that's that all works
there there are some tricky things that
for now we've just we've decided not to
try to deal with for example we had some
use cases for a while we're there one
module the jdk had native code and that
native library needed to link at the
native level to an Esso or dll from
another one of the JD case modules and
it's really hard to make that work in a
highly structured way so we wound up
cheating and but you know at a high
level if you have you can have a module
we can have native code as long as that
native code is is only going to depend
on stuff that it will it can expect to
find in the operating system then it
should just work
no so if a module has native code in it
then it's for one platform and nabol and
it will have wait we haven't we haven't
quite got this into the metadata yet but
it'll there we may be data in the in the
description of the module saying that
this is for you know linux x64 or
whatever well it's a design it you know
it's a design choice we could have we
could have fat modules we could have
been modules you know I'd love to hear
data arguing one way or another we've
we've we've kind of by default chosen
the thin module model for now because it
also aligns most naturally with native
packaging systems but if someone can
make a compelling case for fat Java
native modules you know maybe we should
do that the thing of the thing about fat
modules is that if you for a widely
ported platform like Java it's hard to
know where to stop right I know you know
that mac OS Mac OS has had at various
times fat packages universal binary
swear you had both a powerpc and an X 80
x 86 native code in the same thing and
that was handy but in the in the
constrained world of Mac OS it was
either RPC or x86 and you didn't have to
worry about some other choice in in Java
which is ported to you know 20-plus
different native Native architectures
you could you could chip a fat module
that has native code 43 and then some
user asks for or you to port that to you
know architecture number four now do you
update that same module and force all
your other customers to upgrade or do
you provide a new module you know with
it with a with a different qualified
name that has the same prefix different
suffix or whatever so that existing
customers using the old one aren't
affected you know its policy issues like
that that make it cloudy
when you express a dependency on a
module that is there basically an alias
the results to the right runtime version
of that native punch underlying need a
module because you don't want to there
will be eventually yeah this is it this
is one of the straightforward design
issues that we did need to work out
early on so we haven't but we actually
have an Chris Hegarty has is working on
some code to get the metadata into the
module descriptor and work out the file
naming convention so that this will make
sense and yeah the right thing would
happen it's not that that is not rocket
science and those other stuff is rocket
science but that was not yeah
so
there are
so however if if their dependence on two
versions how will how will it resolve
will it won't they won't yeah it's an
error yes it will refuse to configure an
application if its mantra graph would
have multiple versions at the same of a
models with the same name yes yeah it
turns out to simplify so much both in
the concept or conceptual model in the
implementation to do that that that's
that's been a design choice that that we
haven't haven't thought that haven't
been motivated to question
where files web modules ask my Keith
yeah I'm I can I've had some
conversations about this whether a war
file winds up being as a file full of j
mods or or there's some higher level
packaging thing you know TBD but yeah
yeah no I maybe I I think that's all
straight forward to work out that's
that's a ways down the road because
we're talking about ee 9 which will be
after SC 9 but you know it's definitely
a critical use case that will work out
and make sure there's a good story
yeah yep
the Orioles be customizable and
extensible
we'll modules be customizable well it is
if you have its original contents right
it's am it's a collection of classes and
resources they and maybe some native
code that you compiled is it is a module
itself a thing that's extensible in the
way a class is extensible no no though
the the algebra of composing modules is
much simpler than the algebra of
composing classes and that's a good
thing yeah
no there there there there already is
support for four simple range
comparisons it's not as rich as for
example OSGi is but you know what's
there now is just a prototype it will
probably get somewhat richer
yeah I'm dead inside is very cold
these
would that be the recommended
great
well that gets into deep deep policy
issues you know I think they're there
are I there are several different sets
of best practices around version you
know ranges that I've seen we're in the
jigsaw prototype so far we're trying to
take the tack of not not wiring in any
particular one of those but rather
supporting you know whatever convention
you to you you would like to use
bringing format this bill
yes yeah yes version strings are that
they're they they are or will be
specified in enough detail so that there
is a total order of them you know much
in the same way that if you look at the
Debian policy manual or the equivalent
thing for for rpms you'll find a
definition of how to take a version
string tokenize it and compare two
different ones you know what we used
what we use today it in is is a slight
ripoff of the Debian algorithm so yet
there will be a total ordering but at
least you know so far we haven't seen a
need to mandate that you know thou shalt
have you know only four things in there
they all have to be numbers and this one
means that this one means the other
thing because you know different
organizations have different ideas right
you know I know there you know a lot of
people do use the three segments like
the semantic versioning model and you
know that and that can work really well
but other organizations have have
different models at Oracle I was amused
to learn as when I became an employee of
the company that most Oracle software
uses version strains with five segments
and and and ordering on them is kind of
funny in the third segment it's either
one or two toys and what the third
segment means is which version of the
database connection protocol the product
requires yeah and you know i'm sure most
of this goes back to you know 1978 or
something but they're in yet wait a a
model system that's going to be used far
and wide you cannot dictate that thou
shalt you know have just this new one
particular fixed semantics
the
just
which build part of the
one significant
fuck
yeah we thought it a little bit about
your having a separate build number axis
in the version string that you know
that's probably going to be necessary
it's certainly something that we be used
in jdk builds for 15 years and also
we've we've talked we've thought a
little bit about the maven concept of
snapshot i'm not sure that's exactly the
right concept but definitely something
along those lines so that if you if
you've got what's essentially a
development build that's not not going
to be shipped to customers or publish
publish on the web except for developers
you want to be able to say give me the
latest you know line of this thing
that's in development and then just
update it whenever it updates rather
than requiring a brand-new version
number you actually believe in jdk jars
into those
35 or whatever remember humans
separate cars actually yes we actually
did and they're not jars their third
dream odds you know yep any benefit
having an intermediate java jdk version
that only has split jars you know what I
playing this in concert out of the jar
instead of keeping server we have today
is there any benefit to applying the
same concept at the jar level maybe like
maybe do that in in Java 8 since we
won't have an actual module system that
would actually slow things down that
would slow things down you know the
reason rgr is one giant jar file is that
it's reasonably straightforward to
optimize the bootstrap class footer in
the DM to load things from one jar file
really fast as soon as you have multiple
jar files you have a whole sequence of
jar indexes and you either have to have
to do a big merge that takes a lot of
time up front or maybe you can cash it
but that and that gets tricky or you
have to consult each index in sequence
according to the according to the order
on the classpath and that isn't very
much fun either but I think for for the
inter in in the Java 8 time frame the
profiles answer will be you know that
the set of profiles three or four that
give you so you know some smaller
configurations of the JRE will go a long
way and they'll still have an art you
are inside them you're just splitting up
into into multiple jar files is it
wouldn't be that useful and it would be
a what's the phrase a a tempting
nuisance you know it would 10 people
that just oh well I'll just take that
jar file out and see if it still works
and then they'll deploy it and then
something will go wrong and they'll ask
for support on it and then you have a
painful conversation with a with an
unhappy customer
you mention the service this concept but
generally right ah true can I describe
that a little bit more the services
concept is is is pretty simple we we
want the existing Java util service
loader class to have a sensible meaning
in in module mode and that and then we
have syntax in the module declaration
where you can say this module it
provides service foo where food is the
service interface or abstract class you
know with you know some class name bar
and if you can do that in a module that
provides a service a model that requires
a surface can say requires service food
and then as a you know as another part
of the resolution and configuration
process the resolver will go find all
these service declarations and
dependences and hook things up so that
when you go in and book service loader
it will have all that information and
can quickly find all of the providers in
a given service you know unlike osgi
it's not it's not dynamic services can't
come and go there either there they
aren't but you know for many
applications that's perfectly adequate
going to show them
do we can show some code oh that's a
good but that's only something you put
in a jar file there's J mod files are
not jar files
there's there is no madam so this is
here here's the here's the actual base
module declaration so this jdk dodd base
requires local stock requires optional
requires a bunch of services these are
all things that it will use if they're
if they're around and here's the stuff
at exports and this goes on for a while
of course because while the base module
has about about 2,000 classes in it yeah
can you show something that provides oh
it's right either doug is further down
keep reading work yes provides service
security provider with that stuff and
that's not a service that's just an
alias so it's it's it's pretty simple
there there are some hairy subtleties in
and how you actually resolve things Paul
sandoz on the team has has cleaned that
up a lot it works much more intuitively
now than it did at the beginning
by their business and in fact with us
the target field service road effect
because it's birthday event and takes
all
Shaw and other
converter in and extended to support
service
provides service
yeah and among the cleanups we've had to
do sort of across the platforms find all
the places in jax p and Jax being jax-ws
and it's not the other thing that have
essentially their own copies of
java.util service loader because they
were using the meta and convention
before the service letter class existed
and going and changing those and
changing those in some cases will
actually require doing JCP maintenance
reviews because we have to tweak the
spec a little bit and you know but it's
just me so some of the items on the long
list of things we have to do to get this
whole modular ization project finished
sorry is it possible to do dynamic vote
I reload a module after the BM has
started ya know if you need to do that
then the right tool is osgi now having
said that I you know I could imagine
having some some kind of development
mode where you know you're working on a
mon on an application you've got the
module graph it's not changing you want
to recompile one class in a module it
and and have that to a hot redeploy for
development purposes I think that could
make that can make sense I I would not
want to do that in production i noticed
the you know some people like living on
the edge and doing you know hot
redeploys of single classes and changing
method definitions and production
systems that's always strike has always
struck me as completely insane
one of you you decide
get the plan
God
we don't have a specific plan as yet you
know what would love to hear ideas about
that we've talked to some folks in the
Maven community you know just had
preliminary conversations you know we're
not you know we're not trying to
displace maven but obviously we are
proposing a new format for module
content it would be great if there if we
could work out some you know some way
forward such the people who use maven
today for jar files can use them for 4j
mods in the future
but it's also the point where it becomes
your responsibility
step there is no support for enjoying
some del yeah stop to be quite right
yeah I maven this is its fundamental you
can think of it as like a build time
module system and and that's as far as
it goes which is very useful but but not
the whole story do you see a kind of
migration process to JSON you see a time
where G saw itself will typically be
used as a bill time module system where
we integrated Java CD version thereof
and not really and runtime basically
would still flashback we can you
basically cruise j mods up and then
convert the back to jars or wars because
you're using janja Larry yes so I
amongst the other migration tricks we've
come up with is the notion of a modular
jar file so a shame on file is is highly
compressed it's a custom format specific
to Java well jar files are also well
sort of their zip files with some
customizations but the jar files exist
and all our existing tool chains
understand them so the idea of a modular
jar file is well it's a regular jar file
you look the normal way you do today but
you also provide the the equivalent of
the module info the module declaration
is in a special place in meta in where
you would expect to find it so you so
you have a jar file which you can either
stick on a classpath he's in the normal
way or if you want to play the module
game you can install it into a mantra
library and this this will be you One
migration path so that it so that if
you're providing a library that other
people are using and some of your users
are still in classified stuff but some
of them want to do module stuff as long
as you're not trying to
native code which most people aren't you
can divide a modular jar file and that
will satisfy both sets of users so
there's no need to do some hacky
conversion of producing at a mod and
then you know down rubbing into a jar
files you know just use this mantra jar
file format
one John all
so we'll we'll dividing the JDK up and
do in too many modules effects startup
time yes it will affect startup time it
will improve it it will it will improve
it because because the act the month the
process of installing a module is where
we can do a bunch of optimization work
during that process so the vm when it
when the modular vm is running it's not
it's not pulling classes out of jail on
files a module library can have a highly
optimized internal format you know this
is why we have Berkeley to be in there
for example so that classes can be found
and loaded very very efficiently much
more efficiently than out of a out of a
jar file so no performance that way is
is not a problem that should only get
better make sense
it's all one people
jari an infant and that was just
everything and then a lot of apps
what you will
and now we are
yes so it's it since since since you
know at least in the jigsaw prototype
it's not it's not a dynamic module
system when you when you and when you
install an application module everything
is is resolving configured at that time
there's there's you know that the the
impact at runtime is extremely low you
look up in a bee tree for a class you
find it you get it and you're done yeah
it's exactly it's like a linker you
don't when you start at modularized app
you don't load all the modules they're
still loaded up on demand just just and
the classes within them are loaded on
demand but there's static configuration
data in an optimized forum that lets all
that load and go very efficiently
exactly a module does not have a life
cycle it's it's it's much more it's much
more like a class it it gets loaded it
exists maybe it gets unloaded but if so
that's completely transparent to the
application there's no explicit notion
of an unload event or anything like that
the whole thing
jaja the tool ja Rule
the option is an option we extended our
tool so that you can give a module name
and very name so that it will generate
module in supporting their energy our
existing jharkhand become a modular job
because you're basically run under
jeremy yourself if
those that's nothing
injection
byte code injection or run time yep that
will still be supported yep and in it
you know it's it's not it's a little bit
tricky but it's actually you know if I'm
at a level we're still just loading
classes with class loaders so
yeah yes
yeah well you can only inject a module
in a sense that you can create a new sub
graph a new module sub graph for a
container like thing but you can't it
you can't take an existing you know a
running app with its configuration and
just go insert something into its
Marshall graph that configuration space
well so you know flee roughly speaking
speaking of it the idea for container
support is is the ATO you'll install the
app server you install the GlassFish
root module and it solves a bunch of
other stuff you start up glassfish and
it has the GlassFish molecule graph that
was computed at install time it doesn't
change you know you deploy a web app
into it glassfish uses the reflective
facility the module system to go create
a subgraph a new a new module sub graph
that is kind of dynamic right it's just
for that web app it can refer to models
in glassfish if it needs to but modules
and glassfish can't refer to any of
those that sub graph exists for the life
of that web app when that web app if and
when that a web app is under ployed it
goes away that's that's that's as far as
we've seen the Oviatt that's the only
lonely level of dynamism required having
the ability to you know deep detailed
surgery on a running module graph you
know if you need that I was Joey has
already figured it out
no not exactly 40 s guy and this is what
they're working on in penrose the idea
is to figure out what what hooks does an
osgi resolver need so that it can it can
discover from the platform module system
what models exist and how to sort of
serve surface them as as OS tree I
constructs osgi bundles as it were and
you know sort of had a fake them out a
little bit but make everything legs
still link up in the right way
yeah yeah that's how they have how
things like application servers you know
if somebody were to write you know a
write an ID from scratch maybe they were
choose to do it that way rather than you
know doing a custom thing like NetBeans
did or Australia like it cooks did but
you know that's not that's just not
that's not that general design space is
not something that were they were aiming
for the critical thing is to be able to
support app servers obviously beyond
that yeah so your examples you always
kind of had a single top level module
gifts to you can basically say you're in
modules and here's the main class entry
point that I want you to use no nothing
well the resolver is obviously general
and that you can say here's a set of
modules go resolve everything and we
have to support that for the compiler
because a compile-time Java Sea will be
confronted with some set of source file
is divided into modules and just needs
to resolve everything that doesn't
really care which one happens to have a
main method in it but in terms of
installing and configuring an
application well an application is is
something with an entry point larger
allocation
where you have an entry point but you've
got in optional modules you don't even
know what they are yet so you don't have
a top-level single module that you're
going to be able to call out all of the
other modules in which you want to be
able to say retire this up but over time
you may have optional modules that I
want to are you talking about the
install step or the launch step both
really and then you know if you have a
this application and then you say well
now I have a new module of my
application that i want you to add but I
don't necessarily want have to rewrite
my top level module to say there's a
right to oh sorry so your original top
level module needs to declare an
optional dependence on this other thing
so so so the you can use optional
dependences or even use services and
services might be what a better way to
decompose that sort of thing but
basically if you if you install an
application that that that declares
dependences on some services when you do
that install it will go it will get
linked up to any models that provide
those services of the of the appropriate
types if you then install another module
that provides you know yet another
instance of that same service then the
application will know about it from that
point forward and if you restart the
application that will see it service can
find all of them are by the first it can
you can't find all of them it's just the
service loader API you can you know you
get an iterator you you can June you
choose depending on how the provider is
structured you can take the first you
can look at them all whatever yeah
this one was at one by one of the
this one or that way a destructive
dependence no no we did we don't have
that but as as a side note we we are
appalled sandoz on the team has been
looking into replacing our original
homegrown fairly naive backtracking
resolver with a true SAT solver and that
would make it easier to support such
contra the constructs if we decide that
we need them you know the thing about
sat solvers is that well they're you
know they're solving an np-hard problems
there there's always have that potential
but you know potential degenerate
performance cases but they do seem to
work very well in practice politics I'm
an engineer not a politician I'm curious
about how much your resistance you have
because you're touching class voters and
the hall I mean you're going very deep
the Java fences and so I would imagine
this has not been an easy sale with it
no I yeah I don't consider that a
political question as it has it been
hard hard to sell this given that it's a
it's a deep deep change not really and I
think that's principally because we've
you know we've always promised and we
take it very seriously that in class
path modes stuff still has to work you
know with rare exception i mean if if
you have if you have an application that
goes and finds our DTR and opens it
explicitly you know sorry there's
nothing we can do to help you well
actually there is something but it's
really gross and we're not going to do
it but no I think everyone you know
certainly I've talked to you know the
benefits really seems worth the risk and
I think we have enough you know enough
testing infrastructure in place and and
enough we tend to get an awful lot of
early testing from a developer community
that you know I think we can be
reasonably confident the classpath mode
you win this all ships will will be
pretty darn good so if you use some you
can say
that's an open question probably
probably I hate to say it but probably
that's just one of those necessities
developers their own connections
davai so developers write their own
collections need some dis gunsights
that's a claim I haven't heard before
but I can imagine developers who think
they do outside oh yes so yes yes that
that's true completely I know and as I
said in the little Q&amp;amp;A we had after the
previous session Doug Lee is a very
special case and I know we need to I
know we need to support him no III know
there are millions of developers who
need to use Doug Lee's code I am also
highly confident that there are no java
developers including me were smartest
ugly when he ugly to 12am process no I
didn't say that I didn't say that you
know in class path mode we are probably
realistically just going to have to
leave it there in module mode I would
really rather not have avid exposed in
that way and with i mentioned mentioned
this idea at the end of the the previous
session you know one idea that was I
forget who suggested to me recently was
well hack given the utility of this
thing maybe we should just take the
essentials of Sun this gun safe and put
them in a new class javed outlying gun
safe and make sure that all the security
checking around that is absolutely
airtight and solve the problem that way
yes okay we have we have one customer
how much document
right now
how much documentation is available for
this right now I me of these questions
could be answered I don't know maybe
half of them you know where this is
still all very exploratory and prototype
II and you know it occasionally moves
forward and in big chunks on this page
you'll find there there are two
principal documents one is a
requirements document that's that's over
your over year old that was that we I
wrote by collecting together
requirements from from e.e folks and I
was GI folks and some Eclipse people and
you know a bunch of other stakeholders
and that's that's guided a lot of the
jigsaw prototype design there's also a
big picture document there which I wrote
back let's see last December which is in
need of updating and i hope to update it
in the next month or two they're also if
there's also a whole nother set their of
working documents for example there's
there's a document alex road which which
is the current specification of the
class file of the model declarations
syntax in a class file format other
docket there's a there's a thing that
John Gibbons wrote that explains the
module path convention the Java Sea uses
so you know it's not all highly highly
organized for for easy consumption but
it'll get there in the meantime it's
much more of a you know this is a
project that's that's moving along but
if you have questions you know jigsaw
dev at OpenJDK we'll do our best to
answer them or well you could you could
send me an email but you know if I'm
going to answer a question I prefer to
do it in public so that other people can
find the answer yeah
and
fine
you will get something so when you load
a service we ask for a service provider
you will get something at runtime that
you don't necessarily know of at well
yeah that's the whole point of a service
no it's not summer to import package you
know front from which bundle who knows
but an abstract switch physical the
require service is doubly abstracted
because you neither know what's
implementation you are going to get
Norwich our core module that
implementation is going to come from
so what happens to existing code that
does its own custom class loaders and
stuff for the most part it'll still work
if you if you have code today that that
sub classes or directly instantiates URL
class loader and has a your classpath
and pulls classes out of a jar file
somewhere or downloads them over the
network it still work the context within
to which their load there will be a
little different so you might have take
care there and make sure that whatever
module your whatever effective module
they wind up in it requires everything
that they might need but that's
reasonably straightforward yeah
after
applications we use for testing well we
we run the j ck the java compatibility
kit there's a couple hundred thousand
tests we have a bunch of internal tests
inside oracle we have the regression
suite with you know oracle has a huge
software stack we run that we we we run
we run you know it we have a regular we
have a thing called big apps testing
where we run large bodies of Java code
from you know other important you know
Java oriented companies you could
imagine all the important application
servers yes we do run them from time to
time and that's that's part of the whole
qualification process
yep
we're officially out of time last
parting shot are we done we're done okay
thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>