<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>What's New in JSF: A Complete Tour of JSF 2.2 | Coder Coacher - Coaching Coders</title><meta content="What's New in JSF: A Complete Tour of JSF 2.2 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>What's New in JSF: A Complete Tour of JSF 2.2</b></h2><h5 class="post__date">2013-02-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/FwPySW-lz8A" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Ed Burns and I'm going to
talk to you about the state of JSF two
point two we're gonna go through the
first two points pretty quickly so we
can get to the fun stuff the actual code
and features first though I also want to
make a plug for my colleague Roger
Keynes talk this afternoon at 3:55 over
in the mission whoom techniques for
responsive real-time web UIs so if you
haven't booked that in schedule builder
that's worth taking a look at so its JSF
really that old yes it is job this is a
slide from the Java one 2001
technical keynote where we introduced
JSF and you know we're still the reason
it has stuck around is how could JSF
still be relevant well abstractions
indoor and JSF really is a heart
just a simple mist an abstraction so we
still need to build web apps that are
quick to build maintainable localizable
accessible secure device independent
good-looking and hopefully if you build
them right or fun to use and you know
the underlying technologies that have
been underneath JSF and the technologies
that are sitting on the browser side
those have changed somewhat but you
still have the abstraction of components
and delivering them and collecting them
in pages and views and directing users
through flows of these things so those
concepts have stuck around JSF is still
in wide use it's been used on every
continent including Antarctica we've
have an unofficial usage tracker at real
world JSF links to I would update the
old one but bit ly links are now
immutable it used to not be but now
they're immutable so that's the one you
want to go to if you want to see what's
up and who's using it this is the slide
that people really I think I want to
make sure everyone sees because this
year there's been a lot of talk about
really leveraging the capabilities the
browser's have come to have
with html5 and we can finally say uh the
browsers are uniformly capable of
handling a substantial amount of the
user interface logic in fact almost all
of these interface logic in the client
so what we're trying to deliver to you
with Java EE is the capability to move
this slider or wherever you like you
know you can move it and have all the UI
state in the client with just restful
services on the server side or you could
have all the UI state on the server and
have all the stateful stuff happening
like with JSF and the point that JSF is
trying to do is we're separating the
component semantics from rendering and
we allow the components to own their
little patch of the UI so that's been
something that's been in JSF for forever
and this well-defined lifecycle of
inversion of control where the
components do their own thing and you
don't need to know what the other
components on the page are doing unless
you want to we upgraded jsr 344 which is
the spec for JSF 2.2 to JCP 2.8 and
there's a number of ways to get involved
in track process so I'm gonna say this
at the beginning so we can get it out of
the way we also have a public twitter
account if you don't want to this is
quite a commitment if you want to like
dive into this level of detail you can
do that but if you just want to get a
notification every so often hey there's
a new draft available maybe take a look
at it you can follow JSF underscore spec
on Twitter and whenever I put a new
version of the spec out I'll send a
tweet on that things there's like you
know one tweet every month not a not
overwhelming at all we also have a
public issue tracker so you can file
your issues and we can look at them and
we at the beginning of JSF 2.2 since
this is the community access part of the
presentation we had a little voting
scheme where we had a poll and we ran it
for maybe two weeks and everyone could
vote for their top five issues and then
we said okay these are the issues we're
going to focus on for JSF 2.2
with that we've built the schedule out
and we've been trying to track it as
best we can and updating the schedule as
we go along to take a look and review
the API yourself you can go to maven
java.net and just type in the group ID
Java X phases API and the actually the
group ID is Java X dot faces the
artefact ID is Java X faces API the
version of course is to point to
snapshot and you can look at the Javadoc
jar which will have all not just the
Java doc but all of the things of the
spec the render kit Doc's the jas Doc's
all of the different parts of JSF are in
this jar and we push that out nightly in
fact
where's JSF in its lifecycle well the
big release we did was jsr 314 that was
JSF 2.0 and we are not going to be
having any more major blockbuster
releases like that where we're going to
so I've introduced a whole new
subsystems and and really change things
around because we've found that JSF fits
well on the in the kind of place where
you have state that resides on the
server and you have components and you
have people that are page developers and
you want to give them sets of components
and let them compose their pages with
some kind of toolkit widgets set type
thing the nice part of that is there's
nothing excluding you from having some
of those components deliver the html5
capabilities and you know you can mix
and match you can have both kinds of
things happening in your app at the same
time you know you don't have to go all
one and say we're going to have our app
be entirely in the client with restful
services you know you can have a part of
your app be JSF two based and you can
have another part of your app be you
know avatar based that and migrate
things over time so we've the Java
platform has always been about evolving
gradually and this the way we're trying
to bring html5 capabilities to you is is
to let you migrate to them grad
so you can continue to use JSF and as
new technologies appear you can you
adopt those also we are hoping to hit
public review draft by December of this
year
and JCP 2.8 has introduced a number of
new requirements that actually put a
time limit on things but we are within
the time limit of having to have a
renewal ballot you have to have less
than a year between when you have your
early draft review and when you have
your public review we published an early
draft review in November of 2011 and so
our public review if we have it out in
December early December of actually I
was wrong I said November it says right
there early draft review published on 8
December so if we get it out within a
year of that then we don't need to do
the JCP renewal ballot and everything
should just be okay this blog entry here
is Linda D Michele's blog entry where
she announced the change in focus for
Java EE 7 to instead of has anyone seen
this remember is aware of the change in
focus for Java EE 7 ok I'll state it
real quick
prior to this refocus Java EE 7 was very
much talked about as the cloud ee 7 or
the cloudy ear Elise and after the
refocus we've said well we don't have
enough understanding and cross vendor
support yet for all the different cloud
vendors to really say we can solve this
problem authoritative lis so we narrowed
the focus to deliver html5 type
technology so that's why you'll see JSON
and jax-rs and WebSocket being put in
there and JSF 2.2 as well has some html5
capabilities that I'll be showing here
and the cloud stuff will now go into e 8
so the JSF story fits into that we're
hoping to have Java EE 7 complete in
spring of 2013 we will be releasing JSF
2.2 along with that ee 7 schedule
and one thing we've always done with JSF
who armed sorry with JSF releases is
depend only on services provided by one
version less in the container so you'll
still be able to run JSF 2.2 on neee six
container you'll be able to take the
implementation and drop it in because
we're not gonna place any hard
requirements on any parts of other
things of ee7 the only thing that you
might miss out on is we have some
features that are on the table that
leverage JSON and through the JSON API
that's part of EE seven so if you take a
JSF release and drop it on to an EE six
container then you won't have that API
there unless you pull that back as well
and if you're that advanced at doing
stuff this is kind of ala carte
mix-and-match then either you have a
very kind IT department or you're kind
of willing to take some more risk on
your own hands all right any questions
about the schedule and scope and such I
just wanted to ask when I tell you that
JSF 2 was the last big release of JSF
and we're not going to rewrite anything
and change the focus and say now JSF
also does 100% client-side does anyone
bothered by that approach or yeah okay
all right and so I'm a believer in
knowing what things are good for and not
trying to push things too much all into
one bucket so that's what we're trying
to do just let things be where they
belong and add new things as it makes
sense so I created some bit ly links for
a previous status meeting of this kind
early earlier in September so if you
click on any of these bit ly links that
I'll be showing you here they will take
you to the issue tracker query that
contains those issues and you can track
or take a look at the status you know
the to the commit level of what's been
done and how much time has been put in
on each issue and such maybe
html5 friendly markup support
I call it html5 friendly because there's
nothing really specifically limited to
html5 about this the idea is why would
you want to have a server-side framework
in the first place well one reason is
because you want to create new tags and
you don't want to wait for your browser
to evolve so what are you going to do
you're going to have the ability to sort
of do some kind of processing on the
server side that makes it so the page
author can use these new tags even the
tags that the browser doesn't understand
and then it's processed on the server
side and what gets served down to the
browser is different than what was
actually in the page so that's what any
server-side templating type technology
will do that with html5 now we have a
bunch of new elements right and so we
could either wait for component vendors
or kind of make corresponding JSF
components that fit that html5 model or
we could just say why don't we build the
new system that lets you write regular
HTML and just kind of put a little bit
of sprinkling of JSF on top of it and
then the HTML that you write will be
real proper HTML not processed on the
server side as far as it comes to
rendering but rather only processed on
the server side as far as it comes to
processing on the submission of the data
and that's where the JSF request
processing lifecycle really has its
strengths the validation conversion type
safety the e/l model interaction all of
those kinds of things
by definition HTML doesn't say anything
about that and never has and never will
so it's that's what the essence of that
particular feature is then anyone come
to my session on Monday with David
Schneider about faceless flows anyone
here there ok so that's good that means
I won't be reinventing or see
a lot of content most of you won't be
seeing duplicate content the phases
flows feature is about collecting
modules of related functionality
together and enabling you to build your
application by composing modules of
functionality at a higher level of
granularity than just the simple page so
all the pages that deal with browsing
and inventory can be collected together
into a flow and all the pages that deal
with checking out from that inventory
are in another flow and all the pages
that deal with for example user account
management can be bundled together and
once you have the ability to group these
things together you can reason at a
higher level and also do more reuse so I
those are probably the biggest of the
new features cross-site request forgery
protection that was one that was
supposed to go into JSF 2.1 but we ran
out of time loading facelets via the
resource handler that is getting more
and more specific but that's the ability
to load not just the CSS and and scripts
and images the so called assets through
the resource handler but also the
facelet pages themselves we we are
adding one component the file upload
component I'll explain why it took so
long and multi templating that's another
of the big features but I'm not going to
talk about too much about it today
because we've made not as much progress
on the actual implementation of that
everything I'm showing you demo wise is
already done and implemented in the
reference implementation it's not like
totally production quality yet but it's
usable and you can try it and test it
out so let's get back to the basics JSF
views are written in a view declaration
language and the standard facelet vdl is
really an XML application that contains
two kinds of elements either HTML markup
or JSF components and the HTML markup
kind of things are just passed straight
through to the browser without any
processing on the server side JSF
components take some action on the
server during the lifecycle so your page
is kind of this collection of template
text and JSF components but when the
life cycle runs it takes that page and
produces this tree of UI components and
the template text is kind of sort of
sparkled around all of it they're
scattered around all of it but the
browser is what assembles it all
together for the user and on the
rendering of these things each of these
components can have an e L expression
that points to the Model T R and it can
point anywhere you would like in the
Model T R and on the render the e L
expressions are evaluated as a get to
get what they show and on post the e L
expressions are evaluated as left-hand
sides
L values to set what the user typed in
so before JSF 2.2 you had this notion of
the tags we're hiding the complexity of
the underlying HTML script and CSS and
images and so they did this through the
concept of a renderer and the renderer
had two things two to two jobs and code
the markup to the browser and decode
whatever is sent back from the browser
so with this you know you could use you
weren't limited by what the browser had
you could say this is these are examples
from primefaces give me a color picker
and you know have its value be that or
give me a calendar the the reason for
this is if you're missing a feature in
the browser then you would write a JSF
component to fill that gap the flipside
is with JSF 2.2 you can have pure HTML
script CSS images in the JSF page and
the renderer handles the DES code as
before but the end code is really just
what the page author is written so
that's that lets you get the best of
both worlds you're leveraging the
strengths of the JSF lifecycle on the
request processing but you're leveraging
the expressiveness of HTML 5 and more
importantly probably leveraging the
cable
of your page designer who prefers to
work in that way you know the page
designer would would bristle when you
tell them okay here's the color picker
and you just put it in the page and it
will work or like well I would like to
establish the brand of the color picker
and make it fit with the rest of the
things I would like and you know the
tags might provide some customized
ability but that's not how the HTML
designer likes new things the same is
true with the calendar well because
html5 amusing this example has now added
some new input types you know you were
just using the ones from the browser and
the browser would you know open itself
up to being styled through the usual
conventions that a page designer would
like to work with so the only thing
that's JSF specific about this is this
JSF : value attribute and when the
facelet processing comes along and says
ah I see that this element which
otherwise would be considered a simple
pass through element has one of the
attributes from this namespace here well
I'm going to treat it as a special kind
of thing and make take the necessary
action on the server side so that it
works so here if you have a new feature
in the browser but you don't have a JSF
component that uses that feature you
would just use this new feature which is
called pass-through elements so let's
take a demo of that
okay now these are incredibly on flashy
because these demos are actually just
taken from the automated test suite that
we did as we're developing the reference
implementation the first one I'll show
is leveraging the keygen element which
is a new thing in html5 so you can
choose a key key to be generated you
know a public key cryptography type
thing and if you click it you'll see the
browser said I'm generating a key and
then it's sent on and okay this
particular demo is just showing the key
there well it's not very impressive to
look at but what it does get the point
across of what this feature is all about
so let's take a look at the source
behind that here we are
so here you can see that this is just a
regular HTML form that has a couple of
these special attributes on it and in
here this is a regular HTML button that
has a couple of these things on them
most important for us we're saying you
know even though this is a regular HTML
button I sure would like to have the
ability to call the JSF action that I'm
usually doing with these kinds of things
oh sure
thank you what a rookie mistake you'd
think I wasn't doing this for very long
okay is that better okay so this is a
plain old HTML button but it happens to
have a couple of these attributes so we
flag it and turn it into an actual
command button on the server side so
what it turns out is we've established a
mapping between the element name plus
some combination of zero or more
attributes to say when when we see this
translate it into one of the h : tags on
the server side and for those things
where there isn't the match we've
defined a number of special-purpose
renderers that can serve the needs so
for example here there is no an analogue
in the HTML basic component library for
this key Jane key gen element but yet we
still want to be able to use it so if we
click on the setter here this is just a
regular JSF managed bean
oh yeah it's JSF managed bean the reason
it's a JSF managed bean rather than a
CDI bean which it should be is because
of this automated test we would like to
have as much of our capabilities as
possible running on tom plain old Tomcat
so we've written this test there's a
whole big section of the tests that we
have where we choose not to use any CDI
features just so we can run them all
over the place but really I'd recommend
you not using these anymore in fact the
Java X phases bean
package I'll mention this now let me
zoom out there we are if you were to
download the spec like I showed you and
we're to look at the Java X faces beam
thing you'll see now we're gonna be
deprecating that in a future release so
another nice thing about the if you look
at the spec directly from java.net you
get all these color codings
that tell you you know which was added
which features were added in this
release so it lets you really quickly
look at say oh well there's changes in a
lot of packages but there's this whole
new flow package oh look at that you
know what we'll talk more about that in
detail but I just wanted to show this so
you can get familiar with how to
evaluate the spec if you want to just
see what's new so going back to managed
bean this is my cue to tell you all that
you should not be using these because
they will be going away
another feature this is a smaller one
but it's kind of important because
there's a lot of stack overflow traffic
on it
does anyone here use stack overflow okay
they have like 700 pages of JSF
questions on there so and we're hoping
to address a lot of them and I really
enjoy being able to say oh how we fixed
this one on there now because people are
like you know it's a sense of completion
so any view scoped is one of these
things where people would say I'd like
to move my stuff to CDI but I can't do
it all the way because view scope
doesn't work because there's no CDI
based view scoped well now we finally
added one so in the flow package there
is a view scope thing and even though
it's an annotation that is defined in
the JSF spec it's entirely intend
dependent on CDI so don't be dismayed
when you say Java X faces flow at flow
add view scoped and think well this is
this really CDI yes it is I'm trying to
get across
the point that although CDI is defined
at the platform level each of the
component EE specs that use CDI can use
it in their own way
so because this concept of view scoped
is so tightly bound to JSF we're gonna
define this particular CDI scope in the
JSF spec so there are there will be
other specs in EE that also use CDI but
define their own scopes that only makes
sense in the context of using that thing
okay so that's I got a little
sidetracked from showing this demo here
with the key gen so this is just a
regular JSF managed bean and we have a
new element in html5 and I'd like to use
it but I don't have a component that
does that so you know what do I do you
use this pass-through element feature
here so let me just load it again and
show the king coming across directly a
button and submit this guy again and
there's my breakpoint set and you see
this is the the public key thing for us
being set in a value expression like you
normally would expect so if you already
have familiarity with doing things on
the server side and you have page
designers that like to do html5 then
this feature lets you bring those two
strengths together another example from
this demo also is the input I'm sorry I
know this complex one so let me look at
the page for that one complex and I'll
zoom it up for you
okay so here we have input type equals
text input type equals tell input type
equals email and also the progress
element and these things are all new the
these different input types are new in
html5 and the progress element is new
also so this demo does is shows how you
can use these things together also it's
very handy too you can ajaxify these
things as though they were normal JSF
components so the F : Ajax tag and its
corresponding JavaScript function are
something we added in JSF 2.0 and
they're very easy fuse and Ajax is all
about responsiveness and accessing the
lifecycle doing partial updates to the
server for the purpose of updating
little pieces of the page and with this
feature you can show combining old
fashioned HTML with the traditional way
of doing Ajax in JSF so here if we type
in a name edie and you see ajax updated
this and it updated the progress element
and so if we type an email in here or
something it's not an email rather
actually I'll just type this and type
out oops I press the ctrl tab key that's
the wrong one gave me a valid a browser
validation error that should say if I
mouse over here and again there it is
please enter an email address that's
nothing that's coming straight from the
browser there's nothing there's no
validator you can see on this page
that's a browser feature of html5 so and
the progress meter gets updated just by
the fact that F : Ajax and the execute
phase we're running the lifecycle on
this component here and we're rerender
in the progress bar so as we take action
on each one we'll be sending an ajax
request and updating the progress okay
so that's that feature ah that's funny I
think I just made a mistake if I
accidentally I've observed this there
sometimes if i zoom using the Mac OS
native zoom feature and then go into the
VM things get funny okay okay the next
one faces flows so applications large
applications have navigation challenges
basically before faces flows application
are just one large flow where everything
is visible and there's no logical
partitioning there's no notion of
limited object scoping there's nothing
in the absence of flows or CDI
conversation scope nothing that spans
several pages but is less than the
session everything is a page the only
way to invoke application logic is to
tie it directly to a UI component that
the user activates if you wanted to
activate application logic based on a
transition or some other kind of thing
that's not in the page you couldn't do
that so we have this faceless flows
concept and as we all know standards are
first standardizing not innovating so
we're not inventing anything here we'll
simply looking at the prior art of from
these places ADF tasks flows spring web
flow Apache my faces Cody are the three
big ones that we've looked at to inspire
this feature you can think of a flow
like a Java method you can call the flow
from any place in the application that
you want to that you've defined it to be
valid to call they have a single entry
point they have input parameters and
return values they have a well-defined
interface contract which hides the
internal implementation details we've
added a new scope it's an L implicit
object called faces flow scope so this
scope
comes active whenever you enter this
current flow and it goes away when you
leave that flow we've also added a new
flow scoped CDI annotation which will
automatically activate itself when the
scope is entered and go away when the
scope is exited and this one is really
important because it actually helps you
to define the flow graph itself and this
is the flow graph piece of the
presentation navigation is no longer
just between pages it's between flow
nodes and there are six different flow
node types view method call switch flow
call and flow return and these are the
ones that we've kind of found as the
union of node types when we looked at
ADF swing wrap flow and my face is cody
they all had these six so we've kind of
boiled it down to that and in talking to
the people who work with these
technologies the experts and the expert
group I would ask them allow are you
sure that we need just those six you
know and they're like you know we've
seen so many apps and we thought about
maybe having a custom node type feature
but there really has never been a need
for it so I'll trust the experts when
they say through the thousands of apps
that have been built on their
technologies ok I believe it you know
so we'll just we'll take these and run
with it and if we need to add more later
you know we can have another version of
the spec that does that but I I'm pretty
confident that this will serve most
people's needs flow wise so the runtime
representation of the flow is the
important thing how you author it and
how it's persisted you know in the file
system is in my opinion less important
so the runtime representation we have a
new class Java X faces flow these things
once they're placed into service they
are immutable so this version of the
spec does not anticipate
creating flows or modifying flows
dynamically once they've been placed
into service it makes things a lot of
means a lot
here to understand when you can make
that distinction and say flows are
immutable so flow the flow handler is
the class that lets you you know create
flows and add them to the site it
depends on this new feature client
window client window is something we
really got from my face is Cody and it's
something JSF has been lacking forever
and that is the ability to have
something that maps to the browser view
so if you have multiple tabs or multiple
browser windows each one of those things
will finally now have a client window
that's associated with it and whatever
you see in that browser tab or browser
window will stick with that client
window and that feature is fundamentally
important when doing phases flows
especially when you have nested flows or
when you have a flow that wants to do a
sub flow that is kind of modal and might
block and present prevent you from going
anywhere else until you complete that
sub flow having client windows essential
for that the authoring experience for
flows is still under discussion you know
I really would like to not introduce any
new XML to the spec although the current
prototype that we have is using XML I
really think the right thing to do is to
have a builder or some kind of fluent
API for it and that's what I'll show
here so those of you that went to the
talk on Monday you'll see that this is
very different from just what we did on
Monday because I in talking to other
folks at JavaOne here getting inspired
by that conference energy that we all
come for that made me kind of want to
rewrite things and make them better so
the view node represents the page within
the flow it's what we already know it's
any JSF page is one of these things or
can be one of these things the method
call node lets us invoke logic from the
flow graph so it decouples the
invocation of logic from the UI
component you have a method identified
by an email expression and an outcome
from the method or you can actually in
the flow definition define
what is the default outcome so basically
it's a method that tells you where to go
next the switch node is like a Java
switch statement it's similar to a
method call but instead of just being
one you have a list of them and the it's
gone you go down the list and the first
one that evaluates to true is where you
will go next and of course you have a
default outcome as well there flow call
node is where you you if you navigate to
this thing you're saying okay I want to
leave this flow and go to a different
flow or I want to leave this flow and go
out of the flow entirely into the
unbounded flow of the application so
this is where you would define the
output parameters that you're passing
when you go somewhere else and what
return value you're going to send out
when you leave actually did I get that
wrong
yeah the flow call node this is where
you define the parameters you're passing
the flow over turn node is I was wrong
returns to the calling flow and this is
this is where you identify the return
values sorry about that I mean okay and
the flow definition this is the key part
it contains the name of the flow
identifies where it starts identifies
what the input parameters are and the
optional initializer and finalizar so
this is what I was thinking would be a
better way to define it than just
XML so this beat this does two things
here this is a J a CDI managed bean
declared to be in flow scoped and when
you do that you have to declare the
identifier of the flow that you are a
part of you can have many different
beans flow scoped beans inside the same
flow that belonged to it but only one of
them will have this produces method on
it that is where the flow gets defined
so here you'll get passed a flow builder
and here's where you can define the
start node and the return and the
switch node all of these other kinds of
things and this is completely you know
up for grabs or as far as how we're
going to design this the other
alternative is to have you know an
xml-based syntax which I will show you
when we get to the demo but I think that
a Java based solution is probably better
for this point in time so here we go to
the demo okay all right let me close
this one out
okay so here is the simple and again
this is just an automated test so it
doesn't look fancy so this one we enter
flow a and we go a few steps forward and
then we call flow B and now when we call
from flow a to flow B we pass some
parameters and let's go through and this
one will call back flow a again and pass
some parameters and now we see we get
the values passed through there and also
this one will demonstrate the phases
flow scope al object and let me go next
you'll see that there so alright how
does it look in the authoring experience
here it is basis flow call so there's a
lot of naming conventions involved here
and we have adopted one that if you want
to create a flow very simply just make a
directory and give that directory a name
as you have to do and if you have a file
in there this is the xml definition you
know this is the way the prototype is
implemented that builder thing is not
implemented yet so if you have a
directory that contains a file with the
same name as the directory but - flow
XML then it will get loaded and looked
at as the flow definition so let me plus
this up so you can see it better so this
is what it looks like an XML you define
a faceless flow return and you can
define your inbound parameters and here
is the flow call node that's saying okay
what I call flow be right there I would
like to pass these two parameters
parameter and
pram one from flow a ram two from flow I
and this could be this could be an e l
expression here okay and if we go and
look at flow B you'll see the flip side
of this where it has
input parameters that must match up with
what we're passing from flow a so this
is saying I expect these guys to be
handed to me and you know what it's
going to do with them it's up to
whatever you'd like but here in this guy
he's saying I'm gonna go and just stuff
these in the faces flow scope all right
let me zoom back out now you can define
any number of pages inside here and
they'll all be in that same flow scope
so this is where we say input text value
equals faces flow scope this and on the
next page of course we are just
outputting that value to show that the
new implicit e-l object is working as
expected and this guy also has a
annotated beam like I showed you there
and this will become active when the
flow is entered and the active on active
when the flow is exited okay that's the
flow feature
lovely look at that beach ball Oh
another thing about floes you can
package them in a jar file this is what
I was talking about with the modularity
so once you have your flows package in a
jar then you can really build tests and
redistribute reusable web application
fragments and the first question you
might run into with it is well if I'm
going to make something reusable I you
know would like to take it from an app
that has one sort of visual style to it
and use it in another app that has a
totally different visual style but I'd
like to use the same flow in both places
and isn't it the case that because the
flow has views in it the visual style
will be kind of baked into those views
and well that would be the case if you
you could do it that way but there's
another feature that we have called
multi templating which is kind of the
other dimension of customizability here
where with the multi templating that you
that's where you put the style and the
visual representation of things and so
those can also be interchangeable so we
have the ability to have two different
dimensions here the behavior of the
things is encapsulated in the flow jar
and the visual representation visual
style of it will be encapsulated in the
multi template jar and when we decouple
those things you get the ability to
reuse flows without having to bake the
visual appeal visual appearance of the
flow into the flow jar itself but using
those two features together gives you
that capability okay
cross-site request forgery protection
this is one of the things that we had on
the list for two point one it didn't
make the time cut so we are adding it to
two point two and basically the idea is
this attack tricks the browser into
sending requests that the user did not
actually intend to initiate so how does
JSF protect you from this attack well
the good news it already does and always
has here's one case where the JSF
postback feature is a virtue
because everything in JSF has a
viewstate token and that serves as a
built-in level of cross-site request
forgery protection
well we added what the feature is we
require that the viewstate is now
encrypted by default you can turn it off
but now we're saying it's on by default
so if there someone tries to tamper with
the viewstate and make a request then
their encryption will fail and you'll
get the proper error that says hey I
can't I'm not going to take action on
this thing because you messed with it
that's fine for postback requests but
for non postback request that is when
you are going from one part of the site
to another from get using you know
multiple get requests and there's ways
to do that in JSF also instead of using
post we have this concept of a protected
views element and there's an algorithm
there where when we're trying to access
a new view we will look at these you
know the view handler will ask is the
view protected is it been specifically
listed in the set of protected views for
the application if so let's continue on
if not well we'll look at the referer
header if you're coming from a protected
view to another view in the app then we
say that that's fine
so then we'll proceed if we don't have a
referer header we'll say well does the
referer header at least originate within
the same app and if we do then we know
that we're coming from one of our pages
to another one of our pages so it's it's
okay to proceed if there's no referer
header then we'll look for this special
non post back token view per am and that
query parameter will be present because
we've made some changes to respond state
managers so that the that token has
always passed if the feature is
activated so I have a demo of that as
well
right there okay so we're on a non
protected page and we're doing an on
post back navigation to a protected view
and we're able to see it because we're
going from one to the other we have that
token there but if I was to strip off
the token and make the request again
you'll see a protective view exception
so let's look at how that looks in the
page author perspective okay CSRF tests
here we are and let's look at the faces
config so this face is config is very
simple it has a protected view with a
URL pattern it just specifically names
this one guy and that's how we're able
to do it
okay the file upload component so why
has it taken so long Apache Commons file
upload has been around for like eight
years at least does anyone know exactly
when it came out eight sounds about
right
yeah well why is it taking so long for
the benefit of Apache Tomcat users JSF
has always chosen to lag one servlet
version behind the umbrella spec in
which it is included so because we want
you know what we want we know the Tomcat
is very widely used and we want JSF to
be also widely used so we've chosen to
not really put things in there that
would restrict the set of people that
can use it
so with j2ee 1.4 even though we had
version 2.4 and the servlet spec we
didn't depend on anything except in
servlet 2.3 and so on and so forth so
servo 3.0 was the first version of
servlet that had multi-part form file
uploads support and so not until EE 7
are we able to do our normal trick of
depending on one level behind so that's
why we have it now it's a very simple
usage experience the final spec will
have Ajax and non Ajax support there
will be some additional JavaScript API
that we need to add for the Ajax case
but this is how it looks in the non Ajax
support you know we have a new component
H call an input file and it's value will
just be the servlet part that is sent in
the multi-part form submit so we have a
managed bean that gets the part of
course it has a getter and a setter and
the way you work with a part is you can
take this upload file which is a type
part and ask it for its input stream and
then you know my simple example just
will scan for some text I also wanted to
show that you can add validators to it
you know it's a regular JSF input
component so it's subject to the same
rules that any input component is
guy because it's a validator it gets
past a value and the value is a part so
it just does the same trick and here in
this example its scanning for if the
string jsr 3:44 exists in the uploaded
file let's look at that demo okay here
we are in the browser and I'm gonna I
have happen to have two prepaired files
this one will fail this file does not
contain you probably can't see that but
I'll zoom in this this is the text of
the file this file does not contain the
required string and will not be set into
the model okay let's open that and
submit it and it will give us a
validation failure and this one does if
we look in here this file contains the
string jsr 344 and will be successfully
set into the model so if we select that
and submit it that's funny why is it
doing that success please browse submit
yeah this file contains the string and
so you know let's just set a breakpoint
to see like we normally have these kinds
of things working file upload input file
here we are if I alt click on this
here's my file upload bean so you see
the setter is getting called oops I'll
click it one more time I'll blowed the
failure text to see that the setter
doesn't get called because the
validation failed that's not called but
if I update the successful one you'll
see the setter does get called right
there and so this is a part another
thing to point out of course is you have
to set egg type as multi-part form data
on the form otherwise the browser will
be able to do the right thing
so even though this is an H : form you
can still pass the ink type attribute
okay alright
you know well with that with the pastor
element feature you wouldn't have to but
you'd have to would have to be flagged
as a pass-through element okay this one
is kind of small but it's important
loading the faceless via the resource
handler JSF to todo added facelets and
also added resource handler but these
two concepts were not unified resource
handler was used for helping components
to render themselves when they have to
do things that go beyond markup but now
with this version of the spec we are
using facelets as depending on resource
handler to actually get the file that it
will parse and turn into the component
tree the multi template feature that's
very similar to Joomla and basically if
facelets lets you template page elements
then multi templating lets you take that
up a level and let's let's you template
site elements so sidebar navigation into
content area this enables you to define
a contract and you can code your site to
that contract and then any multi
template that implements that contract
you are able to use and multi tablets
also can be packaged as jar files I
don't have a demo of this one
unfortunately the medium-sized features
this bitly link will take you to that
set of them we've had a lot of features
in the component renderer realm the
window ID thing kind of fits in there
with facelets we've set html5 doctype as
the default so will automatically
generate whatever you know whatever you
say unless you specifically say don't
give me this we'll just say doctype HTML
we've added a facelet factory api that
wasn't there before
another fun one this was also on the
list for 2.1 but finally made it in is
view actions this is basically like a
button that clicks itself when the page
is loaded and you can also customize
when the button will have clicked itself
in the lifecycle so it's useful for if
you want to just you know do some stuff
before the page loads
and you want to make sure that it's
always done we made it so everything is
CDI injectable all of your JSF artifacts
we're not CDI injectable all of them
before just managed means we're but now
you're components and validators and
converters anything you can declare in
JSF is also now suitable for at and
inject small features there's a lot of
those a lot of bug fixes in these areas
of the specification so thank you very
much for your time and we have about
five minutes left for questions okay</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>