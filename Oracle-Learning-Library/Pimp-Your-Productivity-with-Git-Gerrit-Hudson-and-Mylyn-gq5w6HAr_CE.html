<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Pimp Your Productivity with Git, Gerrit, Hudson, and Mylyn | Coder Coacher - Coaching Coders</title><meta content="Pimp Your Productivity with Git, Gerrit, Hudson, and Mylyn - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Pimp Your Productivity with Git, Gerrit, Hudson, and Mylyn</b></h2><h5 class="post__date">2013-01-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/gq5w6HAr_CE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right welcome everyone my name is
Mick curse Tom the creator of the clips
myelin project and a CEO of Tesla
Technologies and I'm here with Stefan
Pingo one of the principal developers at
a supplement when the first and most
prolific Milan committers and today
we're going to show you how we've wired
together our collaboration and
contribution stack and tool chain that
we use on Eclipse to contribute to
eclipse to contribute to the my own
project that we used to communicate and
collaborate with our community and it's
been adopted by a fairly large number of
Eclipse projects give you a sense for
the sort of tooling that we use and you
know the whole goal here is that you'll
get to see how pieces of this you can
apply to your own day-to-day work to
your own tool chains the position
Eclipse it's actually quite a large code
base and quite a large number of
committers and contributors and the
interesting aspect that of those of you
who don't work on open source day-to-day
will see as little different is just
it's got this massive community of
contributors which in the end is you
know similar to your user base similar
to your you know ticketing system so
acquits has been growing right now we're
looking at for the junior release that
came on in June it's 55 million lines of
code so in the order of magnitude of the
Windows OS in terms of the size of the
codebase and we've got altogether a
fairly large number of projects so in
those projects you can think them as
teams so 72 teams and what's been
holding all together it all started as
you know back in the days of Eclipse 3.0
back when it started at over just over a
decade ago it was really just CBS and
Bugzilla and as you can imagine as that
those lines of code grew and grew that
became that was insufficient for
managing all the all the collaboration
that was going on at eclipse so what
we've got now is this dramatic growth in
the basically the amount of
collaboration all still hooked together
around the source repository and the
issue tracker which again like with
Mozilla projects is bugzilla there's a
pretty huge number of these things that
we call tasks the Bugzilla bug reports
you know we're now edging onto 400,000
of those and each release is this series
of communications and collaboration
around that and we'll show you how the
with the Eclipse mount project did is it
took those and make them the sort of
that the anchor of collaboration and
communication around the clips and then
hooked everything up around that so what
this meant previously is that when we
were using CBS Milan would connect your
CBS commits to the tasks that you were
working on and make it very easy to work
with pattice now it's all changed we've
got a better set of tools for managing
this where things are more linked into
this more connected graph that
represents our collaborations on Eclipse
and the two new tools in our toolbox
that help enable this argot and Eclipse
is actually now in the process of
churning a ramping down CVS support so I
think by the end of the year there'll be
no more CVS at Eclipse that legacy will
be gone only get will remain and then
how Garrett's added this new dimension
of code review so you'll see how we've
now connected the basically the issue
tracking the past side with the review
side with the commits and then also the
build because the build system is what
hooks us all together all of those
projects that you see on the previous
slide these are all connected with a
very large Hudson instance that's
running many build plans
how many build plans 200 yeah 200 build
plans so this is basically our
application lifecycle management stack
that we'll be talking about I will show
you how we work with it day to day and
Stefan will give you a few demos of what
an eclipse committers days like and then
you can compare that to how you work day
to day and how we can basically help you
optimize the way that you work with
these freely available and open source
tools so it used to be a lot worse and
Stefan's going to show you a little bit
of what it was like to be working in the
con Eclipse five or six years ago and
what we were dealing with that is
actually you know as recent as a year
ago in terms of dealing with this you
know basically this massive amount of
input that we were getting from your
core customers are so our open source
users is v's and vendors want to
contribute to the milan project because
one thing i should mention by the my own
project it's it's been one the most open
and transparent contributed projects on
eclipse a seventh of the worked out on
milan has been done by non committers so
people just submitting their patches and
you know it's not clearly recently that
you know
previously I was then Stefan was
completely overloaded with dealing with
the number of patches numbers of
submissions of people want to change
myelin for their needs for embedding
into their commercial products or for
just streamlining around their work
clothes so this is what we used to do
and to give you a sense of the
challenges that we're facing I'm going
to take you through one of those
contribution cycles so when somebody had
an idea what they would typically do
they would file a bug in Bugzilla and
attach a patch and then the commuter
would go in download that patch apply
that to its Eclipse workspace try to get
things building trying out the feature
and a lot of times we would we would
notice that some part of the code pace
didn't compile anymore it certainly
worked on the contributors workspace but
on a developer workspace it that patch
might have not worked so we would go
back in Bugzilla and ask the contributor
to attach another revision of his change
and would go through those same cycles
again grabbing that patch applying that
to the workspace trying out the feature
running tests and then maybe handing
this over to another committee on the
project to also verify that change made
sense and once we're happy with it going
through multiple cycles of this would
commit it to CVS then trigger off the
build in Hudson and what would often
happen is that once the build ran on
Hudson it was executing all of our
integration tests maybe integration
tests on a different platform the build
would break somebody would notice would
have to find out who actually did that
commit blame them and then blame the
contributor eventually and would go
through this whole cycle again and what
you can see here is that there are a lot
of manual steps on this process it
doesn't scale very well and we end up
with failing builds with just something
that we never want to have in our
repository we always want to be able to
make changes to master and not worry
about failing builds and the feedback
that the person who made the change
initially this comes very late until
they know if that
change actually works a lot of time
passes and all of these different
systems that we use in our day-to-day
development like Hudson like CVS like
Bugzilla they're not very well
integrated then they have some
connection between the systems and we
have some of these tools available in
our IDE but things like our Hudson
builds like our bugzilla tasks that's
something that we're missing from our
IDE which is what as developers we work
with day to day so and this is similar
to what you might experience when you
say join the new team right you had the
amount of setup that you need to do in
your own workspace and in terms of
hooking up and understanding the way
that the builds were happening the way
that the team worked in the way they
reviewed code it's it took a lot of
friction we had to resolve it right we
had they see four core committers at the
time and again this massive input of
patches of people wanting to to evolve
the project which was working but the
limiting function was how quickly we
could review those so what we did is we
created both the server side
integrations between those open those
tools those are just part of the Eclipse
infrastructure we drove us into the
Eclipse infrastructure and then the IDE
level integration so this could be all
hooked up and it could become much
easier for people to to contribute and
and as a result of this process we end
up with a lot of accidental complexity
and mixin are gonna take a closer look
at the IDE and and look at some problems
we're facing there yeah because in the
end when you've got when you're dealing
with this it's you know it's a sort of
frustration of again deal you know
basically doing these administrative
tasks and not coding not not doing what
you want to on that project
not adding that cool new feature ramping
up and fixing that that set of bugs so
the whole idea is that we get rid of
these manual processes some of which
have to do with your project ramp up
time when you're working some of it just
go on and on right if you don't have
this level of automation or this kind of
integration your IDE you're dealing with
this manual friction you know every
every day of your life as a developer so
the whole idea is that we want to get
rid of this
friction and then the kind of
distraction that results from this so
the fact that when you're you know when
you're waiting on a request from
somebody you know for us I'd be a
contributor you're just you never
staying and you never cook you're not
coding anymore
right you're just always waiting on the
output of a build system on on the input
of someone who is blocking you from
getting your change into a system and in
the end you know these are things that
we've recognized you know just do not
make us happy the friction distraction I
would kill her today what we're after
and the whole goal and this is actually
one of those that all the slides from
the Milan project the whole goal of the
project was to do the opposite to do the
things that makes us happy as developers
and if you've created Michael checking
Lansky's concept of flow or there's
there's a new movie now that called
happy that talks about this as software
developers you know the best thing about
our job is that we can get into the flow
of our work when we're programming and
if it's you know if you've got that
green mess that you saw on the previous
slide that doesn't happen but the whole
idea here is that we put in place that
flow and flow takes focus if we're
getting distracted whether it's you know
by these disconnected systems or
interruptions
we're unhappy when we get flow in focus
when we're in our IDE and we're writing
code and things are being built behind
the scenes for us and the contributions
are making it out into the builds and
getting released then we have this
feeling of satisfaction from from the
coding that we're doing I got pretty
interested in this when I used to sort
of in a before I started working on the
application lifecycle management side of
tooling I was working on basically tools
for better modular modularity so that
was the aspectj the velum environment
that's when you're programming a lot of
which is a lot of those concepts have
now made it into some of the runtimes so
the JVM since CLR and into frameworks
like like the spring framework I
realized that we were kind of getting
the the flow and focus that we would
work previously when we had these
simpler systems where people were
working say in small talk VMs or in very
sort of well you know we're very
constrained systems would just come from
getting better abstractions so this this
constant march of of getting from you
know from object
programming more dynamic languages two
things that make it easier for us to
write code at the language level or at
the framework level we were getting
diminishing returns and said in terms of
our happiness on those right if you have
you know closures are not going to make
closures are really important they're
not gonna make your day twice as
productive sadly when you get them in
the JDK or in the day or I should say so
I took a step back and this is a while
ago and looked at what was actually
happening with our day where we were
wasting the time and did my PhD thesis
on that and then someone fall down with
some work that illustrate that's even
better and basically showed that a
developer's day more than half of it is
just this is like excluding meetings so
more than half the time you're spending
in your IDE which you're already
wrestling to you know to spend more time
in is just thrown away on dealing
basically with this these friction these
distractions so switching applications
when you're you know I know you're
getting into a VM and testing things
handling the sort of interruptions that
come from you know waiting on someone to
review something of yours navigating the
code and searching code for the stuff
that you need to get your work done and
this is just very clear from the way
that IDE is used to look eight years ago
before we started driving this notion of
of task focus into the IDE which is you
know Milan pioneered which is now
actually a subset of Milan is now at
when the key things that's new business
C to 2012 that's being released soon so
just to get away from the squirrel who
are most of what you seen your IDs are
relevant to both in terms of the code
and in terms of the collaborations to
most of what you see being what you work
on and what you're working on is you're
collaborating with people in the social
way on tasks which are these activity
streams with comments and maybe
attachments and reviews and change sets
you've got builds that you're running
that you want to make sure you're
successful and you've got code that
you're editing so to go away from that
view where most of those icons are these
methods that are all in one file or in
one package that most of which are
relevant to your task at hand into that
kind of view where everything's linked
up in this kind of mashed up much more
social environment which previously
Milan was bringing in tasks and
connecting code what you're gonna see
today is the way that reviews and
version control and now a first last
part of that so what we want to get rid
of is these kinds of overheads of
multitasking searching interruptions all
that stuff that you saw in orange and
just get as much of your day as possible
onto the productive work we're in the
flow where you actually you know hacking
code and and creating cool things or
fixing challenging bugs so Stefan's
gonna start with a demo and we'll show
you something we'll just review some of
the key concepts of Milan and then go
into some that new functionality on
garrett and hudson and get alright so um
this is just a regular eclipse and one
of the things that milan provides as a
planning perspective that just has a
little bit less clutter so i'm going to
switch to that and this has a central
view in milan the task list and the
ptosis has all of our tasks if they're
in Bugzilla Adira HP Quality Center IBM
RTC doesn't matter this is our central
hub for our all of our collaborative
activity and in order to get those tasks
into our taxes and we have to set up
tasks repositories that is like your SVN
or CVS or git repository you basically
provide it with the location a URL and
credentials how to access your tasks in
this case I've set up a local Bugzilla
instance because we don't we don't have
never connectivity here and then in a
second step what you do is you create
queries in your tasks and queries are
basically your personal view of that
task repository so it's all the tasks
that you're interested in working with
for instance in mitosis I've set up a
query for all of Frank's bugs which is
somebody I collaborate with so I can say
I want to see all the tasks that are
assigned to Frank by the way even if use
NetBeans you can still pay attention
here because on Thursday Stefan ends on
the NetBeans teams will be showing you
how this has now been how my on have
been integrated wouldn't that mean so
yeah I'm very excited to see that and
once you once you've run
I'll find out for you by the end of the
session one once you run this query it
downloads all these tasks from the
Bugzilla server in this case to your
local workspace and it actually Milan
actually catches them offline so I don't
have to wait when I open these tasks
they open instantly in this case it's
these shots are coming from eclipse org
and in this task editor that opens I get
access to all the all the different
attributes on the task so I see the
priority I can edit this I can change
anything here in the task editor I see
the entire comment stream on this task
and I can work with the attachments on
the task so I can I can attach a new
screenshot it's very helpful if you have
a defect and you want to demonstrate
where the problem is and I can just
capture the screenshot I can highlight
something in here and then once I I can
provide a description once I had
finished that screenshot is attached as
a new attachment on the bug I also get
rich editing in this editor so I get
things like wiki text where I can
provide headings I've all these these
little helper things that I'm used to
from my IDE I also get in this task
editor so I get content assist for
instance I can link to other bugs if I
know key word or something that's that
this bug might relate to I can see I can
say see also and then if I use cotton
assist I get a list of all the tasks in
my task list that reference this keyword
and once I enter this it turns into a
link that I can actually click and then
if I actually click it it should open
this house okay here we go
so I can instantly navigate between all
my my different tasks I think like the
outline
all integrated so what we've basically
done here is taken the the IDE the IDs
my Chinese is this functionality from
navigating structured information it's
all indexed it's all accessible it's
easy just go the methods and and bundles
and files and so on we've applied that
to navigating the structure of your
tasks and issues and what we've noticed
is that these are sort of a key unit
that we can hook all this collaboration
functionality onto that Stephan will
show you but the main thing is you've
got this just like IDs created knapsack
function of files and this structure
under those files they see that you know
document object model under those files
we've done the same thing for tasks
wherever your task clip so whether you
zero bugzilla Romantics or track as the
open source things you use closers tools
like IBM rational team concert HP ALM or
rally or version one or mingle order
we've got a slide for the versus they're
supported it's it's almost all the
popular ones with developers they show
up in here and they've got this common
functionality it's like you're sort of
rich email client all native all offline
so it's all instant you're never waiting
more than 200 milliseconds for if you
click things properly for things to open
it's basically you never you're never
getting here Stephan's twit you with a
mouse you navigating it all your tasks
as quickly as your code because again
you refer to those as much as you
requiring your code now given the way
that stuff develops changed and become
much more social much more collaborative
and what's really nice is missing and
TAS are really like a first-class part
off Eid you know I can I can now like
any file I can save this change and in
the tasks here on the right where you
could well you'll actually see it's a
little black outgoing error which means
there's a safe change that I haven't yet
transmitted to the server so only if I
press submit it's this change actually
going to be submitted in Bugzilla and
then it's going to be visible to
everybody else and usually what happens
if I make a change and all of the people
subscribed on this bug will get an email
notification that somebody commented on
on this bug with Milan I don't need to
switch to my email client to actually
see those notifications but I can
synchronize these queries here usually
they're synchronized automatically and
what I'll get I'll actually get all
notifications for all the incoming
changes and if I hover over this task
here for instance then the tasks I see
this little blue air and it tells me
that there's a new comment on this task
and if I open it I actually all the
things that have changed while I last
looked at this bug um since I last
looked at this buck are highlighted in
blue so I see that a new comment was
made and I see there a bunch of new
attachments on this on this task so you
know what you're getting from your tools
like you know like JIRA like bugzilla is
is basically this team view of you've
got everything you've got you can easily
navigate all the issues in your web
browser and with all of that the key
difference of the approach with miles
always been it's it's extremely
personalized to you the task list it
doesn't only have your you know what
you've got in JIRA if you if you're
using another repository because you
work with another team so they're using
say a rational team concert instance but
something else you've got all this
information in your task list and all
your red state so everything you've read
or not write is cut up on so scroll down
Stefan and if you've seen that basically
I mean in a task editor if you've seen
the you know some of these tasks because
they had so much collaboration happens
around them it's everything's collapsed
that you've read already so you're only
seeing what you need to see everything
that's always focused for you it's very
you know the big difference with
violence when you used to look at
people's IDs before this they would all
look very similar with mile and
everything's completely personalized to
you to what you've seen before to what
you care about to who you collaborate
with and red-state is a very big part of
that and it layers over top of any
repository that you use and well you'll
notice if you look at my tasks list it's
really really simple to create these
queries and you end up with a lot of
tasks in your houses now I've even
filtered the completed ones but if I
unfilter you can see they're thousands
of tasks probably in this houses I think
my tasks this has 10,000 tasks I think
maybe what
like 20,000 so it becomes really easy
and you can easily get into a mode where
this houses gets overloaded which is the
very same thing that we're trying to
avoid so we added this planning mode
where I can switch here from on the top
I can go from the categories into a
planning mode and this organizes my
taxes by days of the week and I'm
getting things done basically that
that's style of organizing your work
when you've got too much coming at you
to give you it's all about giving you
more control over your day when you've
got you when there's lot going on around
and when you get focus and I see down
here I see all the unscheduled ones and
I can just simply drag and drop them
into these buckets and that means
basically when I drop a tasks into the
Wednesday bucket means I'm planning to
get to that task on Wednesday and you
can see the blue ones those are the ones
that are scheduled for today um if I
don't complete a task today that I have
scheduled for today then will
automatically move to the next bin so on
Tuesday all of these tasks if I haven't
completed them will be in my to save
inside I never lose track of them and
one thing I find really useful is if I
open a task a lot of times I don't have
the time to review it in all detail and
I'll just click this button up here but
schedule the schedule it's for today so
it shows up on top of my task so I know
this is something that I want to look at
later and it's like stare starring a an
email I can just click click the button
up here in this house task editor and it
shows up in my tasks list
and sometimes there are these weeks when
you don't get anything done and tasks
just keep piling up and that's when I
I'll use those this week bin but just
really useful it's basically it's not a
particular day of the week but it's just
something that I want to get to some day
um so for those tasks I put them into
this week bin so I'll always see them
but they don't show up on top of my task
list
and even now I have a lot of tasks
visible here so we added this this
notion of focus to the houses once I
press the focus button the taxes filter
everything that's not relevant to me for
this work week so I only see the tasks
scheduled for this week and I see all
the tasks that have incoming changes
that I haven't looked at yet so for
here's another task with a new comment
so if I open this it disappears from the
task list because I have now read it
it's no longer relevant if I still care
I press this button scheduled for today
I'm sorry have it in my focus tasks
again
so you basically go from the state where
you've got your email inbox is filled
with change notifications on issues that
you're watching to you know the whole
goal being in your IDE you've got this
task list that's all the stuff that you
need to be coding and be productive and
it doesn't have a scrollbar and usually
we have this these best practices where
the more and you'll blast you're in
comings schedule things for two weeks
from now but then you'll do them then
and you know get to the point where you
don't have a scrollbar so you can then
start what Stefan will show you in a
moment which is get back to coding so
one feature but we added recently which
I find really useful to us so you can
you now have a indexed index over all
the tasks in your tasks list since
they're all cached offline I can search
over all of them and you can even use
content assist in the search box now
where you can say okay I want to search
all the comments for the keyword secured
and it'll show me all the tasks that
match that match that search thing it's
incredibly useful if you're looking for
something so anyway so what we now want
to do is now that we've found a tasks
that looks interesting to us that we
want to work on we want to activate it
and the easiest way to do that is here
from the task editor that's a big
activate button basically just means
we're now starting to work on this and
if you haven't used Milan this is other
than you know you first get comfortable
with with it passing a task list and
just working with them there so you
never copy pasting you know ticket IDs
and so on that big bigger step and
changing process is this notion of
activation and it kicks off a whole
bunch of automation behind the scenes
that Stephan will show you but that's
that's a thing you've not had to do
before it's actually activate those
stats right now if I look at my package
Explorer I see all the projects in my
workspace
um and I see all the classes methods
basically that whole compiler centric
structure of my workspace is visible and
instantly accessible but right now as I
work on this on this task I really only
care about this this handful of classes
that are relevant to that particular
feature or defect that I'm working on so
what I can do now in the package
Explorer I can filter it so like we saw
in the tasks I have this focus button
and as I press the focus button it
filters everything else that's not
relevant so I can always unfocus shows
me everything
once I focus it only shows me the things
that are relevant and now watch what
happens as I navigate this file as I
touch a method these methods get add to
my task context and they show up in the
package Explorer because they're now
interesting to what I'm doing you're
folding Stern's up alright and I can
even even in the Java file I can fold
all the methods that I haven't looked at
because they're not they're not
interesting to me yet so I only see this
the relevant stuff and as I touch
something it automatically expands gets
added to my task context and this also
works for a number of number of other
things in Eclipse for example the
content assist now lists the things that
I've interacted with on top of the list
so don't have to scroll down the entire
list I just have those methods on top
right here and the the same Oh I haven't
opened any type so that doesn't work but
I can also filter other views like the
markers view so right now it shows me
all kinds of problems if I focus it it
just shows me the problems for the
classes um that it that are part of my
task context so basically the idea is if
you work on anything other than you know
a toy or a tutorial example system there
is more stuff showing in your ID than
you care about at any time but and the
whole intuition the whole idea behind my
life for no matter are systems that we
work on will just continue to grow in
complexity right we will make better
framix make their languages to hopefully
reduce the lines of code count but I
don't know how many of us have actually
been seeing declining code counts and
the applications that we were gonna be
working on when we get back from the
conference so what we've done here is
said ok for though that complex is
obviously hurting us badly dealing with
that navigating it the fact that even
though the IDE can open you know
Stephan's eclipse right here has about 9
million lines of code under it and you
know the the index technologies means
it's no problem to display all that but
you know neither our brains nor our
screens can fit that properly so anytime
we're seeing the structure instead of
showing you everything which again the
compiler the build system cares about
focusing only shows you what's relevant
to the task at hand and the way that you
interact with the system so that the
navigation and coding activity create
this task context so what you see in any
view when you press the focus button
it's not everything just like task
context everything else is still
underneath it but the task context is
now explicit everything you touch
everything you you edit and there are a
few nice gimmicks if you can press ctrl
alt shift right you have to have six
fingers on one hand to do that oh it
doesn't work in the VM that's terrible
I should've tried this before it will
show you a viewer can navigate within
your context or we have this little plus
button so if you know there's a class in
this package that's also relevant to me
and I want to quickly navigate to it
then I press a plus button
it it temporarily I'm filters that
package that I I clicked on so I can see
all the items under that and quickly add
that to my task context yes even though
the things are hidden they're still
still just a click away but again the
idea is if you've got a 24 inch display
or you know 21 display and your package
Explorer your project Explorer you're
not seeing a scroll bar most of the time
the scroll they don't work right if
you're seeing a scroll bar you're
missing part of the structure of the
code for this task if all you sees the
all the files in one package all right
so it's um so this this is really great
if I work on one task but what a lot of
time happens is is that you're switching
tasks all the time so what's happened
with whether it's because you've adopted
agile you're more connected now to your
user base through you know through
tickets through issues however it is
we're crashing a lot in the way that we
work today so you get in on Monday
morning and you know you're actually
over the weekend you actually got your
your energy back up because you know
you've got this cool new feature that
you want to work on that you want to add
to a screen in your app then you know
that thing happens when someone says ok
there's there's a problem we got to
figure what's going on here this looks
like a p1 and you start looking around
for what's going on you know could this
be in your code well you know what's
you're now investigating this defect and
then you spend the next part of your
morning fixing you know basically invest
investing fixes for that defect you go
and you take a very short lunch because
you're still worried that this could be
a problem that you introduced you then
catch up to see if there's a more severe
problem after lunch then the one that
you're working on so you go through your
email inbox and do that then again you
have to basically get back and you know
we store the context because every time
you do that your browser tabs go away
your equips other tabs go away and you
have to recreate that state right every
time you get your ID into a state just
like you know with a virtual Windows
Manager you kind of like the way you
laid out your windows it all gets blown
away multiple times a day or you deal
with the 80 open tabs then you realize
that this thing looked familiar to what
you were doing previously
and you spend more time swapping and
searching because you remember you know
that this piece of code this npe on this
line of code was actually related to
something else and then you realize it's
this bug from six months ago this old
thing that you actually did check so
what you gonna see next is our whole
goal of getting rid of all that swapping
and searching basically accepting the
fact that if you're working agile you're
working in this more social more
collaborative way you're going to end up
multitasking throughout the day you
should try not to but you will and the
task the whole goal of the task focus
interface here and we'll just show you
first four issues later so we will show
you how this relates to commits and code
reviews and branches but the whole goal
the whole time is to get rid of all that
gray so you can multitask with a single
click so you know the idea is that you
then recover that time in your day get a
bit more time for fixing that bug
because you knew exactly what it was
take it take a longer lunch of them
hopefully get to work on that new
feature by the end of day so that's when
you know someone tweets that myelin help
them and is making them happy and that's
that's our whole mission here let's look
at how that works in practice so right
now if this task activated if I
deactivate it from the task list
save my changes my package Explorer goes
back to the state it was previously and
where I see everything so now if I
reactivate the task it instantly
restores all the editors taking me back
to that exact cursor position that I was
last last that when I worked on this
task so I don't have to remember all
this context I just reactivate that task
and I'm instantly back at that same at
that same place unless eclipse
pre-orders my editors and I can so this
helps me if I have multiple tasks that I
worked on I can quickly switch between
them and you see now I see the context
of this task activate the next task
takes me exactly to the context of that
task and we have a nice feature in
in this version bear if I have a task
that actually that has a that has a
stack trace on it let's see maybe we can
find one here and I activate this task
Milan will actually look at the
description of this task it'll
automatically create a task context for
me based on the classes that are
mentioned in this Factory so as I
activate this you can see I already have
a context now I already know where to
start working on based on the stack race
that I see here in this task so what you
saw previously the context were just
fully manual wholly based on your
navigation activity we'll show you how
they can actually incorporate navigation
it could be from other members of your
team and so on but we're trying to
provide you know now that all of this is
in place we're trying to see if it other
innovations built on top of us like the
idea of pre-populated context and an
easy way to do that is through a stack
trace okay so now let's let's look at
how we actually work on those tasks I've
I have two working sets on this
workspace there's a demo working so that
just has less project so it gets more
obvious what are we doing here
so working sets are basically just a way
to organize your workspace where you can
group certain projects into different
working sets if you work on four
different customers for instance that's
very useful so in this working space I
have a query against my local Bugzilla
first thing I'm going to do I'm going to
create a new task say improve messaging
for a j1 and I'm going to submit that to
my local Bugzilla and going to activate
this Taos weekend because I know want to
work on this so what I want to do for
this task yes I actually want to change
this class I can now focus the context
so this is really simple implementation
that says hello Linux talk this is out
of date
I'm gonna change this to hello Java one
20:12 maybe and save this change now
want to commit this into my version
control system in this case the project
is in git and what you'll notice as I do
commit here the commit message is
automatically generated for me this is
based on a template that I specify in my
workspace and you can see that it has a
reference to that tasks that I just
activated so I get this traceability for
free so a commit let's change I can now
do you activate this task and I I see in
the history now I see this commit
message and from the context menu of the
history view I can even navigate back to
that task so I can make that full
round-trip so since this is a git
repository I only committed this change
locally now in order to make it visible
to my team I have to push it to the
server
so I'm going to push this to upstream
okay excellent
and this git repository is hooked up to
a Hudson's server and that Hudson server
you should now kick off a build and
Milan also has this builds view and that
builds view is very similar to the tasks
for tasks the builds we add the same
functionality for builds so I can
basically define my Hudson server or my
Jenkins server subscribe to the built
plants on the server that I care about
and then when i refresh that view it
shows me the status of my build spawns
so here I now get this notification that
this change that I just submitted kicked
off a build and the result of that build
was actually that it fail and if I open
this I get similar to toss I get this
rich editor where I see all the
different details about the build I can
look at the console output
opens in the Eclipse console the just a
centered maven build I got hyperlinking
and so on and I can also see the test
results and I see that in this case okay
apparently um one of my test cases
failed based on that change that I made
and I can I can see that was exactly
this change where I just changed that
one line okay so let's look at that
let's look at that failing test and I
can do that right here from the editor I
can open that in the eclipse trained
unit view and right from here I can
rerun this test in my local workspace
and I can see okay this is indeed
failing so you know I know I've been
trying count clicks but something about
it 15 20 clicks there is no login to any
server everything all your credentials
are there for the service that you've
set up there was no download there's no
you never copied paste any text to you
know to get the stack trace in here
figure out what the failing unit test
was there's just the Swann basically
rich Native Client on your desktop which
is your your IDE where you do your
coding which is hooked up to the build
system everything you're watching
whether it's build plants it changes you
get a notification on your desktop you
can click into it and everything is
wired in again it's just because even
though the failures on the build server
of that J unit test your IDs setup to
run those J unit tests so just to click
and you're running them locally so it's
basically no we treat all of these
different ALM servers as just these
services for your development you know
one of them is it's Hudson or Jenkins
another one is your SCM system the other
ones that your issue tracker and then
this client wires them all up and the
key thing is everything is navigable so
whenever you know step maybe you'll show
some build changes in a moment but note
that you're never you're always
navigating everything the structures
explicit and it's all related to your
changes to your commits to the part of
the code base but you're working on I
mean it's from this test fear it's
obvious fight changed it here but I
didn't update the test case which is
terrible I'm so I'm just gonna
reactivate the TAS and go back back to
my test case
I'm gonna update that as well and this
time I'm actually going to run my tests
to make sure that they work locally okay
great
I'm going to commit this again and I'm
going to amend my previous commit
because I obviously that commit wasn't
right so I'm just gonna Kim amend this
meaning update the same commit and push
this again and hopefully now this will
kick off a building in and by refresh
this here in my builds for you I now see
this little gray a little green arrow on
my build plan which means the build is
in progress and as I refresh that again
it should complete and hopefully now the
Builder screen I get my little
notification pop-up and I can see I can
see the change so what I didn't tell you
is that I didn't just push this change
into a git repository but I actually
pushed that to a Gerrit server and a
Gerrit server from the outside looks
just like any other git repository but
it also adds some workflow it adds per
mission control to my git repository and
more importantly it allows me to do code
reviews on those commits that I did and
just like for bugzilla
we have a connector a task connector for
those Gerrit reviews so in my taxes I
can define a query against that Gerrit
server and say only see all the open
changes all the open reviews on the
server if I now refresh this query I
should see a new code review that is
based on the change that I just pushed
to the server and this is no this is all
created automatically for you and shows
up in your tasks list notification
there's no additional setup in Stefan's
workspace and on this code review I now
I see already see a common thread um
this is our Harry Hudson just basically
the Hudson user but every time there's
somebody submits a change it'll take
those change trigger off your build and
then it'll put the result back on the
code review so I can see this was the
first built result was unstable second
build was successful and under reviewers
I've already have a vote from Harry
Hudson that this change was verified now
in order to approve this change so that
I can actually put it into into my
master branch what we still need is a
code review and code review is something
that that developers have to do and
before they unless I give me a plus two
on this change it's not going into my
main code base I can also see the
different revisions um that that was my
first change that was the second one I
can compare them here so I can see it in
the and the second round of changes what
I actually did is I changed the test
case but now to actually do this code
review we need a second developer
because I shouldn't be reviewing it's
good if I if I review my own changes and
that's that's something I would always
recommend but what's really valuable is
if we have someone else review our
changes and I think we have Alice in the
system as well so I'm going to add Alice
as a reviewer to this code review and
start a second instance off Eclipse so
now I'm putting on a different hat I'm
being a different developer who wants to
now review this proposed change from Bob
so now while you're interacting all in
your IDE everything is being all the
information that that's shared is being
stored on the server soon as Stephan
push that change batson get as soon as
the review is initiated the other review
it gets a notification and their task
list in their desktop - you know either
go work on this and then take the
interruption or to schedule it for
tomorrow with the scheduler facilities
or to set it for the next sprint because
if you're using agile all of the agile
facilities show up in the task editor if
he--if the repository supports it and
Alice now has a very similar set up with
a tassel with a career e for all the
reviews I
what's a most two kliks I can take that
change put it into my workspace I can
try it out I can run it locally I can
review the changes and the compare
editor and right here from my IDE I can
add comments on it and can say okay this
looks good or maybe that doesn't look
good maybe there's something else that
that Bob should be doing maybe he didn't
follow our style guide or something else
and rather than doing this in the web UI
where you're missing some coding
facilities you're also able to do it
there but if you're doing it here you've
got all your unit tests you know you've
got your unit testing your SCM to
everything all the code graphing
facilities are your fingertips and once
I'm done with my code review I can
submit my comments and I can rate that
change so what we were missing where
this what's this plus two so I'll
provide that for this change and now if
we look under on the reviewers we now
have all the all the requirements
satisfied which is something that you
can configure and Garett depending on
your workflow it clips for instance has
this IP clean flag unless the committer
says that this changes IP clean that
can't be submitted but the default aside
you need a verification and a code
review and now as I submit this change
Garrett
it's going to automatically merge it
into my master branch and this code
review should now go into the merge
state and if I switch to master and pull
all the new changes in the master branch
I should see that I have exactly that
change that I just could reviewed and
approved is now I'm part of my main code
base so the key thing is you know this
process that previously you know at for
large-scale software literally these
processes are complex the the review
stage you know clips we've got you know
IP climbing lights to deal with there's
another example that Stefan pointed out
but the key thing is it's all
explicit and the way it's configured in
the bugzilla kid Garrett Hudson servers
and then Milan just hooks it all up on
your IDE so it's easy for someone to
just come in and start contributing to
that to be committing to the codebase
and have things be built off a branch
show them on the build server that the
bill failed rather than you know you
need to set everything up locally and
then it's actually the review process
that's the whole staging for this you
know for the way that we've hooked up
everything through CI and the last step
that Bob would usually do is um since
that change is now merged what Bob would
do is persist that task context on the
bugzilla bug so in the task editor on
the bottom I get this context tab but I
can review the entire task context I can
also remove things that I I think
shouldn't be in there like this main
method maybe shouldn't be in there I can
mark things as landmarks thing this was
really important for this change if I
interact a lot with certain elements
like a method then it automatically
becomes a landmark and goes bold but I
can always also do that manually and
once I'm happy with this task context I
can say attach contacts in my task
editor resolve this bug and then Milan
takes this task context externalizes
into an XML format zips it up and puts
it as an attachment on this task so for
any contribution to Milan we require
tasks context because then we see all
the API that you referred to that you
looked at in addition to your code
changes we see the key part basically
the key parts of the code base that you
looked at and we changed in making this
change which makes reviewing your
contributions you know ten times faster
for us and all of these contexts are
stored on in the Bugzilla repositories
attachments or in your issue tracker so
just to quickly wrap up you know what
you saw here is just the way that we
have a certain development process
you've got your own development process
the key thing is that with these tools
both the new generation of code review
tools then you generation if you issue
trackers and this reviewer can control
tools you can configure them to capture
your processes and then this new
generation of ID clients can actually
hook into that what you saw is that this
review was staged but with a
contribution from someone we don't know
we didn't even trust let's say like a
new project member and
our case someone just from the wild this
was pulled by Hudson in this case Hudson
built it after the build Hudson voted so
if again they didn't make the unit test
fast as Stephan failed to it would not
get any further before they did that and
they would they would get a notification
on that a proper reviewer and external
reviewer was also then also contributed
their reviews another review system like
the IP cleansing system like a black tie
system can then also hook into this it's
approved twice and then as soon as that
approval happens that automatically
triggers the merge say into master per
our policy and the contributions are
made so all of this as you know is now
explicit and all wired up inside the IDE
so we will really quick wrap up on what
we've got here then there are some more
talks that it will explore some these
con concepts all of this is hooked
together through the milan api is when
the key things about Milan sits
frameworks and the way that they've been
extended so you saw it working for our
tool stack the main thing is making it
work for your own tool stack and getting
some of these benefits for what you work
on these are the tools are supported
some in the open source ecosystem if you
just Google for Milan extensions
you'll see a number of these some
commercial tools pass up we attach will
give a certification program to make
sure that the web service of the ALM
tools has all the web service API s for
us to do this automation we've got some
new features in Milan create to free the
check out so just Google for Milan
downloads you'll get to the new
noteworthy and there have been
improvements in the garret and get and
had some connectors to support all of
this and again you know the key thing is
that we're trying to connect but you
know to give you this very personalized
connectivity between the way that you
work that would you know the way that
you need to be to focus on writing code
as our ALM stack as our tools chains
have gotten increasingly complicated
keep this very personalized connected
and focus look on it so for the other
talks we've got I'll be speaking about
the future of ALM and the social code
graphs or something conceptual you know
five-year vision stuff around us and
where we're going with the open source
projects with a number of partners and
open source development efforts but bits
more at ten we'll be showing you
work that we've been doing with Oracle
around bringing some of these concepts
and hosting some of this in the cloud
that will be tomorrow at 11:30 a.m. and
will be featured in some of the open
world keynotes as well and Wednesday at
1:00 p.m. is the Milan NetBeans talk so
you can check that out as well and with
and then there'll be another conceptual
talk on Thursday about linked data how
we can hook these things up by expanding
the web standards that we have with the
work we doing with the w3c
so with that thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>