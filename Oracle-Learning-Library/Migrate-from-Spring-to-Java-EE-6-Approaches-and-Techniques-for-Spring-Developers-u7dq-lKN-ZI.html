<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Migrate from Spring to Java EE 6: Approaches and Techniques for Spring Developers | Coder Coacher - Coaching Coders</title><meta content="Migrate from Spring to Java EE 6: Approaches and Techniques for Spring Developers - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Migrate from Spring to Java EE 6: Approaches and Techniques for Spring Developers</b></h2><h5 class="post__date">2013-01-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/u7dq-lKN-ZI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">first welcome i hope you enjoy the
content so far my name is Maurice Povich
i'm a i'm working for jboss by Red Hat
I'm a spring enthusiast I could say
since 2005 which might strike you as
interesting because it's actually a talk
about migrating from spring to Java EE
I'm the lead for a project called
snowdrop which provides a spring
integration utilities for jboss a server
so we try to get some deeper integration
in well with in jboss I in time I've
started its kind of doubling more into
java ee working a little bit on weld the
reference implementation for GSR 299 for
CDI i'm contributing to the CDI 1.1
expert group i am working on another
project called jdf gypos developer
framework which is which provides a set
of tutorials and basically resources for
Joe evolve furs to understand how to
build better spring a better java
applications so my experience has been
basically in both sides of the of the
under both sides of the fence right and
what I think what I thought about doing
today is basically trying to give some
sort of some sort of practical overview
of what tools it can use if you have a
spring application and would like to do
more Joey right because we have
something like that so essentially this
is the assumption about the audience
which is very presumptuous I would say
is I don't know any of you how many of
you fit actually this profile how many
of you are using spring okay check how
many of you would say that they
understand concepts like dependency
injection cross-cutting concerns
declarative transactions so on okay
don't one sorry about that and how many
of interest is enjoy
in learning about jelly kind of cool so
we're all in the right spot what I
discovered when people try to use Joey
so everything is great when you start
learning about the differences
everything is it's grape and you start
learning about the tutorials everyone's
showing you how to start from scratch
and so on and so forth but then what I
found always hard is for example when
people move to like from a spring plus
Tomcat environment and start moving into
a more java ee aware application server
that's all there's also one way of using
java eat right and start asking
questions how do i set up things easily
how do i configure my my application
take advantage of services how do i
write tests right how do i migrate my
code my existing code what do i do with
the with the existing code because
greenfield applications are rare and to
say i like saying that a lot of times
production environments are more
promiscuous that tutorials will like you
believe you have different types of code
different types of applications mix ups
and so on so you have to juggle with
that very often and tools get actually
tools and utilities can take you a great
way to actually solve the problems that
appear there so what I'm going to show
today is some tools and technologies
think an easier transition into java ee
learn java ee use java ee i understand
how java operates right so we're going
to talk about forge and actually we're
going to talk about not only forge how
many of you have seen forge demo how
many of you know that Forge has a spring
plugin they can help you set up okay
they can set they can help to set up a
string project through Joey services how
many of you have used arquillian you
should it's a very good party that's a
very good way of testing
again I'm going to show you how to use
it for your spring applications it's
another step of the transition so I'm
really envisioning this as a gradual
process becoming more from the ovary
Joey services understanding how to test
in container and then moving towards
Java completely if you want to do so so
if the final step would be integrating
Java EE and spring especially CDI and
spring using utilities like seem three
the seem to be spring module which we
have like now and how many of you have
heard of a project called Delta spike
Apache Delta spike that's really good so
a quantity Delta spike is basically a
set of utilities that provide extensions
to CDI for different tasks so they can
be core utilities or let's say something
more functionally tables like better
integration with JSF or spring
integration work CDI query for example
so we're going to take a look at that
and we actually all they want to do is
really demo all these technologies so
just to understand where what I'm coming
from in this discussion I just want to
clarify the talk a little bit about the
role of java ee services in spring
applications now how many of you are
using spring and JPA how many using a
local entitymanager factory be or how
many of you are acquiring from jindie
for example is a server site deployed
but a few so my take on that is
basically a distinct teams take in that
the spring is focused around three
things dependency injection aop
important service abstractions and the
first two are actually what forms the
programming model so that's
platform-independent that's business
concept that's oblivious of
infrastructure and you actually spend
ninety nine ten for your development
time you don't worry too much about what
kind of but you what you JP a panty
manager is coming from or what's your
transaction manager set it up once and
forget about you start writing your
controllers your da OS and some other
stuff but what really happens under the
scenes is that your application delegate
Stu services and so Springer solves us
through the concept of portable service
abstractions like things like the
platform transaction manager or the
local entitymanager factory beam which
whose role is basically saying well if
you're not running an application server
you don't have to worry about you don't
have to worry about the fact that these
services are not available you can
supplant them by providing our own
implementations right I think it's we
don't spend too much time in this but
this is where your application actually
runs so you may want to consider let's
say the merits of running of using those
services in a in your running
application so I'm really really looking
at a model where as at least as the
first step in approaching java ee you
would look at combining the programming
model with portable service abstraction
implementations right and there are
advantages to this one thing is for
example using manage data sources it
sends a minor thing rather than using
the basic data source how many of you
are using a genie provided data source
for example okay I don't have anything
to tell you that for the ones that are
not though there are benefits in using
like in in the in using an application a
data source at the application server
level that they're not come necessarily
come from the manageability of the data
source for example I'm going to give him
providing an example from my own turf I
manage data source
is can be well managed on jboss using a
command-line interface so you can write
scripts to actually manipulate its
doesn't matter too much for development
but it matters is a lot for operations
another example is using manage GPA as
opposed to bootstrapping your own
entitymanager factory within your
project you don't care too much about it
because at the end of the day in your
user Dao it's you're going to get an IDP
manager injected where you gain what you
gain by using this is that if the
application server is really good it can
do optimizations for you like we do for
example we use a pre annotation scanning
process to speed up the deployment of
persistence units it's an example of
something that the server does what you
get through a service which is not
apparent in the when you think only of
the programming model or you can use GT
for transactions how many of you using
turn GTA transactions well good we
advocate using JTA transactions because
for one thing to integrate with the
their requirement for example if you use
the server-side deployed persistence
context but it's not for that only it's
basically that very often when you
combine spring with other models you
have to issue that you have a
transaction we have local transactions
created by some components we have a
other transaction exceeded by other
components and so on and so forth and GT
actually allows you to basically
propagate the transaction across
different component models easily and
don't think about it in a very
transparent fashion and again if you
worry about the performance in JTA just
remember that most transaction services
can do not use two phase commit for two
like four for single
resources most of them most of them
don't grade to a one phase commit which
is probably small difference compared to
local transactions but you get a lot in
terms of ease of integration and there
are some other things like how many of
you are using messaging in applications
now if you use messaging you have
different strategies for configuring how
many of you are using a message listener
container right now in spring you can
either use the default one or you can
let the application server messaging
system actually take care of passing
messages to your to your listeners again
there are advantages in doing this an
application server normally optimizes
transaction integration message delivery
consumer caching session caching and so
on and so forth doesn't appear at the
programming model this is not evident at
the when you actually run you get
benefits and the first question here is
yeah okay fine I'm going to start using
java ee services to backswing
programming model one question that for
example shows up on our users is ok I'm
going to do that how do I do it how do i
start up easily and in hope i start an
application easily but spring had
actually said set it up to use this on a
container managed entitymanager or a OJT
a right or you can copy and paste code
but we have a better solution for this
and i'd like to introduce forge now
forge is a rapid development tool that
we kind of really the tables but in fact
it's a community project so it has a lot
of contributors from the community xn
extending the core but especially
creating a Ania like extending the
ecosystem of plugins it's very easy to
what it does is basically helping you
set up start up a project set up the
infrastructure create component create
entities scaffold and so on so let me
just give you a quick example
oh this is this is the forge consult
that's available in the table developer
studio jboss tools I prefer using that
it's well it's command for as a shortcut
but if you can install tables tools or
if you can open it from here so you show
view it's a view and it basically say
Forge as the forge console so I can
start a new project right
negate a new project it's very easy can
you just
this basically just creates me a basic
structure nothing I didn't tell if what
kind of a project that one could i can
add persistence to it
it is yeah so the question was whether
for Jesus yeah porch generates maven
based projects we find it easier to like
it they lend themselves easier to be
manipulated in this way um how many of
you are using maven okay that's a lot it
might not be that bad and for example
there is there is an idea right now that
it could generate it could also generate
Gradle based projects as of plugging as
an option and there's an extension but
maven is maven is probably the easiest
to integrate it with because there are
good libraries for processing XML and
for actually for processing the palms
and I think stuff like that so I can go
and very easily create my persistence
layer I can go and create the I can go
and create for example an NTP now it
doesn't the question was whether it does
mybatis it doesn't although there was a
proposal for plucking that can do that
so right now it's very like in some
sense forges right now very somehow java
eccentric right but again you'll see
that we can actually add a very i can
add spring on top of it so okay this
generates me an entity right we all know
how to write in it is not expect a cur
what I'd like to do next is kind of set
up my project so that it uses the things
that I've been talking about regarding
spring configurations like jindie a
continental manager required from Jind
EG j transactions and so on and so forth
so first i'm going to create
the field so that this entity has
actually use so I created it like this
and right now I can go on in two
directions I can generate the scaffold
with jsf and all the other stuff I can
create a number of restful endpoints
with Jack's arrest right or i can add
spring so here's what happens i yes
problem is that I disabled the shortcut
it's really the clips not being very
cooperative so you've got me I'm an
ontology using the problem is doesn't
affect the console is just a fella
affects the code okay it's good then
thank you as I said what's wrong with
these intelligences all right so
unfortunately I don't have a forge
blocking for ontology I cannot
demonstrate that and this actually works
out very nice as it shows you the code
and as it is being generated all right
so I set up spring and here's what
happened it had its spring to my
application it added an application
context but more importantly
just refresh yeah
it's
this is what happens when you don't
sacrifice a rubber chicken to the demo
gods hmm I'm sorry yeah I should do that
next time is obviously it's well yeah I
mean it's it says that it's located
there and probably has generated but
clips refuses to love that we love the
projects
you know I think this is a bug now it is
it is about here drink now it's okay
okay this is not what I hope to show you
fortunately created something and right
now it just eclipse refuse to refresh
itself and we know its mangled so I have
to recreate again if I wonder why I'm
suggesting you to do this it's because
in general it works
so it is the only one in one command
basically we can do it into this one
didn't work that well basically what I
did is I was telling the project that
this is a web project using spring so
what it did is basically it has change
the type of the project in the palm to
war but more importantly it has
generated context definitions so this is
basically the entitymanager factory and
the GT transaction manager right and
everything else is basically a spring be
so I can go and say scaffold
that is basically generates the rest of
the project right so now
whoa
Oh
this is my running application II that
started easily the infrastructure is
there the rest of the programming I say
the interesting part is not the scaffold
itself the interesting part is
generating the configuration easily and
get it set up right I think that's
probably one important step when
migrating like when migrating to Java
kind of starting of thinking of the
application server as a provider of
services that can be used okay fine we
are using the Java infrastructure now
it's very cool what happens to the tests
the biggest problem when you're actually
starting relying on on server provided
services is that you typically don't
have them in a unit test and this is one
thing where like which train test for
example was pretty good at that's not a
problem we have the means for actually
testing applications that run in
container so here is like I like to
introduce our Killian for the ones if
you haven't have an encounter dark okay
we can talk about it again I don't I
really didn't want to and I don't I
didn't want to enter this discussion
necessarily and kind of I'm taking that
as a given for the discussion why do I
want you why do I want to use I'm sorry
yeah it's we can have a debate at the
end and I'll explain my motives why I'm
interested in it I think there are very
valid reasons right now to use Java
years of platform and the devaglia the
Platinum has attained of maturity at
ease of use that don't justify some of
the
some of the things that you would have
gotten let's say seven or eight years
ago if you started using spring that's
in a nutshell so moving forward on the
other hand the component model is going
to become more pervasive so see stuff
like CDI is going to be used much much
and more across and I think you would
gain a lot by adopting this by adopting
this right now that's one of the reasons
why I became involved in the work like
while recognizing that spring is a
powerful framework is a useful framework
is a popular framework and I personally
like it I personally at the same time
I'm working on the Java EE side because
I think it has a very valid very
compelling the development model that
makes it easier maybe even easier at
this point to use if you if you use a
java ee stack that's my personal opinion
i mean that's that's somehow that's how
I see things you may not see things this
way but that's I really wanted to
address I didn't I don't really want to
address this part and that might be
something that may not be well received
I think I really wanted wanted to deal
with the practicalities of the move
rather than the E let's say the
ideological reasons for I do that but
I'm personally committed let's say I'm
personally committed in saying that you
can create powerful very powerful very
simple and I'm saying simple not in the
sense that the left sophistication but
they actually are easy to develop a in
Java EE and you would gain a lot for it
for adopting that's my this mapping all
right
yes unfortunately because a lot in a lot
of cases if you if you are fortunate
enough to gain approval for a full
migration of your application it's fine
you can migrate your applications
forward but a lot of times a petitions
will migrate that easily you don't get
to spend time on already on code that
the existing that and works if you have
a full application rewrite then by all
means go for java ee we discover that
with a lot of our users it's not always
the case they would like to migrate
gradually and start developing in java
ee but but keeping some of the older
code just because they cannot really
they cannot spend they cannot be in two
places they cannot do the migration in
implementing features and they're paid
for implementing new features so they
adopt the the adoptive AE while having
the by having the opportunity of action
integrate it's a it's a practical
problem happens a lot of times
I can show you how can use cocaine use
code side by side and I could show you
that the code actually that you have
side by side that the job that CD I code
is actually not that different so the
beans themselves are not that different
I would say that if you if you're
interested like Bert Bertman and a poll
Bakr have done a very good talk on
showing exactly the migration process
step by step I really didn't want to get
into the let's say in repeating that
what they said however they didn't talk
about the tools themselves and I really
want to demo these tools and these these
technologies go into more depth in what
can use now if you want to test
applications in container you have tools
like arquillian that actually provide
you a very good way like bridge
basically the gap that is between Joey
code and testing so basically if you
migrate to bore it's like if you start
using Java EE services with the inner
spring applications you can use actually
the same infrastructure as our Killian
and actually start tuning your your
applicator application applications in
your tests in container so let me just
show you a quick example of such an
Arcadian test
so this is a unit test let me just
increase them
this is an example of our tests written
without killing you can run it in any
application in any application server
you want right it's it's not different
like it's not very different than a
normal gene unit test what's special
about it is that you get to create a
test archive you put clep the portion of
your application that you want to test
you get to you get to put your
configurations in it and you start the
test
so you see the test here
actually starting the server doing the
deployments and essentially running the
test why insist on doing this because
this is exactly how you test your Java
code as well it's the same process the
same thinking you have differences in
what you're actually testing against but
basically you can imagine that instead
of an outer wired being you would have
here and uninjected ejb and it's it's
quite the same yes now it's a good it's
a good question it it's actually the
test itself is packaging that so the
question was what do I need to set up on
the server side to get actually it does
package the spring artifacts it packages
the spring dependencies and it resolves
them through maven yes I mean normally
you would create you would create your
you could what you could do is use the
modularity features and installed spring
as a as a shared library and I will
probably reduce the size of your archive
so that would be a good idea anyway but
we kind of try not to assume that you
did that you did that that's some sort
of a detail I mean it's not really a
matter you don't have to put them this
way
yes yes so basically after after you
migrate the code for example you would
have to hear just CDI beans no
dependencies because you have everything
in application server and it's the tests
that the cool part about all that is the
test is virtually this it looks
virtually the same if the beans are like
if the beans have injection capital if
you use something like if you really
look some if you really use something
like adding ject you can take a look at
the bean and not not know what it is
whether it's a spring beam or a java
evening you can have we can do it in
multiple ways so this is running this is
this is running it in a managed
container we can have a central instance
you can set it up for example for our
build tests like when we test many do
integration integration testing but
stuff like this we basically grab the
server through maven which is a maven
artifact put it in the target directory
and run it from the target directory so
basically have almost no external
dependency and normally if it's if it's
cached like if the artifact is cached
locally you have no problem with that
yes you can start other servers so you
can start glassfish that yes it starts
to boss yes yes you can see the console
yes so everything happens in about two
seconds
no depends depends on how you write the
tests if you if you have them like if
you want you can do that but normally
normally you would start it once run the
test battery so basically every every
test is a deployment yes now what
version what version of cables are using
first what version of cables are using
ok ok first yes let me just answer the
question the server is started once for
the test battery each deployment is
separately each test class creates a
separate deployment so you basically
have the server started once each you
can put multiple methods in the can put
multiple methods in the test class so
you can group as many test methods
methods as you want / deployment so you
can reduce the number of deployment of
of times for example the deployment
takes place by simply grouping the test
message together right so you have
options of actually reducing the
overhead of starting the application
server yes but what you don't get is
basically you don't get any hidden you
don't get to touch your runtime in any
shape or form and we find it sometimes
that's an issue because the test does
not reflect how the application actually
behaves in the on the server
you can set it up you can set them up
but it's usually you can you can set it
up that way too I think what you can
also do is for example just deploying a
running application sir deploying a
running application server and then
given that the overhead for that yes so
it supports it also supports it also
supports and running against so you can
pack it you can run against the server
you can run against and locally
basically just like sprint as does you
have this option but we prefer like we
see the real value of our killian
deploying into deploying into a java
application server like this is where it
actually shows the shows the real well
so now that's fine so for the last part
I just wanted to talk a little bit and
demo one integration between CDI and
spring which would be again one of the
one of the problems while you have that
you have when you do the when you try to
migrate the code very well basically if
you look at the two right it's very easy
to learn java ee for example if you if I
any files I said you understand
injection you understand the concept of
a container you understand the concept
of a B it's it's pretty much the same
it's the ideas that you create object
graphs based on a blueprint you have you
have the managed object which is a beam
both support standards like GSR 33
or which is at inject jsr 250 so
basically if I write a class using that
inject like here for example here I
can't tell what exactly what kind of a
beam is this it's very easy to
understand that's my point well of
course the differences are more about
mountain bounding the relationship
between spring and Java EE so spring is
basically something that lives on top of
Java EE services CDI is the job native
Joey component mob it's lighting
integrated by design this is and it will
become tighter as the specific that's
the java ee specification moves forward
so you get will get more and more cases
where components are injected by default
right things like i don't know injecting
a service into an jpa event and stuff
like that all this happens by default
it's managed by the container so the
benefit is that your code actually
becomes simpler and simpler and as I
said defining beans is very it's a very
simple task so basically we can any
class is essentially a managed bean and
participates in the injection process
including some of them or you can like
when you can't produce such class like
when you have classes that are coming
from other libraries using play like for
third-party libraries you can use a
producer method to actually create new
beads and that cleans up creates a bean
percent in directing a beam for example
is very easy you just use the add inject
a notation and again it's really really
easy to move across if you understand
how it works if you want if you look up
for concepts like more advanced concepts
like interceptors where you would write
an aspect in spring CDI allows you to
write very intuitively interceptors so
you basically can create an intercept
binding a special annotation and then
apply it on a specific method and then
specify what is the Interceptor that
will actually be applied on that
particular method so it's very it's very
easy to to create a to create a DSL
around your cross-cutting concerns again
another thing that CDI has its
decorators it's very simple to it's very
easy to if you have a class for example
decorators require an interface you can
actually create a class that decorates
this and basically add functionality to
existing class so the the development
model is powerful it's powerful enough
that this for example is a complete
business component so yes well it's
applied automatically so what happens is
that what I'm saying here is that any
instance of service that is managed by
the by the container will get this
enhanced service around it and
essentially the method do something for
example will actually execute and
optionally delegate to the wrap instance
if you want if you want to think of the
decorator think more of interception
based on interface right so you rather
rather use any you rather want to
enhance the classes that satisfy a
certain contract
so that because if you want sorry now
the annotation a decorator is basically
to tell the framework to treat this as a
decorator if would otherwise it could be
a normal be what happens what happens is
that wherever an instance of service is
a like wherever I do inject service
whatever I will get a decorated instance
I don't have to request and enhance
service in fact I cannot inject an
enhanced service you know so for
defining full-fledged business
components I really I guys came right
for example very easily an ejb so this
is a dependent service is a simple
powder doesn't do too much right an
event repository and then I can inject
it into an ejb I mean very often we use
ejbs or like ejb is basically the any TV
is a component that you want to use for
setting up things like transactional
boundaries perhaps security and so on
and moving on to like EJ like EG bees
are essentially much less one one point
to make here is that EG these are much
less verbis to implement than they used
to be in our previous versions right up
to Joey definitely less verbose than
before ejb three now come moving forward
that the specification is actually even
more permissive so in java ee 7 for
example you will see that transactional
attributes can be applied to any kind of
p so you have that option to if you want
this the only thing that you want to
have is transactions the point is that
you can
that one of the advantages of moving to
Java EE is exactly what i showed you can
very easily create these components and
it's very the programming model is very
powerful the question that remains is
okay why do I do with my existing cup
and there are various options right um
what I'm going to show you right now is
one component that we have developed for
in as part of the seam spring project
how many of you have used seen in the
past would have heard about it see you
now scene 3 has been designed not as
serious a successor to seen but more is
to provide a a set of extensions to CDI
at some point it became apparent that a
lot of other groups like the Apache
project created their own extensions so
rather than having everyone write their
own extensions which virtually the same
thing or with minor differences it's
been deemed better to create a single
project which pulls all of them together
and this is how the project Apache Delta
spike has come into existence basically
pulling stuff from c3 apology cody CDI
source and other contributions from the
community and this is basically the
future of this extension of this is the
future of this the extension that I'm
going to talk about but right now you
can exist in this form as part of the
scene 3 spring module what it allows you
to do is do two things consume spring
beans as CDI beans and vice versa so how
does it happen it's basically the
problem that we are trying to solve is
exposing like creating application
contexts and exposing spring beans as
CDI beans so that the injection process
can take advantage of them so what we do
here in order to do that is really we
can install
a spring be spring context as a CD I be
and we can acquire this context either
for example if it's bootstrapped from a
context loader listener or we can
bootstrap this from we can bootstrap
this from the extension itself right and
you look up with this file and to create
the application context wonder what's
the context has been bootstrap it
becomes a source of be so I can go and
say well I really I wanted to produce a
bean a user service beam which is in
fact the user service being from the
application context in the future like
in in future versions of the of the
framework we will try to automate this
process a bit more so that the beans are
imported automatically one of the
problem is that if the web context is
bootstrapped by the if the web
application context is bootstrap by the
context loader listener so you want to
keep part of your application still
working that happens after the CDI
container has been initialized so we
don't have access during the
initialization process and CDI is very
restrictive with respect to how to the
fact that dependencies have to be
available so basically it can create the
spin and I can inject it into a session
scoped be just like this in Reverse I
can do the same thing with spring beans
so I can if I'm developing for example a
component a specific component in CDI
and it just create it like this I can
simply reference it and use it within my
spring application so let me show you a
quick example
that's a good question you you will want
to avoid that you will want to avoid
that so basically what happens can I
don't have it actually but I can show it
to you it's actually a good question
i'll show you the demo yes so it's
actually a bit worse than that it's it's
not only that you want to get a
duplication in memory the problem is
that a CDI deployment will feed every
being every class it founds as a CDI p
so if you have a bean / do so let me
just sure it is quickly well I really
want to show you the code here because
it makes more sense the demo itself like
running the application you just prove
that it works but what I want to show
what I shall what I show you is this so
i have this user dao created by my
application right and then i have this
greeter that is using that is delegating
to this invoker object and the invoker
object is in fact a CDI be now what it
does the invoker object is also
consuming the user dao which is in fact
a spring be this is a kind of contrived
example it's a controller delegating to
a CDI beam which is delegating to a
swing beam just to demonstrate the
directional injection now the
interesting part is this
sorry
look at this veto annotation right this
is a cbi extension so that's not part
this is going to become part of the CDI
core specification but it's basically
using an extension that can prevent
beans from being installed into CDI I
really don't want to have a CDI beam at
this point which is a user dao
implementation because i don't have what
to do I don't have anything to do with
it when I migrate at some point in the
future when this code is going to might
be migrated CDI I will remove both these
annotations I will remove it as a
service so that it doesn't get installed
into one context and i will let CDI
actually take its course
so basically what happens here is you
see the CDI greets John Doe which
happens because the invoker sorry the
invoker here is basically processing the
call right right here and then the
invoker is delegating to this spring
mean or doing its job that's the whole
trick right now but it takes kind of it
takes a bit of work to get things set up
let me just show you how this comes into
place basically happens like this first
I have a context producer which tells me
what context should the extension use
for grabbing spring beans because this
is this is a working spring applications
i didn't want to remove the context
loaded listener altogether although if i
didn't need it anymore if my MVC stuff
was completely migrated for example i
could have simply put here a
configuration annotation and had spring
do that extracted from like had the CD i
had CD i had CD i do the bootstrapping
itself and actually there were the
advantages for that because CD i could
actually do the output vetting of beans
and could my extension could do more
much more because it knows that these
beans are under its control and then the
other option and the other thing is that
i'm creating this producer here which
creates my user da OB and installs it in
the installs it into the basically it it
is a producer field it's following the
produce produce resource producer field
pattern which basically what it does is
I let I let the you will see the number
in the application for example this is
actually injected this field it's really
done
by the spring extension the actual
instantiation of the object and
population of the field but once it's
there cv i will use the value in this
field to actually do the to do the
injection wherever a beam requests like
here so this is basically once you reach
this point you can start thinking about
really moving current from one side to
the other i want you to show these tools
because i really think that they are
useful like in general we get a lot of
questions about one or another of these
facilities so I think I've been starting
setting up infrastructure in Java EE
style testing in container migrating
code and basically using this migration
so thanks a lot if you have any
questions you're welcome I'm here to
answer your questions but if not then I
hope you had a great comforts thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>