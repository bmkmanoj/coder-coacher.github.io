<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Future HttpClient: A Sneak Peek into a New HttpClient API | Coder Coacher - Coaching Coders</title><meta content="Future HttpClient: A Sneak Peek into a New HttpClient API - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Future HttpClient: A Sneak Peek into a New HttpClient API</b></h2><h5 class="post__date">2013-01-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/xs1RXPaUOAA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay welcome to to our talk on the
future httpclient my name is Michael
McMahon and this is Danny cars will be
both sharing this talk so just just to
let you know that with some of the
detail on these slides there's quite a
lot of text on some of them and so you
might need to move a little closer to
the projector to or to the screen to be
able to see some of them so when I would
further ado I'll hand over to Danny to
to get started okay so it was funny
Michael and I both came to this project
independently Michael did a buff on this
topic last year that some of you may
have been at and then I'm working now
from the Java EE side we were looking at
new HTTP client library and then after
Java on last year we realized we were
both working on the same kind of thing
and this is how we this is what happened
so here's the safe harbor statement we
talking about some future plans so there
oracle lawyers makers put this slide in
says don't sue us if we get the date
wrong what we'll talk about is just a
bit of the background why we're doing
this we'll take a look at the new
features in this library for JDK 8 but
the bulk of the talk will be taking you
through the new API looking at API
methods and also some sample code to
illustrate how it works and then I think
we've got some open issues because we're
not this is a work in progress so we'll
cover those and then hopefully there'll
be time at the end for questions so I
know everyone here has used HTTP pari
you know 80% of people in the world have
used HTTP but just to frame things I
thought it was worth reminding ourselves
of the basic form of an HTTP interaction
you know it's defined by the IETF RFC
HTTP requests with request properties
here where here's just a simple post to
Espie we have a number of headers the
specification defines headers that
define metadata about what the request
is about what requirements it needs the
server to meet and then there's a
payload on this request message which
can be in you know multiple different
formats text images video etc and then
that gets sent to this the connection
gets established the first thing that
happens is the the request properties
and headers get sent to the server then
maybe you know maybe right after maybe a
little bit later the request body if
present is sent to the server when the
server has also think it will send back
the status of the response that it's
going that it makes whether it's okay
and then of course we all know there are
any number of statuses that mean lots of
different things but in general after
that the headers are transmitted and
then finally either right after the
headers or on demand from the client a
number of different modes depending on
the implementation the body is sent back
so here the the server wasn't very happy
so once the Queen to chop your head off
so this is the basic format we all know
that there are mechanisms with an HTTP
like redirects and security
authentication interactions that live
within the protocol but just to frame
this I wanted to show that this is a
request and response interaction model
and so now that sets things up for
looking at what we've got today in the
JDK we've got HTTP URL connection so
let's take a look at using HTTP URL
connection for this basic kind of HTTP
request/response interaction so in this
example and this is where you know feel
free to move closer to the screens
because we've got lots of small fonts
like this to try and illustrate code
might be more readable closer to we
create connection object based on a URL
from the URL of the weather connection
is going to be made to then we're gonna
set some headers here we're just setting
the content type of the request body to
be HTML on the connection class we
actually because we're going to put a
little request payload and request body
in we happen to have to set a flag on
this connection object to say I'm going
to put a payload on the request then we
connect then we open an output stream we
write the request body and then we close
that output stream then we look for a
response coming back from the server so
this is a blocking call here get
response code until the server has
responded then we can read the response
with a traditional iostream and we can
look at headers and so on in the
response object now this is you know
we've all written code like this I'm
showing you this because this is the
basic template for any use of HTTP URL
connection if you use it your methods
gonna look something like this it's just
gonna have you know different different
headers being set or different content
payloads being set and read and so on
but they all basically look like this so
let's take a look at how this works for
everyone the the problems using this API
are fairly well documented it's actually
fun to Google had the kind of complaints
people have about this API the first
thing to notice is that the the API of
this connection object is spread across
two classes in a hierarchy and to make
things worse the both classes URL
connection and HTTP or our connection
have lots of methods so if you're
looking around in the Java doc for how
to set a header there's a lot of you
know
you have to do you have to do a cast
here because the URL the URL open
connection method returns the super type
you have to cast down because we're
using HTTP when you set a header on the
connection you you're calling a method
called add request property on the
superclass but then when you read a
response header the method is called get
header field field so this because of
this the way things are arranged HTTP or
our connection trying to fit into this
more general framework you have some
inconsistent method naming so none of
these problems at the end of the world
in themselves but let me keep going
the next problem that people usually
find is that because this is a the
connection object is modeling in a
linear sense something that is a
nonlinear interaction we're crew you
know we're making a request we're
sending it to the server
we're expecting a response back and yet
all those different states the requests
being you know being formulated the
requests being committed waiting for the
response the response partially arriving
the response having fully arrived all
those different states that are inherent
to the protocol are modeled on a flat
linear single object with multiple
methods so it's very easy to call the
methods at the wrong time where you can
call methods too well let's take a look
at the example I've got here where as
soon as we call connect near the top
right under the try clause that commits
the request headers and sends those to
the server's so if you as in this
example I've switched around the method
calls if I try to set a header set more
of the properties on the connection to
do with the request it's too late
because I've already connected and
committed the headers to the server so
in this example as soon as I connect and
then I try to modify the request that
making these methods throw illegal state
exceptions to tell you you've done the
wrong thing at the wrong time and then
equally by calling get response code for
example on the connection once the
request has been committed that will
actually you know block until the
response headers are read by which time
if you're still in the middle of writing
to the request body it's too late and
you may not know this but in this
example here where we call connection
get response code the first highlighted
red line and then we continue to write
to the output stream to the request body
this actually fails silently
because the request output stream has
been closed by the implementation so not
only do we get you know inadequate state
modeling you get different kinds of
reactions from the API when you do the
wrong thing at the wrong time and then
of course Michael reminded me that the
history of this API was to support the
hot Java browser which is one particular
class of HTTP interactions which really
meant that they only needed at the time
blocking API for filling out the payload
of a request object and reading the
response object as well so the only mode
possible in this API is blocking i/o and
from any well even for browsers today
that are you know downloading text and
images concurrently in a website this
kind of blocking mode is not really
adequate and there are lots of other
modes that people would like to have so
this is all to say that while this this
API works for the common cases or worked
for the common cases probably ten years
ago it's not really flexible enough and
because it doesn't model well this
request response interaction that's
inherent in the protocol it leads to a
very difficult to use API in the sense
it's
easy to do the wrong thing at the wrong
time so I know you know I've you know
often tripped up using this API and it's
taken me a while to get everything in
the right place makes it not very
productive so I think I covered all of
these points in my example except to say
that the other drawback is that the only
protocol provider the only
implementation of the HTTP protocol that
this API allows is the one that's in the
JDK so if you have some super optimized
implementation of HTTP it's not possible
to slot it underneath this API and let
developers use that through the standard
JDK API so these were all issues that we
thought needed addressing and so over
the years of many other projects there
are lots of popular libraries that do a
really a better job than HTTP URL
connection of modeling HTTP
request/response interactions and here's
just you know a short list of some of
the more popular ones when we started
this project we looked at these projects
very closely and looked at all the
different perspectives they took on how
they would solve this problem just and
tried to bring you know the best of the
ideas from all of them there so that's a
bit of the background so just to now
talk about the new project we started
this is a work in progress although
we've been at it now for well almost a
year we have a stable I a the packages
java.net HTTP client we have working
implementation of the API together with
a number of tests so we've been you know
building the implementation as well as
designing the API it's on the list for
JDK 8 so we're you know working towards
deadlines for JDK 8 on this project and
for those of you on to download code and
look at it look at the API see it
working see some of the test code and so
on there
the link there we have a public java.net
project for this so the features are you
know primarily two equally to equal or
exceed the functionality of the existing
HTTP URL connection class to better
model request response interactions for
it to be easy to learn and easy to use
these are the sort of classic drawbacks
of the HTTP or our connection class to
provide more modes of operation
different ways of sending messages
asynchronously receiving messages
receiving payloads in different formats
and so on there are now lots of
technologies that build on top of HTTP
you know many of the web service
technologies build on HTTP we wanted to
make it easy for them to be able to
layer in their own content models on top
of our API so this led to us wanting a
filtering a formal filtering model as
part of the API we wanted to let other
people plug their own implementations of
this API underneath the API
perhaps suited to a you know a
particular environment or perhaps
optimized in some way optimized for a
specific architecture and then there
seems to be growing interest in the HTTP
upgrade our architecture for you know
protocol switching initiated by an HTTP
handshake and WebSockets is a really
good example of that so we wanted to you
know allow or have the API support that
kind of mechanism so now let's turn to
the main idea in the the new API so you
start with an application the first
thing you do is get hold of a client
builder from which your going to build
an instance of an HTTP client then the
HTTP clients job is to build request
objects for you and to do that it uses a
request builder the request builder
builds instances of HTTP
Quest's where you configure the headers
and the payload and so on in a variety
of different ways then once you've
formulated your HTTP request using the
request builder you pass the request
back into the client and one of the
execute methods and this opens the TCP
connection to the server sends the
request object
it's headers and properties and payload
in various different modes and then at
some later time when the server is ready
you receive a response back from these
execution calls on the client so every
use of this API looks something like
this you create a client you create a
request object you send the request
object through the client and you get a
response back it all looks like that so
you can see already we're trying to
model the HTTP protocol more closely
with an object model here and we've
added builders in for reasons we'll
explain a bit later so let's go back to
the old HTTP URL connection example here
that's very linear style connection
based API so the new code looks looks
like this so you can see at the top the
new package the first thing we do is
create the client instance from the
client builder then from the client
instance which is highlighted in blue we
create the HTTP request builder and then
on the request builder we set up the
headers and perhaps the body if we were
doing the body this is where we would
set up the body so in this case we're
just setting a content type on the
request builder and setting a simple
string into the request body and then
when we build on the request builder we
get the immutable request object that
we're going to use in this case we we
invoke the client object we call the get
response method on
client object passing in that request we
just made and this example shows a
blocking send we wait until the request
that the response object returns and at
that point then we can start examining
the state of the response and in this
example we just use traditional blocking
i/o to read the response payload back so
this a little bit like the example I
showed the old example this being the
template for every use of HTTP URL
connection this example is essentially
the template for every use of the new
API every use of the API looks something
like this it's a variation on this kind
of example so let's just look at some of
the high-level knobs and things we can
twiddle when we use this kind of
template we on the client builder this
is where we can configure client scope
properties and I'm going to talk about
them in a bit more detail but things
like the connection pool default
timeouts for making requests and so on
then on the request builder builder we
will you know twiddle with the request
scope properties like adding headers
configuring whether redirects work
perhaps overriding some of the default
client scope properties then we have a
variety of ways also on the request
builder to fill out the request body we
have push and pull versions streaming
setting with our just a simple byte
array and so on then on the client
object where we see client get response
we have a number of different ways to
send the response either in a blocking
manner or asynchronously and then once
we've got the response object we have a
variety of ways not
just blocking i/o to read the response
payload when it comes back so these are
the ways that we can vary things so
let's just take a look a quick look at
the main objects again the HTTP client a
builder that's the starting point for
the API this is where you build client
instances the client instance is used to
send HTTP requests and execute and get
responses back the request builder
builds and configures request objects
and then the request object that you
create from that encapsulates the HTTP
request the response equally captures
all HTTP response state and we have a
HTTP headers object that clearly is used
in both it's consistently used both in
the request and the response object to
give a you know consistent view of
header manipulation and the reason we're
using this build a pattern is so that we
can make sure that the the main objects
in in play during HTTP request and
response interactions are immutable the
builder has all the mutability and
that's done at configuration time but
once those objects are created there
then immutable this brings a lots of
benefits to developers they can be
accessed concurrently by multiple
threads it makes them very easy to to
debug once you have an immutable object
you know once the state has been set up
it's never going to change throughout
the lifetime of your program so if
you're debugging with immutable objects
it's it makes it easy you can rule out a
lot of possibilities for what might have
gone wrong then some of the secondary
objects that assist these main objects
in the API the handler objects so these
are callback objects that come into play
if you're using any of the asynchronous
mode of the API if you want to be
notified when the respond
has arrived from the server rather than
waiting on a blocking call then you
would use a response headers handler if
you want to be notified as the request
body is being downloaded in pieces
rather than waiting for the whole thing
to come down or waiting on a blocking
iostream you would configure a response
body handler if you want to be notified
of errors during the execution of a
request response interaction rather than
sitting on a blocking call you can get a
callback
using a response error handler so you
can be notified if there's a problem
rather than sitting and waiting to find
one and then we also have our filter API
for decorating for modifying request and
response objects request objects on the
way out and response objects on the way
back in and we'll talk in more detail
about about all these we also have a
simple API for configuring connection
cache we provide a default connection
cache in the implementation but we know
that people perhaps would like to
optimize that part of their
implementation so you can add your own
connection cache if you want to and we
have a little API for upgrade handling
all right so let's go back and look at
the API and a little bit more detail
again this is the main template the
client the request and response and the
builders that make them creating a
client builder there's really two ways
there's you know just creating an
instance of the builder but then also
useful once you create a decline
instance and you may have set up time
out properties or maximum buffer sizes
and so on it's useful to be able to
create a request builder using the
properties of that client so this is a
quick and easy way to create a client
build with an existing set of properties
that you've already set up for another
client then a quick tour of the helper
objects of each HTTP client instance you
can set proc
is here this is why you would set or
reset if you wanted to override the SSL
context this is where you would override
the that's a local this is where you
would override the HTTP connection cache
if you had your own implementation of it
this is where you can use the existing
cookie manager interface that's already
in the JDK to you know provide your own
custom cookie management so this is good
for if you've implemented one already
the way you set and configure filters
and this is where you would perhaps
override the default executor service if
you wanted more fine-grained control
over the threading properties then the
you know the more rather than helper
objects the more property level flags
here we have a you can turn on and off
pipeline mode you can set it to follow
redirects or not setting the request and
response body buffer limits that the
implementation uses timeouts and so on
and also usefully here this is where you
can select the implementation provider
if you want to so if you have somebody
else's whiz-bang Linux super optimized
HTTP client implementation this is where
you would ask for it then finally once
you've set all that up you call build
that creates the client instance and the
client instance can be then be used for
multiple request response interactions
all that will share this infrastructure
that you've just set up and then all
those helper objects and properties are
available as accessors as getters on the
client instance so just a quick example
here we just get the default client
builder we're going to set a proxy we're
going to you know allocate a fixed size
thread pool here we're going to use the
default connection cache but we want to
you know have an instance of it that
uses a certain
parameters for you know how many threads
it will cash and so on and and so on and
you can see in this example as we set
these helper objects and properties
we're using the fluent style we thought
this is a good fit for very declarative
looking code when really you're doing a
lot of configuration cause then the
requests ending methods are on the HTTP
client instance and there are two of
them one is send headers and the other
is send requests send requests is the
main sort of workhorse this is the the
asynchronous operation you are returned
a future object by which you can track
progress of the interaction and on the
HTTP request you may have configured
those completion handlers for errors and
body parts coming and request had a
response headers coming so you would get
callbacks then otherwise if you want to
do that traditional IO where you send
the request headers and then do a
blocking you know write on an output
stream of the request body we have the
second a highlighted in blue there send
hath headers methods that returns an
output stream to the request body now
the request bidder builder this sets up
all the properties of the request
objects from the headers the request
body any call backs for the asynchronous
mode operation and and any you know
implementation specific things like
timeouts and and buffer sizes that you
want to override from those clients go
properties and you create the the
request build the request builder from
the client instance capacity a URI
that's the starting point and here you
can set the method set the request URI
set the headers in a variety of
different ways we try to add some
convenience methods there again this is
fluent throughout the
Qwest builder also has other properties
like setting the time out the request
body buffer limit and here's the way you
can set up great handlers for doing
WebSocket upgrades for example a variety
of methods that I think Michael will
talk about in some of the code examples
better setting the body by byte byte
array byte buffer iterators of byte
buffers so you've got lots of push and
pull methods for setting the request
body I talked about the response
callback interfaces if you want to be
notified when headers arrived
when headers arrive back you you know
use the response headers handler
similarly as the body arrives in pieces
the response body handler at the bottom
and then in the middle the response
error handler to be notified when errors
come and these are all added these
callback handlers are all added on the
request builder as you can see in this
example we create the URI and then from
the client we create the request builder
passing in the URI and then we set in
this example we're going to set the
property so we have a get request with
some string as the post data we're going
to configure an error handler so that it
gets called back if there's an error on
the connection add some headers such a
30-second timeout on the connection and
then build and then we have a request
object
I'll just finish the algae's food we're
just working out where we're gonna hand
over and then the request API allows you
to access all these properties on this
immutable object that we just set up so
with that we've now set up the request
and then Michaels going to take us
through to all the other aspects okay so
basically the next dozen or so slides
I'm going to talk a little bit about the
different modes of operation with some
code samples so basically there's three
different things we're interested in
here at the different ways that you can
send a request and receive a response
and the different ways you supply a
request body to a request and then the
different ways that you can receive
response bodies so basically there's
three as Danny already introduced to
three different ways basic mechanisms
for for sending and receiving you have
the traditional blocking mechanism and
then the two new asynchronous mechanisms
using either callbacks our future
objects so we look at some examples in a
moment
and then the different ways that you can
supply a request body you can do it the
traditional blocking output stream
mechanism and we refer to that as a kind
of push mechanism what we mean is that
the application is kind of driving the
the data pushing it down to the stack
and out onto the to the to the network
and then second there is a so called all
at once mode and all that means is that
the application will provide the the
entire request body in a byte array or
an array of byte buffers and then
thirdly we have our so called pool mode
which uses either iterator byte buffer
or iterable byte buffer and I'll explain
the distinction between those two types
later on but basically the idea is that
the the application will supply one of
these iterator type objects to the to
the client and then when the client is
ready to send the request body it calls
back into the iterator
to retrieve the byte buffers one at a
time so for receiving response bodies
it's exactly the same basically the same
three the same three options for said
three different ways of receiving
response bodies either in and all at
once in a byte array or an array of byte
buffers are through blocking input
streams or iterators are then thirdly
asynchronously using callbacks so take a
look at a very simple example in this
case which is simply allocate a byte
array we call some method to populate
the array and we create a request
builder and set the body call asset body
method which gives the byte array to the
request builder and we build it and then
we just call clients and request them to
send that request so to look at the the
pool mode now so this shows an
implementation of an iterator now the
next slide will show a slightly more
realistic example but this slide shows
you the methods on the iterator
interface itself now we only use the
next and hasnext methods remove which is
part of the iterator interface we don't
we don't use it so perhaps in JDK a so a
default implementation of the remove
method will be provided and that would
mean then users don't have to implement
it so again what happens here is you
call set body which are it iterator
object and you call send request and
then as previously the implementation
will call back to the iterator and to
retrieve the byte buffers one at a time
using the next and hasnext methods so to
look at some better example perhaps of
how this might be used this example
shows a new type called readable by
channel iterator so this is a type that
we would probably provide as part of the
API it's a relatively simple
classless that's 25 or 30 lines of code
so but what it does is it takes a
readable by channel and returns an
iterator for that channel and in this
example here you can see we've created a
file channel which is reading from some
file on the file system so we create our
iterator from that and we call set body
with the iterator
and then send the request out so we've
we've an example showing the use of the
iterable type so what's the difference
between iterator and iterable well
iterable objects can return multiple
iterators so so the difference is that
in this context if you if your
application provides an iterator you're
saying here's a bunch of data and you
can read it once from start to finish
but on the other hand if you provide an
iterable what you're saying is you can
read it from start to finish but if you
need to read that data again you can
call into the iterable to get a new
iterator and then you'll be able to read
read the data again from start to finish
now that's that's useful in HTTP context
in certain situations such as say
redirection our authentication when a
request needs to be repeated and what it
means is you can avoid having to offer
the we can avoid having to buffer the
request body data if if the application
has provided one of these iterable types
because we know that we can go back to
the iterable to get a new iterator which
will will regenerate the data from the
beginning ok
I'm just going through this quickly so
just moving on then to some very simple
examples so this is a real simple
probably the simplest possible example
of sending a request in this case with
no request body so you can see we create
a request builder build a request from
it and then you can call client of send
request but the highlighted line at the
bottom then is is where the blocking
happens so the client we call client our
get response and so the the calling
thread just simply blocks at that point
until the request has been sent and the
response has been received so what if to
move on from that example say you want
to also do some blocking mode but you
want to send a request body but using an
output stream now as Daniel mentioned
earlier there's a slightly different
mechanism for that and you have to use a
specific send headers Carl and you can
see their ass and headers takes two
parameters and the HTTP requests that
you want to send out and second a
numeric value which indicates the number
of bytes that the are going to be sent
through the output stream so that could
be either a positive number which is an
exact number of bytes or it can be the
value minus one which indicates a an
indeterminate number of bytes and and
yet the caller can send any number so
once you get the output stream then you
can use the normal the normal pattern
then for writing through output streams
where when you're finished you call
close and as in the previous example
then you just call client target
response to to get the response to that
request so now we take a little look at
the the asynchronous interfaces and so a
little code sample here now if you
remember a couple of slides back Donnie
introduced the three handler interfaces
now these were defined as as three
separate interfaces each with a single
abstract method so that means these
interfaces can be used as
functional interfaces for for lambda
expressions so I just want to show a
little illustration of how lambda might
be used in that context so we start off
with a request builder and then we call
the on headers method with a little
lambda expression on the left hand side
of the lambda expression contains the
method signature for the the headers
handler mm-hmm and the right-hand side
and the expression is the block of code
that would be executed whenever the the
headers are received so then we could do
this exactly the same thing then for the
error handler as the left-hand side of
the expression is the the method
signature is for far the the error
handler interface and then the
right-hand side of the block of code
that gets executed when an error occurs
and finally the same thing for a body
part so so basically the block of code
there will be at will be executed and it
will have access to those parameters
that you see there so we build up build
that request and use the client to send
us now if you're not if like like myself
you're not 100% okay with with lambda
and exactly all the details and this I
just wanted to put aside in here to
explain the kind of equivalence between
this that lambda example and how you
might have been had to implement that
before so this this would have been
implemented previously prior to JDK 8 as
a Animus an anonymous inner class
implementing the HTTP response headers
handler interface so by using by using a
lambda expression you at least at very
least you you lose the boilerplate code
there which you also save the compiler
having to generate this extra class so
that's that's a small advantage
what you don't have to use use it with
lambda expressions you can use a
conventional handler class so for
instance here we have a class that
implements the three antler interfaces
you alternatively if your application is
only interested in one or two of those
of those handlers then you your class
only needs to implement whichever of
them that is interested in okay so
moving on quickly then to the other type
of asynchronous interface futures so if
it's if you think back each and each
example that we showed previously the
client of send request method was was
treated as if its return value was was
void but actually it actually returns a
future object so in situations where
where you don't set a handler where you
don't set callback handlers then you
probably do want to use the the future
object as a way of keeping track of the
response so that in this example we
store the future object in a variable F
and then sometime later we're going to
call F get to to get the actual response
object itself so we'll just take a quick
look at the HTTP response API itself
it contains accessor methods for all of
the things that you would expect to see
in HTTP response like the content length
content type response code and SSL
information if it's a HTTP connection
and then H HTTP headers objects and for
both the headers and if there are
trailers on the HTTP response and it
also contains a method which gives you a
reference back to the request that that
initiated this this response
and then so now we move on to the
mechanisms that are used for reading
reading responses so the first two
methods we look at here are blocking
reads that return the entire response
all at once so basically we have two
methods get body as byte buffers there's
two variants of that one where the
application will supply the array of
byte buffers and a second one where they
would be allocated internally and so
variants exist also for for byte arrays
so to equivalent or analogous methods on
HTTP response exists also for reading
responses into byte arrays and then if
you want to if you want to read the
response in in a blocking or streaming
mode then we have two interfaces here or
two methods here get body as byte buffer
source which will return an iterator
byte buffer or get body as input stream
which returns a regular Java IO input
stream so I just wanted to show on this
example how you can actually mix the
different modes here so so say for
example your application wants to use
the basic asynchronous mechanism but
what you also want to read the responses
using using an input stream maybe
because you have some legacy code which
only understands input streams so what
you can do here is you can see in the on
header is method the implementation of
that is checking for a response code of
to hundreds meaning okay and if
everything is okay then it calls
response ticket get body as input stream
and we got back an input stream out of
that and then the input stream is handed
off to some kind of a reader thread than
to to read the actual response body it
could be read in line and in the actual
header or the the the method you see
here are alternatively true through a
separate thread
okay so that's I wanted to move on then
to some of the other types in the in the
API so the first one that I want to
describe here is the filter API which
Danny described it earlier quite well so
basically I just say briefly that the
filters are blocks of code or classes
that perform application independent
processing on requests and responses so
they're organized in a chain or a list
per HTTP client so an application can
build up a list of filters and associate
them with the with the HTTP client and
then that means that every request and
response belonging to that client will
be passed through the filters so in the
picture at the bottom there you see the
kind of sequence of events so on the
left hand side you see a HTTP request
that would come from an application and
then it's passed through the filter
chain and then what emerges on the right
hand side is what gets sent out to the
server so the response comes back from
the server then and that is passed
through the filter chain and what
emerges on the left hand side is the
HTTP response that gets sent up to the
application so all of this is
transparent to applications the
application behavior is exactly the same
in regard whether or not filters are
installed or not so we'll take a quick
look at the filter interface itself
there are four methods on the filter
interface each and each will have a
default implementation so applications
are our filter implementers only need to
implement the specific methods that they
are interested in before a request
that's called once for every request and
it's given a request a HTTP request
under a modifiable HTTP headers object
if there if the implementation needs to
modify any headers second method then is
on request body part so this will be
called always at least once and possibly
multiple times depending on the amount
of day
that's being sent and this is quite a
powerful flexible API it's it's it the
the Methodist it's passed an array of
byte buffers and a flag boolean flag
indicating whether this is the final
call for this request or not so the
implementation can then it can look at
the the data and the buffers possibly
modify them possibly replace them
completely or buffer them store them
internally until the later call but it
must return so it returns an array of
byte buffers also and what's returned
from one one filter is basically passed
as the input to the on request body part
method for the for the next filter in
the chain so then we have the after
response method this is called once for
every every valid response and this this
returns this this is allowed to do a
number of things for instance it's
allowed to examine the if the response
headers are response codes and it can
decide whether to allow the response to
continue or whether to cause an error or
it also has the possibility to cause a
new request to be issued and sent out
transfer complete ly transparent to the
application again and in such a way that
the response to the second request would
be the one that the application
eventually receives and you have an
example of that later on and then
finally the on response buddy part
method is the exact equivalent to the on
request on request body part method it
works in exactly the same way so to take
a simple example of a filter this is a
real simple logging filter which you can
see here the before request method logs
the the request yet the request method
and the request URI and the after
response method simply logs the response
code and nothing else
and then the the on response body part
method it so this examines the returned
response body and alters in this example
is that it's it can't it can't it keeps
a bite can't so for across each call of
this method a bite can't is maintained
and incremented or updated with the size
of each byte buffer that's being passed
in and then in the final call when when
complete is true it it logs the the
total count at that point so it's a
quite a simple example we've just like a
more complicated example here were where
some simple modification of the body
might occur so you can see here this I'm
calling this an encryption filter but it
could be any kind of content
transformation filter so so this this
filter object could maintain some kind
of encryption state it's it's on request
body part method then allocates an array
of byte buffers and then it calls some
kind of external encrypt method which is
where it's given the input buffers and
top method generates a new byte buffer
which is put into the out buffers array
and then it's a array about their array
of ID buffers that's returned from the
on request by a part and then the on
response body part is exactly the same
except that it's calling a decrypt
method instead of encrypt so that
example just shows very basic
modification of data in a kind of a
streaming sort of a way this example
here shows a slightly more complicated
example and what we're trying to do here
is this is trying to illustrate a case
where in probably an unusual case but
let's say the filter wants to read needs
to read the entire request or response
body and based on the content that it
sees it prepends that content with some
kind of a header so that's that sounds
like something that's quite difficult to
do in a filter
the way you would do it here is that the
you allocator linked lists are some kind
of storage structure for the for the
byte buffers and in every call of an run
request body part we simply add the
incoming byte buffer buffers into the
storage linked list and we do whatever
whatever calculation or thought that is
needed to to generate the header that
we're looking for and in all cases were
where the complete flag is false then we
return null so what that means is that
the filter is not not returning any data
it's not passing any data answer the
following filters in the in the chain
until the very end
so when completes when this is called
the last time when complete is true it
it generates this special buffer which
contains the header that were interested
in it prepends it to the beginning of
the list and then returns the entire the
entire list onto the remaining filters
so it's it's kind of an extreme example
but it just gives you an idea of the
flexibility and power that powerful
things that can be done and finally the
final example for our filters is I just
go through this very quickly this is a
kind of a partial implementation of a
redirection filter so what it's only
interested in the response so it
implements the after response method it
checks for a response code indicating
redirect it creates and you a new
request based on the current request but
what sets the request URI to the
contents of the location header which is
a standard thing to do for for redirect
and then it calls this special new new
request method on result which is
telling the system to send out a new
request and wait for that response to
come back before sending the response up
to the application
okay so that's everything on filters I
just want to go briefly just mention
briefly a couple of other classes or
interfaces in the nd API that perhaps
most applications won't need to use but
HTTP connection cache is one which
allows a certain amount of
configurability of TCP connection pools
and keepalive behavior and if you can
see at the bottom of that slide there we
have we have a concrete implementation
of that class so that's probably going
to suffice for most purposes but if you
had need something more specialized then
you would need to implement this this
interface so the first what's
highlighted there at the moment is is is
a sub interface which provides the view
that cache implementations will have of
connections and that's that's so this
shows you the information that the cache
has of connections and what it can use
to to define its its strategy for for
for caching and then the the cache
itself then just implements these two
methods return to cash and get
connection and the client implementation
calls these two methods to put
connections into it into the cache and
then to get to retrieve connections from
the cache and then the final class I
wanted to mention is the HTTP upgrade
Handler this is it's basically an
implementation of the upgrade the
generic sort of upgrade mechanism in
HTTP but and it's will be used for
protocols that use that mechanism like
like WebSockets so it's kind of similar
to the filter API in that the upgrade
hound our HTTP upgrade handler has
methods like modify request and examine
response so that allows as a handler to
add in the special headers that may be
specific to this to their protocol and
it also allows them to examine responses
to make sure that the expected headers
in the response have have come back and
then finally set connection is called
this this is where the client hands all
over the the TCP connection
to the protocol implementation such as
such as WebSockets and then again and
then you have the upgrade connection
interface itself and that that shows
what the protocol implementations such
as WebSockets can do so it can call a
get channel to get an asynchronous buy
channel or it can call get input stream
or get output stream to to provide a
blocking raw channel for reading and
writing bytes so this is the final slide
or the final topic only two slides just
a brief word on security permissions in
this API the permission checks will be
similar to the existing client in terms
of the checks would be done in the same
place for the same kinds of things but
will be we will be using a new
permission class instead of socket
permission it may be called HTTP
permission or URL permission or
something like that but it's a
higher-level permission class than
socket permission which will be more
suited to two HTTP usage so things like
proxy access socket permission is still
needed for that and then there will be a
number of new nap permissions then for
specific things like setting and getting
caches or filters or upgrade handlers so
to show an example of what the in a
policy file might look like with with
one of these new HTTP permissions so you
can see here a grant of a HTTP
permission to some URL food @ www.viki
/i
and then the it lists the methods that
are allowed so what this what this
permission is granting is that whoever
has this permission is allowed to do
gets and posts to any URL below this
this path so that's the kind of a higher
level and way of specifying permissions
and then the way socket permission
worked previously
so finally just to repeat what Danny
said earlier the source of the API it's
it's all freely available even prior to
being it hasn't been integrated into JDK
8 yet but we've been using a java.net
project initially for for for managing
this but you can say you can download
the stuff from there if you want to look
at it the API has nearly complete Java
doc and you can use it and try it out we
also discuss the the API it's not 100%
complete yet and so discussions take
place on the net dev alias there number
of open issues we still have to define
an authentication class for free lists
that and provide an implementation at
least of basic and digest authentication
and we also have to complete the these
security permission work I think that's
it
there's any questions we can take them
now yep
yes so the question was what about
closing of resources that that there
wasn't any examples shown yeah we do
have a closed method I don't know
whether it's must be I think it's an
HTTP response but but there is a closed
method there which will which will close
off resources and yeah I think response
is also implementing Auto closeable so
that that whole mechanism works as well
no not out of the box in not in the JDK
but we as part of the WebSocket project
will probably provide an upgrade Handler
and implementation of that interface as
part of that in part of the client side
of the WebSocket project yeah yeah so
what happens if you try to connect to a
host that doesn't have a DNS record yeah
well connection error is any kind of
error we didn't show the exception
mechanism all that well but I mean if
use in blocking mode it's clear enough
some kind of exception will just be
thrown from the blocking method itself
but but the on error method if you
remember that if you're using
asynchronous mode that has a throwable
parameter which will contain whatever
exception caused the thing to
exactly yes yes and the same through the
future Madame mechanism as well there's
also a way of getting execution
exceptions from that also yeah that's
the plan that's the plan is to include
in JDK 8
so the question is is to do with SSL I
mean okay in general to do with SSL we
we we implement SSL using the SSL engine
class so we defer everything to do with
SSL - that pup - the whole Java X don't
necessarily provided enough folks to
configure everything that needs to be
configured and but we don't do any SSL
specific stuff in our in our own code
yeah I'm actually not really qualified
to answer kind of SSL specific questions
yeah that's an interesting question SPDY
yeah we have we there's two things there
we have two we'd like to we want to be
sure that the API will fit the speedy
model yeah yeah so so then if that
assuming that that's the case then it's
it's just a case of somebody
implementing providing an implementation
and I we didn't really go into the
service provider part of this API but
there is it's a fairly simple mechanism
to load you can have multiple providers
even running at the same time for
connected to different clients so it
should be possible to do things with
that yeah I think we've run out of time
actually so we're probably available if
you have any more questions outside
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>