<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Field Guide to Java Collections | Coder Coacher - Coaching Coders</title><meta content="Field Guide to Java Collections - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Field Guide to Java Collections</b></h2><h5 class="post__date">2013-02-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/PZl_0URd8Qo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon I'm Mike do we go I'm the
speaker for this talk I'm a member of
the Java core libraries team I work
maintaining the existing collection
libraries as well as I'm working on the
bulk data collections extensions which
are coming for lambda in Java 8 this is
a talk which is mostly about hopefully
finding new things about the existing
collection classes that you already know
and use it's not a tutorial there's an
assumption that you haven't had exposure
to most of the classes that we're going
to talk about but hopefully we'll have
some interesting things to say and some
tidbits you may not have known before or
provides new ways to think about the
collection classes you're already using
in some cases maybe provide alternatives
to the choices you're making now with
other collection classes that may be
more suitable for the problems you're
trying to solve so we're going to cover
some of the classes or many of the
classes pretty quickly and not a whole
lot of depth we'll just be covering the
more interesting points of the
particular classes and we'll take a you
know small detour to collection classes
outside the JDK I will be posting the
slides to my Twitter feed there will be
a link on there I had it on the initial
slide it will also be on the Q&amp;amp;A slide
at the end so all you need to write down
is the Twitter handle that's on the very
last slide everything that's on the
slides will be it will be will be there
as I said we're going to you know look
at the collection classes through the
through the lens of the interfaces that
the various collection classes implement
many of the classes implement one or
more interfaces and interfaces are the
normal mechanism used for describing how
the particular characteristics of that
implementation behave so there may be
more than one implementation with
different behavior different performance
characteristics different space
characteristics but they'll be generally
categorized by a common interface that
describes an overall set of common
behavior between the very
implementations and we're going to be
looking through the individual classes
in the context of the interfaces that
they implement the collection classes
that are provided by JDK come in two
fundamental shapes the first of these is
what our have it as their root something
called collection which is just a group
of objects in various ways that the
objects are organized a grenaded other
other properties to how they're handled
but fundamentally it's just a group of
objects the second shape in the Java
collections is the map shape where you
have a pairing of a key object and an
Associated value object and again it's
just an aggregation of multiple key
value pairs so those are the two
fundamental shapes within the Java
collections we'll move on to the map
shape which as we've said was it as a
mapping of keys to values now the keys
in a map are distinct in that there's
only one instance of a given key within
a map the values need not be so in this
example we have two items which have a
value of dairy both milk and cheese can
be classified as dairy products so that
there's duplication of values but not
duplication of keys beyond that great
we'll see those slides again beyond the
characteristic that keys are unique and
values can be anything not much as said
in the basic map interface about the
characteristics of the data in
particular and basic map interface what
type of objects the keys are or what
type of objects the values are is not
part of the definition the basic set of
operations on a map are quite small you
can get an item by its key or get the
value by its key see if a particular
value or key is contained within the map
remove a key and then there's operations
for putting key value associations of
the map either bulk or one at a time the
map interface even though it doesn't
have any direct association to hashing
is the reason that the hashcode method
appears on object many of the of the map
implementations are in fact based on
hash maps and as a result that's why
object provides hash code so that the
map implementations of sturbation on
hashmaps can in fact utilize that in
their implementations one thing to
mention about the hash code
implementation will make a few other
comments about it as well is that if you
put a map if you put an object in a map
it's absolutely critically important
that it's hash code value not change
well it's in the map the reason is is
that the hash map implementation will
take the hash code value of a key decide
where an object goes in into the map and
place it into the internal tables based
on that hash code value if the object's
hash code then changes and you try and
look it up again it won't be found in
the correct location than the internal
tables so you can affect lose an object
in a map but if you change its hash code
value or its compared to
violation so it's generally well it's
absolutely necessary that you not change
your hash code value for the object well
as installed into a map or set so the
first map implementation we'll talk
about is hash map and as we said it's
based on hash tables and it is one of
the implementations that uses hash code
is backed by a bucket array the location
of an items locate or the where an item
is placed in this bucket array is based
on this hash code and one thing that's
pretty important here is that because
the map doesn't actually choose the hash
code for an object instead it relies on
the object to provide a hash code value
the objects have to provide quality hash
code implementations if you defined an
object whose hash code result every time
was four and then tried to make a map of
them the map would still work assuming
your equals method behaved properly but
everything would end up in the same
bucket so high quality hash code
implementations are absolutely essential
for quality map per hash map performance
if you don't provide a good hash code
you're gonna get order and behavior in
which case it's kind of questionable as
to why you're using a hash map at all
one of the other things about hashing is
is that because the keys are stored into
the bucket array based on hash code
indexes which are essentially random and
there's something called rehashing when
the table needs to be expanded the
iteration order of elements in the hash
table isn't predictable and in fact in
7u6 and Java 8 it will become less
predictable so if your application has
assumptions on how
SMAP ordering which as it turns out that
there are a lot of applications that do
if the order of iteration changes either
because the implementation of hashmap
changed or because the table expanded at
some unexpected time let's say you had a
table that for the last ten years have
had five elements in it and you were
very used to those elements iterating
out of that hash map in a particular
order and you add a sixth element and
all of a sudden the hash tables
re-indexed well they now come out in a
different order in the 7u6 or something
called alternative hashing which does
randomize the hash locations and we
found that there were actually quite a
few cases in JDK where there were was
code that had an implicit assumption on
ordering of the other results coming out
in 76 and later it's can become less
predictable so start looking at your
applications for places where you might
have either explicit or implicit
assumptions on ordering in general as it
turns out the smaller and more stable
hash map it's more likely that there's
actually an implicit assumption examples
would be things like service loaders
where it's loading services that have
dependencies on each other and if the
service is loaded one time you said okay
it works if the iteration order now
changes in the services load in a
different order they may be
prerequisites that aren't met and now
all of a sudden the services crash yet
that was a hashmap with let's say only
five entries in it so it's not
necessarily big hash maps that have that
problem generally when you get to you
know a couple hundred elements you no
longer have a particular order for the
elements in line so you you you stop
making that assumption but anyway start
looking for that in your applications
linked hash map is a way to get a
particular order to the elements in the
map and in
the order of the element iteration is
the order that you inserted the items
into the map and linked hash map is most
often used for LRU caches so that when
something is referenced from the map you
remove it add it back in so that it's
now at the head of the list and whenever
you run out of space so you you
reference an item that's not already in
the map you eject the oldest item in
order to fill a map in some people are
surprised that even though the linked
hash map provides an iteration order
it's not a sorted map it could be
considered a sort of map if you
considered the sort ordering to be an
off object or something that memorized
the fact that what the insertion order
was but that wasn't mean to be a
priority for this particular structure
so they decided not to make it a sorted
map you know it does have an order but
that order is not a sorting but it's
still nonetheless useful for those
applications another type of map that's
actually in JDK is we cache map it's
also used for caching and like linked
hash map about a different kind of cache
most often is used for in combination
with soft references where you want to
cache something that if the VM runs out
of space it has the opportunity to eject
it and/or its caches for things that
have weak keys so that as long as
nobody's referencing it or as long as
some of these referencing you want kept
in the map if if there's nobody
referencing it anymore you want the
whole thing to be garbage collected we
cache map provides functionality is
specific to that so again it's primarily
useful for specific cache uses identity
hash map is a map which is really
unusual it's probably the most unusual
map type and there
it's most unusual in that is that it
doesn't use the equals operation or hash
code in order to determine equality of
entries instead it just uses identity
equality and it's mostly used for very
specific purposes of things like
serialization where you need to maintain
an object graph and another example is
deep copy where you want to not copy the
same object over again if you encounter
it you just want to insert a reference
to an object you've already copied
otherwise you could have if you had a
list that contained another list that
contained the original list if you don't
keep track of which objects you've
already copied and linked them back in
when you make a copy you just end up an
infinite recursion of copying the same
list over and over again so I didn't any
hash map useful for situations like that
that words were it was originally
developed for but there's one other
common use for it which is that if you
have to associate some metadata with a
particular instance of an object
identity hash map is a good way to do it
so you you put you make a map at an in
any map that has the objects you're
interested in and the associated
metadata for that object in a in the
value field very occasionally is used
for things like interning but it's not
always advisable for that and you have
to have kind of pre planned ahead quite
well in order for the identity hash map
that to be useful as an intern map but
occasionally people find the performance
beneficial sufficient to make the
trade-offs worthwhile here we go again
that's one penalty of using a VirtualBox
to present from PowerPoint on a Mac is
that sometimes misses keystrokes yeah
we're in the right place a new map is a
specialized map which the key type is
actually a Java 5 enumeration and the
reason you'd want to use this over a
regular hash map with just the
enumeration of the keys is that it's
very space efficient it essentially just
has a table of the values for a table of
the values and can doesn't actually have
to store any of the keys so if your key
spaces can be described by the
enumeration or already as an enumeration
a new map is a very useful thing there's
been requested in the past for this to
be a sorted map because enumerations in
fact do have an order but that wasn't
part of the original implementation the
choices to do that predate me and I've
never been able to find out why it
wasn't made into a sorted map but it's
been requested and it is possible that
in the future it will be upgraded to a
sorted a sorted map ok so if you started
with Java at earlier days the map type
that you used was called hash table and
it actually predates the collection
framework and was retrofitted into it
the kind of subheading bullet is is that
some people still believe that hash
table is faster and generally they
provide a benchmark that proves it most
often these benchmarks turn out to be
one of the two instances that they're
comparing is rehashing one more time
than the other one and that mostly has
to do with the thresholds that the two
classes being compared don't have
exactly the same rehashing thresholds so
one come you know they usually that's to
say Oh hash tables faster well if you
look it's at
thousand items there for hashmap
rehashed one time more than a hash-table
if you go to 20,000 Island items now
hash table has rehashed one more time
than hash map and hash tables now slower
so be very suspicious of benchmarks
where hash table comes out ahead of hash
map in the general case hash map
generally are almost always wins as with
any you know sufficiently complicated
data structures always corner cases
where some alternative will win but in
general there's no particular good
reason to be using hash table anymore
in particular one area where hash table
is weak and this was done in order to
preserve iteration order from very early
implementations so that you know if
applications have assumptions on
iteration order they didn't want to
change those so they didn't change the
way key distribution that's done if you
have a bad hash function hash table ends
up with far more collisions than hash
map which kills performance so in
general hash map is going to have where
almost every circumstance hash map is
going to have better performance than
hash table if you know one reason people
do use hash table is that all the
external methods on that are
synchronized so you don't have to do the
collection synchronized map in order to
get a concurrent a concurrent map if in
fact you're using a highly concurrent
application you should look at using
concurrent hash map instead concurrent
hash map is similar in internal
implementation to hash map except that
the array that contains the hashing
buckets has in fact been divided up into
multiple segments so that when you're
doing operations on that table mostly to
our operations which mutate the map the
operations are redirected at a
particular segment of the map so let's
say a map is divided up into eight
segments if I'm in fact inserting in one
and
moving if I'm removing one element
inserting another it's highly likely
that those operations will end up in
different segments of the map when that
in fact happens the two operations don't
contend with each other for concurrency
they the two operations can in fact
happen simultaneously so for higher
concurrency applications concurrent hash
map is a better choice than then regular
hash map or definitely hash table and
there can be some surprising things
about concurrent hash map related to the
basic hash map type one is is that
concurrent hash map like most of the
java.util concurrent classes is allergic
to null it doesn't allow either null
keys or null values to be put into the
map there's a very common pattern which
can be used however where you substitute
an object that you create ahead of time
for null within the map if in fact you
do need to install them all under the
map if null is in fact you're standing
for your default object it's better just
to create a default object and install
that into the map as either a key or
value rather than using it all anyway
one one benefit of not allowing nulls is
that normally when you look at a regular
hash map if I say get key and the value
that comes back is null did that mean
that there was nothing in the map for
that key or did that mean that the value
for that key was in fact null I can't
tell the difference with regular hash
map I have to call contains to find out
if there was a Association for that
particular key and if there is no
associate if there is an association
then I can get the value and say oh the
value is no because concurrent hash map
can't contain null if you call get and
you return to null that Keys not in the
map
there's a big difference between the
iterators for regular a hashmap and
concurrent hashmap regular hashmap
iterators are something called fast fail
which means that if you create an
iterator and start iterating and
meanwhile somebody changes the map while
you get concurrent modification
exception indicating that the map state
has changed while you were iterating and
the existing hash map treats that as a
you know essentially a programming error
that you modified it while you were
iterating concurrent hash map doesn't
view it like that instead it's iterators
are consistent while you're iterating
which can have surprising effects in
that if you do something like check the
size of the map create an array and then
try and copy all the elements into the
array with an iterator well when you get
to the end of the list of elements you
may have already done you may already be
beyond the end of the array or you may
find that you haven't reached the end of
the array the other example would be if
you create an iterator then call it
contains on the map for a particular
element and it says no and then you
start to iterate through the elements
you may in fact find that element or not
because the map can be concurrently
modified while you're iterating through
the elements as long as you're you know
not assuming that certain things like
the size of the collection don't change
while you're iterating or particular
elements are in and out during the
course of iteration you'll be ok but
there's there's fewer assumptions you
can make about the state of the
collection while iterating using again a
concurrent hash map concurrent hash map
instruments a different interface than
concurrent than regular maps which is
called concurrent map and the reason
that concurrent map exists is because
there are a couple operations that if
they didn't if I weren't defined in this
concurrent map interface you would have
to enclose the concurrent hash map in a
synchronized block in order to be able
to do them and these are all atomic
operate
that if I want to do something like
check to see if a keys already in the
map and if it is just leave it alone
otherwise put this key into the map
that's a two-step operation first is
check the map do some boolean logic and
insert in the map if I don't have this
can this put if absent method and I have
to do it as two discrete operations
somebody may be able to sneak in between
those two operations and the answer that
I can that I come to will essentially be
correct and the other ones like remove a
particular key if it has if it has a
particular value also atomic operation
and the replace operations where I
replace a key only if it has a
particular value with a new value again
I would require multiple steps in order
to do that operation without this atomic
and I definitely don't want to have to
add a synchronized layer and on top of a
concurrent hash map so they added this
addition additional interface beyond
what basic map interface provides in
order to provide these atomic operations
and there's actually two math classes
concurrent hash map and concurrent skip
list map that implement this concurrent
map interface beyond the basic map type
so another map type you know extending
the basic map interface is the sorted
and navigable map and the difference
here from the basic map type is that the
keys are now sorted they have a
particular order and the in addition of
the keys being in a particular order the
iteration order is now specified so when
you ask for the elements you're going to
get them back in their sorting order
there's not going to be a random
unpredictable order like it was for the
basic map interface but beyond the
iteration aspect the other key advantage
to sorted map is that you can now create
sub views of the map that makes sense by
specifying a particular key range saying
I want all the I want a sub map that has
everything below this particular value
or above there's your headset tale set
or head mapped tail map sub map
specifying a range that you get a sub
map view out that is just the range that
you specified that is in fact a few of
the basic map so that you can then hand
that back to another part on other piece
of code and if it makes modifications to
that sub map that will be reflected in
the in the overall map as well so the
partitioning features are actually quite
useful for sorted Maps oftentimes you
don't really care what the ordering is
but the sub map the ability to do
partition but partition sub maps is just
as useful as ordering now I had on that
slide you know reference to navigable
map and there's two structures you know
sorted map now the coupled map well
what's the difference in fact they're
providing essentially the same
functionality sorted map was around
first and then they decided that there
was some additional functionality that
they wanted and they added navigable map
in Java six because of the well all of
the existing implementations which
provided the sorted map interface tree
map etc we're in fact upgraded to the
navigable map interface so you can use
those navigable map features on all of
the classes which were originally sorted
map and they're quite useful example
would be lower which is that I want to
find an element whose the the the
element whose value is the that's in the
map there's the one next lower than a
particular value so if I say I want
whatever elements in the map is below
2.0 you'll hand me back whatever
element that is I don't need to know the
exact value of it to extract that
particular element previously you would
have had to do a head set our head map
on the element with 2.0 you get back a
map and then extract the last item from
it lowers a lot easier than that and
again because the existing classes were
upgraded there's no reason not to use
map navigable map in all cases unless
you know you're still having to maintain
with compatibility with Java 5 you might
as well use a navigable map in Java 6
and later and you'll probably find that
you can get rid of some crufty iteration
code that was doing things like
effectively doing things like lower and
inclusive inclusive head map and tail
map that in the old sort of center
interface so one of the implementations
of of navigable map is tree map it's
bred but black tree order and order log
in operation for mancine contrast to the
hash implementations which are order one
it doesn't this is a kind of a strange
mapping that conditionally supports null
if you use it in the default sorting
order which sorts the items in the map
according to their according to the
comparable interface which the compare
to method you're not allowed to use null
because it's unspecified as to where
null would fit in the sorting order if
you provide your own comparator function
that handles no then in fact you can use
null in the keys for a tree map but it
is kind of odd for some people that
sometimes you can use null sometimes you
can't with this particular class
concurrent skip last list map is a
concurrent implementation of the sort of
navigable map interface it if in fact
you're doing heavy concurrency kind of
along the lines of concurrent hash map
it's a much better choice than using
premised sorted map or synchronized
navigable map on tree map and in fact if
you have you know massive concurrency
where you're you know have many many
threads modifying a map simultaneously
concurrent skip list map is can actually
be better than concurrent hash map and
the reason is is that the contention on
nodes is only blimp is only comes down
to the node ahead and behind a
particular know that you're you're
inserting or removing whereas in
concurrent hash map the map is divided
up into segments so the contention space
in a concurrent skipped list hash map is
much narrower but it does have a higher
GC pressure for the way that it create
if you're doing a lot of operations to
insert and remove it generates a lot of
garbage which is a frequent complaint
about by the people who use it for
therefore is high concurrency
characteristics but there's not really
much in the way of alternatives because
it is the highest throughput our highest
concurrency our highest throughput in it
is the highest throughput in very high
concurrency situations and again it
doesn't support an all keys their values
like most of the other java.util
concurrent implementations so we started
off with map which is probably a kind of
a strange place to start them this is a
collection stock we're gonna actually
talk about the collections classes now a
collection in its most fundamental state
it doesn't actually say too much about
the objects that are in the collection
if we look at this example we've got on
the screen here we got fruit bread and
milk meat are those items ordered do we
know our duplicates allowed well there
aren't any duplicates in this list but
maybe they are allowed maybe they aren't
are these in fact ordered in any way
don't know the basic definition of
collection is actually quite vague
and the outset of operations that are
provided on a kind of primordial
collection that's actually quite small
you can add it an item to the collection
but how what the semantics of ad are is
not completely clear you can check to
see whether somebody's in a collection
that one's pretty obvious and you can
remove items this is one of the
collection interfaces that has no actual
implementations all of the
implementations for collections within
the library actual actually implements
sub sub interface of collection there is
a type called a bag or a multi set which
we don't provide an implementation for
in the JDK that would in fact implement
the collection interface directly but as
it turns out as it happens we don't we
don't provide that so if you've got a
collection and it's got a fairly limits
of operation you know one of the key
things about collection is that it's not
defined by what it does but it is a bit
defined by what it doesn't it doesn't
say anything about ordering it doesn't
say anything about duplicates it doesn't
really say anything about mutability and
there's nothing really said about
concurrency either all of those
decisions are in fact left to the sub
implementations and if we look at an
inheritance hierarchy we can see all the
supplementation's that provide
specialization of those behaviors and
answer some of those questions as to
whether duplicates are allowed ordering
etc but we don't need to look at this
this inheritance hierarchy just for the
specialization cases we can also look at
it for the commonality that's expressed
here it is useful to for example you
know pass something as a collection when
I don't care about the
you know I don't want to expose the fact
that I used a particular sub interface
like list or set if all I want to do is
find the intersection of two things the
fact that the implementation of those is
a particular type may be irrelevant
so it's advantage advantageous in some
cases to ignore the differences between
the actual specializations in order to
have more generality of the operations
that are performed upon it and the most
general operation isn't even in fact
part of collection it will be part of
the iterable interface where it says
just give me an it or iterator for those
things and iterables kind of even a more
primordial collection and that doesn't
even provide the opportunity to add and
remove items or check for individual
items with container or even compare to
two things
it just says give me a way to enumerate
all the items in this in this container
and that that's really useful to be able
to numerate all the things in the
container the fact that it happens to be
an ArrayList or a set or whatever in
those particular cases I'm probably not
interested in that characteristic all I
want is the items in the list so there's
advantages to the generality and we'll
look at look at shortly at some of those
first of them being that if you're doing
variables and if you're defining
variables and fields it's advantageous
to specify the type of the field as the
interface rather than the implementation
the reason is is that if for some reason
down the road I wanted to change to you
know a linked list or something like
that because of some performance
characteristic I would now be free to do
so and if I had something like the next
situation where I have specified an
ArrayList in a method parameter I can
now
use any of the other list
implementations I'm stuck with having to
provide an ArrayList and it would be
really inconvenient if I happen to have
something in a linked list on this
calculating method only took an
ArrayList and I had she had to convert
the linked list to an ArrayList in order
just to pass it in it's better to use
the root interface type or Co is more as
generic as possible
Minh ever you specify these things so
that you have the widest variety
collections that can be used one
interesting trick that I kind of
discovered over the last couple of years
is that if you define an interface like
this here where you have some method
taking a type and returning a type this
looks pretty straightforward I've
avoided this problem of ArrayList where
I'm not specifying a particular type the
problem is is that if I if I have an
ArrayList and I want to keep it an
ArrayList because I'm using it in a
particular circumstance where the
characteristic of the ArrayList is
important if I have this definition of
sort the for the first definition sort
what I get back is the list and I can't
assign that to ArrayList anymore I've
lost the ArrayList characteristic of it
by calling this method there's something
you can do with generics which is to say
that a extends list of string and then I
say a in the return type and a and bar
for the parameter type now whenever I
pass a list to this sort method the type
that I get back from the sort method
will in fact be the same type as the
type that I passed in so that allows me
to do something like passing an array
list as list and assign the result to
another array list but that can be
pretty useful to not lose the type
information that you had by passing it
through a method and you'll see that the
JDK collection classes for things like
sort in fact use this exact declaration
for return types that they generate
summary of the this kind of section is
that if you don't need some
characteristic of the particular type
you're using go for its more common
ancestor you're going to gain generality
which we in the long run will will pay
off so we've we're now going to continue
through some of the collection classes
we'll go on with said said is a
collection class that does not allow
duplicates for each item in the
collection it's only allowed to appear a
single time the items in the set are
also not ordered so in this particular
case we have a particular ordering of
fruit bread no need etc if I were to
regenerate this set they might be in a
different order but that doesn't that
doesn't matter or shouldn't matter up
here we go I'm sorry about that quite a
ways that time
there's not much to say beyond the fact
that items are not ordered and the
iteration orders not find and there's no
duplicates allowed there's an extensions
of set which are the sorted set and
sorted map that we'll be talking about
and one thing that's kind of neat about
said is that there's a utility which a
lot of the set implementations are in
fact built on existing map on
plantations like will see sorted map etc
are sorted set that's built on sorted
map there's not a complete Universal
congruence in that in that there's not a
concurrent hash set but there is a
utility which allows you to make a set
from any map type so if you have some
other map type you can you can make a
set out of it
specialized sets we have an enum set
we've already talked about a new map
this is very space efficient for just
enumerations
but if your data is not an enumeration
you can't use it it essentially comes
down to a bitmap which you know for
reasonable size sets can just be a
single word which is you know there's no
external objects that are linked out
like there would be on another map type
is highly efficient so if you haven't
looked at Inu Maps or enum sets go ahead
it actually supports enums bigger than
64 items as well that's the second
implementation and in that case it's an
array rather than a single long for the
bitmap but enum sets are quite of quite
efficient hash set we you know mentioned
that that many of the of the set
implementations are based on map
implementations hash set is in fact
based on hash map linked hash sets in
fact based on
linked hashmap used in similar ways for
for LRU caches we're gonna move on to
sorted set now and like mapping the
partitioning is in fact one of the key
values of having a sorted set not just
the fact that the items are ordered but
being able to partition them teresa is
the implementation of of set that's
based on tree map it has some of the
same it has the same restrictions
regarding whether you can include nulls
in it or not if you provide a comparator
that handles null you can use nulls
otherwise you're not able to concurrent
skip list set it does it is sorry it
does have an association with concurrent
skip list map you don't have to use the
collections set for a map but it is in
fact based on concurrent map some of the
surprising things about it you know that
our mentioned are that like we had
talked about with concurrent hash map
the iteration the the things you're
iterating can change while you're
iterating them not the individual
element but you know an item might not
be there later on in the iteration that
was there at the start of the iteration
one thing that's really odd about
concurrent skip list set is that most
people are used to being able to call
the size operation on the collection and
have that be a relatively cheap
operation for concurrent skipped list
set it actually has to enumerate all of
the items in the set and because it's
enumerated it might change concurrently
while it's happening
in order to generate the result from
size in general though if in fact you
are using a current list gift set
concurrently the size operation as a
result is almost meaningless because you
can't really say at what point that this
structure actually
have the size anytime you go back and
look at it again the answer might be
different so size is not only more
expensive to calculate than you might
expect but it's also less useful with
the concurrent skip list set and that's
also true of concurrent skip list map
we're following we finally got two lists
which you know some people may have
thought we should have started there but
we wanted to mix it up a bit so we start
with we end up with lists nearer to the
end
unlike set items are ordered whatever
order you put them into the list is the
order that they're presented and you're
allowed to have duplicates list has some
variety in implementations and one of
the key differences between the
implementations is that some allow
efficient random access to the items in
the list others do not we'll cover that
there but there's an interface that is
used in addition to the basic list
interface called random access to
describe whether a particular
implementation allows efficient access
to indexed items within the collection
ArrayList is one of those random access
implementations it's probably the list
type that most people are hopefully
using in almost all cases and hopefully
very familiar to everyone there is
another ArrayList which can be a bit
confusing and this is provided by the
java utils array class and this is
actually a specialized list
implementation for wrapping an array and
then presenting it as a list it's kind
of odd but it has exactly the same name
as ArrayList and you can get the two
confused on occasion and that can lead
for some head scratching because in fact
arrays hash lists a rate list has
different capabilities than an armor
ArrayList the most noticeable of those
is the fact
size is fixed there's no way to shrink
or grow it the array that backs an array
an array z' arrays list can't be
modified or it's truck can't be
structurally modified neither shrunk nor
grown you can still modify the list so
if you want to set a particular element
to a different value that's still
possible with this type of list but
structural modifications aren't allowed
and you know beyond the watch out for if
I'm having some problem with an
ArrayList why can't I modify it why did
I get a unsupported operation exception
when I just tried to do something
totally normal an ArrayList well look at
the class name signature and make sure
that it's not one of these that someone
snuck in on your on your code because it
certainly can be confusing
we're going to jump fairly quickly here
because we're running a little late but
copy-on-write ArrayList is a specialized
type of rayless for for concurrent
modifications
the main idea here is is that whenever
the list is modified a copy is made and
the advantage to this is that if you
have a structure where you're doing
mostly read operations in iterate and
and iteration operations it provides a
stable list that those operations will
complete successfully you're not going
to run in concurrent modification
exceptions and other threads can
continue to modify the list well while
you're iterating it this does come at
the cost of those modifications copy the
backing array of the list
so that if you're making a lot of
modifications on the list it can end up
being quite space inefficient that does
generate a lot of garbage but if your
usage is dominated by reading and
iterating copy-on-write can be very
useful because it avoids having to block
people who want to make modifications to
the list until you're done iterating
them or having to make copies of the
list just in order to be able to iterate
it usefully utility class vector is the
counterpart to ArrayList its main
difference would be that all the public
methods are synchronized the performance
trade-offs between it and ArrayList
ironist dramatic as they would be
between a hash table and hash map in
part mostly because hotspot is magic if
a list is if a access is uncontained
'add hotspot is able to basically omit
the synchronization steps that would
otherwise be required but there's not
much there's not much good reason to be
using vector anyway you might as well
just use a collections synchronized list
on an ArrayList
linked lists not backed by Narae instead
it's a linked list of elements it
doesn't have a random access capability
so that if I want to index into the list
to get the fifth element I have to
actually iterate through the four the
first four elements honor to get to
their the main advantage to this is that
there's no size bounce like there is
with ArrayList and linked list also
supports additional interfaces of queue
and deck so that it can have much better
performance or it has much more
versatility than than ArrayList now we
will move on to queues simplest one
would be array deck it is reasonably
space efficient but it's not highly
elastic so if I have cases where the
size of the cube grows and shrinks
radically array deck is not going to be
the best choice priority queues the one
caveat on priority queues that you must
pay attention to just like hashmap is is
that if the priority of the item changes
while it's in the map you have to remove
it and re-add it the map are the
priority queue will in fact be
inconsistent if you would change the
priority of something while it's in the
map and the results are unpredictable
and and this is one of the most common
problems with priority queue is that
somebody changed the priority of an item
while it was in the queue this is a
specialized linked queue type mostly its
advantages latency it's not a blocking
queue that the there's another two type
which is mostly used for concurrent
operations which is the blocking queue
and deck operations and what's meant by
blocking here is is that if I'm trying
to push an element into the queue and
there's no space I'll block and wait
until space is available the same it
happens on the removing elements
the queue or deque is that I will block
until I element becomes available
because I'm blocking it's absolutely
essential that this be used concurrently
if there's no one else coming or coming
to add elements to the queue or remove
them I'll end up blocking forever so
these realities operate these blocking
queues really only make sense used in
concurrent situations I'm afraid it
actually killed the whole presentation
that time that didn't happen any of the
rehearsals of course
arrey block eq is the most simplest one
one characteristic that's important here
is something called fairness if I have
many threads inserting and removing
elements let's say I had 100 threads
inserting elements in one thread
removing elements in the random case the
threads which were trying to insert
elements would dominate the behavior and
would be difficult for the one that's
removing elements ever to get around to
removing them the the the people trying
to stick things in would completely
overwhelm it in the fairness if you use
that option it adding and removing
elements is done in a round robin
fashion so that the longer you've been
waiting you know it's first-come
first-served for adding and removing so
that you're able to make more progress
in situations where it's unbalanced it
does have somewhat lower throughput
because you have to keep track of what
order the adders and removers are came
arrived at though at the queue for their
operations but it doesn't show progress
in the unbalanced case I'll turn it up
to the array one is a link one based on
similar to a linked list and the main
difference here was would be that you
don't need fairness because they're add
remove operations happen at opposite
ends of the queue so that they're not
contending with each other again like
the other cases of array and linked
lists the main reason to use a linked
structure would be the fact that this
structure is unbounded or optionally
unbounded Doleac use a specialized queue
that you can't pop the item out of the
queue until after a specified delay
occurs this can be used very much like a
priority queue but for time oriented
things you set a delay of not before
this particular time
so it's a specialized queue synchronous
queue is you know some people may not
call this a queue at all it's in fact a
handoff mechanism where you had fact
have to have a a pusher an element
pusher and an element receiver in the
same place at the same time in order for
an element to be exchanged there's no
storage for elements elements don't sit
in the queue unlike all the other queue
types but this can be useful when you
must know that handoff has occurred when
your thread returns the item has in fact
been handed to the other thread so we're
just wrapping up the collections library
is not going to be enhanced
significantly in Java eight to add new
collection types or major or there's
some performance improvements to the
existing collection types but the new
area that we're mostly working on for
Java 8 is to extend the existing
collections to support the lambda
functionality and that mostly involves
extending the collection so they can be
sources for the bulk data operations
including where appropriate parallel
operations and so when you get the
collection since you have eight most of
the collections you're going to see
other familiar ones but I don't know if
you hopefully you saw some of the lambda
talks and/or checked out the videos
later on because when Java 8 comes
around you'll be using the connect
collections that you've been using in a
very different way and a lot more
parallel than you have been using them
in the past so that's actually quite
exciting coming for Java aid
there's beyond the jdk collections
there's some other collection libraries
which I'll take it you know short
moments memo mentioned the the quota
tech the text in grey is quoted from the
individual websites of the products
you can find them at the links and if
you need the length
don't try and write them down just get
the whole presentation off my Twitter
Twitter stream
Goldman Sachs has provided a very rich
collection library the one thing that
makes it very attractive is that they
have collections on primitives which are
somewhat more space efficient than the
collections we're providing in JDK but
they have more they're more specific of
less generality than the collections we
provide one of the criterias for JDK
collections is they have to be of
general appeal we haven't necessarily
found a need for having a map that has
keys that are only doubles goldman-sachs
on the other hand probably has a great
use for that so their collections
library has Maps keyed by doubles the
primitive doubles not the the Box
doubles that you could use with a
regular Java map so they have quite an
interesting collection library here and
including some parallel implementations
that use fork joining another one which
a lot of people probably heard of
already is the guava collections library
which is provided by Google and in fact
guavas more than just collections
they're now branching out into files and
preconditions some designed by contract
functionality and character set mappings
and other things like that but there's
some interesting collection stuff in the
guava collections that aren't part of
JDK there are a few things in guava that
will in fact be bringing in to Java 8
but it won't be any of the big
collection types that they provide there
have been a proposal to add some of them
but so far we haven't found any that we
absolutely needed to bring in so what
we'll be bringing in for Java 8 is
mostly just very small utility functions
that we think are useful and we'll go to
questions and that
address right there is my Twitter stream
where I'll be posting the slides and you
can also grab the links to the glava and
Goldman Sachs collections there so we
have any questions we have probably just
you know one minute
unfortunately but the outside go ahead
sorry well they're maintained that's one
difference trove does provide primitives
collections and there are people who are
using them but there hasn't been much
maintenance on trove recently my
understanding is is that the the Goldman
Sachs guys think they're pretty close to
trove in terms of functionality and
they're they're doing maintenance and
working on performance more so applying
more resources performance than we're
ever applied to trove</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>