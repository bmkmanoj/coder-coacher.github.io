<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>OSGi in the Cloud: A Case Study | Coder Coacher - Coaching Coders</title><meta content="OSGi in the Cloud: A Case Study - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>OSGi in the Cloud: A Case Study</b></h2><h5 class="post__date">2013-02-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/oN3jYKOQ1Tk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm a fellow at luminous technologies
and also a committer at Apache and
member there so I'm heavily involved
both in commercial and open source
software developments my Twitter handle
is on the slide so if you want to get in
touch that's the way to do it and my
co-presenter will introduce himself Paul
so I'm basically working right now
besides that I'm also work on a bunch of
open source projects
I'm working on a budget age I'm working
on I'm down to some JBoss related
projects and I do a lot of this kind of
talks so well yeah sure for what so
let's continue okay and so the case
we're going to look at today is an
education educational system and we're
just going to show you show you a little
bit what it's about
not because we just want to as well show
everything and us because that's not
really interesting we're going to focus
on the technologies using and it's being
build on but just to give you an idea
what kind of application in this I just
want to tell you a little bit about what
it is so it's in a system that we are
using in dutch high schools and which is
focused on personalized learning so the
problem you're seeing in education is
that well students especially in the
netherlands well they're just sitting in
a classroom and they're not three
learning the best way they could because
everybody is everybody's doing the same
and it just has to well do all the same
stuff and it would be much better if
they can actually well loonatics that's
right for their level right for their
interests right for their learning style
and well our system is focused on
helping them with that and besides that
give teachers a lot of control and well
monitoring students about how they're
doing and how well learning for them
could be improved um so this whole whole
system is based on the concept of
profiling and recommendation so when
after
whenever the the student is using the
system we are well profiling that
so we're basically doing what Google
does everything you do we save that you
store that data for later use
and after that well we can look at the
students look how is how he's performing
it will analyze his learning style and
will analyze what modularity modality
preference he has if he likes video or
text for example and depending on that
people well adapt the learning and make
sure he gets but the best experience fit
for him so that maybe we just try to
give a better learning learning
experience and if you're going to look a
little bit closer at the application we
have some well difficult requirements
you could say first of all we have to
work with different devices if you're
looking at the schools we are working
with right now
some of them use iPads well okay that's
that's okay we could use from iOS
application but some other schools just
want to use desktop applications or
laptops some other schools use Android
devices and now we're looking at Windows
7 for example yeah so we have all those
different devices that you have to deal
with and that we are running on which
well it's challenging at least the other
thing that we have to deal with is
scalability there's a lot of students in
the school and they all will start
working start working together at the
same time with our system which gets a
lot of loads on the on the systems on
the other end if school's out well
everybody just goes home and well maybe
some of them will do some homework but
well the load on our system goes down a
lot so we have to do with it because you
don't want to pay for all those servers
all the time one of the other things you
have to deal with is that different
schools have well slightly different
requirements some schools use different
strategies depending learning styles for
example and other schools will use
another way of dealing with that so we
have slightly different versions of our
system and yeah well we have to manage
that somehow
and the other thing you have to deal
with well we were just starting to do
this and have you get a lot of feedback
and we have to be able to have a fast
feedback loop so when we get a new
request or five bucks we have to fix
them quickly and go back to production
production in easy way although we work
at a lot of different schools and a lot
of different servers so this our
requirements which are nuts well that's
special I think there are a lot of
applications out there that have similar
requirements these are requirements
which will make things a little bit more
complicated at least to just give you an
idea I have some screenshots of how the
application look like this is a
dashboard it's based on OpenSocial I
will tell a little bit more about it
later later on and it's completely built
in html5 that's the only way that you
can make sure that it works and all
those different devices that we have to
deal with so this is a picture of an
iPad but it could be just a laptop for
example Android device so from here and
the students well that's different
let's say applications that you can open
to for example start looking at these
lessons so right here you see biology
it's all in Dutch but this is biology
and there's a list of learning goals
that he should be working on and the
list of learning goals is well dependent
on his progress at a particular
particular time those pictures that you
see at the right top that's learning
objects that students can open to just
start working on some learning content
for example doing some exercises or some
tests on the other end we have teachers
who want to monitor students I want to
see how students are doing and want to
see if well their profile is correct for
them they want to see do they still make
progress or should I change something in
their profile so they will get different
learning learning materials for example
- well make more progress and this is a
process that is changing all the time so
here we can see how this progress is
going for for a particular students and
there's a lot of information in there
but well this is just an example of the
things you
get from the profiling information so
let's take it to Marshall for this
exactly so Paul has quickly introduced
the system to you guys and you probably
already see it as this is something
that's that's quite new it's it's an
area that hasn't been thoroughly
examined and developed yet so we're kind
of threading into new territory here
building on an application where upfront
design doesn't always give you the best
results because what we try to do that
and try to look for people who know
everything about this domain and who can
tell us exactly what our requirements
should be but those people are hard to
find you're doing something new so
you're sort of inventing things as you
go along and nobody can tell you exactly
when you're on the right path or the
wrong path so what does that mean for
your software development process and
the way you architect your software well
the best solution we found was to
process-wise stay very agile use scrum
as a methodology work in two-week
iterations make sure that every two
weeks you deliver a new version of the
software get it in the hands of teachers
and students as quickly as possible and
just get feedback from them and we
learned a lot and there's a lot of
things that we didn't think of to name
some trivial stuff we created this nice
iPad application and we had lots of lots
of girls complained that the buttons we
made were too small for their
fingernails to hit the right button
that's that stuff you don't think of
upfront and that's that's a rather
trivial example of course there were a
lot more fundamental things that we
learned from from this experience but
the process has been one of feedback and
evolution taking small steps and keep
trying to find the right direction for
this for this application and we're
still doing that
today so how do you do that in your
codebase how do you deal with this
evolution with this change you have to
find a way that allows you to change
basically any part of your software
easily because there's no really fixed
parts of it everything you're doing well
you might be re-evaluating its
refactoring it and changing it a couple
of months or a year from now so we have
to also make sure that in our
architecture we do the right things to
to stay agile and part of the solution
for that is to apply modularity which is
nothing really new and nothing specific
to iti mean modularity is all around us
all the engineering disciplines use it
in some form and it makes a lot of sense
for us as well to use it and to make
sure that through modularity we stay H
out and we can change our building
blocks and and tweak them until we're
confident that it's really the right
solution so modularity basically gives
us a way to isolate changes to make sure
that once we're developing and changing
one module these these changes don't
ripple into other parts of the system
and well there's always some influence
on our modules because no module will be
completely independent of of the rest of
the system but at least all these
dependencies are well thought out and
it's very predictable if you want to
change something it's gonna be quite
easy to do and quite easy to overview to
have an overview of the impact of such a
change and some examples of big things
we've changed I think halfway through
the project so far we changed from using
a semantic database to a database
MongoDB which works completely different
and because we had the proper
abstractions in all our different
modules
for dealing with storage and for dealing
with doing all kinds of queries on this
data we could easily transition from
from one system to the other and we even
had a time where we were both using both
of these systems next to each other some
modules were still using the old system
some were already using the new and I
don't think we could have done that as
easily without applying modularity and
having all these abstractions so in in
our code base so that has really helped
us so far the other thing we quickly ran
into and Paul has briefly mentioned that
already we're deploying to different
schools and well this isn't specific to
schools probably everybody who is
deploying standard applications will run
into the issue that even though it's a
standard application it might not really
be that standard you might get customers
who demand some small changes and
changes that shouldn't be applied to
other customers might be possible to
completely solve that by just adding
some configurable options in your
codebase but if they're bigger changes
it probably means you need to somehow
fort the codebase and that means a lot
more maintenance if you have three four
or five of these Forks
so also through modularity we can try to
isolate those changes and maybe create a
different implementation for just one or
a couple of modules instead of having to
fork the whole codebase and that has
worked really well for us as well we
have of course different requirements
from our customers and we have a couple
of modules and a couple of configuration
files that are different for them but in
general we can deal with that and it
doesn't cause too much development
overhead for us testing those and making
sure we keep everything up to date there
so looking a little bit at modularity in
practice how should we do that what
kinds of issues are there to to look at
well a couple of things I want to
briefly mention obviously you have to
decouple your modules by defining
interfaces and make sure you design
those interfaces well that's always a
challenge because you're trying to make
a system more flexible and allowing
alternative implementations of some
piece of functionality and you really
have to push yourself hard to not have
implementation details leaking into your
interfaces because if you if if you
start to do that switching from one type
of database to a completely different
type of database it's still not going to
work so yeah that's something you really
need to take care of another thing is
well obviously separation of concerns
make sure that each module does only one
thing and and doesn't do a couple of
things at the same time that's that's a
very obvious one and another reason for
separating something into modules might
be the rate of change not everything in
your project will evolve at the same
speed if you look at more traditional
architectural layers where you have the
database layer at the at the bottom then
some business logic and then maybe a
user interface most of the time from
bottom to top things will change more
often if you get more to the top of the
application user interfaces change every
couple of years there's new cool
libraries there's new devices to support
so that stuff keeps changing business
logic well a little bit businesses
change their environments change
databases don't change that much but
well the example I just gave we switch
databases already within a year so those
things can change as well and that's
something to take into account when
designing your system and break
it up into modules yep a semantic
database is basically a triple store are
you familiar with that you know if not
I'm probably best to yeah okay
we used sesame for that yeah okay so
those are some things you need to take
you into account when designing a system
so I've been talking a bit about
modularity and I think probably most
people who have been designing systems
have been applying principles of
modularity to their software
architecture for a long time already
where things might not be as as as
modular is at runtime at least in the
past I've experienced a lot of times
that you had an architecture it was
clearly defined different layers
different modules so on paper everything
looked great just in practice when you
start programming Java in the end you're
throwing everything together on the
class path and that means that in theory
you could get all kinds of dependencies
in your codebase that weren't really in
the design so enforcing modularity also
at runtime might be a good way to to
really make sure that your design on
paper matches your design in encode and
there are other tools as well that help
you with that some of you might be
familiar with the tool called structure
101 which can analyze your source code
and sort of make a graph of all the
dependencies that are in there and you
can even define some rules about what's
allowed and what's not allowed and
through that sort of get a report on how
good your codebase really is compared to
your to your design so there's
definitely other tools as well but we've
been using OSGi as a modular runtime
and just to give you a very quick
overview of that oh she really leverages
the standard Java jar file as a module
and in that jar file you can stick
obviously lots of classes other
resources and by default
nothing is shared so everything that you
stick in the module will be only visible
to other code that's running in the same
module if you want to share something
you have to make that explicit and you
can do that by sharing at the package
level the Java package level certain
packages and usually that will be the
packages that contain your interfaces so
you only share your interfaces but not
your implementations and by doing that
and by also importing interfaces that
somebody else might have shared you can
be very explicit about what's okay to
use for others and what's not and that's
enforces your modularity at runtime so
okay
I've talked about interfaces that's cool
that's cool as a way to decouple stuff
but if I only have access to an
interface and not to the class that
actually implements this interface how
do I instantiate it I still need an
instance to talk to in Java in order to
invoke methods I can't just talk to an
interface if there's nothing behind it
so we don't do that by just
instantiating that wouldn't work but
instead we have a service registry which
is sort of the man-in-the-middle where
you can on the one hand register
services and if you need them you can
look them up there so this is just a
location where you can find all the
available services at that moment in
time and once you have it you can invoke
methods on it these interface of these
services are very fast method calls are
just direct method calls there's no
marshaling going on
so it's really lightweight and you can
really make a lot of fine grained
services that way without impacting
performance
so a typical OSHA application might have
hundreds of services that's that's not
an issue that won't slow anything down
so that's OSGi really really fast
and I'll hand it over to Paul to see how
that's being applied in this application
yeah let's take a look at an example and
we're going to look at all several
different views of how this application
is built but let's start with Justin
well a typical layered architecture and
as I told you our clients the the device
we work with we use html5 so most the
client related stuff is all working in
html5 in the browser on the client
itself
the later internet and that's the first
Java layer it's all restful web services
so we have our clients directly talking
to restful web services and what that's
the step to do the java roles those
restful web services are authorized
services by themselves and our business
logic and data access layers for example
are also our services we run on top of
Apache Felix but you could run on well
any kind of our CI container but to use
Felix M for stores we use mongrel for
for most of our stores and for binary
file storage you use Amazon s3 because
that's very run um then you see on the
left there's also um data and that is a
well a platform or a framework we are
working on so open source and there we
work on OC our components which makes it
more easy to create cloud like
applications so we have for example
support for multi-tenancy we have
support for using MongoDB in an OCR
world we have support for restful web
services using jax-rs and all that kind
of stuff is in under two and it's just
well perfect for everyone for you to use
and we'll show some more examples of
that later on
if you can take a look at how the
modules are well separated there's this
enlarged overview which is completely
unreadable but I will swim into that of
all the modules that they define these
are high level modules so there are a
lot more bundles a lowest level then you
see here but this is like high level
modules and if you soon zoom in a little
bit
these are modules that we have to find
that we well say these are functionally
tied to this application so it's all
educational related bundles or modules
so for example we have something to
provide content we have something that
does the profiling a recommendation for
for content we have a profile surface
where we store the
student profiles cetera solutions all
kind of well functionally separated
modules on the other hand we can look at
some more technical modules and this is
all part of a motto and here we have for
example
jax-rs so support for restful web
services we have something for MongoDB
we have something to work with blob
stores these are more technical
components but you see this role just
separated and once again these are just
high-level definition of modules and
let's take a look how they could look
like closer to codes so once again I
have an overview of the layered
architecture we have our user interface
which is all JavaScript then we have our
REST API and mvf from other Java OCI
services to go for example to the
database or to talk to Amazon s3 each of
those blocks you see here are all CI
bundles and are always represented by an
ocean surface so in this case we have
one ocean bundle that contains the Java
Script just for a small part of our user
interface in this case just one gadget
on open source and export that does
something with content we have one rest
rest of web service endpoint it's just
once again in our CI surface in our
bundle and just as one thing it's just
about doing something with content in
this case and if you have another
functional
like profiles then we have just well the
same laboring with the same kind of
bundles but they are all separated of
each other so fee change something on
the content was just about content it's
not anything other than that if we zoom
in a little bit more we will see that
our gadgets the thing that runs on the
on the device just uses HTML and I will
use Ajax to communicate with our rest
restful web servers and ports and it's
very well possible that one gadget uses
several rest endpoints because we might
want to have something about content we
need to show some content but to show
some content we might also want to have
some information from the user itself so
then we also use a profiling for example
to store what the user is doing and
remember all of those are just Ostia
services except for the one on the very
top within a restful endpoint we don't
want to have any business logic and the
reason for that is that it's very well
possible that one risk at one osseous
surface talks to another or judge
surface to actually well in this case
decide what kind of content the show to
decide what kind of content to show to
the user
that's something the content sequencer
is doing we have to go to the profiling
data store to get some information about
what the user has been doing before so
we push that kind of functionality down
a few layers implement them and
implement them as Oranje services and we
can both well give them back directly as
data to our gadgets using REST API or we
can communicate to them using Java API
so all those Java API so if you have to
find for oshiage services you keep them
pretty much stable so of course we start
to build a new one while we start
playing with the API to to figure out
what what's the best API for it but
after that we try keeping keeping a
stable and if and when we changed from
what Marshall said from a semantic data
store to Mongo we didn't even have to
change the interfaces and that's one of
the really nice things about using OCR
services and using molarity this way you
well you you
separates those different concerns and
if it's two men once more there's just a
very small part of the application but
you see here a few bundles working
together so the content sequencer itself
for example is no GI surface and it
communicates to other ocean surfaces but
it will not talk to an implementation of
a surface but it will just talk to an
API and to make sure that we don't have
to update our API so whenever we change
an implementation because that would
break break modularity we package the
API sin separates our bundles you can
keep them stable we never have to update
them and we can just plug in different
implementations in there there it is
even more important if you have to have
different implementations for different
schools for example so you see that all
those OCI bundles re very small there's
not a lot in there we just create a lot
of them and that sounds like a lot of
work but it really isn't if you have the
right tools to do so this is very easy
just comes naturally it just gives you
an example of how many bundles you could
have in just just some system in system
we are talking about today we have 138
bundles in a deployment and 80 of them
are bundles that we created specifically
for this application the other ones are
part of either on data or Apache Felix
or some other kind of framework related
bundles this number is going up very
very quickly the one 138 is already not
correct anymore very close to one and a
70 or something at the moment so every
time we add something well you will have
some new bundles so and that's really
not a problem it's easy to manage like
this yep so well we're steadily updating
the number of bundles and just to give
you a sort of reference I'm sure you're
familiar that the Eclipse IDE is also
built on Ohi I don't know if anybody
ever looked inside Eclipse to see how
they implement OSGi and how many
bundles they have but we haven't reached
the number of bundles they have that's
like four five hundred or something like
that depending obviously on the amount
of plugins that you install in new IDE
so that's that's pretty normal for an
OSGi project to have that many different
bundles I wanted to shortly focus a
little bit more on data which is sort of
the engine on top of which this
application is running and just zoom in
to some of its features and how we've
applied them and just to give you a
brief overview of what's in in ambato
paul has mentioned some of these already
we have jax-rs support backed at the
moment by mostly apache wink but some
other tools as well we have support from
MongoDB we also have support for
Cassandra for example which is another
no sequel solution we support different
blob stores and for that we base our
work on what J clouds gives us which is
a nice abstraction on top of many of
them so we try to leverage that we've
implemented a system for transparent
multi-tenancy which is really cool
because it allows you to use normal OSGi
bundles and just by redefining their
metadata a little bit and make them into
multi-tenant aware bundles which means
that not only for example in your
database can you leverage multi-tenancy
but also in your business logic for
every tenant for every customer you can
use slightly different business rules if
they can still be supported by the same
code with different configuration for
example and that's really cool because
you can take a lot of existing bundles
and just run them in such a multi-tenant
scenario we've also included options to
have search capabilities and there
obviously we're leveraging stuff like
Apache Solr
and
Paul already mentioned the OpenSocial
implementation that we have which allows
us to create all kinds of different
gadgets on a dashboard that interacts
both client-side and server-side with
each other and easily allows us to also
incorporate third-party components in
the user interface that leverages Apache
shindig
so really the indata project is about
leveraging a lot of existing open source
projects and making sure that they work
well in an OSGi environment so maybe
it's more project like Red Hat which is
sort of a distribution that collects a
lot of existing components so diving
into some of these these things a little
bit further modularity in the user
interface this is always tricky because
if you take the average user interface
toolkit it might not be that ideal to
create modular user interfaces just just
going back in time there are a lot of
web user interfaces that require you to
sort of have one XML definition that
defines every individual screen every
individual component in your web
application so that's not really helping
modularity and so there are some
toolkits you can and some toolkits you
can't use in such an environment and
we've chosen to use OpenSocial gadgets
as a way to modularize our user
interface that was a choice that worked
well for the application we were
building here might not be the best
choice for all of them because well you
end up with gadgets that you have to
place on a dashboard that gives you some
constraints as to what kinds of layouts
you can and cannot support sometimes
that's okay a lot of times you might
have to use different paradigms than the
the desktop with gadgets but for us
OpenSocial is a very in
and good fit because not only does it
support creating components user
interface components individually but it
also gives us some social features which
to a school environment are very useful
because you always have all kinds of
groups there and having these groups
interact through these features makes a
lot of sense another thing I want to
briefly zoom into is profiling Paul
already mentioned it we're basically
trying to record every action that a
user is doing and every event that he or
she is triggering within the system and
we're doing that because we want to use
this data to do all kinds of analysis
later on so that creates a lot of data
and we need to deal with that and we
need to be able that were not just
storing it but that we can also retrieve
it in sensible ways later on so that's a
challenge and that's also a subsystem
where I'm dad who can help you with some
building blocks to create such such an
environment and maybe arguably the heart
of the math system is a system for
recommending recommending content to
students a pulse briefly showed the the
screenshots that we have where a student
can look at some of the next things that
he or she can start learning or doing
and really we have no fixed order for
content anymore it's not like we've
digitized some kind of book and there's
pages and you always go through them
from the first to the last one now we
really have a system that has lots of
individual pieces of content and based
on what we know about a student and
based on what we know that he or she
should be learning next we try to find
the best pieces of content for this
person so that's an interesting process
you have to know something about a
student know where they are and maybe
also add some influence from the teacher
who might be wanting to steer some
students in some specific direction and
based on all of that we can then come up
with the next pieces of content and we
use student profiles we use the profiler
for that and that's that's a very
dynamic system and where that's also a
system where we are still learning how
to implement that best biggest again
that's an area where not everything is
set in stone yet we're still discovering
how to do that best and the next thing
and last for the and our two side of
things for now is search and well this
is probably not rocket science
there have been search engines around
for a long time now but it's very
important because a lot of times you
will want to look up certain content as
a student you know you've read something
about I don't know Phil K notes or
something and it has appeared in some
lesson that you had weeks ago you might
not be able to find it anymore by
browsing through your history so being
able to look up content is very
important also maybe for teachers who
are trying to put together lessons they
want to be able to effectively search
through this whole big bowl of content
that we have for that we leverage Apache
Solr and we've created again a small
wrapper around that so that we can use
that effectively in a noisy I context
and Paul's gonna do
well maybe the last part of undertow and
a very important one about deployment so
we have been looking at how we actually
built the software and how we left fresh
modularity mostly to do that in a way
that we can evolve
well the in the first pace that we have
been doing the other side of the story
is well how
deploy this stuff because here from was
another application and it doesn't
really make sense to just package
everything up again and well shortens in
some application container and well hope
it keeps on working so I'm going to talk
a little bit about how we do deployments
and especially about how we how are we
going to do auto scaling so at this
moment we are running in the Amazon
Cloud but we could well use any kind of
cloud or a priced cloud doesn't really
matter as we're using in using the
Amazon Cloud and what we use is a server
cluster per school it doesn't really
make sense for us to put several schools
from one server because well it has a
heavy load anyway so we decided we have
a cluster of servers for each school if
you look at a school school like that
and the first thing you will have is the
load balancer a load balancer host
bye-bye Amazon and behind that load
balancer VF well several servers
depending on how many students there are
active on dust2 it on that school and to
make sure this keeps on working and we
don't run into all kind of problems we
make sure that all the instances are
stateless chawla copyrights is stateless
of course it doesn't mean we don't store
data with all the data which stores
either going into Mongo database for
example or if it's temporal data it's
going into memcache the instances itself
and the OCI services are basically
stateless on the other hand to use among
our cluster among our clusters just
optimized do to do high i/o performance
and although the school clusters are
using same Mongo cluster but very
necessary you can scale out even more by
saying well they make a mono cluster per
school but it's so far works very well
this is not very well special I think
there's a lot of applications doing load
balancing the stateless
web servers that's that's not very
rocket science what about auto scaling
auto scaling is one of those things that
people talked about a lot as a reason
why I should go to the
the cloud left with you or enables you
to yeah well start surfers whenever you
want and also stop servers whenever you
want
and other scamming is not just about
extremely high lots most of the time and
people talk about scaling in a cloud
they talk about well Twitter and
Facebook and everything that have
message of my message massive amounts of
users and they have to have very large
skill well that's the part you have to
deal with because you have a lot of
students but on the other hand those
students are not always online we are
just working in the Netherlands at the
moment and students are mostly sleeping
at night so it doesn't really make sense
to Fr very well a big cluster with a lot
of source in it and pay for them during
the night doesn't really make sense so
we need two things and one end and
during the daytime during school hours
you have to deal with very high loads
because there's really a lot of students
and although students are working at the
same time so we have a lot of concurrent
users and on the other end at some point
we have to scale down again because you
don't want to pay for something we don't
use and that's something that well that
might be a downside of the clouds surfs
are actually pretty expensive if you
look at the numbers that that Amazon for
example charge you or any any other
cloud provider they are not cheap so you
don't want to pay for it if you're not
using it
so what are we doing um we want out of
scaling and to do out of scaling we go I
have to apply some tricks because we
want to make sure that you never go down
we never want to have downtime when
effort student tries to log in you
should be able to do so the problem with
Amazon and most of the other cloud
providers is that you can't just change
the instance type while running a system
you have to shut down the Machine and
start up a completely new machine to
start working again
so we use this mode trick for that we
say well we use load balancer for each
school so each school has its own load
balancer behind that load balancer
there's at least one node active at all
time and that's the notes which is just
very small it's a small machine well it
doesn't give us a lot of performance but
it makes sure that we are always online
now when the day starts in the morning
and students start to flow into the
school and start using the system we
just say well let's add some larger
machines a load balancer automatically
pick that up and spread the load to
those two to thousands and of course the
amount of machines in the size of the
machines is completely dependent on how
many students we expect but we basically
see that well in the morning at like
8:30 people start using this stuff we
have a lot of concurrent users and at
four o'clock five o'clock something like
that well nobody uses it anymore and
what happens then at the ends they just
shut them down again but we never have
any downtime because there's always at
least one node active
right for deployments next slide so I'm
getting there
so the question is okay and this is nice
this is just one of the basic pictures
you would expect from someone talking
about clouds you can scale up and you
can scale down by wall enabling and
shutting down surfers but how do you
actually get your software on there
because what happens if I start a new
new instance in Amazon Cloud how do I
get my software on there
well I'm very sure not not one to do it
well create an image in Amazon Cloud and
just well put my my software on the
image because everyone's make a small
change to my software I don't want to
create a completely new image that's
just well cost loves time cost a lot of
storage I don't want to do that what we
do do is use Apache ace for provisioning
and Apache ace is a professional surfer
well specifically for ours yeah you
could theoretically use it for other and
all kinds of software but it works best
with OSGi and what we do there is say
well ace is our provisioning server so
whenever we have some mushroom bundles
we upload those bundles to separate
bundles auto Apache ace in Apache ace we
used the user interface or SEO web
services to define a distribution from
from a group of of bundles that we have
bundles or very fine grains their first
small that we group them into a
distribution and we can have several
distributions specifically for a school
so school a can use distribution a
school B can use another distribution
with slightly different components in
them our servers on the right side
that'll destroy every startup at Amazon
the only thing that runs on the server
is just well Apache Felix a plain OSGi
container completely empty and we just
put one extra bundle in there which is
the age management agents the age
management agent is just a no GI bundle
which will go back to apache agent say
well i hello Here I am I'm I'm a target
and please get me some software
so whenever a new surfer started up and
I will show you how we start and start
him up automatically it will call back
the age register itself and it'll say oh
I've some software for you and we'll
just proficient all the og bundles to it
and a few seconds later at projects we
start up completely the other nice thing
about this model is that whenever we do
an software update so let's say I change
some user interface and some kind of
gadget I don't want to package my
complete lab complete application with
all those 150 bundles applied upload
them all to just have small changes in
the user interface doesn't make sense
but that's what most people do instead I
just want to update one bundle just
upload that one bundle to Apache ace and
Apache ace will make sure that all those
servers that should have that bundle but
automatically be updated so I uploaded
once and all my service will be updated
a second later instead of going to all
those surfers hand by hands and up to
update those myself that works very well
if you look at a patchy ace you will see
that those servers on the right side
there are called targets they don't have
to be cloud servers in this case they
are but it could be just from devices or
maybe some embedded devices or some
Android devices or some servers to just
start yourself you have lots of fun lots
of options there but then we still have
the question ok so we have a bunch of a
semi F we want to have auto scaling but
how exactly do we well start and stop
servers I'm for sure not going to sit
behind my computer at 8:30 in the
morning and start to resurface just to
make sure that this we can handle the
lots that's not going to happen instead
I want that to be automated
completely automated so Amazon has a
nice future for this which is called the
auto scaling and it's basically just
well you have some console commands and
you can basically configure a cluster
there and you can say well I want to
have a new cluster and the cluster has a
name the cluster cluster belongs to a
load balancer and I want at least a cert
amount of specific machines so what ad
what I do I say well I want to have a
cluster with at least one machine and
that's it and the other thing you can do
is configure some triggers to start new
servers or shut down servers and that
can be while looking at the CPU load of
your server for example but in our case
it's very simple at 8:30 in the morning
we one start supercenters five o'clock
in afternoon one stop servers it just
works like that so what we configure as
well at 8:30 in the morning please give
me five more servers for a specific
school so that this configuration
schools specific because what loads of
school specific and what happens there
out of scaling a pea ice off of Amazon
that just runs in their cloud I'll start
a new note for me with my own image on
it and the only thing on the image is
just well the Felix runtime with age
management agent in it it won't be it
will start up it will start talking to
Apache Asian sidewall I'm a new note and
I'm specifically for this school because
that's a metadata metadata we provide
Apache ace go give all the LGI bundles
that will be started and will be
installed in the felix runtime it will
automatically register ourself to the
load balancer now wallah we have a new
server and we can do this for 30 serfs
at a time if you need to and the other
end to the end of the day the other
scaling affectionate if Amazon will just
shut down surfers and we will just keep
one or two to just make sure we we stay
alive this works very well it just takes
me well if there's a new school that I
have to configure it takes me about five
to ten minutes to set up a load balancer
and well that's it well and run the out
of scale in configuration but that's a
few commands no command line
that's it so it's complicated model but
very easy very easy to use yes
the note keeps pulling every few seconds
roll the way you configure it yes and as
soon as there's an update you will just
get those bundles pushed to you that you
need because we have a lot of lot we we
have more loads than it would make sense
to put multiple schools on on one
machine sure
yeah but this is very easy to manage for
us because don't forget that those
different schools also have different
configurations so every cluster looks
slightly different there are different
components on them so it's not trivial
at all to do to put multiple schools on
one machine and performance-wise it
doesn't really matter because we at
least need a certain amount of machines
per school anyway so for other
applications it does make sense but in
our case well it didn't really help
although we could do that yeah
servers do not talk to each other and
they talk to Asia but the notes that we
have don't talk to each other because at
the moment it is a single point of
failure but you can configure ace to
distribute out all its data to multiple
services well so we could set that up to
be highly available but for now for us
we don't make updates every hour or
something and it's not critical for us
if the a server would be down for a
couple of minutes that wouldn't bring us
give us any trouble but we could set it
up that way and probably once we have a
larger number of schools it will make
sense to do that because we've seen in
in in Amazon I'm sure in other clouds
that happens as well sometimes machines
just go down Hardware breaks down and
suddenly your machine is gone so yes
that's something we're going to be doing
in the future yep yep yeah no it doesn't
have to be but
yeah so up till now we've been talking a
lot about architecture and how we've
solved problems in our application but
this is also a developer conference and
we wanted to show a little bit of code
some people yesterday might have already
been in the session that Paul and Beth
gave in in the back yesterday morning
a hands-on session on working with with
OSGi and enterprise applications so
sorry about that we're going to use the
same example and I'll quickly go for
that right now
and I wanted to show based on MongoDB
how you can create code that works with
that and all the way up to a rest
endpoint so we use MongoDB in in our
case because we're doing a lot of rest
communication a lot of our data is in
JSON format anyway and another reason is
we need quite complex queries on that
data and Mongo is quite good at querying
JSON data and really going into these
JSON structures and getting at all the
individual fields in there and well a
profiler generates a lot of data it
tries to record everything all the
students are doing so that that can be a
lot of data pretty soon so let's let's
take a look at how you would use MongoDB
in annum data to project and all of that
starts by configuring a Mongo instance
you have to have Mongo running somewhere
or a Mongo cluster running somewhere and
there's a couple of things in your
application that you need to configure
so you have an OSI service that you can
talk to to talk to Mongo and this is a
XML file they're not always as readable
as they could be but there's only a
couple of things you need to change in
there you need to define your database
name username password and one or more
machines that are running your Mongo
database and when you have that set up
you end up with an OS GI service that
you can talk to
to interact with Mongo and this is an
example of yesterday where we created a
conference agenda so we have an agenda
service running and this where this
service is using Mongo as its storage
mechanism yep the XML file is actually
also an artifact which we provision to
our system so ace provisions all the
different bundles or the modules
containing the software and we have
different artifacts that contain the
configuration for a system we can have
many small files so each part has
different configuration we can also
merge all of them into one big
configuration for a school yep ace will
also manage different versions so if you
from have a new version of a bundle and
you release that to production you can
upload it to ace and set up ace in such
a way that it will automatically update
every target every server that needs to
run this bundle you don't yeah yeah it
keeps track of that yeah yeah
we have a bundle for the client api's
for Mongo Mongo itself we don't provide
as a bundle we could wrap it but it it's
not Java code so the only thing we could
do was wrap is wrap this native code in
some bundle and launch it in a separate
process we actually have some some
components to launch native processes in
general so you could take that and use
that to also package Mongo and and send
it to a server if you want but
I think we've set up Mongo yeah we just
installed Mongo as a cluster by hands
because it's just a 1:1 one-shot deal we
just have to build it once so it's not
part of the provisioning at the moment
one cluster for all the schools but we
can just as easily take it personal or
per set of schools that's very matter
yep I think we're almost out of time so
I think it's ready to take the next
questions offline and just try to wrap
up yeah I'll quickly go through the rest
of the example so it's talking about
creating a component that talks to this
MongoDB service this is a bit of code to
to set up that component and to define
its dependency on this MongoDB service
and then actually using MongoDB looks
somewhat like this we use dependency
injection so our component just gets
injected a MongoDB service we invoke get
DB and then we get a collection of
conferences in this case we then
leverage mechanism injection to create a
type safe collection and then we can
just iterate over the results and return
them to the user or whatever component
wants them saving new conferences adding
them to Mongo looks like this it's a
little bit similar again talk to the
database and then wrap your new
conference and and save that one so
that's pretty easy as well turning
things into rest services looks somewhat
like this if you've done jax-rs this is
really nothing new this is just standard
jax-rs stuff and we're just talking
again to the agenda service here to get
the conference's or to print one etc so
that's that's a little bit to give you a
feeling of how to develop code based on
these components so to wrap it up how
does this fit with with other
applications I think
in our experience so far there's many
modern web applications where these
components make a lot of sense and give
you a lot of leverage saving you for
having to do too much plumbing yourself
OSGi for a long time has had a big
disadvantage in the tooling area it
wasn't always easy to create OSGi
applications that has changed over the
years
we're at the moment big fans of a plugin
called B and D tools which unfortunately
is only available for eclipse at the
moment we would love to have that ported
to other IDs as well but it's a really
productive environment it gives you
really quick turnaround and that's B and
D tools I'll get to that to have a slide
with a link etcetera so that that's cool
and the stuff that we've shown you is
all running in a cloud but that doesn't
have to be you can use that on all
normal servers or desktops or even
devices as well that's all the same just
to give you a link to the indata project
in case you're interested we have a
website it's open source or you can get
involved and if you're interested please
do just give us feedback on what you
find there we have some tutorials we
have some videos so just look at those
and see if you like what you see and
give us some feedback on that there's
one plug I wanted to do for a talk of a
colleague of ours on Thursday mark and
hunts in this same room are actually
going to give a talk about enterprise
search in action which will focus a lot
more on search components and doing some
really nice stuff with that so if you're
interested in that please go to that
session and finally we have a couple of
links for you to share if you want to
learn more about Ace or the indata
project or this eclipse ogi plugin
there's some links here and if you want
to learn more about our company or learn
some Dutch
that's the last link we have an English
version so you can try and figure out
what's being said there and yeah we want
to thank you for your attention maybe
answer a question or two if we have some
time if you go to them down to the tork
website there's a lot of videos there
this builds up a complete tutorial
basically and documentation of all the
stuff that should get you started so
yeah the guy in the red shirt just
bottle room yes that well there is a
specific reason I'm a Felix committer so
but but but in general any OSGi
framework could run this code and we've
run it on other frameworks as well that
that would work just fine
exactly yeah yeah
my memcache isn't completely here you I
hear something about memcache
what client I use I will look it up for
you yeah please
and I've maybe repackaged that in OCI
again using or in and out to associate
offices so that's why I'm not exactly
sure anymore but yeah yeah yeah
yeah explaining how that works probably
gonna take me more than two sentences so
let's take that one offline and I'll be
available yep yeah if you want yeah no
backbone made mostly backbone mostly
backbone yes but well it's all html5 big
backbones that's that's it no oh yeah
get all my libraries for touching it
sorry if some libraries are touching
that but I'm not even completely sure
because you have some interaction
designer guys doing a great job there so
yeah we're not that good at javascript
to be honest
for the cluster configuration yeah right
that reassign ually yes but the
component concentration is in Apache is
so which bundle should go where and
which configuration file should go where
that that's the Apache is the closure
configuration that's just three commands
on the command line using the Amazon API
so we don't really need a zookeeper and
somebody in the back West has been doing
this for a while so I guess that's it
for us for today
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>