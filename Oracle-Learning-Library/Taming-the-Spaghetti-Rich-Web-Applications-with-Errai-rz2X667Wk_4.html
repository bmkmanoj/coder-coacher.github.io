<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Taming the Spaghetti: Rich Web Applications with Errai | Coder Coacher - Coaching Coders</title><meta content="Taming the Spaghetti: Rich Web Applications with Errai - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Taming the Spaghetti: Rich Web Applications with Errai</b></h2><h5 class="post__date">2013-01-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/rz2X667Wk_4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon and welcome to our talk
which is called taming the spaghetti
rich web applications with the ride
I'm Jonathan Firth hi and I'm Christian
Sadiq this talk is about building
maintainable large-scale web
applications with the che bus arrive
framework but we have to start with some
sad news
somewhere near and dear to all of us
could not be with us tonight
that's right sadly a server-side
rendering of HTML pages has passed away
after a long battle with Ajax now of
course this isn't news
we put its end date probably about two
years ago and we didn't come all the way
here to Java one to tell you that
server-side page rendering is is old
news but what we would like to talk
about is the frameworks that we all use
the ones that were that were developed
and and loved by all of us for many
years were developed in an age when web
browsers were not really reliable enough
to have an application live full-time in
a single page in the browser I mean I I
can personally remember the hundreds of
hours and the late nights staying up
trying to make a single page web
application look the same in IE 5 and
Netscape 4 is like a horrible game of
whack-a-mole gone wrong but ya know I
think it's fair to say that the worst
nightmares are over and we can count on
compatibility and speed in JavaScript
CSS and Dom those who have libraries to
fill in the remaining gaps like jQuery
and the Google web toolkit so also
browsers have access to more
computational power than they had ever
before we all just have to look at our
phones for evidence that's right if you
if you think about your your whole web
application as a distributed system you
think about the database tier the
middleware it's here and then all of
these clients out here all of these now
fast and reliable runtime environments
and you weigh the amount of computing
power that exists in your distributed
application you'll find that most of the
computing power is in the thousands of
clients the web browsers that everybody
is using to interact with your web page
so we really should be taking advantage
of this now so yeah in short we have
those web browsers and they're really
good application deployment platforms
so why don't we put more application
code more of our applications logic into
the browser right well why don't we I
think I'm sold okay this is compelling I
think let's actually just change this
into a hands-on lab everybody get on
your laptops are gonna crank out about a
hundred and fifty thousand lines of
JavaScript in the next two hours who's
with me
we're gonna get started well well not so
fast what what well I already have
thousands of lines of java code in my
head are you saying I should pitched at
all rewrite it in JavaScript all of it
well yeah why not we have these
wonderful browsers we've got all of this
computing power in the clients here and
we want to take advantage of it we don't
even have to pay for those CPU cycles
and I mean who among us has laid awake
at night just wishing you could throw
away all of your legacy code start over
a Greenfield favorite I say we go for it
well what about security and data
validation I can't do that completely in
the browser the users in complete
control or a hacker would be in complete
control of that logic yeah okay okay so
that's a valid concern we can't rely on
the browser as a secure and trustworthy
computing environment even if it's a
nice consistent deployment environment
it certainly can't be tampered with so
we'll keep that code we'll keep our
business model and our form validations
and our security checks but I'm also
going to implement those in my new
client side code base because I want to
do form validations on every keystroke I
don't want to do server round-trips for
all of this stuff we can make these web
applications fast and responsive so we
need this code on the client okay let me
see if I get this right so you're gonna
implement the whole business model again
in JavaScript with identical validations
and then you can't gonna keep
maintaining and developing this in
lockstep with night with me over the
next five years mm-hmm
okay well I think you might have got me
a second time there because I've been in
this situation I've I've led a team that
was at loggerheads with another team
trying to keep two code bases that do
essentially the same thing in lockstep
they were written in different languages
and it was somewhat of a nightmare it's
not just doubling the effort it's
creating a lot of drag on both teams
so no I don't want to keep my JavaScript
code in lockstep with your Java code
forever so well work in the same
language that essentially means we have
two choices yes write everything in
JavaScript or everything in Java okay
okay I think I can agree with that
statement and now that you framed the
debate that way I think I would prefer
to choose Java I mean just thinking
about the IDE tooling that I love just
just the rename refactoring alone I
would hate to give up completely
reliable rename don't think twice just
do it I also love call hierarchy find
usages I'd feel like I had my right arm
tied tied behind my back if I was
developing a web application without
these simple tools that we take for
granted yeah plus we have an existing
team it's all made up of Java developers
and there's a large giant pull out there
right that's true our developers are
already really good at writing solid
clean Java code and I've seen things go
off the rails if we try to dive in and
write a giant application in a language
we're not entirely familiar with so
that's another good point and another
point if you don't want to keep up your
libraries right no that's true that
legacy code base that I was laying awake
at night thinking about rewriting
actually we've we've improved that
recently and now we've got we've got
like the Google collections in there the
guava libraries I don't want to give all
that up and go back to just plain lists
and maps and the stuff we get in
JavaScript so okay yeah well we've
settled the debate yeah we want to be
able to use Java on a client but
obviously we don't want to use applets
because there was a mistake in history
yeah just check the last four or five
weeks of news and you'll see that's not
a popular choice now okay so why don't
we use the Google web toolkit compiler
to compile our Java to JavaScript not
only really translate our code it will
give us cross browser support and will
apply a lot of heavy upfront
optimization server code so that the
child script becomes smaller and faster
than any handwritten JavaScript we could
come up with and it will also give us
development mode the code and refresh
development experience you know you
change Cody just refresh the browser and
also it will allow us to debug
client and suicide kodesh Java code
Anela ID okay well this sounds great we
don't have to give up code and refresh
when we come keep programming in Java
that we're familiar with and we've got
the great tools so why doesn't everybody
use this all the time well it seems to
catch a lot a lot of misconceptions
around to Google that toolkit ok
actually I know one of them I one thing
that I that I hear a lot from people
when I've told them that I'm working on
this quit based framework at JBoss they
say well I would love to use the Google
web toolkit but I really don't want to
commit myself to writing all of my user
interfaces in this programmatic
procedural UI framework that's kind of
like swaying or AWT I much prefer declan
of layouts and HTML and templates and
this kind of thing but the truth is
that's just one way that was it's true
at the beginning that was the only way
you could make a GUI and quit but now
quit offers the uibinder framework which
lets you declare all of your layouts in
XML it's not dissimilar from the way you
create layouts in Android we also will
talk about later a declarative
templating system that we include an
arai that's based on html5 template
files and of course the Google web
toolkit isn't a firewall from the
underlying Dom that's that's living
there in the browser window so you're
totally welcome to just go and
manipulate the Dom objects using that
same horrible w3c Dom API we have
available to us in the browser so if if
you'd like to do that you can any any
other reasons that that we might not
want to look at this now that that myth
is busted there's another one we hear
very very often and that is that there's
some magical server-side runtime
dependency that makes this all work
where the truth is that there is
absolutely no runtime dependency or
there has to be no runtime depends the
older older compilation happens at Build
time so you deploy static static and
perfectly cashable JavaScript to the
server ok so there's no magical server
time compiler runtime that's good to
know so that's sort of hopefully we can
all be on the same page about what
exactly the Google web toolkit is and
what it isn't and help dispel some
rumors but we heard to talk about Arai
which is the framework that we were
full-time at JBoss so what does ever I
give us well quit is really hyper
focused on being the the best smallest
fastest tightest code that it can
produce and whenever there's a trade-off
to be made between this user experience
and speed versus developer experience
they tend to lean towards the user
experience they they really want to stay
hyper focused on performance but we're
taking the balance a little bit more
towards us because we're developers we
like making software and we like
enjoying making software so we have a
few mantras that we use when we're
deciding how to get things working in
our eye
first of all we say decorative rocks we
like to declare what our application
does the sort of the bones and the
structure of the application should
exist in the bones of the code so we
have a lot of annotation driven things
and a lot of the structural expressions
are done in the structure of the code
rather than hidden away in procedural
logic the other thing we say is
boilerplate sucks I mean this is a
common criticism of any Java framework
and it's come so far in the last five
years you wouldn't even recognize Java
anymore if you stopped using it five
years ago and we're trying the best that
we can if the framework can infer
something for you we don't make you type
it out and we don't make you read it so
we try to keep boilerplate to an
absolute minimum and finally and maybe
most importantly we say code at once and
this is what that whole dialogue at the
beginning of our talk was really getting
at is that if we can write code one time
maybe we were thinking it was going to
run on the server and we decide later
actually we want this code to execute in
the client instead or as well it should
be trivial to just take that code that
we wrote maybe move it to another
package to indicate where it's supposed
to run and then it will just work it
will do the same thing in the client as
it was going to do on the server and
vice versa so what did we do to turn
these mantras into reality so the first
the most important part is that we made
a lot of existing server-side api's
available on the client so they can
compile the JavaScript yielding the same
results that's for instance the CDI API
a chuck's RS client mjp a
we also have what we believe is the most
unintrusive marshaling system out there
that imposes practically no limitations
on the objects that are to be marshaled
and we have communication mechanisms
that tie all of these features together
right well this all sounds great now how
would I get started with a project like
this what does it look like well it
looks like a typical quit project and a
typical Java project so you have two
source main Java folder which all maven
users are familiar with it has the grid
XML top-level module descriptor which is
defines which other modules we inherit
and just gives our modular name and then
most importantly we have a client shared
and server package sure everything in
the client and shared package gets
compiled to JavaScript and all the code
in a server package would just be
deployed as fight coders with any other
regular Java bad-bad if your source main
let that folder that's where you put all
your static content and your deployment
descriptor that's you're all familiar
with that and the only thing that awry
yet and remember because we say
boilerplate sucks is the right app dot
properties file and in 99% of the times
this is an empty file we just need it as
a placeholder for class path scanning so
we know where to start looking for
annotations that we have to process
right so I guess it's time to dive in
talk about the first Java EE feature
that we've implemented in the browser on
top of quit and that is CDI the who here
is familiar with CDI should be yeah most
people that's great so we'll just go
quickly through what this is this is
exactly like CDI you would have used on
the server here we're looking at two
features of CDI one is the dependency
injection feature and the other is the
eventing feature so at the top code
block there we have injected a @ updated
event of document and we're calling it
updated doc event so what this does for
us is it asks the container to provide
an instance of event and event is a CDI
type that is it's an interface that
allows you to fire an event and the type
parameter of course is the type
object you want to fire as the event
object so in this case it's a document
now the twist with CDI events is that
you can or a CDI everything is that you
can qualify it with qualifiers that you
made up on your own so at updated in
this example would have been a new
annotation we introduced in the
application code itself so we're saying
here inject a way of firing an updated
document event and so we called it
updated doc event now in the bottom code
this is how we would actually fire the
event when we want to we've just come up
with arbitrary button click handler and
so we just say updated doc event dot
fire document and document is just any
instance of document that we want others
to know about so of course this is a
decoupled events are a decoupled way of
building a system so the observers are
completely separate from the place where
we fire the events and so here's how you
would create an observer in CDI you
simply make a method any name any access
type that doesn't have to be public and
then you say app observes you put as
many qualifiers as you want there zero
or more and then you say the type of
event you want to receive so in this
case it was document and then the
container will invoke this method with
the instance of document every time it's
been fired from wherever and in a rye
when we say wherever we really mean
wherever so in normal CDI when you fire
an event it's just inside of the
container it's a local method call
synchronous on the same thread that
works of course because whatever CDI
container using on the server does that
it works in the client the same way
synchronous event dispatch but the thing
that we've added is that you can also
observe events on the other side of the
connection between the client and the
server so if you fire an event on the
client when somebody clicks a button and
there's a CDI observer on the server for
that event with that set of qualifiers
then Arai will serialize the event
object move it across the wire and
invoke the method on the server side
with that event object so this gives us
a way of building highly decoupled
distributed systems
yeah so the fundamental mission here in
your eyes you really want to have a
uniform programming model across the
client and the server so it really
shouldn't matter where your code is
written for you should be able to
replace it at any time and another
feature we can use in the browser now
that comes from CDI is producers so in
that example we've just seen BER Charla
from injected an event of type T and all
that injection sometimes you need more
control over that sometimes you need to
be able to manipulate that object before
the container inject it into your being
and that's exactly what produces a four
so in this example here we see that
we're producing a widget and that was
qualified we've supported and the point
here is that we could check at run time
whether or not I can html5 feature is
supported and then just return a
different bean type from that method and
when you anywhere in your app you in
check the supported base widget will
just in check the right instance of it
so that's just CDI produces that act as
a source of objects to be injected and
gives you more control over dependency
injection and again that's now working
in the browser now before we move on to
this next feature I'll just talk how I
highlighted that we had this highly
decoupled eventing mechanism that works
both on the client and the server and
across the wire and I'll just share a
quick story with you about an
application I was working on about five
years ago at a different company it was
a swing application and we just really
fell in love with this event-driven
programming model and and all the
benefits that building a decoupled
system gave us and we took it actually
too far we we ended up hitting a
complexity wall with with our
event-driven programming where we were
trying to coordinate too many things
competing things were actually mutating
state in the same object from different
observers and the whole thing just hit
the wall and we spent actually quite a
long time trying to keep it event-driven
and highly decoupled but really the only
way we were able to solve that problem
was eventually to simply introduce a bit
more coupling and couples some of what
had been just listeners right into the
code with direct calls so we could
control the sequence of when these
different mutaters were happened
so what I'm getting at is sometimes you
need something that's a little more
highly coupled than just a distributed
event and that's where these remote
procedure calls come in so if you've
used the Google web toolkit before or
maybe if you've just read about it you
probably know that GWT comes with its
own RPC mechanism we've come up with one
that we think is a lot simpler to use
we've reduced the boilerplate
significantly and again like Christian
said earlier we have a really nice
marshaling framework that we'll get to
in a moment that removes much of the
burden of getting the objects and the
return values across the wire so just
quickly how to make a remote procedure
call an arai you just declare an
interface you put it in the shared
package because the server and client
code need to know about it on the server
side you annotate an implementation of
that interface with at service which is
an arai annotation and then you put your
method bodies whatever you want to do
return the values you want to return and
on the client side you inject a caller
of happy service and caller is an arai
library type but you probably see a lot
of similarity with the the CDI event
interface caller works very similarly
you you put your own stuff in there and
the type parameter so we're injecting a
way of calling happy service the
container provides the instance for us
and then we go happy service call a
bunch of junk and then dot is everyone
happy and because dot call returns the
type parameter of caller that dot has
everyone happy is something that eclipse
is very happy to autocomplete for you
now this junk in the middle if you guys
were at the Technical keynote on Sunday
Brian gets said something about beef to
bun ratio and we're not too happy with
the beef to bun ratio in this anonymous
inner class here unfortunately there's
nothing we can do about it in the
browser because we have one thread on
the client side if if we were to make a
blocking call here everything would
freeze up the whole browser UI would
freeze up until the server responds so
we have no choice but to have a callback
and we hope we hope to improve the beef
de bun ratio with maybe one day there's
Java eight
supporting the quick compiler but for
now or when we need tighter coupling
we're stuck with this how does the
communication work when I'm doing an RPC
yeah what happens well that's a good
question how does that work well the
setup in Arai is that on the server
there is a bus in an arai bus object and
it federates with each of the clients so
when you start up a grid application by
hitting the webpage that's the the entry
point the host page for that application
there's some startup code that goes and
talks to the server negotiates whether
or not the browser and the server
support HTTP long pulling or maybe
WebSockets and they make that
negotiation and they federate their
buses with each other
figure out who's observing what and all
of that kind of stuff so nothing
unnecessary goes across the wire and it
also allows us now of course because we
have a common channel or even better
than maybe a WebSocket to push events in
both directions with no delay hmm I have
a confession to make here what before
joining our team I don't think I would
have ever touched a message bus the
message bus yeah I mean over HTTP yeah
you don't like that no I think I know
where you're going with this I I think
you're one of those Resta fairy ins yeah
I think that's what's happening my name
is christian i'm the rest of Farion
right
I apologize that's fair I probably am
too a little bit so so what do we do to
fix this everything we've talked about
so far this is not terribly restful yeah
well it turns out that we can use that
exact same API that Jonathan just
explained for RPC for rest cults so what
we see here is that that at remote
interface was replaced if an interface
that's annotated with chuck serious
annotations and those annotations of
course describe the HTTP traffic that
takes place to invoke an endpoint and
now the cool thing here is that we'll
again on the client just in check the
color for that interface and you invoke
a simple Java method on that interface
and that will carry out the plain HTTP
rest call as in
attended by rest affairs right so that's
great I mean this bottom code block
looks exactly like the bottom code block
we had earlier with theory RPC but now
we're rest clean and we can decide
exactly what the HTTP traffic is going
to look like right and that interface
you can either using Chuck's arrest
implement on the server which would
expose those endpoints of HTTP or you
don't have to implement it at all and
just use it to contact another
application or even a third party
restful service and you can just use it
on the client side only right so you
could even use this if you've described
the API saying some interfaces you could
use this to talk to your bug tracker or
Google Maps or whatever exactly yeah
right and a really cool thing is we
don't see any requests logic or any
serialization logic and that offers the
possibility to do a lot of really cool
refactorings and we'll show that in a
second in a live demo but speaking about
serialization first is that all it takes
for an object to be serializable in your
eye is this one annotation here that's
called portable and what we see here is
a simple pocho so that's not a surprise
like every every marshaling system can
can see realize that that's not so
impressive the next thing we did is we
wanted to be able to offer a lot of
flexibility for marshaling so we don't
want to impose any limitations on the
beans that should be marshaled over the
wire so for instance here we could just
remove the getters and setters and it
would it would still work okay but I've
seen that trick before - I still feel a
little bit constrained because one of
these other things that keeps me awake
at night is when I deploy an application
that's got some mutable state especially
if it's shared but even even if it's not
shared mutable state is where your bugs
come from they're the things that make
you not get home for dinner so yeah well
we want to get rid of immutable stake as
mutable States because it's really just
a big surface where bugs can occur so if
you advance the slide we'll see that
we're also able to support in immutable
entities so Li takes you here receive it
has a private constructor and a factory
method so
the penis created you can't be changed
and all it takes in Arai marketing to
make that work this is one extra
annotation maps to that maps the factory
method parameters to the beam properties
that's all it takes now we have an
immutable washable entity that makes me
happy and the the beef to bun problem
here with maps to may hopefully go away
as well because as far as I know Java 8
is going to give us method and
constructor parameter names in
reflection finally so the maps to is
just there because we don't actually
know what those parameters are called
when we're building all this stuff so by
now we've seen a lot of code snippets I
think it's about time we show that this
actually works at this point we also
wanted to sacrifice a chicken to the
demo gods yeah but we took the chicken
with us to Pearl Jam last night and it's
still waiting for the bus so yeah the
chicken is stranded in that bus queue
so I guess Jonathan starts with the with
the demo sure
so what I'm going to show you here so
what I'm going to show you here is the
little demo app that we've prepared for
you so this is an arai application a
very simple one and what it does when
the page loads is that it makes a a rest
request using that call or API back to
the server and it gets this list of
customer objects and populates the table
with them and that's that's exactly what
we've seen here we can see what the data
looks like by coming over here I think
we have it already yep there it is so
this is just a JSON payload that comes
back from our customers resource that's
a jax-rs resource and the JSON type here
it is an arai format of JSON it includes
a lot of type information as you can see
but it's actually structurally very
similar to jackson and we actually
provide a Jackson converter if you'd
like to interoperate with existing
Jackson based resources the other thing
we can do of course is post a request
back to that service we do that it makes
a post request and it appears in the
list so very basic demo let's have a
look at the code so we see here in the
structure I'll just make this bigger so
you can see it just like we went over
earlier we have a local package a client
local package that contains the code
that's going to be compiled to
JavaScript and run exclusively on the
client so this code won't make it to the
war file as Java classes then we have
this shared package which is both
compiled to JavaScript as well as class
files and deployed to the server and
finally we have the server package which
is not compiled to JavaScript at all it
just stays as class files and works like
any other stuff you would do in a web
location so let's dive in and take a
look at this app dot Java so when the
page loads because this is an entry
point class Arai is going to create an
instance of this class and call its post
construct method this is another CDI
feature post construct so we initialize
the page by adding this customer table
to it we call the populate customers
table method which is right here and
this is one of those callbacks like we
saw earlier so it's a remote callback of
list of customer we receive the response
from the service just as a list of
customers we don't have to do any
marshaling it's not a string or a JSON
object it's actually a proper list of
customers and we add them to the table
and the way that we put all that
together so we just go with this
customer service which was injected for
us right here caller of customer service
dot call list callback dot list all
customers so that's great
take a quick look at the interface the
jax-rs interface oh thanks it's already
open there it is so this looks like any
jax-rs there's no special arise stuff in
here I'm sure everyone's seen this
before we just for example the list all
customers method is annotated with get
so it responds to get requests it
produces an application JSON response
type and it just returns the list of
customer and the right takes care of the
marshalling when the response happens so
what have we gained from all of this
well one thing that's neat if I do call
hierarchy here sit control l.h this is
interesting so this is a jax-rs resource
method and we've got a caller who is it
hey it's this client-side code that we
were looking at earlier so that must
mean that I can also do this maybe I
want to say list all customers
whoops by name okay so I just renamed
that resource method I was I happened to
be in client-side code at the time but
of course that can go back here I can
also look at the implementation this is
nothing magical we do this every day in
Eclipse or whatever IDE we use but the
really neat thing is that it has updated
client code and server code trivially
the other thing we can do which is maybe
a little bit more special is that let's
say we've we've built up a big
collection of jax-rs resources and we
haven't really agreed on the language we
want to use so let's say that we wanted
to standardize on singular names in our
jax-rs paths instead of customers we
want customer and if we have a method
that lists a bunch of customers we're
going to give it a name of list so have
slash customer slash list now instead of
customers now I've done this lots of
times over the years and what I would do
now after this trivial change is I would
go through all of my client code and
update it all everywhere where I had
said customers I have to say customer
and everywhere I say customers without
an ID which was a list I now have to go
in and put lists but because our client
code our callers are generated for us
this is already done I don't even have
to touch the client code now so if I
simply restart this embedded server
that's in dev mode here restart server
there come back to the browser
this type of we'll explain why that
happened in a minute it's expected and
here
so this client has just booted up made
its rest request to slash customers
slash list and it got the data back good
look here
that's a 404 now as expected because we
changed the path of course it is at the
new location so that's it we've just
made a potentially serious change to all
of our jax-rs paths and we didn't touch
a line of fire code and it's all still
working great yeah that was really great
but what if I want it when you create
one of those customers what if I wanted
all clients to update because right now
you create a custom and only your view
and a client will see it yeah so
although I like rest sometimes push
messaging is an excellent use case for
message bus I will just quickly show
what it takes in a ride to get that
feature implemented so the first thing
we would need to do is we go to our
server-side implementation and we are
going to inject an event of type
customer and call it the new customer
event and we are also going to qualified
with new so that if we have different
custom events we can differentiate with
Windows when we observe the events and
we just organize the imports here yes
okay now I have an event so when
somebody creates a customer I'm gonna
fire this as a business event so that
other components in my app can observe
it so I'm just gonna say new customer
event fire customer so so that's great
at all now my server side component
fires an event but now I can switch to
my client side code app touch app dot
Java and I can observe the event now so
I'm saying public void
on you it's called customer from server
I'm saying it observes new customers
okay organized imports again and what
we're going to do is we're just going to
add it to the table so that we'll see it
happened so call this a customer and we
add a single customer ok we just watched
you write about four lines of code there
so yeah I have to restart the server
again because I changed server-side code
but we'll we're working on that with
zero turnaround so we just didn't finish
the che rebel plug-in in time but it
will be there shortly so you don't even
have to research a server again but
that's not the point of the demo is
really that you can refresh the browser
but in the next couple of weeks you
certainly also be able to skip that
restart server face so I think I
restarted the server now I'm gonna
refresh the client again there I haven't
broken anything that's good so to
simulate this we need a second client
I'm just gonna open a new tab which is a
new session in awry or okay sort of what
what I want to happen is if I add a
customer here it should also appear here
right if I'm not mistaken though it's
calling this a new customer at a postal
code and storing it it appeared here and
it also automatically appeared here so I
had to write four lines of code to push
a message out a change that are the
business event out to all clients that
are connected at that point in time yeah
that's pretty fun yeah and it's fun to
do and really what we've shown here is
by working with the same language on the
client and the server we have all these
amazing opportunities for refactoring
across the client and server
this makes the evolution and the
maintenance of the app so much nicer and
easier yeah for large scale
and not even just for the the tooling of
the refactoring and the renaming but
just even knowing if if I wanted to
delete this attribute of customer what's
it going to affect well we get an answer
that even reaches out into the user
interface layer not just to our sort of
API layer that the browser talks to okay
so let me just get back to the
presentation to show some our newest
features JPA in the browser so we wanted
that feature because basically all of
our users use JPA on the server so you
want them to be able to reuse not only
their entities on the client but also
their business logic so you can now use
the GPA and image on the client so here
we see a button click event that uses an
injected entity match and persists an
entity right and this isn't storing on
the server right now we're that's the
amazing thing here what this is going to
do it's going to persist identity in the
html5 local storage so if you advance
the slide we see this is Chrome's
development console we see that an album
entity it has name queries like your
standard kpa entity and by using the JPA
code on the client this entity just is
stored as a JSON structure in your
browser's local storage so the point of
this is that you be able to support
offline mode really easy so you detected
a service gone and but you could still
complete the business transaction at
least partly so but then when you user
comes back in the circumspect online you
can just finish the transaction right so
you where we're showing this this entity
class album here complete with some J
pql named query it's got an ID that's
generated and we can do all of this
stuff through the entity manager on the
client side and it works largely the
same as it would on the server side
there's a few caveats that we've
documented we're not at a hundred
percent API coverage on JPA but it's a
very useful subset you can build stuff
with it yeah there's a five megabyte
limit of things local average but they
are low in George yeah what else
O'Reilly I I just made a brief reference
to this at the beginning of the talk
when we were talking about UI
binder which you're probably familiar
with if you're already a great user so
around you I what we're doing here is a
similar in spirit to UI binder but as
you can see this template here is not an
XML file this is an html5 document this
is a valid html5 document they took away
a lot of the boilerplate for us like you
don't need a head or a body tag anymore
so what we have here is what we like to
refer to as a designer template because
as you can see there's a stylesheet
reference in the document so your web
designers can work directly with these
in whatever their favorite tools are and
anybody can pre preview them in a
browser without actually running them
through a template processor it's just
an html5 file it's valid the browser
will display it and it will look right
so let's just walk through what we've
done here you probably noticed that we
have these data field annotations like a
form data field equals form the input
data field equals user name and so on so
these data fields are attributes that
link up from the template back to the
java class that's the companion to the
template and we'll switch over to that
now just remember we have a forum user
name password and a submit button so
here they are they've come back we have
the username the password and the submit
button and again we're using this CDI
programming model where we're injecting
the instance of text box but we've added
this data field annotation which tells
Arai that in this template class when
you're injecting a text box for me this
is a standard quit widget that wraps
around an input type equals text I want
you to give me the element that was in
the Dom that is that text box and just
put it in that user name field so that's
hooked up now same with password we're
just demonstrating here if you can't or
don't want to name your field the same
as your data field in the template you
can provide the name so in this case it
was passed in the template and it's
password in the Java class no problem
and finally there's a third scenario for
getting data fields hooked
between the HTML document and the Java
class which is I don't want you to pick
it out of the document and stick it into
my class for me I want to provide the
instance of button to you and you put
that into the template for me
where the data field existed so that's
that third scenario in this case it's
trivial we've just created a new button
for no reason but if you have some
special needs you need to create a
special widget you can make one and Arai
you I will stick it into the document
for you rather than pulling it out so
that's all there is to hooking up the
structure between a template and a class
now what about behavior well here's how
where we have managed to get rid of one
of these anonymous inner classes that
nobody likes to write or look at you
simply say at event handler you give it
the name of a data field and you can
call the method whatever you like and
tell it what type of event you want to
receive from that element so in this
case anytime there is a click event
originating on or bubbling through the
submit data field this method will get
called with that event object and we've
got just a little comment here it's a
bit insidious it's a suddent login
request so how would we do that I think
you can imagine how we would do that
there's probably a class called user
somewhere in this application so we'd
probably say user user equals new user
it's not good so far then we'd say user
dot set user name user name get text
still sounds good user dot set password
password get text okay I'm getting bored
how can we fix this this sounds like
boilerplate to me exactly so lines with
two or three of the same word on them
yeah so the good thing is you don't have
to write that code so we have a new
model that's called a module that's
called write ADA binding and why you can
use it a sustain alone component as a
fluent API it's also integrated with our
UI so it just takes this to annotations
here Auto bound and bound to bind an
instance of a model the user object to
the UI to the data fields so what
happens here is that the user is bound
to
the mapping fields username and password
and it's automatically kept in sync so
anytime you changed you call username
user dot set name the user name will
change and any time you change to UI the
model will update automatically so you
don't have to write any of the
boilerplate event handling code to
update the UI in response to model
changes or to update the model response
to our changes there was just the
framework generates code for that and it
will take care of it but but do we lose
all of this nice security and type
safety that we had when we wrote
everything out longhand
no that's the cool thing here because
because we have to process that
annotations and generate code when we
find mapping problems we can just fail
at compile time so let's say our user
object here doesn't have a user name
property javabean property would just
tell you we can't bind to the user name
textbox because there is no user name
property and user and then you would
have to specify which property as an
attribute of bound you want to bind to
so when we redeploy our new app on
Friday evening and then go out for
drinks we're not going to get a surprise
call because we forgot to line up the
naming fields or anything like that well
that's pretty this way you're less
likely to get a surprise call okay
that's fair so that sums up the breadth
of the high-level features we want to
talk about there are some lower level
API is inside of a ride that we're not
going to get into today but we'd like to
take our last few minutes that we have
to talk a little bit about how all of
this goes together like how do we
implement these traditionally
server-side api's to run in a
significantly different execution
environment like a web browser yeah so
many of you probably have written
framework code of frameworks already
java web frog has been around for a
while and they all have one thing in
common
massive use of java reflections that's
really what they do
unfortunately inquit and a google web
toolkit there is no such thing oh yes
ouch
how do we do this that we don't know
what everybody's code says how do we get
along without reflection well there's
this feature in which we can't really do
justice in a few seconds or minutes we
have remaining
but it's called deferred binding it has
two main use case
the first use case is to replace a type
2 when the compiler finds a type it can
replace it with another type that's used
by quit internally to generate all the
different permutations for the different
browsers so who it doesn't just compile
one one version of the Java Script it
compiles many versions for each browser
separately and it uses that first
feature of deferred binding where the
compiler sees oh there's a pop-up
implementation used and if I compile for
a Mozilla browser that just replaces
reformed that works there right and a
big reason the the motivator that lies
behind this from Google is that because
there are significantly more quirks for
some browsers you could probably fill in
what those might be in your mind we
don't want to punish everybody by having
them download all of the compatibility
code for that browser if they happen to
be using another browser that's much
closer to spec yeah so you only download
the JavaScript in that browser you're
working with it's all the JavaScript it
needs it doesn't need all that other
JavaScript to check for other browsers
so the second feature and that's the one
we use heavily is code generation so
when a compiler encounters a type it can
generate an implementation of it or
another type that's used for it so
that's used for RPC for instance for the
kola API where we just refer to an
interface and we invoke the method what
happens there is that the implementation
of that interface on the client a proxy
is generated and we invoke a method on
that proxy that does all that
communication with the server so
cogeneration is really our our
replacement for our Java language left
right and I'll just point out that this
looks like not only xml configuration
but maybe a little bit of boilerplate
you don't need to do this in your own
applications your equipment will inherit
our quit modules and you don't need to
write any of this deferred binding
configuration it's just there for you
your quit module descriptor will be very
simple just inherits the parts of a ride
that you'd like to use so what does this
generated code look like it sounds kind
of scary is it ridiculous well here's
one this is this is an example of the
type of code that would be generated for
one of those J pql queries
that we saw earlier so in this case this
this was a query we saw earlier in the
presentation select a from album a where
a dot name equals a parameter called
name so it's not that much code really
it it's as much code as you would write
by hand to do something like that but if
you could write that one top line by
hand just the part in green rather than
this page full of code that does the
same thing in Java wouldn't you prefer
to write the top one I think it's more
fun to maintain and even easier to
understand at a glance yeah okay so we
hope we've shown you how to get from
this twisty maze of little callbacks to
this that's some tame spaghetti so now
you know everything there is to know
about Arai and thank you for coming out
to our talk and giving us your time and
attention thank you yeah we're still
here for questions of course also don't
hesitate to get in touch with us of
course everything we do is open-source
the find us on github you can join our
IRC channel or ping us on Twitter or
wherever we're really interested for
feedback and questions and as you can
see from the background picture the
whole awright team happens to be based
in Toronto so if you're in Toronto come
out to the local user group and chat
with us there yeah questions
thank you
right okay two great questions the first
one is about does this work with mobile
are there any special considerations we
need with mobile and of course there are
many frameworks already that work with
mobile and can you use them together
with Arai that was the first question
and the answer is yes it works great
with mobile we actually have a demo that
we've done it's a very lightweight
low-level demo we didn't bring in any
new mobile frameworks but we have we're
just showing how you can get the html5
orientation events from the device and
use them we actually bridge them over to
CDI events and stream them up to the
server so we can show you that after
we'd be happy to and the second question
was about security and a little bit
about the overhead of all this
serialization that's going on do you
want to take that one Christian yeah
that is hard to answer so one thing you
do is the main reason for the portable
annotation when it was designed was for
security so we only expose the types you
want to be exposed so when something is
not portable the client will not see it
so that's really the the most
coarse-grained security mechanism we has
is this annotation that's the only
reason it's there for to mark something
explicitly as portable to be visible to
the client so in that sense it's in your
control what we have on what not
right actually oh do you want - you mean
that the chase informant would be too
heavy
yeah yeah it's actually very fast we've
done some benchmarking on it and we're
very pleased with the results inside of
the browser we're using whenever
available we're using the JSON parse
method and it's shockingly fast I had it
a huge payload far bigger than you would
want to design for like many megabytes
and JSON tough parts came back in no
perceivable time it had parsed it
already it might be a little bit lazy
but it doesn't matter as it's just it's
so fast you can't see it going and on
the server side we have actually written
our own json parser with the primary
goal being performance and it's
extremely fast we can chew through
megabytes of JSON and in no time at all
another reason it's so fast is because
we use statically generated Marshalls so
we don't have one marshalling framework
that just happens to work with all those
annotated classes the moment you energy
the beam with portable with generative
specific Marshall instance at that
particular type so we can really
optimize on a field level for your
particular being how we marshal it there
was another question
well in our PC you would always send the
whole object that's correct so you're
always that sent the full object but if
you you could implement lower-level
events then use a CDI event for just a
change set and push that to the server
oh yeah it's correct if you do an RPC
you get the full object not only the
change server right now well I have one
more question we said at the top of this
talk okay that server-side rendering is
dead but is that really true well no we
might actually be introducing a feature
where you could render parts of the UI
on the server right this is a trick
we've read about that that Google+ uses
heavily although it supports incremental
updates for everything it does it also
pre renders the page and pushes down a
bunch of HTML to you when you first hit
the site and that's what makes it look
like it has loaded so fast and according
to this article that they wrote if you
try to click those buttons as soon as
you see them they don't actually do
anything yet because it's still
downloading JavaScript to the background
it takes a second or two before there's
behavior on the page but you can't tell
because you're still just trying to
figure out what you're looking at so
server-side rendering isn't really dead
what's dead is exclusively server-side
rendering and so we're really keen in
the next version of Arai to see how we
can use these awry UI templates render
them on the server render them on the
client get exactly the same results in
each side so when there's the initial
page load you see a fully form do I
that's correct and then a few seconds
later the JavaScript catches up and it
does something so we're interested in
implementing that in the future yeah and
another future thing we were going to
work on which I forgot to mention is
that when we persisted the cheapy entity
in the browser one obvious question
would be which I forgot to ask you how
do I keep those entities in sync when
the soul comes back online somebody else
might have changed identity and I of the
browser yeah it's gonna happen there
right so that's that's what I'm looking
forward to getting into as soon as we
get back to Toronto the idea we've got
is if you take a JP QL named query
complete with parameters and a where
clause of course
you can specify this little slice of
your overall database it's more than
likely going to be data that's of
interest to only one user like the
person who's logged in say and it will
probably even be a subset of that like
maybe the stuff that's on their initial
home screen so that you can keep it in
the client so you get this little J pql
query that extracts the the information
that just that person is interested in
and then you give it to this
Arai method you say take this query and
give me an object that has all of the
results of this query in it and keeps
them in sync so that the results set of
the query remains the same on the server
and the client and whenever something
new enters the entity manager that
matches that query it will get added to
that set and it will be present on the
client and the server as instantly as
possible assuming that they have a
connection and you're not in offline
mode similarly if the entity manager
notices an entity being removed and it
matches the query that state can be
synchronized as well so we think this is
going to be great we just need to get to
work on it and see if it's as awesome as
we hope anything else all right oh yes
right that's an excellent question it's
about complex objects and do you need to
build DT OS to sort of constrain the set
of things that's going to get matched so
we're hoping we can use the fetch clause
in the J pql query to prune the set of
things that are going to be fetched so
even though like the semantics of the
query say well those will still be
lazily retrieved if you cross those
boundaries we'll use that as more of a
hard limit where anything you didn't
fetch eagerly is simply not considered
to be part of this syncopal data set
that also gets read off that proxy
problem right yes we like to try as much
as possible both in our CDI
implementation and our JPA
implementation to not require proxies
around things so as much as possible
you're working with just raw objects
which gives us maximum speed and minimum
size yes
why the user that's an excellent
question actually we're even working on
a way to just inject an ad model with a
user annotated with model so we bind it
together
the reason we inject the data binder
isn't we had a lot of discussions in the
team about that is that you often want
that bindings to be mutable so what
happens here is the data binder is
fought against that was a very less than
there was the discussion exactly so what
happens here is that data binder the
framework is calling the bind method on
it for all of those fields but having
the data binder you can continue adding
more bindings or removing bindings plus
the day the binder has a lot of nice
utility methods to get access to changes
and to figure out if something changed
or the register property change handlers
so the data miner is just a lot of
utilities you can use and then every
demo we build so far we always need to
involve one of these methods so this is
the reason why right now we're using the
data binder but as soon as in the next
release will have a model annotation so
you can inject the model directly yes
it's a good question great thanks
we just have two minutes left so we
can't take one more question if
anybody's nobody staying around here
though so it's great yeah well I hope we
could have a chance to chat with you
later thanks again everyone thanks for
going</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>