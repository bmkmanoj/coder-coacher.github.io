<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Software Modularity: Paradoxes, Principles, and Architectures | Coder Coacher - Coaching Coders</title><meta content="Software Modularity: Paradoxes, Principles, and Architectures - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Software Modularity: Paradoxes, Principles, and Architectures</b></h2><h5 class="post__date">2013-02-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/D37sb08SodU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome it's very nice to see all here
it's a we are very happy to see this is
such a good turnout so this talk will
handle will will discuss paradoxes
principles and architectures of software
modularity my name is Andrey all shocked
until very recently I have been a PhD
research fellow at the University of
sumfin Denmark there I was investigating
the topic the very topic of software
modularity and this dog by the waste a
result of doing this then I'm also our
creator of the fetchers tool that that
that is also connected with majority I
will talk about the tool a little bit
more in the slides right now I I fight
cancer I work at a Danish company called
decor that does cancer diagnostics with
me is euro of Tula his as you probably
all know he is the founder and the
architect of the NetBeans IDE and the
net which cloud platform he's an
experienced API designer and three known
speaker and outer of several books on on
API design okay so let's get started the
talk basically is divided into into two
parts first I will talk about how you
split up your legacy or your monolithic
application into modules so how we
design the boundaries in this i will
discuss different how would have to
split up different architectures what
principles you can use to guide this
process then there will be a suave
telling about how to design the
interconnections between the modules so
the api's of the modules and then he
will use some paradoxes and principles
to illustrate this ok so basically the
grand motivation of this talk is that at
some point if you haven't done that
already we have to get out of the
monolithic cave basically you you have
probably heard about all this project
jigsaw and all this modular ization
effort that is going on so if it will
not be because of the developers that we
want to switch then at some point there
will also be the management at probably
at your company saying oh there's this
new thing you know what's clouds two
years ago now
have this modularity thing we have to go
for it so it's good to be ready but
really so if we just look at what is
what is a monolithic system so I'm
analytic system that's also where the
cave metaphor comes in so if you look at
this this beautiful picture here it's a
little like a monolithic system so
there's no logical disconnected part
that you can distinguish you know this
of course also applies to software so
this is just a metaphor of a software
system so there's in a monolithic system
there's no logical parts that you can
distinguish if you want to change part
of the system then is very likely that
the change will affect pretty much
everything else in the system in such as
such systems are difficult to evolve and
and it's difficult to control complexity
if in such systems so where we would
like to go we'd like to go we would like
to achieve we'd like to create a modular
system out of our monolithic system
because the modularity traditional
promises that if you did if you
correctly decomposed your system into
intelligible modules then you will be
able to partially comprehend so
partially understand the system and also
partially change it so basically this
promises that a modular system in a
modular system you will be able to look
at one module in isolation from the rest
and understand it kind of by itself and
when you change it hopefully then the
changes should not propagate too much to
other modules and then the tool that you
that you would like to use to do that is
it's a module system so module system is
a tool and basically what module system
does probably most of you know or any
what a module system is but I just
mentioned that what a module system does
is it allows you to physically separate
your logical modules so basically you
are getting something a little bit like
advanced jar files where you can
actually declare the version number and
explicit dependencies and explicit
exports from your modules so this this
all this and forces improved code
isolation however since a module system
is as only a tool
it's possible to misuse it so basically
their decor here is that just having or
just using a module system does not
imply that you will end up with modular
source code it's how you use it so it's
how you design the division into the
modules and how you design the
interconnections between them so that
that's really the motivation of this
talk we will look into how to design
those divisions and those API sin in a
beneficial way so we'll start with
architectures so I will use a running
example here for this part that that
will be we will just assume that there's
a simple system that we want to measure
our eyes it has some it has three layers
the first is you I then there's some
kind of a logic layer that encapsulate
some algorithms and then there's some
domain model layer could be also
persistence underneath this system let's
assume that it provides three features
to the users as you could see by the by
the ovals on the picture each of the
features has on you I that's the kind of
usually what happens every feature has
to have some UI in order to take
parameters and show the results of the
round then it has some logic and they
also has some domain model it parts of
the domain model that that are used in
that feature why why do I think this
this example is particularly good
because it actually kind of is the ball
down it's the essence of several
architectures that you may know if you
for example look at
model-view-controller Model View
presenter onion architecture hexagonal
architecture and some summer
architectures then basically what they
ball down to is this kind of vertical
layering of technical concerns so
technical concerns such as you I logic
domain model persistence okay so let's
say that we want to modularize this
system this is very popular I get
architecture so we have at least Oh at
least three options so the first option
is okay let's just take the packages
let's just let's just take layers that
we had and enclosed out and closed
in one big module that's not much of
modularization but still II we are using
module system right so we we are allowed
to do that in principle okay the second
way we can do it is we simply say okay
let's take the packages as we have them
now and let's try to just rub them with
modules then basically you also get the
kind of layered set of modules that
mimics the original structure of your
application the third way to do it so we
have looked at the horizontal division
so the third way to do it a different
way it has to be a vertical division and
indeed it is so the vertical division
would be to say okay we have to split up
the original structure of the program
and and make each module encapsulate one
feature of the program then we end up
with two features so we have those let's
say we have those three options so how
do we how do you choose what is the best
way of module arising this kind of
architecture yeah it's actually a
difficult question there's no simple
answer to that as we'll see in a moment
because modularity is not majorities is
a relative property of software so it's
suffer is always modular with respect to
something so then then this something is
the changes that you actually want to
prepare your software for this as you
can see there's a small reference I I
give there I would be doing that
throughout the slides and at the end
there will be a list of those references
then you can look up and maybe read up
on those topics in some papers if you
are interested in the slides will be
online then you can find out later on
and so as it was discussed by pernas a
long time ago actually then the
modularity actually depends on the
changes that the sort that your software
has to accommodate in the future okay
let's say and yeah LG just use a simple
example to demonstrate that I will have
to change scenarios the first one will
be okay we want to modify our user
functionality maybe if it's a text
editor and we want to modify how the
spell checking is done or whatever then
let's see how the first
Gitex accommodates this change the first
division into modules in this scenario
you as you can see on the slide the
change will affect all three layers of
the application basically this this is a
little bit problem problematic why I
just haven in a moment as you can see
here I drawn those arrows just to say
that whenever you change part of a
module then since there is no boundary
boundary between what you are changing
and what should not be changed for
example in the view layer then is very
easy for changes to to propagate since
there is no kind of insulation to
isolate the changes another thing that
this is very problematic it's not only
the changes dislocated or delocalized
over the three modules but also the
scope of change is actually divided
itself so basically the boundaries of
modules coming your way so let's imagine
that first you you are looking in the
GUI of your program okay you know which
GUI elements implement the feature that
that you are changing then in order to
track it down to bottom layer you
actually have to hop over the boundaries
of the module and actually this this
kind of decision ears what will talk a
little bit more about that later but
this this kind of stuff is is quite
problematic so in contrast if we look at
the second architecture this change is
very well accommodated just perfectly
corresponds to one of the modules
brilliant very nice so if we just look
at a different change scenario which
could be kind of interesting to some
people migrating your UI to javafx
that's kind of a different different
kind of change as you can see the first
division into modules that's that's
really perfect then you just take the
old view throw it away we implement make
the new one and pretty much the
controller and the model layers will not
be affected so that's a very nice
scenario however if you look on the
second division into modules that we
that we have this change becomes a
little
ematic then we run into exactly the same
problems as I discussed later for the
for the first division with the first
scenario so the change is delocalized
and it's it's easy for the changes to
propagate to the code that should
increase it will not be affected so
basically there is no silver bullet
modularization you always have to look
at the changes that you that that will
happen in the future but of course how
do we how do look into the future that's
a little bit difficult one thing we can
do we can improve if you have
experienced programmers or experienced
domain experts maybe they will actually
anticipate some of the things that may
happen maybe you have worked on similar
on similar projects to to what you are
doing now so then you can reuse that
knowledge there's no some other sources
of data about that there are several
papers that report on the software costs
costs in organizations what is commonly
reported in those papers is that during
the evolution period of software is the
users that drive the changes so 75
around 75 percent of changes during the
evolution and maintenance of software is
connected with enhancing adding or
fixing features functional features for
the users the remaining 25 years is the
rest is other kinds of changes just to
give you a kind of a more yeah more
overall impression about the importance
of this thing I include this part so
from this other green pie chart you can
see that that's the face of software
evolution and maintenance typically
typically consumes from sixty to ninety
percent of of costs in organizations and
that resharpen sharply contrasts with
the ten to forty percent of the initial
development so so preparing for a whole
industry that's very important point and
so basically conclusion from this
picture is that that out of the two
divisions that we have seen out of the
to change scenarios that we have
considered the one con
with ears are functionally that's that
that will tend to happen more often so
we have this kind of understanding we
have this kind of mental framework but
does it work we have actually tried that
in in practice this kind of an idea
there was an application called NTV's
that is developed by a company called
visit trend basically the tool is a tool
for neurological analysis kind of a
complicated domain so so basically the
story behind that was that the the
company wanted to motorized this this
piece of software they they were also
kind of undergoing the NetBeans training
and let me reach kyle at foreign navies
module system then we actually got
connected to them a true getcha from the
NetBeans team so that was that was
really nice because he heard oh you need
to motorized this piece of software oh I
know the guide I know a guy that is
interested in modularity he has this
tool let's see if it works you know we
can try it out so that that was Rico so
the idea was the company wanted to bring
the end of each application from from a
monolithic state to port it to the
NetBeans module system and then
gradually scale up to the to embrace the
whole NetBeans rich current platform the
motivation for the four modularizing the
code base was to improve the functional
customizability of the of the program so
that it becomes easier to take features
in and out of the of the program and to
evolve features in the plant
independently for from one another
another point that was that was very
important for the owners of the of the
project was to improve their
reversibility of the core algorithms of
the of the software because then they
had a larger portfolio of applications
that they were developing so they wanted
to reuse some of the parts that was not
very possible with the monolithic
approach so they need to modernize so
the starting point was that the
application was actually quite small as
you can see was only ten thousand line
of code lines of code and 27 use cases
so that's that's kind of small it's it's
not not so small to be
a toy example but it's certain not a
very big system however what made the
the whole thing the whole transition
quite quite problematic was that the
code base was was unfamiliar to us when
we started and the domain to this day I
don't know how what really happens in
that this neurological analysis thing
add a little consists of a like a
visualization of neurological data I
don't really know how it works but this
didn't prevent us from modularizing the
software so basically we had this tool
that is called features then we we
basically use that to to modularize
ndb's how we did that was what there
were several steps of doing this the
tool is is a plug-in to the NetBeans IDE
so builds up on the on the on the
libraries and and has integrations with
code editor and stuff like that and you
can also find it online and also find
the sources you can play a player on
good so basically how how the process
worked was first we actually needed to
uncover where in order to modularize
features of entities we need to uncover
or find where actually they are
implemented so we need to find the
packages methods classes that implement
each of the features so that we can
actually kind of understand how they
work and how they relate to one another
so if this will be difficult to split
them so we did that through so-called
feature location that's basically a
fancy name for establishing traceability
links between features and source code
so basically finding where the features
are implemented in features this is done
through dynamic analysis so we trace the
execution when of a program when when
the user interacts with with a program
then we basically this way we are able
to tell which which metals gets executed
based on this traceability information
features provides a number of feature
entered views so basically there are
some visualizations on top of the
traceability links like there's some
different plots and graphs so you can
use that to understand how features
write to each other how they are
implemented in terms of packages or
classes and then
based on this kind of understanding we
performed an observer atif modulation of
features so we're taking some features
each day and and modular rising them I
could help in doing that was was this
kind of tight integration with the
NetBeans IDE so for example one of the
things was that while programming we
were able to see those colored side bars
next to the code that saying okay this
this method is actually implemented by
is contributing to this feature and that
features so then that was very it was
that was helping a lot then the last
step was establishing module api's that
the tool does not provide much support
for that it's more like kind of a manual
process and how to do it you will hear
more from yours love so using the tool
we were able to modularize NTV's in only
35 man hours that was completely
unfamiliar code first so that that was
kind of a kind of a good result you can
see the structure that we achieved so
it's kind of a mixture between the
idealised vertical division and a
horizontal division so we arrived at
explicit and pluggable feature models
which means you can take features in and
out from the system without changing a
single line of code by just loading or
unloading the modules and then the core
modules underneath there can actually be
flexibly reused right now with in other
applications without taking without the
need for taking the features together
with the core modules because the core
modules do not depend on the future
modules yes so that's basically
concludes the architecture architectures
part so definitely transitioning from
horizontal to vertical is possible it
can it can be done and in a reasonable
amount of time then in order to tell
about how you can do it how you can
guide the process we I will mention some
principles so what I would like to
promote or what I would like to sell you
in this talk is that the separation of
concerns is on the only principle you
will ever need I will try to show you
why so what what is separation of
concerns what's
was the terminal traditional was coined
by Dykstra in 74 that is to study an
aspect of a subject matter in isolation
that's a little bit kind of difficult to
grasp but so what are the what are those
concerns concerns in your program could
be your implementation of your use cases
or your features could be your
persistence that's one kind of concerns
could be security that's also kind of a
good example of concerns caching and
some others so the notion of concerns
and this kind of a point of view that
there's some more to software than just
classes and methods was later refined by
the aspectj guys you probably know about
that aspect oriented programming and
they're all so sad a hyper J guys that
was also a little bit similar to aspect
orientation but yeah I've had some twist
on it so basically those two approaches
aspectj in her pj they emphasize that
there are multiple so-called dimensions
or types of concern so for example if i
have one concern that is safe my
document then load my document and
another concert that is it may be
persistence then kind of the the user
feature their user concerns that carry
out some task for user one dimension and
then the persistence kind of an
orthogonal dimension to that so what
what happens often with concerns is that
they cross cut you probably heard about
that the particular two facets of
cross-cutting is scattering tangling
I'll talk about that a little bit more
so when you motorized basically when you
use the separation of concerns principle
basically it boils down to reducing
scattering Antonia features so what is
scattering scattering is happens when
our concern is implemented by several
models so when when it's de localized
over those modules so in order to in
order to reduce that you need to ensure
that your your concerns would be
localized this of course reduces the
scope of change because there will be
only one place that we will have to
change and then it also reduces the I
think of the localization which is a
software comprehension phenomenon so
basically there was a paper that said if
you have to change
stuff in multiple places it gets more
difficult to understand so there's also
the the second thing which is tangling
and tangling occurs where multiple
concerns overlap or use the same piece
of code so basically you don't want that
because when you change the piece of it
let's imagine you want to your intent is
to modify one of the concerns and you
end up modifying code in that is shared
between this concern of interest and
some other concerns so what may happen
is actually that you may break another
concern that you are overlapping with in
the process and you don't want that so
it's best if you keep that your constant
separate yes separation of concerns
exactly this this also reduces the
so-called interleaving that's another
software comprehension phenomenon by the
way that says that if you have several
concerns that overlap with one another
then the code just gets more difficult
to understand that's kind of kind of
intuitive so I also I like to include
real-world metaphors and I often use
that to explain stuff that I'm doing in
software to my girlfriend and to my
friends that are not that fond of
software so in order to grass better
what I concern is we can look at a book
this book you probably know it's Lord of
the Rings it you could say it consists
of three modules and am I push yes so I
know now I know that why my friends
don't want to talk about software with
me now but yeah so so basically the book
consists of three three modules so there
are three parts the book is decomposed
according to them the dimension of time
so first part of the book is first
period of the time of time and so on and
so so that's the kind of the design of
the book you could say the structure but
there is some more to it if you look at
the concerns of the book there's several
concerns there are even several
dimension of concerns so several
concerns are like marriage people some
Frodo so those some characters the
characters dimension of concern there's
also some locations or some themes like
Moria that's another dimension of
concerns so and as you can really see
graphically on the brave on this
brilliant picture that i found on the
internet it's really the concerns really
tend to kind of tangle with with each
other and tend to be scattered over
different parts of the book so that's
that this metaphor I really like okay so
we kind of got the grasp on what those
concerns are what tangling is what
scattering is kind of that's Albert may
be foreign to you so I thought it would
be a good idea to kind of help you to
map this separation of concerns thing to
some other principles that you may may
already know so we said that there is to
face faces of separation of concerns
scattering and tangling so if you look
at scattering that deals with localizing
stuff putting in them in one place you
may know a principle called information
hiding that basically says you should
not reveal too much you should each
model should have a secret that should
be guided so this secret should not leak
out then there is a another principle
called low coupling that's all so
basically if you look if you put stuff
in one place then obvious you you reduce
capping so that's good there's also the
dry principle meaning do not repeat
yourself and that's also kind of if you
have thing in one place then it will not
be you will not help yeah that's
basically what it what it means having
stuff in one place prevents you from
having clones of this thing in some
other places so if we look on the
tonguing side right now there's a
principle called single responsibility
basically if what you have in your
module is not tangled so itself only one
one purpose then it has single
responsibility so that fits very well
and that that's very similar to the to
the principle of high
asian so cohesion means serving a single
purpose but that's almost almost the
same as single responsibility there's
also another principle called common
closure that says things that you group
together in a module should always
change together so if you have the same
concern or single purpose of the things
that you group together then they will
always change together so just as the
last thing I will I want to tell a
little bit about measuring this these
things because it's it's own eyes that
that we have those principles and it's
it's all fine but sometimes you know
there's this famous saying that you
cannot control what you cannot measure
so in order to be able to understand in
what state my program is so how much
effort would it take to modularize it or
when you are done modularizing to
actually evaluate evaluate the results
and they even present some fancy pie
charts or some fancy plots to the
management then then you need to measure
these things so there are basically
three options that I can see the first
option is do the concern location so use
some kind of a mechanism either static
or dynamic or something else to find
where the concerts that you are
interested in are in the code and then
use some of the concern oriented metrics
there are some you can use that there's
a paper that reports about this being
done at motorola i'm not sure if they
are doing that still but they tried that
at some point and the paper kind of the
conclusion was kind of optimistic so
it's definitely possible also at
companies not only at universities
there's another option is to go with
static analysis and then the metrics of
cohesion and coupling that's kind of
there's a lot of tool tools out there
that can do that for you so you can also
use that to get an approximation of the
scattering entangling but there are some
some kind of some kind of corner cases
like for example consider the tension
between the coupling between coupling
and code clones
if you have a class a that depends on
Class B for something maybe calls a
method there is some kind of dependent
hitters you could say there's some kind
of coupling between the classes what you
could actually do to remove this
coupling is to say okay I take this
method from here copied bullet in this
class I have no more dependency but it's
probably not really what you what you
what you want there's also this case of
the unco he civ java.util package so you
know there's a lot of a lot of stuffing
in Java util it's not really cohesive if
you if you use the coefficient matrix on
it but this kind of packages they occur
in in real life so real life is
definitely not ideal okay and the last
the last thing the last way of measuring
that you can actually do some repository
mining to to check how the classes
change together in your program so if
you plot that on the adult for each
class on the on the axis of time you
will see if the classes that are that
you have put into modules actually
evolve together because if they don't
then then you can then you have a
problem okay just to sum up and
transition to to your stuff what like
the key points is that I wanted to tell
you about is that module system is not
is a tool it's not a goal in itself so
it's module system is there to help you
but it will not not do the job for you
it's it's you that has to design the
modules so there's no silver bullet
modularization it's very relative it's
possible to restructure horizontal to
vertical and I was trying to convince
you that separation of concerns is a
root of all principles and that that's
the only one that Yuri have to remember
and the rest you can just go top down
and kind of figure out as you go okay so
these are the references you can read
them later on on the web when we sit so
yeah then you there are some some
interesting readings here yes okay so
let's put the MJ stalk into different
context I really like it yesterday when
we practice I was amazed about the
content of his
part but what I like to talk and
concentrate on is API design because
when you have modules you need
interfaces so the modules can
communicate and when you start designing
ap is well as an initial architect of
NetBeans platform I spent a few years
designing api's and you may realize that
the rules to design ap ice is are
slightly different than the traditional
rules that you use during software
development and I managed to collect at
least 20 different paradoxes something
that slightly does not match our
day-to-day expectation unless you have
good enough knowledge of API design and
I will try to go through some of these
paradoxes and put them into context of
modularity oh yeah okay thank you no
that's too much no
okay I think yeah exactly yes oh now it
should be fine okay thank you so the
first thing to say is that all the
recommendation all the references that
on Jay presented talk about the change
to minimize the change whenever you have
new feature requests you should be able
to implement it easily without changing
things on it so many places if you have
good enough modularization but this is
not what you can do with api's you
cannot change api's because if you
publish api it's like a star you never
know who is observing it who is using
the API so you just cannot delete a
method somewhere in your API and because
you cannot know all the places all the
users and you cannot fix all the usages
so basically the we still need to deal
with change when designing API is
because we want to improve the api's but
it's not like then you change something
you need to go somewhere into all the
usages and modify them that's just not
possible Andre said that the initial
development of well is about ten to
fifteen percent of every project and I
can confirm that basically designing
api's is most of the time just
sustaining when you are creating the
first version that's sort of innovative
process you can feel like an artist but
then when you are about to do this new
and new version of an API you need to
care about the previous usages of the
API just cannot completely change it and
that feels like a sustaining which
implies that basically you have only one
try to do the API right
of course we should anticipate what will
happen in the future because it it's
completely clear that however you try to
design your API at the beginning you
will do something wrong that the
requirements will change evolve and you
will need to update the API so for that
I like to separate the api's and SP is
client AP is that people call in and
service provider AP is that people
implement because if you tell someone to
implement an interface you cannot in a
subsequent version at their new methods
so basically it's like a fixed point it
cannot be modified if it's a server
service provider API if its client
provider API then quite opposite every
release your users will be more and more
happy if you add new methods into your
API because they will have more to go
and basically you are not breaking any
one by doing by adding something into an
API that cannot be implemented by anyone
else you can just please newcomers and
that leads me to the topic of backward
compatibility so I know that the court
compatibility that there is source
backward compatibility binary backward
compatibility and functional
compatibility the source means that
whatever used to compile against
previous version of your API should
still compile this is slightly hard to
achieve in a Java because we have wild
card imports so basically whenever you
add something new into an API someone's
code can break because the compiler will
not be able to identify which type the
code wants to import so the most
important compatibility of basic
compatibility in Java is
binary compatibility which basically
means if i compile against previous
version of your library i want to run in
the dead version and also its subsequent
versions without recompiling so it's
just about linking on a class on a class
level and some basically the paradox fix
from my book describes I have some
differences between source compatibility
and binary compatibility because the
format of Java byte code is very close
to the structure of the Java language
but there are differences and sometimes
these differences make a huge difference
and then of course at the end functional
compatibility is the most important one
because you not only want to link with
some new version of the API but it
should also work correctly and achieving
that is slightly hard you probably need
to write a lot of tests to guarantee
that you keep the same functionality of
the vial producing new versions I I
tried once to live without AP is my
website is powered by mediawiki witches
marathon in PHP so I happened to be a
PHP developer beginner and I'm basically
the way how you deal with mediawiki and
probably with other PHP projects as well
is you download the sources you unpack
them and then you start to mangle and
change them well that's perfect thing at
least it feels there are no IP is no
boundaries enough you can do everything
well yeah so I did it and then new
version of mediawiki was released and I
could not upgrade it probably that's the
reason why people don't update running
servers that much because I could of
course apply the same disc to the new
version but would they fit in probably
not because the media VK developers did
changes possibly in the same classes as
me and my my pitches would no longer be
valid and also similar story that I
heard by my colleague he had a system
the day for tracking issue requests
inside of a company sophisticates and
and they had a lot of customers I'm but
they didn't sell the system as is
usually they also delivered a consultant
with the system and the consultants just
went into the source code of the system
and change everything tweak it so it
fits the needs of a particle customer
and then they had problem because they
could not upgrade to new version the
company produced new and better versions
of the software but nobody was able to
take the version and replace it on the
customer side and as a result the
customers that were seeking in upgrades
usually switch to a competition because
if the upgrade is as painful as switch
to new system why right right upgrades
so having API basically gives you even
Royal customers it's surprising that
usually when designers or architects try
to design a system they concentrate on
our relationships between classes and
sort of logical design but the physical
design how do you structure modules is
at least as important as well maybe even
more because it influences how you can
deploy things it shows what should be
the interfaces and the interfaces should
be stable so during your development you
should concentrate on providing good
api's between the modules so clearly the
physical separation matters a lot
um we have good example of how
modularity helped us because and
actually modularity in form of osgi
because we wanted to share code between
NetBeans and jdeveloper and for that we
basically started to support osgi inside
of the NetBeans platform and meanwhile
the jdeveloper team a river all the data
system to use osgi and by having with a
common ground we could basically start
to share between those two systems so
really modularity helps you a lot even
in sharing and improving care design
what is essential then you want to share
when you want to take something from one
system and bring it to another is how
heavyweight your module is and the
weight of a module is usually described
as the amount of outgoing dependencies
and dependencies are there to basically
described the necessary environment for
a module because modules don't live in a
vacuum they they always need something
your your java code needs jdk your java
EG gold they'll need web and application
server and with tons of modules you
somehow need to specify this and this
environment is usually specified by
dependencies and the more dependencies
you have on other modules the hard is it
to take these modules and bring them
into different environment I have
example with Milan Milan is originally
Eclipse technology and we are now
reusing it in netbeans and again this is
possible because of modularity because
of supporting osgi and whenever we wants
to take a module from from from Milan
for example bugzilla connector it really
helps
the milan team decided to separate the
core implementation of the bugzilla
connector that you are from from its UI
so there is one module for the core
implementation and one module for you
are and because eclipses SWT based and
we are suing based we don't want the UI
we want the core functionality but if
they made a mistake and put the UI and
the core functionality into one module
the outgoing dependencies would be
really huge and the module would not be
arranged able at all so that basically
says that if you have a module it should
probably be targeted towards a single
single goal you should not mix the
concerts um I've read really nice book
about modularity by written by Kirk and
he basically argues that you reuse
complicates use basically if you have a
monolithic system then it's much easier
to to code against it but if you want to
do what we did with the Milan or with
the jdeveloper guys something like take
the functionality and bring it into
different environment then it's much
better to have finer granularity of the
modules because then they are more
reusable and click argues that these two
forces goes against each other and
cannot be solved and actually I wrote a
paradox about that where I'm trying to
introduce a black box pattern that
basically tries to do this and the
example that I use is in netbeans we
have a module that can talk to a browser
so from so code inside of the NetBeans
IDE can open up a web page in a browser
and and this module has a simple API
show a show URL and it has no
implementation but it's declares in its
dependencies that it needs an
implementation and then we have about
four modules 1-4 windows one
for Mac 140 Linux one for solaris that
basically implements the API the service
provider interface of that module and
hooks in and then container the NetBeans
runtime container knows that as soon as
someone wants to use the API it needs to
also enable one of these modules
depending on which platform you are
running on but the user of the API
doesn't see that at all so basically
everything remains module modular you
can still reuse individual modules there
you can play with it but the user unless
the user is really interested in doesn't
mean to carry everything works ok and
that's basically possible in osgi 4.3
because of their capabilities they
support that as well so I decided that
for the purpose of this presentation I
will try to explain solid and apply
solid rules to api's so here is a
prescription of dough or with every
solid rule I'm trying to match it what
it could mean for designing api's so
single responsibility principle usually
talks about a class should have a single
meaning so I mentioned that it is better
if a module as a single meaning if you
if you want to reuse it also I've
noticed that the modifiers that we use
in Java like public protected our don't
have single meaning if you make a method
public somewhere what is this good for
you can call it but someone else can
also subclass the class and override the
method so it has a double meaning it's
much better and having clear meaning of
things helps the communication between
the API designer and the user so
basically we prefer in that means to use
public final that's only callable method
protected abstract
that's the one that you have to
implement and protect it final that
means if you subtract if you can call it
and those combinations of modifiers have
single single meaning and I think it's
much better to use them when designing
ap eyes open cause principal so it says
that class should be open for
subclassing but closed for modifications
that's sort of okay for the provider
api's if someone is going to implement
some interface then of course you cannot
change it it's closed you however are
following this principle for client
api's would be disastrous we tried that
once and as a result the all over the
codebase we had to put if instance of a
subclass of this class then do something
differently and that's a relatively bad
so I rather use final classes for for
for the client API and I can then evolve
evolve them so they are not that closed
and I but because they are final I
cannot hurt anyone by adding something
into those classes liskov substitution
principle says that if there is a
subtype of your type then you can use it
instead of the supertype in all places
which is not true for a WT just try to
put jframe on the place of jbutton it
won't work in spite frame extends
component the problem is that people
often use inheritance not to express the
subtype principle up just to reuse code
and that's that you can do it if you are
if you are not in API business but in
API business it's big no-no it's much
better to not expose it
if hierarchies at all especially if
client API is final class and they're
basically basically can be deep
hierarchy anyway and rather than doing
things with inheritance it's much more
safer to do things with the delegation
okay interface segregation principle so
you should it says that you should call
code against interfaces not
implementation and actually in netbeans
platform as well in osgi the modular
containers really support this they
encourage you to create an abstract
interface it doesn't have to be
interface it can be abstract class and
then let other modules to register their
implementation and they provide the
module system provides you away how to
obtain all the all the implementations
so this vote goes very well with
modularity and API design dependency
inversion principle yeah I once I got
into argument with dependency injection
fan who claimed that netbeans API is our
old are too old-fashioned and they use a
lot of Singleton's and Singleton's are
bad you cannot use Singleton's every
dependency injection fan knows that well
actually I that made me think about the
reasons why we are using Singleton's and
why they are not dead back and I
realized that V in netbeans have some
special form of inject singleton which I
call injectable singleton and I
described that in paradox 14 and I think
it works relatively well so the lesson
to learn is don't just climbs unless you
understand what they are based on
and few more paradoxes how api's look
from a point of view of a user so in
paradox one i define that all users are
clueless that they worship cluelessness
and I I don't think that's anything bad
on that because we always have something
better to do than fuel understand
libraries that we are usually using
occasionally and the API design should
support that you good API should be used
even by unexperienced people and yeah
that basically leads me to an evaluation
of an API some API can be evaluated from
three perspectives coolness time to
market and total cost of ownership so
cool ish is good because if some API is
not cool you won't notice it exists I'm
to market is essential it supports the
cluelessness you basically should be
productive with the API immediately and
but total cost of ownership is very
important in long term because you are
not about to create just application but
you are going to maintain it and you
will upgrade your libraries and you want
to upgrade not to negatively influence
functionality of your arm of your
application so basically total cost of
ownership is very important in the long
term and okay so okay one claim that I
made and I basically observe it with
Milan guys as well if you have cold
which has api's it's easy to maintain it
then if you have a code without AP is
because users of your API are
programmers can program they know how to
write unit tests so and they also know
how to create etches so if you have API
and you are open to contributions then
you basically can ask or offload the
work to users of your API whenever they
want to improve something you can ask
them to do it
that's exactly what the Milan guys did
with me I needed to contribute patches
and they said oh no but I'm formatting
mm-hmm next one so what but it works for
them very well and actually we are
trying to do the same thing in the beans
as well and the last thing to say is
about beauty sometimes you may want to
reject a donation into your API because
it's beautiful and I think it's a
complete mistake api's should be
practical which they should be usable
but the beauty unless it hurts time to
market or cost of ownership is not
important at all and also I should
mention it you should optimize for the
end users of the API not for the writer
if writer of API says all I'm the code
is so ugly I just don't want to do it I
I don't want such AG made I don't want
to maintain such a gray code then that's
a completely wrong argument because we
don't care about a single writer because
we care about the usages of the API okay
so it's time to finish I should mention
that this is my book that i've just
finished but actually it's not available
on amazon yet we are in a review process
but if you want you can visit this URL
and at least browse the online resources
on my website if you are interested in
and in a week the book should be
available so thank you questions
this
there was Alison co-star
yes there were no interdependence that
No
that
yeah okay so the question was about the
diagram that I showed us the result of
the restriction of n TVs and that there
was no dependencies between future
modules was that accidental or was the
intended or how in how was that achieved
basically so yes there was indeed no
dependencies and that was one of our
goals because if there were some
dependencies between features then you
basically features you cannot take one
feature out of the system without taking
dragging another one with it but what we
also found out is that some features
will tend to will be dependent on each
other basically this happens when
they're exes like you could say
semantics or semantic dependency between
features like so at the level of
requirements if you say let's have a
feature that is safe document and create
annual document right you cannot save
the document maybe that's not the best
example but there will be there will be
some features that will have to depend
on each other maybe what if one feature
is part of another feature so there's
are some kind of a composition between
them then then then this kind of stuff
we'll look here I'd like to add that for
example my my case with the browser it
also has features so we have browser for
a linux mac windows and they are they
they are completely isolated but still
the API has a dependency a reverse
dependency on one of those
implementations so really there can be
dependencies on among the features yeah
okay any more questions
we saw that most of
but not
okay so the question is how we will
rewrite netbeans module system to
coexist the jigsaw well it is it it will
be done by the oil GI guys because
NetBeans is interoperate with osgi
jigsaw interoperate with osgi so that
will be solved by someone else well so
that's not going to be that easy we
probably do something but overall it
should work we basically basically
demonstrated that we can coexist with
other module system osgi so he should be
able to coexist with jigsaws phone</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>