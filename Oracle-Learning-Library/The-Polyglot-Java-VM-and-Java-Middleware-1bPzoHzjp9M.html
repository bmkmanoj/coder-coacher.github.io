<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Polyglot Java VM and Java Middleware | Coder Coacher - Coaching Coders</title><meta content="The Polyglot Java VM and Java Middleware - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Polyglot Java VM and Java Middleware</b></h2><h5 class="post__date">2013-01-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1bPzoHzjp9M" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I am Bob if you are Java programmer
of a certain age you may remember the
code house I'm Bob the despot from that
I'm a founder of the drools rule engine
project and also torque box which is
what kind of where I got my start in
polyglot world on top of the jb m and
i'm currently the director of polyglot
works at jboss most leaf in terms of
middleware over the years i started in
c++ and to java then i went to ruby that
unfortunately i came back to us either
speak louder alright alright alright so
you know why I'm here is because Java is
not the only language out there I know a
lot of us like to have our Java projects
and we work just in Java but there are
other languages out there that are each
serve their own needs that are useful
depending on what you're trying to solve
in just a quick example I mean there's
Ruby enclosure and Scala and bring
and Erlang and everything that's out
there right and you know they each have
their needs um but most of the people or
many of the people who use any of these
languages kind of a shoe the whole
enterprising nature of Java you know a
lot of them have been Java programmers
in the past and they didn't like all the
enterprise eNOS of it and ran off to
play with ruby on rails or such and this
can be exemplified in like tweets like
this one from coding horror we says it's
awfully enterprising it's mine is my new
shorthand for your code sucks you know
and I think that's because we we we did
back in the day of like Java to or
whatnot we had a lot of XML we had to
write a lot of annotations and things
that just were larger than they needed
to be and that these little languages
out there like Ruby which is started
doing convention over configuration have
taught us some things and then Java EE
has accepted that and regardless of
whether you're using Java the language
or not there is a lot of good technology
especially in the Middle where space for
java so all these people who say stuff
like this they say it because they're
ignorant you know they they may have
done Java back in the day but they don't
recall you know where they don't know
now why Java could actually be
beneficial and we also have to realize
that Java was not always enterprise-e I
mean you remember Java 118 and your
applets running in your web browser and
we didn't have all this cool stuff that
we use now to build our enterprise II
scalable systems you know things like
transactions or messaging or caching
which all grew out of a need and you
know working through the JCP the Java
world did
I hate little is the standard I some of
this stuff let's let's get some of this
enterprise-e stuff we need to build
large scalable applications and
ultimately along the way Java solved a
lot of the same problems that the people
will see solved back with Corvo back in
the day right but ultimately other
languages out there haven't figured this
out yet instead they just say oh man
rails can't scale and some they go back
and start writing stuff with Java you
know we're really it's not that rails
can't scale it's that just using only
rails with MRI maybe can't scale but
once you start throwing in some actual
middleware then maybe you can actually
get the scalability you want so will
they say can't scale but then they start
to worry about you know scaling their
apps you know and we have to realize
that that when you talk about
enterprise-scale apps regardless the
lingua sure you're writing in they all
requires certain amount of
infrastructure you know that a lot of
times messaging becomes important and
you look at the rubios of the world and
they start playing the Rubio RabbitMQ
you know which is Erlang but still they
they start mixing together all of these
little technologies they play the rescue
or were you know delayed job or whatever
they need to do trying to stitch
together something that will scale using
these little languages that aren't Java
and of course you can do that you can
assemble a stovepipe you know we did
that in Java before we had java ee that
was kind of this platform we could work
against you know we'd pick this little
thing and that little open source
project and pull them all together and
you can do that you know and you can
look at it and say rails is quick and
easy man that's also mike and i can
build an app in like four hours right
but then i got added memcache d to kind
of cash some things so that can go a
little faster maybe have my database
less then i got some scheduled draught
jobs and i'm using Ruby on Rails and so
I got to play with crontab and then
maybe zookeeper to kind of coordinate a
couple of machines together but then
what how do I really cluster and scale
this whole amalgamation of all these
technologies we've taken together you
know but if we stay take a step back and
look at the JVM it gives us a common
substrate that we can work against the
GV i'm not java the language but the JBL
and we can approach it from two
different directions you think like yeah
so we have java developers who want to
use other languages and we have non java
developers who need middle
whether they know it or not and the jvm
is where we can bring all this together
because the jvm is actually a polyglot
JVM sure it has a J in the front of it
but that doesn't mean that job of the
language is the only thing that can run
on it so a little tangent i said i'm the
founder of torque box which is where
we've taken JRuby and we included to
jboss as7 and so it now runs Ruby and
rails apps or whatever we also then took
Ruby included on to a lot of the job
java ee specs like JMS you can now d
message driven beans with Ruby we glued
on top of an finis fancy have your
distributed caching with rui we took the
court scheduler and we glued ruby on top
of that so now you can do scheduled jobs
you know this is all within the single
process of the app server that's running
but what we found was that we actually
have better at option from Java
developers than we did from Ruby
developers that it was much easier to
actually convince people who already use
a middleware who understand the need for
all of these different types of
components that hey you know here you
understand the middle weary but you want
to play the different language you can
come use torque box we found a lot of
great adoption that way as opposed to
trying to take all this middleware and
say hey rubyists now look you have
middleware available to you so you know
it's something we got to kind of work on
from a marketing perspective if we
really want to get other communities out
there using the JVM and middleware as
their ideal runtime but one good
question is why write another virtual
machine for another language you know we
were talking about these other language
on the JVM but we got to get them on the
JVM to start with you look at something
like Ruby which has MRI you know that
that has its own virtual machine that
was written just for Ruby there are
other languages out there they have
their own virtual machines written just
for their own language where the JVM is
it's pretty awesome I mean a we got real
threads which is a lot of these VMs
don't really have had a really good
garbage collection I mean last I heard
there was like you know 100 people
working on each garbage collector Oracle
or something I mean you guys invest a
lot on garbage collection um and we get
a common model for multi glatt you know
and what I mean by that is I mean we
have you know we from whatever language
you're using we have the same calling
conventions the same FICO that get
submitted the same idea of what an
object is and the JVM gives us that that
kind of ronde
point that we can start bringing objects
and then calls from one language to
another language across the JV oh it's
been optimized out the wazoo and it's
just a journal useful virtual machine
you know we got to stop thinking of it
as just that the Java Virtual Machine I
mean I know job is the brand that's
applied to it but it's a virtual machine
in Java is that just happens to be the
first language that was on it so you
know before 2010 or maybe even earlier
we had one GV m which was great for
running java but today we have one JVM
in the other over 20 languages and if
you went to Charlie nutters and tom n
debose up off the other day they
actually presented 99 different
languages that run on the JVM and to me
while you may not want to use all 99 of
these languages to me that shows that
there is a lot of possibility out there
that you can bring all sorts of
languages on top of the JVM and you can
benefit from all the experience that has
gone into the construction than the
engineering of the JV o so some of these
languages are inherently JVM centric
they were built from the ground up to
target the JVM whether that's closure or
Scala or jboss a salon project you know
that's that that's the easy win right
there some though our first-class
implementations like JRuby or dine Jas
orn as worn I mean these are things that
were not initially written on the JVM
but the languages are accepted these
implementations now in the JVM are
accepted to be first-class citizens of
that language specification you know
JRuby you spend time over the years
trying to become a first-class citizen
charleen Tom worked like crazy to get
the Ruby the language specs suffered
from Ruby the implementation and with
JRuby and Rubinius and Ruby acts and all
the other Ruby implementations out there
we finally achieved that for JavaScript
thankfully there's always been a lot of
implementations of JavaScript and all
sorts of languages and so there's a
speck out there you meet the spec you do
great some of these languages
unfortunately a little subpar like Jai
thon you know they're the Python
community is pretty much defined by the
Python implementation it's kind of like
the Pearl community where Pearl's is the
spec is the implementation the only
thing that can implement parole is pearl
and and so jivonne unfortunately is kind
of in that same boat but I think with
some ever we can start bringing the the
Python language community and let them
view Python implementation C Python
separate from the
vm implementation and maybe get jivonne
up to be a first class citizen so this
isn't the talk about middleware and i am
from jboss and so this is the jboss
approach to polyglot oralism it may not
be a word but I like that word so we're
going to call it so my approach is first
of all to stop re-implementing
everything you know we don't have to say
hey here's the new language of the week
let me go rewrite transactions and
caching and everything at it we don't
need a transaction manager written in
Ruby we don't need a message broker
written enclosure you know and we don't
need to distribute to cash rent and
JavaScript because every java ee app
server out there already has all this
stuff it's always already running on the
JVM we have this functionality that
people have invested a lot of time and
effort into what we need to do is simply
map these languages to this middleware
and thankfully musta most most of the
Java EE stuff these days is not written
to be very very specific to Java the
language or if it is we can bind to it
so here's here's a slide of how we
approach torque box on top of jboss as7
you know everything in blue kind of
comes out of the box from the app server
and torque box just glue the Ruby on top
of it you know we have rack which is
kind of bound to servlets you know we
have web sockets in there we have
scheduled dot jobs all sorts of things
but we don't have to implement this from
the ground up we didn't have to say all
right let's go implement XA transactions
using Ruby code you know that that's an
effort in insanity right there but hey
we have it in the app server let's use
it so the general approach is to take
the app server the AS plus a language
runtime and then you get a language
specific AS and once you have a language
specific apps where you have language
specific middleware and or what you can
do is take like us are q23 and just mix
in a little bit of another language into
your app but that's kind of boring i
like to go whole hog let's give you a
whole Middle where stack so when I say
mapping so like this is where we took
the servlet API right and we mixed it in
with a ruby to get rack we mixed it in
with closure to get the ring API I'll
mix it in with Python to get wsgi for
caching we have the closures core cash
or we have the rails cache API so and we
just map that down to our existing Java
middleware so now from your
males web app you can do some caching
and is actually putting it into the
infinite span distributed replicated
cash or coherence if you're an oracle
user you know for scheduling and
messaging you know hey they don't have
middleware in Ruby yet so they'll let's
invent something because they don't have
AP is that we can necessarily find two
and this is an important I think
especially when you think about like
platform as a service and moving into
the cloud because really das is a
platform as a service it is a place a
substrate and pom which you can put your
app and then you have all these services
if you're trying to stand up a new a new
product or a new service out there and
you have to start up you know a hacker
mongrels and also headset stand up
rabbitmq or a whole lot of services now
suddenly you don't have a platform as a
service you have a whole lot of little
bits and pieces where if you're running
on top of an app server regardless of
the language you're using you have your
platform right there you start your app
server you give it your app and then app
has all sorts of components it's not
just the web layer plus these other
things running in other little silos
it's basically everything's in the 10
and the real benefit for that when you
start talking about operations is that
you have a smaller management service a
JBoss has spent a lot of time on their
own whole domain model to make it easy
to manage a big cluster full of app
servers you no longer have to think
about you managing 15 discreet little
services or even you know 15 nodes and a
cluster we provide a singular management
layer for all this stuff and that
applies to to all of your middle we're
not just the web server and so if it
applies to all of your middleware and
then it applies to all of your Ruby
middleware all of your closure
middleware all of your Python milla
where you've made management a lot
easier one challenge we found though is
that someone would just have no idea
about specs and interfaces I touched on
this when we were talking about like
Python where python is the spec in the
implementation all together right but
even in the world of rails they they
have a lot of things that are built and
that's that's it you know they were
never built to say here's the interface
and here is the default implementation
or the reference implementation it's
just here's the thing here's the library
go use it so that's a challenge you know
when when we have to actually figure out
when the implementation is the
specification that kind of sucks we
gotta figure out where
we get in there and rip their
implementation out where can we eat
define the lines and these other
language was getting better as far as
defining specs versus implementations
but it's still kind of a long way to go
so from the jboss point of view I've
mentioned a lot of these words already
but we have what I call the other glatt
app servers it's still our Java app
server running on the JVM and we have
toured box which supports Ruby we have a
mutant which supports closure we have
escalante which supports Scala
yellowbeard for Python and then the one
in the middle i like to call ass jazz
just because it's fun but that sports
JavaScript and that's the one that is
ultimately going to be supporting nodejs
sooner or later and we may end up
working with an as foreign guys to just
shorten our time to market on that but
what's really cool i think is a multi
glaude s you know instead of still
having little islands where it's like
all right here's my Ruby app server or
here's my java app server here's my
closure I app server you have an app
server that can support in different
languages and sometimes some components
are good to write in one language and
other components are good to write in
another language I'd like to call that
the enterprise mullet you know maybe you
got Ruby as your front-end you got some
Java in the middle and you have some
closure in the back doing some hard core
processing and ultimately because some
problems are easier to express in
certain languages you know I really
enjoy using Ruby and rails for doing
front end stuff it's super simple you
know and I don't ever have to touch any
XML you know and I like Hamill as a
template language but as long as I can
get back and touch my legacy java
objects using CDI or something that's
fine you know i don't have to reinvest
in all this back end stuff and this kind
of a little tangent but like you know
we've taken some time looking at torque
box thinking all right why do people use
some things and like one big use case
for messaging while it is great for
integrating you know assista made a
system be a lot of times people use
messaging to just run something
asynchronously I want something to run
on the other side of a queue using
someone else's thread you know I have my
web request as knee just go off and send
some email and so using Ruby is really
neat is that we can mix in this thing
called background of all it's a torque
box invention and so inside your Ruby
class you just mix this in you denote a
certain method as being always
background able and now whenever you
call this it just happens to run
asynchronously and behind the scenes it
is the message queue and you're doing a
publish and somewhere over there we're
pulling these things off a queue and
running in a different thread to
actually take care of your work and so
this is where I think rubios might
actually say hey I need this I don't
think I need enterprising middleware but
I need this I like running stuff
asynchronously because there's 15
libraries out there in the world of Ruby
for ruining things they sink but here we
can give it to them and we sneak
middleware in there and we know it's
running on like an enterprise-grade
message queue so if your system falls
down before this completes it'll get
picked back up or if this throws an
exception some other processor will pick
it up and make sure it runs and we got
to kind of convince the polyglots of the
world or the other lots of the world
that maybe you don't need enterprise-e
middleware but you need the
functionality the enterprise-e
middleware it gives you but yeah like I
say you know rubios JavaScript guys
Python East O's whatever they they hate
Java and you know it's okay to dislike
Java the language and you know I'm not a
big fan of John the language I are right
at a lot these days but it's not my my
fun language but we realize we have to
be a part of their community we have to
love their language you know if they're
rubios they want to do things the Ruby
way if there python guys they want to do
things the Python God Python way and we
got to realize that there are market we
can't just say all right we'll let you
do Ruby on jboss or on Java EE it'll go
really fast and you'll have failover and
high availability but you got to use a
lot of XML and maven you know that ain't
gonna fly for we got to realize that we
got to work the way they work and just
integrated as smoothly and as
transparently as possible and then in
this world that means like using rake
and bundler for the rubios orlinda gem
for the closure guys or a node package
manager for the node guys and we don't
force java and xml upon people who
prefer json or gamble or convention over
configuration you know they hate opening
up an xml file that has 600 lines that
define what the defaults are that's just
not what they need and we also need to
recognize that they're parallel
communities there's the language
community and there's the implementation
community you have the language
community let's say a ruby you know the
ruby is a language out there but then we
have the JRuby guys the people who like
using jruby we have the MRI guys the
guys who like using the sea based ruby
implementation and having two
communities is actually beneficial if we
can get them to
think of themselves as two communities
right now Python guys think of
themselves as one community there python
guys and so jai phones a little
redheaded stepchild you know so if we
can actually create these two different
communities help them find the split and
define the language and then let other
implementations live there particularly
implementations that we can stick on the
JVM then we can start to win and
ultimately we have to jump on the
grenade I gotta write Java so that the
guys who want to write you really don't
have to you know they loved using JRuby
that you love using all the messaging
stuff we provide to them but they love
not having to think about or write Java
or deployment descriptors or any of that
stuff and so this kind of reaches the
end of this part of the presentation but
you want to say jboss is renaming jboss
as2 kind of support our not necessarily
Java mentality so you can go vote on
that and now I think I'm gonna hand it
over to John and see what he has to say
okay
amazing
so my my viewpoint here is very down
stack let me get my button over here
like impress it's under the hood it's
it's the view of a compiler writer and a
vm hacker so I'm going to do a few case
studies of how people use the polyglot
vm but it's from my view underneath I'm
the plumber that makes the plumbing that
makes all the amenities of the house
work well so my my job besides compiler
engineers also jsr to 92 lead how many
of you know something about invoke
dynamic and method handles ok good I'm
going to rely on some amount of
knowledge in this room with apologies to
those for a move it's completely new
there's there's no time to do a tutorial
on it but there are there is excellent
knowledge there are other excellent
talks about this sort of thing elsewhere
and of course this is our safe harbor
slide which says that nothing that I
tell you is can be taken to the bank but
it is it is what I'm really working on
what we really what we really want to do
with the JVM and what we have seen with
the JVM and that's so I'm going to get
right down into internals and talk about
bytecode level stuff that that affects
the way the JVM supports the the
languages up above to start with kawa is
a dialect of lisp it was written
interestingly on the the very earliest
versions of the JVM how many of you have
used kawa it's been around for a very
long time okay just one it's I Lisp is
has been around since the 60s pretty
much and this this particular list runs
very very well on the earliest JVMs and
has been used continuously by a small
devoted community of users it fits with
the vision which was mentioned very
briefly in the JVM architecture
specification which said we believe that
the JVM may be useful for other
languages besides just job
and so the developer of kawa airborne
air went and enthusiastically embraced
that little bit of vision and made it
works but he was the he was just the
first or one of the first few of what
has become well over 200 languages
running on the JVM 200 and growing it's
it's impossible to keep count because it
prep there's probably a new one every
week what kawa gives you is scripting
you can type in a lisp expression and it
gives you gives you the answer the
scripting is not just for things in list
that gives you access through its
dynamic typing mechanism and its
dynamics coping mechanisms to to all
sorts of things on the Java VM but it
gives you also the amenities of Lisp
which lists programmers are used to how
many of you have used any form of Lisp
including emacs lisp okay that's good
right so you know what the amenities are
you just try something out you type it
in and it works this is a script II feel
it you can do it nowadays with
JavaScript with Ruby with many with
Python with many kinds of languages but
this was one of the early ones one
important thing that you'll see a bullet
point on many of the next few slides is
that there's Java platform integration
you get you get you it's not just that
you're running in a little sandbox it
only knows about Lisp you you get access
to all the richness of the Java platform
and that is the key value of being
polyglot it's not that we support each
language in isolation is if the
languages can all talk to Java classes
and to a lesser extent but a growing
extent they can talk to each other so
what else we got here the the
compilation mode of kawa is that it
directly compiles to bytecode like many
in the languages some of them are AST
interpreters you know they walk over
abstract syntax tree and and interpret
it at a very sort of course level but
most of these languages that i'll be
talking about compile the byte codes so
they are first-class implementations on
the JVM Ness horn I nasara guys this is
this is these fellows work and it's
really all I think awesome once again
you get your scripting to Java
developers once you get a very
le dynamic languages prototype based on
so you get to do all sorts of monkey
patching on objects you you once again
have integration with all sorts of tools
and libraries in this case you can write
very simple-looking expressions how many
of you went to any of the Nashorn talks
good stuff huh I you can just get in
there in JavaScript and start typing
java.lang.string or whatever and and get
to the get to the classes and and work
with them directly being able to
interactively invoke Java classes is not
as popular a an activity as it should be
it's a really great way to get to know a
Java API mean you get the dynamics tip
you get a dynamically presented static
view in eclipse or netbeans but that's
not the same as being able to just try
out expressions on the command line and
see what they actually do in real time
so one thing that JavaScript gives you
on the JVM like it did with rhino the
predecessor is a new options for for
integration with cool things like html5
once again it's direct compilation fight
codes but unlike kawa this is a
compilation that uses invoke dynamic
which is a new instruction from jsr to
92 and that allows the code to be
simpler and to elaborate a itself
dynamically rather than to have a lot of
compile time activity jruby great stuff
how many views how many here have used
JRuby good this is jay Ruby Charlie
nutter was one of jsr 292 invoked
dynamics first best customers he made it
he kept us honest by making sure that
what we designed would work well for his
dynamic language which is rightly
thought of as a good a good proxy for
all sorts of dynamic languages and
that's that's going out with NASA warned
and they've used they've used the design
that was refined at first by our
conversations with Charlie and some
other people and of course we're
refining our optimization techniques now
with with the help and pressure from the
NASA horn people jruby as you probably
know allows all sorts of its class base
but it allows monkey patching so it's
almost like its prototype based like
JavaScript and you can also
put methods on instances which is a
really crazy idea I Charlie has to be
very clever Charlie and his his cohort
Tom and so forth need to be very clever
about implementing that on the JVM but
the JVM reacts to it and is able to
optimize it fairly well and is getting
better at it too once again you can
access all sorts of Java platform
artifacts and once again as with NASA
learn there's a direct compilation using
invoke dynamic which gives you a fairly
simple code shape and Morgan more user
control on how the JVM optimizes things
one thing in particular that invoked
dynamic gives you is patchable call
sites and that works with J Ruby's ideas
about how you how you can cache dynamic
dynamically arising hot paths within the
implementation of the program so the
patch will call site mechanism is
something that's newly newly supported
by the vm in jdk 7 in both dynamic
Clojure how many of you is closure good
it deserves to be popular it gives you
again like any list that kind of a
scripting feel to it but you can also do
some very massive programming of large
concurrent data structures because of
it's rather unusual it I won't say
unique but it's way out there on the end
of the spectrum of pure pure languages
languages which deal with immutable data
structures which sidesteps a whole lot
of problems with concurrency and the
language supports it and the data
structures support it beautifully you
can also use that stuff from Java to it
is a dynamically typed language so far
all of them have been dynamically typed
haven't they but that's not the only
polyglot possibility javafx and Java
itself are are statically typed but once
again you get the integration of the
platform that's actually not true that's
a typo it should be direct compilation
to byte code using invoke interface
closure Lisp uses heavy use of
interfaces to tie its modules together
in particular because it's listed it
centers on functions so the functions
are represented using interfaces there
it is that's what I meant to say
challenges for cloture probably the most
important challenge for cloture is for
the JVM to get more and more savvy about
immutable data structure which isn't
it's a little bit hard to use that stuff
in Java but the closure libraries need
to be optimized very well and so this is
a this is an open-ended challenge for
the for the sub the polyglot vm to be
able to optimize using invoke using up
noise with final fields and other
immutable constructs final arrays for
example do not exist yet and that's a
problem which we hope to address Scala
now that's not dynamically typed
although you can use it in a redeveloped
print loop it is is a language how many
of you've used it right you get type
full programming heavy use of types
traits which are very interesting thing
we're getting something like traits
light with lambda in Java but there it's
very strong in Scala is a very strong
brew let me say it that way the implicit
conversions lets you mix and match data
structures with great abandon and then
there's also the notational flexibility
which gives you the ability to define
dsl's so it's a very powerful language
and you can do a neat stuff in it it
compiles directly to buy code it
compiles statically which means the
compiler has to determine all paths it
might happen in your program all
conversions that might happen and omit
adapter classes statically there's a lot
of specialization of code that happens
and this is a challenge with them if we
can make that lazier then then I think
that their programs would would probably
optimize better because it'd be less of
a big sea of statically generated code
in the vm who concentrate on hotpads so
the challenge is code bloat in too many
little classes their jar files are hard
like bags full of broken glass I think I
speculate that that invoke dynamic would
allow them to sort of lazily elaborate
their their their specializations and
and create smaller initial jars and let
the JVM be in the business
of generating customized code they also
have some interesting problems with
defining with implementing their kinds
of arrays they have value types with the
JVM doesn't support value types yet so
that's a problem and they have some
technical problems with lazy data
structures so let me give you how much
time do I have left yours who's holding
the clock haha nobody good thank you so
very quickly this is the like three
slide introduction to what's under the
hood that's new in jdk 7 and 8 that
gives you gives you some support for
this stuff method handles are nameless
pointers to methods it can also be
adapted you can load them from the
constant pool you can look them up
reflectively you can get a method handle
on any method or field the vm will
optimize through these things you can
manipulate them to add or reorder
arguments you can bind and bind them to
values you can change types you can
compose to method handles and so forth
its kind of functional programming but
it's at the vm level it's it's it's as i
said earlier it's like plumbing invoke
dynamic is a new instruction which lets
you take a method handle graph and
insert it into the bytecode stream
lazily you like any invoke it can take
any argument return any value its lazily
linked just like just like most parts of
the named parts of the VMR and but you
get user programming when the when the
thing first execute so you're you're the
linkage actions are user programmable
uses method handles I and you can put
arbitrary static information on every
call site so the metadata is not just
the name and a class it's all sorts of
data including other method handles and
also the vm knows how to patch metha
invoke dynamic sites optionally you can
have them be re rebound over time as the
types and the program change so it's
like a Swiss Army knife I think Charlie
Nutter coined that that observation
there's a dyna link dynamic linker which
is gives you a polyglot backplane by
which different
languages can talk to each other too so
this is a library writers Swiss Army
knife it lets you take a collar and a
collie in two different languages and
take both languages into account and
link them together okay future
challenges we're getting to the end here
there is a talk that I gave which I
encourage you to look at either the
slides of the video on wiki jvm language
some calm on a raise to dot 0 where I
talk about the the challenges that are
facing us in the future to make a raise
be say in some cases more Fortran like
in some cases more immutable and
basically build out the Java array model
in new directions for other languages
value types is a similar story you want
to be able to have a type complex or
other less obvious types which can or a
vector type like a quadruple of floating
points you can't say that efficiently in
Java today but that's something we're
working on maybe tail calls we've been
talking about this for years but it may
be time for that and interface injection
is a technical thing but that there's
several things that will help languages
be even better on the vm so we're we're
not just resting on our laurels we're
both actively working and thinking and
dreaming about the next steps and your
community involvement will help us with
that a final step here let's see yes
here is a slide here's the part of the
agenda from the JVM language summit if
you go to jvm language summit com or
wiki JVM lang summit you'll see the
talks that we did this summer we do once
a year we have a room full of language
geeks and vm geeks talking to each other
so this is part a lot of what I've been
talking about is the fruit of these
conversations that we have both online
of course and and face-to-face once a
year hosted by Sun and then oracle so i
encourage you to go to the summit wiki
and click on those links and see what
people have been talking about there are
many more languages here that i haven't
had time to bring up that you can find
out about it at your leisure so at this
point i think we can take questions
I think they're all waiting to go to the
website and see what what the heck I was
talking about so can I see the hands of
anyone who's actually doing anything
other than Java these days I actually
trying to put jruby or anything in
production anyone couple coats
how many of you are language
implementers that have emitted bytecodes
to the vm for your language okay I I
don't expect many of you to be such
because the people that do that are at a
high leverage point hopefully if they do
their job well and we vm people
underneath them do our job well then you
just get the right notation for the job
right how many of you use regularly more
than two or more JVM languages for your
for your critical work yeah one yeah and
so it's um there's more of you than
there are the people that actually emit
byte codes and that's the way it should
be the people that admit byte codes have
to have peculiar peculiar interests and
and their work Estill yet you're welcome
I the your work leverage is greatly on
to the people that use your artifacts so
those are all who didn't raise your
hands we weren't using other languages
but you're in this talk are y'all
anticipating using that the real just
seeing what's out there this is a quiet
room
two reasons why tail calls even though
there are no brainer are not there yet
number one is to do it reliably is
technically difficult it's not the 99
percent case of tail calls those can be
done by those can be handled by inlining
mainly and so we get the benefits of
tail calls in 99 but ninety percent of
the cases where you think you'd want
tail calls we give you that through in
lining but the remaining cases are very
difficult because you have to actually
sort of hack stack frames to keep them
from piling up and causing stack
overflows so you at some point the the
tail collar needs to look and say well
have I made used too much stack I need
to compress frames some house there
needs to be a new runtime frame
compression mechanism or else moving the
stack completely into garbage
collectible frames or something like
that which is would be very difficult we
have prototypes for that second reason
is the good is the enemy of the best if
you have a workaround that gets you the
ninety percent place then then you're
not going to go yell at you know the VP
in charge of the JVM saying we need this
we're dying without it say well we're
getting along okay so this is a this is
why we have java arrays that haven't
changed for years why we have we don't
have a type complex yet there are
workarounds for it that are good enough
so it's sort of a it's a it's a
community effort to determine what our
priorities are and say okay now it's
time to spend the difficulty of the
engineering effort to make this new
feature make sense
alright well we'll be we'll be up here
if you want to talk one-on-one and thank
you for your attention</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>