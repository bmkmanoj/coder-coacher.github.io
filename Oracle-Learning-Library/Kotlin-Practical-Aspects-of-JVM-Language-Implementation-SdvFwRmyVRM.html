<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Kotlin: Practical Aspects of JVM Language Implementation | Coder Coacher - Coaching Coders</title><meta content="Kotlin: Practical Aspects of JVM Language Implementation - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Kotlin: Practical Aspects of JVM Language Implementation</b></h2><h5 class="post__date">2013-02-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/SdvFwRmyVRM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">you're in a coupling session no matter
what the title says and who knows what
cudlin is two and a half people in the
room not bad all right so I'll do a
short introduction just let you know
what I'm talking about and then proceed
to my main subject so common first of
all is a programming language compiled
to java code so it's in the same area of
all those new modern gvm languages like
Scala or groovy or sellin or many others
it's developed by JetBrains the ID
company so it's supposed to be like a
very ergonomic very usable language both
from the language concepts ID and the
from the tooling support site the
biggest question when I tell anyone that
I'm working in the language is like why
and there is a pretty good answer why so
if you think about the situation we're
in now there are very many Java
developers you can see what a fraction
of that mass of people at this
conference and we're pretty happy with
the platform have a really good platform
that is around for quite a long time and
it steadily evolved over that time so
job is great in that respect and now I
think about job of the platform versus
Java love language there was a huge gap
because javelin language as well as the
platform came about and 1995 and if you
remember that time what was your monitor
like was this huge and did you like it
you probably did it was fine at that
time I hope you had a good monitor right
but over time my monitor improved a lot
and my language improved
so I wouldn't call it 1995 design
anymore but it's probably 1998 design
and this is kind of a mismatch you know
we have so much of improvement in the
platform and hardware in many other ways
but the programming language we're using
is a little bit outdated ideologically
so this is why we are working on
something new because we think in very
many contacts it will be really relevant
so now about this talk so this this is a
talk about cobblers internals how you
how we drop the fangs under the hoods so
you are supposed to be interested in
subtle details and stuff like that how
many of you knows much about java
bytecode okay so it's more than two and
a half people in the room that's great
okay so today I'll be showing a little
bit of by code and mostly talking about
the concepts implying that you kind of
realize how the by code works okay so
why should you care if you know about
bytecode you probably know the answer
already but I'll still tell you about it
so any language is basically an
abstraction I hate the term syntactic
sugar because it doesn't make sense any
high-level programming language is
syntactic sugar and even the assembly
language is syntactic sugar so basically
whatever language you are working with
it has some means of implementation
under the hood and it's an abstraction
and any abstraction leaks at times so
you have this broad spectrum from your
ideas about how the program should work
your programs being some reflections of
those ideas and that implementation
under the hood that actually works here
and if something goes wrong it may be
very handy to like see through the
matrix right and
you know detras is way too easy when
play this way so we'll be trying to peer
through the matrix today a little bit
since we are having this interesting
improvement of the Java language being
the Java language staying as it was and
other languages kind of filling the gap
between the state of the art and jela
it's a good question how each language
does what it does because there are very
many interesting approaches to solving
the same problems and today I'm mostly
talking about how coughlin does that but
I'll give you some hints about other
languages as well any questions at this
point okay by the way oh ok ok the
question is how did we come up with a
name cotton it's a good question all
right it's actually a name of an island
city ated next to the city I'm living it
and all the elder cuddling Tim a team
was situated in any more questions okay
by the way I would really like us to
have fun together so go ahead and ask
questions as soon as you have them so I
don't like the situation when I'm a
speaker you are the audience because I'm
simplicity ition I'm supposed to have
all the fun and this is not fair mm-hmm
okay so two words about me to put in the
context so I'm currently leading the
design and implementation of Calvin it's
been over two years since i joined
JetBrains to start the project and I
also serve on the expert group for a
project lambda in the JVM in the JCP
sorry so I'm kind of you know serving
the two different approaches to fixing
the language situational JVM ok so when
you think about what you want to do to
provide people with better experience
programming finally our goal is
to make a modern language for industry
and this modern is kind of a dream a
broad spectrum of things you can do and
industry is constrained because you have
to be reasonable it's for hardworking
people to use not for dreamers to dream
about right so and this basically boils
down to two most important things they
are you want a smart compiler that
figures out things people can figure out
and you want flexible abstraction
abstractions that let you but
interesting algorithms and interesting
patterns of coding into the library not
to go over and over again doing the same
code all time so God line is statically
typed it's supposed to be readable more
than writable and of course it relies on
lots of to support and we make huge
emphasis on Java interoperability and
today I'll be referring to that all the
time like we didn't do that or this
because we want to interoperate with
Java and other JVM languages all right
so let's start with some warm up I'll
tell you about extensions who knows what
extension methods are one person two
people in the room good so there is a
huge confusion about what extension
methods are in fact so I'll give some
introduction the first of all meet God
lon are there any questions about other
any questions about this program since
we're in this talk this should be
probably well you're smart of course and
you know how this should work but anyway
so one thing you don't have in Java and
you straight away have in common is a
free function so here I have my main
function that does not sit in any class
how does this work I have a package and
a function right inside the package what
is it I can this be Java has all the
methods in classes right
so for a warm up you guess what we do
there go ahead ok so the answer is that
would create a class per package and our
free functions are static methods there
so here is my by code view or use it to
debug our compiler and really there is a
class called whatever extensions /
namespace and here is your familiar
public static void main with the string
array and everything and you don't have
to be fluent in the bytecode to realize
what the signature is right okay now a
slight extension to this currently I
have only one file in this package so
you can put many coughlin files
scattered across the file system but
currently in this package there is only
one and I add another one and say that I
have another function there what do you
think how many classes do I have now won
em now still one okay actually is three
and it doesn't matter how many functions
I put it here it's three for two files
and 443 files so on so forth so you have
one class for one file and then n plus 1
class for more than one file and this so
this is what it looks like so here is a
terrible name for this class guess what
this number is
Oh No now timestamp would be very bad
because the name would be changing all
the time so I actually I don't like this
implementation detail here so we'll be
changing in but currently it's a hash
code hash go to this string the relative
named to the file this is stable but
very ugly I hate negative numbers there
so this is one class and it holds this
foo and the other function also foo and
here's another class with a clean name
namespace and a foo delegating to that
other one what do you think why would we
put that there yet yeah so the conductor
here is that it's about visibility
constraints in fact it's a little
different it's about debugging the
problem there is that you have those 0
line numbers here all over the place are
there in the bike of you I don't have
any any code sorry I'll put a piece of
code here just to give you print one
never mind the stack trace it's okay so
i have this biz line numbers here this
is line number four in my file and at
the top it tells me that it's whatever
that class this line sets on and this
class file has only one source file
associated with it so when I step
through my program my debugger tells me
okay you're at line for and if it's only
one class for many files I have no idea
line photo of which file i meant so i
have to create many classes to work out
the debugging and by the way it also
helps figuring out initialization
because you may have a package level
state like i can create
a variable here it's actually a final
variable of value and the question is
when this gets initialized and the
answer is of course when business this
class is loaded and this class is only
this file so it's consistent inside
inside the same file so you have the
logic of linear initialization and if
you have cross-references it will be
handled by the JVM any questions all
right so now let's do something
interesting I'm removing the extra class
extra file to get rid of extra classes
okay so here's my print line function
it's a library function from carbon as
well as this main it's a package level
function and of course i can define my
other functions say I want a utility
function last on a string that will be
last of string and yeah return a
character give me a last character yes
yeah lamb minus one okay so here is
basically the way you treat utility
functions in Java you create a static oh
so a class full of static methods called
string you know or whatever and you put
all your string utilities into this
class and it's terrible for two reasons
first of all you have to say string
doodle dot whatever function of that
string right so it's extra string little
there and then if you want to do one
operation and then on its result do
another operation you say it you say
backwards it's a few of bar of string
although its first bar of string and
then du feu right so this is why you
would really prefer to put those custom
utility methods on the right like if
they were members and indeed i think all
new JVM languages let you do this
java doesn't and even Java 8 doesn't but
we do and everybody does it in a
different way so i'll show you the
syntax for how coughlin does it and then
we'll discuss how it works I can say
that my last function is a function for
string so I have a string prefix for the
function declaration and inside this
function i have my normal vest as if i
were setting in the string class and
this is how i refer to everything there
so here is my extension function i added
something to the string type so that it
can call it with a dot and it shows up
in the completion list here's the last
end among other things and there are
many extensions in the library so a big
advantage from the usability standpoint
is that you can learn your AP is just by
hitting control space like you do with
class members but that now includes all
the utility functions now the question
is how does this work what can it be
there are many possibilities for example
groovy would do this through expanded
metal classes and scary stuff like that
so it will have some custom dispatching
mechanism or you could imagine us
digging into the string class at say
class loading time and adding the method
there right is it possible almost not
because the string sets in the boot
class path and it's protected but yeah
you could even hack that enter into your
custom version so locally installed
version of the virtual machine or we
could do what's Canada's and create an
object that wraps the spring and have
this last a member of that object but
that would introduce another instance at
wrong time or we could do what we
actually do here it is simply say here
is
your normal static method that takes a
string as an argument calls it this and
does the work so our approach to
extensions as plain simple you have your
good all static utility functions in a
nice syntax if you call it sin text
river I don't like it okay sure what
curious the bytecode for for the method
body and here's the signature all right
now there is no x axis there actually
it's another interesting part so the
question is what are these square
brackets for here and your your
intuition is that it's the array that
sits inside the string but it actually
isn't it is simply a call to a get
method which is not in the bike out
either because it's optimized for
Strings but never mind so it's a
convention in carlan if you have a
method called get you can call it just
by putting a square brackets there
because it's nice this way just know yet
okay go ahead
this get is a trick method so yeah the
question was is this get for string an
extension method so we under the hoods
we use the java string but we have our
like view class on the string because
string is basically built in type so
it's not an extension method it's in
this fake class which has no class file
for it and it's all translated down to
whatever it is on a platform we can pile
for we don't compile only for the JVM a
compiler for javascript as well and it
gets compiled differently for different
different platforms go ahead okay the
question is which namespace does this
last set in so it sits in the package
for this one and to use it you have to
import either everything from the
package or this method individually so I
can use it here because I'm just in the
same scope but if I want to use anything
that is declaring the other package I
have to import explicitly good
yeah great question i was about to ask
everybody if can you access anything
private or protected on string inside
this extension function what do you
think no way exactly because it's not in
the string class the security descriptor
will just kill me if I do it will be
just around time exception yeah so there
is absolutely no magic it is a normal
static function that you can just call
with the dot because it's more
convenient this one more questions okay
go ahead
okay the question is is there actually a
cool tool s currently yes we really call
all the functions you declare but we're
going to implement something called
inline functions which are not actually
cold but just in line at the call sign
in this particular case it would make
sense it's a good point yeah for this
particular case it may not make sense
that's correct because yeah because this
is a very small method and it's their
little overhead actually but where it
will make sense is when you want to
allocate an object for a closure you can
get rid of all that all together just no
call no closure no mega morphism no
nothing ok so i can't demo it so i won't
talk too much about it all right so
we're done with the extension example
and takeaways here our first our
packages can handle free functions but
under the whose they are classes with
static methods and extensions are static
statically dispatched there's no runtime
polymorphism these are just a nice form
of calling your utility functions ok now
let's talk about bridges were in san
francisc after all who knows what the
bridge method is ok to people in the
room that's great so I'm sorry for
explaining this but everybody else needs
that so here is some class it's a
generic class and I declare a function
of T that returns the same T you know
that Java doesn't have a runtime
generics so in the bytecode there is the
signature for this function which is
called generic signature that is used
only by the compiler and for the runtime
the signature of this method is this I
abbreviate java.lang for GL so
I have an object parameter and the
object return type now I want to extend
this class I make it subclass that says
it's it's a child of Bayes of int right
so mighty is no longer there mighty is
now int and I have int in and int out
the problem now is that I have changed
the signature and what does this arrow
stand for it's yeah something is not
working but what contravariance is not
working as correct but something more
fundamental for jahvid is not working
here yeah so the problem there is that
there is no override it's just no
override whatsoever because it's
completely different signatures and what
JVM actually does it run time it matches
the whole signature including the return
type so you have two different methods
they don't over at each other that's a
problem because what I meant was stove
right and this is this is what happens
on lean kotla so it's not my stupid
design that breaks everything this is
this is exactly what Java Sea does and
the problem is naturally solved by
yourself by something called bridge
method also in in vanilla jalwa so
actually the compiler adds another
method to the child class with a
matching signature so for cuddlin this
top type is any so i have an any to any
function with the matching signature
that actually overrides and it it's a
ready wrecked so it delegates to the
custom version that the user wrote
casting the parameter to what it should
be there okay so yeah so why does this
casts always succeed
and does it so I have a cast there so I
have potential risk for a
classcastexception yeah so normally it
will succeed because the compiler checks
the types for you and it wouldn't
compile a program where this cast
wouldn't succeed but if you somehow get
well yeah of course if you just have a
row type of base without tea without
anything and you call a foo it now takes
an object and pass a string into it it
will fail if you actually have a
reference to child and garland this is
not possible we don't support raw types
we fortunately can afford no backwards
source compatibility with java 1.4 we
have binary compatibility okay so this
is what Java Sea does and coughlin does
and everybody else does actually now
there is one thing in this picture that
is specific for Kotlin it is this
signature of the custom method which is
I to I I and the bike o stands for
primitive int what Java does here is
java.lang.integer to java.lang.integer
and what we do is into in and it gives
us some benefit because if you access
the actual iran type type so if you have
a reference to child you don't have any
boxing if you go through the base class
30 you necessarily have boxing because
you go through the object reference but
if you have just the precise static type
I have no boxing no random penalty make
sense ok questions
now bridges are very widely used in many
different tricks JVM languages play for
in order to make things nicer so the
next example will be default arguments
everybody hates overloading I mean now
everybody on this side hates overloading
because it complicates language design
so much we can't get rid of overloading
because you have to be Java compatible
first of all but we can simplify so that
you don't need it in very many cases for
example we cuddlin does not support
overloaded constructors because with
this feature it's basically not needed
so what do you see here is a function
that takes two numbers and provides
default values for those numbers so you
can say foo of no arguments and get to
defaults and so on so forth the last
option here is to specify the name of
the argument you're passing so that you
get first thing by default and the
second thing over the custom value any
questions ok it's not now there are a
few ways of doing the implementation of
this and there may be different goals
for example skala generates lots of code
for this method and like extra classes
and extra virtual functions to make the
default values of writable yeah so if
you want to override your default in
your subclass you want a virtual
function there and so on so forth but so
my intuition there is is that you
actually don't want to over anything
because the contract at the top said it
will be 0 if somebody else say ok I
don't like zeroes it will be minus 1
something may break in the contract so
then there will be two strategies you
could at every call side amid the byte
code that creates those expressions
zeroes in this case or something else if
it's something else there or you could
do this inside the method but to do it
inside the methods you actually need to
bridge and this is better because it's
binary compatible if you omit those
zeros at every call site I have to
recompile everything if you change
anything in the signature and this is
not very convenient so to support
defaults we use bridge methods as well
for this declaration regenerate two
things two functions one matches that
exactly so it has two parameters and the
body inside this compute the salmon
return it and the other method the
bridge one has an extra parameter which
is a mask a bit mask for which defaults
were passed and it says if the first bit
is set then take default for 14 for the
first parameter if the second bit is set
take the default for the second
parameter and then call the other
function any questions here
today
oh ok so the question is can I in the
default value for one parameter can I
take into account the value of the other
parameter yes you can so they are
evaluated one by one so if i want to say
if my offset is something then the
default is the other one i can do it
because if if is an expression you can
put an arbitrary expression for the
default failure it will be just
evaluated they're more questions
let me see so if you add something that
matches the signature of this mask in
the same class it just won't compile it
will tell you your you have a clash of
signatures for one thing for overriding
it won't interfere because it's a bridge
method basically two won't hurt you most
situations yeah more questions so if you
by any chance want to pretend you have
default parameters in Java you'd need to
compute the mask but otherwise you just
call the two parameter function directly
because yeah yeah so basically this mask
thing is a bridge and what you get is
the few one for Java because Java on the
client sign doesn't provide you this
capability of defaults okay now oops
yeah now another detail about this yeah
go ahead
yeah so let me check I don't remember
what we do there so let's see I have
this example here and my base class has
this foo method with all one parameter
and sorry or is that oh it's a child
sorry so here is my food okay it's a
different name yeah this is what I
suspected sorry it will be just a
different thing here with the dollar
that is not available in Colin that's it
yeah so what I wanted to show you here
is this so I have a base class with some
default value for this parameter and
here is my child class that is not
allowed to provide anything here will be
a compilation error because I can't
override default how many methods are
defined in this child class how many
meth is doing neither it's actually one
because this bridge method has only the
single implementation it computes the
values from the mask and then calls the
normal method and all I need to override
is the normal method I don't need to
override the mask method just because
it's the same implementation for all
classes so here I'll have only one
method in the subclass which saves you a
little byte code and makes things more
straightforward for java
interoperability so here is my South
class nothing special questions
ok
yes yes you can so let's let's just do
it so here is my fun of fun foo of a int
and be also int it will have this exact
signature here and it won't override the
mask one at the top because i had a
mistake in my slide telling you that the
name of the bridge method was the same
as the original method but actually the
name of the bridge method is not foo but
foo dollar default that's it it's early
in the morning I forget my
implementation details okay more
questions all right now
yes for for the compiler you have to
save the actual non Java signatures
somewhere in the bytecode and the most
convenient way is to put an annotation
of the method it's not only default as
many other things so we have this jet
type info jet method annotation which
carries flags and the returns and
whatever many other things
what the compiler does when when it
resolves the call it looks for it looks
at the actually passed arguments then it
looks if it can make these arguments fit
into the signature taking the defaults
in the into account and then it amidst a
according bytecode so if any defaults
were used it will be the mask method
otherwise it will be the original method
okay okay so next thing is code and
interfaces and this is a contentious
point because they will have it in Java
8 there is a question yeah
yeah for for binary compatibility okay
clapping yes okay so back to traits
people want code and interfaces for
different reasons first of all multiple
inheritance were was taken away from us
long ago we want it back we can get all
of it back and different languages again
do differently for example groovy gives
you something like categories dynamic
makes sense and scalar gives you also
traits that can even carry state
coddling doesn't give you stating traits
they are still like interfaces but it
can put code into it and Java 8 give
gives you also some code in interfaces
but it behaves in a funny way so that it
doesn't always work as you expect it to
work because if you have a class method
somewhere in the hierarchy it always
beats the interface method even if the
interface comes later in the hierarchy
so if you somewhere you have your foo
and your implementation comes from the
interface know why it will beat it so we
do just straight so there is no this
funny effect like Joey and the question
is how do you do it so here's my traders
compile down to an interface obviously
and so far you can put any code into the
interface and until Java 8 it won't be
allowed so what do you do how do you put
any code in your interface any
suggestions
you can copy the code now you can say
okay I have some kind of you know
storage for my bike code and whenever I
have a subclass that just copy the
implementation from the interface to the
sap class this is bad binary
compatibility by code size everything
it's just very bad you can do a little
better not all much better but a little
better so what do you actually do you
put a static class next to your
interface that carries all the code and
it's called whatever trade dollar impul
with static functions the signature here
is wrong I'm sorry it's so type on the
slide actually the food takes an
argument of type trait of course because
it's me that this and then yeah so here
at the call site I didn't make the
mistake and in the class that extends it
straight there is no explicit code that
accesses anything but we actually made a
method that would call this static
implementation any questions here okay
good
in your classes and crates yes we do
okay yeah well this imp 0 is just a stop
name it will have some numbers there and
yeah yeah but but in general you always
can write some code where compiler will
complain that you can have some name
clashes if even in Java it can do that
all right yeah so so what I do here I
simply redirect to this static method
and then if somebody changes the
interface in the library I get the
changes to me just because it's a method
called not just the bytecode injected
ear now the interesting part comes when
there are few traits extending each
other the thing is that okay in the at
the top I had a method then there was no
overriding and trade and then I extended
three so which one should I call the one
above me or the one at the top what's
the answer well it's drawn there but why
do I actually go through another method
call why don't I just call the top one
directly yeah it's the same answer just
binary compatibility because if somebody
evolves the tea to trade and adds the
method there I have to be able to handle
that change I have to be able to call
the actual overridden implementation and
I have no power at runtime the Java 8
will actually alter the resolution
mechanism invoke virtual invoke
interface will work differently but I
can do that I don't have a virtual
machine unit my disposed yeah so this is
how it works wretches okay so it can be
all perfect I mean there always will be
some binary compatible changes of course
like in Java like everywhere but it's
pretty good if you don't do too crazy
things
okay so the summary for this part of the
talk is that sometimes you just need
another method go ahead yeah sure
yes when when you when you extend a
trait you always have the implementation
it meet them I mean not in a class in a
trait you always have a redirecting
implementation in a class you have to
implement it somehow because it's a
complete if if it's a concrete class in
an abstract class you don't have to make
sense okay you have a long chain that's
right yeah yeah but this is a chain of
trivial calls it will be in line it's
okay alright so next big thing is
collections collections are actually as
important as any language feature
although it's a library feature but he
uses them so much that they basically
shape takes the whole experience oh so
every new language basically comes up
with its own collections these are
another way and there has been a
difficult story about this because if
you look at javas collections there are
many problems people don't like them
this is a boy and so language designers
tend to say okay those collections are
just bad don't use them use our
collections they're better and
incompatible which means that if I have
my huge java project i have to convert
all the data back and forth to
interoperate with the existing code and
that's sad but Java collections are
really problematic so what do you do as
usual we can play some magic and do
something like this so have a look this
is the cousin collections hierarchy you
have the green part if you can see sorry
about that I'll just really really loud
so the green part here on the left is
iterable collection set list all the
familiar names the changes they are
immutable
actually they're read-only not immutable
and they say out t there because T is
contravariant carla has declarations at
variance you don't have to say ? extends
integer or ? extends whatever other call
site you can just say okay my class is
always covariant in this parameter and
you you're allowed to pass your say list
of strings where a list of any is
expected so let's just show how it works
sorry here is my collections example all
right so here's my print it takes a list
of any and print it out and here is my
list of integers its evaluate its type
is inferred but it's inferred to be in a
real list of integers and I can freely
pass it here it's okay because my list
this class is not the java.util.list it
scotland list which extends the
collection and has only the reading
methods it has no mutating methods so it
can be covariant and e it's fine okay
now the magic comes in this is
java.util.arraylist okay so that was a
cufflink class and this is a java class
and we didn't order the JDK but as java
class extends the cuddling class and
again you can do any like runtime magic
you can't alter the class of the loading
time and so back to this hierarchy of
course all those read-only classes are
fake there there are no class files for
them it's just the type system fiction
for the better experience and you have
mutable collections hierarchy which
basically replicates the Java
collections that extend the
corresponding classes from the
government perspective and your
arraylist and have said
everything extends the mutable ones and
of course there are implementations for
immutable ones as well not all of them
already the library but that will be
there now there should be a big question
what happens to the interop the problem
there will be okay so here is my custom
implementation over the shortest class I
could find which is iterator so it's a
name it's the read-only iterator doesn't
have the remove method right so to
implement it i just say has an axis that
next is is this and here is my byte code
is there any by code yeah sure it is
it's has next and next and at the top it
says that it implements
java.util.iterator so there should be a
question where is my remove like what
happens if I pass this object to Java
and Java calls remove what do you think
one option would be not implemented
exception we actually throw that another
exception but yeah the point is that
there is an implementation for for the
remove method but what it says is create
a non support exception throat so if I
just say so I have this class here that
takes an iterator the Java class takes
an iterator and removes everything from
it and if I want to call this from
cudlin collections test it is collection
test that remove of my iterator just
create a new object here it will be an
exception at runtime of course but this
is basically what you're used to have in
Java because this is what happens when
you say this unmodifiable collection and
pass it to some to something else that
would like to modify you'll get an
exception in Calvin you're just not able
to call this won't work
questions so it's basically it's again
one more method but this method is not
for calling but for just guarding for
being called against being call no
questions okay so this is actually one
of the features I'm really excited about
because it makes the world so much nicer
with so little effort and you basically
you get the java java collection
hierarchy fixed with absolutely nothing
invested into the infrastructure it's
all the compiler magic good
straightforwardly so if you have a bunch
of collection classes they actually fall
into this category there where arraylist
never everybody else sets so yeah i'll
show it in a second all right so this is
the translation strategy what I have
here is my list rate just disappears
it's not in the bytecode my immutable
list corresponds to java.util.list and
if I see that something in Java
implements java.util.list I just say
okay it's a mutable list that's it with
guavas immutable collections will need
to play a special trick for for these
particular classes some somewhere in the
configuration of the compiler to say
that okay these are actually immutable
and if i have time which is unlikely
i'll tell you about this mechanism so
now if you compile the Cullens code that
uses lists it will be always
java.util.list in the bytecode and yeah
this is what I want to show you about
the fake methods there and now the most
interesting part which is not fully
implemented yet is that for java these
methods have right signatures as well so
if you have your covariant place there
it will just say ? extends something it
will work even for job
a little trick there is that when you're
calling java from kirtland java on this
as list doesn't tell you which listed it
is so the default is to take the most
permissive strategy so if if the method
in java takes a list it will be a
read-only list you can put anything
there and if it returns a list it will
be mutable for you to be able to call
anything there so with its dear little
effort we can make our collections
better than java's and still compatible
questions okay so the last part will be
about nullable types as again the story
of safety basically the collection store
is sort of safety and here is a short an
introduction here's my piece of code
about java.io.file so this is standard
java ioa what's the risk here if i call
this size the compiler complaint it's
because this list files has a funny
contract which gives you a null if the
file does not exist or is not a
directory so common knows that this is
nullable if we look at the type it will
be an array of file with a question mark
at the end meaning it may hold a null
and this files now cannot be dressed
right away you have to guard before you
do anything to it so if I say if files
is not know i can now the reference but
without it i can so this is purely in
the collins type system it's not
anything actually connected to the java
in drop but the question is how do i
know that this file this method in the
file API is nullable and say name yet
name is not malleable the answer is I
basically don't and the default is to
treat everything as knowable if it's not
primitive everything that comes from
Java is not able but
I would end up with something terrible
like this like an array of novel files
reds bud it's very inconvenient and we
provide something called carbon
signatures my ID is terribly blinking
for some reason sorry about that so a
cuddlin signature is yeah it even fits
on the screen it's something like this
where you say okay Calvin should see
this method like this without the
question mark at the array and the
compiler will just look at the signature
and know what's not able and what's not
the good part about it is that well
actually the bad part about is that we
started with annotating manually like
you you have a compilation air you go to
the JDK you put an external annotation
and a method and you're fine with this
method but there are dozen other methods
that it didn't annotate and every time
you go there and entity it's not too bad
but pretty annoying and last week we
almost finished and it will be out maybe
in two weeks from now a tool that
actually figures that out for you so it
just does all the annotating
automatically from the bike oh good I
have very little time but I'll try so
the thing is that you have the by code
from your jar and you can see if
something definitely returns a non
nullable value you can see if something
accesses its arguments without checking
for null and these two things mean that
your other returning or taking an
unknowable value you can also see if you
modify a collection so you can infer if
the list is modifiable NAR or not you
can see if you check something for null
and throw an exception it's again a non
nullable thing so on so forth so there
are a few heuristics that cover maybe
eighty five percent of the whole thing
and then the rest their little may be
taken wrong and you all just correct the
annotations and send it to the central
rapo so that everybody gets the day
right annotation
and the good thing about it is that it's
not only for cudlin it fixes things for
Java as well because the ID knows the
annotations and just does the analysis
for you okay so my time is up and just
welcome to the cotton world I don't have
any internet connection here sorry about
that so you're welcome at all our
resources to check things out to
contribute to the open source project to
ask me questions thank you very much for
your attention</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>