<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Arquillian Universe: A Tour Around the Astrophysics Lab | Coder Coacher - Coaching Coders</title><meta content="The Arquillian Universe: A Tour Around the Astrophysics Lab - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Arquillian Universe: A Tour Around the Astrophysics Lab</b></h2><h5 class="post__date">2013-01-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ZazXxC6beIQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good evening everyone welcome to this
little session from me and me are stuck
Hudson and Andrew rubenzer both from Red
Hat I'm going to take you on a
interesting tour around the the Ark
alien universe I'll show you what's
going on in the end the sparrow testing
so when everyone's are when you hear the
word testing what's the first thing that
kind of comes to mind don't have any
good no one sorry taking it right right
well more of a more of the feeling of
what you feel when you hear testing that
most people is no fun it's boring it's
too slow too hard and as developers we
all know that our code it's not full of
bugs anyway right so there's no point of
testing but there's a different aspect
to testing it's not necessarily to
verify the correctness of your code but
it's due to verify that when you change
the code a leg actually still doing what
it was supposed to do that's more of the
actual agile approach testing so we like
to talk about something called the
testing gap that's when we're moving
from the unit tests which are normally
define it's very simple single classroom
method type testing it's easy to mock
out it easy to to work with then when
we're moving over to integration
especially when we're talking Java were
normally ending up in some form of
container that being a bean container or
a application server e-type container
and then your test has to deal with
setting up that container during the
deployment starting and stopping it and
if you're in if you're developing for
more than one platform that being for
instance jboss or the jboss and tom cat
or glass fish then you test with start
to get bound to how these different
servers are started differently and
control differently so that makes it a
lot harder to do the integration testing
and you most people end up kind
skipping it and going over to a more the
old type of manual QA Department who
sits and reads through hundreds of test
scripts so how this is supposed to work
and same with functional is work well
the scale scale just keeps going upwards
so in the arquillian project or the I
Killian framework or the universe's we
like to call it we have three core
principles the first one is that a test
should be portable between different
runtime environments the second is it
should be executed from both the IDE and
the build tools that you're using you're
not going to have to go out of your
development mode and go to some third
party system and start hacking around
with massive build systems to build your
whole application and get you out of the
the tiniest scope of what you are
actually trying to test where you were
in the code at that point and the third
principle is we're not going to reinvent
the wheel here we're going to reuse a
different testing frameworks that are
out there there's a lot of frameworks
for doing persistence for doing
transactional testing that works
perfectly fine but they're still missing
the the crucial part of of handling DD
containers so
just started at the bottom of the
universe or at the top whichever way you
want to look at it we have our Killian
core and our Killian core in itself is
just a tiny little event machine that
doesn't really do anything on its own
but core as we know it it's it's built
to be to be flexible in the sense that
what technology we have today is not
going to be what's going to be there
tomorrow even though it will be there
for a while there's still we don't want
to redevelop this framework constantly
so it's flexible in the sense that it
can it can handle most anything within
the the platforms that we're targeting
and by that or we deal with the
flexibility by being extensible means
that anyone can write a extension to
handle new functionality or new
technology that is needed within the
testing space so are killing core itself
has three types of extensions it's one
for testing one for container and we
want to integrate the two so the testing
extension is a set of SP is to integrate
against some known test runner being j
unit testing g your spark or j behave
and the likes someone that will control
control the interaction and startup or
Killian itself on the other side of the
scale this is a container extension and
that's the SP is for interacting with
the different containers ranging from
our container can be defined as anything
that is and providing you a wrong time
that provides used services so it's not
necessarily an application server it
could be google app engine it could be a
cloud it could be a physical server to
be a mail server for that matter we
normally try to categorize container
types in three different styles it's an
embedded type of container that runs
within the same jvm as your test has
your test runner then it's the remote
one with
runs somewhere else it could still be on
the same physical machine but it is in a
different JVM but might as well be on a
cloud somewhere or your your testing
environment in your in your office or
staging or production and then we have
the manage which it kind of combines the
two and it's a different table jvm but
it's something that our Killian can
control as well so you can start and
stop it and that's typically a a
container two runs on your local machine
but runs in a different JVM just move
over to to how would you set up
something like this well it's not it's
not a a requirement from merculian site
to use a dependency management system
but it will help you a lot so while you
can use and for instance on its own own
and get all the different jars and
modules set up on the classpath maven
and Gradle and and plus IV using that
their dependency mechanisms makes that
task a lot easier basically allowing you
to pull in all the container client
dependencies pulling in the component
api's so in the maven example what we do
is set up the arquillian bomb which is
the overall overall bill of material as
we call it that handles how to or the
different versions of the different
components that are available to
simplify it for you so you don't have to
necessarily know all the different
versions of the sub components that are
in ER the next step is then to add on to
the the testing framework in integration
that you want that being in this case J
unit or testing g and from there on you
have the base arquillian setup and you
can start toward to write your tests so
if we look at how the basic test class
what it looks like this is basically
what you can say to be a Jane it
skeleton it has a class that has a test
method and it ended up some assertions
so we add on the arquillian bits to it
it uses the the j unit or in the
generate integration it uses Jane its
run with annotation 22 so Jane it will
hand over the the control of running and
executing this test case to our Killian
and then there's this deployment method
which defines the isolation level of
this specific test which environment
should this be be running in and then by
reusing the component models that are
under test in this case it using the jsr
330 or CDI to inject back the running
instance that is deployed on the server
ok ok so the deployment method that you
saw there that's using AP I'll cook API
called shrink wrap and shrink wrap is a
java api for doing packaging so you can
create your job archive your web web
archives or enterprise our cards it will
operate on the the client test class but
so in the same cost path as your your
your test so you can add classes at
packages at the file resources classflow
the resources and so on and package them
up the Buddha way the way you like in
simply a very narrow point to what you
really want to test they're not
necessarily the whole application as you
would through a some other type of build
system and along with shrink wrap
there's a project called shrink wrapper
solvers and that helps you out with
integration against the
in dependency pendency management
systems so you can load up the palm file
that you're using you can get the
dependencies that you that is already
defined there every way it will go out
to the repository system either locally
on your disk or remote Apache different
dependencies together and the next one
is the descriptors which basically does
the same for your configuration files as
it does for the the archiving where you
can create your web app descriptors your
egb descriptors application descriptors
etc when you look at this test there's
nothing that binds this to a specific
container so how is that done arquillian
used since the classpath and what's
available on there typically distance
standard java java spi type pattern so
when you add in a specific container
adapter people then find and find that
and use that as the target environment
normally split up in like this case
where you have multiple profiles that
are that is that they're being they're
being run in in navan so you can select
between if you want to run against gmos
a 7 or glassfish and so on so how does
this work any in the inner core so the
first step when you run your let's take
the example of the j unit test
the first step is that Jane unit star
chopper Killian arquillian will we look
for the container and depending on what
type of container it is will either
connect to a running instance or started
oh sorry first you have to select the
data then you can connect or start do as
that could be anything from a simple pin
container like spring or weld or up to a
remote cloud somewhere achillion doesn't
really matter though doesn't really care
and then it comes into the packaging
face where it will amongst other things
run the deployment method that was the
finder to package up the the environment
then include itself and the deployed
deployed to the container then through a
remote protocol between the client and
the container it will start to execute
the test and at this point your test is
actually running inside the container
itself so you have access to all the
resources that your application normally
would that being injection of beans or
transaction managers ejbs doing security
lookups or or database then it transfers
those test results back to the container
back back to the client side and also
then converted back to the test
frameworks own own the integration so
they will pop up when you run it through
J unit in the ID they will pop up as as
any normal Jaina test and same with when
you run it through to maven surefire for
instance I've also come up as the
standard surefire report then this the
last step is to employ and to to clean
up the tea container so if we look at
first the
you see them at fun do that take care of
a job alright so the first thing we're
going to go look at is what does our
killing core and itself self provide and
how can you do do your testing based on
that figure it out so we have a tiny
little application here that basically
has some kpa entities it has a stateless
session bean to do the interaction with
the the entitymanager we have a rest
service and we have a AV you see the
i-beam to to be used with with CDI go
one down and started serving first now
in the other console
then the other one this one one over
so first wing gun is we're going to do
with in the startup page a bus 87 server
that we have running on our our laptop
now I'm going to use that as our target
platform when we run the test if we look
at the look at the see this myself so if
we look at the Jaypee I test the
conference repository test case well
what you will see now the core is that
not say car what's the one else open
house I 30 lumbers encore sorry buddy
can sort of principles are just pointing
yeah that one so you see in the top of
that one you will see the D deployment
that we spoke about in this case we're
kind of abstract it away from the actual
method itself but it's calling out to a
static factory to to create our little
deployment and next we then do the
injection of the of the conference
repository and we inject our normal user
to section and then in inner test case
we can then by having a little
transactional callable we can call
different things within our own
transactional scope so in one case we
want to store a conference between one
transaction and within another
intersection we want to fetch that the
fetch book what we have stored and then
see that those different values those
different values are equal so from the
ID you can just right click on that and
say run as a unit test
we swap back to the s7 server you will
see that the deployment starting to
deploy it will find the teg bees it will
set up the database start weld and
execute the test cases in there
somewhere and then on the play them
again and we have a green bar so that's
the aspect of our Killian from from core
where we're doing a test in container
but there's still valid cases where you
want to poke at the air at the external
entry points like a rest service or a
HTML page for instance if we look at the
conference rest client tests Kate's gone
below
what's different in this case is that we
have to find the deployment that's not
being testable it's a very poorly worded
thing but it means that our Killian will
not do anything specific for
disappointment it will basically just
deploy deploy to the server and your
test cases test case itself is then
running on the decline sides so you can
only reach the key remote endpoints
what's interesting here though is that
our Killian since it controls the
container it controls the deployment it
also knows what's in that deployment so
by using the arquillian resource we can
inject back the the URL to the web
context web context that we just
deployed you don't have to externalize
that into properties files going between
different server environments for
instance so if it's your you're staging
server or your cloud server arquillian
will still just inject the different URL
depending on where where the target
ended up in this case we're not doing it
more fancy than just calling in the HTTP
connection and sending some XML object
back and forth to verify that the rest
service that is a a post on the
conference will store it and a get on
the conference with an ID where I should
return that same same conference to us
if you again just run that so Janet it
and yet that's done
should have a green bar somewhere clean
power that's it two different aspects
that are killing core gives you the
container control it's the entertainer
or outside of the container and put the
full access to to operate on the in
container services that the container
provide if you go back to the slides and
and then started to go into what the get
closer baby go on back on the
tapster and just scroll your way down to
where we're supposed to be high 80 yeah
sorry about that so the first extension
we're going to look at is HD persistent
extension oh go back there we go so when
we saw the JPA test that was in the in
decor it was very recorded low level in
the case of doing one entity and then
verifying the result of that if we
switch to the persistence extension it's
meant to handle the cases where you have
larger data sets or more complicated
data sets and when externalize those
from from the test case so the
persistence test case
so now we have a couple of new
annotations on on the test cases on the
test method one that when we when this
test method ends or is done we're going
to match that the database actually
matches the the conference with speaker
llamo file that we have here that is the
that is a a copy of the content of our
did of our database but excluding
columns like ID or conference ID your
speakers and times which are fluent
values so the persistent extension is
built upon the DB unit tools plus some
more it sports llamo XML adjacent Excel
files and a whole bunch of other formats
so we kind of up to you how you want to
do it and if we go back to the test case
and so we're staying at it when this
first test method is done it's going to
look the database is going to look the
same as this file or the concerts going
to be the same and we're going to clean
up the data that are in those files
sorry in the database afterwards and
then the next method we're saying that
use this data set as the basis for this
tests so insert all of this data before
our test starts then clean up when we're
done and in that case we basically just
getting the D conference instead of
inserting it and this all runs in
containers
just a green bar into the ball hi
so that persistence and we go to the
next one which will be drone drone is
the extension that handles everything
related to selenium and webdriver and
those types of testing tools for the
client side if we look at the drone test
case it will handle the life cycle of
the selenium driver and potentially the
selenium server insulin e1 and you can
inject back which which driver which
driver you want to use and in the test
case itself use selenium s as you
normally would by finding elements in
this case we have a form on our JSF page
to input a conference you can set the
different keys and just run it
so the only thing you really care about
in this case is that you have or you're
you're focusing on your test logic and
not this setup of the the containers or
the drivers and the next one which is
somewhat in the same field you go back
to the slides of all and then is that
there's one color Killian warp we've
seen seen that you can have for one no
sorry one slice right one slide no other
way so we seen agree with the test case
can either be in the container or on the
client side what warp does is that it
combines the boat so you have get more
of the the gray box testing so you have
black box and white box being in
container and then you have the gray box
with with the warp extension if you go
to the test case and see what that looks
like so the this is still the same with
we're using drone to inject the driver
and it's the same deployment but then we
are running the test case on the client
side even though this is an entertainer
and defined employment we're finding the
different elements in in their form
again but before we're submitting it
we're wrapping that up in a warp
execution and warps text and up every
verify step and piggyback static on the
request that is being sent to the server
so while the the webdriver is executing
the submit button click the there's a
server assertion object at being
piggybacked on that request and it's
executed within the life cycle of death
of that request
so when the server you can scroll a bit
down when the server hits we can then
annotate that server assertion up with
things like before servlet or after
servlet or all the different JSF life
cycles before render after render and so
on and do different assertions or create
objects or whatever we want to do so in
this case where we're injecting the the
conference repository after the servlet
is done and verifying that tally was
actually stored on the on the stored in
the database as well so while our web
page could potentially return the
results and our selenium test would pass
it doesn't mean that the data is
actually stored in the back end this
test kind of verifies both in 10 suppose
to see basically
you know
let's graphing graphing is a a wrapper
around the selenium api's to handle
things like a checked wait operations
and wave conditions and a lot of other
or it simplifies a lot of the the
standardized things around asynchronous
requests in web but in the new alpha
version that that is out now it has a
very interesting concept that kind of
builds upon the selenium page objects if
anyone is familiar with that where you
will take a instead of in your test case
itself do all the the fetching of the
ids or the CSS and so on and testy the
actual HTML it it encapsulates that into
a object where you can then say navigate
to page and find me something on a page
instead and graphing posts that upper
level to a component framework type
where you can have within your page you
can inject component fragments as well
if you look into the page the page the
conference page object which is a normal
selenium page object let's inject it on
page
and then we can say within this page
somewhere there is a component that has
the idea of create then we can nest
things down and then we have created a
java api for our conference form if you
go into the form it's basically what we
had in the test case itself in the
previous example but when we have
reusable components in the web layer we
can then reuse the test components as
well so one of the first thing that's
going to happen with this idea is that
the richfaces project for instance will
be providing their own jsf sorry they
are their own page fragments for their
jsf components so you can use boogie you
can even use the patient objects to
inject like a auto complete form or a
calendar and then you say java api to to
get the values or to set this election
and i'll have to to worry so much about
what the actual HTML behind this is
again we are in the test case here we're
combining this with warp test case
so well the first thing we do is to
navigate to a page then we're fetching
the form from that page and we are
wrapping the form submit which is same
as our click within a client server side
a client-server action so the verify
conference in this case it's the same as
same as the other ball number is just
verifying that it's actually stored in
the database
Oh
that's a short introduction to what
graphene or some parts of graphene and
then there's white man anyone know what
white man is cables pikemen no awesome
its runtime manipulation of your class
files basically so it's mocking runtime
where you can redefine how your classes
work or how any class ended in the JVM
work so arquillian interne integrates
with white men by using the BM rule
annotations so here we're saying that
when there's a class that is called
conference repository on the store
method whatever that method does is
unimportant we're going to rewrite that
to throw a new java java persistence
entity exists exception and then well in
this case we're just verifying as that
happen but it's much more useful in in
let's say you have a multi server setup
and you want to force the cash to not be
able to reach the other cash in in a
replicated scenario you can rewrite the
behavior of f java socket for instance
just say that there is no there is no
socket anymore and then that rule will
only be active in the scope of that test
so when it when the test is done the the
overall over override rule is also
removed so we did this store before they
didn't fail and now we added the
expected enter the fist exceptions and
it should still pass as we are rewritten
tlie because if you have ran it okay
right
there's two cuckoo there's the code
coverage bit where normally when you
need code coverage on the enterprise or
a container type setup you will need to
manually start the container in within a
different job agent and have that agent
manipulate the classes as they are push
to the server and you will have to find
that file on the file system where that
server is is running with the arquillian
integration since we're manipulating or
we can manipulate classes on the client
side we're actually deploying the pre
instrumented classes to the container
and we're handling the result as well so
you can code because you can get code
coverage on a remote server that is not
on the same file system as the other one
if you run that in this case we're just
activating a different profile in maven
to activate the shikoku and a plug-in
that will run through our whole test
suite
and should output the the shikoku
coverage report
if you go up and view that in the Chrome
browser know if you go back down yes
start chrome to cleanse up I'll make
command line
outgoing when you were at the wilk
landline you're at and arrow up one more
one more there that's generated report
from jigoku if we go to the repository
the universe repository which sorry our
ejb cannot see that we have coverage on
the methods that were called in that
scope so we have full coverage and get
and store but we never got a cuddle all
of them so that's a missing missing test
so the next one is Jay rebel integration
anyone used g rebel ready deployments
yeah cool the there is an extension to
to delay or delay the redeployment of
the test archives put in our Killians if
we the first thing we do is to activate
the special maven profile within the IDE
which is called our Jay rebel don't keep
the donut hole and that then tells
arquillian on the client side to only
deploy it if we haven't deployed it
before and then it would generate out
the the the the XML jejejeje a rebel XML
2.2 to the local disk and from their own
let terrible handle the the the up
updating of the sea deployment as we
change it if you go down to the standard
warp text size case that we have before
and if you run that once and we look at
what's being deployed to the server
are you scrolling or go down and see put
the bar hmm go to the bottom of the did
you run the test for
so
okay Democrats are in also well anyway
the point there is that when the first
time you run it and it's now being
deployed arcadium will deploy it
normally the second time we you run the
same test case arquillian stops the
deployment because it's already existing
because it never under played it and
then it's just terrible class loading
that is updating your EG bezoar your
test case on the decline side as you
keep keep writing them so is that the
only thing that exists in the arc of the
universe and not at all there's
extensions for doing android based
testing for iOS testing visualized
testing with with rush i to verify that
the output of a of a application being
the image or the visual aspects of it
actually it looks correct and not just
that it has to correct HTML but hTML but
the CSS and all that matches up spring
to the handle spring MVC and then
they'll spring embedded containers the
tiny performance extension to measure
tegra getting performance of different
test methods next one
there's a transaction intersection
extension to handle rolling back
intersection or starting one before the
the before the before and after two test
methods jsf unit two seam two and portal
integrations and if you want to know
more about oh sorry go on and there's
also support for our Killian in maven
where arquillian only handles feed the
containers so you can use maven plugin
similar to Shetty run or the cargo
containers where it will start up a
container is part of the maven lifecycle
and not necessarily a part of the test
life cycle and also deploy deploy an arm
deploy from them there's a forged plugin
to handle simplifying the setup of the
tendencies and create test cases and
versions and so on and there's more
talks at javaone this year it goes more
in depth on on the different topics
lincoln and brian has one about jsf
we'll cover more of drawing warp and
graphene Carl has one would go into
mobile testing with Android and Marius
has one for spring parts of it where
it's using the spring extension to to
test we have another one and we have
another one oh that's true on one a
wonder what's that sure Winston
Wednesday will be gone through use cases
in Java EE testing so we're going to be
looking at a bunch of the rougher edges
along java ee testing transaction
security nodes we're going to pull from
our examples and do probably some user
questions and probably have a discussion
about how we can use our killian to dig
into the container and do some white box
stuff in addition to the black box stuff
and integrate this all together from a
use case based perspective so that'll be
on Wednesday
afternoon yeah you can find us on
google+ and whereas our chili in their
org and will of course open source and
we're all kdub all the extensions and
for anyone have any questions or is
everything clear on this little talk
excuse me
yes and not currently i think but it's
part of the training material that's
being created now i think yeah he should
know although we are writing a book said
although we are writing a book yeah
which will showcase the usage of our
Killian and various jboss org
technologies that are complementary to
Java EE and building a top of it and
even going into things like Jay rebel
and whatnot the book is called
continuous enterprise development in
Java and it's available for the early
access release is out now we have some
cards that we can show you and you can
go in and kind of take a peek at the
types of things that we're going to be
addressing in that book which will cover
the things that OSH lock showed you
today and also the use cases that will
be shown on Wednesday but yeah the
arquillians suite is is pretty
consistent throughout I mean it's used
as the test suite for EAP which is the
enterprise application platform so as
these things roll out in the training
comes in I imagine that the arquillian
training will will have a central role
in that part two as well sure we have
some handouts for you it is called
continuous enterprise development in
Java and it's available that we have a
book site that's being built at
continuous dev org so if you come up
here you can grab a little thing there's
a QR code and you can take a look at
that at your leisure they're also a book
number two in in the works from packed
i'm not sure what the name of that will
be yet but it's there's more than one in
the works
nothing thank you for me class dismissed
early</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>