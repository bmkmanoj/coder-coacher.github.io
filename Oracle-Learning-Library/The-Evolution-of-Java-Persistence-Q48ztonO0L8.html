<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Evolution of Java Persistence | Coder Coacher - Coaching Coders</title><meta content="The Evolution of Java Persistence - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Evolution of Java Persistence</b></h2><h5 class="post__date">2013-01-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Q48ztonO0L8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everyone nice bright and early
this morning was very good boy I went
back to my hotel nice and early last
night just for you guys can't promise
that for the rest of the week but um
okay I work for Oracle so I put this at
this front of all my slide deck isn't
most of what I'll be talking about today
is available in open source but it does
get distributed with Oracle products so
I'm not committing to any release
timelines on anything very non-committal
today so my name is Doug Clark I am the
director of product management I have a
couple of different areas of
responsibility at Oracle primarily I
look after the top link product line the
persistence pieces that feed into
WebLogic and GlassFish I'm the co-lead
of the Eclipse link project which is
mostly what I'll be talking about today
and recently I became the product
manager for all the Avatar stuff you've
been hearing about in the Java one
keynote and then I have some other
sessions on that later this week so
today what I want to do is I about I
have a lot of material so we're gonna
see how this goes I tried something a
little different and reordered
everything and tried to jam my two and a
half hour workshop into a 50 minute but
there's a lot of interesting stuff we've
been working on for the last couple
years that I want to make sure people
are aware of and really explain how we
see the persistence pace evolving and
give you some insights into where it's
headed so I'll try to be as quick as I
can on the background material so in the
persistence phase our primary data
source is relational we deal with object
relational mapping we are the reference
implementation of the Java persistence
API JPA what we've also done a lot of
work in the recent years expanding what
our persistence engine can do so we've
added a Jack's B implementation to do
xml binding and then a couple years ago
we added a feature called database web
services which was really focused on
auto-generating a
so jax-ws based web service so that's
kind of where we started from
and then today what I'd like to do is
walk you through some of the features
we've added above this core persistence
piece and how it do you know every
feature we add is based on conversations
I have with people customer visits
dealing with consultants trying to
figure out what you need next in your
applications and try to deliver more so
each of your custom applications you
have to code and maintain less that's
what I see my job as so on the standard
side obviously we're very involved in
standardizing persistence I will we have
JP 800 which were the reference
implementation of we implement Jack's b2
- we are the reference implementation of
SDO two on one that's the last time I'll
mention SDO this week I like to bring it
up once but some of the stuff we've been
doing recently is we've expanded to add
JSON binding support a feature I called
dynamic JPA which gives you a lot of
flexibility in how your models can be
defined and evolve multi-tenant support
or tenant isolation different strategies
for running in a software-as-a-service
environment with a shared database
schema I'll walk through some of those
and then we have a feature that kind of
brings all of that together with restful
JPA
and that's some of the pretty exciting
stuff we're doing and it leads into thin
server architecture html5 JavaScript
clients and I'll hopefully have time to
show some demos there and then we've
also introduced no sequel support so a
similar object relational JPA style
binding but to data stored in a non
signo sequel database looking forward
beyond what we're doing today we have
the JPA two ones back on the horizon
there was a number of talks this week on
JP a21 so I'm not going to touch that
material if you're interested in that
come by the booth and we can walk you
through what's in that we're gonna
standardize our JSON binding work we're
gonna figure out what kind
standards people want around no sequel
in in the Java persistence pace right
now it's kind of a maturing space and
then I also have some interesting stuff
related to Java persistence in a
JavaScript and node environment
server-side JavaScript dealing with
persistence that's pretty interesting
and that I'm gonna leave till my 5:30
buff today okay so the eclipse link
project that I co-lead has several key
components JPA moxie which is our xml
and json binding solution and database
web services our goal is to provide a
common persistence engine that you can
use in your applications no matter where
your data is stored and no matter what
kind of container environment you want
to run in obviously we're tightly
coupled with the Java EE container but
we run quite nicely in Java SE and we
run out of the box as an OSGi bundle
with a special support for bytecode
weaving in an OS GI container so we're
pretty unique in that space too so
pretty much anywhere you want to run
your code anywhere you want to store
your data and help you with the
flexibility of doing the mapping on the
tooling side we're an eclipse project so
we're distributed to Eclipse and
included in the Eclipse IDE we are a key
component of obviously Oracle toppling
the product I run at Oracle basically
redistributes Eclipse Lincoln adds a
little bit we're shipped out of the box
in WebLogic GlassFish and then there's
some other open source projects out
there that have started picking up the
eclipse link and distributing it and
that's far from complete but that's some
of the nicer pictures I could find so I
want to start with JSON binding
obviously with the growing use of rest
and html5 JavaScript style clients being
able to work with JSON is very important
so what we've done is taken our Jack's B
implementation with its XML binding
support and extended it so that with a
given moxy context I could go to
Cemil or json using the same mapping and
it's really flexible because I can
actually using the same configuration in
the same running service get my data in
whichever format I want so there is no
standard in this space a lot of the
solutions you'll find out there actually
translate from an object form into XML
and then use a string based conversion
routine to go from XML to JSON what
we're doing is we're actually using a
mapping engine to get the values
directly out of your business objects
and put them directly into a JSON
structure so it's a lot faster it's a
lot less memory intensive on the
standard side our goal is to take what
we've learned about Jax be apply it into
the JSON space and standardize this
piece so there's already a jsr filed for
json P which is the parsing which is
comparable to the the jax p the parsing
side of xml and then we're about to file
the json b spec so it'll have a lot of
capabilities very similar to jax be but
just be json focused so here we take a
simple class right now we're just using
jax be annotations annotate my class and
then I can easily marshal using the same
runtime artifacts to XML or JSON and I
dropped a code sample in here to show
you how easy it is what we did was we
extended the marshal ER and unmarshal ER
just to make use of a media-type
property very similar to how jax-rs
works so if you're actually using this
inside of a jax-rs service you take the
media type requested pass it to the
marshal ER and it automatically gives
you your objects back in that format so
that second line is the important one
the next one just really deals with how
the root level element is spelled out or
whether it's embedded
so when we started dealing with rest and
xml binding and json binding in a
environment with JPA entities we ran
into some problems
the Jax bees specification is really
focused on how do I get objects in and
out of XML the JPA specification is
focused on how do I deal with relational
databases queries foreign keys primary
keys and they you know these two specs
never really sat down and sorted out
their differences so we we ran into some
problems in in JPA you end up with a lot
of cyclic references bi-directional
relationships based on foreign keys
there's some composite key classes and
then every persistence provider does
some form of byte code media
manipulation to be able to augment the
state of the class to get better
performance you generally don't see it
but inside your classes when you load it
up in a JPA application if you looked at
in a debugger and you'll see a lot of
extra properties that you never wrote we
put them in there through the bytecode
weaving instrumentation capabilities but
the problem is if you add additional
state to a class and then add ask any
reflection based API to interrogate that
class and do something with it you're
gonna have problems some of those
problems are very simple ones like if I
put an additional state attribute on
there Jack's be a LOD matically go
through and put that in my XML say you
know that was an easy one we just when
we bytecode we've the attribute we add
transient to it but some of the more
complex pieces are dealing with some of
our relationships and some of the ways
we deal with how we bytecode we've those
starting out with a simple relationship
I have a project class project that has
a collection of employee members and the
employee has a single project that's a
very simple one-to-many many-to-one
return very common in every JPA
application the problem is when you take
that relationship and you convert it
into xml you end up with
infinite loop you know the you other you
have a couple of choices it's back in
here did you stop working there we go so
we can strip out the relationship
information and just marshal the core
structure of that employee but the
problem is when you go to bring it back
in now I've lost information so I need
to have knowledge when I'm dealing with
JPA entities going in and out of XML or
JSON about these relationships and what
they mean and how I want them rendered
so what we had to do was add some
additional metadata to our mapping world
so here an employee has a project and I
marked that as an inverse inverse
reference so now the metamodel knows
when I'm reading this out just the
containment within the project of an
employee I can populate the other side
so really I'm just telling the mapping
engine which side I care about when
you're creating the XML so if you just
took Jack's be the reference
implementation out of the box your only
way to make this work is to go in and
break relationships in your object model
so basically tear down your JPA mappings
to make it work in XML and nobody does
that
so what everyone ends up doing is they
end up making multiple domain model
structures and they write all this code
to copy objects their data values from
the JPA and these into something that's
Jax be friendly and what we're trying to
do is just deal with that Jax BJP a
fidelity with a couple of simple
configurations so with that setting we
can store the values my employee still
looks the same as it does before but
when I build it back up I can
reconstitute all the relationships so
that was just one example there's other
challenges dealing with foreign key
relationships within objects large
documents how you reuse pieces there's a
whole set of functionality if you google
eclipse link Jack's be
our chief architect he blogs I think
hourly but the number of examples I've
got to the point now where I don't have
to remember anything I just google it
and all my examples come up so blazed on
he publishes all kinds of stuff on all
the features in this area okay so that's
kind of the introduction to our JSON
binding I'm slowly building to how all
these pieces fit together another one
that I was very involved with is a
feature called dynamic JPA
obviously sitting within Oracle and
dealing with relational databases I have
a lot of customers who are other Oracle
software groups and one of the things
we've discovered is a lot of the
features they offer like the Bibble the
pimple solution and the SOA
infrastructure lets you go in and
configure how you pull data out of the
database and expose it to a web service
well they don't want to be code
generating all these JPA entities
compiling packaging and deploying when
there's no actual application logic so
what they wanted was a solution that let
you use standard JPA without any Java
classes so what we ended up doing was we
we have a two-part solution in this
space we call it dynamic JPA because
there's no java we don't generate any
source there's no dot class files
there's nothing packaged it's all
declarative JPA usage through a feature
we call virtual entities and attribute
accessors and we're heavily using ASM
bytecode weaving for this as well the
second piece is dealing with extensible
entities and I'll show some more on that
on the dynamic side here's a simple
mapping for an address class it looks
like a standard or M XML file I have an
address the only difference is in
standard JPA i define my access to be
property or field for how the reflection
engine talks to my class well there is
no class so we added a new access type
called virtual and the only pieces you
need to make this work is
we need to know it's a virtual class and
since there's nothing to interrogate the
class to get back it's tight you have to
tell us what the types are so in here my
address ID is an int I have a city
country and postal code that are strings
but for the most part it looks like
standard standard or M code with these
small additions and what happens at
runtime is we actually bootstrap using
ASM we create this address class and
then we can do full standard Jaypee a
full metamodel j PQ l even criteria
queries talking to the database so if
you have a situation where you're you
don't know what the n domain model is or
the relational structure a given
application component is going to deal
with I can still build service modules
that can be configured dynamically at
runtime the second piece of this is a
little more common and we've been
dealing this I've been working on top
link now for a little over 15 years and
this problem has always come up I write
an application I you know I have all my
attributes they map to certain pieces in
the database but certain types of
applications need to be more flexible
what they want to do is they want to
allow you to configure additional
properties that I can use later on post
deployment so historically what people
would do is they would have a class that
has a map of additional attributes and
you know in JPA I can actually map that
to a secondary table of key value pairs
the the problem is it's not very
efficient every time I want to read an
employee I have to read all of its key
value extensions so what we did in a
couple releases ago was added explicit
support to let an entity type be
extensible in the same row and then you
have a couple of options on the database
side you could have predefined flex
columns like reserved unused columns
that you later on define their use or
some more adventurous customers are
using schema gen at runtime to alter
tables in a in a running database system
I
yet to meet the DBA who likes that idea
so for the most part we call this kind
of flex columns you have a set of
columns at design-time that you say I
don't know what the end user is going to
need so I'm gonna put these flex columns
in and then during the lifetime of the
application I can define through
metadata what those columns are used for
and get full JPA support so here I have
a player his static attributes are ID
first name last name which are mapped as
standard pieces and then I have these
additional flex columns that I'm going
to define later to make my class
extensible I need to say that I have
virtual access methods which says by
default I have this Get Set pair that
deal with the attributes in that map I
use field access by default so I need to
mark that as transient so JP doesn't
pick that up as a as a special attribute
and give me a blob column for it so I
need the get method here and the set if
I don't like those method names in there
is additional settings and virtual
access methods I could use a get put
whatever I want so those ones there then
the next thing is how do i define what
these extended attributes are so again
here is a snippet of a Eclipse link or M
XML file for the class player and here I
state the additional attributes so I'm
going to store penalty minutes and
position their virtual and I give the
types now I can do this and package that
up with my application and it runs quite
nicely the other piece we've added is
the support for pulling your additional
metadata from an external source so I
could build an application I could make
it extensible and then I can build a
server admin repository where I can go
in and configure these extended
attributes and every time the
persistence unit gets rebooted it will
make a call to that service pull this
additional metadata and augment the
static metadata and if all goes well I I
can show you what that looks like at
runtime
so it's again it's the virtual access
and the attribute type that I need to
provide okay
the third piece them to my puzzle is
dealing with multi-tenancy or
cloud-based deployments I tend to focus
on calling it tenant isolation much more
than multi-tenancy if you're going to a
lot of the cloud talks here when we as
Oracle generally talk about
multi-tenancy
we're talking about you as a consumer
that we want to keep your application
isolated from anybody else who runs in
our cloud we want to keep your data
isolated from everyone else I'm not
breaking any of those rules here I do
have a large group of a growing group of
customers who want to build software as
a service application they want to build
a hosted system where they can provision
and deal with multiple tenants and
within their data set they want to store
it in a couple of different relational
strategies and it really comes down to
how I want to share or have a dedicated
database schema tablespace and then how
my runtime architecture works whether I
want to have a dedicated application per
tenant or a shared application per
tenant so if you look at the dedicated
dedicated this is kind of the most
common thing people have today they
build an application it talks to a given
data source it has a database it's
completely isolated if I want to deal
with a second tenant I would customize
that application and deploy it again
that's fine we we've added support in
all of these areas so in the dedicated
dedicated I can actually customize and
augment dynamically my metadata without
changing the application so I could
deploy the application and have it pull
additional metadata to talk to a
different data source the stuff I'm
gonna show in my demo is really dealing
with some of the shared database and
shared application space where I have a
single application that can host
requests for multiple tenants they can
be stored each in their own database
schema tablespace or however you want to
isolate your data
or what some of my customers are doing
is they want to actually store it in the
same database and stripe that data so
each database each database row is
tagged with the tenon it belongs to and
then all the sequel to access it is
augmented to do that 10:00 in comparison
okay so in the dedicated dedicated space
everyone has a unique container you can
do full caching because you're you're in
your own space everybody has a unique
set of tables there are no common
storage the only thing you must do is
make sure it's deployed uniquely and has
its own dedicated data source configured
some of the more interesting ones is
when you end up with a shared
application and when you come in the
front door the application you have to
indicate which tenant you are it can all
run in the same space with the same code
so this lets me scale up the number of
tenants without having to redeploy a new
application each time so if you think
about a multi-tenant application that
has many small tenants like I have one
customer who does task management and
the number of active users they have is
very small so deploying a whole new
WebLogic instance and dedicated
dedicated application instance with a
dedicated database is just too expensive
so what they do is they have this hosted
environment where they still depending
on what the customer wants as far as
data isolation they can run in this mode
with a shared application infrastructure
or they can start looking at shared
database so what we introduced last
release was a multi tenant annotation
that basically describes how a given
entity is stored in the database
alongside other tenants data so the
first thing we introduced was this
default annotation which is our single
table and it means the rows for multiple
tenants are stored in the same physical
table so you know it depends on your
application how comfortable you are with
this we introduced the feature because
customers wanted it but the other piece
that rule
doubt of it is we always had VPD support
to do a database isolation of data using
Virtual Private database in Oracle's
label security support so it was really
easy for us just to piggyback on that
existing functionality and add this VPD
level now when I come in the front door
I specify my tenant the VPD context on
the database is set with the right
credentials and I can only read my data
so instead of doing sequel augmentation
the database is restricting my view of
the table so that's a lot more secure
and you know more DBAs tend to like that
one better up here I can't do native
sequel support because I can't ensure
that the sequel string follows my multi
tenant rules but in the VPD world since
they're actually augmenting the sequel
going to the JDBC driver you have full
access it looks like a real database the
database just only shows you what you
need okay 10 accustomed 8 ok I'll keep
going on this so the tenant strategies
as I mentioned we added multi tenant
which is the single table together we
have multi tenant with VPD which is
basically just the single table and we
have this flag to whether or not we
include the additional criteria you do
have to pass through the identifier and
clear identifier we look after that for
you but the you need to map your tenant
ID into the database credentials and
then of course you have to configure
your database so we've augmented our
schema generation so if you're running
in this mode will actually generate all
the Oracle sequel necessary to set up
VPD for you that was a great feature
because I can never remember that stuff
and then that was our first release with
this multi tenant then we added in the
next release table per tenant so now
when I connect to the database I can
actually specify that each tenant has
its own given database table by name or
I can actually dedicate a schema per
tenant so again our goal is to give you
whatever flexibility you want for how
you want to isolate your data
so a couple of code samples here there's
a standard class in my sports demo I
have a player with a bunch of static
attributes and on the far right hand
side I have this league attribute so I
can always support this in my
application if I wanted to custom code
my application to isolate data by this
column I would just have to manually add
that to all my queries always add the
league that I'm looking for what we're
doing is making that a little more
transparent for you so here I say I'm
going to use multi-tenant which is a
single table common storage for all my
tenants my discriminator to indicate
very much like inheritance which tenant
it is I have a property called League ID
and the column name I just say which one
it is so now I don't have to map that
into my object just every time I go to
talk to this class I need to specify a
league ID property in order for it to
talk to the database and then on the VPD
side it's the exact same relational
structure of course the database has to
be preset up I just tell it I'm going to
use a multi-tenant with VPD and then
that league ID property is used in the
context value that it's passed in to the
database to set the VPD column state and
last but not least our new one table per
tenant here I'm using a strategy by
schema so I have a schema for my
high-tech hockey league with a player
and my soccer league so they each end up
in their own schema with the same table
name I can also do prefix postfix on the
table name if I like to keep it in the
same schema and just have it customized
by name of course in this world I need
to generate new tables for every for
every tenant I provision a couple of
runtime architectures around this one of
the things that quickly comes up when
you start looking at a shared
application supporting requests for
multiple tenants is dealing with caching
and security of data so if I'm dealing
with a shared database I can't read a
row convert it into a knob
can put it into a shared cache and then
have another tenant show up and
accidentally act access data from
another tenant so it out of the box when
you enable this we turn off the shared
cache and of course all our caching is
configured by type so you know you might
have some tables that are not
multi-tenant and some that are we just
turn off the caching for the multi
tenant tables so that each one of these
requests coming into its own entity
manager it runs a query creates some
objects populates them it's running in
its own context with its own tenant
identifier set on it if I connect and I
don't provide that tenant identifier to
the entity manager it will throw an
error when I try to hit one of those
tables so this is what we do out of the
box some there is the ability to turn on
that cash but we disable it by default
to make sure that we've protected you as
much as we could then we have some of
the other strategies here I have three
different threads coming in two of them
on the left are tenant number one and
the one on the right is 10 and number 2
so now what I've done is I'm spinning up
a different entity manager Factory
that's kind of the singleton in your
application generally you have one of
those in your whole application but in
this multi tenant world where I'm
dealing with different tenant datasets
we now have added support where I can
easily spin up an any manager factory
per tenant now within a given
application I need to look at the
reasonable behavior I expect if I have a
limited set of tenants you know tens
hundreds of tenants it might be
reasonable to create a new entity
manager Factory in every single
application instance if I have an
unbounded set of tenants this becomes a
huge memory hog so it really needs to
fit in your world so if you have a large
number or a dynamic tenant base you
probably want to turn off caching and
limited but some customers have asked us
for the ability to have caching per
tenant and that requires having a whole
entity manager with a backing session in
its cache and its own data source access
and connection pool
okay I'm making good time today so what
we've talked about is having a JSON
support within my persistence framework
we've looked at dynamic persistence for
how I can build models on the fly or
make my models extensible there is
support for pulling metadata in from a
running service of my applications
become much more dynamic in their
metadata and then we looked at some of
the multi-tenancy so the last feature
that we added so last year at JavaOne we
announced this project avatar and
depending on which talk you go to this
week you'll get a lot of different
definitions of what that means I'll tell
you what it means to me it was kind of a
overriding effort to address how Java EE
developers can deal with html5 and
JavaScript so under that we have a bunch
of different areas that we looked into
so we've added WebSocket support we have
a proposed standard for WebSockets
server sent events jax-rs is revving
obviously to support these clients and
ice rest interface and then on the
infrastructure side we've done a couple
things in toppling but what came out of
this was how do I take an existing Java
EE resource and easily build one of
these thin clients so what we did is we
introduced something called JP ARS kind
of playing off the jax-rs
which is support for exposing a JP a
persistence unit over rest without
having to write any code and I'll
explain what that means for those of you
who haven't done a lot with rest of
obviously represent represents
representational state Wow jax-rs is the
standard there's two versions the two o
is in progress right now and it looks
pretty impressive I think they're gonna
wrap up very soon or freeze it as they
work towards their
their new implementation and what it
really focuses on is how do i
programmatically set up my services
within a Java EE container so I have
some code samples here so if I take out
an invoice service that is able to read
an invoice and return it to me
so here I've mocked out the example I
make it a stateless session bean I drop
some JPA code in here to find the given
invoice obviously my application never
fails so I don't need any error checking
whatsoever to make it a jax-rs service
you have to give it a path which is
basically the URI route within your
application namespace for how it talks
to this being over rest and then I
expose different operations
so within rest you know I can get I can
do gets puts posts deletes so here we're
gonna do a get and within my path I'm
gonna say that after invoice the next
element is going to be the ID that ID
gets passed into my read method through
this additional annotation I tell the
engine get the ID off the off the URI
and pass it into my method and then I
can run my code and then as far as data
format I have to say which kind of data
structures I'm bringing back generally
XML or JSON there's obviously a number
of other ones but for my purposes today
those are the most important pieces so
what I end up with it all I send a get
operation to my machine oh whatever port
the application context for the and the
you root URI for the application and
then I go slash invoice and slash 4 with
the jax-rs engine does is takes that
information translates it down and says
ok I have a beam that looks for invoice
with a get operation that takes the next
element of the URL and treats it as the
ID and I pass it in so the jax-rs engine
is all about doing that translation for
you and it does it very well so what we
end up with is we have a client
application
making rest calls over HTTP to my java
is a server where I've exposed some set
of session beans through a rest your
rest api and then for our purposes we're
getting that data out of the database
with JDBC using our JPA layer so what
you get at runtime and this is you know
obviously doing all this JSON and XML
binding we we started playing around a
couple years ago with how to best use
our stuff within a rest interface so
that the jax-rs layer typically we use
Jersey here I end up with a number of
these session beans exposing services
that I want to get to over rest so when
I make a request like the one I showed
you that invoice request to get invoice
number for the jax-rs layer does the
translations as okay you actually want
to talk to the invoice bean and we're
gonna pass number four in there then
within my own custom code that I have to
write in every single session bean
method that I expose I have to look up
the persistence unit create whatever
kind of query or operation I need to do
through JPA
talk to the persistence unit run my
query it talks to the database and gets
me back my data in object form and then
I need to return it but that's a lot of
code now for every persistence operation
that I want to expose I have to write
one of these custom service methods so
what we did was introduced this other
layer called j pers or restful j PA
which automates the exposure of a
persistence unit I don't have to do
anything when I enable J PRS it will
take all my persistence units expose all
the available operations automate the
binding to XML and JSON of all my
entities of course I can you know go in
and limit it and apply security policies
for who's allowed to do this
but out of the box I can just turn this
on and I get full access so now my get
comes in jax-rs hands it off to the j
pers layer now i have this additional
route in
my URI the persistence unit name is the
next piece accounting I want to talk to
the invoice and do a given operation the
GPRS layer looks up the right
persistence unit converts all the input
parameters that we need to run the
operation execute it through the
persistence unit gets back the result
and automates the return of that result
to the client in the format they
requested so it's really about
simplifying development what we do is
we've built a web fragment that you just
drop into any Java EE application that
has a persistence unit and it will
automatically spin up this rest
interface obviously we're tightly
coupled to eclipse link JPA
and we rely on Jersey for our rest
interface we've recently made some
enhancements to make that portable
should be completely standardized across
any jax-rs implementation what you get
is all the functionality of your JPA
persistence unit whatever kind of
caching multi-node configuration
database virtual private database
whatever other features of your backing
store and we get it out to you some of
the unique features we added beyond that
is obviously we've taken our dynamic
persistence so I can actually spin up a
JP RS restful interface to my database
using dynamic persistence and have no
code whatsoever I take a couple of
standard persistence XML our extended
ORM XML put it in a web in a war file
deploy it and I have rest access to my
database so you can use it both with an
existing Java EE application or for one
of these dynamic persistence units and
that's where we're starting to build out
or tooling where we can do it for you on
the fly ok so I am
I see some people out there who are
obviously interested in the no sequel
support based on their t-shirts but I'm
gonna skip over to one of my demos okay
so I'll see how my application wants to
run
I mean my computer have been having
issues this week so what I've built is a
simple somewhat simple demo application
and this is hosted on the eclipse link
project it has its own get repository
and what it does is it makes use of the
multi-tenant capabilities both with
single table and table / table / tenant
support that actually loaded and it
makes use of @jp RS to expose that over
rest and we've also included this
extensible entity support so it's a
little confusing because I jammed a lot
of features in there but I was having
fun and I run a lot of sports leagues at
home so I was working towards something
I might be able to use so what I end up
with here is a very simple multi tenant
application so on the home page instead
of logging in I just have you pick which
tenant you're interested in and when you
go in it does some simple stylesheet
stuff I am NOT a web developer this is
as fancy as I get I was pretty impressed
oh yeah I gotta admit I won't I won't
tell you the number of people who had to
do the graphics and stuff for me but so
here I have my little soccer league it
has two division my under six and under
eight if I go in here I can see all the
information I can see my Bears team and
here's all the people first name last
name and since I'm dealing with little
kids and snacks after soccer I was
curious what their food allergies might
be so that's a very simple application
if I go back up to the front now I go
into my believe this one my kids hockey
football league so now I have the first
name last name the position their weight
and height so what I've done here is
I've actually taken the player class and
make it extensible which in itself isn't
all that magical but over in my
administration stands in my
administration
we customize and provision new tenants
and they become instantly available in
my my sports portal so if I go in here
to the Soccer League I got to get it a
little bit a big stick of note Doug
please refresh your application before
you start clicking on things yeah I
don't know what the timeout is said on
my on my app server I think I'm good for
about eight seconds so here in my admin
console I can actually look at the
sports league you know I have a logo a
name how do I want to do my Tennant
isolation this one is set to row and
then down here I'm tracking allergies so
if I decided that I wanted to also track
shoe size for whatever reason I store
that in the metadata database I come
back up I come back in this I want to
look at the sports team again today okay
but I'll show you how it wires together
my admitting there and it exposes a set
of rest interfaces so in here it
actually returns this so this is my
extended definition you'll see I have
divisions teams and players they're all
a single table ten in isolation with the
discriminator and then down here on the
player the one I've made extensible I
have allergies and shoe size so when the
administers it however it wants to store
its metadata but then it makes this
available now the running application
whenever it boots up a persistence unit
of this type it's configured to make a
request to the adminserver for the
extended attributes so if i refresh the
metadata in that application restarted
it'll come up and it'll then expose
these now in my JSF front-end
I I do a little work with the JPA to
metamodel to actually walk through the
metamodel and see what the attributes
are and that's how I customize the
columns there's not a whole lot of black
magic in there so that gives me my
extensible application and then if we
look I'll quickly flip back over here to
the console yes so as I was walking
through that application when I made a
request on the first page it stored my
tenant ID for me if I had a more secure
application I would log in and it would
you know verify passwords and then cache
within my session State on the web
server who my tenant is and then every
time I talked to JP AI past that tenant
information into the persistence context
and it makes use of it so here I was
using single table and you'll see that
all of my queries are actually augmented
to have the league ID checked so when I
wrote those queries they have no league
just through the multi tenant annotation
and me specifying the property all my
sequel to that type is customized I
believe the I go back here and look at
the football league Wow we're fast today
okay this one this one seems to be
running nope so if I go back and look at
the sequel now this one is using a this
is using table pretendin so now when I
log in and say I'm using the kids
football league unlike the soccer league
which is in the shared striped database
table this one actually spins up and
uses its own dedicated table and in my
min app all I had to do was indicate
that if my team in a payment or
a table level and if I inspect schema
level it would have just looked in a
different schema so that all works
pretty nicely so the other piece that I
wanted to show you that we've done on
this application is I dropped the j pers
restful capability into this app and now
i can come in here through my test
client my rest test client and i want to
do a quick run-through so if I ask for
JSON and see if I can get the right one
now which localhost my sports oh yeah
get
okay that application is not behaving
properly let's redeploy it
okay so if I talk to the application at
the root level persistence I can go in
here I do a get I have to specify
whether I want XML or JSON and what
we've done is we've built out a metadata
API as well one of the tricks when we're
trying to build these rich clients is
what are the URLs available and what are
their data formats that it returns so in
addition to just returning the data for
your operations we also added a whole
metadata API and as I navigate through
this assuming it wants to behave make
sure this one works first yep so there's
my listed divisions but I could also go
through and say okay and this is really
just exposing JPA standard metadata over
JSON so the URL I hid there was I want
to see the my sports the Ottawa Soccer
League tenants metadata and it says okay
well I have four different types user
Division player and it was pretty nice
we decided to actually give you the URLs
and there's my metadata for a player
it's got ID allergies emails first name
last name user ID version and then some
different links down here for queries
that you might want to run so that works
nicely the I can change the the type to
be XML and I get XML back and really all
we're doing is passing the media type
through the jax-rs layer into our
Marshal order so that gives me that
piece so then what the goal here is in
this whole thin server architecture
world exposing JPA over rest was what
can we do I'm not sure how well this is
gonna work so right here we've built out
a pure JavaScript html5 application that
is completely client-side using the
exact same services that I exposed so
one of our JavaScript gurus whip this up
for me it took him about 20 minutes
and I'm leveraging my exposed JPA
artifact without having to build a new
custom client the next piece we did was
the JavaFX guys took that same hosted
service and they whipped up a Java FX
client running online machine and again
it's making the same rest calls and this
one is actually using Eclipse Lincoln
Job FX to do all the unmarshal anon the
client side so using the same soccer
league I can walk through and you can
see all the attributes of the players so
that was that was pretty neat I'm not a
big Java FX expert so I was happy to be
able to expose my stuff then he took
that same one and installed it on my
oldest ever iPad this is my finger of
God demo and again this is hosted with
Java FX running on top of iOS 6 in
development mode and it's the same
hosted service so the whole point now is
I can take my JPA work expose it over
rest really easily like I just dropped
this web fragment into my package war
file or your file redeploy it and I have
this rest interface and then I can go
build whatever kind of client solution I
want completely independent of that so
if I have an existing Java Java server
faces back and I'm doing whatever kind
of server-side rendering of the client
and then I want to move into this world
we tried to make it as easy as possible
ok so that kind of pulls together all of
our json or dynamic our multi-tenancy
and exposes it to this thin server
architecture JavaScript html5 world some
of the other areas were working on is no
sequel support and this is the last one
I'll touch on today now this is not
standard JPA I need to make that very
clear to be compliant JPA provider it's
very clear right now the JPA standard is
coupled to relational but what we did is
we stepped out
side the JPA spec and tried to build a
JPA style access because we wanted to
get it out there and get some feedback
obviously every no sequel database has a
Java interface of some form that works
quite nicely
and this style of access is not going to
be applicable to everyone our goal was
to deal with the same problem space
we've always dealt with with this
binding to my domain model and using my
domain model in my application space and
then storing the data into the no sequel
store so obviously if you're going to
use a large Hadoop data store storing
documents it probably doesn't fit well
into an object relational or object no
sequel kind of solution but this is
really to get some some work out there
and get some feedback and see what
people are looking for and where we
should be looking at standardizing this
in the Java EE space so obviously there
is no standards right now we have to do
a custom integration with each solution
we've shipped two solutions one with
Mongo and one with Oracle no sequel a
couple flavors in there with the
Berkeley and the the new no sequel API
on top of that when you run queries
depending on the backing story you'll
always have different levels of
functionality so some some data stores
we're only going to be able to do
primary key gets some we can do little
more rich criteria based queries when we
sit on top of coherence not truly what
everyone would think of as a no sequel
store but we can do a similar operation
we take your JP a query we parse it down
into our own expression graph and we
generate coherence filters so we're
applying that same logic in what we're
doing here with no sequel and we're just
trying to offer whatever capabilities
they have and expose it up to a JPA
style interface it has some custom
annotations it does some subset support
of JP QL as I mentioned we have two
databases we're looking at additional
ones now always looking for feedback on
what people like this and what
additional data stores that are
interested in and then we also have some
interesting capability to mix relational
and non-relational persistence which i
think is going to be more of these
hybrid datastore solutions so we have
another talk a little later today a
couple hours from now called polyglot
persistence and in there they're gonna
deal with bringing together some of the
Mongo store relational store and
wrapping it all up in one facade with
multiple persistence units or what we
call composite persistence units talking
to these data stores and provide the JPA
program or a consistent API so here's
what it basically looks like now these
examples are taken off the eclipse link
wiki so I state how I want what style of
no sequel access and then within the
mappings I need to provide some
additional field information for how its
stored now and we have a lot of a lot of
leeway and where we're headed in this
space obviously with the ability to bind
in to and out of JSON JSON storage
databases might look a little different
to us again this is a this is not an
effort to standardize this is an effort
to engage and learn so if you're if
you're interested in a Java API that can
kind of bridge cross multiple data
sources we'd like you to try this out
and give us some feedback okay so just
to kind of wrap up where we are and kind
of where we're headed so eclipse link to
Oh which was the RI for J p220
came out in 2009 as an eclipse project
we tend to ship on the annual eclipse
release train so usually we're busy
coming into June we introduced J
upgraded to Jax b2 to the JPA fidelity
features that's how JP a entities work
better with Jax B and we added dynamic
JP a in two one which was the Eclipse
Helios release we extended our queries
we can embed more database functions we
can do treat as for casting within JP QL
statements some new batching operations
to give
more flexibility attribute group is
really great for defining partial entity
graphs how you load how you fetch merged
them we cut how to introduce our own oxm
mapping file and we did the same thing
we did for JP a with dynamic moxy so now
I can have a complete metadata driven
solution that does both JP a and the XML
JSON side 2/3 which shipped in 11
introduced our first 10 in isolation
multi-tenant with single table the
extensible entities external metadata is
the feature that will pull the
additional mapping information from
another source at run time being
composite persistence units dealing with
multiple data stores data partitioning
probably more commonly known as charting
being able to partition your data across
multiple tables to deal with some
scalability issues and then to for our
last one were to ship was the JSON
binding support we introduced our first
release of JP RS table pretend n't we
enhanced our schema generation to do
alter schema when you start looking at
all those extended attributes it became
clear that people who do want to
customize their database we're we've
always been able to drop tables and
create tables in a production
environment dropping a table and
creating a new table sounds nice but
losing all the data not so good so we
finally got around to alter schema where
we can add columns without having to
drop the whole database to do it so you
know lots of people you have their own
DBAs who do all their own schema
management but there's lots of smaller
shops who rely on the JPA persistence
provider to generate these scripts for
them or to do it directly on their
database and to for introduced that
initial know sequel so where we're
headed now obviously we've introduced
this rest interface we want to continue
to enhance that there's some great work
coming out in our our next release for
better handling relationships within
those rest objects and one of my new
projects is dealing with server-side
JavaScript so we have a talk this
afternoon looking at the new NASA horn
JavaScript engine that's coming in se 8
and this prototype node implementation
we have running on it and then in there
we have varying degrees of support for
JPA
within a JavaScript node application so
if you're interested in where we're
headed with that stuff I believe my boss
is at 5:30 today somewhere that's so my
four o'clock problem so that's that's
what we got how do I do one tell him
we're done so I ran out of time without
questions I'm happy to stay around and
ask questions I don't have anywhere to
be immediately I will be up at the Java
one demo grounds for most of the day if
you want to come by there walk through
one of these demos talk more in-depth
again we're always looking for feedback
and you guys are really in charge of
guiding us and what we need to do next
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>