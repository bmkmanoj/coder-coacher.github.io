<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Client/Server Applications with HTML5 and Java | Coder Coacher - Coaching Coders</title><meta content="Client/Server Applications with HTML5 and Java - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Client/Server Applications with HTML5 and Java</b></h2><h5 class="post__date">2013-01-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Y4YMY2ruUhw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm James Ward from Heroku so this talk
is going to be on client-server apps
with html5 and Java going to be some fun
code to to go through so first out off I
want to start about talking about like
why why why are we changing the
architecture for our web applications
again and I think there's really three
primary drivers that are causing us to
rethink how we build our web
applications the first one is
performance with traditional web
applications we have requests for every
UI interaction and this is burdensome on
the server but also creates a lot of
extra latency in as the user interacts
with an application so we can improve
improve performance on both the back end
and on the front end by switching to
more of a client-server architecture the
next one is faster development
iterations typically when we're building
a web application we're doing everything
on the server and that means that any
change that we make whether it's a
back-end change or a UI change all of
that has to go through usually a longer
compile cycle possibly a redeployment
cycle and so we can have pretty long
iterations usually in how long it takes
to to just test a simple part of a web
application so with with client server
the client-server style applications we
can actually build out the client and
the server independently of one another
and that allows a UI team to iterate on
the UI separate from the team that's
actually building out the backend doing
things like transactions and talking to
databases and and messaging and all that
kind of stuff so it allows us to split
out those two concerns and I think be a
lot more productive with how we build
our apps then the last one is that it
allows us to reuse code and services for
mobile web and possibly desktop
applications so you may be familiar with
PhoneGap PhoneGap allows you to take an
html5 application and package it as a
native application and run it on all
sorts of different mobile devices and so
when we build our application in this
client-server fashion then we can
actually take the client side of our
application and actually just
turn that into a mobile client and have
a lot of code reuse between that and the
web application so I think those are the
three main drivers but let's talk about
what what is this modern web application
thing I think there's really three
primary parts of this new architecture
for web applications and so the first
one is a stateless web tier what we've
seen is that is that we're taking our
back-end services we're exposing them
out through through HTTP and we're doing
this in a stateless way and there's a
few advantages to doing stateless I'll
talk about those in a little bit the
next one is modern web applications use
this client-server architecture the
interesting thing about kind of coming
back the pendulum swinging back to
client-server you know we were there
long ago with thick client applications
and we'd talk directly to a database
we're not going back to the two-tier
style system we still want to have this
this tier in the middle that's providing
security providing transactions
providing a place to aggregate things
providing a place to version api's so
we're not going back to to tier you can
do that if you want but but I do think
there's definitely still used for for
that middle tier it's just now we're
using that middle tier as the place to
serialize our data and add transactions
add security those sorts of things and
then the third one is transparent
real-time
is anybody here ever use Trello com they
may here use Google Docs okay so if
you've used Google Docs or Trello what
you've experienced is this this concept
where everything is just always in sync
when in our typical web applications we
always have a stale copy of the data on
the client and what we when you
experience Google Docs are especially
Trello which is more data oriented than
document ordinate oriented what you see
is you're like this is how the web
should work I shouldn't have to do
refresh I shouldn't have to wait for the
server for me to do some interaction for
me to get the latest data the server
should be able to contact the client and
say hey here's the latest copy of the
data because this user over here changed
it or here's a message that the server
wants to send you and it just feels much
more natural when you use Trello feels
like the way that web
applications should work so so I think
that's a huge part of what's changing in
the way that we build web applications
as well so we're going to drill down a
lot into the client-server architecture
and in this presentation mostly but I
did want to highlight that I think those
are really the three primary things that
make up this modern web architecture
real quick on stateless a few things to
point out about that server unoffending
the goal we don't want to replicate
replicate session or have sticky
sessions because that really inhibits us
from scaling horizontally and so so it's
much easier to take our session state
and put it into an external system if we
have session state session state is kind
of an artifact usually of having state
between requests but when our requests
are our when the UI is fully on the
client a lot of that state just moves
naturally to the client so and then the
other thing about about this is that
we're a lot of us are moving towards
continuous delivery we want to be able
to update our applications faster and it
turns out that doing sticky sessions and
having session State in the web tier is
actually a huge barrier to doing
continuous delivery so I won't go into a
lot of detail on that now but the other
last thing browser browser back forward
and reload just work when you build an
application at stateless architecture so
now let's dive into the actual
architecture here the client-server
architecture so it's really pretty
simple we take a back-end and we expose
rest services typically the data is
being serialized as JSON in both
directions but I'm not going to tell you
you have to use that you could of course
use XML or soap if you really want or
any other serialization technology so
we've got our restful services and
restful there there are certainly
different ways that you can adopt rest
you can be a real stickler for the the
way that you form URLs but the idea is
just to have some way to get to data
over HTTP right
and of course update data and that sort
of thing HTTP or HTTPS and then on top
of this you build a web client and
possibly mobile clients or
they're clients and the interaction
between these two is just data so the
only thing moving back and forth between
these two things is data the UI is
running fully on the client and so when
we're in the the context of a web
browser or a PhoneGap application that
client is built with HTML Javascript CSS
that sort of thing
so the the thing I'm going to touch on
at the end which I think is really
exciting about this architecture is that
once we've taken our whole client side
and we've turned it primarily into
static assets that run on the client
side now we can do some really
interesting things to take advantage of
CDNs content delivery networks to really
speed up the the ability for users to
load the applications and run them so
we'll talk about that towards the end so
let's let's talk a little bit about
html5 html5 is kind of a big buzzword
right now this is the definition from
from Wikipedia mine is just a little bit
simpler html5 to me is the browser is
now an application platform so there's a
lot of different parts of html5 a lot of
different specs involved in html5
there's things like new video tags and
there's new HTML tags that you can use
there's a lot of new API s for handling
things like offline and drag and drop
web storage all sorts of great things
like like once we get all this stuff in
every browser it'll it'll make a huge
difference for how we build our
applications and the capabilities that
we can take advantage of css3 is also
there
unless you're building a mobile
application with PhoneGap you probably
actually won't be using a whole lot of
these api's there's ways to like shim
support into older browsers to emulate
some of these API s and you could go
that route certainly but I think for
most people until the browser's until
most people have adopted browsers that
have these capabilities in them we're
still kind of stuck with with doing
things doing some things in the old way
but I want I do want to point out one of
the primary things that's really
enabling us to use the browser as an
application platform is actually not
part of the html5 spec at all
it's that we need a really fast engine
to execute code on the client and that
code that browsers execute is JavaScript
and the fact that JavaScript engines
have gotten faster and faster and faster
that's really what's opened up the
opportunity for us to move the
client-side over to the browser actually
and actually run it on the client but
there's no spec as far as I know
this says that JavaScript must be this
fast right it's just that the browser's
have reacted to demand and so things
like v8 and chrome and all the other
newer JavaScript engines have just made
it faster which really opens up the
opportunity for us to take advantage of
it so we we tend to lump a bunch of
things under html5 some of which
actually have nothing to do with
technically the spec but to me html5 you
can refer to it as the the set of
specifications or you can refer to it
for me what it really is is that it's
really about building modern web
applications ok so the interesting thing
about this the space right now is head
it's changing very quickly it's evolving
very rapidly and what we're what we're
actually doing in this the client-side
space in JavaScript and on the website
is that we're rebuilding a lot of what
we did on the Java side like like 15
years ago we're rebuilding that stuff
now on the client side so you see
there's like now this like boom of MVC
frameworks written in JavaScript right
and so we're and there's tons of them
just like you know back in the day there
was tons of Java MVC frameworks so we're
rebuilding a lot of this stuff there's
there's tons of client-side templating
libraries written in JavaScript so we're
taking a lot of our tool sets that we'd
built to run on the server and now we're
rewriting them in JavaScript so I want
to go through some of these tools just
to give you an idea a little bit for the
landscape and the things that that you
should be learning and looking into
before I do this I think that as Java
developers we're more and more going to
have to start learning how to write
JavaScript and have learning how to use
these libraries I think that the amount
of work and time that we're spending
writing actual back-end code these days
is
is diminishing greatly it's gotten
really easy you know things like spring
and other technologies we just don't
have a lot of the complexity there
anymore so so now a lot of our work is
actually transitioning to the client
side and as Java developers I think we
have to be learning the client-side
JavaScript is not as horrible as you may
think
CoffeeScript makes it a whole lot better
we'll talk about that but but so you're
probably here today because you want to
learn about this stuff so great okay so
let's go through some of these tools so
jQuery if you're not familiar with it
like buy a book learn it like as soon as
possible jQuery is is like the standard
library in JavaScript for working with
the browser Dom so the browser Dom all
that it is it's the tree of things that
are actually being displayed on a web
page so so jQuery is a great library for
for manipulating the Dom for making
Network requests using Ajax it's really
kind of the Swiss Army knife library for
the browser and I think it's really the
standard library now for the browser
people aren't using the the browser
specific API s they're using jQuery
which does a great job of wrapping all
the different ways that the browser's
implement the the different API is for
doing stuff so so you have to learn
jQuery it's it would be the foundation
of of most stuff that you will do then
the next one is Twitter bootstrap
Twitter bootstrap has has really become
quickly become a great library for
helping developers build decent-looking
you eyes in the web I used to be at
Adobe and worked on a product called
flex and the thing I loved about flex
was that I is a developer with no UI
skills could create something pretty
decent looking and of course that ran in
flash so it had its downsides but
Twitter bootstrap is now becoming that
thing for standard web browser
applications it's certainly not as
evolved as as flex is yet but it is it
is maturing very rapidly so check out
Twitter bootstrap there's a few
different parts of Twitter bootstrap
I'll show some code in a little bit but
mostly bootstrap is a CSS library that
will that makes its styles Dom elements
and makes them look good
and then they also have some jQuery
plugins that also will do more like
functional component things like like
type-ahead searches and combo box and
like combo boxes and that sort of thing
so check out bootstrap so CoffeeScript
is kind of the this new cool thing that
all the the hipster people are using
these days and it CoffeeScript is is
really just a layer on top of JavaScript
or a language technically a language
that compiles into JavaScript so instead
of writing raw JavaScript you can write
CoffeeScript and you're the syntax is a
bit nicer and they take some of the
weird things about javascript and they
make them better and so CoffeeScript is
great the the downside to CoffeeScript
is is a couple things one if you're
writing CoffeeScript you should really
still understand JavaScript because
today if when you're CoffeeScript gets
turned into JavaScript that's actually
what's running in the browser and if you
need to go in and debug your application
you're debugging the JavaScript that was
generated from the CoffeeScript and so
you have to have be able to build a
mental model of how the code is
transforming from CoffeeScript to
JavaScript to be able to debug your
problem
there are browsers are working on a way
to deal with this and make this better
but for now if you're writing
CoffeeScript you really do have to
understand what's going on and how it's
transforming into JavaScript essentially
CoffeeScript just becomes a faster way
to write JavaScript for you then the
next one is the asset compilers this is
something that I think is a really
exciting area of development right now
what's happening is that now that we're
doing so much stuff on the client-side
there's actually a huge lack of tooling
on the client-side and so when we go
write our CoffeeScript and we go write
our JavaScript and go write our less
less is like is like CoffeeScript for
CSS so we go write this code we have
very little support for for writing that
code for testing that code for getting
compile errors in that code and so what
what the asset compilers do is they'll
actually integrate the experience of
writing the client side of the
application into the experience of
of writing the server-side application
so play - and rails and Grails they have
these asset compilers that actually will
when they compile the server-side code
it will also compile the client-side
code so you may be thinking javascript
isn't really compiled there is a Google
closure JavaScript compiler it's not
really a compiler what it really does is
some basic basic checking syntax
checking on your JavaScript the
CoffeeScript is compiled so you will see
compilers but this just helps you be
more efficient as you're writing the
client side of your application so that
you are you don't have to switch your
workflow to something else if you're if
you've heard of nodejs
no GS is a JavaScript based server kind
of new new and upcoming exciting thing I
personally I want to use the JVM on the
back end so I've played a little bit no
GS but for me I'm mostly sticking on on
the JVM technologies but no GS has this
the same experience where where they've
really integrated the client-side
development and the server-side
development but then they run in on just
in distinctly separate places right but
it still doesn't mean that you as a
developer have to have that that
fragmented development experience so so
check out stuff with asset compilers be
really helpful so as far as MVC
frameworks really these are very similar
to to the MVC frameworks you're familiar
with on the Java side they they usually
will have some connection to to the
templating languages which we'll talk
about in a minute but the the most
popular one the one that really seems
like it's getting the most traction
right now and most interest is called
backbone so if you really want to dive
into this area you know first learn
jQuery and then probably the next thing
you're going to want to learn is
backbone but I've you know I don't have
a whole lot of experience with with a
lot of the MVC frameworks so I think my
recommendation in terms of the MVC
frameworks and the templating language
templating libraries is try a bunch of
them and see which one fits best with
your way of thinking in the way you want
to write code because they all they all
have differences they all are kind of
created out of a different mindset
it so try them out so you'll see which
one works best for you
it may not be backbone and that's fine
angular actually is one that that fits
best with my mental model of how I am
used to write in my client-side
applications but but try amount see what
works for you and there are a ton out
there so there's also some really good
blog posts and articles one from
LinkedIn where they go through a bunch
of the different MVC frameworks and kind
of compare them head-to-head so if you
search around you'll be able to find
these head-to-head comparisons that go
into a lot of detail on the differences
and a lot of code examples to show you
how they're different but but I would
certainly recommend try them out
yourself see which one fits best with
with the way you want to work and then
for client side templating you know just
like on the server side you know we have
JSP and all sorts of other templating
languages so we're now recreating the
templating stuff to run on the client
side and there's lots of different
options again here mustache dust and
tons and tons of others so so again I'd
recommend try a bunch out see which one
works best for you okay so that's kind
of a quick overview of the landscape of
the the tools it's all changing very
rapidly if we come and do this talk
again two years from now this slide will
probably be completely different with a
whole new list of technologies it's it's
changing that quickly
the hard thing about being in an
enterprise right now is deciding like
which one of these are we going to
choose because we're probably gonna be
using it for a long time so so I don't
have a good answer to that I think we're
kind of in this unfortunate period where
there's a lot of turmoil and it's going
to take a little while for the dust to
settle and and some real kind of winners
or best technologies to emerge okay so
let's talk a little about rest so the
idea with rest is that we we get very
close to the HTTP protocol what we do is
we map HTTP verbs and paths to specific
resources and so for instance we say
alright if I make a get request to slice
widget widget then we're going to get
all the widgets if I make a get request
to slash widget slash one I'm going to
get the widget with an ID of one if I
make a post request to slash widget I'm
going to create a new widget and I will
need to pass
via Jason or some other way my data for
the widget n if I do a put slash widget
slash one I'm going to update my widget
I actually use HTTP delete on slash
widget slash one I'm going to delete
that widget okay so that's I'm not going
to go into a lot of detail we'll see
some code for the stuff in it in a
little bit Jason if you're not familiar
with it the JavaScript object notation
and really what it is it's just a way to
serialize data in a very very simple
form that is native to the browser which
is Jason so it's pretty simple format
key value pairs basically a very limited
type system in in JavaScript and Jason
so in quick little snippets on jQuery so
you can get an idea for it jQuery what
it really is is a bunch of functions
JavaScript functions that you can use
and the way that you call those
functions is kind of funky the first
time I saw the dollar sign I'm like like
what is that all that it really is is an
object essentially that contains a bunch
of functions so when I say dollar sign
dot get I'm just calling the get
function in the jQuery library and then
I and then I can pass parameters to that
function I can set callback handlers
that sort of thing
the CoffeeScript for that looks very
similar a little bit neater they use
CoffeeScript uses significant spacing
like Python does and has you know it
cuts down on a lot of the boilerplate
code that you normally have to write so
let's see a real live example here I
built this little application called
jax-rs bars and all the code is on my
github and I want to just walk through
this application and all the pieces of
it just to give you an idea for what
this what an application built in this
new style architecture looks like and
it's it's pretty simple but there there
are a few pieces so first before we do
that let's let's just go check it out so
I'm going to start it up here so go to
localhost 8080 so this is my little
application it's just a way to create a
list of my favorite bars I guess and so
I can come in here and add in a new one
Joe's bar right so very very simple
application but this is there's lots of
different words for for this style of
application it's a single page
application or you could put a number of
different words on it but it's not doing
any refreshes right when I do when I do
a request to add a new one it's doing it
via Ajax underneath the covers for the
so there's no page refresh when I
there's no data coming from the server
that is part of markup it's just pure
data coming from the server
so let's actually take a quick look at
Firebug and see what actually is is
getting loaded here so you can see
what's going on so first thing when I
when I load the page page I just
reloaded it we make a request to slash
and that of course brings in just the
basic HTML page we'll see that in a
second I'm also loading in bootstrap and
jQuery I'll talk about that in a little
bit and then I have really the the whole
kind of core of my application all the
functionality that happens on the client
side I have in a JavaScript file we'll
see the code for that in a second but
know at this point at up until here no
data has actually come down to the
client it's all just all just the whole
client side so JavaScript HTML and CSS
and then I make this request for slash
API slash bars and that's what actually
gets me my list of bars as Jason and we
can drill in here and actually go see
let's go check out here's my Jason
objects that came back right and then I
just iterate through and display those
on the page ok so that's my simple
little app let's go walk through the
different pieces of this and I've made
some technology choices here just just
to show how you can do it there are many
many ways to build out this type of
application so I'm going to walk through
how I built it don't get too hung up on
on some of the choices here so one of
the choices was I decided to use grizzly
and Jersey to do a jack Sarris back-end
for this application so so the whole
back-end for the application there's
there's actually no container in this
application all I'm doing is I'm
starting up a Grizzly server very very
simple and and then setting up my
my jax-rs services setting those up
through Jersey and so that's all my
dependencies here oh yeah and then I'm
also using MongoDB for for doing
persistence and so I'm using the Mongo
Jackson mapper okay so very simple there
and then what I need to do is because
I'm not using a container I need to have
a way to kind of bootstrap my
application start listening for HTTP
requests set up my connection to MongoDB
so I just walk through through this just
so you can get an idea for for what it
looks like to to go container list I
think the the java community is is an
anomaly in this space of how we deploy
our applications I think we're the only
ones that actually like deploy into a
container most of the rest of the world
the the thing that's doing the HTTP
handling is actually part of the
application there's not this separation
between the thing that's running the
application in the application itself in
the rest of the world the rest of the
programming world everything is one
application the HTTP handling is just a
part of of the application so that's how
I'm doing it here just to show you a
different way to do things you don't
have to do it this way obviously but so
first thing is I'm setting up my Mongo
database connection and then let's get
down to the the part where I'm actually
setting up the server so so I'm creating
this new HTTP server I'm telling it
where to find my static assets I'm
setting up this this Jason Jackson
module and what this is is this was is
what's actually going to provide the
support for jax-rs and handling
connections that I sanding the HTTP
connections to a jax-rs resource okay
and then I'm telling Jersey here alright
let's let's create a new a new container
up yep and then add a handler here so as
we add a handler and we start the server
so very simple to do it that way again
you don't have to do it that one okay so
that's that's how I bootstrap my server
then I have my my little entity here
this is my my bar entity has an ID and
then it
as just a single property called name
I'm just doing public properties if you
want to do getters and setters totally
up to you this is just Jackson is is
dealing with this the the Jackson Mungo
mapper is dealing with this object so so
yeah so you can do it however you want
okay so now let's look at the actual
jax-rs stuff so what I've created is
this bar resource and I actually told
the the Jersey the thing doing the
jax-rs stuff I said just search my class
path and if you find a class that's
annotated with app path then it's going
to set it up to handle connections and
let me go back and show you the part
where this this actually gets mapped so
this is where I'm actually saying if a
request comes in for slash API slash
something that's going to go off to the
Jersey library that's going to be
handled by my jax-rs stuff so in bar
resource when I say app path slash
that's going to just handle any request
to slash API in in the server so then I
have a little helper function to get me
my Jackson DB collection to talk to
Mongo and now this is like the real
jax-rs stuff so so first I have a public
method called add bar and you'll notice
that there's in this method this is like
very pure you know I'm just talking like
value objects I'm not actually talking
protocol at this point right there's no
like HTTP request HTTP response type of
stuff it's it's a very pure just about
the functionality right and then Jack
Jersey is actually going to figure out
how to serialize into these objects
serialized from an object out to Jason
so the we have to tell Jersey some
information about how it does that so we
say alright first we need to know the
path for this thing so if if the path is
slash API slash bar then it's going to
be handled by it by this function but
then I'm also saying at post so I'm
saying only do that if this is a post
request right and then I'm also telling
Jersey I'm saying all right this this
consumes Jason so the user has to send
JSON content to this this method if they
send anything else it's going to return
an error right and then it also produces
Jason so the response coming back out is
going
to be Jason and that's all I have to do
Jersey takes care of all the
serialization from Jason into a bar and
all of the serialization from the bar
that is returned back out to Jason so so
Jersey just does all that for me so in
this case I'm just inserting the bar
into the database and returning the the
saved object very simple and then the
next one is is very similar I've got a
path for bars so now if there's a
request to slash API slash bars and it's
a get request then I'm going to produce
some JSON and all I do is I go get all
my objects out of the MongoDB database
and return the list of bars and that's
it okay so that's that's my my simple
rest client we can actually test this
directly in the browser too if we just
go to slash API slash bars then there we
see all of my Jason coming out of
MongoDB okay so very simple okay so
that's my my jax-rs stuff that's my
whole server side that's the there is
nothing else running on my server you
you may have noticed when I started up
my server it took like less than a
second like super lightweight just start
up my server the IntelliJ or you can use
J rebel will do hot swapping for you so
so if you're making changes to the
server side it kind of hot-swap
automatically for you those classes but
but that's my entire server side really
simple really lightweight okay in there
again there are lots of different ways
you can build this stuff out spring MVC
has great support for Jason and restful
style URLs and that stuff as well play
framework all sorts of frameworks you
can do this kind of thing in so lots of
different options for what you do there
okay so let's take a look at the client
side now so this is the client side so a
few things I want to walk through in
here first the the first thing I'm doing
is in this HTML page there's there's
again no data right this is this is just
about the UI that's it and so the first
thing is I load in the bootstrap CSS
library so this I've just copied let me
show you the structure here I guess it
should have showed the structure a
little bit but
your source mein Java and then my
package and then I have all my Java code
for the server now their source main web
app that's where we're at now
and there's index.html and then my
bootstrap directory which contains all
of the Twitter bootstrap stuff
there's index CAS we'll look at in a
minute and jQuery that's it that's my
whole project so pretty simple okay but
let's go let's go dive back into this so
I'm loading in the bootstrap CSS library
I'm loading in the jQuery library and
I'm loading in index J s so so that's it
I load all the scripts in I said
overwrite a little style here for for
bootstrap and then I'm using a few divs
so with bootstrap this is how we kind of
style our components we create divs or
other other components on the page and
then we set the class to tell it what it
should look like so in this case I have
a div that's a navbar nav inverse and
nav fix top and then what that does is
that creates this this big black line up
here and then inside of that I've got a
navbar inner and a container and then a
link up there that with a class brand so
very simple with with bootstrap to make
it look fairly decent I mean this is not
beautiful or anything but it's again
only like like if you learn to code
there to get that and then I have this
other div I've given this an ID of main
and a class container and container is
just another thing you can use in
bootstrap which just kind of like polls
pulls it in and centers centers the
content so it's not you know stuck to
the left edge or something so so that's
just my basic page pretty simple were
there again no data no no logic even so
the logic now is actually in this index
J s so I could have written this with
CoffeeScript
but decided just to stick with with
JavaScript for now so in this one the
first line there the dollar sign paren
function what that's doing is that's
saying all right when the page is ready
I'm so I'm giving jQuery a callback
function I'm saying when the page is
ready run this code so when the page is
ready it's going to find
and this that main element on the page
so if we look back in the index.html
you'll see that there's a div id main
and the way in jQuery that we find that
object on the page we can look through
the Dom and find it is to do dollar sign
and then say I want to find pound main
that we'll find by ID you can do all
sorts of different complex selectors to
find stuff on in the Dom with jQuery but
that's just an ID selector so we get
that and then I'm actually going to add
dynamically add some UI to this page so
there's a few things that I need on this
page one I need I need a thing that says
hey here's your bars and I need a place
to hold my bar so I add those to the
page so I just create those and append
them onto that main element there and
then I also need to wait to add new bar
so I append on an input and a button and
this is just the the simplest way to do
this what I should be doing the way that
I should be doing this which would take
a few more steps is to use a client-side
templating language and put this stuff
put this UI stuff into a template and
then I would say render this template
and that would happen on the client side
and then I'd get the UI rendered but I
wanted to start out with something very
very simple just the very basics of how
this works once I have created a place
to display my bars I called load bars so
that's just a function down here what
that does is it says alright let's make
an AJAX request to slash API slash bars
so Ajax is not going to refresh the page
and then I'm setting the content type
which I don't think I even I do need to
set the content type here and then I
have a success handler so all this stuff
all the the Ajax functions are
asynchronous or can be asynchronous and
so I'll get a call back when the
responses come back and it will have
already deserialized the JSON into
objects so this data here is actually an
array of my bar objects so what I'm
going to do is I'm going to just remove
everything out of the the current ul
that's kind of a brute force way to do
it but then I'm going to iterate through
each of my bars that I got back and I'm
just going to append each of them onto
that bars ul
so that's it that's how that's how this
page actually renders these elements
here make the Ajax request we get the
JSON back deserialize the JSON iterate
through each item and add it to the the
page add it to the UL okay again many
other ways to do this with client-side
templating languages but I wanted to
start with the basics okay so now let's
scroll back up so so then I've got my
way to add new bars and I'm setting up
an event listener saying alright when
somebody clicks the submit button call
that this add bar function or if
somebody hits enter in in that form
input also call add bar okay so then add
bar it is also doing an ajax request in
this case it's it's doing that to slash
API slash bar the type of request is a
post and the data type is jason and then
what I need to do is assemble a string
of the data that's needed and so so
what's happening is Jersey is going to
automatically map to that bar object I
don't want to give it an ID that the ID
is going to come from the database so
all I need to send is a name so I
specify the name parameter is the the
name in this object and then I set the
value equal to whatever the the value of
that bar thing is so if we look back
here bar is that input field so I'm just
pulling out the value of that input
field string of find JSON string of
Finance so that creates my my JSON
string and then on success I'm calling
load bars which makes another Ajax
request to get the latest data don't
have to do it that way but easy way to
refresh the list okay so that's my whole
application all runs fully on the client
side so that's the the basics let me see
if I missed anything here before I leave
this code is anyone have any questions
about how this is working
yeah go ahead
what's the alternative
dojo okay dojo is uh it's it's more than
jQuery jQuery is just like this
low-level library dojo is is a full-on
like client-side UI library that's
that's a great choice if you want a full
library that can do ajax can do
templating and can do components it can
do a lot
tons of functionality in dojo so for
enterprises that may be a great choice
there's also like ext Jas is one of
these like full kind of end-to-end
client-side frameworks
Baudin is another one so so lots of
different options if you want to kind of
go with a with one package that has kind
of everything you need so you can go
that route there are there are
trade-offs in both ways you can kind of
piece mail stuff with jQuery and
bootstrap and a bunch of other stuff or
you can pick up pick something that has
everything you need so totally up to you
which which way you go on that yeah
question yeah I'll talk about that in a
little bit yeah good question I'll get
there okay
any questions about the code
specifically how it works okay okay
we'll keep going here so covered all
that okay so this again is a very very
simple example I want to talk about a
few things that that would make this a
lot more real-world first one is
authentication so authentication is
something that most of us probably have
to do in our applications there's a few
things I want to point out about
authentication we can certainly do
authentication in this type of
architecture
but we need to or we should do a few
things along with that first we should
remain stateless so what that means is
that we need to keep our rest services
stateless we don't want state between
rest requests that's that's a definitely
an anti-pattern with rest so to do that
we may have to have some way of holding
some state but we're not going to put
that in memory because we want to be
able to go hoarders
with scaling and so if we need state
between requests maybe we'll put that
into a memcache server external to our
application and we'll just have a simple
little cache that we can use and we'll
use some kind of token to say alright
this is the user but now where do we
where do we put that token we don't want
to put it in a cookie so cookies for VAR
s services are are not a good way to go
and there's a few reasons for that one
of them is security when when the
browser makes a request to an endpoint
it automatically sends the cookies for
that URL and this is great in most cases
but in some cases by doing this
automatically you're actually opening up
the potential for for cross-site request
forgery attacks and so to avoid that we
just say all right let's let's just not
even use cookies for this method instead
we could use HTTP headers we could have
one of the parameters that we take in
our rest service be a token but this is
functionality that we're going to have
to manage on our own right this is not
something that the container is usually
providing for us so we're going to have
to implement this this aspect of our
application a bit on our own
there are evolving libraries that help
with this there are like modules for
like Grails and play framework that help
with this but if you're you may have to
do some extra work here to do this the
right way but just keep in mind don't
use cookies because that doesn't fit
with rest and opens up the potential for
cross-site request forgery and remain
stateless and your rest services okay
the next thing that we could do to go
further with this is let me go back and
show you something that I don't really
like so much in this so in my in my
source directory for my client-side my
source main web app directory I've put
bootstrap in there I just downloaded the
bootstrap zip file and extracted that
there and I downloaded jQuery and put
that there this is the typical way that
we bring in our client-side libraries in
a web application I think we need to do
this better so I've started working on a
little project called web jar
and the idea with web drives is that I
take client-side libraries like
bootstrap and jQuery and I just shove
them into a jar file and right now I'm
working on getting these jar files into
maven central there's a non maven
central repository you can use today but
what this allows us to do is now specify
our client-side dependencies just like
we specify our server-side dependencies
so we have one place where all of our
dependencies go and this allows us to to
see real easily what versions were using
it allows us to handle transitive
dependencies so bootstrap depends on
jQuery so that should be something that
I don't have to think about bringing in
if I depend on bootstrap it should bring
in the transitive dependency for me so
it's it's a kind of experimental project
at this point if you're interested send
me an email but or check out web jars
github comm is where the the current
information about it is but but I think
that we could do better than this I
think this is not the best way to manage
our client-side dependencies so so check
out web drives if you're interested in
that oh the other thing like bootstrap
there's no version number in here too
right so there's a few a few side
effects are not having version numbers
in any of this stuff one side effect is
that I have no idea what version of
bootstrap I'm using maybe it says in one
of those files but it's really not clear
to me the other one is that with static
assets we want to be able to take our
static assets and do what's called far
future expires which says like alright
when you when the browser requests this
thing tell the browser that it should
hold on to that cache that static
content forever basically
and that I the the server is never going
to have a new version of that that's
what we want to do with all of our
static content but in order to do that
we need to have version numbers in the
files or directories some somewhere in
the request path there needs to be a
version number or possibly like a an e
tag or something that is is unique so
that when we when our application says
we're going to use this new version then
that's referenced somewhere and so then
the browser pulls in the new version so
so that's something that web drivers
will help us with as well
ok that's web jars so next up API
versioning my API that I showed
do my very simple jax-rs API if I need
to make a change to that API then I
could potentially break third-party
clients that are consuming that API so
the right way to deal with this is to
version our API version API is a huge
pain there are some frameworks emerging
that help us do it
I think thrift is one from Apache but
it's hard anytime you need to version
API is it's it's going to be a challenge
so just be aware of that if you control
all of the clients then you you may not
have to worry about this it's when your
people when you expose an API for
consumption from a third party that's
when you would want to start thinking
about versioning your API s ok and then
the last one we talk about is the slow
client fallback strategy so the client
server architecture I've just presented
I think that's like that's where we want
to be right I think we're on the path to
get there but and people have tried to
implement this today like Twitter tried
to implement this on their website and
what they realized is that for most of
us in this room we have pretty fast
computers we have modern browsers with
fast JavaScript engines but there's a
whole bunch of other people out there
somewhere in the world who don't have
fast computers or fast JavaScript
engines and so the problem with that is
once we do everything on the client we
really need that client to be fast for
the users to have a good experience and
depending on who your users are that may
not be the case
and so in that case we may have to have
a strategy that allows us to fall back
to server-side rendering when we need to
do that and so there some of the
client-side templating libraries also
have corresponding Java libraries that
you can do exactly the strategy with so
you can say you can have some way to
determine if the template needs to be
pre-rendered on the server and then in
your Ajax request you'll send down the
rendered content instead of sending down
the data so just be aware if your
clients are on slower computers or some
of your clients around solar computers
you may have to for the next few years
come up with some way to have a fallback
strategy and it's really just about
performance okay
so talk about web dryers so I want to
take this application I just built and
deploy it on the cloud and then we'll
talk about CDN stuff so I work for
Heroku and we provide a platform that
allows you to deploy Java and Scala and
nodejs and Ruby and all sorts of things
on the cloud so I'm going to just show
you real quickly how we deployed this
application on the cloud so first
there's one thing in here that I need to
do that's that's Heroku specific but
it's just one line in one file what we
need to do is say all right for the web
process running on Heroku we need to run
this command so this is how we startup
that that grizzly HTTP server I could do
that
that same command locally to start up my
server this is assuming I've run maven
package and I have my dependencies and
everything there but so this is the way
that the Heroku will know how to start
up that server so once I have that the
way that that are one of the ways to
deploy an application on Heroku
is using a git repository you can also
deploy war files but I'm going to show
you the git wakes it's pretty cool so
I'm going to create a new git repository
and I'm going to add some files to my
git repository if I see those files this
is just my source files so I've got my
pom dot XML for the maven build my
server files and then all my client-side
files and let's commit those so I'll
commit them in my git repository and now
that I've got those files committed into
my git repository I want to tell her
Roku all right
create a new application for me on the
cloud or provision a new application so
there's a bunch of different ways to do
this one way is through the command line
we have a Heroku command line and I've
already done Heroku login which so for
this command knows who I am so I can
just say Heroku create so this will go
off to Heroku and create a new
application it will assign a random name
to me so I got comm planes 2177
so if you go to column - planes - 2177
dot zero crapcom let's try it now see
what's there I haven't given it my
application yet so this is just going to
be the basic the default one so that's
that's just the default page so I've got
my my application created it has the
HTTP endpoint
it has a get end point the get end point
is how we upload files to Heroku so I'm
going to use git and I'm going to say
git push Heroku master
so this says take my git repository push
it to the remote named Heroku which
corresponds to this get URL here and
then push the master branch so this will
upload my code then Heroku will
recognize hey this looks like a maven
project it's going to run the maven
build on the project which will pull
down all the dependencies and then it
will deploy the application out onto the
cloud so so you'll see that that upload
was just a hundred and thirteen K so
really small upload and then now running
on on Heroku it's going to do the build
pull down in the appendices and launch
the app so that'll take a minute to
launch to build and launch first time we
run it we have to download quite a few
dependencies but it's faster than
creating a war file and uploading a war
so that's why I chose that way okay so
while that's running let's talk a little
bit about the CDN stuff so in a typical
application typical web application what
we usually have is most of our content
is dynamic content most of our
application is dynamic so if we're doing
server-side templating most of our pages
they're dynamic right they change based
on the data that's in the page and then
a small portion of our application is
actual static content and usually we'll
just serve everything from one location
so for so if I if my application lives
on the East Coast
then maybe it's 200 milliseconds per
request to get either dynamic or static
content right from the west coast maybe
it's one second cuz we have you know the
speed of light and unfortunately it
doesn't go faster so takes a little bit
longer to get from the west coast to the
east coast so when we go into this
modern web architecture things change
and it opens up a really new exciting
opportunity for us now our dynamic
content of our application is a lot
smaller portion of our overall
application most of it is is just these
Jason small JSON services right small
JSON objects and so maybe we still leave
that on on the East Coast right and so
for the few number of requests for the
small amount of data that's going to go
to the
East Coast it's going to be fast on the
East Coast and slower from the West
Coast or somewhere else right but now
because we built our whole client-side
in static static client-side languages
or static client-side technologies HTML
CSS JavaScript images whatever now we
can use a CDN and then we can actually
serve our most of our content from a CDN
so if you're not familiar with the CDN
what it is is it takes static content
and it puts copies of it all around the
world and then when somebody makes a
request to get the static content the
CDN directs the person to the server
that's closest to them we're talking
like usually like eight hops so eight
HAP's if you're familiar with doing
trace routes it hops is very good right
and so it's going to be very
geographically close to the consumer of
the content so we put this content
everywhere and then that means that most
of our requests are going to the CDN and
are happening much more quickly than
before so let me show you a little
example of exactly this let's check back
on our build before we do that okay so
my build finished oh and I got to do one
thing this application uses MongoDB so
Heroku has this concept of add-ons so
anytime you want to add some other
service to your application whether it's
a database or monitoring or messaging
whatever we do it throughout on so I'm
going to say
Heroku add-ons call an ad and I'm going
to add the Mongo lab service to my
application so that'll take a second to
add mongolab and then restart my server
but then then we should be good to go so
let's go back here go check out there it
was right there let's just hit reload so
it might take a second for it okay looks
like it's good so let's try it out this
is the Jax bars application running on
the cloud so there we go
cool so everything's working okay so I
did basically that exact those exact
steps to deploy this application and I
deployed it on a website called jax-rs
bar zero capcom this is like the same
same application go ahead you can go
conference network sometimes
funky okay so unstyled though this
version I didn't put in Twitter
bootstrap so it's kind of ugly
this is jax-rs bar zero crap com so when
I load this what what I've also done is
I've told the application that for the
static content in the application
instead of pulling that from the jax-rs
bar zero crapcom site go to the CDN and
get it from the CDN so if we actually
look at Firebug let's pull that up and
go back to the net tab and reload so
when I load this page we'll see that the
first request for the index page goes to
jax-rs bar zero capcom to get just the
index page remember the index page
doesn't have a whole lot in it all it
does is it loads the stylesheet the the
java scripts but all of that extra stuff
for the client-side is all static assets
and all of that now it's coming from the
CDN so if we look at this next request
for jQuery you'll see that the URL for
this is some big weird thing dot
CloudFront dotnet so I'm using Amazon
CloudFront and I've told cloud front
it's very simple to do this is a really
cool thing that cloud front can do I'm
telling you I'm pointing it to that
jQuery Minjae s but I've told cloud
front that where it gets that jQuery
from and where it gets the next one the
index JSE is pulling from the same CDN
where it gets that content from is
jax-rs bar 0 crapcom so the first time
somebody makes a request for index j s
club front is going to say hey I don't
have that content on the CDN it's going
to make a request to my source server my
origin server to get that javascript
file and then as soon as it gets it it's
then going to scatter it all across the
globe right so now no matter where
somebody makes this request for index GS
from its going to load very quickly
you'll see that that loaded in 29
well the request happened in 29
milliseconds it was cached because I
have my headers all set correctly but
still very fast to make this request so
this is what we want to get to right we
don't want to have to go through the
hassle of having different deployment
procedures for how we deploy our
application this is why a lot of us
haven't used
in the past because typically they
involve doing a different deployment
procedure to deploy your static content
but most of the the modern CDNs now
support this concept of an Origin server
where all you put everything in one
application this allows you to test
locally allows you to do development
much more easily and then you just say
all right fetch the content from the CDN
CDN says all right if I don't have the
content I'm going back to the origin to
get it so I think this is the the future
of how we deliver our static content and
the great thing is we can do this with
our whole entire client-side so
everything coming from the client comes
from the CDN or everything coming for
the client UI comes from the CDN so then
the next request here is for slash bars
so to get back to your question earlier
because my index page was on jax-rs bar
0 capcom I can make the scripts that I
have on the page can make requests back
to that domain without having to deal
with cross domain issues so there is a
way now in modern browsers it's called
cores to be able to do cross-domain
requests you could also do this in flash
but we now have a way to do it but only
in modern browsers unless we have like a
flash failover or something like that
dojo has that actually has a failover to
flash for doing across them in request
but in most cases cross-domain requests
are pretty challenging so instead of
dealing with cross-domain requests this
is a very simple approach right I just
have all of my content all my static
content loaded into the page the context
of the page is is where my services are
so I can of course make requests back to
there to get my data ok that's a very
simple approach to how we can leverage a
CDN ok one other thing I should point
out is that something that we that we'll
often do when we're building these
single page applications is we still
want to have meaningful URLs right and
so there's a new html5 API it's a
location API it allows us to on the
client side change the URL while the
user is navigating
so that the URL is changing but we're
not actually refreshing the page and
that allows us to still give the user a
bookmarkable URL
we're not giving that up by going to a
single page application I have some I
think I have a blog post on on that
somewhere but email if you need more
information on that okay real quick
transparent real-time a few things to
look into for transparent real-time most
of the modern web frameworks are now
building this this into the framework so
like play framework does this really
it's about clean keeping the client
state in sync and doing real-time
notifications atmosphere is a great
library
what atmosphere does is pretty cool you
plug-in atmosphere and it figures out
what the server capabilities are does
the server have WebSocket capabilities
great then we're going to try to use
WebSockets it also has a JavaScript
library that figures out what the
client-side capabilities are so if the
client can do WebSockets great and the
server can do WebSockets we're going to
do WebSockets if the client doesn't have
WebSockets
then we're going to failover to like
long polling comet style and so amis
fear is great there are others out there
that do similar things but so if you're
looking at a real-time lots of different
options so check them out ok we have a
couple minutes left maybe one minute
left so any questions about anything
yeah good
yeah so the question is how does the
client know that my JavaScript files
have changed so you need to make sure
that you're either versioning those
files in my case I didn't burn the file
that was probably a bad idea actually
maybe version that or some frameworks
like Grails will automatically put a
version into the URL for you that would
be a great approach or you put lower
lower cache expiry numbers in your
headers you say like maybe only cache
this for up to a day and you just put
that in an HTTP header so good question
I'm sorry I'm out of time I'll be
outside if you have other questions but
thanks for coming up that was useful for
you Thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>