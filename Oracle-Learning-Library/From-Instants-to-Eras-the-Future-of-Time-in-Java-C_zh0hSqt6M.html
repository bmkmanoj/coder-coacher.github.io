<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>From Instants to Eras, the Future of Time in Java | Coder Coacher - Coaching Coders</title><meta content="From Instants to Eras, the Future of Time in Java - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>From Instants to Eras, the Future of Time in Java</b></h2><h5 class="post__date">2013-02-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/C_zh0hSqt6M" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay there ladies and gentlemen hello
and welcome to this talk on date and
time jsr 310 so i'm steven colborne
Roger Riggs is over here he'll be
speaking a little bit later um it's
obviously what we're here to talk about
today is this picture in my view it's
the incredible disappearing complicated
pneus of actually getting a date and
time API the suta books it seems like
such a simple problem but it isn't it's
a complicated problem space there are
you know it's one that if I asked you
you know in the audience you know what's
the date and time you can just look at
your watch but there's a lot of stuff
that goes into figuring out what the
time is and that solution isn't driver
is hard so jate r310 is intending to be
a new date and time library for the jdk
and obviously there are interesting
design constraints around being in the
jdk and it's kind of inspired by joe to
time so for those of you who haven't
used Joe two-time go and use it and you
know it's the best thing that's
available in JK six and jdk 7 and better
than java.util.date in calendar so if
you Joe two-time than much of Jerris
r310 is fairly familiar 310 is an open
jsr project so once it's been much
openness and transparency in the Jays
JCP recently j cell 310 has kind of been
doing it that way all along so you know
it's there's a bsd license code it's
open mailing list it's on github easy to
deal with basically so his little
timeline as how things have gone along
it's a long time ago since the genocide
was approved we had an early draft
review back in 2010 and we're actually
in a second early draft with you now
coming up towards the feature complete
date thereof january twenty thirty now
you know you could say that's a long
time line it is a long time line but you
know there's no point in putting
something into the jdk that's broken
once it's in the jdk is fixed we already
have to let say broken jdk api's and
date and time we can't afford to put a
third poor one in there
so we need to make sure we get it right
so all the overall goal to the jsr well
we're trying to find this comprehensive
model of a date and time we need to
support global calendar systems and we
want an element of type safety so where
it's sensible to avoid primitives we
want to do that I mean you know day of
the week six doesn't really mean a lot
whereas a day week as an enum you know
where the enum is something sensible
like thursday that makes sense so there
should be an element of sorts of self
documentation about it should be easy
for you to you know once you've written
your code you should be easy to know
what that code means and it should be
ide friendly we always your IDs these
days obviously we have to interoperate
an xml and database of big users of dane
time stuff so these are all the
principles we set out way back when one
thing to be immutable you know part of
the big problem with Dayton calendar
class today they're mutable so you know
if you receive them in a javabean you
have to clone them if you're passing
them between threads you're not sure
what you're getting it's far better for
us to have immutable classes that's
really what's really required here you
want the thing to be fluent so you can
basically read what the date and time
says how the key one is this clear
explicit than expected these methods
should be well defined if you call a
method you know you need to know what
it's going to do there shouldn't be too
much ambiguity in terms of what that
method call is going to do and this
results seem quite a strong control over
state so you have to control what the
state of the individual classes are in
order to be able to define very clearly
what the methods do would be an example
of that later and we know jdk authors
j's are authors with yeah there's many
different ways you can work with dates
and times we can't know everything so we
need an element of extensibility this
just gives an idea is to sort of some of
the different concepts that there are
out there in dates and times yeah people
talk about rubber seconds or Julian
calendar systems
and SI units there's many many different
aspects to date and time these it can
easily you can easily get lost in the
number which different ways that the
word time can get overloaded so time
itself just how so many meanings so what
we're trying to do part of the what the
jsr is trying to do is define a domain
language for dates and times so they've
people talk about this particular word
we know what their meaning it is it's
it's like design patterns you know if
somebody talk to you about a factory
pattern or adapter pattern we pretty
much know what was because those have
kind of viewed themselves into our lives
and so it's the same here we're trying
to add in a level of information by
using words and consistent language
within the date and time domain there
might not have become immediately
apparent as to why that's necessary but
once you've used if you view at a time
you actually find yourself talking in
terms of the class names as the concepts
you're trying to represent so you end up
modeling using those class names as your
concepts so it ends up kind of the ISIS
deadly end up with is sort of two core
requirements so you have machine time
and human time so the one on the left is
a cesium clock so that's the atomic
clock but actually yeah counts the true
length of a second in terms of the
number of permutations of a cesium atom
that's what one of those looks like and
so the continuous stuff that's single
incrementing number you know it's great
for machines machines are great at just
counting incrementing numbers yeah we
know they seen java.util.date where you
just store a number of milliseconds from
1970 where's humans we like to do with
something sensible we can grab hold off
so we deal with years months days hours
minutes seconds and so there's obviously
a relationship between these two things
but they are different so the timeline
itself well I is just a fundamental part
of human experience there's no
particular model class to represent that
in the API but the first class we do
have it instant so instant is just an
instantaneous point on that timeline so
you've got a time time
stamp of an event kind of equivalent to
what you might use java.util.date for
just to represent a point in time with
no ability to get hold of years months
days that kind of stuff out of it if you
convert it to other classes to get the
years months days out but you can't get
the mac directly so we're measuring it
using nano seconds there's a
requirements only from the database side
to store nanoseconds unfortunate this
gives us a problem because you need 96
bits to store enough information and
there's no primitive in Java with 96
base so we have to work around this we
have to store seconds in a long and
nanoseconds in an int and combine those
two things lots of maths so duration
again these are concepts which are
probably quite common and quite
understandable but we have to give them
names now once we give them name
everybody within your team can
communicate using these days the
duration is an amount of time is a
quantity there's not connected a
timeline but it is it is it in in the
particular model we're using it's a
directed difference so it points for
words so you can have negative durations
if that's what makes sense in your
application again it makes its measured
in nanoseconds and again obviously we do
that 96 bits so here's some example code
um so here we're creating an instant
from a number of milliseconds second
line an instant of now that's going away
using the system clock
system.currenttimemillis internally but
there's expansion on that which will
cover later on nice convenient method to
check with this before or after we can
get hold of duration in a similar way
obviously duration being an amount we
can multiply that by things we can
divide that by things and add it and
then we can combine these two things
together so again you're beginning to
see the the code they're just kind of
reads very naturally there's nothing
overly complicated about that but we
have weird things in dates and times
yeah there is such a time as 23 59 60
so in real life the length of the SI
second so SI system international i
think it's the scientific definition of
a second so that cesium clock we saw a
picture of earlier that defines length
of a second in terms of assam based
system so that's absolutely fixed it
doesn't change but the length of the day
does very you know astronomers look up
at the sky and they tell us how long a
day is and the earth is slowing down
that's what they tell us so since the
length of the day changes but the length
of a second doesn't change we have a bit
of a problem and so the problem is that
the day isn't equal to the total of all
of that information so the UTC which is
the clock we all do with laser leap
seconds to practice now probably the
average member of the general public
doesn't really notice leap seconds
computers don't handle leap second very
well they only happen occasionally there
was five or six years without any leap
seconds that generally happened once
every 18 months that kind of thing so
Java counts milliseconds from 1970 but
what does this mean well the strange
thing is that a UTC definition I was
just talking about only began in 1972 so
1970s and too terribly great day to
choose as your definition of a fixed
point in time and the definition of Java
milliseconds assumes this number of
86400 seconds per day so what happened
throughout leap seconds so there's no
happy answers risk or basically when I
say it only started properly the
scientists define what UT cement in 1972
now they actually did find it before
1972 whether this definition before
nineteen seventy was even weirder they
added in tenths of seconds and seconds
that weren't a second long yeah trust me
you don't want to know before nineteen
seventy that's even worse so we've taken
an approach so we're defining a java
time scale and on our time scale so
midday is always the same as midday on a
UTC tight timescale the civil time scale
now I'm
saying civil time not UTC there because
if somebody in the future redefines what
UTC is or the world decides that UTC is
not is no longer than most commonly used
time scale in the world this doesn't
this definition doesn't change we're
just talking about the most commonly
used civil time scale in the world other
times have to match within the day as
best as possible so we're defining a job
of a day is divided up into 86400
subdivisions which we're calling seconds
now what that means is a second in Java
is not always the same length as a
second as defined by the scientists but
you know most of the time that's what
developers actually what he actually
governor there's a google arctic online
which basically says how they smooth
over leap seconds to make sure there's
always 86400 seconds per day so Google
second is not the same as a scientific
second and that's what a lot of
operating systems try and do as well so
this definition is not unheard or
unreasonable it's just a practical
definition that means developers to need
more leap seconds probably don't really
want to know much of the time so human
scale date and time obviously that's
what most of us are interacting with all
the time years months days hours minutes
seconds x 24 hours 70 weeks all this
kind of stuff so what we need to be able
to represent in our applications is the
concept of a date and a time or a date
on its own or a time on it so offsets
from Greenwich so I'm going to go into
these in a bit more detail so a local
date so a local date is a reference to a
time to a date without any reference to
any times or time zones say no my
birthday might have been the first of
april nineteen hundred i don't need to
specify that i was born in you know
london I don't need to specify what time
of day I was born I'm just specifying
the date and that's great so now we have
a class that we can just all that
information it and that actually turns
to turns out to be one of the things we
most commonly want to do in our
applications now if you're still using
Java util calendar or
you're probably doing is setting all the
time feels 20 if you want to represent a
date now unfortunately that actually
doesn't work because once a year in
certain countries there's a time zone
gap where midnight one o'clock in the
morning doesn't exist so if you're
trying to set your time to midnight 0000
you're setting it to a time that doesn't
exist in you'll get errors having a
class that only represents the date on
its own means you don't get that kind of
thing we have a local time class yeah by
analogy it just represents the time yeah
when does a shop open time shown on
alarm clock time shown on your mobile
phone java class associated with this
again it just stores the time and it
stores it down to nanosecond again but
you can use it in effect for just our a
minute or more than that then we combine
these two classes together so we have a
local take time class yeah the date and
time a top flight takes off you normally
talk about that in terms of a local time
and then we have the concept of zone
offset so over here we're like eight
hours nine hours behind the 80 is it
seven like I lose track behind the
Greenwich and in London were either at
greenwich time or we're one hour ahead
of greenwich time so you know freely as
a head USA is behind this is a concept
which you you will see as this plus 80
plus 0 1 colon 0 0 and this is perhaps
what you know you might actually be
using that offset with so you have the
offset daytime so this is the date and
time combined with an offset so if you
actually want to specify a point in time
then you know here's a way of doing it
so if you remember back we had the
investment class the incident class was
a point on the timeline that had no
information about human scaling time he
couldn't find the year the month of the
day out of it whereas an offset daytime
represents exactly the same point on the
timeline
but because we've got the offset in
there we can actually now define what
the year month day hour minute second is
so that extra piece of information
allows us to convert the overall instant
to a date and time and there's other
classes so if you just want to represent
a year you can do that or a year in a
month for a credit card expiry date
perhaps you just want to represent a
month and day how many the Brazilians
don't like giving their birth date birth
years so they just give you your the
month and day Dave week month on the
Rome so you have a nice enum to
represent yeah whether it's april or sep
tember mean I'm to represent whether
it's Tuesday or Wednesday and other
combinations as well some code so we can
query date and time using standard kind
of get methods just returning whatever
the best type is for the field I
primitive int the most fields and you
know if it makes sense no as I said
earlier day we kill six doesn't mean
much Dave week dot Saturday does now we
have to look at what happens when we
were immutable so if we're immutable you
can't have set methods sets doesn't make
any sense for mutable classes so instead
we have with methods so you don't change
the original object you return a new
effort so if you use this kind of thing
before string dot your local case to
lower case is an example of that kind of
thing so here we have an example of
creating a local date and you know third
to December 2010 setting the year so we
just do with year 2011 so that's like
calling set year 2011 but we're
returning a new object so it's with you
but there are more complicated ways to
adjust dates and times on that so we
have this adjuster interface what this
allows us to do is prepackaged our logic
for changing dates and times so you can
say date with the last day of the month
or a date dot with the next third friday
of the month or last wednesday of the
month so
the kind of algorithms that when you're
working with dates and times in your
applications those are the actual useful
algorithm the basics of just changing a
year or a month or a day they're quite
boring ones changing it to the last
Friday in a month that's the more
complicated one you know changing it to
the next non weekend day that's the kind
of algorithm you want to be
pre-packaging up so some of these
prepackaged things will be provided by
the JDK and some of them way and then we
have the problem of time sense time zone
under a problem it definitely are so the
world is divided up next time zones
these are political things political
things means government means power
means control over people you know
people change their life savings sign
rapidly with few days notice over a
number of years as experiments maybe
every year you know you can't assume
there's only one daylight savings time
period a year yeah places in the Middle
East typically have daylight saving time
then and come out of daylight saving
time for Ramadan and then go back into
data it's safe it's time again these
things get complicated there's not much
you can achieve about it so then you
have these rules which define how that
offset changes so you're virtually got
to have somebody who gambles together
all the information from all the
governments and figure and provides that
information in some kind of database so
it turns out there's multiple groups who
pull the information together from
databases so the big one is the time
zone database group which is now with
ayanna but also windows does the job
iata for travel industry does the job
various commercial companies do the job
and so each group probably defines its
own ID so the time zone database it's
europe / london so if you ever use time
zones in java you're actually using the
time zone database which is the same one
that's used in all the UNIX stuff as
well if you have a look for the jdk does
it has this class time zone and this
says it represents the time zone offset
and also figures out daylight savings
this is an example of where the Javadoc
is kind of telling you this class is
doing two things so what we're doing
here is separating out responsibility
into two separate classes so you have
the zone offset which is just the offset
it set on its own then you have the
rules which are the rules for how and
when it's which is offset and then you
have the zone ID which names a set of
rules so you have to break the concept
wrap into different parts but you only
end up with this one additional time
third class zone datetime so zoned
anytime if you use Java util calendar
you could argue that's the equivalent
because it's the one that actually
stores a date at the time and the time
zone to interact with now now that's not
me saying replace all driver you to come
in there with daytime because that's not
usually what you want to do you want to
look at your code and say well actually
was I using calendar just to represent a
date on its own if so then I should use
local date Beck's if I was using it just
to represent a time of day then I should
actually switch to using local time so
it's not a case of you should just swap
from one to another you have to think
about it and then we have the problem of
where what happens with those lovely
gaps and overlaps in daylight saving
time so obviously in spring yo there's a
bit of the like there's a there's an
hour which doesn't happen in the autumn
this the same hour happens twice though
we have a strategy pattern which allows
those things to be defined and
controlled we can ask the guy to find
out what the situation is so we can say
you know for this given local date and
time is time changing is it in the
middle of a gap is in the middle of an
overlap and do certain business logic
around that and there's a summary of
where all the different classes sit so
we have local days liquid time work will
take time they just build up on this
local time line so there's no
information about time zones are offset
there then we add in the information
about the offset and then only at the
end do adding information about the time
zone so build up step by step so what
this means is that when you're doing
your writing your code you should
actually be choosing which one of these
classes represents the information best
that you should be storing in this
variable so it's adding to the data
modeling ability of your API but it
requires obviously there for
extra a little bit of extra thought to
make sure you're using the right concept
rather than the wrong concert project
thank you so all the support in the
classes that Stephen isn't talking out
represent through the core iso API and
it's in one of the packages of the 310
API there's quite a bit of other support
their one topic is how we're going to
integrate the 310 classes into e to the
J to K so that it's possible to transfer
to convert job eula calendar and dates
to 310 API send back when necessary when
you have to go between sort of existing
code and new code so the technique will
actually add some of the interfaces you
know from 3-10 into Java util calendar
to make the sort of normal operations
within 3-10 be able to convert and
exchange dates and times plant current
plan is to not have any not to have Java
calendar date show up in the 310 API
it's sort of a bit of pollution you get
to choose which way it works seems good
to keep the 32 napi clean the tub just
as Steven said all of the core classes
are based on the iso standard and some
fairly fairly straightforward constants
and definitions 310 else has to take
into account sort of the other places
that represent time and xml and in
databases and we'll get to that a second
so in databases there are you know some
well-defined in jdbc it defined the SQL
standard it defines similar concepts of
dates times without time zones times
time stamps without time zones etc from
various combinations and there's a
straightforward mapping from the both
SQL concepts of date and time to the 3
10 types that are represented there are
the timezone issue there are I guess
that the standard basically says what
happens that all dates and times are
representatives potentially having
offsets but there's no really support
for times
in the standard however there are many
proprietary databases that have SQL
extensions or database extensions to
deal with that so we're going to work on
how that those translations will work to
support the s2o well the other another
aspect which Steven mentioned is the the
idea of a period sort of a it's not the
same as duration iteration is really
sort of a very fixed amount of time but
durations are measured more in terms of
the units of human time like year and
months days and the difference really
shows up only in a few places when there
are time zone differences or daylight
saving time changes where you're not
really representing a length of time but
between the point distance between two
clock meetings and look at the clock
twice and it has a certain difference so
the period class will be able to
represent these differences in terms of
you know the number of years months days
hours minutes seconds and now seconds
and those periods can be added subjected
to the time and date classes but you get
some interesting artifacts that we have
to figure out the details of if you add
a day to january twenty thirty first or
actually if you had a day in a month to
january thirty first what do you get to
the marchers if every so there's some
interesting problems and this is you
know Stephen the loot into these little
pitfalls all over the API the other
aspect which we also need to cover in
the 310 API is the support for other
calendar systems there's you know
besides the the core case of 8601 and
the iso calendars there are many other
kent historical calendars and calendars
in common use around the world and the
goal is to try to make the API so that
we can support both well but not really
not really sort of contaminate or make
the ISO API less clear less useful and
as always we need to make sure that
there's no ambiguity and developers that
API will help developers write good code
so there's a lot of different calendars
the API needs to be able to do so look
up by names one of the concepts that
we're still working on is the concept of
a calendar neutral API where the
calendar system is a parameter to the
API so that you can write code that
manipulates does calculations in the
calendars without actually knowing which
calendar in it's pretty straightforward
to say you can add a day sometimes it's
pretty straightforward to at a month at
a year but the actual computation and
what the date ends up being when you do
this operations hands a lot on what
calendar in and so there's a notion of a
chronology or a calendar system that has
to be taken into account that's not as
fixed as the one myself there are many
oddities and calendars you know and I
guess in traditional Chinese there can
be an extra month inserted between any
two months in 12 month calendar their
calendars in which sometimes they're 12
months and time sensors 13 so the API
for that needs to keep the developer
from making assumptions about you know
the number of months in a particular
year the kind API that is in the edr its
focus just on the date concept there's
no unlike I so there's no way to
represent a date at a time or a date
time and offset or zone daytime but they
all are convertible to the iso times so
it's this chronology package which is
separate from the main iso package as
factory is chronology class which
represents the things that the
parameters that are specific to a
particular calendar allows conversions
in and out of concept of epoch day going
back to the 1970 date where in order to
be able to convert the things everybody
univ as to be a common understanding of
where some date appears in every end
time appears in every calendar and then
just fairly straightforward methods
about including mentioning of eras there
in the many of the calendars that have
at least two eras like ad and BC and the
Gregorian calendar japanese calendars
have you know air at number of errors to
a new era begins when when the Emperor
dice so there's been a long series of
eras and if you represent things
natively in the Japanese calendar you
have to take into account that it's a
offset from the beginning of the era and
you have to know the error name so
there's it's sort of an additional
concept in the regional calendars that
is not present in Eric and I so but most
of the same operations work and adding
getting the day of the week I mean we've
sort of set along the fact that the day
of the week really is the same the world
around some places the this week starts
on a different day but to be consistent
within the API you need a fairly
constant very stable set of how to
indicate days a week adding and
subtracting days before and after you
know all of those common concepts really
do work across all the calendars the
actual computations are a little bit
different but the developer can use the
sort of this aggregate behavior well in
general the API has to be we have to be
able to support new calendars because
we're not going to prevent provide all
of them so it is a goal like with many
of the other aspects that to be
extensible in adding new calendars
right so about the world calendar I
don't think I've heard about that one my
understanding is ISO covers all of those
those same constraints but I haven't
heard one created by the UN so find out
more about them just like with the ISO
calendars there's still a need to be
able to do state adjustments because
there are a lot of you know there are a
lot of more interesting dates if you can
ever more counter esting computation of
how to change from one day to another
and so the same data gesture mechanism
works with the call to chrono or the
chrono calendars shifting on a bit to
questions about what's the current time
right the lot of the current classes you
just sort of say you know get me a date
and don't tell you sometime but it sort
of implicit what the timezone is that
comes with that so the design for in 310
for the current time is built on the
notion of a clock object and there are
system to fall cloud objects the clock
objects that come with a time zone in
the current time and many of the api's
can only it guys can build from o'clock
but it the result of there being and
clock object if you can actually supply
your own clock either to be able to
modify do things when you're testing or
to have some better different control
over time there are certain places where
you want to emulate and change things
big things from ambassador slower so for
example here there's there is there's an
API called you typically called the
method called now pretty much everywhere
that gives you access to the current
time either from the system clock or
from a application-specific clock and it
works in two ways I mean it so Steven
mentioned that there were instance which
really represent a point in time I
through independent of a calendar and
you can get that from the clock or
create one from o'clock and similarly
you can create the local date you know
get a date or time from the clocks as in
the same way you know when you use you
can create a zone daytime from the clock
as well and Rhys resync a particular
date time value to particular
time zone the one of the uses that our
clock interface is to be able to in in
frameworks that can do injection you can
those in those frameworks you could
actually have the clock particular clock
value be provided from outside and the
developer would actually be writing to a
specific the code to provide the real
clocks but you can parameterize the
whole your whole application that way in
if you're using one of those are the
frameworks another one of the sub
packages of 310 is support for
formatting and parsing it's driven it's
unlike simpledateformat it doesn't have
a mutable context that goes with it so
like the rest of the API it's built on
immutable objects and is safe for
multi-threading the the main classes
date time for matter and it's built on
the fields that exist in many of the
objects and one of the subsystems of 310
has specific support for each identified
field type you know the hour seconds
ampm clock of ampm and this is one of
the aspects one of the dimensions of
extensibility is the identification of
the definition of fields the film at the
formatter is built on the fields and how
to format those fields in format strings
the most common part of the API is
format strings the same way they are
used in in simple date and many of the
same letters and it's also their
extensions to be built on top of the CLD
are standard for formatting syntax and
semantics so underneath throw the high
level API is that we've been talking
about there are 22 core interfaces that
provide sort of a base substrate that
all this stuff is built on date and time
the date-time interface is it has a
model of all the objects that have each
has fields and you can get field and you
can you can eat say quote set but it's
really the methods are called with and
it returns a new object so and that's
one of the primary this API is primary
gives access to all the details of
particular day time object and it's one
of the sort of the primary way that you
can do conversion between objects
most of the daytime objects that they
have a date also support a field called
epoch day which is the number of days
from 1970 and that's sort of a lingua
franca from across all the calendars and
all components the other interface at
this if its core level is the adjustable
datetime interface and it delegates to
the field the extensible field system
the ability to add and subtract from
fields so that you can add one to the
seconds field of some object and it will
give you back the new object that has
that field set so as I mentioned earlier
the there's a lot of extensibility in
the API at the field level and at the
four periods in the period system is
obviously you can have periods of hours
minutes days years seconds and there's
potential to be able to add new period
types and the mecca is all the
mechanisms that compute periods will can
delegate to them to new classes there
and then the primary one I mentioned is
the date-time feel is the abstraction of
fields within the state time interface
and there's quite a number of predefined
fields for all the standard things but
you can add your own as needed so as the
questions earlier it is possible to
write your own calendar system the
creating an implementation of this
chronology class and an implementation
of the chrono date class which is sort
of the general general purpose interface
the it's currently defined we're going
to be able to hook into the service
loader mechanism in the java runtime so
that it's easy to hook new new calendar
systems into the JDK just by including
them in your jar file with the red men
data and that same mechanism will extend
the service loader mechanism is used
both in the current jdk and several past
ones and will be adapted for use in jdk
nine with the manual system so shifting
topics a bit to sort of where we are and
what do we have to do next there's a
sort of a set of open issues we're
looking at through where we are in the
schedule and what needs to be done
we've got some key questions just kind
of reevaluating the current API is about
the relationship between the regional
calendars and the ISO calendars and how
much support should be in the regional
calendar API is to make them usable
we'll get some questions about that
later the size of the epi is was at some
point was it concern but it's gotten a
lot better and sort of a question of how
it has to fit into the JDK there a few
questions there one of things we haven't
looked at closely is whether there's any
potential for integration with Java 8
language features there's financial
views default methods and maybe some
lambda features but we haven't really
gotten to that point I think mostly we
have the details of period settled
support SQL but we go finalize that the
sort of a bunch of detailed issues
around formatting of regional calendar
and date and time things to match to be
consistent between what the jdk does
today and what CL dr's the CLD our
standard before formatting suggests and
we have to implement a bunch of
calendars which we don't have which we
haven't yet implemented some of them are
easier than others so there's more to do
there so next step wise obviously we
need to address a bunch of the design
issues the 310 has been is implemented
in the github and the standalone open
source project one of the steps in
integration into the JDK is getting it
into the Intuit openjdk 310 project so
we can build it with a jdk and take
advantage of the the other features that
they're coming into the jdk at the same
time today the API is built I think it
was originally built in jdk six and
until recently didn't take advantage of
anything in jdk 7 but we're moving in
the syntax at least up to jdk 7 in the
open source repository so the other
thing we have to keep a real close eye
on is the schedule the jdk you know his
post of the schedule and we mentioned
this data at the end of junior
ray which is milestone six and JDK where
they they call a future complete and in
order to synchronize with that schedule
about we have to synchronize that
schedule sort of one way or another so
there's obviously more implementation to
do more testing to do and get it
reviewed so we have confidence in the
API so I think in summary we've got a
very robust very complete API that deals
with different concepts very cleanly in
terms of incidents and durations very
robust capability for a date and time
period very complete formatting and
parsing mechanism support for multiple
calendar systems as part of the API and
needs to support through worldwide use
of calendars and with a clock API you've
got control over time so Stephens been
running this project for many years the
project is very open they're always
looking for health and contributions and
you know please review and the documents
and contribute during the deal if
there's a purge 0 feather tonight
actually it's right here at seven thirty
so if you've gotten you know if we can
answer your questions right now come
back and we can have a more dynamic
conversation so if their questions or
just even few last time yeah I mean I
think that's the thing a over the whole
point is it is open and you know
everybody can contribute and yo your
feedback is always listen to i think
that's that's a key thing you know
there's there's no point in hiding away
from people's experiences with date and
time so whilst we got something from the
audience i'm going to ask you to take up
your hands before before i get to
questions i'm going to get two questions
don't worry so first question I want you
to put up your hand if you in your
business application let's say in the
last five years have ever used dates
before the year 1900 so if you ever had
to deal with dates before the year 1900
as we've got 56 you want to quickly
shout out what's what have been the
primary use case of those
you want to start down there
okay so really old companies yep one
policies that are old yeah birthdays
well anybody older than anybody older
than that but just birthdays or anything
else nope okay yeah our company's again
yeah but they good yeah ah is that way
you're thinking of but now you're
thinking of just very old people yet
cool that's fun so company's policies
that's good yeah good reasons yeah and
the second question we have is how many
of you put up your hands use a calendar
system in your day-to-day coding in the
last five years that is not the standard
ISO calendar system that we're using in
the Western world europe so put up your
hands if you're using a calendar system
that is not the iso callum system in
your applications one anybody else can
you give us your why you use that column
system okay yep and you use that solely
for displaying to humans or do you
actually have to do calculations in the
hit recover okay thanks cool Steven
that's a very good question why I asked
that one I wanted to pee until yeah yeah
so if and Tyler here and yeah if if
there's anybody from Japan or Thailand
in here can you please afterwards come
and chat to us because we'd really like
to know what your experience of dates
and times are in those two particular
countries Thailand and Japan the Guru we
know those are two of the countries
where dates and times are more different
than other countries so now we're ready
for any questions you might have did you
have a question
so the question is what's the difference
between the period class in the duration
class and this is an understandable
conflict because they represent similar
ish types of things they were both an
amount of time so a duration is an
amount of time I just measured in
seconds in nanoseconds so it's only on
the instant time line whereas a period
is measured in terms of human scale time
so years months days are minutes and
seconds so your suit amongst you will
notice the seconds it is in both of
those definitions so you could therefore
theoretically define duration as a
period just use the second feel however
there's also a difference in terms of
which time line they associate with so
we talked of earlier about having local
date local type time liquidate time so
if you have a daylight savings time gap
in spring and you measure the period
from midnight to 6am in the morning
you'll get a period of six hours but
you'll get a duration of five hours so
the duration is taking account of the
timeline the instant timeline the one
actually you know the real fine line
that occurs whereas the period is only
taking account of the what appears on
the clock yeah on the clock we've gone
from top of the clock to six o'clock
therefore that six hours so that's the
difference between the two question over
here
yeah so the question is is there a such
a concept as business days within the
application yeah yeah working day
working days that kind of thing yeah so
there are companies out there which make
money from selling you the information
as to win holidays off it's a
complicated job keeping track of all the
countries around the world and what days
holidays occur it it's more complicated
than figuring out when times they
exchange governments make gum makes even
stranger decisions around when holidays
are so you know could we providing the
in the JDK that information it's not
really practical to do so however what
we can provide is is is the ability for
you to have somewhere where that code
can be plugged in so we talked about
daytime adjusters so date china
adjusters allow you to wrap that kind of
holiday behavior so if you have a
library or a database in your
application which probably comes from
some one of these commercial vendors or
maybe from somewhere else you have the
right tool with the de justice to be
able to easily integrate that into the
API I mean even weekends believe it yeah
that varies around the world you know oh
oh I mean one of the databases that goes
into support of the API is is the CLD
our database where they've tried to you
know can create a big database of for
every region concepts like what's what
when does a week start one of the
weekends and those things don't take
into account holidays or this level tell
you that money is a holiday or you know
the Germany has a bank holiday so that
really requires this extended database
but I think we can build in the notion
of sort of the standard week concepts if
it's drawn from the CLD our data like
the time zone data we can't we don't
know that you know a priori if the time
zone stuff is built on the olsen
database and it's plugged in
and CLD idea comes from is another
source that we could expose to the API
but they really solve a problem with you
Deb more commercial gap week working
days versus weekends is in the CLD our
database when holidays are isn't so we
might be able to do warm but not the
other not at the moment it's it's one of
these nice to have features we with the
data is available in CIF co dr but we've
got other issues to tackle first I'm
gonna go white yes for reasons of scope
we don't have a interval class you know
it doesn't prevent it from being added
in the future JDK but we don't have one
way yeah yeah
well I have a plan my plan is that I
hope to make Joe two-time a new releases
over time which implements the
interfaces of the JDK so the problem you
have is the class names will clash so
there'll be a local day class into time
will be a local take place in the JDK
there's not much I can do about that but
you would be able to pass and
interoperate the things between the two
but that's that's my plan obviously
that's you know down the road but yeah
the idea is this is a jdk 8 in terms of
what i was talking about there I was
talking about adding interfaces to jdk
to jojo time that would then run only on
red k i'm gonna go there
yeah i mean the sources of sort of as
you mentioned politically or driven data
are not going to change right so
actually I don't know there is a TZ
updater which is a separate application
which applies the times on database to
multiple versions of the jdk that
doesn't actually mean you have to
replace the whole j2k maybe you did that
for other updated for other reasons but
there is a tool that will insert new new
time zone data into the jdk and that
will still persist we don't have any way
to do that I have heard of essentially a
network-based source of ulsan data but I
don't think at the moment we have any
plan to qualify it and see whether how
it should be hooked in but I think it
could be plugged in at some point yeah i
think what i say is that in the jsr on
the current github site we actually have
that information as a separate jar file
but when we integrate into OpenJDK it's
not clear exactly whether we be able to
keep that well he's over it may make it
a lot back down again if you do to me I
mean energy in the current jdk the time
zone did it is a separate file it's if I
forget work directory it's in but it's a
separate file it's replaceable and
updateable and that I don't see any way
around that given like you said if
external data
so the questions about the size of the
API in terms of modules and where the
module might sit so there's still an
element of discussion to be had around
this you know it's quite a low
fundamental thing date and time and
particularly if we make the existing
java.util.date and job you to a calendar
classes implement 310 interfaces and
obviously some of those interfaces
clearly have to be in the core because
java.util.date and job you to a calendar
are going to be in the core modules so
freaking out the exact boundary of that
there are a couple of options there but
it's not a it's not a small API the date
and time stuff I think I think why I
want to try to go through it you know
there's there's quite a lot of
functionality and quite a lot of
features which you kind of need if
you're actually going to accurately deal
with eight and time so you can certainly
spit out a calendar system jars because
a multi-client systems obviously plug in
a certain way the question is whether we
can spit out some of the other stuff and
that's an open question maybe come
tonight if you want to explore any bit
what he did do you want to say something
that I they go there
so the questions about ta I versus UTC
and conversion between these two things
so about two years ago we have a set of
classes called tii instant UTC instant
and instant and these provided the
conversion mechanisms between them in an
accurate way the problem is the problem
is that a UTC as it's currently defined
may go away so do we want to you know
this is under discussion about so if we
put in the classes into the JDK now that
become redundant in a year's time that
doesn't really make much sense so it's a
question of well you know this is such a
niche tii versus UTC but it doesn't
really matter so in the end the decision
appears to be that we're going to leave
out details of other time scales does
that mean but yo yeah the classes still
exist the classes are still in github
there in just a directory with Bracy
says this it's not being included in jsr
you know can we then maybe publish those
as a jar file on maven I'd hope so you
know so if you're a scientist and you
care about these things why not yeah
you'd have to pick up an extra jar file
from maple but it would integrate so
that's sort of the direction of travel
or thought and hopefully that will be
sufficient actually say we have any more
question oh yeah
so that so the question is you know
Israel point to which we can grab the
API before it gets integrated into the
JDK and this is a it's a hard question
it's unlikely there's going to be a
fixed jazz our definition before it gets
into integrated JDK now in an ideal
world where we all had ponies and
multiple you know 48 hours in a day we'd
be able to produce some kind of backport
version that was constantly kept up to
date with what's in the JDK that seems
unlikely at this point it's more
important to focus on the actual main
base of the code itself yeah I mean
Roger mentioned the possible use of
lambdas i have to say i haven't seen
anywhere where lambdas really make sense
in the API however the date-time
adjuster interface is a single method
interface so you could theoretically use
it for lambdas but I can't say I'd
really see much use for the using it for
lambdas but you probably could it it's
not that we're by an T lambda is just
that it doesn't seem to fulfill any
useful use cases have removed any more
questions I think we don't okay so don't
forget to come on to the ball tonight if
you've got more more input you want to
give and if you're japanese or thai
please come see us now thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>