<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CLDC7: The Java Platform for Feature Phones and Low-Footprint Embedded Devices | Coder Coacher - Coaching Coders</title><meta content="CLDC7: The Java Platform for Feature Phones and Low-Footprint Embedded Devices - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CLDC7: The Java Platform for Feature Phones and Low-Footprint Embedded Devices</b></h2><h5 class="post__date">2013-02-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/SBSEO0s3oDo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon my name is Roger rigs and
this is a session on CL e c8 we're going
to talk about a bunch of updates to the
cldc specifications in the java in
suitable for java embedded and mobile my
colleague Michael agali is going to take
up about halfway through and talk about
the some of the topics in the middle oh
we have a standard disclaimer here about
this is most of this work is related to
standards effort and but it's all sort
of forward-looking and we're not making
any any promises to moment so cldc has
been a predominant specification in
runtime in mobile phones for probably 10
and 12 years now it's been through many
revisions from CL dc-10 to data 1 dot 1
1 dot 11 and it's part of an overall
Java ME runtime stack that is augmented
by the bubble information device profile
or mid p to add more application level
functionality and by a number of other
jsr s that have provide different bits
and pieces and some of those will show
up a bit later primarily here we're
going to talk about this lower level
piece of the platform which is a subset
of java SE and is sort of the core
platform and virtual machine for phones
the effort in this update which is sort
of long been long and coming is to bring
a number of features up to par with java
SE 8 so the current strategy that we
were picking up at this point is is to
make sure that Java ME is really the
little sibling or the smaller version of
Java SE it's api's need to be a strict
subset of se so that if you write an
application or write libraries to that
this part of Java ME then you the same
code will run on java SE and we're sort
of renewing our efforts to make that
true across the stack the we wanted to
get to the point where used if you have
a smaller device you
help you sort of explicitly make a
choice between functionality and
footprint we've done a lot of efforts in
various places in the stack to try to
make the implementation of some
functionality be small but at some point
you just have to start throwing stuff
out so it'll fit in smaller and smaller
devices another big point about the me8
releases is that we're trying to run
synchronize with the java SE releases so
similar functionality will come out in
the specifications and in the end you
know to be available at the same time
the benefits to the community of
synchronizing releases you know not
delaying getting features in the
features from getting into the small
platforms when they get into large
platforms though there I've score some
features in the large platform so it's
just are not appropriate for the small
ones and then you know really get ahead
to the point where the api's are the
same between or subsets between se enemy
we're also working in the direction of
trying to bring a bunch of value in the
Java mej SRS for this optional packages
like location and messaging to java SE
so that there's more functionality
that's typically been created initially
for mobile phones but should also be
across the full job of stack and also
we're trying to sort of reinvigorate the
tools story so that the same set of
tools are used for Java ME applications
is for java SE and really bring some of
the higher power tools to Java ME I've
seen a pretty nice demos of a Java ME
device being used with visual vm so the
the breakdown of the overall platform
for job for embedded devices as Java
card at the bottom which is a fairly
special purpose runtime for secure
applications Java ME targeting this sort
of 12 tank megabyte in and a bit below
space and then java SE embedded which
there other talks going on at the hilton
this week and
and it is a full set as well it's a can
give you the full a seat on the upper
end of the embedded stack so we have got
complete coverage of the different
device it's device scales just to just
sort of give you an idea of all the
places that Java can be used and it's
really sort of all over the map you know
there's a version of Java that can help
with almost any any embedded device so
I'm very pleased that we have actually
filed the jsr s4 to these two steps CLD
c 8 which actually got put up for review
today and includes some initially GG
members that are willing to help us
develop the api including applix nokia
north 61 and one of the individuals on
the executive committee stefano and
Rihanna if you're interested there's a
easy way to join the asked to join the
expert group and we'd love to have all
the help we can get and then the second
profile which I'm not going to talk too
much about today but there are there are
talks is talk on it tomorrow is the Java
ME embedded profile was also filed for
review today and it is the sort of the
successor and broadening of the imp and
the mid p specs to a broader set of
invented embedded devices so so what's
in this java SE le c 8 platform release
the we've sort of needed for a long time
to modernize the platform which means
updating the vm specifications to a bit
closer to current levels align the
language definitely align the language
constructs there have been a lot of
language editions in java SE 5 6 and 7
that have not made their way to Java ME
until now and then the that will bring
the tooling in line with java SE as well
and there's a separate profile the work
on to develop
for embedded devices one of the other
initiatives is part of the overall
platform update is to improve the
tooling to work on on-device debugging
and on device profiling and all of this
is targeted at the broad mark market of
small embedded devices so typically just
a couple of typical devices these are
sort of bread board or you know sample
devices this SD micro device you know
nothing to the Kyle board nothing to
amazing about it except it's easy to
pretty easy to get to and it's got a lot
of common functionality so it's easy to
sort of prototype on the other one is
still our typical topic of a feature
phone the HTC smart is just an example
from of sort of about the capabilities
that are useful where the Java me a
platform would be applicable so in
broadening the the the market I mean we
can actually are drawing on all of the
optional packages and the that have been
developed in Java ME over the past 10
years the so there's you know support
readily support existing standards for
many types of graphics 2d and 3d
graphics the contactless communication
xml some of them are were originally
sponsored by by son now oracle others
have been contributed by siemens and
nokia a plex motorola so there are 33
new j SRS that were that are being
worked on the first two have been up for
review today and the third one a device
access API we'll talk a little bit about
but it's it's going to be just where to
start that one off a little bit later
it's targeted at making it easy to write
a java application that actually deals
with device registers and primitive
devices on the top on the device
so let's focus a little bit more now on
CL dc-8 in particular what's in the the
updated specification of the features
many of the language features as i
mentioned come from java SE five six and
seven there's some new features in the
API that people have been asking for for
a while there's a bit of update to the
virtual machine which target is still to
try to keep the footprint pretty small
the you know in spite of the fact that
you can get bigger bigger devices
there's even more devices that are
pushing toward the lower end of the
spectrum so there's a real tension
between footprint size and functionality
the more functionality you can add the
platform the easier it is for developers
to bring their skills from Java SE and
apply them to embedded in mobile devices
one feature that sort of had gotten away
from us in the previous specs was the
generic connection framework that has
it's a sort of it's a different
framework for doing i/o networking and
it had spread out to multiple
specifications and that's being
reconsolidate aback into a single
specification that can be used across
the platforms and then of course because
co DC is sort of at the core of all
these devices and there's a lot of
applications out there backward binary
compatibility is is a key element of the
update so in in sort of big blocks the
the CL dc-8 architecture consists of the
GCF on the top which has the individual
protocol supports for Datagram sockets
multicast is new and then below that
there are the core packages that are
subset from SC including java dot io
lang support security and util and a
couple new ones drawn from niÃ±o niÃ±o
buffers in particular and we're also
considering looking at niÃ±o file
support so that there's a standard file
i/o API in CLE see
so just a couple of examples of the
kinds of things that are new the
assertions the search statement had been
added in I think java SE 5 is easy to
sort of stick in code make sure that the
things that your program assumes are
still valid one of the bigger changes
that the language level is generics
which allows you to have lists of
objects of particular types and be able
to have a compiler enforce that types
the types of things that are in the in
various collections types as an invent
advanced for loop which makes it easier
to iterate over iterators or arrays just
it sort of syntactically makes it easier
to deal with that auto boxing the
compiler will automatically convert from
integers integer objects wrapper objects
two int's and back and same with other
types enumerations is another powerful
feature where instead of just declaring
you know primitives is public final
statics you can declare an enumeration
and in case and switch on them and make
some maintence a little bit easier the
code because there's are they're
actually typed object so not just were
bare primitives ver args I mean actually
many people will be familiar with all
these features because they are from
Java five six and seven static imports
just makes it easier to write the code
where the some of the code can be more
concise can be briefer because the
import static imports the symbols of in
parallel d annotations are a place where
we actually had to compromise a bit
because the full an application support
consists of compile-time annotations and
runtime annotations but to keep the
footprint small on Java ME the runtime
annotations which take up space not only
in the class file but in the runtime and
require extra api's and the runtime to
deal with them seemed like they weren't
they weren't quite worth what they cost
in terms of footprint
a few more language features being able
to switch on strings some syntactic
things the compiler dealing with the
markup of integers and literals the
multi catch and multi in precisely throw
is makes a cleans up the code because
you don't have to have as many sort of
repetitive exception handle blocks and
then of course there are places where
the type inference is it has been
improved make it so that there's not as
much redundancy and declarations and a
really powerful one to also help to
clean up source code is this try with
resources construct where it's you say
try and you put a try block and it will
automatically close the connection
closed whatever it is at the end so
instead of having to write the code
yourself to catch the exceptions and
write the finally clause and whatever
sort of complicated code is to actually
get the thing closed the compiler will
generate all that code so that's a big
improvement so in addition to the
language updates there's a sort of a
matching set of runtime library updates
to both some of them are there to
satisfy the language requirements and
others are there to just sort of improve
the set of AP is that are available to
developers there's a set of collections
interfaces that are being add their
collections are being added and some of
the implementations as well the compiler
improved performance in string build in
string constructs the Java C compiler
produces it now uses this strunk this
structure that requires that use a
string builder instead of string buffer
which was synchronized so to get a
performance increase they change the
implementation of the way string
concatenation works but that type and
care sequence have been added to the API
other little things like the comparable
interface works with collections and
makes it easier to sort of reuse things
there's a subset of an i/o buffers that
had been in use in one of the graphics
i/o packages it's being pulled into the
the core platform because it's
partly used by I mean it's used for
applications in the graphics case but
it's also used by the niÃ±o file feature
that we're considering as well and then
one one particular new feature that's
that it's going to help a bit quite a
bit across the platform is the service
loader interface that does sort of late
binding of interfaces to implementations
and there's more on that later yeah so
let me end it over here to to Michael to
continue with the service contact okay
thanks very much Roger so now we look
into a couple of the concepts and just
the core extensions and only focus on
some of them to give you an idea of what
we actually extend so there is a new
mechanism which is called service loader
or service provider actually which helps
us to package an interface and some kind
of some kind of behavior behind behind
an interface and that can be loaded and
implemented on a well in in the deployed
platform so it's a way of extending the
platform you can think about services
being put into a shared library of
services being included as part of the
application or less being deployed at a
later point in time um a provider class
must have a zero argument constructors
so they can be instantiated you're in
loading and they are just loaded and
instantiated on demand as a way of
describing these providers there is a
provider configuration file and this is
just put into the meter and services
resource directory of the of the package
and this is not a new mechanism it's a
mechanism that is taken from Sen that is
just being reused and being included
here and here we have a picture of
showing that is showing how this this
works so imagine that we have a service
which is going to be imported so we are
importing comics XYZ that service a in
this service contains three different
providers so there are three different
implementations of the service service a
with a provider one two three so you can
imagine this is just a plug-in of three
different implementations behind the
same interface and you have a you have a
common way of defining these services
and describing them in the in the meter
in services so for the for the first one
we have a section in under service a
with the names of the of the service and
then in the service be we just have
another section and all of them just
have to implement the service interface
the appropriate comics website interface
and that get loaded with this implore
new service loader statement with the
with a class name um connection
framework updates so if you look into
the specifications right now we do have
a GCF generic connection framework
packages spread across multiple profiles
and span packages coming out of the
history of how this was conceived so
there is parts that is in this LD c 1
dot one dot once bet their parts in mid
p their parts in cdc and andreas our 197
and we have been working or working on
our working on consolidating this into a
common GCF spec taking all the different
protocol implementations and combining
that into passing
spec we work on providing consistent
ipv6 support here to be state-of-the-art
compatible and we have been twiddling on
failure information by some additional
exceptions from java.net as also in
addition fire support various the stream
connection and we have been extending
the protocol support with IP multicast
and the permission system is applied
protocol now so in terms of new
protocols you are going to see that
there is the UDP multi-class connection
which is not on the next slide but on
the slide after that so in ipv6 this is
just a maintenance issue ipv6 is just
happening and the common way of doing it
is to have ipv6 addresses in square
brackets so in all places where you can
in the previous co DC specs we can use
an ipv4 address now you can also use an
ipv6 address this is normalized in a
common form as described in the official
RFC and so we have just regular ipv6
support everywhere UDP multicast and
Europe emart accursed is basically an
extension of the unicast protocol which
allows joining a group of multipath
hosts and helps to build distributed
services which to an automatic discovery
of services and supported features it's
quite common and used for example for
multicast DNS for media streaming to
multiple lines or other use cases and we
have been defining an extension of the
of the UDP Datagram connection in a new
class with European which is called
European multicast connection and which
is a straightforward extension here
so we can do client and server side
multicast scenarios we can join
multicast groups and we can create a
multicast service socket or also just
send data to a plane multicast group
without any additional effort a couple
of other things Oh connection options so
there is a need there was a neat showing
up in a couple of specifications to add
additional parameters to GCF so to
specify additional values additional
parameters for example some kind of keep
alive value or a proxy port if you're on
a proxy connection or some credentials
or maybe an additional time out or maybe
if you're on if you have several network
interfaces or several Wi-Fi connections
to select some some of the parameters
there so it's an extension of the
well-known connector that open syntax
with an open with Anwar our parameter
where you can specify the connection
options and these are just typed fields
or typed parameter values that you can
add and that are implemented and
understood in the protocol specific
fashion um coming to the access point so
there's an API now which allows us to
select a network access point which is
useful when we have different networks
so when we have 3gpp networks or cdma
networks and in conjunction Wi-Fi when
you open an HTTP connection you may want
to specify whether you wanted to use
your Wi-Fi network or you want it to
switch your to your cellular network or
maybe if you are also having a device
which is plucked just to an Ethernet
cable you may also want to select that
so you can query what kind of access
technology is supported on your device
you can get specific properties and
these are different / technology so for
example in 3gpp you can get the country
code the network code the operator named
to find out where you actually are and
then you can use this information to
select an access point for a connection
in addition the API also has a
notification mechanism to show you when
you have a connected or disconnected
situation so here's a brief example how
this could be used to report throwing a
couple of Java code lines to you so it's
pretty simple basically you can get the
access point in the beginning then we
just pick the set the first one so what
we do here is we attach an event
listener and we want to get notified on
any change on the on the access point so
if things get connected or disconnected
we can detect that now with this event
and we can print out the name of the
operator in this example so whenever
let's say we come into a roaming
condition we get this event and we are
able to query the operator name and we
can print the new operator named note
and here we just select as another
example the first one the first access
point that we get in this kind of list
of access points and unconnected not
open we specify this ID as the
connection open so we don't assume let's
assume we have we have three different
technologies we have wired we have Wi-Fi
we have GL GPRS then we will just put
select the first one which in this case
would be the wired connection
this is just to give you an idea how to
use the API and how simple it is okay a
little bit more on development tools so
first you see we are just using the
standard JDK tools so the regular
compiler the regular IDEs you can use
any Java IDE for developing that all you
need to do is to set up a different set
of class libraries to compel against
there are some additional tools that are
targeting the application for us you're
the sea platform so after that they
could in the compilation step there's a
pre verifies that but this is not new
this is just happening since the
beginning of cldc and it's helping to
get the archives pretty small and it is
integrated with the Emmy SDK and with
the common IDs so to summarize cldc
eight as a new GSR it contains
long-anticipated updated updates to cle
see which aligns the language and the vm
with se8 features with a couple of
examples for leave for loops boxing
generics Roger had all the details
already we also do a library update with
an extended collection subset we have
tried with resources we have new I knew
I oppa first the service loader and a
couple of other things on the plate we
are consolidating the GCF connections
plus the multicast connection and a
couple of extensive like ipv6 and
connection options and the tools and
support for embedded and mobile
platforms are being worked on and are
available so a couple of references and
things that also happen during java one
this week so the first one is the JSON
360 page on CL dc-8 this is just knew
this just happened today so go to the
JCP but org and look up the chase or 360
that's the specification
we are working on if you are interested
to help here please join the expert
group please help us to get out what you
want and to develop what you need
there's a couple of other presentations
happening this week like the Java me
service platform i think that that was
this morning there's also on the IM p
dot next icon 3984 that's on the other
jays are the embedded platform and a
couple of other interesting talks i
guess that completes the presentation
and now we are open for questions and
suggestions are there are there any
questions
just to follow up so I understand the
question so you say a higher level
developer you developed right we'll keep
up right yeah so one of the things that
that I mean there are many developed
java developers on in mobile devices in
especially in android and they have a
very robust platform on smartphones for
large-scale very functional one of the
observations that the is that there are
still more feature phones being sold in
smartphones so there's a big market for
feature phones but they obviously have
more constrained devices less memory you
know Nokia's got a set of new phones
that run from 300 megahertz to a
gigahertz but still memory constrained
you can write applications that look as
good as any smartphone application with
this platform but you have to be a
little bit more careful about just
throwing stuff in and I so I think
that's court sort of why you care is
there's a big market out there there's
been cheated big market out in in mobile
phones Oracle actually thinks that
there's a much bigger market in embedded
devices which have quite a few greater
variations in terms of what's available
in device and what kind of you I there
are but they're everywhere they sort of
hide in every corner that you can
imagine so this platform these api's
should you know will be available on a
lot of smaller devices and a big piece
of it is also the end end story when you
build as these days you don't just build
a single app in isolation it's always
coupled to other pieces so this is just
you know targeting the smaller end of
the you know all the way out to the I
guess the Internet of Things is the
buzzword but it's very large scale
yes please
okay so two questions so CC was sort of
less standardized maybe about five years
ago as a subset of java SE one dot five
and the with the recent updates to java
SE seven instead of updating the cdc
specification to grow it the if you may
have heard in the keynotes last night
the objective is to take the full java
SE stack and layer it though that
there's a you know a 10 megabyte runtime
that you can use in embedded devices so
I think we're simplifying the set of
platforms that's available by bringing
more power of the java SE down to the
embedded space and growing a bit of java
of cldc in to meet it now one of the
some of the essential differences in
cldc that are not in the upper level
api's have to do with class loading
there's there's no visible class loaders
in cldc there is the security
infrastructure is quite a bit simplified
you know all the code runs in a single
sandbox and it all has the same set of
privileges whereas in java SE e there's
the the security mechanisms are far more
robust but you can have some code have
more privileges than others but it you
know the constraints and limitations in
cldc were designed in so that we can fit
it in smaller platforms things like
reflection there's actually quite a bit
of overhead and reflection of every
class that you now we found in some
other projects the jax-rs API that
Michael talked about this morning the
way that they've implemented the
serialization and deserialization of you
know plain old objects really can use a
piece of reflection that's not that's
not today there in cldc so this is sort
of conflict between more functionality
and more space that so so on the second
part of the question about dalvik i
think oracle and sun have a robust very
capable virtual machine technology I
don't say we don't need what dalvik has
but it's got some good features but it's
really sort of below
covers developers don't directly deal
with dalvik you deal with you know
writing Java code and using the tools to
compile it and then you know the rest of
the mechanism works that way so I mean
daleks a good vm it does does what it
does very well hot spots even better at
this end of the scale though I mean the
the Monte vm which has been I guess it's
probably five years old it's been
constantly improved and the again you're
making space-time trade-offs so there
there isn't memory space for all the
code to do really sophisticated
optimizations but with some trade-offs
it's a good compiled Java compiled
bytecodes the native code and runs it
very effectively if I may trust up one
thing so going back a little bit in the
presentation to the previous slide to
this one so if you look into the
positioning of Java EE where we have one
to ten megabytes that's a pretty small
footprint actually so you need to have a
highly optimized footprint optimized km
that can be carried on this kind of
pretty small T versus I think even
though actually that leaves the the
architecture slide it had all the
optional packages on it the sort of a
fully loaded mid p mobile implementation
was around was under five megabytes in
that range so there's a lot of awful of
functionality that you can put in a in a
small footprint but it's not the same
functionality today as is in java SE and
that's one of the things we're trying to
look at more closely is can we get more
of the SE functionality into the end of
smaller footprint so developers don't
have to compromise your spine
well I guess that's a question of what
kind of mobile device we're talking
about whether it's a small traditional
phone or a smartphone and these are
completely different segments right and
it shows up I mean I hate to go
Americans they hate you but the most
recent example I have is the the you
know the Nokia series of a chiffon
chiffons that are you know thirty
dollars no subsidized you know over the
shelf you know that's the total cost of
the phone at 300 megahertz and some
memory verses one hundred twenty dollars
for a gigahertz so you pay in the US the
merchandising you know marketing schemes
actually they roll a bunch of the costs
into the subscriptions so you don't see
quite as much of the cost in Europe you
know you by your phone up front flat out
so you know a thirty dollar piece of
hardware that's very capable it's just
kind of an amazing prospect so yeah
another question well obviously actually
the RAM requirement is mostly depends on
the what kind of application you want to
run the minimums are well there has been
some proof of concept which is really
pushed the limit there and i'll get to
that back in a second but the think the
jsr says that you need probably quarter
of a megabyte you know fair i think
fairly modest hmm yeah but i mean if you
think of it it really depends a lot on
the application you can write hello
world that just prints a string without
very much ram at all if you now in
general i would guess that typically
you'd have a megabyte or two of ram you
know just that's a lot more useful sighs
to you can build a real application with
that mantra memory so that's a typical
pluck foam right what's that one that's
the in the carport with a 128 kilobytes
of RAM
but internal memory so they also have
two megabytes of static Ram externally
it depends really as Roger said on what
you actually want to do and what kind of
yeah that's true a lot of the the high
integration stuff the sort of there's no
point putting a little bit of memory in
there because you don't save much of it
part of the updates here are targeting
the embedded space where the volumes you
know the device is a little bit more
specialized and depending on you know
there may be a little bit more sensitive
to cost because they have to pay it all
themselves but we actually I mean I kind
of expect that most any kind of regular
device to have a fair amount of memory
and it all comes
right so on the first point about
Hardware debugging there is i mean the
the missing piece and actually it's not
that missing it there we have quite a
bit of support for debugging on-device
debugging already it depends on some
software features in the in the vm and
the particular vm on the device that
have to be dynamic you know in usually
they're only enabled in developer phones
because they actually they pose a
security risk for them being in the
device but the all of the infrastructure
around you know NetBeans and the tools
and the agents gets down real close to
the device and and the pieces are in
place for to debug many devices were
directly on the device and that's that's
one of the efforts that's being
instigated on this I think I missed your
second point about right so this the
reason that there's a separate profile
for mid p that includes more application
AP is in the AMS the application
management stuff a little bit has to do
with the desire to have a small Emmy
specification that is a strict subset of
java SE java SE does not have some of
the you know it doesn't have application
management functions there you know it's
one of the areas that we're going to try
to push them toward having a way to run
applications and install applications
some of that actually is built into it
was built in plan for jigsaw because
with a module system essentially an
application is a module it has
dependencies it's installed into the
local module library it loads its
dependencies from the repository so what
java SE hasn't really gotten to the
point where they have an application
management infrastructure and when we
get to that point
look at building that into the cldc
profile it keeps it the sale DC spec a
bit cleaner if we can say it really is a
strict subset of java SE and the things
that we have to add for the mobile
market or the embedded market really at
least in terms of the specifications are
separable identifiable components the
the products that are offered obviously
have all the stuff you know lump
together it's you don't just get you
know this piece and that piece and you
have to put them together yourself you
get you know the like the oj oj w c
which is the Oracle Java wireless client
it comes with full support for the
entire stack and optional packages and
links into the SDK for debugging so it's
it's more the products are more fully
functional than the specifications as
both specifications are a little bit of
trying to be clear about particular
pieces of functionality that are
separable and modular okay i generally
oracle have been more than sun has been
pushing toward you know complete
platform definition as you know as a as
a big unified piece and we're headed in
the same direction as well yeah for i'm
sorry for which for Jason there is a
java ee there is a JSR in development
for Jason it's being developed under the
Java EE initiative they originally
started that jsr both we and the folks
in java SE have been looking at it to
try to make sure that it's usable not
just in the java ee context we spotted a
couple of things in the in the in the
API that we think just wouldn't work on
Java ME and
like references to bigdecimal but on the
whole adjacent jsr was you know it
looked pretty good it was it's maybe a
little more votre boasts than we would
have designed it for just a Java ME use
case but and I don't remember the number
its I don't recall that um not probably
without modification I mean it's in them
it's there at early draft review i think
they recently put out an update it
currently has a dependency on bigdecimal
and that's something which we've nobody
an emmy has told us they need so we've
haven't stuck it in it's a pretty big
piece of i we need to work on that
because Jason I mean I I I see I thought
of the direction you're going there
which is really need Jason and you know
both embedded devices and mobile devices
to be able to talk that to the server
and there's no reason it should be a
different API I mean we might have to
subset it I mean for Emmy we have four
years had to take existing SC AP is and
prune them to the point where they would
run on Emmy sometimes that pruning works
better than others both Michael and I
have sort of been working to try to say
well why can't you just make it you know
the original API be usable across the
whole scale but there a lot of the in
every layer sort of has its design
center and the things that they wanted
to do that integrate it with the rest of
the components in that layer and that
makes the design more complicated it
sort of you turn a one dimensional
design problem into a two dimensional to
design problem with it sometimes that
complexity can't you can't be motivated
um well I think on this device we ported
we've ported Java to several brew
devices over the years I mean I think
and it just it runs on top of the brew
api's I mean I probably don't have
enough detail to answer you know a very
deep question there but like any other
sort of run time in a device you can
build java on top of it if you can get
to file access you've got some
cooperative even cooperative threatening
or processes if you're really lucky
porting Java on top of those devices is
you know it's work but it's there's
nothing basic the intrinsically missing
I'm ready yeah okay okay so so maybe we
could us take the questions offline and
connect it to the right people right
yeah if you'd like more depth we can get
you get in touch with the right person
who did this did the port okay right so
clearly with java SE the future of you
is is javafx and you saw in the demo
them running javafx on top of SE
embedded on that kiosk which is actually
there's one out here yeah looks really
good works great the engineering folks
in our that are working to try to figure
out how to scale javafx to down to the
scale of sort of what the space that was
held by lewitt which was this third
party sort of add-on package pretty flat
you know flexible and and used a lot of
functionality in it but we haven't quite
obviously FX has a lot of very powerful
mechanisms components the way that they
render things in order to find that find
a mapping of that down to you know the
300 megahertz device with no jeep well
probably might need
GPU that's work in progress I don't know
how it's going to come out but
conceptually I can see to me it seems
like the obvious solution that we've got
to pursue but if there's some
engineering challenges there all right I
think well we probably have time for a
few more questions but we can do them if
bus formal setting if you want so thank
you very much appreciate coming today
thanks Allah</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>