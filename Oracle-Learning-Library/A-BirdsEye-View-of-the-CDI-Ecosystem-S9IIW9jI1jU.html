<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>A Bird's-Eye View of the CDI Ecosystem | Coder Coacher - Coaching Coders</title><meta content="A Bird's-Eye View of the CDI Ecosystem - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>A Bird's-Eye View of the CDI Ecosystem</b></h2><h5 class="post__date">2013-01-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/S9IIW9jI1jU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is reza rahman I used to be an
independent for a long time i'm the
author of ejb3 in action of course as of
two days ago i am now in oracle employee
as you can see I'm wearing the oracle
shirt i'm an event now i'm an evangelist
for glassfish weblogic in java ee the
java ee have set of family of tools if
you up or family of technologies as
oracle employee i am told i have to show
you this particular screen essentially
what this is saying is that you know the
stuff that i'm talking about that not is
not yet released yet which there is a
few things that i'll be talking about
that still in beta phase is not
necessarily final and whatever i say
here is not necessarily a commitment
that you know that's exactly what's
going to happen for the most part i
don't know what the purpose of this is
beyond oracle trying to cover its but
it's very end in case somebody Sue's
them okay so our first and foremost a
bit of a CDI overview of you will so CDI
as you may or me as many of you already
know is a next-generation dependency
injection standard for java ee what it
basically does is it takes the best of
breed ideas that have been out there for
a long time in the seem to juice and
spring communities and try to collate
them in em in a standard fashion and in
its in that process what CGI also has
managed to do is a common put some
pretty pretty nice innovative features
for those of you who are not familiar
with the outright Gavin king was aspect
lead for CDI one point of Pete mirror
and other gentleman from from Jay bosses
now respectively so the primary focus
philosophical focus of CDI is primarily
loose coupling which of course is host
common to all of the DI mechanisms
that's one of the de facto reasons why
you would want to use di in the first
place is loose coupling however unlike
say seem to or even spring or rather a
spring and rather and perhaps seem to
and more like juice CDI does focus on
Java Cindric type safety quite a bit so
it's really very very xml
a verse and more geared towards
annotations and Java type safety as
opposed to anything else as you will see
another focus of CDI has been from the
get-go expressiveness and ease of use so
what that really means is that they're
really taking care of making sure you
know the constructs that are NCD I make
semantic sense when you write out the
code as well as it's easy to use
primarily we are focusing unusable t as
well as intelligent defaults so the
point of this talk as I mentioned is not
necessarily teaching you CDI 1101 one of
the primary goals of CDI really beyond
simply adding dependency injection to
Java EE is better fostering an ecosystem
around Java EE and I'll tell I'll tell
you a little bit why that is and this
particular talk is really a snapshot of
what is going on in the CDI ecosystem my
you know I don't personally consider
this talk very technically in depth it's
really a talk where I'm going to tell
you what is going on you know in the CDI
world and my hope is that you know
you'll get interested or interested
enough to dig into any particular areas
that that you want to look at yourself
okay so a quick look of CDI before we go
to too far basically as i mentioned CDI
is primarily a set of annotations there
is a there's a basic dependency
injection annotations or that should be
familiar to most people who have india
at doing di for a little bit at injects
pretty self-explanatory add qualifiers
is essentially narrowing down the scope
of what's getting injected Union in any
particular injection point name disc for
component naming stereotype is very very
interesting initially is going to be
subject to more innovation as of java ee
7 stereotypes are a way of creating meta
annotations so it's a way of grouping
together annotations you know NM in a
somewhat component builder fashion so
literally you are defining what it is
that you want your component to look
like in your application very very
powerful t-shirt at alternative is
necessary and very very useful for
things like mock testing and when you're
deployed in
when you want your application wiring
changing from one deployment to the
other it's as it specifies a deployment
specific components produces and
disposes is very very similar to for
those of you who are familiar with see
that are i guess i'm more more
pertinently c++ on the destructors and
constructor syntax of off c c++ what
this allows you to do is instead of
relying on CDI to figure out what beans
you want produced and created injected
into your container and destroyed you
have programmatic control of that you
know when you need to when you need when
you need to set sort of like a escape
hatch you know your escape hatch into
the world of the CDI container again
very very powerful feature very very
useful context management essentially
really means scoping okay so these are
the scope types that are in CDI
dependent is is equivalent to your java
news essentially an object is created
every time it is injected requests coped
as you can imagine it is the direct
equivalent of the servlet request
request scope similarly session scoped
conversation scope is very very
interesting if you're not familiar with
it so basically a conversation scope is
you can think of it as a session
demarcated programmatically so you as a
developer can say you know this is where
my session will end start and this is
where my session will end extremely
useful for things like for example
multi-step work gloves in your
application application scope again is
very very similar to the notion of
application scope in in java ee or serve
in the servlets back in addition CDI
also has lightweight events and and it
does lightweight events in a very very
unique in n type safeway there's two
particular artifact said that that
enable this one is the event interface
and the event indicates essentially
allows you to fire any objects as events
and the observes annotation on the other
hand you know basically whenever you put
it in a in a java method allows you to
subscribe to any event of a particular
type interceptors and decorators as you
may already be familiar with is
essentially
Java is idea aspect-oriented programming
very very powerful and also very very
easy to use considering how what a
complex concept aop is to begin with the
other part of a CDI that often as a
developer you won't think about is
something called a portable extensions
API and this is rather unique and
deliberate in in CDI and frankly the
foundation of today's talk so the CDI
portable extensions API is literally
speaking a set of AP is that allows you
as a component developer or a library
developer to interact with the CDI
runtime ok so I'll talk a little bit
more about what this means but for you
as a developer what this means is that
you now if you want to use a portable
extension say an extension to CDI all
you as a developer need to do is simply
take a jar file drag and drop it into
your application and that's it
everything was so configured for you
it's just like your windows you know way
back USB right the promise of just you
just plug it in and that's all you need
to do for the most part that's true
similarly this is a similar concept for
CDI a bit more on that I I want to talk
about the motivation and the details of
portable extensions just because it is
so central to this particular talk you
know first and foremost that the CDI
portable extension is the concept is a
very profound concept that you know
Gavin kind of thought about and said you
know how do I solve this particular
problem that you exists in Java EE and
in the job I ecosystem at large and you
know what is the best way of solving it
so the problem statement here is that
not everything can and should be
standardized you as a developer you know
for your particular application I have
any needs that are not common to anybody
else right and there are solutions out
there that are just not mature enough to
be standardized good examples today
would be no sequel right you know you
want to use no sequel in your app
vacation you know if you have needs that
are not acid simply not relational
database centric yet you know the no
sickle solutions in the new circle
community is high so highly specialized
and fragmented that there's no realistic
way that that can be brought into a
standard by bringing all these guys
together and say hey you know you find
out what if whatever your common
features are because these today you
know the non-secure community is
striving because of the fact that they
are so highly specialized in their own
niches I'm similarly standardization can
and should take time okay so before I
say that let me also tell you that as an
Oracle employee one of the things I've
been pushing for is regular regularly
scheduled releases for java ee in my
opinion two-year releases are reasonable
for java ee anything more than that it
is a bit much and honestly uh I don't I
don't like the fact that there is
there's an hour gap of almost more than
three years you know between Java EE
releases however asked the reality is
standardization can and should take time
the reasoning for this is really
something like this so first and
foremost you know in a standards body
it's it's always going to take a bit
longer than you know a a single vendor
coming up with their own api's because
now you have to bring you know various
people together that may not may have
fundamental ideological differences
about how to do a certain thing and it
takes a bit of time a bit of churn for
all of these people to agree to do that
um as opposed to just writing an API you
know the standardization process is a
process right so there's you know
there's additional artifacts that you
must generate beyond just working
software and some documentation for
example the reference implementation TCK
specifications and of course the
specification itself so those are our
built-in fax or of standardization in
addition to that and this kind of goes
back to the previous point that I made
it you can't standardized quickly if you
standardize too quickly what happens is
you wind up stifling innovation for
example again let's take the convenient
example of no sequel
right so if if somebody were to decide
in java ee god forbid that we now need a
no sequel standard so em they somehow
let's say agree to you know get a few of
you know of these no sequel vendors come
to the table but a subset of them to
come to the table because it's so image
thus the concept is so immature and come
up with a standard what this happens is
if this standard actually succeeds what
will it do it will wind up stifling the
other ideas you know that are out there
that don't confirm exactly to the idea
of the standard and we've seen this in
action right we have seen this happen
with ejb two ND t beans where there was
a better model with top link there was a
better model elsewhere persistence model
elsewhere that it really should have
been more mature than sterilizers books
to the hurried implementation are BJP to
entity beans so given these two facts
you know how do you reconcile this
problem okay so does this mean that you
really can't use java ee at all i
clearly that's that can be right right
that's not the right answer so the
answer really is to make java ee more
extensible and plug-in friendly okay so
in other words make it easy for you to
use things that are not immediately
standard but by fully leveraging the
standard component model the standard
api's and that's exactly what the
portable extension mechanism is supposed
to be okay so if you're using if you
have a non-standard solution out there
all you really need to do is develop a
portable extension to it that works
seamlessly with CDI drop that extension
into your application and lo and behold
now you're in harmon-wright you're using
java ee but you're also able to take
advantage of feature x and y that now is
not necessarily part of the
specification has over yet it's the
portable extensions api you as I as you
can gather is primarily for vendors and
plug in Rikers so you as a developer I
don't expect you two to know the ins and
outs of it although frankly it is handy
to know it
it's a it basically allows you almost
full control literally almost full
control of the CDI runtime you can do
absolutely anything that you like and
I'll give you a flavor of this in the
next next slide so this is how the
portable extensions SPI at a high level
looks like you have a set of container
events that you can listen to and add
each of them during each of these events
you can create metadata that is
meaningful to the container so what is
meta later that's meaningful to the
container things like beam definitions
meaning object definitions things of the
container ships can decorators
interceptors stereotype definitions any
kind of artifacts that are meaningful as
metadata in CGI world you have a nano a
literal object for to represent that
data so if you want to add a new beam
type you create a new beam type and you
register it with CDI in an appropriate
event at at at an appropriate time in
the containers lifecycle and you also
have something called the beam manager
API and literally this is your your API
into the CDI r online but this is the
guide that will say ok register a new
beam type remove this beam type look up
this beam type fire this event so on and
so forth anything that you can do in CDI
is accessible via the beam manager API a
little bit more of the about the events
to help you understand what what what
this thing actually is so here are some
on the events actually these are all of
the events on this and in this slide in
the next slide representing all of the
CDI portable extensions yeah folks that
you can you can plug in into so there is
before beam discovery and this event as
you can imagine fires before the
container scans for beans this is a
great point in this is a great time to
add you know things that are that are by
default not in your application but you
want to add it as part of your portable
extension or your library for example
qualifiers scopes stereotypes
interceptors and annotated types
similarly after being discovery you know
that this is the
obviously pars after the container has
knows about all of the beans that are in
in that application you can also do
things like register additional beans
additional interceptors additional
decorators additional observers and as
you can see you know i'll give you just
a minute to scan through this you'll see
that you know it basically this is a a
hook into you know each phase of the
containers life cycle and it's allowing
you to do very very powerful thing so as
a as a library developer and directly
interact with the CD i run time so i'll
just give you just a minute to scan this
okay so I hopefully how happened over
Romney already living stopping and just
a scared you had do it does anyone have
any questions at this point where are
you okay yes yeah
now they're going into that one the plug
single deployment unit yeah yep okay I'm
so as I mentioned you know with that
backdrop and a little bit of background
knowledge about portable CD SCD a
portable extensions let me now tell you
how the CDI ecosystem look like looks
like and frankly this slide is probably
the most important slide in my in my
slide deck so there are implementations
there are extensions namely portable
extensions libraries there are runtimes
that support support CDI and there are
two development tools that you need to
use in your day-to-day development that
are primarily based on CD I portable
extensions so in terms of
implementations you have three primary
ones right now jboss weld which is a
reference implementation candy and open
web beans i'll talk about those in just
just a few seconds and i take care of
there we go we have the CDI portable
extensions ecosystem okay so right now
these are meta projects projects that
have groups of large groups of these
little portable extension libraries the
most important one at the moment being
seen three there's also a patchy Cody
okay that's part of the my face this
project but again a set of portable
extensions and that I'll talk about in
just a second apache camel for those of
you who are familiar with it are
actually and those guys are actually
baking in CDI support right into Apache
camel say you can drop Apache camel
anywhere and you know lo and behold you
can start using it with with your CD I
beans right away because they've
developed for FC di portable extinctions
the same is true of rest easy the same
is true of ghouls seen as two of here
ERI which if you're not familiar with
that it's a GWT solution for java ee
from jboss and yet again you know
they've defined all of the GWT and CDI
integrations we are portable exchange
extensions api baked right into the
project there is something called as EK
framework i think it's a very
interesting use case so i actually have
some additional slides on ZK you know
towards the end the end of my
presentation on the run times as you can
see our
as you can imagine obviously all of the
CD agile ie6 containers right glassfish
jboss resin Geronimo weblogic websphere
and the like but you can also use CDI in
things like java SE and pure servlet
containers for example jetty Tomcat and
of course java SE ok so our CD i can be
run in all of these runtimes in terms of
tools i'll talk to these up a bit more
arcania nizza is a testing tool j bar
stools as a as an eclipse plugin and
I'll explain why that's necessary
netbeans Forge is a very interesting
rapid application development to for
java ee 6 Eclipse and IntelliJ IDEA of
course so as I mentioned there are three
major implementations of of CDI at the
moment first and foremost is a weld it's
a reference implementation from jboss
again originally developed by Gavin king
and the world is included as a CDI
runtime in glassfish weblogic and jwoww
says you know and of course world also
has extensions for tomcat JT and java SE
so you can use weld in all of those
environments and weld also has a few
additional features of baked into the
reference implementation all of the CDI
implementations generally have avoided
doing that and really have made a
conscious effort to make any kind of
extensions as portable extensions api is
separate and apart from the
implementation however well does still
have a few of those open web beans is
the apache implementation that's
included in Geronimo and websphere I
think open web beans in my experience
that has slightly better performances in
world but not anything earth-shattering
early again open web beans has really
good integration with tomcat and open e
JV as a matter fact are very interesting
every project that I find very very
interesting it's something called Apache
Tom EE and what this does is it takes a
plane Tomcat and adds open ejb adds open
web beans and a few
the repetitive projects and basically
cobbles together at java web profile
compatible container and they've
actually certified this container
against a TCK so very interesting i
think again open web beans drums in java
SE as well in addition to tomcat
energetic the third implementation is
candy which i actually i used to work
for these guys interestingly enough
candy is actually the basis for the
resin application server so the resin
application server score was rewritten
to be essentially a CDI application I
think resin is actually the largest CDI
implementation out there everything in
resin it's really CDI beans it has also
has built an XML configuration so resins
XML configuration is also just CDI
syntax exact CDX and text so you when
you open are presumed or XML you'll see
qualifiers and things of the things of
the like baked right into resin zone xml
configuration and and that again by
virtue is by virtue of the fact that
everything resin is actually CDI the
other interesting thing that that resin
provides is it allows all CJ's ejb and a
service level annotations like a crown
where transaction attribute at a
synchronous at scheduled to be used in
plain city ID as opposed to each IVs and
I think that's the model that we're
trying to push for java ee 7 and java ee
ate it all so on another very
interesting feature of candy and lesson
is that it allows for CDI integration
with PHP so you can run your front-end
Ian in PHP and it interprets it as a
Java Runtime the terms on the app server
and you bye-bye elu can reference your
CD I beans so you have PHP as your
frontin and java ee as your back in and
do the one and only significant feature
that of well that i wanted to show you
beyond the specification is the support
for SC as i mentioned you know in the
earlier slides it's actually done in a
very interesting way so the way AC
support in world works is it were uses
actually use a CDI observers so all you
do is
in your application you have some code
that looks like this you listen you
observe the container and initialize it
event okay and that initializes when the
JVM starts and you can also get things
like command line parameters we are at
parameters and then just you get a list
of parameters just as you would in
public static void main and then lo and
behold whatever you do whatever it is
that you need to do beyond this API
though don't worry for those of you who
don't really want to follow this model
it does have just a regular old API that
says well dot start and Well dot stop
and Well dot deploy an amulet okay and
let's move a bit more into CDI
extensions if you will and now before I
before I go there anybody have any
questions on implementations so far all
right okay so as I mentioned that the
three major groups of CDI extensions out
there right now are seen three apache my
face is cody and built and CDI supports
in miscellaneous projects so as seen
three is a basically a set of portable
exchange in jars independent completely
independent of j buffs and well by the
way and but there are seen three Umbriel
releases and what this is it's a
conglomeration of all of the portable
Egyptians API is given to you in a
single really single jar file well
that's a little annoying okay um then
then as I mentioned this there's the
Apache my face as Cody project again
these are CD extensions somewhat closely
aligned to open web beans in my faces
but not really and the nice thing about
apache my thesis cody is that it's
really quite modularized perhaps a
little bit better model verizon seen
three they're a bit more configurable so
you can configure some of the behavior
whereas most seem modules really are not
that configuration heavy at all then
they really just use very heavy
defaulting also another nice feature of
of apache my thesis cody is that they've
made the portable exchange
themselves extensible questionable as to
how how useful that is but you know it's
a rather at least an interesting aspect
given of my thesis Cody other than this
as I mentioned at the other class of CDI
portable extensions is really everything
else okay so all of the guys that are
building a building CDI support as part
of their project as opposed to depending
on something like seeing three or Cody
and really this is the ultimate goal of
CDI portable actions and this this is
the vision that Pete and Gavin really
have is that they shouldn't really be a
scene 3 there really shouldn't be a
patchy Cody maybe there is a need for
these things but really the ultimate
goal of CDI portable extensions is that
the various open source projects really
built CDI support in into their into
their own projects so good examples of
these again are ZK rest easy camel or ER
I'd rules and so on to give you a bit of
flavors of what a what is inside the
scene three modules this is a list of
them on this a table and the table after
that and the table after that so as you
can imagine you know quite a few there's
quite a few of these I'll talk to a few
of them and in the subsequent slides
I'll show you good examples of some of
these things so solder is general in
enhancements to CDI it's enhancements to
the programming model that's useful to
third-party writers there are some
logging in there there is an enhanced
injection like for example injecting
property files and the like excellent
xml configuration is really just that
it's xml configuration for CDI the for
those of you who know this basically CDI
is rather bias towards annotations and
the spec doesn't really even define xml
configuration but if you need xml
configuration the xml configuration
module is there for you as part of seem
there is a persistence module that I
again is rather interesting it does
exactly what what the resin does namely
that it allows you to use the ejb
transaction attributes outside of ejbs
as well as defines
its own transaction annotations as well
things that are actually being defined
in java ee 7 now as part of the standard
so it's a good proof of concept the
faces extension is very very useful jsf
enhancements I highly recommend this one
honestly speaking if you're if you're
using CDI there's some very very nice
things in there are things like a better
parameter initialization or page
initialization multi field validation me
an injection support and in converters
and validators and the like you know so
definitely quite a useful useful module
I think JM else in tradition also a
panel so this is basically taking the
GMS api and making it simpler in the CD
i will i'll show you an example of that
this is actually exactly what's getting
largely standardized as part of GMS too
if you have seen seen those examples
jax-rs again useful set of eight in
enhancements for a rest namely you know
beam integration with bean validation
easier definition of rest exceptions
things like templating and so on and so
forth i'll show you examples of those as
well and again some of this not all of
it but some of this is getting
standardized as part of the XRS 2.2
remoting is very very interesting as
well i've used this myself this is
javascript promoting so you can take a
CDI bean and expose it to javascript
okay so yes i mean this is what people
are doing now in web socket and then you
know they've they've had seen seem
remoting for almost two years now and
you could do already do this you could
invoke so recite CDI managed means from
javascript there's a higher level
security api basically this is a sort of
mirrors what you would have in your
container so enhanced support for ldap
and in ldap integration and open Sam
Olens and the like there's a
international module there for those of
you who are interested in
internationalization and localization
this is basically what the seam
international modulus bug mailers
javamail integration again
simplifications of the java api in CDI
i'll show you an example of that
on their scheduling namely integration
with quartz JDK timer an ejb timer
there's document generation basically I
text as you can imagine in enhancements
to servlets which is again very very
interesting so this bridges allows you
the injection of certain servlet objects
as well as allows you to write in
filters and an event listeners servlet
event listeners as CDI observers there
is a wicked integration seem to be
backwards compatibility integration as
well as spring interoperability this the
spring interoperability be sexually I've
had quite a bit of recently interesting
so what this allows you to do is that if
you have an existing spring application
or you want to use a spring module from
from CDI or java ee ee this module will
allow you to inject CDI beans into
spring means and vice versa so you can
take swing mean and beans and inject
them into CDI jcr for those of you who
are familiar with that term java content
repository in tradition so things like
jackrabbit and whatnot can be integrated
into CDI our reports generation and
namely jasperreports and then one other
that i'm not really remembering jbpm
integration in jboss CSV introduction
Louds integration namely Jake loves and
Anthony spin at this point as well as a
social social media plugin which are
currently support twitter linkedin and
facebook any questions on on any of
these so far yes sir yes so yeah you can
basically bundle them either in your ear
lip file or women Philippa
precisely yeah it's just it's just like
a library file um or any other questions
me I think you'll get here called the
bet again alright so some examples this
is a.j bus logging examples included in
in jboss world so this is how our
logging looks like in the weld NJ bus
world so you define loggers in such a
fashion and that's just an interface and
then you can specify your log message by
and simply annotating methods on on that
interface and you can specify parameters
as I have in this case with the % s and
the percent 10 f and those are
corresponding with the to interface
method method parameters and the way you
would do log in then is you would simply
inject an account log and of course JDK
at the jaw jboss logging will do its own
magic to figure out that you get a
properly implemented at home login here
you can specify what category it belongs
to you can specify you know what locale
you want the logger to be n and suddenly
your log statements instead of you know
very cluttered strings all over the
place becomes something much more
object-oriented like something like log
over turn with the account number and
amount will ultimately end up in a log
message like this I think it's a very
interesting concept as I mentioned this
extended resource injection and built
into a weld as well so you can inject
things like any any resource as a URL
any resource as an input stream even
even a property fryer filed from your
class from your class pop a programmatic
um injection is also extremely helpful
so this is where you don't need to you
know figure out okay where do i get my
yearly evaluator from you can simply
inject your yearly value occur via at
inject expression and then you can use
your
expressions in within your application
wherever you need to seen xml
configuration this is an example of it
I've seen xml configuration um I'm
actually personally a very big fan of I
really I really like the way it's done I
think it's done in a much more
object-oriented inika and concise
fashion than your traditional like
simple configuration so let's take a
look at a use case so let's suppose you
have a mail sender and this is your you
just have one plus for your mail sender
and it simply sends out an email to a
configured email address I have
specified two different qualifiers here
and i'll use those qualifiers in the
subsequent slides on the two qualifiers
as you can see our admin and support
okay so i want essentially i want i know
that i need two different types of mail
centers one for admins and on the other
for support so the problem with
traditional annotation base
configuration is there is no way to
redefine this particular object with two
different configurations because what
are you going to specify you can only
specify one of these qualifiers to these
guys not both so the this is where
seemed xml configuration ground comes to
the rescue so let's forget about this
bit of semantics in you know and leave
it for a little bit later i'll explain
what that is what is happening here is
that I'm taking my mail sender object I
have two instances of it both of them
are application scoped and I'm setting
the email property differently in a
neither of these two instances so in one
case it's admin dot acne bank and the
other cases support to attack me back
and the way I am differentiating these
two object instances is by specifying
those qualifiers so I'm placing the
admin qualifier here in the support
qualifier here and when when i get to
injection i can simply i inject the mail
center and the way I'm differentiating
which mail sender i want is again via
the qualifier that i placed on that
object so going back you know imagine
how this would look like in your
traditional xml and how this looks like
instead okay this is very much like your
your java objects very familiar scent
X and very very predictable syntax and
the way c maximal accomplishes this is
by matching java object types with XML
namespaces so seem all of the same
objects annotations are or rather the
CDM trations are all in the same
namespace whereas in the Acme namespace
I actually have all of the objects in my
class path that meet this this that have
followed this package name and that's
how I'm able to use the syntax and refer
to my objects in such an object-oriented
manner okay now here's a bit of a
confession here because i joined oracle
a couple of days ago I I'm really
supposed to put all of my slides in the
oracle format I i was up until 3am
yesterday doing this as you can imagine
running around java one so i haven't
converted all of my slides so the rest
of the slides unfortunately our head are
in my independent consultant
okay so these are the sort of the
servlet integrate servlet API
integration that that I was talking to
you about this is basically allowing you
to listen to servlet events like things
like servletcontext initialized on
session lenient initialization and even
on request initialization VRC di
observers okay much cleaner model you
don't you not don't need to implement
any interfaces or anything else like
that in your objects can simply be pojos
annotated with the ad observes class so
in this case over you know as you can
see you know we're listening to the app
initialization HTTP session
initialization and in this case we're
intercepting every request and made on
this particular path and we're getting
the an instance of the of the requests
that was actually made as I told you
this another the weld nth equation also
allows for injecting servlet objects so
you can inject things or obvious things
like servlet can fix or little context
ATP session the request but you can also
more powerfully even inject parameters
header values that are in your request
cookies and even the servlet response
this is a scene persistence fairly
self-explanatory basically this is an
ejb annotation but notice that it this
beam is not an ej v it's a simple
managed bean that is that happens to be
application is curved and you can inject
an entity manager just you or just as
you would in an ejb and this all works
and again this is a model that is being
standardized currently as part of java
ee 7 Crossfield validation is very very
very very important feature for seen
faces so suppose you have a form like
this and it's a location form you have
city state and zip the problem with this
picture is that jsf allows you to
evaluate each of these beans each of
these attributes by themselves but in
this case for this control what you
really need is you need all of all of
these components validated together
right and there is no solution for that
in jsf at the moment so what seemed
allows you to do I've seen faces allows
you to do is
assign a farmville later okay though so
this will validate the inter form as
opposed to individual fields so in this
case we have a location validated this
is how the location validator looks like
no sir no notice it's just a familiar
jsf syntax faces validator you can
assign a scope to it which you cannot do
and in regular JSF so in this case
Webster's right did this Val later is a
request cooked it allows full injection
into this and you can e of course most
importantly inject the fields that
you're validating so these guys all map
two names that I assigned ideas that
have specified on the page so city state
zip city state zip in perfume if the
names vary you can specify specific name
students and of course now you can you
know just following the validator syntax
and by virtue of injecting these fields
that need to be validated you can
basically then do you can validate the
entire form as opposed to individual
feels JSF payload for those of you who
have done JSF is a pain point so a what
same places allows is the view action a
view action component and this by
basically allows you to take any
initialization parameters and initialize
your bean before the page is actually
loaded the SF project stage integration
is another interesting concept so as you
men as I might have mentioned CDI has
its own concept of project stages
whereas JSF also has its own concept of
product stages and they don't really
integrate with each other as of yet so
what the same places modules allows you
to do is basically integrate those two
disparate walls so now you can if you're
say you're in your JSF application you
have specified the stage to be
development you can either you know in
you create alternative components that
are only enabled when that project
stages active say as for example at unit
test or add development at product
production and the like you can also
programmatically check what your project
stages by in simply injecting the
project stage seemed a JMS resource
injection looks like
this so remember to get arrived at this
line in the past you had to do quite a
bit of work right yourself so you to get
their connection grade the session
create the producer and do the send what
seemed JMS a essentially allows you to
do is get rid of those intermediate
objects and allow you to to inject the
objects that you are actually interested
in in this case that's the session and
the message producer so GCMs behind the
scenes won't take care of the rest of it
so your code can basically look like
this one liner here again very very
similar concept to Watson JMS to this is
how seen email looks like again anyone
who's worked with Java meal before knows
how difficult it is to do all of this
there is no way I was going to I was
going to be able to put this bit of
functionality and on one slide using
java the java mail API but what's email
allows you to do is make make it really
that simple is you take a message
factory you create a message from it
it's specified from to CC even use
templates in this case i'm using a
velocity template to populate your
populate your body right so in this case
on these put statements really refer to
velocity my velocity templates namely
the inline template that i have here as
well as the template that i'm reading
from a file and add attachments and the
like it's it's all just one liners using
the Builder pattern seen rest is also
very very very interesting so this is a
integration with the rest of what the
bean welchen am would rest in the bean
volution api so you can do things like
this you can specify that you want to
you want this bit validated we are the
bean validation api and again this is
being standardized as part of jax or s2
are similarly rest are the seamless TZ
client integration is very very
interesting to me perhaps even more
interesting than the client api that was
standardized as part of a as part of
jax-rs too so in this model what you do
is you take your rest endpoint and you
can literally specify the exact object
that you have on the server side in a
very
object-oriented manner and then just
call that that object it takes your HTTP
parsing completely out of the equation
it's almost as if you're doing local
development although you're still going
through rest seem remoting as I
mentioned to you JavaScript promoting so
in order to do that over here i have a
stateless session bean i have named it
and i've specified web remote and that
will expose it to javascript on the
JavaScript side I can simply then
creates a seemed or create been--but
service and that's referring to the name
here and then I can you know pretend as
though I'm in Java you know I can simply
make this method call right here there's
ways of getting return values as ways of
getting exceptions there's ways of lazy
living entity so all of those are
supported we have seen remoting a little
bit more a little bit about cody modules
um so again these are the modules that
are encoding okay so there's a core
module I can generally useful things for
CDI things like logging and the like
they also have a jsf module they also
have a bean validation module they also
have a jpa module that does very much
what scene persistence does they have a
international module a scripting module
and testing module as well any questions
so far arms on scene yes sir sure
well almost and weld is a reference
implementation which is just a CDI on
time whereas scene is is all of the
portable extensions out there in energy
into what's defined by the standard okay
and anything else yes sir yeah sure okay
so the answer is that CD I takes care of
that and metric that is what the context
in the context life cycle is all about
so when you are injecting an object
object itself is not just like what you
would get out of creating new right so
when when you're injecting the index
that object has a defined life cycle so
it may be request code all of those
scopes that we talked to drag request
session conversation dependent
application spoken and the like so the
container creates generally creates
those objects when that life cycle
starts let's say at the start of a
request and then without you having to
interfere the container will
automatically destroy it when that life
cycle ends so at the end of the
requested will automatically get
destroyed
recognizing what I'm sorry that would be
the application scope I think is what
you're looking for yeah so it will be
created when the application is created
and destroyed when the application gets
destroyed the class gets out laughs of
course we'll get unloaded at that point
ya know from a few examples that I have
in the remaining time that I have and
for some reason okay there we go all
right all right okay um and so in
remaining time that I have it a little
bit of examples of Cody so that you can
actually activate our objects by
expression if you want in Cody so you
can specify you can say you can specify
niall expression as to what when an
object should be initialized or act
rather activated seem cody has a
different take on on loggers then jboss
logger does so in case of Cody you can
actually inject java.util loggers in
just in this fashion then you can even
specify you know your login category and
the like Cody conversations are
different from sim conversations in that
same con or rather not see deceive can
receive wrong position but CDI
conversations in CDI you just have one
conversation you can't have you can't
ness conversations and basically Cody
conversations allow you to ness
conversations that's the principal
difference between CDI standard CD icon
real conversations and the one that's a
that's included in in Cody frankly I
haven't seen very many use cases right
but rather it is there for you
I'm CD i also have both actually both
seen faces and apache cody also define
additional scopes in addition to what's
available to you in standard CD I so
there is concept of view scopes that's
literally an object that's created and
destroyed in a GSF view there's view
access scope which is a little bit more
interesting so this is a an object that
is first created when you first access
of you and as long as this particular
object is is referenced in your
subsequent GSF views the object will
stay alive so very much like java
garbage collection and once you reach a
view where the object is not is not
directly or indirectly reference to any
more this object will be destroyed
there's window scoped and as you can
imagine that this is a scope specific to
windows also Apache codm and seen faces
XML allows you to use scopes that are
that are available in part in jsf but
not in CDI for example you know one the
most important be with being the view
scope cody transactions again I allow
use you to use transactions in put in in
plain managed means as opposed to ejb
cody has its own own transit reduction
ambition call that transactional network
this is exactly what's literally this is
how the job ie7 intercept CDI in
transactional intercept it looks like a
transaction another very interesting
feature that I find in Cody is is
integration with Jace are 223 scripting
languages ok so as long as you have a
scripting language available to you say
rhino in my example you can specify that
you want a script executor and and then
lo and behold in your Java code you can
execute JavaScript if you need it to you
can even use CL expressions you know to
execute JavaScript using apache cody now
um a one other projects that are just is
just getting launched right now have
it hasn't gotten very much traction as
of yet is Apache Delta spiking okay so
I'll tell you what about you Delta spike
is so as well as I went through the
slides you got a sort of a picture that
there's a lot of duplication of effort
between seam and apache cody right and
believe it or not I actually under
understated that in my examples there's
a lot of overlap between Apache Cody and
scene for good reasons right when some
so when a good idea comes along in
seemed the Cody folks are saying it and
saying oh you know we really should add
this and lo and behold it shows up in in
Apache Cody so what happens is you know
you you if you look at it from a CDI
standpoint there's a lot of duplication
of effort and potentially confusion for
the developers as well so in order to
solve this problem you know the seam and
apache cody guys very recently got
together and said you know we need to
salt find a solution to this problem how
can we do it so the solution that they
came up with is basically a joint
project okay so a joint project is
Apache Delta spike the idea is to have
commuters from both seem and apache cody
and any other groups that are interested
in developing CDI portable extensions
and create a common repository for all
CDI portable extensions there they're
just just you know launching this effort
if you are at all interested in CDI
portable extensions this is actually a
very good time to get involved in delta
spike you know because it is neutral
it's more neutral than just jboss or
just a oracle or just apache own and so
on ok dzieki framework um i don't have a
lot of time so i'm going to quickly skip
over it Zeke a framework is particularly
interesting to me it's basically an RI a
framework rich and rich internet
interface framework it uses xml and XC
well components they call it zoom oh and
it's basically creating it's just like
yes if its markup it's you describe your
uin marker so this is how sumo looks
like we're basically defining a window
here we're specifying
the window to be a window to have to be
bound to a object called hello world and
we have a guest name right here and I a
button so in your Jessa backing me the
ones that we that we refer to in in the
UI code inazuma code it's right here so
we're injecting the guests name textbox
the button as well as the hello window
and we're observing at the low button
lock on click event it's a mouse event
and then we're setting you know the the
hello window dot said tighten this way
so very very nice integration and
actually a good model or perhaps how
html5 can be applied to CDI arquillian
as i mentioned to you is a very very
very very powerful and any interesting
CDI portable extension so what arcanine
allows you to do is unit test your java
ee components it allows for in effect
what it does is it it automatically
start your container deploy the code
that you want tested inject the the code
that you need and allow you to use the
injector artifacts in your tests here's
an example of arquillian so in this case
i want to test my account service so i
mean i've injected the account service
ejb in my test i'm going to conceivably
use it in test ad account and inside of
our kelly and i can simply say okay this
is the components that I want tested
this is an alternate test configuration
that I want for this test and deploy
this inline embedded right in in my unit
test so it will start the container
deploy the thing that I want injected
and allow allow me to use the injected
component in my unit s4 for those of you
who are familiar with with the Ruby on
Rails is a rapid application development
command line based tool it's a code
generator so using ford you can quickly
create CDI job ie6 based projects you
can add jsf components or generate
jsf components you can call Jerry JP
entities from tables and the like jboss
tool is basically what Jay bus tools
does is it takes whatever support that
Eclipse has and adds additional CDI
support namely things like CDI wizards
validation quick fixes autocompletion em
the like so if you're doing a Clips
based development today unfortunately
clips as not yet to catch up with CDI
they're adding a little bit of CDI
features here and there with Juno the
current release loz as well as the next
release so your real answer to doing CDI
development where the clips at the
moment is to use jboss tools which has a
much richer support for CDI in addition
to that what I also I guess want to tell
you is that although eclipse is lagging
behind IntelliJ and netbeans is not okay
both of those IDs do have very very good
support for CDI already so again in
summary and leaving a little bit of time
for Q&amp;amp;A against EDI is an iteration
dependency injection for Java EE it's
already got a rich ecosystem around it
there is portable extensions for various
reasons he sub views better job ie
integration integration with third-party
open source tools that are not
necessarily a standard and so on and so
low so so there's tools as I mentioned
that I i welcome you to take a look at
by yourself you know rad coordination
testing ide based development and the
like and there's more on the way you
know what the hope of course off CDI
portable extensions is to make CDI quite
pervasive so that every single java
project out there hopefully has some
shape or form of CDI CDI support ok
thank you very much that's all I have
I'll take any questions that you may
have at this one yes sir
yes they are yeah Paulin Marvin crap
okay any other questions yes sir it's
available already it's wet sure it's in
West curate yeah it's all it's actually
been the for what more than three four
three four months it's Darrell it well
if you're using seven one of the
features of job CDI it's built into the
specification is support for java e5 so
because websphere uses a open web means
you can actually install work when we're
beans now as a library in your java e5
application in and it will get you get
you all of the CDI features that you
want including the ability to use
portable extensions weblogic is there
already in 12-well logic 12 not 11 now
again the same same story there if
you're using 11 just go ahead and
install go and download well be by
yourself or put it in your maven project
and you'll get CDI support out of the
box the integration is already built and
built in for java e5 any other questions
yes sir oh do you mind if I go over
there forcing sorry you let it question
no well you're welcome yes sir
okay so the real answer to your question
is a universal phone once a jsf will
deprecated the managed beans going
forward as a metric to this version yes
at 2.2 Oh already mentions that it's
going to deprecate managed means the
person farmers so what you're doing how
is just not sustainable person follows
however more fundamentally way if you
look at the start ringing of the CDI
programming model you'll see that it's a
lot richer than what what Jessup offers
especially in terms of injection you
know some of the features that we talked
about producers disposers much more
powerful interception model the entire
in a portable extensions programming
model so really what it means is
literally a package change for the most
part right so you replace you know a
managed bean injection with that inject
and you know replace all of your scopes
from jsf scopes to CDI scopes that's it
it's very very simple its
straightforward your users already using
jsf 2.2 with managed means it's very
simple transition to CDI matter of fact
I've done it now a couple of times
already that's it's no pain whatsoever
any any other questions ok thank you
very much in you have a good afternoon</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>