<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Today's Rapid Java EE Development: Live Coding from Scratch to Deployment | Coder Coacher - Coaching Coders</title><meta content="Today's Rapid Java EE Development: Live Coding from Scratch to Deployment - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Today's Rapid Java EE Development: Live Coding from Scratch to Deployment</b></h2><h5 class="post__date">2013-02-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Jdkv4CbdO2E" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">we ordinarily do a whole bunch of slides
and we like to walk you through a little
story and kind of show the story of how
testing really is development and how we
like to go ahead and approach our
project development from like a
test-driven perspective and that's been
been great so far this year we wanted to
take a much more technical approach so
that's what we're gonna do today the
title of the talk is today's rapid Java
EE development live coding from scratch
to deployment and that's exactly what
we're gonna be doing is a series of live
coding and some scripting and it's gonna
be very IDE based and we're gonna get
through these slides real quick because
I'm certain that through the rest of the
week you're gonna see enough PowerPoint
to want to kill yourselves by the end of
it at the very bottom here is a link
it's a bitly link with a session name
and through there you can log on your
laptops or your phones and get access to
the slides that we're using here the
scripts that we're gonna use there's a
blog post that details everything that
we're doing so you can come back to it
and visit it later we're gonna be
covering a lot of stuff and I want you
to be able to go through and replicate
this on your own later so we'll move
right on ahead
puck and I are writing a book along with
our colleague Dan Allen who is not able
to be with us today the name of the book
is continuous enterprise development in
Java and the motivation behind it is
that we've seen a tremendous number of
books written for different spec
technologies there's books on CDI and
books on the e6 there's the eg b3 one
book that I did a couple years back but
there's really nothing that kind of
integrates everything together we as
developers want to solve problems we
want to address use cases and we don't
want to go through and necessarily learn
all about one technology I think it's a
little bit of a fallacy to think when
you read through the EE specs that
you're gonna have an application
assembler person and you're gonna have a
web developer person and a services
developer person because in all the
places that I've worked in for the
customers that I go visit it's usually
the same people that are
doing many roles and he's made that much
easier through their local component
model architecture so we've undertaken
the the writing of this book to show how
to do a e6 development from nothing to
something out the point so this talk
today is actually adapted from what will
be the third chapter of this book where
we introduce you to a suite of
technologies and we say look we've got a
blank repo in a blank file system and
we're gonna take nothing and make a
production web application out of it and
we've got a 60-minute session today to
do it and I'm actually a little bit
concerned because I don't think it's
even gonna take us that long so we'll
get started I suppose we should meet
some of the players that are involved
because it is very difficult when you
get this blank slate here and you say to
yourself how how can I begin to start
this project how do you guys start a new
project actually even architects they're
cool any limitations yeah some
additional libraries you gotta add in
there but the maven archetypes are a
good starting point at least it gives
you some sort of a project folder layout
and a place to put things right anyone
else yeah here's what I do
or what I've done it for years I was on
the a jv3 project I spent a long time
making a pom for it and it had a whole
bunch of different configurations in
there that I like to use I like to
configure a Czech style and out to
configure my fine bugs and the reporting
and a whole bunch of other stuff and
every project I've made for the past
three years has somehow descended from
that initial file because I just kind of
copy and paste the boilerplate and throw
it all together in there and there's
also a good amount of googling and no
small amount of poking through the maven
central index to find the coordinates of
whatever it
because guaranteed I'm probably gonna
forget that
the IDE helps out a little bit sometimes
by suggesting you know what what kind of
teas to put in there but I think we can
do a much better job and that's what
we're going to show today by starting
off with the next project the first
project that we will see today which is
called jalis Forge anyone familiar with
yet cool with that I will but before
people here can tune out and JBoss Forge
is an incremental project building tool
not building from the sense that you are
building your java files and the class
files or assembling jars we need to
build the project source layout in and
of itself it's been compared a little
bit to the tools over in the Ruby
community in rails I remember I used to
go see presentations where they'd start
Rails and they'd start with a project
and they put a bunch of stuff in there
and then like Liz bangumi was done and
everyone in their hands and all I could
think to myself was like you just like
made an application that somehow mirrors
your entities and your domain objects
and you made like a crud database viewer
and like I don't know that like to me
that had no utility as a real
application or anything but I think the
part that I was missing out is that it's
it's a starting point and it's something
that's functional and from there you can
then jumpstart that and go on into other
things so JBOX Forge does a lot of the
same type of stuff that thoughts have
been comparing to spring Roo here's what
really separates it from some of these
other tools it's not just for
bootstrapping you can take an existing
project and it'll read in the
configurations and intelligently mutate
it in a way such that you can add
entities or create few layers
scaffolding from them or deploy to an
application server it's got a plug-in
architecture which means that once
you've read in the project any plug-in
that's conforming to the forge SPI can
go right in at runtime and it's actually
brilliantly implemented because it's a
modular system so you can bring in new
plugins
as you're working and they will go fetch
from a repo build them locally install
them into the current running JVM and
run because it's got this modular
runtime and everything is well separated
so we're gonna be using forward to
kickstart a bunch of our projects today
the arquillian test platform and you
want to familiar with this that's nice
it's very close to my heart and the
project lead of our Killian is sitting
right next to me are Killian is a test
platform that will give you the
component model of Java EE but for
testing so very simply you can inject
into your tests you don't have to worry
about starting a server or deploying
into it or any of these other types of
wiring bits that you normally have to do
when you set up your test harness our
Killian is going to do that for you and
we'll show you what that looks like
later the idea is really just to give
you something that looks and writes like
a unit test but acts as a full-scale
integration test we're going to be using
the JBoss developer studio ide this is
something that I've been hesitant to use
for quite some time
I do use an IDE I use plain old Eclipse
and I never personally found the utility
or all the plugins that might be put
together by JBoss developer studio
recently discovered that there's a lot
of really great stuff in here that does
make your job really easy and for the
other stuff you don't need you just
probably wouldn't use it and it's not
you know it's not doing you any harm to
have it there but JBoss developer studio
is built on top of eclipse and gives you
a whole bunch of plugins all put
together so you don't have to worry
about the versioning between which ones
you don't have to worry about getting
the correct Endon sees it's one-stop
shopping for a whole bunch of tools that
are really going to help you as a Java
EE developer and especially a Java EE
developer working with JBoss projects so
we're gonna use that today and show you
some of the integration points that make
this whole thing really kind of seamless
finally we have the open shift platform
for all of the mouth flapping
about the cloud it really is kind of a
cool thing because we can do that we can
do things now that used to be very
expensive impractical and difficult even
just a few years ago anyone is familiar
with open shift yet will show you that
today two OpenShift ultra cool it's our
it's the platform as a service offering
from Red Hat
it's free you go in you sign up you get
an account and they will give you
applications and the applications can be
of many different types they run PHP you
can run WordPress on there there's a
Drupal app you can run plain old Python
and of course the java application
server jmo SAS 7.1 and JBoss Enterprise
Application Platform and run that as
well and it's all free and it just
becomes available online publicly so
when you think back to just a few years
ago and what did it take to put your
application on the public Internet
needed to probably have a server
co-located probably needed to like set
it up or you needed to pay a company
like Rackspace or something similar for
a dedicated machine because they weren't
really sharing instances for Java
processes the same way that they were
doing for PHP or some sort of like
easier Apache so we're gonna be pushing
off to this today too and that's about
it so again if you can snap a picture of
this or see the link it's bitly on five
four five eight that's today's session
and if you go login you can get links to
everything that we're about to start
talking about and follow along and push
it up on your own and we're gonna have
some interactive stuff as we go on later
well meet when we go push this stuff
live right so I think it's time to ditch
the slides and get on in there
this is G boss developer studio for
anyone who's familiar with eclipse looks
awfully similar we get this JBoss
central view right in the middle there
and it comes equipped with this forage
console we mentioned Forge earlier now
forge is a shell
okay it's implemented as a shell you can
run it in the terminal I generally do
run it in the terminal but recently
found out that it's got such great
integration with the IDE here that it
makes a little sense to run it in the
terminal and I can run it right here so
you start the forge console by pressing
the green button is loss locks already
done and it gets us up with this shell
and if you hit enter a few times it'll
scroll down just like a normal shell
does and we've got nothing as you can
see we've got nothing in our project
Explorer
we've got nothing anywhere so we're
gonna start off and create a new project
we've got some canned commands that
we're gonna throw in here and this one
is called new project named feedback and
we're gonna give it a top-level package
name we're gonna give it a project
folder and hit enter and forge is gonna
chug away and create the initial
scaffolding and the palm for our project
as well as automatically imported for us
in the project Explorer so we've got the
whole structure already and we've got a
project in on the left and we've got a
palm kind of nice all we did is one
command and we've got all that stuff in
there for us already right so already
we're like well ahead of the curve
there's some other things we're gonna
want to set up we've got a blank project
but we want to put some JPA entities in
there Java persistence you all use Java
persistence or at least are willing to
lie about it it'll give you a whole
bunch of options for installed versions
and you know with the default to the
latest release one so we're probably
going to be chugging through here and
just picking most of the defaults as
they go through but once that's done you
see that JPA is installed and it creates
a persistence XML for you we're gonna
change one of the default values from
create drop to update create drop is
going to every time the application is
deployed and under ployed create a
schema and then drop it again you know
we just want to have it updated so that
we can maintain that persistence between
deployments because we're gonna do some
fun stuff with that data later so it
made us the persistence XML it also
added in these dependencies into the
dependency management into the
dependency section for us so again we
have to put that hibernate API stuff in
there we don't have to put the GPA and
any stuff in there it's all just right
there with that one command so that's
kind of nice
we're also gonna want to set up bean
validation don't use bean validation yet
in validation one led by a manual
Bernard came out in Java EE 6 and that's
nice because it gives us the ability to
perform to place constraints on our
entities that are gonna be validated at
the view layer at the database layer the
business logic layer just with one
declaration so we don't have to do like
this many times checking will show that
in action later too so we're gonna first
install a validation set up and we're
gonna give it a hibernate validator as a
provider of that and as you can see when
we go into the palm it's going to have
added this dependency section for us so
that's another thing we don't have to
put in there and remember about yes/no
interrupts that you're well fed so okay
so bean validation is a spec that will
validate any managed bean it's gonna be
an entity that's gonna be you see
usually it's some sort of a user input
and the validations are both canned if
they give you a series of ones that you
can already use like it's not null or
it's greater than this value or it's an
email address
it's got extensible validators to so
they're gonna use the done anything
where you're gonna get user input and
you want to make sure that there's maybe
a database constraint tied in at the
database level and also like a view
layer constraint so they can't put data
into the application in the first place
can give you many layers of protection
with just one validation mm-hmm irony I
mean hibernate will actually do that
this is hibernate validator because this
is here it will then start Tibor Nate to
when it creates the schema for us create
that database constraint as well in this
key
yes umm I think we've got most of that
stuff sorted out I know that my projects
are all mirrored I'm sorry
it just oh I don't know if they're
actually using anything in this so
here's the history there is that we've
had
Chivas we've had a working relationship
with Sano type who are the guys behind
maven and especially the Nexus
repositories and most importantly made
in central we've had a relationship with
them for some time and it took a little
while to get everything all set up so
that we could mirror stuff from the
JBoss repository which is where we
publish things and those things then get
mirrored automatically intimated central
maybe in Central's got a few rules you
can't just dump anything in there you've
got to adhere to them that they haven't
coordinates are unique and that the
repository is complete in other words I
can't push something to maven central
it's got dependencies on something
that's not in maven central right Damon
Central's got to be clear possible so
the answer to that question is
definitely on the onset of these
projects we needed to have JBoss nexus
involved as well but at this point I
think for these types of things these
should all be in central or think and
you can feel free to correct me if you
find otherwise yeah mm-hmm sure I can
talk to you about it generically I can't
talk to you about it from a forage
perspective because it does its project
generation based upon amazing model
something you can do you want to go to
ant is use maven as an intermediary in
other words get all your dependencies in
here through that use the dependency
plugin to suck in the dependencies
output them to a Lib folder or something
and then you've got them all in one
place and then you can go to ant and
make your build system however you like
or combine ant with ivy use the same
coordinates and still use the same maven
repositories backing it on the back end
but use ant as the build system right or
use maven to trigger the build and then
call out to ant scripts there any number
of ways you can you can kind of hack
this yeah well cool we'll go on
once we've got our persistence provider
set up and our validation set up we can
go ahead and create some entities I mean
we right now we've got like scaffolding
for a project and we've got empty
folders but we're gonna go and actually
make make some files now and have it you
know do something so here we've now like
created an entity named a feedback
entity and it's going to automatically
make for us all this great stuff that
makes an entity says it's serializable
has versioning involved as the primary
key field in there and it's you know
just a basic scaffolding for an entity
that doesn't really have anything aside
from an ID so we're gonna give it some
other fields we're gonna give it a field
named Twitter handle
this is a feedback app by the way we're
gonna be giving feedback on this whole
thing right here so that'll be really
fun at the end when we see all the hate
just on the screen it's gonna be great
and we're gonna hold you accountable too
because you got to put your Twitter
handle in there although I'll tell you
right now we're not actually gonna
validate that it's real so you're not
really that accountable we're gonna put
a constraint on the Twitter handle this
is what we're talking about with the
bean validation this command right here
constraint command in the Forge we can
say put a not null constraint on there
and it's gonna put the annotation on
there for us so we don't have to worry
about entering those eight characters
all by ourselves it's really impressive
yeah you guys should all stop him I can
I kick take it bow and drop the mic and
we can be done yeah mm-hmm oh yeah let's
check this out okay so we created this
entity object right now we say forge is
a shell and it actually can navigate
pretty well what Alex just done and he's
typed LS so it's very similar to the
UNIX this command and it'll actually
print out for you the fields on the
methods and you can inspect in here into
feedback entry you can also CD out of
this and now you're back into the model
and LS and see what's in there and you
can CD into
entity again and see what's there we go
go all the way out there buddy yeah and
this is kind of what we're getting out
when we talk about it being an
incremental project building tool right
it can it's smart enough to be able to
know at what level you are what it's
inspecting and what commands it can
operate on given the context of where
you are it's not just a simple script
that generates some stuff and goes on
its way it hopes it all works sure
talking about the language of the shell
language oh yeah they've made it up and
they they made up the commands and they
wanted them to be kind of natural to
anyone who's used to doing like linux
shell scripting command-line
interactions hmm oh I'm glad yes yeah
yeah so there's a whole bunch of
commands and there's tab completion so
if you were to start you know we'll show
you as we go into some of the other
commands will look like half type of min
we'll hit tab complete it'll there you
go yep you can go edit the file and then
at the Titan of at the time that it
inspects is that when it reads it or
when it writes it at the current time
will then edit you can get without any
problem going and code the power on
yourself and they continue to use for
this way I've never actually thought
about the logic involved I know that I
do plenty of putting stuff in the Ford
shell and then I go and I change quite a
bit
manually and I've I've never had things
fall out of sync or like come up with
double knot in all definitions or
anything like that
so what do you say about it together is
all of our entity stuff taken care of
yeah almost
okay so we're building this feedback app
and it's basically got this one entity
in there that's called feedback entry
with two columns one is your Twitter
handle and the other one is like a
string to hold the feedback it's gonna
be a dumb simple app the point of this
presentation is not to show you a real
app or teach you anything about
application design is to show you how to
get started get this thing running on
your own machine get it tested on your
own machine again it pushed up and get
it running in a production environment
right so I think that this pretty much
does it for our entity model and what we
want to do is from this entity model
generate the scaffolding for a view
layer so we do that through this
scaffold set up command and it'll ask us
the second we head out of it like do we
want to install Java server faces and
say yeah because JavaServer faces are
gonna give us a whole bunch of great
view stuff and it is going to give us
the provider and put all the beautiful
pom magic in place so that we don't have
to do all that on our own so by now our
palms gotten pretty big and we've also
got a whole bunch of like images and
icons and CSS files and other things
that are involved in the scaffolding set
up even more stuff on the palm there is
one more scaffolding that we can now
generate we've put the scaffolding up
for the view layer but we're also now
going to generate the scaffolding
specific to our entities so we do that
by this command right here which is
scaffolding from entity and it's going
to ask us if we want to generate like as
I said earlier like a crud application
for the entities right so now we've got
that and we should be off
we don't have to write our own web.xml
we don't have to write our faces config
at this point we've got something that
we can kind of work with so we're gonna
switch over and I think it's time to
probably start generating some tests
because I don't like to do anything
without tests we talked about our
Killian a little bit before we're gonna
see it in a minute but first we talked a
little bit about the plugin as well and
the plug-in architecture allows us to go
fetch a plug-in and install it and bring
it right into the runtime and we're
gonna do that we're going to install the
our Killian plug-in which is going to
enable us to then make our Killian tests
the way this works is it goes out to the
repository it Yanks a bunch of stuff
pulls them down through a git checkout
or I get clone builds it locally and
installs it right into the runtime and
when it's done it's gonna give us the
shell and I'm just gonna say hey you're
done so now our Ford Shale is equipped
with our Killian and we can issue our
Killian commands on it so we're gonna
say alright our Killian let's set this
thing up and I'm sorry
the shell it cuts it off sometimes our
Killian set up we're going to set it up
with a container of JBoss a s remote
seven alright so this is saying that we
have a bunch of different type of
container adapters for our Killian
there's a managed container which will
start the server for you and stop it for
you there's a remote container where it
says alright you start it and stop it on
your own we'll just do deployment that's
what we're gonna do so and here's a
whole bunch of different containers that
we can use and as you see that
tab-completion comes into play here when
it shows you all the available options
so you don't have to remember exactly
what it is you want to put in so we're
gonna set up JBoss as7 and we're gonna
accept the defaults for the our Killian
bomb which is the Bill of Materials pom
will accept the default for j-unit which
is the latest 410 release and we're
going to set our Killian container
remote to seven one one final which is
the last JBoss AS release from there
we've got our Killian in our palm all
the our Killian definitions are in there
we don't have to put them in so again I
think a lot of the benefit is is just
not having to remember the palm
dependencies not having to remember to
put stuff in dependency management as
well there's this dual config palms are
really really verbose way of describing
a project and what they they work kind
of okay but anything we can do to avoid
mucking around with this I think is the
time well served once you've got all
this things set up it might be good for
us to actually generate the scaffolding
for a test right so instead of us making
a new class and writing a new test we
can have the our Killian plugin generate
a test for us and we'll say alright look
based on the entity that we made
feedback entry will generate a create a
test class for it and we'll put it up
there and you know what we'll do we're
gonna come back to that test class later
when we actually go and we write some
real tests for now probably best to take
this application as we have it and build
it because it's it's a buildable project
I mean we didn't do anything to create
it we interactive the shelf but it's a
buildable project so we're gonna build
it we're gonna fire up a server we're
gonna get it running and and see that
it's working okay
so we just built this you know with
maven through the Ford Shale and again
we don't have the JBoss as7 plug-in yet
but that's okay we're gonna go get it
we're gonna fetch the JBoss as7 plugin
and this is going to allow us to do
things like automatically download a a7
for us and start it and deploy stuff
into it and stop it
control the lifecycle of the s7 so that
we're not like manually going
downloading installing unzipping you
know whatever keeps us in the IDE and
working is gonna be good for us
so we've now downloaded the plug-in
we're going to set it up probably should
override the JDK it's set to 6 I've been
testing it with 7 yeah and the other
defaults you can keep so what this does
here is it's going to set up a s7 for us
and it's actually going to go and
download it for us that's kind of a fake
download because I've already got it in
my maven repo so we don't have to wait
for maven central but it all works the
same way if we didn't already have it
installed it would go fetch it out from
maven central so now we've got a f7
installed
we should probably fire it up and see
what a s7 looks like when we start it
has anyone seen anyone not seen a s7
startup before it's fast it's a full
application server there it is and done
yeah that's a 2.2 seconds that's a full
application server it's it's not like
lazy doing anything it's not it's it's
just there and and that's that's the
level that we're at now with JBoss a s7
it's ultra fast and it's can it help
your productivity a whole lot you know
as compared to a couple years back when
we're all used to waiting 30 and 40
seconds for an app server to boot
because we've already built our
application we're gonna say s7 deploy
and what that's gonna do is going to
take the the application that we built
here earlier it's in target right under
target
feedback bar and it's going to deploy
that wire into a s7 for us so we'll say
a s7 deploy and we'll watch it go and
it's the first time it's gonna generate
all the all the database schema stuff
and hibernate it's gonna do it's magic
and it's gonna generate the stuff for us
so when we switch over here and we say
look at localhost localhost:8080 says
hey welcome to forge and this is the
scaffolding that we talked about earlier
we generated the view scaffolding so we
can actually see an application and see
what's going on and we have this
feedback and entry which is the
scaffolding we generated from the entity
so when we go and we talked about those
two columns that we generated we can
actually make those two columns so why
don't we go put a little bit of data in
here and we'll say Twitter handle me
that's al hroub enger' and my feedback
is gonna say it's a little it's a little
slow today
it's a little still still morning and
I'm not fully revved up for Java 1 but
yet and we hit create new actually
connect we delete the contents of the
slow stuff oh yeah yeah put it in my
handle and then leave feedback blank and
hit create new nope no feedback yeah we
talked about the bean validation before
we had some questions earlier right
because those fields because of the bean
validation those fields are they're
starred right because the view layer
knows about it and the view layer also
knows hey don't don't let this thing go
through we've got a validation error and
it's gonna tell you what it is all along
the whole path right no this one right
here is coming out of each other this
one yeah this one this one's going to
the server and it's coming from JSF it's
not going it this is an application
level one but you can actually have
JavaScript validated as well so you
don't even go to the server
yes
and like the Arai project does that too
if you've seen the arrive I mean the
idea behind the model is one definition
for everywhere you know this model
happens to not generate the JavaScript
to like give it to you it goes to the
server but it's stopping there and on
top of that you have the database
constraints as well so there's many
layers all right now you can put some
feedback in and I'm feeling a little
more woken up at this point I guess so
something a little more cheery I don't
know there you go Thanks
all right so you got some feedback in
here that's cool
why don't we will shut down we're going
to unda ploy this application by saying
as7 on deploy and we'll visit our test
script you've gotta kind of speed this
along a little bit here's got the link
for our test script I'm gonna run you
through this real quick we say run with
our Killian at the top that's a standard
j-unit annotation and it says instead of
the standard is J unit for block test
runner use our custom test Runner and
it's the first thing it's going to do is
it's going to hand control over to our
Killian and our Killians going to
intercept the test lifecycle and be able
to do whatever with it right and in our
case whatever is going to be say hey
connect into a server and also look for
this at deployment annotation that's one
of ours and deploy that thing into the
server and it's also going to be able to
know what to do with these inject things
and then run the test methods so as we
said component model for your tests your
test should look like this even though
it looks like a unit test it's a
full-scale integration test it's going
to interact with JBoss as7
but this test right here is kind of its
like helpful in a show you how to do it
kind of way but not helpful and I like
let's test
kind of way so let's pull a test case
we'll just change it up a little bit and
what we'll do is we'll say for the
deployment instead of creating the
deployment manually we're going to pull
the deployment from the one that was
created in target we're gonna pull the
feedback bar I'm gonna deploy that so
we're deploying the real deployment
we're going to inject a persistence
context into the test so the test is
going to be able to directly act
interact with the entity manager and
then this can find feedback by user
thing we're going to ensure that we can
find a feedback entry where the Twitter
handle is at al hroub enger' right so
why don't we make this fail first and
change that to you or something yeah
that's great so remember the server is
still running and we're using this
remote adapter for our Kilian which is
going to hook right into the remote
thing so all we have to do to get this
thing going is well first set the Maven
profile it's going to run under by
right-clicking on the project going to
need and yeah cool and then when we go
to the test case all we have to do is
right click on it and hit run as j-unit
because we've designed our Kilian to not
rely on there's no special plugins or
anything here this is just a standard J
unit test runner we kept the
architecture to be such that you can run
in our Killian test from ant or from
maven or any of the IDE s without any
additional support just if it can run J
unit it can run our Killian right so
we're gonna run this as a J unit test
and we'll see that this thing launches
and it's going to deploy into the
running server and also give us our test
results now we see that the test is
deployed in the green one of the tests
has turned green right so we've seen
that it's deployed and we can get an
entity manager but one of our tests has
failed because we're looking up a user
with a Twitter handle that hasn't been
put in there so maybe we'll go into
test and actually change that up to put
in my actual Twitter handle and see if
we can't look me up in the database
where I shock put me in before via the
web console and now we see this working
right again the whole incremental
compilation thing is awesome in this
regard because we don't have to run any
build we didn't have to do anything all
we had to do was make the change to our
test file and because of the incremental
compilation the ide gets picked up it
gets shipped off here with our Kilian
and the test goes and that's just how
quick your testing experience should be
you got the server running deploy into
it you can execute these things all day
long on your local machine now granted
that's not really a test case I wouldn't
ever tell any of you that that's a valid
assertion or anything like that but it
shows that all right we've got data in
there we can interact with it's a full
thing or all on board you know give me a
little bit of latitude and no one's
gonna come down too hard on me good
we've got this local app and the local
app is all well and good but it would be
much greater if we could make this thing
publicly available right so we talked a
little bit about OpenShift before we're
going to shut down this local server we
don't need it anymore we've got this
application it's ready to go and I've
got an open shift account and because I
have an open shift account I can create
applications on it and provision
provision server instances kind of like
that and with the tool in here in jboss
developer studio it's really as simple
as going on to the server that I've got
logged in and making a new application
the name of its called the feedback yep
so we're gonna make a new open shipped
application called feedback and it's
going to be a JBoss a a7 type and
instead of creating a new local
application for it the embedded
cartridges would you let me get back to
that maybe Thanks so we've
we've created this a this.g boss is
seven application and openshift and
instead of making a new project in the
workspace we're just going to hook it
into the one we've got existing right
here and a feedback so I'll hit OK and
we'll hit finish and what this is going
to do is gonna take a little bit because
it's going to interact with OpenShift on
the back end it's talking into the
OpenShift servers on the cloud it's
creating the application for us and once
that application is created it'll be
provisioned and it'll be immediately
available right and it takes a couple
seconds for this to happen there's a
bunch of shell scripts all calling each
other and they're cloning repos and the
mechanics go and so well it seems like
all right we're waiting a little while
for it you got to keep in mind that like
you're not installing any server you're
not starting a server you're not
administering a server and anything it's
all gonna do it for you right here and
because of this JBoss developer studio
integration it's all kind of hooked in
and you actually get like a nice GUI to
do it too
normally when I do this there's
command-line tools so I use the
command-line tools for my openshift
stuff what do you got hmm sometimes we
hit a timeout if the Internet's not
working quite as quickly as we want it
to but as you can see here we've now got
our application open and if you go into
servers and we right-click on it and go
show in web browser this is our this is
our openshift server that we just
created you can all go there it's um
it's feedback - Java one demo dot RH
cloud com
and I'll give anyone who wants to go
there a second to go check it out
because in a second we're gonna push our
app up there this is the default app
that comes with it we're gonna push our
app up there and it's gonna be live
we're gonna throw some data into it and
have some fun
that is feedback - my assign Java one
demo dot RH cloud.com
yeah all right
so we've got this all hooked up here all
we've got to do is publish the app that
we've got here on to openshift so we do
that by right click and we hit publish
yep yeah so there are paid models I mean
initially you get you get into OpenShift
and like it's gonna they're gonna give
you I think what three what they call
small gears and the three small gears
are they're they're they're smaller like
Amazon Cloud instances but there is also
large gears that you're gonna get for
more money and they're they're much more
efficient they have more memory they
have higher quality CPU that kind of
thing
and there's also scaling auto scaling as
well so if you're under load it'll
revision more instances and go forward
okay man
right okay so we did this IDE because
it's got all the integration they're all
kind of standalone things Forge again
there's a shell and it runs in a shell
so I you know I was until two days ago I
was running this just from the command
line it was running forward straight
from there the nice thing about this
integration here is that you get to type
it here and see it immediately see all
your changes immediately reflected
without having to refresh or anything in
the IDE so that's kind of cool
same thing with open shift I mean open
shift is kind of get based what you do
is you get your repo you pull from it
and you see exceptions there yeah we
always kind of take our life in our
hands and we rely on like the conference
internet to push these things up for us
and hope that like yeah the live codes
cool we can try and fix this up in a
second or I can keep talking whatever
yeah
sure
well keep in mind that you know I don't
really want to advocate any particular
technology over another that I may have
a couple years back but it's pretty
clear that polyglot and choice are here
to stay and that's actually at the core
of some of our JBoss initiatives now we
have something called JBoss everywhere
we have a whole bunch of guys working on
our polyglot Initiative Bob McWatters
started off the torque box project
specifically to bring Ruby and rails
applications onto the application server
in other words give rails app a decent
run time and JBoss application server
with its administration and with its
efficiency is a great runtime it works
out great for rails apps we also have
Escalante which is now going to be
hosting up Scala and akka apps we have
the mutant project for closure recently
joining us I'm really excited to meet
him actually as Charles Nutter who is
he's the JRuby guy he's the one who's
responsible for porting Ruby over to the
JVM so it's not inconsistent to say that
JBoss is pretty committed to having the
polyglot efforts aligned especially from
a JVM perspective and anything that can
run on the JVM we want it to be able to
run on JBoss and we want it to be able
to run on openshift and these types of
things so yeah if you're a ruby shop I
say you know go for it make your Ruby
apps run them on to our fox have them on
AES but do be mindful of the runtime
that you have so a lot of times it used
to be the argument that I would make
would be I felt that Ruby shops and
script kiddies were kind of not paying
attention to some of the enterprise
concerns Tai thought were real important
like transactions and security
especially transactions a lot of people
kind of like throw that over the wall
look Enterprise development we have
these multi user applications that can
be accessed from anywhere and unless you
properly coordinate access to shared
resources and in particular shared
mutable state you've got a real problem
and it's very easy to hack together an
app and ignore all those things and I
feel like some of these communities have
for a long time but that's not - can
the language and it's not to condemn the
framework it's just to say that we need
to be able to arm you with a decent
runtime upon which you can run those
tools that seem to make sense finicky
Internet folks
yeah well why EJB three well what are
you looking to do I mean you've got to
choose the technology that's gonna work
out right for you EJ B may not be the
leanest meanest greatest component model
in EE anymore but it still comes bundled
with a whole bunch of services that are
not standard by CDI right so CDI is
gonna give you type safe injection which
is great it's gonna be a lot more
extensible and in many ways more
lightweight but CDI doesn't have
standardized transaction support or
security these are all add-ons and they
go in through the CDI spi and you can
get them through the Delta spike
community or from seeing three add-ons
but there they're not spec compliant in
that they can be guaranteed to run
anywhere and on any server and act you
know and work deterministically in any
of those ways so EJB still has its role
if I were to look into my crystal ball
or if I were to have my way EJB would
kind of be reinvented services for EE
and split off into different components
packs maybe but use it if you like it
don't if you don't there's still a lot
of great stuff that comes with you JB
there's pooling for the stateless
there's a stateful conversation scope
for the stateful beans message driven
bean are severely underused they can
adapt anything that's got a JCA endpoint
into a listener that means any incoming
servus you've got that you can write a
JC a listener for an inbound adapter you
can then receive as a transactionally
safe EJB it's an amazing thing to be
able to have but I'm not actually sure I
would be surprised if not because the
author of forge is Lincoln Baxter very
closely working with the author of awry
who knows quite a bit about GWT and the
author of awry Mike brach also wrote
this the scripting language called envel
which powers Forge so if that
conversation hasn't taken place I would
be ultra surprised but I don't I haven't
personally dealt with GWT so I haven't
done it on my own actually go ahead all
right okay so yeah we talked a little
bit about these embedded cartridges
first of all for this one right here
we're just using the embedded hypersonic
database but there's also this like
embeddable cartridge for MongoDB or for
MySQL and in that case they give you
login and you can even login with the
shell to get in there I think we're
running a little low on time we're gonna
have all this stuff up would you mind
putting up the link again Thanks we're
gonna put up a link again on the last
slide so you can go to the blog you can
download all this stuff we'll get the
application up and running again it's
this bit leak on 54:58 and i have a
bunch of handouts for you guys if you
want to come up here and and take a card
we've got some links and they'll show
you more about the book and they'll link
into other things like the Twitter feeds
to keep you all involved and and help
you to get jump-started on your own
projects because this is really just to
whet your appetite and show you what's
possible I want you be able to go home
and actually try the style fight on your
own so again good morning welcome to
Java one I hope to see you later and
come up and see us really
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>