<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JSR 353: Java API for JSON Processing | Coder Coacher - Coaching Coders</title><meta content="JSR 353: Java API for JSON Processing - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JSR 353: Java API for JSON Processing</b></h2><h5 class="post__date">2013-01-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/8WAJ-TFSqSw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you for coming to Java 1 I am
Jeetendra I will be talking about jsr
353 and UJ sir it's about Java EPA for
JSON processing is actually safe harbor
statement somehow it got lost so briefly
the program agenda is will talk little
bit about JSON and its overview I am
sure most of you are familiar with JSON
but will just spend briefly few minutes
and some other use cases especially from
the enterprise side jax-rs used case
then we will see the standardization
process about in this particular jsr jsr
353 and we will spend more time in the
api since we have editors wrapped out
and we have the api so we'll spend more
time in the api and if there is some
time we'll see some demos so what is
JSON Jason is basically a lightweight
data exchange format it's basically a
textual representation on the wire and
it's very easy for humans and machine to
read and write it's very compact since
it's part of for JavaScript it's
basically a de facto standard between
browser and server communications it's
used increasingly in many of the use
cases like restful web services or in
databases for example or even in
configuration traditionally XML has been
the strength of configuration etc so for
example if you take a small JSON text
here it's basically a person's
representation this person
representation has 3 name value pairs
here this DSN is basically a object
structure which has a three name value
pairs
the name contains a string value let's
Bob and the ages has a number value and
phone is once again a array structure
which contains our two phone numbers so
basically jason has or two top-level law
structures which is like object
structure as well as edit structure
so other day I was looking at many of
the developer APs offered by the many of
the popular websites most of these
restful web services they offer JSON as
you could see like I I went through some
other sites and I myself was looking at
the developer ApS most of them are in
JSON and in fact some of those popular
web services they offer basically they
discontinued support for XML so for
example I was looking at the cloud
Search API here if one uses amazon's
cloud such and such as first r was you
basically get a JSON document where it
says that the number of hits for this
JSON document JSON is like seven
documents and the hits contained the
documents which contained on this star
was label similarly let's say if someone
is just a Twitter search and if you
search for JSON you get a JSON tag
itself basically you get the output in
JSON and it has bunch of tweets so I
have a brief demo basically passing this
Twitter search API so since we are
talking about restful Web Services in
the platform the standard to do restful
Web Services is on jax-rs
in this example for example let's see
how the XML is being used in the restful
web services using jax-rs let's say
someone creates a restful endpoint and
calls basically it has a get book maybe
called for the HTTP GET method so in
this case the application is written in
a source object which is part of the
Jack's pa-pa since Jack's P XML has the
good support in the platform and Jack's
apps runtime takes the source objects
and converts into the textual
representation so on the other hand
let's say the the endpoint basically
returns a book object and the book
object could be converted to that
actual representation using the ax VAP
that's also part of the platform so so
we have very good support for XML
overall in the Java platform let's say
the same application traditionally like
any restful web service basically you
want to represent it in multiple
representations let's say if the client
asks for like a XML representation it
should be given in XML or if the client
asks for JSON representation it will be
given in JSON representation so that's
basically the code principle of any
restful web service in this case let's
say jax-rs resource basically gives a
book object and based on the HTTP
headers except header so the Jaxx's
runtime decides whether to give the XML
representation or whether to give the
JSON representation so again for XML it
can use a standard API in the platform
which is the XP for Jason you know like
many of the jacks are jax-rs itself
doesn't support the Jason but many of
the jax-rs implementations they support
Jason so as you could see like there are
many java implementations for Jason like
many libraries like some of them are
very popular like for example our Jason
the reference implementation for Jason
itself and Jack's and Google J's and
some of them do the binding from the
objects to the representation and some
of them just do the processing so we
have many implementations so the way
most of the jax-rs implementations
implement Jason basically is jax-rs has
this pluggable mechanism to convert a
textual representation from particular
object so that's basically message body
reader and message body writer so you
can plug in your own message body reader
or writer let's say take an example like
for example if the object is yes an
object which could be converted into
JSON using yes Knox API or if you have
an object like a book object that could
be converted into XML and that XML could
be converted into JSON like there are
some libraries which do this like
jettison etcetera are there are some
libraries which directly take the POJO
the book object and directly converge to
Jason for example Jackson Eclipse link
there are quite a few FPS which do that
but the problem is like since many of
the jax-rs implementations themselves
support so sometimes the applications
themselves they don't bundle these
particular libraries on which this
binding or the processing is involved so
if you move the application across the
application servers different vendor
implementations they fail actually we
see some of the messages on our users
mailing list about this and some of
these solutions also have technical
limitations for example it doesn't
naturally map from XML to JSON since XML
has the namespaces and many additional
constructs those things directly during
my application so that you typically end
up having some technical limitation and
and the more and the other thing is
applications themselves they have to
bundle these libraries if you want to be
portable across application servers and
that also causes sometimes problems
because application server itself
bundles some of these libraries so the
advantage of being a standard API is
like the applications use the standard
types and applications do not have to
bundle these libraries so the
applications become portable across
application servers as well as they will
become very linear so what we thought of
doing is basically like to jsr one is
for processing of JSON is much similar
to what is there in xml world that is
XML Jack's P the other important use
case definitely which we are not
ignoring basically JSON text to Java
objects binding because that's very
important to use case as far as jax-ur
is concerned because we want to create
multiple representations out of a single
Pozzo so that is my similar to jax be so
that's what we've been thinking about
doing or to J's us in the same length of
jxp and jax be so the first one which we
are doing is basically java api for
processing jason is just a pure
processing the similar to what Jax Pease
has been providing
so here we are considering a tool to to
apa so one is a streaming API to produce
and consume basically readings adjacent
in a streaming fashion and writing Jason
in a streaming fashion it much similar
to the Stax API I think it's very
popular the Stax API and it's bit low
level but many of the applications are
written in stacks in fact as far as
infrastructure is concerned it's a very
useful like you could see that many of
the slopestyle soap stacks are
implemented on top of the streaming API
so we expect that the similar kind of
benefits we achieve using providing a
pay for JSON on the other hand we will
have a little bit higher level API like
object model I pay it's similar to the
Dom API in XML and but it will have much
more nicer or constructs using the
latest Java Java Java constructs so so
that's high level for this particular JS
of the contents of this particular
gesture and we have three corporate
members in the expert group and three
individual members but we also get quite
a good contributions from the user
community so in fact couple of four
users are quite good and for some reason
they couldn't be they're an expert group
but nevertheless they contribute to the
specification so currently jsr 3:53 has
gone through the early draft review I
think within couple of days the early
draft review ends the next major
milestone is the public review by that
time we want to incorporate all the
feedback into the public review and
close most of the issues except only
blocking issues by the proposal final
draft the rest of rest of the states
like ballot and all these are primarily
the process of single stages so this
particular jsr is also done in JCP 2.8
so that means we have some stricter
transparency guidelines so and we are
following those transparency guidelines
this particular specification itself is
done as an open source project and we
have created two mailing lists one is
the users mailing list and
there is expert group mailing list and
and the expert group mailing lists
whatever the communication happens on
the expert group mailing list that is
yes our 353 experts that will be
automatically reflected on the US Mail
English so you could see all the
communication among the experts you
would see on the user's mail English the
only thing is the any user cannot
directly write to the expert group
mailing list but you could see all the
communication in fact whatever issues or
anything you could raise on public issue
tracker so that's quiet to open anybody
can any java.net member can post any
issue or what you would like to see in
the je serais PA and all these mailing
lists also publicly are capable so you
can take a publicly archived so you can
take a look at it and you can become a
part of the project itself so the
schedule what we thought initially was
like we want we would like to start
basically both the JSS but the first one
is yes our 350 had three has started
which we are planning to put it in Java
EE 7 and the binding jsr will go in the
next Java EE release so it's aligned
with Java EE 7 schedule which is the
expected scheduled date is basically the
spring of 2013 so as far as the R is
concerned RA is also basically done as a
open source project under basically
under GlassFish umbrella and it's pretty
much up to date with respect to spec
except I think auto detect in the
encoding from the input stream all the
latest bits also in the mavin mavin
central so you could always you can try
it and give a feedback so that all the
feedback will be incorporated before the
public review ok so as I said that let's
I will spend more time in the API so
before going to the API I will just
briefly talk about the grammar so that
one speed once we talk about the
abstraction so we will have a clear
picture like how the grammar and how the
API is going to be related so Jason has
primarily two structures one is the
array structure and other is the object
structure
so the array structure is basically
starts with square brackets and it will
have zero or more values so as you could
see in the first as you could see in the
first first railroad diagram the second
high level structure basically jason has
is one objects object the object
structure it starts with the curly brace
and ends with the curly brace and it has
basically zero or more name value place
the name star name is a string and a
value could be any of these particular
values so there are seven value types
primarily the string number and once
again you can miss the main object
structures like object structure and
array structure as well as three literal
values true false and null okay so as I
said that basically this API consists of
four two top-level aps the one is a
streaming API and other is object level
API the way we see that like a streaming
API is a very low level API very
efficient to pass in generate Jason it
doesn't create any intermediate objects
it could be used for applications as
well as any infrastructures like let's
say if someone is doing a binding
framework so they could use on top of
this particular API and here we also
provide applicability for both passes
and generators so that if any vendor or
if any other implementation wants to
provide their own pass friend generator
which is more efficient than the default
implementation that could always believe
that could always be loaded using a
provider on the other hand object model
API is a very simple API it's a high
level API and it has very few
abstractions and moreover all the API
basically when you take a look at it I
think you should able to start
programming within within an hour
basically so so that that's that's the
basically the aim of API abstractions
should be very self-evident so it should
be able to code pretty fast so let's see
the basic architecture of the AP how it
is so underneath basically we have a SPI
using where so we have the SP a spear to
plug in basically the pastor and
generator so any provider could
basically provide pass friend generator
the past rent generator will be loaded
using the standard service loader
mechanism in Java C and then on the top
of it we have the streaming API
streaming API is nothing but a parser
and generator so the object model API
sits on top of the streaming AP it uses
whatever the parser and generator
available from the provider and it
builds the higher-level objects
sometimes object level model API is also
called the tree API because it's
basically basically object level
structure in a tree format then on top
of it basically you have the
applications the applications could be
using the object model APA or it could
be using the streaming AP so it's based
on the needs of the application so let's
take a look at the first abstraction in
the streaming AP that is a jsonparser
DSN passes primarily as the name
suggests is passes JSON but it's parses
the s and in such a fashion that it
passes the SN in a streaming fashion
it's much similar to stacks XML stream
reader so those of you know about stacks
it's basically a pull parser
it's basically forward only parser so
you cannot go back so you you keep
parsing the JSON and when you reach
certain state in the parser you could
directly get the whatever the data you
require using the the necessary methods
at that particular state so yeah so so
other thing is like created a very easy
static factory to create these partial
objects like we have like JSON dot
create parser and make and part a pass a
you can give a stream and it will create
a JSON parser object similarly we
provided a parser factory also because
if you see the json dot create parser
for every call it basically takes a 1
because it's trying to find a provider
so it is invoking it is incurring
basically a service lookup cost
so that's why we created a pastor
factory so that once you basically
create a factory you could use the
factory to create multiple paths objects
but the main thing which you have to
deal with is only the pastor abstraction
a pastor also could be configured with
the any feature like any parsing
behavior you want to incorporate during
the passing process you could always
create with certain features let's say
if if a particular implementation want
to pass the JSON using single quoted
strings typically jacent strings are
double coded strings but let's say if a
parser implementation wants to pass
using a single quoted strings basically
they could provide a feature and there
the pastor understands that feature they
could always pass that particular kind
of on Jason but the spec itself doesn't
provide any non-standard features but if
an implementation wants to do it they
can always do that so there are a bunch
of passive statements I will go through
them like for the starting of array and
starting off object there are basically
started and start object similarly for
the end of parsing state for end object
and end every they are there and rest of
them are primarily the value states so
let's let's take a look at some of this
like for example I have a JSON parser
the JSON text so how the parser will be
giving is at the start of the curly
brace you will get a start object event
similarly at the first name basically
that's the name value pair so at that
time you will get the key nakey key name
and you could always get using a get
string at that particular state you can
always get what is the name name of that
name value pair once you advance the
parser to let's say to John for example
so you will get a value string because
it's a a JSON string value so at that
time if you as the parser wants you can
it can always get the value of John
similarly let's say at the end of number
25 you will get the value number parser
event and you could the user necessary
method to get the parser
value 20-5 similarly at the start of
error you get a star today so that's
that's a typical behavior so you advance
the parcels to a career arrange state
and get the necessary necessary data yes
please
right
basically all it's saying is when you
when you when you are at the start array
basically it is giving a start array
this one but for number you have to I
you have to keep some state saying that
this is a phone number and you all you
get this phone number is basically it's
a name value pair here as you could see
phone number is just a name and the
value just turns out to be the array
right yes yes definitely because it's a
key name right so every key you you have
a basically key name or state will be
associated Yeah right
so at present in the past sir APA we
just have a string so but in the object
APA I think we have a little bit of
abstraction but so yeah that's the kind
of feedback which we are kind of looking
whether we want we could always hire
additional methods on the parser because
because at any state you can get the
data in different formats for especially
for the number so you could get for
example the number 25 as an T value or
the number 25 as a long value or it
could be any other because here it's all
textual representations so we could add
pretty much any method basically we want
so let me go ahead and at the end of the
error you'll you basically get the end
of heavy start event so for example if
you want to get the value of John you
advance the parser to the start object
so you you basically get to the start
object right you get to the start object
then you advance the cursor to the key
name then you advance to the value
string and then at that time you call
pass or get string you get basically the
John value right those of you are
familiar with stack so I think it feels
very natural basically you moving the
parser in a streaming fashion and get
the necessary data the only disadvantage
of this low-level API is basically at
certain state you might let's say at a
value string state for example for
example here you might call I want to
get this as a number for example that
will throw an exception it's not
typesafe in that aspect but it doesn't
create any intermediate object it
doesn't create a you are directly taking
whatever the information available in
the faster buffer and directly giving
that information whatever the user wants
it it doesn't create any unnecessary
intermediate object it doesn't convert
anything it just use whatever the user
wants that's why it's bit low-level API
but it's very highly efficient API okay
so other abstraction in the low-level
API is adjacent generator so the jason
generator is primarily generates jason
in a streaming fashion so it's much
similar to see me
stacks of XML stream raters so you can
keep writing the JSON in a streaming
fashion to whatever the stream outputs
or so it's available
so like parser it's also created using a
static factory json dot create generator
or you could create a factory and the
factory could be basically create the
generator so so what happens here is a
in future probably the factory could
also be the factory could also be
injected basically into e environment
perhaps but it's not there right now in
the spec but in future probably the pass
a factory could be injected into the
generator
injected into the any e component so
optionally a generator also could be
configured with the Preda printing or
any any other feature for example if a
provider for basically creates any
features so that feature could be used
to configure the generator object so for
example one is the pre depending is one
of the common features like you want to
write the generating the json basically
in a pretty format so here we also allow
a method chaining and it's pretty types
if i'll show with one example here so as
you could see like it's user say
basically something like a kind of a
chained method like object add and
object being an object etcetera and
whatever is um the way you are
generating the JSON that reflects
whatever is generated on the output so
it's exactly the similar kind of
structure like making a rival right so
as you could see the same structure
which you can use it in the code and and
and the advantage here is like it's also
very typesafe so in the in the object
all it all they take is basically to
name basically name value name values
that means two parameters will be used
in all the methods but if you want to
write a single value it doesn't hello
because we made sure that you cannot mix
and match object methods and error
methods so that's what I mean by the
typesafe teenis
so that type safety nets works for
multiple nesting levels also so while
showing the demo probably I'll take a
look at it and I'll
some other code how that works we just
use some generics tricks basically to
make sure that it's very typesafe the ID
and all while filling it up if if the
scope is basically object he just
shallows only the object methods if the
scope is array it allows just only their
methods so that's all we have in the
streaming AP then we will come to the
basically the high level API which is
the object model API so here also we
have basically very few code
abstractions so one is the JSON object
in JSON array which are basically the
three structures for the JSON object in
JSON array then you have a builder which
can build the JSON object in listen
array from the scratch then you have a
reader and then you have a writer the
reader basically creates the s an object
and JSON array directly from the input
source and the jason writer writes JSON
object and the JSON arrived to the
output source this is much similar to
like when you are serializing objects
using optic serialized object input
stream and object output stream is much
similar to that basically you are
reading object directly from the reader
and similarly the writer write suggest
an object and JSON array to the stream
so in the object in array we also have a
little bit of wrapper types for JSON
string and Jason number so that's one
place I think we we also need a feedback
so instead of directly mapping to the
string and directly mapping to let's say
any primitive type or like a premie type
int along row for example or a big
decimal or big integer we created a JSON
number wrapper type so so that that's
one place definitely we need some kind
of feedback once after using a please
let us know whether that is working out
okay or not so the advantage here is
like the essence string and all a string
could be represented basically like for
example based on the file system like
that string could be somewhere hidden in
the file system but while writing we
could basically take from the file
system and just dump it rather than just
smacking into the string similarly for
the number what could be the number type
for example integer long or whether it's
a big decimal so some of the other
methods are there in this one so that's
why we provided at present the wrapper
types so but if we want to provide let's
say directly the primitive types
probably yeah we can take a look at it
once again so let's see like what is the
JSON object yes an object primarily
holds name value pairs and we also
decided that we'll make these objects
immutable so that we could use probably
with lambdas or we could in basically in
concurrent systems it's much use much
easy to manage basically the immutable
objects so that's why we created this
JSON object and JSON array as immutable
objects and if you want to access the
values you could always access as a map
string and map of string and Jason value
but even the return map is basically
unmodifiable map so it's basically a
mutable structure so for example JSON
object let's say somehow you create a
JSON object by jason builder or jason
reader and you can get the values using
a map so object dot get values gives the
map yeah yeah so the iterating order we
defined the way you construct the JSON
object so that's clearly defined so
because otherwise say map right so you
could be getting on the name values
could be any order so but the iterating
order we defined in the spec to be the
way you build the JSON object or the way
you build the J's JSON array anyway it
doesn't have any problem but object yeah
we definitely defined iterating order so
on the other hand it also has a little
bit top-level accessor methods like from
directly from the JSON object you can
get a JSON number from the JSON number
you can get like it has methods like you
can get the inter value or you can get
the int value exact like for example one
basically truncates if the number
doesn't fit if if the number fits so for
the other one basically jason
I think into value exact adding it
throws an exception if the number
doesn't really fit you fit into integer
so it just like whatever the big decimal
has the int value and int value exact
it's kind of similar to that so so like
that yes a number we have a little bit
wrapper type but we may add a couple of
methods by which you can especially the
int value probably we will directly add
to the JSON object you can directly get
the int value without going to the JSON
number similarly we have a way to access
the names or using basically let's say
if you want to get all the names you
could get using the names in this
particular object or take a look at that
and see if you require any new methods
yes please
dates in J yeah Jason itself doesn't
have any concept update I think that's
part of for JavaScript I believe Jason
basically as you could see in the
whatever the grammar I showed it doesn't
have any concept update so it's up to
you how you want to represent on date
either in the string format or if you
want to represent maybe along the
milliseconds or something it's it's up
to the application there is no there is
no support as such in the APA itself
yeah okay
then the JSON array JSON array is
basically a list of values and here JSON
array is also immutable similar to JSON
object here you can access the values
using a list adjacent value basically
the standard collections library for
example let's see you know so you could
get the get values using as a list and
you can use the any of the collection
ApS or tomorrow if the lambda comes up
with streaming API etc you could always
you could you could you could be using
all of all of those things on top of
this similar to whatever JSON object you
have seen you can get a JSON number or
JSON string and you can access the
necessary data okay so let's take a look
at the next Jason builder abstraction it
just follows a builder pattern it builds
JSON object and Jason at Wave from
scratch so using a builder pattern it
allows so method chaining similar to
what you have seen in the JSON generator
once again it's a types if you cannot
mix and match arraigned object methods
so let's say if you want to create let's
say a empty JSON object you create a new
jason builder you start a begin object
you you basically end the object and you
say build you have that JSON object mu
yes please
while building you cannot but while
reading and writing we do have by
building you typically know whether you
are building a object or whether you are
building a array right while writing you
don't know likes in some cases it
suggests a station structure you know
whether it may be a JSON array or
there's an object you could we could
just write it you don't have to write it
you don't have to use a specific method
so but while building I think you
typically know whether you are building
a JSON object our JSON array so that's
why there are two cause basically big
big in object are big in array so that's
the approach so far we have taken so
otherwise how do you build a so let's
say if the jason is there in the let's
say in the text file or something or in
a file system there you don't really
require to know whether in the text file
whether it's a JSON object or yes
nothing that you can read it but while
builder I think you typically know
whether you are building object or so
while building from the text we have a
JSON reader I think you will see that
actually so so there you can directly
you can just read from the text file and
the parser will figure it out and it
will create appropriate structure for
you
yet present we haven't clearly we
haven't specified that in the APA
weather so yeah maybe implementations
probably will do but at present we
haven't really specified that semantics
in the API as such yeah so the you are
asking about the question yeah the
question is are we specifying about the
to string in JSON object and on JSON
array so so if you take a look at the
JSON builder it exactly it's similar to
what what jason generator has done in
fact they they share the same core
abstractions so once again the object
which you are creating for that
particular jason they resemble they
resemble exactly similar similar api
structure same similar structure the way
you are generating let's say type within
the object that's how you basically
beginning object and you at that
particular name value pair so that's so
and it's finally it's a builder pattern
so once you build you have a JSON array
yes
right so so so that is that is basically
poser to Jason binding so that that will
happen probably in the next years are
which which we are talking that the
binding guess are me yeah it's actually
a bit low yeah low level and yeah if
people who don't want to use poor like
instead of dealing with the poachers if
you want to directly build using you
know on ground up from the scratch or
from the object from the file system you
want to directly read it that kind of a
processing there also we need to know
exactly let's say you have a POJO when
you are serializing it you need to know
exactly how to bind certain things if
there is a cyclical structure if it is
the interface there are so many things
in the binding here or if there is a
list for example any collections you
need to have some standard thing to how
to map this to Jason but most of the
implementations they do know if you if
you define what exactly the bindings
supposed to take care what all the Java
like semantics for all the Java's
structures like you know for example
generics or collections so that's that's
what is involved when we do the binding
binding specification that's what we are
going to do that okay
yeah yes yes if they know it's the same
like no it's the same basically that
would take collects a type and if you
want that if you already have a JSON
object you can just pass it as a second
document
similarly okay
if you are building from scratch you
have to basically initiate if you are
building from scratch but if you already
have a JSON object and you want to put
that into a new JSON object you can
always do that so if you take a look at
that add methods basically is just not a
string and integers but it also has
basically you can put completely honest
here Jason any other tree basically JSON
object or JSON array you can directly
attach it so the other abstraction which
we have is the JSON reader Jason reader
is basically instead of building from
scratch the JSON object in JSON array
you are directly using a file if the
text is available in some stream you are
basically converting that stream into
the JSON object and yes anyway so you
could also use the arm blocks so that
you don't have to explicitly close the
readers but it's it's very
straightforward just like read or read
object you will get a JSON object reader
dot read array you will get a JSON array
so if you don't know whether it's say
object or if it is a array you can just
call reader dot read it will give it it
will give a super type of JSON object
and JSON array here basically you are
reading from the input stream or a
reader also if the input stream we
automatically specified to detect the
encoding especially for the Unicode
but if the stream is not a Unicode
stream you could also optionally specify
encoder or you can create yourself a
reader and pass that to while creating
the jason reader so once again here the
jason read it could also be configured
with the features and since we said that
jason reader is built on top of the
low-level api is a jsonparser so it will
always use the pluggable json parser
if any provider yeah
sure yeah sure yeah yeah you just say
reader dot read there is one more method
called read instead of read object and
read array there is a read method is
there that one will give you a super
type of JSON object in JSON array which
is adjacent structure so then you then
you write yeah then you can take a look
at you can see what object it has read
yeah so similarly the writer
so we have our JSON object and Jason
away so you could basically write this
objects JSON object and Jason add a to
the output stream or you could write it
to this a writer so by default if you
don't give em coding it will write into
utf-8 or if you you could specifically
create a writer with certain encoding
and you can ask Jason to be written in
that particular encoding optionally you
can also configure with the features
like let's say if you want to write
Jason in a Freddy format you can create
a a feature for the pretty format and a
pretty feature and just pass it while
creating basically the jason writer so
once again this is also you just say
pluggable jason generator underneath so
if a provider provides their own
generator which may be efficient it will
be automatically picked up and the jason
writer while generating it it will use
that generator and just writes it so but
but the the thing to note is basically
just a couple of lines of code to write
any json object and you can wrap it in
the arm blocks
yes play
yet yeah I present we haven't defined
the prettiness like it's up to the
implementation because I don't know like
how exactly to define like everybody can
have different ways up for doing the
prettiness so there is no not not in the
specification as such we just have for
some features probably it will have that
kind of you know or data but in
prettiness we haven't we just said it
separately so it's up to the
implementation to basically to format
the way it wants to perform at it so
okay then finally the configuration so
the configuration is primarily like
basically it's a parser and generator
features is basically a list of parser
and generator features so so the spec
probably will define only few features
and the implementations may add
additional features as they see but it
also supports so as I said it also
support extensibility like you can build
the custom features and once you once
you build the features basically you can
create a configuration and you can pass
that configuration while creating a
writer or creating a parser etcetera and
and we are and if any implementation
let's say you are moving your code from
one implementation so let's say other
implementation and other information
doesn't understand that configuration it
must throw an exception so that will
guarantee that that particular parser
and generator they understand that
configuration so yes
Preda printing basically while writing
json it shows in much nicer format i'll
show you one example like tabs for
example it indents properly etc so
that's right
yeah so in the previous examples when I
formatted the Jason in indentation and
also that's something like a pretty
printing rather than putting everything
in one particular one in one line and
stuff that it's writing in multiple
lines and indenting properly so so we
still have some work primarily like like
we haven't defined equals hash code kind
of mechanisms and what happens in the
round-tripping basically you have a text
and you created these objects and once
again converted to text and from that
text you created one more object whether
these two objects supposed to be equal
or not so that kind of semantics we
haven't defined especially that becomes
tricky with the floating point numbers
because the way floating point numbers
has to be written on to the text is so
it's quite bit tricky so also whether we
need really need to define this equals
and hashcode is also not we need to have
a discussion because within one
particular provider we don't really
require to define it but let's say you
have two providers i means to complete
different implementations and you
created one json object using one
implementation and you created other the
json object using other implementation
should they be equal or not so that's
the only case probably at present in the
AP we need to declare this equals and
hashcode otherwise within one
implementation it's just one
implementation whatever mechanism it
provides we can say that yeah they can
you don't have to explicitly specify
like hashcode have what is exact
algorithm for the hash code we have to
specify that probably supposed to be
equal etcetera but we don't have the
exactly specifies what is the hash code
algorithm similarly we need to take care
of for exception handling and a few
other bugs which are filed on the issue
tracker so take a look at it and since
the artifacts are already there in
abeyance
so you can experiment it and see whether
the API is simple enough and fluid
enough to use it so I will show some
demos yes
yeah
you can definitely take part of the tree
and just using a builder once again you
can plug into you can create one more
object and you can plug it in right yes
you can you can take any part of the
tree and just put it into the Builder
yes it's always possible so I'll briefly
go over a couple of a simple jax-rs
application now which I have built
because we are driving from the Jax
Harris point of view so so I have a demo
application so it's nothing but a jax-rs
application as you could see it's
importing application path and it has
three resources one is a parser resource
other is a generator resource and other
is the object resource I will come to
what the body writer is doing so the
parser resource is basically it's
listening at the path slash parser and
it will pass Twitter streams
I hope hope you can see basically it
parses a Twitter search API basically it
opens a Twitter Search API for actually
actually Java 1 and it happens the
stream and it creates the parser and it
basically writes certain elements
basically the Twitter parser if you see
that Twitter search it returns a bunch
of metadata so in this example all I am
interested is in two two values one is a
Prem user what is the user handle and
what is the corresponding at feet he is
using so and then he just prints it to
the output stream as a text plane so as
you could see this this particular is
just a text plain representation so the
way we if you see the Twitter's JSON
string adjacent for output is like it
has a from user what is the user handle
it's very deep nested in somewhere in
the in the in the adjacent tree
structure and it has a text texture
information basically I think maybe I
should reduce
maybe this is better I guess so all it
is doing is it is when the event is key
name and if the if the values from user
it is advancing to the its value and
gets an a corresponding parcel string
and it prints that particular value and
once again it goes to the tweet and it
gets the corresponding tweet and just
prints it so let me show actually
probably then you'll get a clearer idea
of what's it's doing so as far as this
Twitter search let's say if I have JA
one so this is this is the format it
gives so bunch of metadata then in the
results it gives basically from user and
the corresponding text right so that's
all those are the two informations we
are pulling out from this particular
class so the from user it is much deeply
nested somewhere within the results and
the corresponding text information
that's all we are trying to get this
from this particular jax-rs resource so
like that bunch of tweets are there so
if I run this particular demo with the
parser so as you could see basically the
user and yeah and the user and the
corresponding tweet and the user and the
corresponding to it so that's all this
jax-rs resource is doing okay so it's
just a simple pass rate a how to use the
parser so any questions on that yeah it
just it advances the cursor to the from
user and advances the cursors to text
and just gets the corresponding data
it's that simple
and it's writing the data to any
streaming fashion so if the data is huge
one gigabyte or something it doesn't
matter you just keep on passing the
things in the in a streaming fashion and
it's also writing in a streaming fashion
here only thing is it's here it's
writing a just a text plane just writing
to the text plane stream so other thing
which you have is the generator resource
I have a simple example for example
ah ladies riding is for the HTTP output
stream
you just keep writing this bunch of data
in a streaming fashion so as I said
previously in the add method for example
if you want to add something so it will
just give only the name value pairs it
doesn't give any object any of the array
methods so that's what I said like you
cannot mix and match object methods and
array methods so that kind of type
safety ness is built into the API so so
as far as the resource is concerned
basically all it is doing is directly
creating adjacent generator for the
output stream that is a HTTP output
stream and generating Jason to that
particular output stream so if you see
this this particular resource is the net
generator so so this is what I call the
pretty printing but if you see the
actual data which we send that is just
like this I installed a small plugin to
show that in a plenty painting in the
browser so if I close this yeah so
whatever Jason is generated basically
that that is coming to the
representation so this is also streaming
way to generate so if you have data we
are pulling from database or something
and you keep on writing the data to
generation you can generate it as much
data as you want because you are not
storing any anything inside the memory
yeah mmm right yeah there is a Jason you
plugin that's what I installed so that's
what it's showing otherwise that what we
are sending is basically just like this
similarly the next example is exactly
same that is a faster object resource
the only difference here is basically
the user has created an object here and
he just giving to the XRS runtime and
jax-ur son time basically converting
this JSON object to the stream so it's
exactly like similar to what you have
seen in the Jason generator but the only
is here the user created a JSON object
and he's written in that JSON object
right so that's all he is doing like you
created you got a JSON object from
somewhere else and you want to basically
write it or something so that's what is
happening
so here the responsibility is primarily
the jax-rs runtime is taking the
responsibility and converting this JSON
object to the stream so the way we do is
is like we created the body writer
similar to other implementations so all
it does is it basically creates a writer
using output stream and writes that
particular structure Jason structure is
nothing but a super type of JSON object
and JSON array so that's all it's doing
it's but the interesting thing is this
particular now this message body writer
is portable across any jax-rs
implementation because it is using the
standard api yeah
and moreover the applications in future
probably they don't have to write this
one because this will be super part of
for the application server itself when
you have a tighter integration between
jax-rs in JSON so the body writers for
these particular objects they all will
be shifted part of the application
service so you don't have to really
write it but at present since we don't
have tighter integration but in the
future by that time the spec ships I
think it will be part of the application
server itself so you don't have to write
in your resource all you have to do is
you just written whatever the object is
an object or JSON array the jax-rs
runtime will take care of utilizing that
similarly while reading also it will
automatically take care if you want to
map for example let's say do post and if
the HTTP request contains a JSON you
could directly map to JSON object and
the Jackson runtime will automatically
take it the input stream parses it and
creates basically JSON object so yeah
that's exactly similar to you don't see
any difference here and even if I say
object so it gives the same kind of
output
I think that's all I have actually so if
you have any questions any discussion we
can have here</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>