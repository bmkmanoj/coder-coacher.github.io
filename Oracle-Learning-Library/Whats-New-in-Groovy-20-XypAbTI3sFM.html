<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>What's New in Groovy 2.0? | Coder Coacher - Coaching Coders</title><meta content="What's New in Groovy 2.0? - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>What's New in Groovy 2.0?</b></h2><h5 class="post__date">2013-01-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/XypAbTI3sFM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I'm gamla Falls i'm working for
vmware I've been working on the brewery
project for the past eight or nine years
now well I initiated the creation of
some frameworks from the groove
ecosystem like the Grails framework the
Gaelic toolkit for google app engine etc
and I co-authored a couple of chapter of
the groove in action book and well if
you want to follow me here here are a
few links you might be interested in so
the this presentation is going to be
split in two parts I'll cover so the
current major version is greeted at home
but there are some interesting features
which you might not be way off which
were part of 318 which was released when
was that I don't even remember the date
but close to one year ago and well these
are the features I'll cover and in a
second part I'll cover there are the
specific features of rudy to the dome
okay so one of my favorite features well
greased used in different contexts as an
embedded long waits for domain-specific
language for business domains it can be
used as a scripting language when you're
in your child can be used in various
contexts and domain-specific languages
is a I would tell you a sweet spot for a
four groovy and one of the features
which came in grey 18 was what we call
come and change it's the ability to have
readable sentences almost plain English
sentences but which are actually valid
groovy code and that's for change method
calls as I will show you in a few
seconds for example something like this
pull request on github it looks like a
you know plain English sentence or
an expression and before everyone ate it
wouldn't have been something that the
gooery compiler could compile but since
grey 18 and then todaro we can do we can
compile that and it's actually an
alternation of method names pull the
method name on is a method name and
parameters so you've got this
alternation method names and parameters
and this is actually equivalent to this
code right that's chained method calls
that's why we call that feature command
chains so this is the simple example
where I just have one parameter but you
can have several parameters you can use
named parameters etc let me show you
some further examples here with multiple
arguments take coffee with sugar milk
and liquor that's again a sentence but
that's valid Ruby code you can use named
arguments and output back the the
parents and dots afterwards I'll show
you you can also use closures for
creating your own control structures so
if you're into behavior driven
development testing frameworks provide
that kind of constructs you know given
when then you can there's one case where
you actually need parenthesis it's when
you have a method in the chain which
doesn't take any argument so this is one
of the cases where parents are required
and another example so far you were
seeing method parameters method
parameters but you can also have method
parameters and the the the odd part
being a property access so let me put
the parents and dots back so here you
see that the the width method in the
middle is the one taking actually two
arguments sugar and milk the second one
is interesting in the sense that
visually we have this impression that
the colon separates both power
both parts of the sentence but this
whole part there is actually a named
argument and this one it's quite simple
it's like just putting back the parents
around the closures and yeah the other
ones are quite straightforward so it
opens the doors for some interesting
dsl's for business languages and I also
know some persons in the room who are
already using that and in that project
and by the way I forgot to ask an
important question who's using groovy or
is familiar with it okay so majority so
way because it's a you know a talk about
what's new and not so much of an
introduction talk so i'll spare you the
details but just in a nutshell for those
who are not familiar groovy is a
language which which is well it's a
dynamic language which derives from the
Java language we at the syntax level
most of Java constructs is also valid
glory constructs and it has the same
behavior plus we add some stuff we
simplify some some things like we have
real properties we have closures etc
plus some api's so in a nutshell that's
the definition a quick definition of
brewery so let's come back to to to the
features the new features from the the
groovy ecosystem there's a project
called jeepers which is now bundled with
the groovy distribution when you
download the groovy distribution jeepers
is a very interesting library which
covers all things related to a parallel
ISM concurrency etc and it provides
different let's say provide some syntax
sugar on top of different constructs
like actors the fork joint stuff of you
know Java util concurrent data flow
variables which is an interesting
concept engines etc
so all these concurrent paradigms are
supported by the jeepers library so
whenever you want to run things in
parallel etc you should have a look at
this very interesting library what's
also interesting is that well perhaps
some of you would like to use groovy in
production but for some reason you're
not allowed to or something like that
but for example if you want to use
jeepers from July you can do it as well
so it's friendlier for groovy developers
because of the syntax sewer but you can
also use that library from Java itself
jeepers da da da sword if you want to
learn more about that library closures
which is a key cornerstone of the
language has seen several improvements
so I'll just focus on the ones which are
in bold let's start with this one color
annotation parameters so that's a bit of
a mouthful when you use annotations in
Java annotations can take parameters
they can take strings primitive types
class values other annotations arrays of
all these things am I forgetting
something yeah probably got them all
that it cannot really extend annotation
to support some other types and actually
we we have a little trick there we are
able to use closures as parameters of
your annotations which allows us to have
to support that nice notation the trick
is that actually we are anchoring the
the closure which is here in the form of
a class so because the JVM doesn't allow
us to provide other types of parameters
so we encode the closure in the form of
a class and in this example I'm actually
doing
designed by contract like is available
on languages like the Eiffel language so
i define my annotation and I put an
invariant annotation on my distance
class and then i create a distance using
movies named constructors named with
named parameters which is going to call
the the setters on those two properties
and then i retrieve the the closure
which is associated with this class and
then i can call that folder with my with
my distance instance and then i'm able
to check that this this predicate is
valid there's actually a library called
g contracts that you can use which
provide the full full-blown designed by
contract like preconditions
postconditions dealing with dealing with
inheritance and so on so it happens
again some interesting perspective for
example if you want to reuse closures
for doing things like validation you
could say okay this field or string
should be a longer than 10 characters
and that kind of stuff so this feature
is interesting for a framework
developers so that's quite nice then
closures are used a lot in the context
of functional programming so Groovy's an
object-oriented programming a dynamic
language etc but it also supports some
other flavors kind of programming so
functional flavor there's definitely a
functional favorite group especially
with the use of closures so what you see
here is a closer between the curly
braces taking some parameters and then
the actual body of the closure so here I
mimic a closure which that
edition which adds a and B but I'm
inserting a sleep 1000 milliseconds
statement before returning the value so
that the computation is slowed down okay
so fortunately when you do sums in
groovy there they don't take one second
for each Sun it would be a bit of a pity
and then I actually called a new method
on closures which is memorize this is
the the memorized memorization pattern
so that it creates a new quarter which
remembers the outcome on pre of previous
invocations with the same set of closure
parameter values so the first time
you're going to call that closure with
one and two it's going to return three
okay that's correct but after one second
okay but on the second invocation it's
going to return immediately because it's
going to retrieve the value from a cache
then if I take some other values which
are not in the cache it's going to take
one second again and the second
invocation of that closure will return
immediately you can actually you have a
bit more control on this feature for
example you can say you want to memorize
at least ten in vocations at most ten
invocations or you can even say between
10 and 20 in vocations if your ear
there's a question already so how would
in terms of implementation details what
is it using so I think it's using huh
I'd have to check the implementation
because I don't remember so it's either
using I think it's equals think it's
equals which is being used they're not
identity equality yeah yeah I'd have to
double check I can check double check
that after by looking at the
if you will you're interested what else
yeah and so there's actually a least
recent least recently used cash and for
example even if you just use men wise
without putting some specific bounds if
you have some if you're running low on
memory there will be I mean the next
time the the garbage collector will come
it will claim what's in the cash so you
don't have to be worried about running
out of memory even if you don't specify
some upper bounds so don't hesitate to
interrupt me with with questions I'm
happy to take them throughout the
presentation okay groovy is well known
for its support of XML back in the day
where when XML was popular the the
dynamic nature of the language made
groovy very powerful when dealing with
XML both for consuming and for producing
XML because we can navigate an external
node graph very easily because we don't
have to do some Java marshalling and
marshalling to get the intermediary
nodes we can just go through with well
let me show you what it looks like with
with the the Jays and support and well
we had that support for XML since well
since the beginning of a groovy but
these days most of the the rest api is
that you can find whether it's I've got
an example with the the github rest api
which is using J'son so it was quite
natural to add the same Kadim of support
for Jason as we had for xml so let me
show you so I'm trying to run that
example just before during my
presentation but since I so it's an old
example I had and I the github guys
change their API a little bit so i
shorten the URL here but it's not the
correct URL and the the path to the the
commit messages as changed though I'd
have to type date this example it a
little bit but you will get the idea
anyway so in groovy even before
mentioning the the chasm sloper class
when you do new URL it's going to create
a you know java.net URL but gris also
adds utility methods extension methods
to types from the JDK so on the URL
class perhaps it's even a final class I
don't remember but we can add new
methods decorate existing classes from
the JDK or third-party classes with
additional methods and dot text is a
shortcut for calling get text the get
text method which has been added to URL
by the groovy development kit as we call
it the GDK and with just you know new
URL dot txt you are doing an HTTP GET
for the this remote resource so in just
one line of code you can consume rest
services very easily so you don't have
to create you know your to open URL
connection get the stream create an
inputstreamreader put all the all the
lines that you read inside a string
builder or something like that in just
one line of code you save 10 lines of
Java code so i really i recon I'm sorry
I retrieved the remote payload then I'm
instantiated the JSON sloper class which
has so the the API looks like the the
external support it's got a parse text
method which I can call on this text
JSON payload and then although I didn't
define some intermediary data structures
I can directly go through the the chasm
rough and say okay I want to retrieve
all the Comets nodes in that graph I
want to retrieve the message note of
each commit message so that i can print
each message okay so in just a few lines
of code I'm able to quickly do something
with some remote payloads so that that's
quite powerful so that's for consuming
Jason content but you can also produce
Jasmine content so similarly to our
external support we've got a builder
class in which you can call so person is
not a method that actually exists on the
jason bittel class but it's somehow
interpreted by groovy to create the
person person key in the JSON payload
that we are creating inside that I'm
going to have well let me show you what
what it generates so it's creating an
object with a person key which is well I
associate another JSON object there
again with key and values name Guillaume
age 35 and the pets when I have a list
here of pets it's going to create a JSON
array and that's why you see the square
brackets and well that's basically it
also it looks like again our example
support boat well that's for Jason and
sometimes the well usually the api's
return some compressed somehow Jason
because they it's not nicely formatted
for a human reading so when you have a
payload like that and you want to you
know for debug purpose or something like
that for debugging purposes you can just
call pretty print from that JSON output
class and have a nice output from that
so this is the vote goes to our abuse
over obviously equivalents so that's it
for the Jason support any questions of
our now
good oh yes there's one sorry say it a
bit louder so I think that for example
the the fastest J's library I think
these days is Jackson and Jackson is
faster than this implementation this one
is as got the same performance or
slightly better than the JSON liebe
library which agree developer used to
use before this support but usually it's
good it's good enough but perhaps if you
really care about path months the the
Jackson one might be a bit better okay
no that's it hasn't changed much since
Green 18 but there are some for example
the Builder which was a compiled well
I'll come back to some of the pictures
of greed claro which are that static
type checking and study compilation and
there are some things that we're going
to combine statically to gain better
performance in in upcoming releases so
we might revisit that but currently it's
small as the same performance between
the the latest major versions of glory
okay aqui aqui facility of Ruiz what we
call a ste transformations so HT stands
for abstract syntax tree that's the
in-memory representation of gooey
program and we have this this will be
like a compiler plugin you can plug into
the group groovy compiler to change the
structure of your program before it is
actually compiled down to bytecode and
thanks to that capability we can
annotate
some elements of your programs for
example we can annotate a class method
field etc and actually do some
transformation before generating
bytecode and we have several
transformations which were new angry 18
and the the first ones came in 16 then
some other ones in 17 and the latest
ones now in groovy 18 and 20 as well
which simplify I would say the life of
developers one of the key goals of
groovy the design gold and I could say
is that we always try to simplify the
life of developers by for example
allowing you to write less boilerplate
code okay so let me show you a few
examples so I'm not going to show you
all of them because it's a bit too too
long and I want to spend some precious
time and greet ooh that'll we have this
at log annotation which triggers a
transformation which injects a loader in
to your classes and which does i think
i'm going to ask you a question when you
do some logging in your classes so first
of all log is instantiated and as a
field of that class so you don't have to
declare it and you can use the log
variable directly log info and is there
something missing in that example
something that you usually do when using
logging api's any idea yep enable so
usually when you write something like
log dot info you surround that statement
with if so depending on the API you use
but if log is debug enabled etc so
depending on the API that's not exactly
the same call but to avoid the
computation of complex strings and that
kind of stuff so you surround that code
with if debug info enabled etc and
actually the transformation
is looking into your code to wrap calls
to the logging API so it's transparent
it's done for you so even if you forget
the groovy compiler will do the job for
you okay so that's a key key aspect of
groovy to try to help you focus on the
job rather than the technical boring
details so there are different
implementations for the different
loggers like comment log in La Forge etc
when you are executing groovy business
rules for example you might want to
check that the code which is being run
on your system is somehow safe for
example you don't want users code
perhaps to do infinite loops or to run
longer than a certain period of time and
there are some transformations which
take care of that for example if you had
a script which did while to consuming
lots of CPU you could use the thread
interrupt transformation which actually
somehow transparently inject statements
like like that thread current thread is
interrupted so if someone interrupted
the thread externally in another thread
you'd be able to stop the execution of
that tube so for people who execute
scripts coming from elsewhere from third
parties this can be handy and also
there's a feature I'm not going to
mention that you can hide the usage of
those annotations so that the the guys
writing the scripts don't even have to
take care of adding the the import so
you can hide that so this one is
triggered when the thread is interrupted
but there's also one for custom
conditions if you let's say you run low
on memory or something
define your own conditions and there's
another one for time to interrupt where
you can specify okay I want you to stop
the execution after 10 seconds and that
kind of stuff some other handy
transformations for example if you want
to generate some friendly two string
method instead of you know person at 61
AF blah blah blah you can also write
your own two string method obviously but
if you want a quick to string you can
just annotate your class with at two
string and it's going to generate that
kind of do you see by the way from the
back Wendy I know when you're in the
back of the the room it's not always
readable you see the last statements
correctly yeah nope you're sleeping okay
well or I could yeah well so to string
we have also equals and hashcode which
generates well equals and hashcode
methods nothing really fancy so for
those who know the long book project for
java it's a bit the same kind of
transforms somehow to inject equals and
hashcode methods so i created to
coordinate I kayden check they are
actually equals and that their hash code
are the same so again that's the
compiler under transformation which does
the job for you to implement those
methods tuple constructor that uh that's
creating the usual constructor with the
different parameters so I can use a name
and age and it's creating the person
string name into H constructor and yeah
that's it that's all I wanted to say
about it another one but again for your
plate code when you create your own
because some exceptions you have to
extend exceptions and you have to even
if your instructors don't do anything
you know more clever than just
forwarding to a super usually you always
have that boy that boilerplate because
you have to specify the four
constructors and cold supper but if you
just annotate that class without inherit
constructors it's going to inherit from
the parent class constructions and just
delegate to supper and that's it for
some of the transformations and there
are many other features but I wouldn't
have time to speak about the the groovy
to dollar features so let's move on and
speak about groovy to little some
questions before moving forward to the
two-dollar features no it's ok good so
what's in store for groovy to the room
so first of all brie we released burrito
at the end of June and since then we
released as there's a question at the
back so at slug does it do what I didn't
hear you yeah yeah it's a the is log
enabled is added automatically but by
that transformation so it's done for you
you don't have to do it yeah so we
release greeted ro in June and since
then we released some other dot releases
so the current major version is 20 dot 4
with you know bug fixes and so on and so
what's in store the key themes are
modularity java 7 alignments with
project coin and also the invoke dynamic
support and there's a static theme with
static type checking and static
compilation let's have a look at that so
people using grew in their projects are
usually using what we
the groovy all jar so it's a brewery jar
containing all its well all the while
all the language plus all the API is
because groovy is not just about the
long wait but it's also about api's
which I'll provide it like there's a
template engine you can create swing you
eyes you can do lots of things with
groovy in a nice groovy way and the this
Charles om beds ASM for byte code
generation and antler for parsing which
are the two jars which are essential for
groovy to be able to parse programs and
compile to vodka and this big jar waste
in at 6 megabytes which is yeah quite
quite big well these days with our big
hard drives and so on doesn't matter
that much but well still it would be so
the thing we we had in mind was that not
everybody needs everything for example
in your project perhaps you don't need a
turbulent engine you don't need the end
scripting capabilities to reuse and
tasks so what about splitting this big
groovy jar into smaller jars so a groovy
core jar with just the language
basically and the ability to parse and
compiled language and some smaller jars
for different modules ok and I'll say a
few words got the last bullets let me
not go too far um so now the the core
jar is just three megabytes so it's half
the size and we have those modules the
console for the Guru swing console we
have the sublet support template support
etc or the Jason support is also it's
also a library in itself that you can
use so you are able to pick up just the
features that you want but you can also
still use the
groovy or jar if you don't want to
choose and that was the last bullet of
the other slide that I wanted to mention
in the way we created and we made gree
modular we introduced a feature which
witch is which we call extension modules
or extension methods which is the
capability of decorating types with
additional methods so for example here I
want to add a new method two string
method to string not to string so that I
can use Guillaume introduces Cedric so
it is a method which doesn't exist in
java.lang.string but a method that i'm
going to add so there are different
mechanisms for dynamically adding
methods to tides thanks to expand
ohmmeter class thanks to groovy
categories etc but this is another
mechanism which is also interesting
because it also works with static type
checking and studied compilation and is
also friendly towards ids for code
completion so it has some additional
benefits compared to all the other
mechanisms that existed for adding new
methods to x so i create a class called
string extension with some with some
static methods the first parameter is
the actual type on which i add a new
method and the remaining parameters are
the actual parameters that are passed to
the method when i actually call it in my
in my code so self here is going to
contain the guillaume string and citric
is going to be put in the second
perimeter here and then I'm ring turning
a g-string an interpolated string and i
can replace the name and self variables
and then i'm able to use that guillaume
introduces eric and to do that so it's
exactly like Ruby categories for those
who know them
it's a little detail we can do that for
instance method but also for static
methods that's the same mechanism except
that here we don't care about the actual
variable but we just care about the the
type of the first parameter so this is
the same kind of structure for the
extension modules and you have to create
a descriptor for your module with the
name version the the various classes
which provide instance methods and the
various list of classes which provide
static methods and you put that into
this file in meter meter in services etc
so this is a nice way for extending jdk
classes and or third-party classes from
third-party libraries okay and yeah I'll
speak again about static compilation at
the end of the presentation but so it's
nice because this mechanism works well
with static type checking in the
competition but I will come back to that
I mentioned java 7 and jdk 7 theme so we
since groovy supports let's say 99% of
java syntax we also thought that it was
good idea to provide the same new
enhancements that were added in java 7
for example the binary literals for
defining numbers so with my 10 11 1
etcetera so we support that notation we
also support the underscores in your
later robes so that's nice for things
like credit card numbers or separating 8
bits etc we also have the multi catch
where you can catch different exceptions
are your exception as well as no pointer
exception instead of creating two
different
blocks and we agree to supports invoke
dynamic in what dynamic is the new
feature from Java 7 and jdk 7 to improve
the life of dynamic language
implementers so the idea is to provide
some specific bytecode instructions as
well as api's to to improve invocation
of dynamic methods and the goal of
invoke dynamic one of the key goals is
to bring some more performance for
dynamic method calls and in the long run
it will also give us the opportunity to
get rid of some of the techniques we
used to improve the performance of
groovy okay and now the big 22 big
features which are static type checking
static type state and study compilation
so one of the complaints we hear from
static language guys or for all from
newcomers to grow is that there's this
fear which is more cliche than a real
problem in practice this fear that okay
it's a dynamic language so when I make a
typo in a variable name or in a method
name I'll get the error at run time when
my application is deployed in production
usually in practice you create tests
you'll run your code in a way or nother
so you never get that in in production
but anyway if you want to get early
feedback for common mistakes like typos
and methods and variable names if you
return some wrong values according to
the return type of the method etc if you
want that kind of early feedback from
the compiler you can now use static type
checking let me show you for example in
this little class
I have a method called method that's
very funky Metheny and actually I made
an obvious typo here and i also have a
local variable name and i made another
typo now if you compile that because you
used the type checked annotation the
compliation the yet the compiler will
throw compilation errors because didn't
recognize that method and that variable
which don't exist and the annotation can
be put at the method level or at the
class level so you can have the same
kind of feedback from the groovy c
compiler as you would get from the java
c compiler it can check wrong arguments
let's say you want to sign an object
into a primitive value or let's say
you've got an array of strange and you
you want to put the the first element of
that array into an int etc all these
things will also trigger compilation
errors like in Java obviously another
example if you have a method which
returns an int so here in the else part
it's ok 42 is a is an integer but here
I'm trying to return a string so it's
going to complain again with a
compilation error and not a real time
ever and something like for example with
string builders you can use that
notation to append strings to your
string builder and automatically groovy
uses to string although this is a
stringbuilder here the the value of that
expression is the string is the string
builder Ruby automatically calls to
string when you return the string so for
that kind of things the groovy compiler
won't complain so you can still write
giriko the same old way you've been
writing Ruby code including things like
the the automatic type coercion that URI
provides so just annotate some parts of
your programs with type checked
especially the parts not needing dynamic
features so that you can get the same
kind of feedback from the compiler with
static type checking we also do type
inference so here name although we
didn't say string name but this variable
holds the string so i can call things
like to uppercase I can call trim which
is a method that was added by the groovy
development kit and yeah that's pretty
much it you can do it figures that the
variable n from the for loop is actually
an int obviously we created an int array
so it works it just works I mentioned
that it should be using tied checked on
Greek codes which are actually not
dynamic because the compiler cannot
really know what you're doing when
you're using some specific dynamic
features for example when you when you
use builders for creating HTML markup
you can create HTML body deve nodes
which are dynamic method calls and this
kind of stuff cannot be type check
because you could be creating any kind
of node so there's no way the compiler
can figure out what you watch what your
intent so you can mix methods which are
studied league checked and usual dynamic
methods by just annotating the ones
which are tied checked something in Jon
which is always be painful has always
been a bit painful is the fact that when
you've got some value here which is just
an object and you want to do different
computations depending on the actual
type of that perimeter when you do if
Val instance of string then if you want
to use the two upper case methods you
have you have to create a local variable
or you have to use cast etc it's a bit
against a bit of oil plate code
but the groovy compiler is smart enough
to know that okay if you make that check
that means that at that point we know
valleys string so you can call to
uppercase visually and what's the other
part yeah so you don't need casts and it
also understands well the the gooery
development kit methods added to things
like strings oh we're going to some more
hairy details when you have something
like so here my method returns and least
which contains an integer earn three dot
14 in group ID faults a bigdecimal so
what's the the common what would be the
inferred type of something of that
expression which what is the inferred
type of the the return value of that
method list off so I here objects
numbers okay what's interesting is that
it's able to figure out that numbers so
it's a indeed a list of number but
numbers well number doesn't implement
comparable but integer and bigdecimal do
so it's able to figure out that the the
actual type is a list of number and
comparable objects right and it's not
something it's a you cannot really
express that in in Java there's no way
to provide annotation for them so it's a
quite fine grained type that we infer
here so with more you things are
smoother and we also figure out so that
well it's called lowest upper bound and
we usually write L you be so that's why
I made that bad joke anyway I had to
explain because we always say the lube
of blah blah blah is it say that well
it's more a job for the groovy
developers implementing the language and
when I speak about type inference we
have this so it's part of type inference
an aspect we call for typing sometimes
people so it's not really a good
practice to do that but still uses of
groovy sometimes do that you use
variable which is not typed so in VAR i
put an integer then well i could put
that into that in variable then in voir
i could put a strain so i'm changing the
type of the variable but well if you're
changing the the value and the type of
that variable let's say here i can call
to integer because groovy figures
figures out that this is actually a
string but then i'm putting back again
an integer a number and if i call to
uppercase it's going to throw a
compilation error because ok you changed
again the type of bar but now it's a
number so there's no to uppercase
methods all right so it's following the
flow of assignments to figure out okay
at this point it's containing straining
the number etc so some some gotchas type
checking is interesting but it's limited
in the sense that it won't work for most
of the the dynamic aspects like the
builders like expand ohmmeter class and
I think I had some further example of
that for example when you use like it's
often used in the Grails web framer to
extend classes for example if you want
to add a few method on integer you have
to access the the metaclass property
which is a dynamic property and then foo
is also well dynamic methods which
doesn't really exist on on integer so
this is actually not allowed by the
static type checker because we can never
know someone from another thread
would add a new method perhaps or it
could remove the full method etc so i
can make any guarantee that the full
method is actually here so that's why we
we've taken a safe approach to to that
problem by disallowing certain dynamic
aspects of the language when you use
type checking at least and sometimes you
have to be explicit for example when you
want to transform that least into a list
of uppercase values the type checker
will complain because it the default
variable of that quarter I mean the
least might be coming from elsewhere IAM
you you're not sure if it just
containing strings could contain numbers
and whatever so you have to be more
explicit by specifying ok the the
perimeter is actually string so that the
the type checker is happier but we are
working on some solutions to be able to
avoid having to type things so that when
you can figure out ok the type checker
can know in this specific case at least
that it's a list of string so it
shouldn't require that string it stuff
ok i think it can skip some of those
details here or terms it still have five
or seven minutes there are some cases
where things are harder to figure out
for example if there's a variable and
it's related to a flow typing that i
mentioned earlier sometimes ok of our
variable can contain a string that it
could contain a date but that quarter
could be executed or not we have no
guarantee for example if we pass that
quarter to sum up some other class or or
or imaging that you do if random and you
execute the closure or not depending on
the on a random value there's no way the
compiler can know what if the course is
actually called or not at runtime
well at compile-time cannot know so we
complain the compiler complains and say
okay this is not okay because okay we
assign a different value here here it's
obvious that we do change the variable
but you can always know this is the case
so in the end what you can call here is
the the lube the last upper bound and
perhaps it's better illustrated with
this other example here I have a and B
which extends a so I create a new
variable with a an instance of a and
here in the quarter it's an instance of
B so whether the closure is executed or
not we know that at least that variable
is going to contain an A or a B but the
foo method is available on both a and B
so the compiler is clever enough to
figure out figure that out and not
complain here okay now that we did
static type checking the compiler knows
a lot about the type information which
is available okay so why not also
generate the same kind of byte code that
the Java C compiler generates and well
that's what we do if you use static
compilation and this is triggered by at
compiled static and a notation so it
provides type safety by using reusing
the static type checking it obviously
provides faster code so map or more
performance and also since the actual
method calls etc are not going through
the dynamic heart of guerrilla meet
objector call it's also immune to monkey
patching because someone in a dynamic
part of your application could have
changed how plus works
that kind of of William with stuff so
we're able to be well to protect you
from people trying to change the
behavior of your code from some other
thread or something like that and in
that case just like when you use static
type checking you use you you you lose
or it use the the dynamic features and
dynamic method dispatch but you gain
some nice performance like the the
previous example with type checked you
can study click compile certain methods
and for example when you want to use a
builder a GUI builder which is dynamic
feature well this part don't compile it
statically okay so you can mix and match
statically compiled code and dynamically
then with dynamic dispatch code so what
about performance I've done some small
benchmarks so I haven't updated the
figures with 204 so this was with I
think 200 200 so I took some usual micro
benchmarks so micro benchmarks are worth
what they were so beware of micro bitch
micro benchmarks because they never
really do justice to the code you
actually run I mean your business called
your real application so you'd better do
some actual measures of performance of
your code rather than relying on what
micro benchmarks say in green 17 we
added some code for when you were doing
some primitive type calculations not in
17 sorry that was in 18 that we
introduced that so for code relying on
number crunching we got some good
performance thanks to those improvements
and then in greeted alone with static
compilation since we generate pretty
much the same bytecode as java well we
if you just look at the numbers anyway
without any kind of optimizations if you
did
fibonacci implementation you could be
well ten times more than 10 times 12 or
yeah something like 12 or 13 times
slower than Java so this is a worst-case
scenario okay because usually your code
is not 13 times slower than JA so these
micro benchmarks are interesting for us
because they show the worst-case
performance for group but usually it's
not that slope fortunately and if you
look at if you just compare those three
benchmarks in terms of numbers this is
usually as fast or almost as fast as
Java okay so there are still some cases
where we can do perhaps agree to that
one etc will be able to squeeze some for
other puff mins because perhaps we still
have some redundant bytecode
instructions and that kind of things but
generally speaking the the goal is to be
just as fast as Java for those parts
which are statically compiled ok so
we've come to the end want to have at
least one minute for questions the big
themes of brewery total all the
modularity allowing you to also create
your own extension modules the jdk 7
related things with the syntax
enhancements of project project corn
like multi catch etc the support of
invoke dynamic if you're lucky to run on
jdk 7 in production which is not yet the
case everywhere you can use you can
benefit from performance improvement
when you run on jdk 7 and we also added
a static theme with static type checking
and static compilation for Ruby that's
it thanks a lot for your attention and
I'm happy to answer some questions
so if you don't use jdk 7 is there a way
to backport to let say when you were in
to jdk six there's a library which is a
invoke dynamic back port for earlier
jelly case but we haven't used it yet so
we might be using it at some point but
the thing is that for further versions
we might require jdk 7 but that will be
for agree 3 which will be reason let's
say in a year from now and if you look
at the performance the current
performance of jdk 7 with invoke dynamic
isn't that far from our own techniques
for optimizing the the brewery bytecode
so there's not yet till the BM engineers
do their work but i know they work on
that because of long does etc which is
in vogue dynamic so we could do the back
porch currently we haven't worked on
that and the performance is is already
good without it and wouldn't make a big
difference because the back port is just
a backboard so it's not really
benefiting from the performance
improvements the jvm engineers put in
jdk 7 pure I mean as long I think I mean
it would work for grew it would work for
the languages that would use invoke
dynamic calls yeah I don't remember the
requirements but it might still require
jdk s6 at least I think another one
hundred percent sure but that might be
the case other questions over there in
the middle
so like using it all the time instead of
just once in a while yeah so well it
depends a lot on the cat of Ruby code
that you write for example when you used
api's like the Jays and support XML
support usually you like the fact that
Greece dynamic because you don't have to
generate intermediary data structures
and that kind of stuff so usually you
would probably use type checking for
library code for code that is not
dynamic at all and then if you notice
some performance issues also use static
compilation for those parts which seem
to be a hot spot so you have to mix and
decide depending on how you use the
language and the virus features and
let's mix and match that's that's the
the point yes yes
oh yeah foo foo yep right yeah so the
thing is you can there's a an annotation
parameter you can say skip for example
if you are notated the whole has to be
statically compiled you could say okay I
just want to skip that method to say
okay don't statically compile it but
currently we don't have the mechanism to
apply it by default but it's it's a
feature we request to know we might be
adding it perhaps in 2001 or something
like that by default yeah at least for
now you can do that yes yeah and later
on we might also perhaps through a flag
when you call the compiler whether it's
through end maven gradall etc you'll be
able to define a flag that says ok 44
all the classes I want them to be
compiled statically by default and well
we haven't implemented that yet but at
least you can already do combine static
then compiled static skip etc yeah over
there the back yeah okay okay sure so
thank you and come and see me for the
next questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>