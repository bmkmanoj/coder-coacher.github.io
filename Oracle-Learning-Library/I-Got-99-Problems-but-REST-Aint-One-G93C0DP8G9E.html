<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>I Got 99 Problems, but REST Ain't One | Coder Coacher - Coaching Coders</title><meta content="I Got 99 Problems, but REST Ain't One - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>I Got 99 Problems, but REST Ain't One</b></h2><h5 class="post__date">2013-01-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/G93C0DP8G9E" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so so I just wanted to have a
catchy a slide one of the things that
led to this presentation was a work on a
new source project called Jake clouds
and we have like a hundred different
various cloud providers to make
connectors for and all of them run the
gamut about what rest is and and there's
a lot of reasons why things look look
like they are and so I figured it would
be a good idea to actually take that
knowledge and and try and package it up
and if i can use big bold all caps fonts
that you know that's also good so
problems we're going to discuss really
is the agenda is a little bit of
background why API and then sort of like
differentiating what's different people
say or what they mean when they say rest
because it is a fairly ambiguous term
and then we'll look at some some design
patterns that are applied to AP is like
real ones so it's my twitter i'm an
architect for cloud hub at mules soft
around the corner which is an
integration says thing you can make like
data loader tools for sale sports and
stuff with also founder of j clause
which focuses on infrastructure and
storage API is like easy to and s3 want
to thank the folks at that contributed
so the way I normally do sessions and
topics is I go and ask everybody what
their opinions are as many as I can
actually get and sometimes it's more of
a fire hose and others this time it was
a bit of a fire hose to be honest to ask
people what their ideas are in rest lots
of people will share them with you
there's a google group called API craft
which is pretty handy and that's a bunch
of folks that i think they call
themselves rest pragmatists Matt
Stephenson who's actually a member of
the J Klaus project also has worked at
amazon web services in the past and gave
some insight about that we got Greg
Campbell from Twitter who gave some
insight about
how their their API is work and of
course some Uli's that I work with who
we've had series and series of debates
about API practices internally to try to
to help guide people in re directions so
that was also helpful and very
conveniently timed so the first thing is
you know why do we API in the first
place like what's the point and a lot of
people feel like they need to put
something up there but it's really handy
if you know sort of like what others
motivations are what I found and I've
worked in ecosystem engineering for a
few companies that have rest api is
including vmware and the biggest thing
people are looking for is you know more
collaboration and in aims to grow their
ecosystem so when you have you know
gooeys and all that right people can
interact with them by the ways that
you've already defined it's sort of like
the pre-2006 cloud model where there's
like these elastic services but you've
got to use a software somebody already
wrote for you and within the API driven
world what you do is you sort of change
that so other people can actually write
software against your back-end services
and make meaningful and interesting
tools with them at that facilitates
innovation and that's what people want
to do you want to be a building block
for other other folks innovation and and
I think we could probably have a long
discussion about other folks and I want
to hear your pains at the end but these
are some of the aspects I think are
really the motivating factors behind why
doing AP is in the first place and the
how part a lot of folks start with you
know a decision tree okay is it going to
be rest or is it going to be soap and I
argue that it's more like rest versus WS
star because what are you looking for
from soap were you looking for the
attributes that are more standardized
relating to transactions or relating to
any any of the other identity services
that are actually well defined and out
there and you know folks that that have
strong feelings towards some things that
are not standard might might end up go
towards rest and there's a pretty
interesting book by George Reeves where
he actually is pretty publicly not so
much a soap fan or a WS span but uses it
internally for other in their systems
interconnections so you know you don't
have to have a conflicted relationship
with api's you can choose is mainly what
is guiding you towards that because this
is a talk about rest I'm not actually
going to drill down into WS star very
much but suffice to say that there are
there are other factors involved and one
of the interesting things about rest was
rest was actually defined in the year
2000 all right so Roy Fielding's
dissertation on the topic which you
could google now and then not hear
anything I say for the next 10 minutes
was was actually you know made quite a
long time ago and so a lot of the a lot
of the ws star specs were actually made
after this dissertation was was defined
and so there's some interesting things
in history and it's actually really if
you look back and you see like now here
we are 13 years later nearly and you
know there's still this catch up with
rest and so it is to me like the history
of breast is is a fascinating topic and
so luckily we have the internet and you
can find all sorts of documents along
the ages but what I'll do is I'll try
and focus on what I feel like a lot of
people are contending with today which
is sort of rest versus rest ish and rest
ish is pretty much what everybody does
and rest is pretty much what hardly
anyone does and I'll get into that and
that's not a judgment either it's just
the reality so it's it really ends up
being people feeling okay I need
something that's not soap or I'm doing
something that's angled towards a very
specific style which you can pronounce
it however you like I've heard a few
things hey dls a dios and hate us so
choose choose your favorite
pronunciation but the idea is is that
you have
you know a structure of of crafting ap
is that has some design tenants and and
you can go and pick everything out of
the book or you can cherry-pick certain
things and what I've noticed and
practice actually there's a pretty
interesting thing you can do is actually
go to stack overflow and and ask about
you know true rest api s and there's
like six topics and only but the closest
one might have been netflix actually to
actually the strictly defined public
service that's thirteen years later
actually using the the more strictly
defined rest so when I say strictly
defined rest what do I mean well seeing
a bunch of different content about like
what what rest is and and there's
basically an idea that there's levels
and you know the level zero you know is
where a lot of folks started when they
were just putting api's on top of their
things and this this leveling suggest
that you will end up eventually at level
three who knows if you will but if you
ever hear someone say level three rest
api you're about to understand what that
means there's only a very few amount of
places where you would ever have anyone
say level three rest api also admit
doing the research for this talk you end
up getting into these worlds and these
these spheres and there's spheres inside
of spheres so I'm going to just give you
some ammunition and save you a month of
research so swamp appox plain old XML so
the most common example of what's called
us you know swamp up pox API could be
soap itself from the perspective of rest
folks the anything that basically uses
payload as the only aspect to figure out
what's going on is a level zero API so
that means that you know if it is is it
get you you don't know what's going to
happen
maybe that get is actually going to
delete every resource in your entire
company who knows you cannot tell from
the way that the API request is
structured outside of reading the
payload and so this does say XML you
know you you will see in the next slide
that you can argue the lines is XML
important probably not the main idea is
that there's a single API for all
resources there's a single end point for
all resources and you have to look
inside the payload to figure out what's
going on resources is the level one what
that's saying is that through the URI
you can determine this you know what's
actually being affected even if you
can't determine what's happening to it
so this is a fairly strange example what
you're saying here is actually the
Amazon ec2 API you could you could argue
this is actually a pox API because for
example it's you know it's not there's a
base there's a base server path right
easy to AWS com there's nothing in the
URI to distinguish it's all inquiry
params and in fact that could actually
have been forming coded and then if
we're talking about comma separated
values versus XML what's the big
difference so you could argue this as
being a pox API if you wanted to and
however what what resources say is that
there's something suggestive inside the
URI where you can tell at least what's
being affected you cannot necessarily
tell what's happening to it based on
like HTTP verbs and you can see for
example here the resource and what's
happening to it is conflated in the same
word so delete volume is action right so
it's actually complaining two things at
the same time so basically the side
effects are API specific you can get an
idea of scope by looking at it but
you're still going to need to understand
the API to understand like exactly
what's going to happen if you do
something like this
the verb approach is where most api's
that suggests their restful or actually
doing so verb approach basically says
okay we now know what the scope of
something is but we're actually going to
use more aspects of the HTTP request and
response to to allow people to
understand what's going on so and it's
also fit more more prescriptive so
sometimes people think of rest api sore
web api is like crud it's sort of crud
plus plus or or crud with a little bit
more gravity so for example there's
there's things in the HTTP spec about
like item potency of certain commands
like for example if your if your verb is
head it's not supposed to affect the
resource in any way the only thing
that's that's able to affect multiple
resources besides what specified on the
line is post and so so there if you
actually look look sort of verb by verb
then ideally you can have an eye you can
get a good sense of what's going to
happen to the resource without knowing
what the API is and so that that's a
handy framework to actually work within
it it also and it's not just the request
so in this request what we're really
looking at here is is something where
things are encoded within the dns name
so the resource affected is actually my
bucket which is a subdomain their head I
can I already know s3 so forgive me for
knowing too much but I could guess based
on head that that's actually not going
to return the entire bucket here it's
actually just going to give me metadata
on it and and that you can sort of get
AG agents in some intuition with with
the knowledge of the basic frameworks of
HTTP and understand what's going to
happen also what's the response code of
doing so for example if it's 200 or 201
I might expect some content back if it's
202 that means accepted meaning that
something is going on beyond it's not a
synchronous command
some is they just accepted the idea so
you can actually look at the response
code and get a good idea of of what's
happening and and so it's more than just
verbs it's there's just a lot more
meaning and and that's why people have
kind of gravitated towards this is
concise it's not overly prescriptive but
a lot of times you do have to affect
resources and you do need to know
generally what they're going to do it
helps with caching and all sorts of
other aspects that you need to deal with
with ap is the the level three is
hypermedia and this is a Roy fielding
hey gos thing right so I have found one
API that is is I would say purely
restful in that way it's not a it's not
an extremely popular API outside of like
a the domain of infrastructure folks but
vcloud is is actually more restful than
netflix which is the only one that i
could find it's actually somebody might
recognize why do i say netflix is and i
don't actually have a screenshot of
netflix but netflix has a very specific
structure of the HTTP pass and you just
you can decide what what's actually
going on mainly all the documentation
discusses aspects of the uri so for
example here you can see there's some
hints like head log item but generally
speaking in truly restful api s they are
always going to say that href is just a
an ID so treat it treated nothing else
because everything you need to do with
that resource is defined by its links so
just just use that as the ID to get
access to that resource if you want to
store something store its href but to
tell what you can do it's the idea is
that you're not actually looking at
documentation you're going to say ok I
can tell what to do by virtue of
whatever links are present so okay I can
remove it because there's a remove link
here or i can edit it and and there's
there's a mapping between some of these
these relationships which are defined in
in various specs that you can actually
say okay what command would i use to
remove so that would be delete what
would be edited it would be a put in in
restful natures it's a little bit
chattier in in the hypermedia controls
because for example update or edit is
intent as a replacement command so we've
actually supposed to send the entire
text so you'd have to get the previous
xml or whatever it is and then actually
push the entire object back so it's sort
of like a synchronization protocol in a
way so the things that are handy about
it is is the is sort of the way you can
walk and discover things so one of the
things about royal Fielding's definition
is that you shouldn't need documentation
to discover what to do it doesn't mean
you shouldn't need shouldn't do
documentation it's just that everything
is discoverable you you enter the the
the API and then we'll have like down
links for all of the resources inside of
them and so what happens is that you can
actually discover new resources and new
actions on resources as you go so it's
so it's actually you know if you're
looking at a level 2 api's generally
speaking what happens is you look at
their documentation page or maybe
something called waddle which you found
on their documentation page and and then
just by that type you can you can figure
out what you're doing because there's a
type associate with specific version it
it's not that hypermedia AP is are not
typed it's just that they're typed at a
finer granularity so for example you can
see the accept header here specifies
that okay in this specific view you know
in this xml view of this this resource
that's that's what i'm actually
interested in and so as long as you have
a mapping to what these various resource
types are where you normally what you
would see like application XML or
application Jason
you're seeing here actually a vendor
type so the type is actually not / AP I
with a list of predefined types is
actually / resource and you just
discover them as you go one of the
interesting things about this is like
how do you decide what those types are
about so for example in vcloud their
their discovery API has links to schema
for each of these types and so there's
some things that you the prac
practically you have to do if you want
to support it so you know what's what's
good you know about something if you're
if you're publishing in XML most the
time people are going to want to know
exactly you know what's inside of there
the the fielding definition really only
defines the fact that there would be
links inside but not necessarily the
form or structure of the documents in
fact that's the point the point is
actually to have a more of a framework
that's self documenting them to create a
type system so I / media is really it's
very interesting and i have to say when
i first work with hypermedia i didn't
like it at all I it's grown on me but
I'm a bit of a bi rest you'll like i
don't i don't mind partaking in both the
type to in the type 3 api's so let's
think again about these transitions so i
mentioned these links and so all
transitions are discoverable by links so
if we look here we saw these links here
what is that basically hint at and hence
at a state machine right so hey TOS
really stands for hypertext says the
engine of application state so state
machine and that means that you know
you're you're you're aware of the valid
transitions based on the links that are
present in the response so for example
there's a number of standard
relationships and what you might end up
having to do is define new relationships
because of the domain of what you're
working with so for example if I'm
working with a virtual machine I might
need to attach a disk to it well that's
not going to be in an HTTP spec
someplace so you might actually have to
name space and create new relationships
too
represent the new states that are
actually valid for this resource which
again hence back to the fact that you
still need to document things even if
they say they're self documenting the
interesting thing about the you know the
the truly r st one is that it maps very
well onto permission schemes so in a way
if you look at a level 2 API you can
find out what you don't have access to
by trying to do it and see if you get an
excess error because you don't
necessarily know if you have fine
grained permissions model what you're
able to do until you actually do it and
fail you know they're they're very few
API is actually have a metamodel for
figuring out what commands you're
allowed to operate against in in the the
hay dios style think of permissions it's
just a mask on you on your on your state
your state diagram so if you're not able
to edit things and the edit link would
not be there if the server is down that
you are supposed to be adding something
to then it's edit link wouldn't be
available so what they're trying to do
is basically say that you know think of
it truly as a as a state machine and
when you design your api's keep things
like permission masks and everything
else in mind because that can help
particularly with graphical renderings
where you don't want to give someone the
option to do something they're not
allowed to do so so it's kind of
interesting how that works and this is
for example in the the Jake law's work
that I've done where I've worked with
the various versions of vcloud that's
how we figure out that we're an admin
user it's like okay well as admin
alternate view present or not if it's
there then I'm probably an admin user
and what does it even matter because
your your if your admin user you just
happen to have this role as long as
everything's represented by by links
that you can access then you don't
really care you just need to know what
what what things you're trying to do and
if they're present or not so so that's
something that's highly prescriptive it
and so that's another way to figure out
whether you're talking about a level 2
API or not because the if the API
doesn't have links it really can't
become a state machine whose transitions
are visible by API and I'd say one last
thing on this one before I ramble on too
much is that it's not terribly important
how the links are rendered so the the
links could be a part of a JSON Bowl the
links could be a part of an XML document
you could actually render them as
headers and some folks actually do that
so that they don't interfere with the
document itself they'll just add link
headers and there's a link header
specification too so just because for
example you're returning a binary file
or something like that doesn't
necessarily mean you can't use links the
biggest part is and I hinted at this
earlier is a content negotiation part of
the truly rusty things so a lot of folks
are there either use to specifying
something like XML or JSON or nothing at
all and just understanding it will be
returned the content negotiation doesn't
actually mean a fully expect out the
vendor specific thing is just in the
context of hay dios there they're really
referring to you know doing things like
versioning if there is any at the
resource level and that would be you
know the content type for that
particular HTTP path so what this allows
you to do it allows you to present
multiple versions of the same resource
and even do things like versioning at
the granularity of a single resources
opposed to the entire API so it's very
fine-grained because for example if I
have a media type for tweets or
something like that I could actually
update just the just the content type of
that tweet to like semicolon version 11
and upgrade that single component inside
the API well what without breaking any
one else so the responsibility is on the
client to present what they're capable
of dealing with so what happens is is
that you can actually support older
clients
because they will continue to present
the old media type so so one of the
things that's that's interesting about
dealing with Haiti OSAP is is just the
acknowledgement that clients are aware
of certain resources they don't always
update update their code and discover
their way through so you know you may
end up having to keep keep different
versions of your code and how is that
represented it's represented as being
having to deal with you know like
different versions in the accept header
as opposed to like different version in
the HTTP path so on a change first off
if it's a non-breaking change generally
speaking people don't don't change the
either the resource definition here or
at a version number basically if they
say if you add it if you defined your
API is one that that's that's going to
have the practice of adding adding
fields you know without incrementing
diversion then you know your users you
know will just work now that doesn't
always work because like for example in
practice I've noticed a lot of people
who have you know their own custom
parsers or whatever can break just on on
a presence of new fields so it's still a
design decision of what you mean when
you say like non breaking change but but
at the end of the day there's two
choices to change versions in atl style
of a specific representation one is to
actually to encode it in the name so
you'd put like one or something there at
the end of whatever the resource is so
say if it's canoes would be canoes
hyphen one another way would be to do
semicolon version and then whatever and
a lot of folks would put like a major
minor there I was talking with Dan Feist
from yourself about this and he actually
helped present this breakdown of impact
of versions and what one is is that you
know there's there's still a chance that
you're actually overhauling the meaning
of these of these types or they're so
different dramatically because the whole
thing is an overhaul
and and that's sort of the difference
between creating a new API in general
and actually just updating media type so
for example if we go back to the vCloud
thing here you notice they also put the
version in the in the path and there's
there's a couple reasons for that
there's an operational reason because
this happens to be you know represented
as a jetty war and it's very easy for
them to you know deploy things as that
but the the other thing is is that in in
their major versions they have actually
changed the entire scope of a resource
so for example this isn't again it's a
virtualization API but they would have
liked networks that are defined at a
higher level scope in one version and
then in the next version it's actually
at a completely incompatible scope so in
that case they actually bumped the whole
API so even when you're doing media type
versioning you may still get into a
situation where you're you're actually
semantically you're thinking about
actually a different API we're just
incompatible relationships and then you
may still have to have like a global
version if you will so a lot of folks
and I'll admit myself here is that you
know find the hideous style elegant and
you know it's it's pretty pretty
impressive because again you know 13
years a lot of people trying different
things out there it it does hold its
model pretty well clients always know
what their transitions are they don't
have a lot of surprises or that's the
idea you can be very granular with your
version and constructs all this we just
reviewed you might say go ahead and use
you know hideous as as your style for
creating a pis and the first thing you
probably encounter is is a perception of
complexity because what's happening is
if you if you like for example you get
to a finer and finer granularity folks
that are not used to that that
particular granularity might might
perceive that as additional complexity
and this is a the real balance of API
development in general and not
necessarily even related to rest is that
you have different
points of view where if if someone who
is looking for more and they don't see
it they'll think of it as a naive API
and if someone's looking for a certain
amount of features and they see too much
they think of it as overly complex so
it's it's really it's not an easy
decision anyway and so you know I'll get
back to this point later but you do have
to know you users will enough or at
least your use cases in which are
optimizing for and be aware of that the
other thing is is that it's not a crime
to actually have multiple views of your
services you can actually have like a
type to view because the interesting
thing is is that the type 3 hay dios
rest full design you can pretty much put
anything on top of that because you have
enough richness in the model to work
with so if you're using some sort you
know you could actually use like a
integration flow to just convert a
simpler view to a more complex view the
the other thing is to remember what
level two is optimizing for folks who
write a level two AP is are not thinking
of themselves as level two out of three
so I mean they're intentionally
designing things not everyone but but
give them a benefit of the doubt that
there's actually some design tenants
going going under and and maybe they're
not inside of the the same you know
mental models as other folks there
there's impact but it's not necessarily
show stoppers for using the the level
two and again that's more like you know
you've got JSON or you've got put in and
get and delete mean things the impact is
is that you have to do more coarsely
grained versions because you're not
actually addressing versioning at the
resource level and that that also might
impact the way that you deploy your your
your API code it doesn't actually mean
that it must be deployed as a single
monolithic thing because there's all
sorts of various ways that people do
continuous delivery and there's lots of
talks here at javaone to talk about you
know how interestingly people can push
changes through
environment so it doesn't necessarily
mean it's it's monolithic or its
resource version you can also have
different ways to just deal with
software deployment it's optimizing for
crud plus plus it's optimizing for for a
quick way to get the intent of what's
going on but there's a limited amount of
representations and so maybe they're
they're easy enough to document so for
example if your github is good hub going
to suddenly turn into a flower shop
probably not but then again you know
Amazon turn into an infrastructure
provider but seriously a lot of people
are not going to dramatically shift
their api's from from day to day and
there's also other reasons why people
version things so I'll get into this a
little bit later in depth but the you're
dealing often enough with services like
it doesn't mean you have to be like a
public service provider to treat
yourself as a service delivery model and
so maybe you're actually versioning a
collection of value that you're you know
delivering as a unit and maybe even that
value has constraints on it like okay
for example the latest Twitter API
release was really more about throttling
concerns than it was actually API
updates and so you do have to package
communication up somehow about what
changes going on in your environment and
maybe people don't want to know bit by
bit every resource oh this resource is
new oh this is resources new because I
crawled the API and found it maybe
there's a communication pattern or some
other reasons for bundling up features
and maybe that actually fits nicely into
a more coarse grained model the other
issue is today's tools now I mean I
mostly do Java development and if you if
you look around and you you know use
those letters hay dios and then do that
with java there you'll find like some
incubating things even though it's 13
years later so for example I've noticed
that there's an extension to jax-rs it's
being sort of kicked around there's some
tools I think yay way guys and in Sweden
or
working on some some tool kits but it's
still surprisingly a work in progress
there's a spring Haiti else which is
also evolving and so the the question is
is like you know maybe you want to
optimize for tooling and sometimes even
with the way that an API is represented
is because like rails is easier that way
or something like that so sometimes
people are optimizing for four different
aspects and maybe there's aspects are
just what's on the ground and what's
what are they able to use the other
thing is is that there's this sort of
like simplicity / elegance or call it
pragmatism or however you want to name
it but there's some folks that that
strictly you know say you know a rock is
a rock you know this is this it's not
going to change tomorrow maybe two
changes six months but let's let's keep
things simple and this is a big debate
and to a certain degree we have to ask
ourselves is it all just prickles &amp;amp; goo
if you haven't seen this is on YouTube
but it's basically the South Park guys
made a pretty interesting way of
describing the folks who like types and
the folks who don't like them in general
which is more an engineering discussion
than a software discussion but your
culture might end up being the one that
decides so if your culture does not
embrace something and that's you know
for example you're you're developing
something and you're you're trying to
attract and we remember we're trying to
grow our ecosystem and right now our
growth area that we need are more
developers who don't like hideous then
maybe I wouldn't play a hideous API in
front of them because what am I doing
this for and so you need to can you
consider the culture of your consumers
so at the end of the day I guess it's a
it's a really long winded way of saying
you need to know what you need and who
it's for and it's more about designers
and as designers we understand that you
know how it's used and he'll will use it
is important and getting feedback is is
important so you know all these things
are their impact is to design beyond
development but there are also
impacts of design that our development
so there's their scenarios where you
might you know might be better served
with one or the other we're both so and
again the iteration like how do you know
unless you ask someone so definitely
socialize your ideas so for example twit
Twitter's is certainly not you know hate
us somehow some people would probably
think their API is is somewhat
successful I think there's there's been
a lot of talks about their various api's
including the recent improvements
relating to straining so they actually I
have three different classifications of
AP is on under their bucket they're
actually they're all happen to be
version 11 but the that version doesn't
really mean anything except for a
collection of of what our value is at
the point we said one dot one exists
that what they refer to as rest is a is
an API that that generally follows most
of the level two things maybe they have
an accidental plus new in the URI
occasionally but but then again we
shouldn't judge too hard because their
rest api is an incremental update and it
was defined in 2008 and not that that's
ages ago but a lot of folks are figuring
out their ways and maybe the the
motivations for what they were designing
it for at the time were not related to
what what hey else is and the other
thing is is that like like in this room
went when i asked about the roy fielding
thing not not a lot of folks had heard
about it yet and and that's still the
case so maybe even that some of the
designers didn't didn't really know or
care to optimize for for the
dissertation search is not rest so
search is basically you know it's query
like you know you're you're going to
enumerate over various things and it's
not it's not fitting in the strict
strict models and some some search api's
are even more so because they're really
just even even like more like a
representation of SQL over HTTP but if
that's what you need then maybe that's
something that's that that's something
that you want
optimized or at least allow folks to do
streaming is is it is an interesting one
I don't really hear a lot of debates
about whether streaming is or isn't rest
because you could think of it as like
okay I can make a content type called
like you know convey Andy Twitter tweet
plus stream or something I don't know
you could do that I guess you know
content representation doesn't have to
be a document but most folks don't
really associate streaming api's with
rest and what do I mean by streaming API
in the case of of Twitter what would
happen is that you would get you would
make a single HTTP connection and then
you would be streamed tweets as they
occur and and with the popularity of
real-time API s this sort of stuff
becomes really important if you think of
it like this search is sort of history
because at the point where it's indexed
it's already past and maybe there's
things that were filtered out by the
time it was you by the time that the
search indexing happened and so you know
if you're looking at a system where
people are increasingly looking for you
know tighter and tighter feedback like
they want to see okay I want to watch
this happen now it might actually be a
combination of many AP is that you use
to achieve the goal and prevailing you
know wisdom now is is that especially
with things like like tweets and
everything else like that that's a
that's a specific domain where things
like streaming come in handy there's
other domains we're streaming or
important because for example the nature
of rest often enough is that your
polling for updates so if I want to know
like maybe I have a container and it has
all of my files in it the only way to
know that there's a new new file and it
is to actually keep issuing to get and
see that there oh there's a new file
link there and streaming as a way to
sort of like change that model so that
you're actually notified when those
things happen instead in fact the
interesting practice for for twitter is
that they use a combination of rest and
streaming to deal with reliability of
connections so streaming basically means
you're making one connection well what
does that imply
you're relying on that connection
because that's that's how you getting to
updates so what if you're you know going
through cell and that drops then you've
lost whatever that window was where you
were getting streamed updates so they
have practices of supporting both and
saying OK and unreliability or on your
mobile when your phones on mobile you
will do this and then when it switches
to Wi-Fi mode you would actually use
this dreaming ap is so there's some
operational controls and context for
certain types of AP is that sort of not
just suggest things like streaming but
also suggest both amazon is certainly
not rest and they don't even pretend it
is they actually call it a query api if
you if you ask them but many people
would say it's good i mean it's good
they've got adoption there they have
massive scale and if you talk to x
amazon engineers they have all sorts of
interesting stories to tell you about it
one of the stories i asked is like why
exactly was it made the way it was and
and apparently they had a optimized HTTP
server that's very very good splitting
query parameters and parsing those out
and so because the infrastructure was
was made for that it was very easy for
them to achieve scale of any given
service by following these patterns
instead and if we look back at the API
itself this one here like I said that
the all the content is is delimited
query parameters and they're not very
deeply nested either which which makes
it a very simple model to deal with
normally speaking your you almost
serialize a portion of the XML in in
query parameters when you're dealing
with with an amazon web services API we
go back to where as good well one of the
advantages there is that is very simple
to extend this API because you just tack
on a new key and that's how when if you
if you follow any of the Amazon Web
Services updates they have updates every
few months I'll across the board with
various api's and it's extremely simple
when it doesn't break very often
it also helps them in their scale design
for security because the way they deal
with security is that they actually
request a user to sign each HTTP
requests based on its headers so because
they know all of the state related to
that request is to realized and headers
they know that any authorization model
has everything it needs to know about if
it has all I'm sorry all the query
parameters then they know that any
authorization system won't we'll have
all the context it needs if it has all
the query parameters so basically it's
it splits it up into a map it sends that
asynchronously to the author the
authorization system that has a little
race this is what I've heard anyway and
that's that it will block until the
authorization system is ready presuming
it's going to be a successful request
and then they just throw away the
request if it at the authorization
failed so you can actually make some
pretty low latency api's if you do
design for things that that might not
seem intuitive when you first look at
them so you know and I'm wrapping up the
session here a little early because I
want to make sure that you guys have
time to give feedback because I totally
used up all the time last one but good
ap is and whether they are your rest or
not you know the main aspect is a
conscious design with your users in mind
right so understand that that's already
part of your agile process anyway
hopefully so just just you know rest is
no different rest is also a product it's
not just an input it's not just an
interface over some implementation it's
something that that's meaningful and
important and it serves audiences that
might be different than other audiences
so just use conscious design versioning
is not right or wrong it's a scope set
matter and how they're applied and that
a change that that applies to your
change model and so if your users cannot
you know embrace change on a daily basis
then maybe you shouldn't version on a
daily basis I mean they're just
conscious decisions to make
and there's certain things that i would
say that are just sort of like i didn't
talk about in depth but try not to leak
too many implementation details and you
in your arrest design this is something
that's that's happening more often as
people try to use different like no SQL
data sources like for example there's
some some aspects of design test them
against different potential backends
that you might have even if you for
example think okay I'm just going to use
my school forever whatever you know if
you do pagination based on something
that happens to work very well in SQL
and then you're using no SQL or using an
array of API is behind it than you know
some other time it might be very very
difficult to implement that so try and
throw more rocks at your designs from an
operational perspective because you want
your API to survive your business plan
right it should it should be able to
perform and stay alive with it the other
thing is use auth models that are
relevant to your your ideal consumers
this is I didn't I don't have a slide on
this but basically you'll see a lot of
popularity with OAuth especially oauth2
lately for example Google is pretty much
wholesale over there Twitter recently
changed it all I think 11 b or something
like that you can expect more and more
services to move towards oo auth I don't
want to do it Oh auth talk was suffice
to say keep an eye out for that because
you want to be aware of the various
types of interactions whether it's
whether it's a back-end whether it's a
trusted application whether they're
humans involved and and keep that in
mind an auth model isn't an API really I
mean their version differently like Oh
auth when I say the version 2 what does
that mean that's that's a version of
something that's not your API so don't
conflate the two but but keep that in
mind like because you know you should be
aware of the auth models because those
by themselves can also interfere with
your users and maybe not attract them
and then your ecosystem goal isn't isn't
well served but at the end of the day
developers and users like to have
documentation and examples and so even
if you use a hey Tiele style
you know great documentation especially
with with literal requests and responses
is very important with working with the
you know a few dozen api's that I've
worked with I can actually program an
API completely offline just based on
copying and pasting from the
documentation on a well-defined API and
well-documented API and that's very
handy because sometimes for example you
know your users are not going to have a
lot of patience with with with API is
where they have to actually discover the
way through so and again it's as sort of
the culture of the user so what now I'm
actually not going to pitch API craft
there's some folks that don't don't
particularly like it I like it you can
join it it's a decent google group and
they do answer folks and there's a
couple books here George Reese is a i'm
actually just noting this very short
ones because i know everyone has small
attention spans so the both of these
books are about 50 pages each George's
is longer but it's got like a bunch of
appendices so there's two books there's
a here that you can have a look at and
there's plenty actually a material
because remember this was 2000 so
there's actually many other books on
rest that you can you can look at these
are just quick ones that that focus on
design but but mostly socialize your
ideas one thing that I found very
interesting in doing the research is
just that there was not there was not a
single mailing list that was overwhelmed
with too many people asking questions
about how their design should be like
the maximum traffic might be one or
three messages per day what does that
tell me people are not socializing their
ideas enough because you know if you go
to a programming mailing list you're
like I can't get it clips to run or
whatever there's a lot of socializing
you know whatever their constraints are
design I'd love to see a lot more folks
like socializing what's working for them
what's not working for them in questions
they have because that that means that
you can I get a lot more feedback went
you know for everyone when when the next
person goes to create a presentation
like this they'll be able to get your
input as well so thanks for coming I've
got
10 minutes for Q&amp;amp;A so yep good yeah
hypermedia API is good yeah all right
thanks
three ghosts
good question so the question was about
search and and how does that play out so
it actually you can boil it down to
nouns versus verbs there's a lot of if
you just like search nouns versus verbs
rest there's some you know long email
threads about that but basically it's
much easier to model nouns than it is to
model verbs so the idea of search you
know and people have passionate opinions
about it but search could be a resource
if for example you're an elastic search
cluster and you could update that that
resource at least some pieces of the
resource because that's actually the the
thing that you're interacting with but
at the end of the day a lot of people
implement search as a cross-cutting
concern across all resources and when
you have like a global search across all
resources it basically means that the
representation is going to end up being
columns you know represented in some
form so you know that that's where I
kind of feel like it's more of like
search as as a query API system similar
to you know it's someone's
representation of sequel or their
representation of composite predicates
or whatever versus fitting strictly to a
rest model what I've noticed is a lot of
api's would will like string on their
filters on any resource it's just those
keys or those facets would actually be
specific so if i'm working with a you
know a server api then maybe I would
have filters on IP addresses which are
which are pre can't facets versus like
full-text search over everything
yeah and Fred and for me that's actually
why I kind of put a search and streaming
in a different bucket because I haven't
yet to yet see someone I'm sure someone
will come up with it but you know a
clever way to actually represent a
system except for providing a document
that has the search keys in it and then
it just gets really weird so I mean I'm
not I don't mean to be judgmental I just
I haven't seen anything that matches
exactly the same hypermedia controls
model plus search without cheating some
way you had a question
No
sure question was on deprecation and and
some people are very strict about it
like I know in Georgia reese's book he
says like you should never deprecated
anything at any time and and a lot of
folks will say that for example it's
easier to adapt an old model to a new
model than to deal with specific like
when you're when you're at the resource
level then actually take take this those
things out in practice these things are
hard and for example twitter says six
months 10 will be gone it looks like an
eol process on any other piece of
software tricks about this i think
there's a api format called a key i
think the bees and maybe they still do
it but these to advocate a deprecation
header like an ex deprecation header and
but but again this is the sort of thing
where the API as you're crawling through
you could you could present the new the
new the new versions and the client
itself could actually continue to ask
for the old version even though the the
media type doesn't match the other thing
is just to remember that the accept
header accepts multiple values so
practice you could suggest if you're
using accept headers is 22 or any any
type of content negotiation is to use
that which is fully supported to you
know specify a list of things to give a
transition period from from an API
that's versioned at its root then then
basically you need to have a way to to
you know eventually get rid of the old
old versions and I wouldn't say that
there's a there's a silver bullet for
that those are the aspects that I've
noticed either published deprecation
policies try and introduce a new header
that would inform them or simply not
publish the links any others
alright five minutes early go get your
lunch</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>