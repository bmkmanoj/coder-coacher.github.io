<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Developing Polyglot Persistence Applications | Coder Coacher - Coaching Coders</title><meta content="Developing Polyglot Persistence Applications - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Developing Polyglot Persistence Applications</b></h2><h5 class="post__date">2013-02-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/v5VIJpkxWL8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thanks for picking this session it's
great that see so many of you are here
to him to learn about cloud services
over the past few years you've probably
had an awful lot about the joys of cloud
computing about how with just a few
clicks of the mouse you can deploy your
application on a public cloud such as
Amazon's elastic compute cloud one over
one of these passes like Cloud Foundry
or hero cook well alternatively how easy
you can just have access to some app
just by using some software as a service
but another really interesting aspect to
cloud computing are these cloud services
so these are web services either restful
or soap based services for all kinds of
different things ranging from image
processing to telephony to geographic
information as a database so these are
services that you can build your app
using and they enable you to very
quickly develop an application in
essence you can master mash up these
different cloud services to quickly
build an application and it frees you
from having to implement in some cases
quite complex algorithms or you know
solve some data storage problems without
actually having to do all of the heavy
lifting yourself now these cloud
services are operated by third parties
they implement them they maintain them
they operate them and they let you just
focus on your core business problem so
over the next hour you're going to learn
about some cloud services why you should
use them what the risks are associated
with with relying on them and then I'm
going to have a show an example
application that let that leverage is a
couple of different cloud services
including twilio which is a very popular
telephony as a service and also fracture
which is a geographic information
database as a service so before I get
into that just a little bit about me so
chris richardson I grew up in England
and then moved to the Bay Area 22 years
ago so I live just across the bay in
Oakland I actually got my start and
software developer
writing Lisp systems list being one of
those early dynamic object oriented and
functional programming languages modern
features like garbage collection all
this good stuff that we're sort of
taking for taking advantage of these
days except that this was kind of a
while ago back in the late 80s when C
was one of the predominant languages
that eventually ended up programming
Lisp wrote the book pojos in action back
in nineteen ninety 2005 and that was all
about how to build applications with
spring and hibernate which back then
were pretty radical frameworks but once
again it's technology that we pretty
much take for granted today and then
about five years ago I started playing
around with this with what was then a
pretty obscure thing amazon ec2 you know
amazon back then bookstore and then they
had this little cloud computing thing
off to the side and I i just had to
discover it one day started playing
around with it and suddenly this sort of
whole cloud computing thing mushroomed
and i created an open source project
which turned into my startup cloud
foundry which was acquired by
springsource creators of the spring
framework shortly before spring sauce
was acquired by VMware it's a great
diagram from the register showing the
acquisition though yeah if you had if
you were my talk earlier you would have
heard that you might joke about how this
is not really to scale cloud foundry at
least in terms of market valuation was
more of a plankton than ER than an
actual fish otherwise I'd be on some I
on my own island somewhere right now and
then these days I'm a developer advocate
for cloud foundry where I travel around
and you know basically give talks like
this on clouds and architecture and
cloud computing and so on and so it will
encourage you to go give cloud foundry
ago and sign up with the promo code CF
java one and in fact as I mentioned in
the beginning if you go and deploy a nap
while you're here and go to our booth
you'll get one of these pre shaved yak
hoodies and somewhere like someone will
explain to you what the
joke is because I don't understand that
one okay so that's me and so in the talk
and you know begin with the motivation
for cloud services what are the benefits
what are the risks and I'm going to look
at an example application that leverages
a few different cloud services and so
what couple in the in the area of
location-based services and then a third
in the area of telephony I'm going to
finish up talking about some design
patent you can use in order to make your
applications robust and fault-tolerant
so I'm sure you've all heard of
hitchhikers guide to the galaxy you know
it most recent incarnation of that was a
movie but for me it was actually a radio
show back in the late 80s that I
listened to on my grandparents radio
that actually had like vacuum tubes and
it was kind of quite a while ago but one
of the really interesting things in
Hitchhiker's Guide to the galaxy is that
they say that every galactic
civilization goes through three phases
survival inquiry and sophistication and
those also known as that how phase the
why phase and the where face so the hell
phase is characterized by the question
how can we heat the why phase by the
question why do we eat and then the
where phase by the question where should
we have lunch so you know if you
actually ever spend time with you me you
actually you would know that like food
is a big obsession of mine and sort of
where to have lunch it's you know big
burning question of the day so I
actually to illustrate some of the cloud
service technology i created this app
called vote meet eat calm and it really
answers three critical questions like
walk restaurants the nearby which of my
friends are close by and we're your
friends prefer to eat and the way it
answers that question is by actually by
using combinations of geographic
database as a service and also telephony
as a service and a little bit later on
i'm going to try and demo the app so I'd
encourage you if you've got a smartphone
text register to that phone number 510
545 99 98 because of hoping you're going
to participate in this some lunch
experiment so as I mentioned the app
uses a number of different things it
uses a restaurant database it uses SMS
and it uses voice calls to actually
interact with people get their
restaurant preferences and so on just in
case the demo doesn't work I want to
actually show you some of the kind of
the key stories from the app so step one
is you text register to that phone
number and you get back your
registration URL so the apps into
communicating virum SMS and you get that
teach you then to a web page which gets
your location and you can put in your
nose your phone number obviously put in
your name and then it then you actually
vote by cooling in and there's
interactive touch-tone part of the
application and then finally the
application announces where we're going
to meet by texting out where everybody
who participated the location of the
restaurant and you know did I say you
should text register to 510 545 triple
98 so so that's the app so it's making
use of geo-information it's making use
of location-based services and yeah the
high level you can imagine an
architecture that looks like this right
so we got the app and needs a database
that keep track of where your friends
are it's a database of restaurant data
massive sort of real real world data and
then there's this big complicated piece
of telephony integration and some of
those pieces are really hard stuff
restaurant database that's really a data
problem telephony that that's kind of
big hairy complex problem and it's like
or do you really want to build all of
this yourself right because it's just
challenging you know would really
involve a lot of time and so on so the
alternative of course is to use the
cloud-based services to do this so these
are highly scalable services that are
offered by some third-party it might be
the platform as the service or the
infrastructure
as a service cloud that you're using
they many of those provides useful
services that you can consume in your
application being a classic example of
that is Amazon's s3 blob storage service
so how's this microphone going so you
know there you can store binary data
this microphone not working oh okay
how's that so is that better good good
right yeah so Amazon s3 classic example
of a service that's provided by an
infrastructure-as-a-service cloud let's
use you know store binary data handout
URLs and so on and then there's a large
number of these really interesting
third-party services they're just web
services that are operated by companies
who are trying to make money from that
come from offering them so in terms of
you know you look at Cloud Foundry the
paths that I'm associated with that
provides things like my sequel and
post-crisis and service rattus and
mongodb as a service and also rabbitmq
so those are all services that you can
consume in your application and then
when you look at third party services if
you go to website such as
ProgrammableWeb but see there's this
huge number of services that are
available then and there actually
increasing exponentially up to over
6,000 services in their database and
they're mostly rest they're offering
primarily a jate you know a lot of Jason
style interface many of them are many of
these services are processing like a
billion API calls a day it's like huge
hugely popular and I'm going to sort of
diverse range of areas so there's like
storm path that actually offers author
security is a service so you can offload
the authentication and the authorization
part of your application to storm path
alchemy does semantic analysis of
documents you can upload a document and
you get back a semantic analysis of it X
commerce that's paypal's that payment
API sendgrid that's email
service and then that of course is
twilio the little red icon in the middle
that telephony is a service and then
you've also got factual as a service as
well that's a geographic information
service as a database so it's all them
in advance with diverse range of
different you know different areas and
you can just consume these in your
application and there's tremendous
benefit to doing that you know obviously
it's someone else's headache to develop
and operate the service you let you
focus on your core business problem you
don't have to worry about building this
highly scalable service yourself and it
enables you to get up and running very
very quickly plus you've got this
elasticity if you know you need to scale
up that these services scale on your
behalf you don't have to worry about
operating this highly scalable
infrastructure and from a financial
point of view it replaces an upfront
cost which could be large to justice or
ongoing kind of paper use model so that
actually is good from a financial point
of view particularly if you're a
cash-starved own startup this mic is
still not right how's that not good
what about that is that okay yeah it's
bad i don't know what's up with it whoa
i didn't think i was tapping it that is
the strange thing I mean it's not like
I'm going this okay I'm just going to
stand like this for the rest of the tour
all right so okay so there's a bunch of
benefits to using cloud services but
there are some drawbacks as well so
number one you've actually now gone from
a monolithic application to a
distributed system with you got services
over here that you're consuming into
your application so there's a lot more
complexity around that then of course
you're dependent on this service
provider to Keogh to be up and running
and there's always at least an emotional
fear that being dependent on a third
party and then there's a really
interesting risk where that seems to
happen with some services where they
become moderately successful but not
hugely successful and they end up
getting a quiet so for example I hope
for while I was experimenting with face
calm which was this really interesting
facial analysis facial detection and
recognition as a service offering and
then they get acquired by Facebook
because yeah it was useful for I've
recognizing people in photos and then
likewise simplegeo that was this
fascinating geo database as a service
got acquired by urban airship and in
both cases their external services were
actually shut down so you know so
there's sort of this risk of actually
relying on some third party but you know
for the most part of if a company is
incredibly successful then they're not
likely to go get acquired by silly sell
out quickly to someone who's going to
shut them down and bring their service
in house so with that in mind you know
we now go back and look the vote meaty
application it's got an architecture
looks like this where we're using twilio
for the telephony
component actually using MongoDB which
is a no sequel document database as the
read/write friends database and then
using factual calm as the source of the
restaurant data so we've offered it a
tremendous amount of the infrastructure
to some third parties and we're no
longer having to do the heavy lifting
there ourselves i'm also using RabbitMQ
internally the tie all of the different
application components together so just
out of interest he was actually who did
who did the sm sent an sm registration
SMS n and it how many people all right
did anyone get a response back and they
registered oh thank god that bit worked
I've only ever actually tested this with
just myself and my wife never done any
sort of at scale testing so now we've
now we've got at least 50 15 people so
I'm going to try and actually kick
something off here which hopefully so
hopefully a little bit you will get a
text message out prompting you to phone
in but in the meantime out I'll keep
talking because if this does take a like
a minute or two okay so that that's sort
of the kind of motivation and a
high-level example of why you'd use
cloud services so I wanted to kind of
dive into a couple of different areas so
the first was looking at location-based
services because you know all of us what
many of us anyway we have like these
smartphones and a big part of using of
using a smartphone of the location-based
services so for example you've got
google maps that give you directions
there's Yelp that will find restaurants
nearby an open table that will let you
make reservations and I think it's one
of the big values of having a smartphone
is the fact that it's with you and it
knows where you are and then lets you
sort of do things that a location-based
you know that's sort of good evidence of
that really was the whole fuss over half
we'll sort of screw up with that with
that mapping application right which I
think I'll of this sort of fake Mars
rover thing well you know they said they
got a upgraded and they think they're in
Norway now but you know that the maps
and having high-quality data are
absolutely essential for an order for
location-based services to work and from
a development point of view the client
site is quite straightforward in the
sense that smartphones have native api's
for getting hope that the application
can use to find the location of the
smartphone and then also javascript has
a location API as well so you can write
html5 apps that go and grab the location
so think of you once you went through
the registration process you saw the
phone actually got your location that's
using the w3c geolocation API so the
client side is fairly straightforward
but the server side is actually quite
complicated in the sense that you know
you need a scalable geospatial database
that let in some cases lets you read and
write Geographic data has to implement
geosearch like find find objects that
are nearby there's also yes some
feedback there there's also datum data
you know as Apple's experiencing there's
a real data management issue you've got
to have quality data in order for this
to work databases of places with object
with you know businesses in the right
location the maps have to be accurate
you want to have Street information then
you've got to implement algorithms like
forward and reverse geocoding mapping
between latitude and longitude and
street addresses so it's all actually
quite complicated you know it's not the
most part it's not something we want to
build ourselves and our in our
applications the neat thing is that its
various geo-information as a service
offerings out there so Google for
example have a whole bunch of api's
y'all have AP is that let you access
that database of businesses and then
there's other ones like geonames that's
geodatabase then 1 i've been
experimenting with is factual that's a
bit faces the the places database that
you can query and has also got a reverse
geocoding capability so if you look at
what goes what the vote meet eat
application needs to do in a in the
location-based for location information
number one it needs a friend's database
that it can add records to so keyed by
your phone number and then you need to
be able to do a query to find friends
who are near a particular point so the
examples that I'm using here a scholar
but you know it's sort of not too
dissimilar from Java and then there's
also a restaurant database that's a pure
read-only API where it's just give me
databases that are near a particular
location so give me restaurants that are
near a particular location so if you
look at how we're going to implement the
friends database originally I'd actually
that's so that's read write and
originally I'd used the service then got
acquired so I sort of the simple GF
service so I ended up having to modify
the application to use MongoDB because
MongoDB it's a document-oriented
database and it's fast and it's scalable
but it also has this nice query language
that supports location based queries so
just sort of out of the box you can have
objects that have you can have documents
that have a location attribute and then
you can execute queries that find
documents with near a particular point
and the other neat thing about it is
that it's provided by Kyle foundry so I
don't actually have to set up the
database myself I can just provision it
using cloud foundry and cloud foundries
responsible for keeping it up and
running so as truly as a third-party
service so then if we look at you know
how do you store friend information in
the database so here's an example of a
document so it's got an ID attribute
that's the phone number it has a name
attribute and then it has a location
attribute that's the XY coordinates so
it's pretty you know it looks like Jason
and it
for all intents and purposes mongo
documents really looked behave as if
they're JSON documents and then a
collection of these documents form or
set of these documents forms a
collection that's like a database table
they reside in a database that runs on
the mongo DB server so that that's the
data model then if you look at the code
that accesses the database that's
actually built using spring data for
mongodb so spring data is this umbrella
project to spring source of projects
that make it easier to write data
applications so that there's a spring
data for JPA and then their spring data
for various no sequel databases
including Mongo one of the things that
Mongo spring data for Mongo provides is
a mongo template that somewhat like the
spring jdbctemplate so it hides all of
the boilerplate code that you need that
you'd otherwise have to write and then
it also takes care of the mapping
between your domain objects and Mongo
documents if you had to write that
yourself it would be a little bit
tedious so here's some code that's
written using Mongo template so the
first thing it actually does the post
construc instruct annotation that it
just makes sure that there's a
geospatial index created on the friend
record collection you have to create a
geospatial index in order to execute do
queries so we just ensure that that
index exists and then here's the code
that actually inserts friend inserts or
updates friends entries in the database
so it creates a friend record oops and
then just saves it cools Mongo template
save and save it away you can see the
friend records just the idea the name
and the locations that maps quite
naturally to the document and then
here's the code that does the query so
it actually creates a query object and
then calls Mongo template geo near to
execute the query and says give me
convert all of the documents that you
find back to a friend record and then it
just sort of massage as the results and
returns that so it's pretty
straightforward and then so the codes
quite simple and then when in terms of
actually deploying the application
remote with Cloud Foundry that's quite
straightforward Cloud Foundry just lets
you easily create a service it's an
instance of a Mongo database so we're
doing that and then when you deploy your
application you can just say my
application needs a Mongo database and
cloud foundry just takes care of what
what's known as binding that applicate
that service to your application so
that's quite straightforward and then in
your application you have to do a little
bit of spring configuration in order to
consume that service so over here we're
saying wheezing a spring 3 profile which
says well you're running outside of
Cloud Foundry access this Mongo database
but when you're running inside Cloud
Foundry access the database using the
cloud namespace MongoDB and so if using
the profiles mechanism to Rivet to write
an app that runs both inside cloud
foundry and outside of cloud foundry
once you do that pretty straightforward
so that's the sort of friend database
side of things then the restaurant
database is a little it's a little
different here we're actually consuming
a third-party service and so we're using
factual so that's geographic database as
a service that just happens to provide
808 a data a restaurant database that's
got about eight hundred thousand entries
in it and you just sort of have it has a
pay-per-use model and so the actual API
is rest with Jason and it uses OAuth
authentication and basically it lets you
execute queries against this database
like find restaurants near this point
and then do text based filtering on them
for example with with pagination well
then there's libraries for various
languages so of course I'm going to use
the Java library here so here's the
implementation of the service and so the
first thing it does with the
initialization method
so the actual API that factual provides
is not thread-safe so i'm using creating
it using a threadlocal so each thread
has its own copy of this factual object
and then the find method basically just
does a query to find who creates a
circle with you know the centered on the
location that we're searching around and
it just says find me five restaurants
that are within one kilometer of this
point so it's pretty straightforward and
you know we execute the query so that
under the covers is making an HTTP
request to the factual server and then
I'm just massaging the data that I get
back and turning it into a list of
restaurants so quite quite
straightforward stuff but you know there
you know we're actually leveraging this
service that's providing us with
presumably high-quality data we're not
responsible for actually keeping it up
you know keeping the data accurate
they're doing that and also that service
is presumably highly scalable as well so
we don't and in theory when our
application needs to scale so will that
service as well so that's quite nice you
know if we were to implement this
ourselves you know theory we could go
use postgres with geo extensions but
then we'd have to figure out you know
what get a source of accurate data and
constantly re-imported keep it up to
date which would be a total headache so
that's the real problem so with this
it's quite straightforward okay so
that's the location-based side of things
now I want to switch gears and talk
about telephony you know it's funny for
two logics then I sort of live in a
world where I just send email and I use
Twitter and so on but apparently out in
the real world people are using phones
and SMS a huge amount so there was a
survey that was saying the average u.s.
teenager was sending seven or sending or
receiving seven text messages for every
waking hour of the day which you know
it's to me sounds like a huge ADHD
problem and it actually
not actually sure how they're managing
to get anything done yeah yeah the
numbers are just just quite a known as i
was at 3,400 and that was a year ago so
yeah just astounding numbers and you
know of what people use their mobile
phones a lot as well though the actual
number of voice minutes apparently is
declining so you know we live in a world
where telephony and a semester hugely
important you know at one time I was in
London came across this so it's like a
way of reporting problems with with them
traffic lights he just text to code the
traffic light ID and a problem code to
to a SMS number and that's their way of
getting information about traffic lights
kind of a cool little app and of course
you know this has been in the news a bit
about Google's two-factor authentication
right where they will text you a code
that you then use in addition to your
password once again they're you know
they're making use of telephony so
there's an awful lot of really
interesting uses of telephony and in the
vote meeting vote meet eat com app
there's various different things that it
does so it's using it has to process
registration smss which i think is some
of you saw it sends out SMS is to notify
people to vote and then when people vote
is actually handling the voice call from
users doing a text to speech of all the
restaurant options press one for this
restaurant press two for that restaurant
and then it's collecting the digits that
you enter via the keypad so that the
touch-tone thing as well so and then
also the end it will send out an SMS of
the voting results so hopefully that did
work for some of you did did it work for
you did you actually able to dial in oh
yeah she'd do it right now it's okay
it's not rude
in this case so a lot of different uses
of SMS and also voice so in theory once
again you could build this yourself I
once worked on a project you know this
actually saw sparked my interest robe
client had purchased this incredibly
expensive of via box for like quarter of
a million dollars though that was
plugged into the telephone network that
let it do all of this kind kind of stuff
and so you know theory you can do it
yourself but it's kind of complicated
and it's expensive that's why it's a
good idea to use some telephony as a
service offering instead there's a few
examples of that you've got twilio as
one which is sort of my favorite but
there's another one called troppo and
then I I was in India about three weeks
ago and someone was using I think it was
text to webbs that was a SMS to http
gateway so the thing is a few up few of
them out there so if you look at twilio
so that gives you a REST API for
allocating and maintaining phone numbers
it's a REST API for making and receiving
phone calls and then sending and
receiving SMS messages as paper you so
you're just paying a month a monthly fee
for each phone number that you allocate
and then you're just paying for each SMS
that you're sending or receiving and
you're also paying for each minute of
voice calls there's a whole bunch of
different examples of people have used
that for doing quite interesting things
so if you look at how twilio interacts
with your application so it's doing all
the complicated part of communicating
with the phone and then it's just
doesn't but enough does a number of
things someone it is exposing that rest
api to your application so that's one
way you could you make HTTP requests to
it but then the other thing that's
really interesting is that say one of
SMS message arrives it actually doesn't
HT makes an HTTP request the to the SMS
number that you to the SMS your
ral that you've registered with along
with that phone number so it actually
does an HTTP gap or an HTTP post back
into your application and then likewise
if a phone if there's an incoming phone
call it does an HTTP get or post back
into your application so it's sort of
acting as a mediator between the phone
and your application and you're just
speaking HTTP to twilio so let's look at
an example so you know step one in the
app was handling the registration SMS
messages so you text register to the
twilio photo to this number that's
hosted by twilio so what's actually
happening is the hit I've set it up to
do a post to a URL in my application one
of the URL parameters is the phone
number that the SMS is coming from along
along with the body of the SMS and then
what my app does is actually respond
with what's known as a twee ml document
so it's an XML document that tells
twilio how to respond to that SMS and so
here I'm just telling twilio just reply
with the text to say you know to
complete registration go to this URL and
that's it that's all it takes to
actually handle SMS in your application
and the actual little app that's sitting
behind this is is this one here I know
this is a java conference but this is
actually some it's actually true because
this is a sinatra application so Sinatra
is a ruby dsl for building web
applications so this is the incredibly
simple little app that just says
whenever there's a post to this URL
respond with this document which is here
it's just a string and it just responds
back and the reason I pick Sinatra's
that it was really simple and you know
in many java web applications you need
more XML just to configure it than you
would actually to handle the response
but anyway you get the idea so then you
know then too
of inviting users to vote that's a
matter of sending out SMS messages and
that to do that you're just making a
restful cool to the twilio API that
looks something like this so you you are
the URL is you know the version accounts
then the account ID / SMS / messages you
do a post to that with the from phone
number the two phone number and then the
body body parameter that's the actual
message of the SMS and then you've got
to have basically based basic
authentication on there as well and then
you know looking at the code the Scala
code to do that so a little send em SMS
message that just calls post to twilio
with the URL fragment and then a map of
the request parameters and then it's and
that actually gives you back an XML
document that it pulls out the s ID
that's sort of the idea of the object
representing that SMS message and then
here's just a little bit of code that's
using a spring rest template to do the
post and it's got some error handling in
that but we don't need to go into the
details of that okay so that sort of
some of the basic SMS handling and now
let's have a look at the voice side of
things which is a little bit more
interesting so when you when someone
phones in to vote so they're making a
phone call to a twilio number that's
actually doing a post to the URL voice
URL that I registered with the
application so it's literally saying
you've got a phone call from this number
and that that's coming into my
application which then responds with
another XML document that tells twilio
how to respond so this one's a little
bit more complicated so the first thing
it says is this the save verb says so
that's doing text to speech and it just
says it actually just takes that text
and converts it into speech so you're
here Chris would like to meet need and
then the gather element is like a form
so you can think of it as it's kind of
like an HTML
warm except that it's gathering digits
yeah well when I when I when the user
touches keys on the phone and at the
same time the say elements nested within
the body of the gatherer getting read as
well so it's going to say press 1 for
this press 2 for that and then when you
press one the gather verb is going to do
an HTTP POST of that digit back to the
URL that I specified so the action
attribute is specifying that so that's
sort of that's kind of its way of one of
the ways of gathering data from users
and so you're going to see a post back
to your application with the digit that
the user pressed so you're going to know
from this phone number the user press
this digit and then you have to respond
with another XML document in which in
this case it just says thank you for
choosing and the most popular place so
far is blah blah blah and then you'll
hear from us shortly so it's letting us
do all this sort of text to speech and
interaction with the touch-tone keypad
and so on but it's all just done through
this nice HTML and xml interface and
here's some of the code that's
implementing that so it's actually a
spring MVC controller and this is once
again it's written using scarless so you
can see I'm just basically cooling into
the survey management service saying
this final surveyed that's corresponding
to the phone number that's cooled in and
if there was no survey found then just
say sorry we don't recognize your number
otherwise if a survey was found and
generate the xml response that i showed
on the previous slide so that's a little
bit of cryptic Scala code there so the
control is just returning an XML
document that then gets translated by I
configured spring MVC to turn that back
into an HTTP response and then here's
the code that's handling the post of the
users choice once again it's just
calling into the survey management
service to record the vote
and then generating an XML response
document so it's quite if it was jiving
you can imagine the Java code except
that would be a little more complicated
because you can't generate xml quite as
easily and as in java anyway so
hopefully that that's given you a flavor
of how you can do telephony so it sort
of seen some examples here right we've
seen factual that's the geo database as
a service so you know Mongo that's the
platform service and we've just used
that as the read/write geo database and
then twilio for doing telephony but out
there there's sort of this humongous
number of different web services that
you can use in your application so it's
pretty exciting so in the sort of final
part of the talk I just kind of wanted
to talk briefly about some strategies
for building sort of robust applications
that consume services so one of the
problems you have is what is the need
for parallel ism so for example you know
request comes in and you need to call
services a and B to get some data from
them and then you need to call service d
to get some passing the results from B
and C to it to finish off the processing
of the request so in theory you could
call be wait for it to return cool see
wait for it to return and then cool d
the trouble is with doing things
sequentially is that it just increases
the overall response time you really
need wherever possible to execute
service calls in parallel so we want to
call B and C in parallel and then cool d
trouble as many of the low-level
concurrency a pee is or a bit sort of
primitive error-prone kind of messy to
use but there's one that's really useful
and that's the concept of a future so
that's part of the Java concurrency
provides that so a future is an object
that represents the result of a
concurrent operation in other words you
can you know using a thread pool you can
create some concurrent operation
and then you get back a future that will
ultimately contain the result of that
concurrent operation so otherwise we
basically in order to execute some
remote service we go through a thread
pool the threads execute the thread and
thread pools executing concurrently and
our main thread has a future and from
which it can then get the result of that
service call so Java futures are not bad
and you know it's a step forward but if
you go look at the accra framework it's
actually got a much better
implementation of futures mainly because
the future API the future class is
actually much richer epi and there are
methods defined on that class that let
you can compose futures together in
really interesting ways so you can call
a bunch of things concurrently and then
create a future that contains the
results of taking all of those other
futures and combining those values in
some way so yeah hit here's an example
of that so I got my friends service
that's set up to return a future and the
restaurant server is set up to return
another future and then i can write code
like that shown in the bottom where i'm
using a key using scholars for
comprehension to actually call a bunch
of services concurrently and kind of
combine the results and that will
actually give me back a third future so
you can sort of mmm sort of glossing
over the details here but I'd encourage
you to go off and look at the arc of
framework and its future implementation
because it's actually quite powerful and
it's a really nice way of writing
concurrent code so that's one of the
themes that you kind of have to deal
with this concurrency and I think
futures are a good way of doing that and
then the other thing that's sort of
challenging is well I sort of mentioned
this in the beginning we now have a
distributed system now we've got lots of
remote services both you know twilio zuv
remote service factual remote service
and then actually the way I've
implemented the app is also internally
it's a collection of services that are
tied together through a message broker
so for example the registration service
when
fill in that form actually posted a
message via RabbitMQ to the user
management service so it's all this nice
loosely coupled system which means that
where we which now means that there's a
lot of complexity now and it also means
that when service a call service be and
service be could be one of our internal
services or it could be some remote
service all kinds of interesting errors
could occur right because it's remote so
the remote service could be down or it
could be slow or the network could be
down or it could be slow and so when we
build our application we have to be
somewhat mindful of the errors that can
occur because it's now a distributed
system so great example of a company
that spent a lot of time thinking about
this is Netflix so I think most of you
know Netflix is this video streaming
where they started off as a DVD rental
but now they're big thing is video
streaming apparently on some nights of
the week and take up thirty percent of
the internet traffic in the US and
actually they're very cool company I
think it's a good use of bandwidth
Ashley but you know they they're
absolutely there architectures
absolutely fascinating they actually
process over the streaming side of
things process is over over a billion
API calls a day so out there they're all
these devices that are Netflix the
netflix enabled whether it could be your
iPad or your Apple TV box or your iPhone
or your Playstation or whatever so the
streaming is all managed through this
API and then the H API call comes in and
actually found out on on average to
about six different back-end services so
you think in total is a billion API
calls day which is translating into six
billion service calls a day so the scale
of their systems phenomenal you just
imagine that has to operate reliably
right they're sort of interesting things
that can happen so if you're
for instance you know tomcat requests it
coming in you have only so many execute
threats right so if you're cooling some
back-end service which is down if you if
you don't do things carefully you know
you're basically all of your execute
threads are going to be blocked waiting
for this back-end service to respond and
it's not going to because it's down for
a reasonable length you know if it's
down for any reasonable length of time
you're very very quickly going to run
out of execute threads within your
tomcat server and your whole entire site
war within a few seconds just come
grinding to a halt so you actually have
to you know expend a lot of time coming
up with strategies to prevent that from
happening any sort of access latency in
the system will just could just cause
their site to come to a grinding halt so
on that blog so tech blog Netflix com
got a fascinating series of blog posts
about the architecture that they're
using it's a sort of number of different
patterns that they use so one of them is
simply to use timeouts and retries so in
other words when service a equals
service be did it a should never wait
forever because that could cause an
execute thread to be blocked
indefinitely so instead it should just
have a timeout you know figure out how
you know what what whatever the right
number of milliseconds is to wait for be
to respond and if it doesn't just give
up but then rather than just into giving
up entirely what it can what you should
do is actually retry because many of
these errors that occur is somewhat
transient so retrying often means that
you will succeed so that's one basic
strategy and then the other thing that
they do is for each de pet for whenever
service a invokes service be it doesn't
do it directly it actually it does it
fire a thread pool that's bounded in
size and the value of that is because
the thread pool has a maximum size if
that
limits the number of outstanding
requests that a can make to be so
otherwise it just if a is not going to
perform any kind of denial of service
attack accidentally on be that was just
going to have a it's going to be so many
outstanding simultaneous requests so
that's sort of a way of kind of
implementing kind it's kind of like a
flow control throttling mechanism and
then the other thing that it has is the
thread pool has a bounded queue so you
can imagine if B is down the thread pool
will fill up and then the queue will
start filling up and so in theory that
cue could start growing in an unbounded
fashion which that in essence means that
the execute threads are going to be
blocked indefinitely so by actually
imposing a maximum size on that bounded
queue on the queue it means that you're
going to start failing fast after the Q
gets to a particular size so you very
quickly detect the fact that something
is not quite not right and then you can
sort of recover in the appropriate way
so that's the second thing they do and
then the third thing that the third
mechanism they use is the circuit
breaker pattern so that was a book must
deploy it will ship it from nygard a few
years ago so the idea here is is that if
you detect a high rate of arrows when a
is cooling be you know for example 10 10
calls from A to B fail in a row you
actually the circuit breaker will then
trip and so then temporarily a will stop
calling service B which has throw a
number of benefits so if B is down by a
there's no point in cooling it so you
just give it a chance to come back up
instead of having to keep calling it and
timing out which causes execute threads
to be blocked so you just fail fast
right and then if B is slow by
temporarily not cooling it that means
that it just gives be a chance to kick
sort of recover and catch up with its
workload
so it's just a way of building a system
that's a lot more robust so that's the
third strategy and then the other issue
is well if there really is a failure
what do you do so if a calls B&amp;amp;B doesn't
respond watch what should you do so one
option is just to return cash data maybe
data that's two minutes old is okay in
your particular application you don't
need the latest and greatest version of
the data another scenario is actually to
just return default data which in some
cases could be no so for example imagine
a is responsible for gathering the data
for the product page and B is the
recommendation engine and it's down so
rather than just displaying an error
page you just display a product page
with no recommendations right yes that's
yeah that's pretty good and so in that
case the sort of the default data is not
perhaps in other scenarios you've got a
more elaborate kind of default data and
then the third thing is worth B is down
then maybe a should just fail fast and
just throw up its hands say hey I don't
know what to do and that could say that
so they you end up effectively giving up
and going all the way back to the
original client which could then decide
how to recover maybe it would make
another request which would get
load-balanced to a different server
which is perhaps working better than the
original one so some very interesting
strategies and it really sort of two
categories of either you avoid failing
or if you are going to fail fail fast
and it's sort of like the worst thing
you should do is block for a long time
and take up execute threads because if
you've got a high volume of requests
you're very quickly going to run out of
execute threads and have a dead
unresponsive website so you know the
other thing you wanted to just finish
with I've actually been experimenting
with kind of using a aspect drawing a
programming in conjunction with
choose to implement a circuit breaker
mechanism so the idea is that when the
cooler tries to invoke us a stub that's
going to invoke some remote service the
actual core gets intercepted by an
aspect that then delegates the fords the
request off to the circuit breaker
that's keeping track of successes and
failures and deciding whether to be open
or closed and then then it actually deaf
delegates that request to a worker pool
of worker actors that basically wrap it
through a thread pool and then actually
call the dependency stop so you end up
with a sort of nice declarative thing
where you can just put an annotation on
a service saying this service should be
invoked via the circuit breaker
mechanism and this is the amount of time
out time out I should you should allow
well this is the amount of time you
should give it to succeed and then that
gets in that gets ends up executing this
aspect which then right at the bottom
you can see that it's invoking an actor
saying please go off and execute this
concurrence concurrently which gives you
back a future so I'm hoping to put this
code up there on this website in a
little bit of time I'm still trying to
clean it up anyway so that that's my
talk and I hope you found it sort of
interesting so kind of in summary it's
like cloud services these kind of great
highly scalable services that are
operated by some third-party and by
using them it lets you focus on your
core business problem you don't have to
do implement complex algorithms you
don't have to be responsible for
ensuring that you've got some more you
know the quality of your geographic
information database but you know there
there's the rest the the provider that
you're using is kind of successful and
they end up getting acquired by Facebook
because that's sort of that kind of
sucks
but you know it's kind of these
companies in the middle like I think you
know twilio that they're having a very
very successful business so they can
remain independent but where's the ones
that are not quite as successful they
look for an early exit through some
acquisition but you know the only other
the other hand you end up we're now
building a distributed systems that
requires careful design to deal with
dependencies and timeouts and all that
kind of thing so you need patterns like
the circuit breaker and and so on so
that's my talk you shoot you will find a
copy of these slides up on SlideShare
shortly and you see my twitter handle as
well and if you've got any questions
please don't hesitate to send me an
email so yeah thanks for listening I
hope the next week when you recover from
the conference you'll go back to your
office and start experimenting with
cloud services so thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>