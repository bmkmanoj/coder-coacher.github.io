<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Making RESTful Web Services the Easy Way with Node.js | Coder Coacher - Coaching Coders</title><meta content="Making RESTful Web Services the Easy Way with Node.js - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Making RESTful Web Services the Easy Way with Node.js</b></h2><h5 class="post__date">2017-07-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/qZoOl43Ou8g" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi welcome to making restful web
services the easy way with nodejs I
don't intend to show you anything you
can't do already today but just in case
I slip please don't make any purchasing
decisions based on we see in this
presentation my name is Dan McGann I'm
an Oracle developer advocate I focused
primarily on the JavaScript and html5
communities my contact info is on the
screen please feel free to reach out to
me if you have any questions about this
presentation or really bad to me
JavaScript and all related questions in
general I'd love to hear from you
here's an overview of what we'll be
taking a look at today we'll start with
a rough intro to building api's and then
we'll take a look at how you can
manually create the api's image as well
then see how you can do that easier ways
with sales jazz and with orgs or quest
data services imagine you show up to
work tomorrow and your boss says hey can
you create us a new REST API on the HR
data using that cool new tool that
everyone's talking about no js' sure you
say and then you run off and try and
figure out what your boss talking about
res stands for representational state
transfer and it's really just the
architectural style of the web now being
applied to API development and Roy
Fielding's doctoral dissertation he
defines six constraints to which REST
API s or really rest architectures
should conform but the truth is that
most implementations do not comply 100%
in rest api's clients must communicate
their intent and they do this via two
different means URL pads and HTTP
methods the URL pads should be based on
nouns and non verbs here you see two
examples one for a collection or an
array of data and one for a single
resource so with the array we just have
an endpoint that ends with API slash
employees and this would give us all the
employees and the next we see employee
slash 101 so this would be the ID of one
particular employee in the past using
maybe RPC style API
this would say get all employees and
that get is a verb this is something you
do not want to do with restful api s
instead the verb is part of the HTTP
protocol so we use HTTP methods like get
put post delete and they correspond to
various crud operations and thus various
database operations as you see here once
you have a better understanding of rest
you may decide to tackle nodejs nodejs
is a server-side runtime for JavaScript
this can be very powerful if you're used
to working with JavaScript in the front
end because your knowledge can then be
applied in the middle tier nodejs is
built on Google Chrome's v8 JavaScript
engine this is known to be one of the
best JavaScript engines out there it's
highly performant known to be
lightweight and efficient it uses an
event-driven non-blocking i/o model and
it also comes with npm or the node
package manager which is now the world's
largest repo of open source libraries
here's an overview of the architecture
that nodejs uses basically all of the
javascript code that you write will run
in a single thread known as the main
thread and eventually you'll make some
call out to what are known as a seen
api's and these can go one or two ways
they're either completely evented things
like timers and network communication
TCP and HTTP or they might end up going
to a thread pool by default node.js runs
a thread pool with four threads in the
pool and these threads are used for
things like file i/o DNS as well as user
codes such as database queries there is
a queue in front of this thread pool and
either case when the work is finished
the callback function that was supplied
when you made the async call will then
be added to the event or callback queue
and eventually your callback will make
it through and get back on the main
thread for execution once you have a
handle on both rest and nodejs
you'll need to make a determination
as to how you want to write your API and
you'll need to choose between convention
or configuration on the configuration
side you'll end up writing more code but
you'll have more flexibility and you
won't end up with anything that you're
not actually using on the other end of
the scale you can choose convention here
you'll end up writing less code but you
will have a little less flexibility and
the idea is that if you're okay with
what you get by convention then that's
probably the better path and if you find
yourself constantly fighting against
Igraine then you might choose the
configuration path in either case you'll
need to decide exactly which features
you need to support there will be some
basic features like pidgin Asian sorting
and filtering of course we'll need
authentication and authorization in some
cases but then you get into things like
caching documentation real-time push
throttling and so on and so forth and
don't get overwhelmed with all of these
features you don't need to support them
on day one usually these are things you
can add over time if you choose the
configuration route the coding route
you'll definitely want to add these over
time if you go with the convention route
using a tool like sails loopback or
words you'll get a lot of these sort of
out-of-the-box from day one all right so
what are the basic ingredients of a
restful api well of course you'll have
your three tiers the client tier at the
mid tier using nodejs and the database I
personally like Oracle database there
but in that mid tier you're going to
have a web server and the web server of
course just a basic web server it's
going to be responsible for accepting
HTTP requests and then sending the HTTP
responses back out you're going to need
some kind of routing logic and the
routing logic is going to identify that
intent that we talked about before it's
going to look at the URL path as well as
the HTTP verb and then route that
request to the appropriate controller
logic the controller logic is going to
look at the data on the request maybe
apply some business logic and then
generate a response and part of that
business logic is going to be
interacting with the database
which means you have some database logic
and there may be some additional
business logic there and of course it's
going to update the persisted state now
exactly how you go about doing all of
this is completely up to you let's take
a look at manual API creation using
nodejs
the first thing you'll need to decide is
which web server you want to use Express
is always a good choice
it's a highly popular general-purpose
web server it's not as low level as the
built-in HTTP module that comes with
node but it does not offer a lot of the
convention you'll see with some of the
other options here Resta Phi is a good
option if you just want to build a REST
API it doesn't have some of the options
you'll see with Express which don't make
sense grapey is but it does add some
things that may help like DTrace support
if your operating system supports that
and even throttling it was cracking from
the folks at PayPal which is basically a
layer over Express but it adds some
structure and convention and then going
even further is happy from the folks at
Walmart and this includes all kinds of
modules for validation cores sessions
and caching and so on they're all really
great options in the example that I will
show you here in a moment but I chose to
use I went with Express you also need to
determine how you want to interact with
your database you can choose between
drivers or ORM s if you're really
comfortable with the database or
databases you'll be interacting with you
may choose to use the drivers they're
going to be lower level but they're
extremely flexible and they sort of plug
you into that database functionality you
may already know and appreciate if
you're not as comfortable working with
databases or you're working with a lot
of different databases you may choose to
go the ORM route that's just more
convention ORM s attempt to abstract
away the database which can be very
convenient especially if you're working
with a lot of different databases
surprised
I chose to use the database driver for
nodejs this is node Oracle DB as you can
see it's made of a number of classes the
base class being Oracle VB this class is
primarily used to do one of two things
or either going to create a connection
to the database directly this is known
as a dedicated or one-off connection
these connections are fine if you're
running scripts periodically but if
you're creating an API where you'll have
a lot of requests for connections coming
in and you first want to create a
connection pool and then obtain your
connections from that pool in either
case you'll eventually get a connection
and the connection object is what you'll
use to execute your sequel and PL sequel
statements and depending on the
statement you're executing you may end
up getting one of these other classes
either a result set or a lob the results
that provides a read consistent view of
data this is for working with a lot of
data and then we have the lab object
which is used for working with B lobs
and C logs and just streaming those into
and out of the database when you choose
to create an API manually you'll of
course need some kind of directory
structure to put your files in and
because there's no set directory
structure this can lead to analysis
paralysis so I'm proposing this very
generic directory structure here and
things start with this package dot JSON
which is something of a manifest file
it'll contain a name and description for
your project as well as a list of the
dependencies both for development and
production there may also be some
scripts in there for things like
building and for testing the index dot
is is like the main application file
it's the file that will start the
application the idea is to keep this
file somewhat lean and you'll do that by
moving logic to other modules as needed
I have a very generic so
directory and the ideas will just put
code here that can be reused by other
modules in the application we have a
controller's directory and of course
this will just contain the controller
logic for the controllers that were
using as per our routes I have a
database api's directory and the reason
I have a database API as opposed to a
model models directory is because I'm
not using an ORM so I just rename this a
little bit and we also have a
configuration directory and because
we're taking this manual approach this
vector will be somewhat light but it's
still a good idea to have a
configuration directory and to push as
much configuration into this as possible
the only director have not accounted for
is that node modules directory and the
reason for that is this is owned by NPM
the node package manager and that's
where it stores all of your applications
dependencies all right this is Oracle
code so let's get to some code it
wouldn't be practical to watch me write
a manual API from scratch right now we
wouldn't be able to do in the time
allotted so instead I'm going to give
you a code walkthrough of an application
I've already created and we'll touch on
those major moving pieces including the
web server the routing logic controller
and database logic to take a look so
here's the application the directory
structure should look somewhat familiar
and we'll start with the package.json so
here you see the name and description of
the app as well as the dependencies and
notice that the main file is the index j
s so we'll open that up here in the top
I'm bringing in two modules all a module
really is is a file written in
JavaScript that exposes some
functionality or keep some private and
I'm bringing in two modules from the
services directory one for database
functionality and one for the web server
note that I'm increasing the thread pool
size we have that background thread pool
we can use for asynchronous processing
because I'm going to create a connection
pool and I want to be able to have more
of those connections working at any
given point in time I'm going to
increase the size of that pool this
needs to be done very early in order to
work then really this is the bulk of the
logic when when we're starting our
applications so the first thing I'm
doing going to the database module
calling open connections and then I'm
going to the web server module and
starting up that web server a little
further down we have some event handlers
so on an unexceptional previous eve a
sig term or sig and event if somebody's
trying to shut down the process then I
invoke the start shutdown function which
have defined down here and so I'm just
doing the reverse of what I did to start
things up so here I'm shutting down the
web server by no longer accepting any
HTTP connections and then I can close
the database connections as well let's
take a look at the database module
that's in services and here it is so I'm
bringing in some config information
related to connections I only really
have one in here to connect to the HR
schema but if I add more this would work
just fine
and the idea is that I'm looping through
any connections and for each iteration
I'm calling create pool and then I pass
in the alias based on the key name so
that I'm able to retrieve the correct
pool a little later when I need to use
it because it closed connections which
just does three various iterates through
the connections and then calls closed on
the pools and then I have a simple
execute function this is just a little
wrapper module for working with the
driver oftentimes if you're doing just a
single execute you don't need a
transaction then the overhead of getting
using and then releasing a connection
might be a little laborious so
oftentimes we create these little
wrapper functions to make these
interactions a bit simpler so that's the
database module check out the web server
which is here and remember this is the
first major piece that you'll have at
any kind of API so I'm bringing in a
number of libraries here including
Express for the web server as well as a
few others so let's see here I'm
instantiating an Express which gives us
an instance of an Express application
this is a web server and I am using the
HTTP module which comes with node in
order to do some functionality that I
wouldn't be able to do otherwise I'll
show you that down here so you see this
HTTP server on connection track
connection
the reason I'm tracking connections this
is a bit of plumbing code so that if you
look down here this is track connection
I'm basically adding open connections to
a map and then when they click collect
connection closes I then remove them
from the map so when the stop method is
invoked this basically allows me to
destroy any open connection so we can
successfully close the web server just
some plumbing code really the bulk of
the logic for the application is this
logic so we have the instance of Express
and Express is really simple because it
uses this middleware logic and we
basically set up a little pipeline so
each time I'm invoking use I'm passing
it a function that an incoming HTTP
request should be passed through so
Morgan which is our logging application
here it's just Express middleware and
I'll show you in a minute what Express
meant aware is but Morgan this combined
call here is going to create logging
that looks a little bit like Apache
logging it's going to have some
information about the incoming request
as well as some information about the
outgoing request or response here we are
using body parser to parse incoming
requests if they are sending us a JSON
bodies will parse that and I have a
little date Reviver defined down here
don't forget JSON doesn't support dates
so this will basically using this
regular expression convert ISO 8601
formatted dates into actual JavaScript
dates next in the pipeline is enable
cores now these two middleware functions
were brought
in via NPM modules but this one I've
defined myself so we can actually see
that signal to enable cores is defined
right here so this is the signature
basically middleware functions take in
three parameters the request represents
the actual incoming HTTP request
response is an object you use to
generate the response you want to send
back out and next is a function you
invoke if you want this to continue
through the pipeline so I am invoking
next year after I modify the response a
little bit adding some HTTP adders so
invoking next essentially what happens
then the request goes from this use to
the next use if we don't invoke next it
kind of stops there and it's expected
that you handle the request completely
here's the next part in our chain so we
had the web server and then routing
logic right so here I'm basically
mounting a router at slash API and that
router is coming in from another file
and it's in the same directory as this
one so here's that router file and again
I'm bringing in Express and then I'm
using another part of Express it has a
router class so I'm getting a new router
and I'm also bringing in a security
module as well as some controller logic
here from some other files and the idea
is I use the router and invoke the route
method and basically say route this path
sofa request comes in on slash employee
employees / colon ID this is a parameter
in the path the question mark makes that
parameter optional so this would get
routed whether or not there was a value
after employees and then I can chain
these handlers here I can say forget
request comes in on this route then go
through this pipeline here and so we're
saying I have this security authenticate
middleware and the way this will work is
if the user is authenticated then
they'll be allowed to get through to the
get controller logic in the employees
module I tend to copy the naming
convention here in my routing as well as
the controller logic
sometimes folks do it differently it
might be the get request gets mapped to
employees dot find and the post goes to
employees create and so on
the authentication here is a bit more
advanced in that it's involving some
authorization as well we're basically
saying if you want to read data you at
least have to be authenticated if you
want to modify data then you need to be
an admin I'll show you very briefly that
security module so there's some
functionality here for various security
aspects such as hashing passwords and
giving tokens and so on but really what
I wanted to show you is this
authenticate module here function here
and this is a function that actually
returns functions that are unique based
on the role they're passed in but you
can see the function follows that same
Express middleware pattern that we've
seen before and it basically tries to
identify the user based on what's in the
token were passed and if it can then we
invoke next otherwise I will send out an
error message that's appropriate so
again the router ultimately is trying to
route the request into some kind of
controller logic so we'll look at that
next going to controllers and I'll just
show you employee since that's really
sufficient notice that the employees
controller logic is bringing in the
employees database API logic as well so
again just this Express middleware
pattern and what the controller logic
needs to be able to do is look into the
request and the request can transfer
data in usually four different ways one
of four different ways so you have the
actual URL and there's two parts of the
URL there's the path and we can get data
from the path via parameters and there's
also the query string and we can get
data from the query string as well and
you see an example of both of those here
we can also get data from the body of an
incoming request and then of course we
can get data coming in from HTTP headers
although that
a little less common so the controller
logic is going to get some data from the
incoming request in this case it's
bundling that up in the object called
context and then it invokes the database
API employees find passing along that
context so the database API then does
its work and eventually passes facts and
rows of data and the controller logic
needs to decide what to do with that
sending out a single row of data error
message or an array of data we see the
post down here so this is for creating
employees now you see how data comes in
from the actual body of a request and
remember that body parsing middleware
will have already parsed this out so we
have actual JSON or rather JavaScript
data we can work with and we simply pass
it along to employees create in this
case and put and delete work very much
the same so if we look then at the
database logic for employees you'll see
that we have a base query being defined
as well as a page inator and this simply
is going to be used for pagination
depending on what the incoming request
looks like so with find what we're doing
is looking at the context and based on
any number of different properties in
the context whether the user is looking
for one bro whether they're doing
pagination this will get configured and
eventually we have this query setup and
ready to go and then we're going to use
the database that simple execute method
I showed you a moment ago to execute
that query and I'm logging the query out
here in the console so that we can
actually see it this is fine and
development but you want to remove that
usually anyone production this is what
create looks like so the create method
is down here I'm just defining the
sequel statement here what that should
look like see a number of bind variables
here and so when create gets invoked
it's passed the employee object there's
a little property here added to that
because this statement actually has
returning employee ID into an additional
bind variable which is an out bind so
that we can pass the new ID out to
the controller that invoked in so we use
simple execute to execute that statement
and then when we have the result we can
resolve that and pass it back to the
controller and of course update and
delete look very much the same alright
so what I want to do is show you how
this application works in order to do
that I'm going to go back to the
directory where the app starts and we'll
open this in a terminal and I'm just
going to type node period because NPM
knows then where to find the main file
so we'll hit enter into starting
application it's connecting to the
database starting the web server and the
web server is now running so I like to
use an application called
paw to test my web services a lot of
folks like to use postman post bans
another really good option and let's see
here okay so the first thing we're going
to do is issue a get request on
localhost port 3000 slash API slash
employees and when I execute that we get
401 unauthorized that was expected so
the next step I'm going to do I'm going
to invoke create user this is a post on
API slash users and so we have I'm
sending it as part of the body my email
address as well as a really complex
password so we'll execute that this was
successful and we can see then in the
database that I have a new user record
and we see the password here has been
properly hashed and I have this idea of
61 I look at the wha
raw response here and postman we can see
that idea of 61 and we were also
provided a token value so I'm going to
grab that here and copy that we'll go to
the next step and note that this is just
like the first step except that there's
this authorization HTTP header that
we're including so now we're going
against the same URL only this time we
actually get some data back
and if we look at the JSON response we
can see we got 100 rows of data back we
can see what that data looks like it's
JSON data as we would expect if we want
to get a single employee back 101 you
can fire that off and we see we get that
employee back now remember to modify
data we actually need to have a
different role so if I execute this even
with our new token we get the
unauthorized response but I can create a
new session oops let's see what there we
got here unique constraint violated
looks like it wrong endpoint there we go
so we have a new token here actually
what I need to do first is change my
role to admin commit that we'll do this
again we'll get a new token copy that
out and now if I try to post some data
fingers crossed we're able to create
data as well on these protected
endpoints of course update delete work
the same way the last thing I want to
show you is update this header is the
ability that we've built in to make this
API bit more flexible and so we have
additional parameters that work in the
query string limit offset in order and
these are for pagination so if we start
with a limit say of 3 and the offset oh
and the offset said well yeah let's
leave it disabled we'll start with the
first so we're ordering by ID ascending
if we fire that off we see we're getting
ID values coming back 100 101 102 and so
on I can change that sort and now
starting with 218 and going down this is
the new record we just created go back
to ascending if I want to say do an
offset of six and a limit of ten you'll
see that that works just fine so it's a
little bit tricky coding this the first
time but subsequently you can just
copy-paste and kind of update from there
but one thing that's not supported here
is the ability to filter data in a
flexible way and that's something that
exists out of the box with the other
implementations that we're going to see
it be a little tricky to do that here so
I'm not even going to get into that for
now
well that was a lot of lovingly
handcrafted code it's maybe not so bad
if you're comfortable with sequel and
especially if you're doing complex tasks
such as transactions but they're simple
crud functionality it can feel a little
tedious for sure also get requests can
be difficult basic pagination not so bad
but there are no generic solutions with
the driver to convert javascript objects
in the URL to where or order by clauses
okay let's move on and take a look at
some higher-level solutions and we'll
start with sales J s actually sales is
just one of many MVC and API frameworks
that are available to you when working
with nodejs all of these tend to offer
all-in-one solutions they bundle web
servers they provide a means to generate
routing controller and model logic
making that a bit easier and depending
on which one you choose they're going to
offer a lot of other features out of the
box but of course that will vary
depending on which framework you go with
the key here is that each of these tend
to favor convention over configuration
sales and loopback are by far the two
most popular of these frameworks sales
is described
five is an MVC framework because it does
provide some capabilities to create
views for websites they use water line
for n o RM and there are various
adapters for all sorts of databases out
there my favorite features of sails
include boot prints which allows you to
easily create and prototype api's and
then WebSocket integration so if real
time data is important or interesting
view then just know that there's some
support for that in sales jazz as for
loopback it's considered an API
framework it's more focused on just
api's it doesn't include that view layer
and it uses a custom ORM it's actually
very well done my favorite feature of
loopback is the discovery API that
allows you to basically go and create
models from your existing tables within
your schema in the database between
these two I chose to demonstrate Sales
Jas to get started with sales it's
pretty simple just run NPM install sales
followed by the - gee the - - you'll
install that globally and then to create
an application you can just say sales
new followed by the name of the project
that you want to create - then start
your application change directories into
that project and just use the command
sales lift and to install the Oracle
adapter for that water line o RM you see
the command here NPM install sales
Oracle VB the - - save just adds that as
a dependency in the package.json let's
take a look at sales so what I'm going
to do here is start a new project we'll
open up the terminal and I already have
sales installed so I'm just going to say
sales new my project you can see over
here it's creating that project and it
gives us a note that because I'm in a
newer version of NPM is a temporary
issue so it basically has to do is clone
a starter repo from NPM package so it
takes a little bit longer then it might
normally but as you'll see here
momentarily it's still not terribly bad
it just really depends on your
your internet connection essentially and
we're done okay so we have a new project
and you saw the manual approach before
let's see what sales gives us by default
voila a complete ready to go application
the most important directories here are
config and API as you can see config has
quite a lot going on this is what we
have to moon by the learning curves a
bit higher with these higher-level
frameworks and then an API the most
important directories all your models
and controllers also policies is very
important as it relates to security so
what I want to do now is see the end of
the project and then use sales lifts to
start it up so you get this message
telling you it's listing on port 1337 so
what we'll do is go to 1337 and when it
loads you'll actually see a webpage and
this is what makes sales an MVC
framework because it actually does allow
you to create websites it has that view
layer we're not going to really use that
but we're going to use the api's and for
that go back to the command line I'm
going to shut sales down I'm going to
use sales generate API and we'll call
this employees excellent it tells us
it's generated a new API so now to go to
API and we look in controllers we'll see
employees controller and if we look in
models we'll see
employees Jas so these are the two files
that created for us and at this point I
can use sales lift again to start the
application back up now it's asking us
what we want to do in terms of schema
migration I'm going to choose the safe
option one as you get more comfortable
with sales you can determine which
source is right for you and at this
point what I'm going to do is run some
tests on the API and to do that I have a
little another pas helper I'm going to
go
into a previous back of them off I'll
open this guy out all right
so here you can see I'm just going
against localhost 1337 slash employees I
refreshed that and the raw response
shows us for getting back an MTA
interesting the next thing I'm going to
do is issue a post or create against
that same endpoint to sending in some
employee data or refresh magnet says 201
created need let's go back and we
refresh we're now giving that employee
back the question is wait I just created
this sales project I haven't yet linked
to the database so what's going on here
well this is what blueprints is all
about it's basically API prototyping and
the adapter that we're using right now
is is writing this JSON to disk and it's
a very convenient and fast way to get
API is up and running and then later you
can tie them into the backend now tying
them into the backend at least for me
was a little bit tricky I had to learn
how to do this and I'll share that with
you have some code samples here so the
first thing we need to do is install the
adapter for Oracle database so we'll get
that going here and as you'll see in a
moment it's going to start a compilation
process that's actually the database
driver we were using from before so the
adapter depends on the driver and in
order for this install the work you need
to have the OCI libraries in place so
just follow the installation
instructions for the driver on the
github site for the driver and this will
work just fine for you all right so
we're all set and ready to go we can
start to interact with Oracle the next
thing I had to learn was how exactly to
go about doing that so the first thing
we'll do is go into config connections
and you'll see that right now we just
have that local disk adapter and I'll
paste this one in here this key here is
for HR and it's very similar to what we
saw before except we're also specifying
the adapter so I'll save that change
and the next thing I need to do is
update our model to use the connection
so we'll go into API models websites I
already have that open so we'll paste
this in save that change and this key is
just pointing to this key here so I will
start sales again and choose one once it
start it up let's try this request again
and now we're getting an error and if
you look at the command line it's a
little bit cleaner you'll see we're
getting Tabler view does not exist so
this is where I had to start sort of
learning exactly how sales works and
then I found that basically by default
sales
creates a table name based on the model
name but it uses lowercase with double
quotes and of course they provide a
means to override that via a table name
property so once I put that in and then
restarted sales I found
yet another error so you come back here
and it says employees updated that is
invalid so with a little bit of learning
I realized that sales is essentially
trying to do some more magic for us so
it's trying to add to our table created
that and updated that Auto primary key
so basically what I needed to do is turn
off this magic for my existing table and
to save us a little bit on time I'll
just skip to the next lesson which was
that four columns I also needed a column
name mapping so we'll just grab all of
that drop this in our model save that
and we restart sales and at this point
we get our data back exactly as we'd
expect so this is perfect they also have
built in the ability to do pagination
syntax is a little bit different than
what we saw before but I can hit refresh
here and we're seeing we're skipping ten
and we're limiting to ten rows and I'm
sorting descending so we're seeing ID
197 coming first I can change that
ascending I can choose not to skip and
maybe limit to three and that works just
fine as you see no configuration here it
just works and it gets really
interesting when you see that they
actually have support for wear as well
and the way this works you're basically
using their predefined syntax so you
have to learn exactly what that is that
you're passing in serialized JSON and
when we issue this request you'll see
even though the limits 100 only getting
10 items back and these are the folks
that have an aien and the first name
field pretty cool huh
as you can see sales brings a lot of
convention out of the box and it's for
that reason that the initial learning
curve can be a little steep but as you
use sales more often of course it gets a
lot easier and in fact over time would
be faster to use as you saw blueprints
is a really great feature too that can
help with API prototyping quick note of
caution when working with ORM s-some as
I learned with sales do enforce case
sensitivity and that may not be the
default way the database normally works
others may not use bind variables this
actually is true as well with sales at
least for now and some don't support
transactions so just be aware that and
make sure you know what you're getting
into all right let's move on to orgs
Ords stands for oracle rest data
services it's basically a java
application so it's going to run in a
java application server and that's of
course quite different than nodejs but
the way I like to use orange is actually
to put it behind a firewall and treat it
just like yet another driver and that
way you get the best of both worlds you
get the benefits of node as well as a
lot of the benefits that you get with
words or just been around for a while it
started back in 2010 as the application
Express listener then in 2011 it got the
first rest capabilities the most recent
version released in 2016 added a really
nice feature especially for these crud
style API is that we've been creating
thus far that allows you to auto enable
rest on a table which is a few clicks
the way that boards works basically a
developer defines a URI and then Maps
that URI to sequel and of course you can
map a URI to PL sequel and of course now
we have this auto rest enablement as
well which just makes things a lot
easier once that's been defined then a
developer can just
consume that via HTTP and they get the
JSON response and just use it from there
all right let's see how this works with
ords first thing I want to show you is
that you can just google Oracle VMs it's
usually the first link we build
developer VMs if you scroll down here
you'll see the database app development
VM this VM comes pre-loaded with Oracle
Database 12c r2 it has org has sequel
dev it has application Express two
really great VM to install that into
VirtualBox you'll see what I'm seeing
here and if you double click the start
this will open up a lot of labs that you
can work through and learn from and of
course Oracle rest data services is
covered to cover how to install words
and how to create users to work with it
I've already done the installation so
let's just use Paul to run a test so
here I'm hitting on the development VM
URL it's running on 9090 with words and
then the HR schema and the employees
table so when i refresh this it's failed
and what I'll do then is go to the
schema and sequel developer and I'm
going to go down to rest services I'm
going to enable rest so we'll check that
and complete it and what I need to do
next is do the same for the tables that
I want to enable and you'll note that
I'm not adding authorization another
thing to note is that they do provide
the sequel so if you want to do this via
programmatic API that's fine too you
don't have to use the GUI all right so
we're enabled and you notice all I did a
couple of clicks right but we should now
have full crud functionality so we'll
refresh this again excellent so we're
getting our data back
you can see one thing that makes swords
a little bit different is that it
actually has a little bit more going on
in terms of what it's going to send back
the actual data comes back on an items
property but you get some additional
metadata that applications can use for
things like pagination which is real
nice
you're going after a single row where
it's just like you'd expect and what may
be a little bit different are these
parameters here so offset and limit work
as you saw before when I did the manual
API so that works just fine but when you
want to do ordering what you need to use
is this Q parameter I think of that like
as a query parameter but it can be used
for all sorts of things if you look
through the documentation on ords you
will come across this doc on
installation configuration and
development and if you get down
something too far to this part here
filtering and queries this has all the
information on how that Q parameter
works the various syntax operators and
so on and even some examples too to get
you going this first example just shows
how you use order by again it's
serialized JSON similar to what we saw
the sales so if we add that we can
control the sort you can switch it to
descending and then we get everything in
reverse order and another property that
you can include in that JSON is column
eight and they can use the operators for
doing things like filtering there's also
adds up you can view data as it was in
the past this one will just add an in
string field so if any of the first name
values have a n then we should only see
those and it looks like that's working
just fine with cban and Allen
as you can see or it can really simplify
creating api's on top of tables via the
auto rest enablement for tables there's
also a lot of other out-of-the-box
functionality that you get with words it
does have a built in Tawaf server
although I didn't demonstrate that today
and as I mentioned before I like to use
origin combination with no js' just
putting boards behind a firewall and
using it like a driver over HTTP
especially for those get requests where
you get all that rich functionality that
all it has to offer so in summary there
is no perfect way to create REST API s
with nodejs
the manual implementations definitely
require a lot of knowledge and certainly
a lot of code but they also give you a
lot of control o our ends can add some
abstractions for databases but just be
sure they're using those databases
correctly
finally API frameworks provide a lot of
convention but that really only makes
sense if you agree with those
conventions I have some next steps here
if you're interested in learning more
these links should certainly keep you
busy for a little while if you're
interested in getting these slides or
code I used in this presentation please
feel free to contact me via the
information from the beginning thank you
very much for your time and good luck
creating those ap is the remaining time
in this session is set aside for your
questions please use these final few
minutes to submit your questions via the
Q&amp;amp;A widget
you
the remaining time in this session is
set aside for your questions please use
these final few minutes to submit your
questions via the Q&amp;amp;A widget
you
less than five minutes remain for your
final questions please use the Q&amp;amp;A
widget
you
this session will now close please
select your next session
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>