<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Batches: A Unified Approach to SQL, RPC, and Web Services | Coder Coacher - Coaching Coders</title><meta content="Batches: A Unified Approach to SQL, RPC, and Web Services - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Batches: A Unified Approach to SQL, RPC, and Web Services</b></h2><h5 class="post__date">2013-01-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/K-yJbUWOhIs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I am William cook and I am pleased to be
here for my first talk at javaone I'm a
professor at the University of Texas at
Austin and prior to that I was involved
in the first Internet software boom so I
have a lot of industrial experience I
was at an enterprise software company
called allegis in the late 90s and early
2000s and so some of the stuff that I'm
going to talk to you about is is
motivated by that experience now what
batches are about is a it's a technical
innovation that's a new way of doing
remote procedure calls sequel client
access or you know being up being a
client of a sequel server and web
services and it's one of these things
where we have lots of solutions here and
everyone's kind of tired of it I mean
everyone's worn out right we've got
korba and rmi and you know all these
different sequel interfaces from you
know starting with jdbc onward and so I
could understand everyone being a little
blasé and saying well why should we
keep talking about this there's
obviously nothing that can be done it's
just going to be a mess forever but I
think that I've been working on this
problem for a long time and it's kind of
embarrassing that I feel like after
10-15 years I finally have a good
solution but sometimes simplicity is the
result of a lot of hard work and letting
go of some of your basic assumptions so
if you just take one of those directions
that the remote procedure call and and
how it essentially evolved from the idea
of a single remote procedure call well
we can make a stub it'll send this call
remotely and get the result and Marshall
the answer back in and from that little
seed was born all of this notion of
distributed objects right with with our
my and decom in korba a lot of work has
gone into this and there's a you know a
book about how to create these kind of
you know distributed object systems
and he touches on a bunch of other
things too but he talks about the sort
of the vision of this procedure calls
which is that you can use existing
languages you just take a language and
you can make it remote able it's got it
what looks like a very elegant object
oriented model but there are a number of
problems in particular latency is one
big problem where the more calls you
make the longer it takes and the the
cost is essentially linear in the number
of calls so every call is a round trip
to the server and so the more calls you
make the more round trips and on a cell
phone the round-trip time is very long
and so the latency is quite high it also
implies stateful communication because
the server is getting multiple
individual calls and it has to remember
the object state between one call necks
and you say you get this idea of
distributed garbage collection and it's
just it's also tends to be very platform
specific because come on in just started
because the the values that are being
copied back and forth between the
machines are often serialized they have
their internal structure put on the wire
and serialized and then they need to be
read off and dealt with on the other
side and so that assumes that there's
some uniformity there so we've got
solutions to some of these problems like
doing remote facades which means you
rewrite your server based on the clients
behavior if the client always makes
three calls in a row then you make a
call on the server that implements those
three calls and you can do it in one
round trip but then what if your client
changes and that is a fourth call you
have to rewrite your server interfaces
so it makes it architectural II it's
it's very bad because your server design
depends on your client behavior and
that's just wrong so server facade or
the remote kassad is not very good and
the same thing applies to data transfer
object if you want to get three pieces
of data you make a data structure that
pulls down all three pieces at once
instead of having to do individual
getters and again that's a kind of hard
coding your client behavior into your
server so so I guess I my conclusion
from all this is that this whole line of
work is we've kind of made it work but
it fundamentally it's not used very much
I mean our
i doesn't get used korba i think this
whole idea was fundamentally a disaster
from a programming language point of
view is that it's one of the massive you
know just kind of construction failures
that the amount of effort and went into
making all these technologies isn't
hasn't paid off so what I want to do is
just start over and reconsider the
problem and make a slight change to our
assumptions and the first assumption i'm
going to change is that rather than
looking at a single remote procedure
call let's look at two at the same time
okay we want to make two calls to the
server and so the idea here is that our
is a remote object and print is a local
function and so we just want to get the
name of our and get the size of our and
print out the answer okay under korba
rmi semantics that takes two round trips
to the server you look at it immediately
you go why should we do two round trips
to the server we what we want to do is
do this in one round trip and so you
could make a server facade and change
your server interface to make a get name
and size method but then you get into
this hole oh we're just redesigning the
server to match the client which isn't
going to scale so so I want we round one
round trip I haven't Illustrated a proxy
in this example but i also want to get
rid of proxies the proxies are the stubs
that allow you call the proxy on one
machine and it forwards the calls to the
server those are bad because they're um
they're stateful they require the server
to hold a state for on a per client
basis okay so stateful doesn't mean that
the server has state or stateless
doesn't mean the server has no state the
point is that the server obviously has
state the question is is it maintaining
per client State on a connection basis
so we want to get rid of that platform
independent meaning it should work
across any machine any language so you
should be able to call from Java to
python python to Java you can't
serialize the internal of your Java
object and send it to a Python vm and
get it to come out right it's just
inherently not platform independent and
then I want to get rid of all these
bad anti-patterns essentially my
argument in this is that data transfer
object is an anti-pattern of the most
vicious sort it's just absolutely wrong
whenever you think you need to write one
there's something wrong same thing with
server facade same thing with adding
changing your server interfaces to say
remote able and things like that you
shouldn't have to rewrite your server
okay so how do we do this anybody tell
me just how do I solve that little
problem of doing that in one round trip
anybody got an answer you know right you
look you're smiling no well yeah Jason
bet it bed at a high level what's that
well you you need to bring the object
down locally okay but let's say it
really is a transactional stateful
object and we don't want to bring it
locally okay it really does exist on the
server we don't want to copy objects
around let's say so what if we could
send so what if you think about it what
RPC does it sends a command line to the
server it's like a little script to
execute one procedure call right what if
we could make that script have two lines
and send it to the server so that it
said get the name and called the get
name method and the get size method in
one script okay what's going to have to
happen there well we're gonna need to
buffer up the two results right so we
need to get the a a result as the first
result and get the B result then we'll
bring back down to the client a pair and
then the client can happily print the
first element of the pair and print the
second error of the element of the pair
so if you can just sort of take all the
server stuff and send it to the server
and do it in one go and bring the
results down and then run all the client
code that needs those results and you'll
get a really nice behavior and that pair
is essentially the data transfer object
it's been created for you automatically
and the little script that you sent that
said get the name and keep the result
get the size and keep the result that's
your server facade it was also created
on the fly so we're doing those anti
patterns in the compiler instead of in
the in the programmer
so here's the solution is to is to just
introduce a new language construct
called batch and what batch does is it
means let's communicate with a remote
service and make sure and we give that
remote service a name our and we give it
its interface item and the item
interface is essentially the virtual
interface of the remote server it says
exactly what capabilities that server
has in the sense of a capability model
and we can call get name and gets eyes
on our and then bring the results back
and print them both out and the
semantics of the batch is that it always
requires exactly one round trip and no
more so it's block the fact that it has
a scope matters because it's saying I'm
going to do all of these commands in one
run trip and guaranteed okay so it gives
you a performance guarantee in a kind of
nice semantic package there so the way
it works under the covers is that the
compiler transforms this code to run it
in a completely different way instead of
calling you know a remote object and
another remote objects the code to send
a script to the server that contains two
lines getname and gets eyes on the route
object and then the server execute those
two calls and because the two calls have
been tagged to say that the client needs
the results it makes a pair of results
and brings them back and then the client
runs the local code namely the two print
statements so it's the execution model
is completely different than ordinary
Java which is fine okay so let's here's
here's what here's what the compiled
code looks like if I were to kind of
compile the code and then and then you
know kind of re-engineer the bytecode so
it creates this script that says call
root get name root get size capture the
out means capture those outputs into a
field named a and a field maybe and then
so that creates a script it execute the
script gets a result forest which is now
going to be a collection of results like
a result set in sequel and and then
print out the get of a and the get of be
I guess the first one should be
getstring actually that's okay and I'm
calling this the batch command pattern
and the idea is that you're used to
writing this
kind of thing manually right this looks
like a JDBC call you make a query you
execute it you decode the results but
the key thing is in this model you never
write that code you never write the
batch command pattern yourself you
always write this and the compiler
generates the batch command pattern for
you all right so this is not human
written code and if you're ever find
yourself writing this code you're doing
it wrong because that's an anti-pattern
at a human level at a programmer level
that's my argument okay so let's scale
this thing up now I want to talk to a
mail server with a bunch of messages and
put a loop into my script into my into
my batch so this is going to say connect
to a mail server for every mail message
in a in the messages on the server if
the size is greater than some limit then
print out the subject and say that it
was deleted and actually delete it and
then otherwise print out the message in
the date okay so the idea here is that
the bad this is surrounded in a batch
which means that the whole thing has to
execute in exactly one round trip to the
server so how are we going to do that
it's got loops and conditionals in it
any ideas you look like you might have a
clue on that one know what do you think
think about what data needs to come back
so the blue code is all the remote code
actually the data that needs to come
back is the size and the subject the
date and the delete may or may not have
a result we could actually talk about
that in a second the only way to do this
in one round trip is to send a script to
the server that has a loop in it ok so
this loop needs to get run on the server
the conditional can get run on the
server and then it will conditionally
return the subject and delete the
message or return the subject and the
date ok that's what the server can do it
can do all those operations we're
returning the appropriate data and it's
quite happy and then the client needs to
run the loop again to loop over the
result set it doesn't really it needs to
test the condition and needs to know the
answer that happened on the server
it'll print something out or it'll print
something else out so if you think about
this code is is taking the code and kind
of running it once on the server with
all the server parts and then rerunning
the control flow on the client the
client cloak control flow is going to
exactly mirror the suit the server
control flow okay but it's not going to
do any of the server operations it's
just going to consume the results that
were created and stored on the server
and transferred back to the client a
limit know that notice that limit is a
local integer so that actually needs to
get sent to the server for the server to
be able to do this test so there's
really a kind of a a handshake that the
client sends the script and the
collection of data inputs needed for the
server to do its work the server
performs its actions and then collects
up all the answers and then sends the
results back and then the client reruns
itself to do any remaining computations
and it's always exactly one round trip
no matter how many nested loops you have
or how many conditionals or anything now
you're probably immediately thinking
well this doesn't always work what
happens if I ask the user a question in
the middle of the loop do you want to
delete this file well that's not a legal
batch you can't write that that's a
syntax error according to the batch
statement so you have to what you'd have
to do in that case is write a batch to
get all the names of the files and the
sizes and then go through and ask the
user if they want to delete them and
then do another batch to delete them all
on the server so you're there would
still be some you do need to manage the
interaction with your remote service in
a logically consistent way you can't do
a batch that involves both many round
trips to the client and the server you
have to kind of logically separate it
into into these phases but at least then
your program is going to logically
represent the structure of the
interaction with the server as I need to
get a bunch of things decide whether to
delete them and then send that off to
the server I'm going to be a
compile-time error yeah exactly i mean
that's why i said syntax error but it's
a compile-time error it's a compile-time
error if you write a batch where it
doesn't have essentially there's a data
flow analysis here I dupa data
dependency the batch has to only depend
on things that are exist before the
batch statement if those things are
inputs to the syrup to the remote
service
okay you can't have an input to the
remote service that is computed in the
body of the batch because otherwise you
get a tangling in the data dependencies
and that's detected statically by the
compiler okay so I'm going to skip over
this briefly or run through this really
briefly this is just an example of the
actual script that gets sent to the
server in this case and you notice that
it's got all the code that was blue and
all the print statements have been
deleted removed and it's outputting the
conditional of the the boolean because
the client needs to know that and it's
using an input named X so it's got a lot
of stuff by the way I'll just mention
now that the the bat this is a batch
script language and it's not so we don't
send Java to the server to execute we
send these little scripts that are
directly analogous to sequel it's it's
really taken the sequel execution model
and redoing it for our PC and what you
end up with well so so one amusing thing
is that i'm using a subset of javascript
as the batch script language so it's
analogous to Jason which is the subset
of JavaScript which is the data language
this is a subset of JavaScript which is
the remote scripting language and this
is completely secure you can't call
constructors you can't call you know
static methods you can't call anything
that isn't in the root service interface
so it's just as secure as normal RPC
you're not opening up your vm to a
remote system and these scripts are
executed under potentially under very
tight control so that the server has
complete controller how to execute them
here's the remaining client so this is
the this is again this is compiled code
after running the script it decodes and
this is all the stuff that's left over
with the print statements and the client
code and that the the whole data
transfer has been managed for you it's
making this essentially a table of a B
and C values that tell you tell the
client what happened on the server and
what control flow to follow and what
things to print out everybody got the
basic idea it's like why didn't we think
of this before right it's so obvious why
I kick myself every morning because I've
been working on this for so long and
took me this long to figure it out and
one thing that required me to do that
that was ingrained one of the
assumptions that it requires you to get
rid of is the idea that you can take a
programming language design it
completely wrap up the spec make the
compiler and then make it remote if
that's your constraint that you have to
take an existing language and make it
remote able you cannot solve the problem
because you need to change the language
semantics to do this so this requires a
change to the Java compiler it's
actually I've implemented it in OpenJDK
and I'm essentially announcing it today
and you can download it and try it out
Oracle is encouraging me to do this and
and propose it as a future feature for
Java so I won't say they haven't
authorized this as an actual future
feature but they're certainly
encouraging its exploration so summary
the server published as an interface
just a clean interface an object or an
interface that says what the clients can
access and then the the server also
creates a little engine to run these
scripts you can write one in Java in two
or three days I mean it just is a very
simple language and you know it's
essentially a student project the client
can only access them it's stateless
because the batch contains it can
actually generate remote the batch
script can can access remote objects
intermediate objects and perform method
calls on them but when the batch is over
the server can actually free up all
those intermediate objects because it
knows the scope of the entire
interaction with the client it doesn't
need to maintain state across the calls
in a batch because they all actually all
happen in one round trip on the server
the client needs a new cinta and new
syntax and new semantics it needs to be
changed and but you can do this in any
language and the other thing is it
there's no serialization in this model
the only data that flows back and forth
our strings integers dates reals and you
know basically primitive data types just
like in sequel so it's completely
cross-platform ok so here's the actual
subset this is the this is the scripting
language it's got variables constants
conditionals for loops
barrett local variables you can actually
have local variables in your script
filled access method call primitive
operations so you can do comparisons and
things and it actually has lambdas and
these input and output or what allows it
to do the bulk data transfer so if you
squint and look at it it's actually kind
of like sequel and I'm going to get into
that a little bit more but it is a
subset of JavaScript and it's a it's a
fun little language that's really well
suited to exactly this this application
okay so let's talk about the sequel
angle you know again we had sequel and
then we created all these clients and
you know hear it everybody see this this
is the batch script pattern right this
is simple JDBC select some files execute
it decode the results that's the batch
command pattern I was telling you about
so here's the code written in batches
okay it's a lot smaller and you can read
it in two seconds where is this one you
know what's going on here right there's
metaprogramming going here we're
artificially introducing metaprogramming
where we're manipulating programs of
values namely the script we've taken
half our program and we turned it into a
string and then we you know run that and
then we manipulate the result set why
don't we let the compiler do that for us
right this is the point you write this
you get the previous slide for free and
so case is not obvious when you write
that it actually creates this batch
script here for F in route dot files if
F dot size greater than 90 output a as
the file name and output be as the the
results of calling f dot size and that's
just another syntax for sequel okay so
there's a there's essentially
isomorphism between the batch script
language a subset of it that doesn't do
the batch script language is able to
call methods and do series of method
calls if you kind of restrict it a
little further then you get something
that's just the query sublet subset of
batch script and that can be translated
to sequel efficiently and so what you
end up with this is a really nice
guarantee that if you target if the
service that you're targeting could be
an RPC server but you
switch it over to be a database server
and the batch script language the
translations will all happen
automatically and the other thing that's
nice about it is that you actually get a
guarantee that every batch statement in
your source program generates a constant
number of sequel queries there's no n
plus one query problem okay so every
batch equals constant queries no matter
how many loops you do you can do five
nested loops you can do arbitrary stuff
you'll always get the same number of
queries at runtime and so that's a very
hard guarantee that for example link
doesn't give you you don't know what
your performance is okay so in order to
do this you need to have a rich
interface so the server as I said
publishes an interface so what kind of
an interface does a database server
publish because what I'm doing is I'm
saying that the interface is going to be
published in an object-oriented style
but we know how to do that you take a
database schema and we know how to turn
it into an object-oriented observational
method getter kind of interface
collection and so your database is a set
of many customers and many orders and a
many is this sort of generic collection
thing that allows you to count it and
get the average and do you know basic
kind of sequel collection style
operations encoded as methods and then
the order is god it's data you know
fields customer has its data fields and
you can represent bi-directional
relationships as you know that I think
it might have know if it got deleted
here but you know an order customer can
have many orders and an order can belong
to the customer and things like that so
you know all your standard object
relational mapping stuff happens and it
just it works in this case and so what's
going on is that the that logically
you're operating over what look like in
memory objects but behind the scenes the
stuff that's on those database objects
gets ripped out turned into a script and
then that script gets turned into a
sequel statement and then the results
are decoded back into script format back
into it into appropriate structure to be
presented in the
in in the original code okay so okay so
let's talk about link so link is very
interesting because it introduces for
c-sharp this idea of sort of queries as
syntax right where you can actually put
a little for each files put the query
and stuff and so it's doing some of this
translation for its where it's kind of
taking expressions in the c-sharp
language and promoting them to be
abstract expressions which then get run
on sequel but the thing is it's funny
about it is it still uses the batch
execution pattern you still have to
execute your query create an artificial
result set and you have to do that
yourself and then you have to decode the
results so so link doesn't go far enough
in some ways to getting the the true
kind of abstraction away from this idea
of meta programming and you can really
see that when you try and do a dynamic
query in link if you want to have a
search page and you have a field that
they can enter optionally or not and if
they type in a name test a test then it
adds that as a condition to the query
and if you don't type in that test it
doesn't add that as a condition so here
you're you're actually doing kind of
condition lunging in link where you
create a collection a virtual collection
and then if there's a condition the test
is a string field if they specified one
then we update the matches virtual
collection with a where condition that
kind of slams in a where Clause into
that virtual collection the way link
works is that it just it just the
collections don't actually create the
syntax create the sequel statement and
go to the database until you say fetch
or to list but anyway so then we can do
a selection on that and then check the
actual results and it'll do the right
thing it's not too bad but here's the
here's the batch version of this and the
interesting thing is that what's going
on here is we have a conditional that
says if the test length is zero that is
that they didn't specify a criteria a
test criteria or if it matches
then we print the thing out so this is
saying if they didn't have a criteria or
if the criteria they gave matches then
print it out and the the interesting
thing about the left side of this
conditional is that it doesn't involve
any server information the test value
variable is a client-side variable and
so the system the batch system can
actually pull out that part of the
conditional and execute it before it
runs the batch and use that as a
condition of whether to even insert the
condition for the second part so it's
doing kind of staging weird saying ah
here's some part of the condition that
only depends on local stuff so why don't
I do that before I send it to the server
I don't need to send the server the rest
of this condition so it's a it's
essentially the the same as the you know
the rule for what they call it the
conditionals are sort of non-strict they
only evaluate the left side they don't
run them what is that called you don't
run the right side of an or if the left
side is true well there's some name for
that My Mind's too early in the morning
short-circuit evaluation thank you good
man short-circuit evaluation but here
we're doing short-circuit evaluation
against a remote call so when we short
circuit we don't even send the rest of
the condition to the server great that's
what I needed okay okay so it does
involve one round trip as I said so if
you if you try and get a remote value
like the subject of a message ask the
user if they want to delete it and then
delete it and write that in one batch
that will be a compile-time error
because it requires going to the server
getting the subject going back to the
client getting the answer and then going
back to the server to delete it so if
you do that kind of tangling it tells
you no you can't do that you have to
rewrite your program and that's that's
connected to the idea that the batch is
a guarantee of one round trip so you
have to do it in two batch statements
two round trips that's just the way it
goes ah one of my favorite topics I
always say there's no serialization and
I don't know some people might kind of
cheer inside but most people go what no
you can't get away without serialization
that that can't be so so what do I do
about serialization well let's consider
the
so first of all I prohibit it in the
current version of the system and again
it's experimental so if we find out that
you know this is completely this isn't
going to work well we'll fix it but I
have a solution that I'm proposing and
so we can't send the internal guts of a
hash table from one vm to another
language vm right they just don't
represent things internally the same way
but every hash table has an external
interface that makes sense potentially
on both machines and so what is there
isn't not an example of a hash table bit
of a set let's say we have a set of
names and we want to take that set and
send it to the server ok so we have a
set of strings called local and that's
our we build up this set of local names
that we want to send the mail message to
and then we want to take that local and
send it up to a server set of recipients
and then send the message to those
people right so I mean involves copying
the set from the client to the server
and I've said you can't do that so what
do we do what we do is we we use it the
nice feature that we can have factories
in the server interface right the server
is allows you to call it has an
interface that says what methods you can
call and one of those methods can be
make set and what that does is it makes
the server set it doesn't make a client
set it makes a server set but then when
you make a set that set in turn has an
interface for things like insert an ad
adding up you know values to it so what
I'm going to do here is in this batch
make a server set and make that into a
local variable which is going to be a
local variable in the script that will
run on the server and then locally
iterate over the local addresses adding
all of the values from the local set
into the remote set using the remote set
add to interface ok so we take the
remote guy and we actually call his
remote method to add each item this
looks like a one of these tangling is
back and forth but it turns out that it
can be untangled by just before sending
the batch to the server do this local
iteration to gather up all the local
values out of the set put them into that
input structure
that gets sent to the server then the
server will run create the server set
run the loop again because we're always
seeing these loops are getting and as it
runs it'll pull out the items out of
that bulk data transfer list that was
sent to the server and it'll add them
into the server set and then it's got a
server set so you're essentially playing
this trick of kind of getting bulk
results back but in the other direction
where we're sending bulk inputs to the
server okay and it turns out that
there's no back and forth tangling here
because the the local information just
needs to be collected all of the local
information gets collected and then sent
to the server in one chunk so what I
call this is serialization by public
interfaces so we have the server has a
set interface that's a public interface
and we can put things into it using that
interface and we can get things out of
our client value by doing you know it
getters essentially our iterators and so
the net effect is basically the same as
serialization right on the client it
collects up all the data that it needs
to send to the server in a block sends
it to the server and then writes that
into the server object that's more or
less what serialization does the
difference is rather than doing it on
the internal guts of the object we do it
on their public interfaces and therefore
it's cross-platform it doesn't matter
whether this server set is a Python set
or a Java set just as long as we can
create one and call the add method with
a string it will work so that's and then
the trick is that you don't want to
write this little helper code this is a
helper code these three lines are the
helper code that copies a local set to a
remote set we don't want to write that
everywhere that we need to do it so we
need a way of modular rising that into a
reusable kind of library call and so
there's a way to do that and I'll just
mention this it's a little bit squirrely
to talk about this but let me let me
just stop let me just mention that I
don't have a great example
handy right now so the point is that up
to now the batch a batch block contains
essentially arbitrary Java code okay
it's subject to some constraints the
local code actually can be arbitrary
Java code the remote code has to be
restricted it can only perform method
calls and simple boolean comparisons and
loops and things ok so the remote code
is is is restricted but the local code
is not restricted there is this other
assumption that is implicit in what I've
been saying that every method call
occurs either on the server or on the
client and you it's all on one or it's
all on the other all right and that
makes sense in some ways right because
every method body occurs on exactly one
machine or the other machine it doesn't
span machines but this case is a case
where if you want to put this into a
procedure into a method then it in fact
has both remote and local operations in
it so that's a method that needs to kind
of run on both places so what a batch
method is this including batch attribute
on a method says that this is a method
that essentially when you run it on the
client it gets in lined into the batch
and it in turn can get partitioned so
the method itself gets split into two
parts half of it gets included in the
script that sent to the server and the
other half is local code that gets run
and I know people are looking at us a
little quizzically it's like what the
heck you don't need to understand this
to get the idea the point is that if you
want to really get true modularity we
need to kind of introduce this
complexity of methods that can be
partitioned that's the phrase that I use
sometimes is that remote and local code
gets partitions split into two pieces
normally we chop a batch block into two
pieces the remote part in the local part
everything's clean sometimes you want a
method they've also gets chopped and so
that's what this is we can we can make
these chapa wall methods and the point
is that now i write this reusable send
method and now in my in my mailer call i
can just say send on the local set and
have it go up to the remote set and all
that gunk of copying the values is
hidden in the send call ok so I've
managed to modularize it and hide it
it's a it's probably the nastiest thing
I mean it's interesting i think the
batches idea is very simple but it does
unfortunately get some complexity in the
especially when you start writing
reusable libraries exceptions are very
interesting what happens if during the
execution of the batch block an
exception is thrown and there are two
cases where that can happen one is that
the script gets sent to the server and
while the server is running the script
an exception is thrown you call the
delete method on a message and it says
can't delete that you know for whatever
reason your security violation or
whatever what happens is that the batch
the default behavior is that the batch
gets terminated and all of the results
up until that point are returned to the
client and the exception an abstract
version of the exception gets returned
as well it's not actually the real Java
exception because again the client could
be Python and what is the it going to do
but it gets a description of the
exception and so as the client runs the
code it's going to process the results
and the minute it tries to access the
result that was the thing that caused
the exception it will get the exception
to so the same exception happens in the
same place and everything is cool and
that actually works really nicely so so
exceptions do get handled if the server
really there's no mandate that says how
the server execute these scripts if the
server wanted to keep going you know
that would be part of the server
contract essentially what's going on
here is that the batch script is like a
server specific domain specific language
the batch the server could choose to
execute the scripts in parallel for all
it you know for all the client knows
right that's why sequel does essentially
it reorders the execution right with the
query plan so the server could also
execute the thing transactionally that
if it got an exception it would roll
back all of the operations that had been
performed and send an exception at the
very beginning saying batch failed right
so you could actually do transactional
RPC servers in this style which is very
nice batches don't require transactions
but they certainly enable them in a very
nice way even for your RPC servers yes
yeah okay I'm wrong okay I need to
change my spiel primitive strings and
these special exception values come back
yes there's a third kind of thing and
they just our little like little bombs
the minute you try and touch one boom
you get the exception and so I mean the
client can catch the exception and keep
going or even handle it in different
ways because it's arbitrary Java code
you can't do exception handling
currently in the batch script itself the
server script can't catch an exception
and proceed but the client code can
finally there's one really nasty bug
that lurks in this and I'll just tell
you about it which is that if the server
execution processes completely okay but
when the results come back the client
code gets an exception while it's
actually consuming the result set like
it tries to print out all the names are
the things that got deleted if it gets
an error in the middle and it fails to
process all the deleted things then you
actually have a potential bad situation
because the server has actually done a
lot of work but the client failed to
kind of can't you know process at all
correctly so clients do need to be very
careful with their exception handling
because the the work has already
happened all the server work has already
happened right it's not synchronous like
in a normal RPC so we already mentioned
this they're not transactional that you
can do transactions if you want to it
doesn't get rid of the issue of partial
failure but it reduces its scope because
there are fewer round trips I find it's
really interesting that there was this
article a really famous article now the
note on distributed programming by man
the name was just in my head Waldo some
people might know this anyway and I
think this was in the mid-90s they wrote
this beautiful note explaining why RPC
was so broken and then they turned
around and implemented rmi because and
did all the wrong things again and
because they just we hadn't figured out
a way to do this
and so it's like if you go back and read
that note relative to what I've done it
um it actually tries to address some of
those issues so the other thing is that
there's a very strong guarantee and
there's a very strong non guarantee that
you have to keep in mind this if I was
just mentioning that what's going on is
that there's remote and local code
that's interleaved in the batch block
what happens with the with the compiler
partitions them into the remote part in
the local part and it runs the remote
part first then it reminds the local
part so what's happening is that the
order of execution is actually changing
of the order the logical order of
execution of the remote parts relative
to the local parts they're being
reordered it's like an optimizing
compiler that depend the correctness of
that transformation depends on the idea
that there's no hidden channel of
communication between the remote server
and the local if that if there was like
back information then that
transformation will produce a different
answer than if you ran it the normal way
if there isn't any back information
channel then it will be semantics
preserving it'll mean the same thing so
there is this assumption that the remote
and the remote really does mean remote
when you're talking to a remote guy the
only effect you can see is the method
calls so those get reordered however it
would be really bad if the remote and
local parts themselves got reordered
because they have a logical flow of
control that really matters in the in
their own context so the guarantee is
that batches always run the code in the
corrected logical order that you would
see if it was run you know without
batches on the server and on the client
they're consistent with respect to
themselves it's only with respect to
each other that the reordering happens
and so here's an example that is a
compiler error even though it looks like
a valid batch what it does is it gets a
local a it calls update a on the remote
thing and then it prints out the answer
then it gets some local be called update
beyond the remote server and then tries
to print out the answer now if you think
about what has to happen in order for
this to work we have to call the blue
code in one round trip to the server
therefore we need all the inputs to the
blue code first in order to do that we
have to get a and B first to send them
to the server but that implies a
reordering
of the get be and the first print
statement on the client so the logical
order is get a print get B print on the
client of the of the red and green code
that's the order in which it has to run
in order to run this as a batch you
would have to call get a get B then call
the server script then print print and
those orders are not the same so this is
actually a another compile time error a
simple answer which is to get these two
things put them in a local variable
first make sure their strings and
strings don't have any side effects
right that's one of the reasons why we
can treat them as you know primitive
values are good and then call the two
updates and then you're fine because if
get P it get be for example calls that
gets the length of the print stream then
you're going to get a wrong answer if
you run the the get be before the print
there's that's that's an example of the
hidden state okay so I'm going to kind
of plays through this really quickly but
web services are interesting to kind
went from HTML the XML and then these
web services things and there's there's
at least two ways to do what web
services one is RPC web services and
those all my arguments about RPC web
services are covered in the in the RPC
this you know discussion that we've
already had but the document-oriented
web services are really interesting
that's when the client sends a big XML
document that says process this please
and then the server supposed to do some
work and get the answer back it turns
out that there are examples of this
document or a web service is around like
amazon web service interface to its
product catalog and so what this happens
here is you send a request you send the
item ids and then you send the names of
the methods you want to call the
properties you want to access on those
two item ids and you know when i see
this i immediately think oh there's a
loop here and there's you know to get
errs and to write one of these things
essentially what's going on is this XML
document that's being sent is like a
custom scripting language what it means
is for each of these items get these two
properties and give me the answers okay
and every single API call individual
call has a different scripting language
with different conventions okay
and here's how you here's how you call
one of these things you create an object
you create a request and you put the
things in and you put the other things
and then you execute it and then you
decode the results okay so that's the
same anti-pattern happening again but
this is even worse because we're we're
doing it in XML right everything's worse
in XML although I like XML a lot when
you met a program directly in it it's
pretty ugly so here's what it looks like
in a batch you make a connection to the
server you log in you get the first item
so this is actually asking the remote
service for item one and getting a
virtual remote handle to that remote
object called item and then you display
which is the local method the sales rank
and the small image but keep in mind
that this item a that's a server object
that never gets instantiated on the
object there's never a proxy for that
object on the cert on the client it
never gets instantiated on the client
what happens is that a script gets sent
to the server which gets that item and
then calls these two you know specific
methods oh I didn't mention that's
besides dates and strings and integers
there's also binary data blocks like
images okay those are essentially
primitive values as well blobs so
exactly like sequel then we get item two
we print out the sales rank on the small
image and you're done and there's none
of this sort of meta stuff whenever
you're creating a request object
manually and populating it with stuff
you're creating syntax and you're going
meta and you can just see that you have
to process this with two levels of
intention right there's the code that's
running in the Java that's creating the
code that's running on the server and
that in Direction this is analogous to
direct manipulation user interfaces
right you like to recommend emulation
because you click on the object and you
do things to it this is not clicking on
the object and doing things to it this
is writing down a recipe to tell the
person who actually is on the other side
of the land to click on the object and
do it whereas this is direct
manipulation yeah
you could you could put loops and things
I mean but it's still not going to get
rid of that in direction you know and
you could wrap this by a nicer call on
the client I'm just saying that the
batches kind of do the plumbing for you
yeah there are ways to clean up the ugly
version but but this is kind of a power
tool for cleaning it up we did actually
do a version where we wrapped the Amazon
Web Services with a batch interface and
ran this code so so it does work ok so
the hard part if you're interested is
adding batches to your favorite
programming language I've done it for
Java I have a student is doing it for
JavaScript another student is doing it
for Python but the server side is
actually really easy because it just
needs to execute scripts that's trivial
the client-side involves actually this
partitioning process and so that's a
compiler activity what actually happens
under the covers is that the the source
code of the original language gets
converted into a script with an other
node that represents all the stuff that
can't be in the batch script there's a
partitioning algorithm that's written as
a library that you can run it kind of
creates the three stages the local part
the remote part and the local part the
remote is guaranteed to not have any
other nodes in it because those are by
definition things that only can happen
in the client and then that gets
rewritten back into the little pattern
here the batch execution pattern where
it calls the local stuff to create the
script and the local inputs execute the
remote part gets the outputs and then
post processes them and all you have to
do is really write these two
transformations back and forth it's done
as a a completely you know how the they
introduced the new for loop into Java
you know the for in loop essentially
it's a it's a since there's a phase in
the compiler that translates that into a
normal for loop batches are done the
same way it's plugged in in a very
modular way or just it it actually uses
exactly the same trick so let me just
mention the batch OpenJDK Java see that
I've released has no syntax changes and
no type checking changes at all to the
Java compiler it's completely matches
are just an optimization
in order to get in order to achieve the
no syntax changes I couldn't add the
batch keyword because that would break
the language of break Eclipse and break
everything right so instead what I do is
I use the for loop it turns out that for
and batch have exactly the same syntax
it takes an interface a local variable a
thing to operate on and then a body and
the rule is that if this implements
iterable then it's a normal iteration
for and if it implements service then
it's a batch for and what you mean when
you say this is for get me this remote
handle to this remote service do this
body one time it's not a repeated for
it's a it's kind of a declarative for
for this server connection do this body
and the semantics of that is completely
different as I said but the syntax and
the type checking and everything else is
the same so there's essentially no
language changes at all except into the
fact that this kind of four gets if it's
a batch for gets rewritten you can also
write your own pluggable service
providers and I have a couple little
execute things remotely they'll execute
them locally that'll translate them
sequel so it has a full sequel
generation ORM type system with all
including inserts deletes and updates in
bulk and aggregates and sorting and
stuff and you can do XML transport Jason
transport it's easy to add your own
transport to transport these bulk
recordsets back and forth so this whole
fetish about is it XML encoded is it
Jason encoded is it this encoded it's
just it doesn't matter that's that's
irrelevant okay so the idea here is we
take the best things out of these three
guys web service is our cross-platform
right but they're really ugly RPC is
kind of beautiful you just directly call
your odds and sequel has this whole bulk
you know transfer thing going on which
is really cool but doesn't you know it's
hard to interface with your regular
language and you just unify those three
three things into one new construct
called batches they may have a better
name for this I'd be happy to
to find a better name but anyway so it's
a general it's actually a very general
statement for dealing with remoteness
and i even have projects that are
thinking about your GPU as a remoteness
okay you want to talk to your GP you
efficiently you need to do bulk data
transfer and transfer scripts to it
that's exactly what you know
coprocessors do so you could use this
there it unifies distributed objects and
RPC style programming relational
database access clients and service
implication for web services and it
gives you all these beautiful benefits
that's its sufficient because it does
these gives you a performance guarantee
it has a very clean programming model
it's direct manipulation instead of in
direct manipulation there's no queries
it's stateless there are no proxies and
it's completely language neutral so I'm
having a lot of fun other than the fact
that it took me so long to get here and
the big the big nasty thing is that you
can't do it as a library you have to
change your compiler and so that's what
I've done for java and it's available
now to try out i'd love to have people
help me out and work on this and we're
going to turn it into a you know an
openjdk sub-project is the current plan
I think that I'm done so thank you any
other questions we have few during the
talk yeah yeah
yeah yeah you'll actually find that a
lot of the Martian a nun marshaling
happens automatically in those
collecting up the bulk results okay but
you're right the other kind of big you
know advantage or disadvantage depending
on how you look at it of this current
proposal is that the server objects only
exist on the server they don't ever
exist on the client so it looks like an
object relational map but it doesn't
bring the objects down all right it just
brings down the parts of the object that
you need to do the local part it'll
bring them all down but so that is
probably the one area of kind of
research open the weather the current
thing is good enough if if you wanted to
add sort of a that that idea i talked
about serialization by public interfaces
that could be automated right you could
say get me this object call all of its
public methods and then call this local
object and write the stuff in right
because that's essentially what you want
to do right you want to that the client
the server object doesn't really exist
on the client because it could be
implemented at a totally different
technology but logically it does exist
on the client and so a kind of automated
copier that would just kind of read out
the data and write it back in I think
would be really cool and we could do
that and then it would I think satisfy
your concern but but that's absolutely
right now I'm kind of holding the line
and say can we get away without it but
my guess is we probably won't and maybe
i'll i'll add that so help me out other
questions
the script language yeah right now the
the specs are given as a series of
academic papers published at oopsla andy
coupe but i am converting them into a
kind of you know more normal java spec
format and so there will be one yeah
definitely ah a synchronous calls yes so
that's the other thing that's really
interesting as most people say ah our
pcs broken the answer is asynchrony
right now asynchrony doesn't help if you
have conditions if you have ifs in your
in your loop so so batches actually run
faster than a synchronous code if you
have conditions because the condition
causes the client to have to block and
wait for the results before it can know
what next call to issue by transferring
the condition to the server it actually
can run freer now the so so in that
sense there's some ways that batches can
perform better than asynchrony as its
contrition alee understood now the other
thing is that there's no reason why we
couldn't run the batches asynchronously
as well and actually right now it's a
synchronous thing where it sends to the
server gets the result set and it brings
it all down but the way sequel works and
the way batches could work is that you
can actually run the the server and the
client as co routines and the minute the
server starts producing results the
client can start running okay and
essentially you'd stream the result set
back to this to the client and so that
would give you full asynchrony again
without having to write any you know
weights or racing calls or anything so
that's another research area is to make
an asynchronous version of batches yeah
but I guess it it's both if you look at
link batches kind of use some of the
link ideas there's it uses filter prox
and group by things that are prox so it
uses some of those ideas again with its
it's completely compatible with
asynchrony as far as i can tell it could
do this object serialization thing a
little more automatically so there's a
lot of room to to build on this basic
intuition that we're just going to do
multiple things at once instead of
sticking to the synchronous the model
okay other questions we done and there
you got to get to your next talk yes one
more
I do I have a Java server side it's like
three hundred lines of code I mean it's
just trivial and I mean you'd like to
make it more robust by doing some some
maybe if you want to add a security
model it's already fairly secure because
you can only call public interface
methods but it uses reflection I have a
I have a Python server and the Java
client can call the Python server and
yeah it's and it the thing is that you
know you have to realize that they're
the server interfaces get written down
in Java for example but when Python uses
them it just uses name matching right it
doesn't actually have an interface yeah
okay cool thanks again</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>