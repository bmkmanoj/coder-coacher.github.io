<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Migrating Spring to Java EE | Coder Coacher - Coaching Coders</title><meta content="Migrating Spring to Java EE - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Migrating Spring to Java EE</b></h2><h5 class="post__date">2013-02-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/mzyX5uGTl5U" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so yesterday we did a talk together or
it's a two-hour to tutorial on Java EE 6
and at the end of the presentation I
just quickly showed this as a shameless
plug to get you all into this talk and
at first when I showed the picture
everybody started to laugh because they
thought we were making a joke out of it
right
so of course well I admit there's some
controversy in it of course I mean that
will make it a little bit more fun but
then there's also a very serious message
in it and I hope you're all here for the
serious part because we prepared a well
five-step process in order to get rid of
spring and migrate your existing spring
applications towards Java EE 6 we're
gonna tell you all about it in the next
hour so before we begin that just
briefly introduce ourselves we already
did a number of talks so actually we
assume everybody has seen us now a
couple of times already
maybe so this for when I both work for
Luminess in the Netherlands which is a
consulting company of about a hundred
people we do Java a lot of Java ranging
from enterprise systems to mobile and
then besides our service departments we
also have a Rd division that's where
Paul is working and follows the amount
of open source and he's also working on
our under cloud innovation platform so
if you're interested take a look at that
and if you want to reach out to us
please do so on Twitter so the first
question to ask when attending his talk
is who is this talk actually for so I
take it that you're well interest in
Java EE because it has seen all have up
taking the past couple of - well maybe
in the last couple years - years or so
there's a lot of update for Java EE
I mean well honestly Java EE hasn't been
so hard to like say five six seven years
ago right so that moved a lot of people
into the arms of rod Johnson and in the
spring guys and well maybe you've read
their books the j2ee design and
development book and that book addressed
some well some issues in the Java or in
explaining the j2ee platform by that
time and those issues were valid and he
made some really good arguments and some
really strong points in order to get
them solved but they weren't really
picked up by this person by the tennis
commission that that took a while
took maybe six seven years or so but now
over the past couple of years the
standards are really on
with what you need today so Java EE
seems to be hot again so that might get
you interested into being here and
looking into how to get your spring
applications converted into Java EE
applications and we have actually a
valid business case for it as well but
we've come to that in a couple of spots
so why do you want to listen to us well
maybe just like you Paul I had like
endless discussions about which
frameworks and which tool stacks to use
and our discussions actually started
friendly with a couple of beers
something like that and then finally if
you started shouting and scratching each
other's cars right so you might
recognize that maybe from your own
experience and well actually we've been
building with all of all the stacks
right we've been doing j2ee applications
maybe in the early 2000s we've been
doing spring applications meanwhile and
the last couple of years we've been
building a lot of Java EE stuff so the
important thing to note here that we are
not working for any application server
vendor I mean there's currently 14
application servers certified out there
for Java EE 6 but we're not working for
any one of them and just to get it
straight we know actually no rod Johnson
group easier right but you might have
guessed that from my first line so why
do you want to migrate and this is a
valid question to ask I mean it might be
a religious thing right you might be a
spring hater or whatever I mean well
that's that's funny for talks and you
know over drinks but I don't think there
are much customers out there who will
just give you like blank check and say
ok well comfort on my open all my spring
application to Java EE here you go
all right so that's not a valid business
case so we have to find a business case
but a business case that we think that
might be really relevant is that you
would have been building spring
applications for the past swell 5 6 7
years maybe and you have built such an
application let's say five years ago and
it uses for example a number of outdated
s-- frameworks for example you chose
that framework that was really hot then
but today isn't really hot anymore in
fact it might be dead already
right so no longer supported or not
there might be no longer updates for
that particular framework same goes for
persistence well maybe you use some JDO
in the past or something or something
like that right not really a current
framework anymore
so you might have
some technical depth in those
applications right so you're facing some
serious issues in those applications
because all they have been running in
production for the past five years and
your boss wants them to run into product
to run in production for the next 10 15
years right so if you're facing
technical depth and and and and the
issues with those applications then you
are well that will require some work
anyway right so you have a number of
choices well upgrade to a newer version
of the Spring Framework and use some
newer frameworks on top of that or maybe
consider taking a little bit of an extra
step and going to the standard and the
standard is important because it will
guarantee you that your stack your
platform will be maintained for the next
5 10 15 maybe 20 years I mean Java has
come a long way 17 years there's there's
some deprecation in it maybe not enough
but it has been maintained over all
those years right so if you want your
application to go for another 10 15
years it might not be a bad idea to go
to its standard a standard did a lot of
vendors agreed upon a standard which is
available all around you in 14 available
application servers and a standard which
has some really different frameworks on
which you can go like send the
applications with so you are facing some
serious operator issues and now you're
facing your decision whether you just
want to stick with your spring stack
which well may be good in yours but in
your particular situation but if you
want to have a choice if you want if you
want to go the other way we will show
you in the next hour or 50 minutes we
will show you how to do that right and
then again let's not forget spring as a
proprietary technology right so it
started out as a great open source
initiative then came some vendor capital
always that along then there came some
commercial companies along and now after
a while it's in the hand of a company
called VMware and well don't know about
you but I don't really know VMware in
the Java world right but what are they
best known for it in in a java world
what's the biggest contribution the only
thing I can think of is being able to
run Windows on my Mac whatever I'm not
sure if that's that's a really great
thing right so so ok I use a lot of
words already but something that you
show little pictures to make them a
little bit more interesting so the
choice that you've made in the past and
only
the past five years or so they might
have been competitive in grades by that
time so there might have been good
decisions like five six seven years ago
but now after a while facing some
challenges facing some I may be sure to
add some new functionality to the
application as well you might need
something else right so you might need
some other features so just to get it
straight this is not my company car I
would really love it to be so I mean the
make is the same but that's where the
equation answer so before we dive into
the actual migration path let's get a
couple of misunderstandings out of the
way first
the first thing is this one as soon as
we start talking Java EE some people
will lady D they say okay well Java EE
wasn't it supposed to be you know fad
and you know little boilerplate and
heavyweight and slow all right that's
what most people remember it from right
so there's a number of people out there
that think that Java EE stands for Java
evil edition right yeah
and that might have been the case in the
past but it's no longer the case right
so now it's just the Enterprise Edition
and things have dramatically improved
and it was about time so if you take a
look at application server startup times
for example they used to be like 30
seconds right or if you had that tray or
WebLogic it will take you like 5-10
minutes just to start up your
application server and some of us are
probably still facing those sort of
times today right that those were
horrible so the complete container
architecture has been overhauled and
completely overhauled the complete
programming model has been overhauled so
it's now all based on lightweight Bojo
based programming and this reflects in
the startup times so for example he take
a JBoss application server and the
latest version that will just go startup
in about two seconds right so it's
blazing fast same thing goes for
GlassFish and some of the other
application servers just a couple of
seconds just to boot up the application
server if you compare that to a tomcat
spring stack it's not the same right and
then this is a basic and a tomcat spring
stack but as soon as you're building a
more interesting more complex
application you start stacking
frameworks on top of the tomcat spring
combination so actually you're building
your own application server with
your application and then the startup
time will just eventually grow right the
good thing about Java EE 6 is also that
you can keep your deployment artifacts
pretty much well really small I mean
because a lot is already contained
within the application server the only
thing you need is the code that is gonna
use those services so typical
applications may be just a couple of
hundred kilobytes right
so a couple of hundred kilobytes jar
file or wire file I'll just boot up
really quick in the application server
so here's one of our favorite quotes
it's from a JBoss guy and he says well
no we're in the Java EE spec does it say
that Java EE service should be
heavyweight and slow well some vendors
might have read that somewhere in the
spec like a couple years back but now
it's verified it's no longer the case to
make a heavyweight in slope location
surfer right so okay you think well
that's nice but you know when I build my
next application I just need to have
dependency injection right okay fair
enough
I mean dependency injection was really
popularized by the Spring Framework well
let me get it so it wasn't very
invention right so dependency injection
is something which is like a Batarang
which comes from the late 80s I believe
but it has been heavily popularized by
the implementation of the Spring
Framework and dependency injection is
actually a very good thing right if you
want to have a testable architecture you
just need a dependency injection if you
want to have a decoupled architecture
you need dependency injection so the
Java EE Eckford groups set together and
look at the number of dependency
injection frameworks out there and they
decide to come up with a new dependency
injection they standardize a new
dependency injection model so they did
not create their own but I just really
look at the things that were working in
your implementations and they came up
with a very powerful new model which is
called CDI which stands for contextual
dependency injection which is a really
powerful model because it does not only
do dependency injection but it also
takes care of handling the states which
and which is held in the context so it
injects something out of a session or it
injects something in your request all
right so it's not only dependency
injections also contextual dependency
injection and another good thing about
CDI is that it's made to be extensible
so if it's not in the basic
specification you are free to roll your
own extension in a standard way
that's exactly what we're gonna do when
we show you how to upgrade some of the
spring stuff to Java because you have a
lot of slides we will cover questions at
the end if you don't one okay so CDI is
very is a very nice addition to Java
section we're gonna use it a lot in our
migration approach so you say okay
that's nice so dependency injection can
be done what about AOP right because I
need to have ILP well the first
questions I want to ask to you is do you
really want that I mean ALP is something
that you can shoot yourself in the foot
with I mean if you end up getting your
code all a symmetric and unreal
I mean because you just add aspects all
over the place I mean I've seen some
horrible some horrible implementations
using AOP so actually what you want from
a opie is extra is what I would like to
call some lightweight AOP I mean a specs
aren't known are not bad if you use them
too much I mean it's like pepper right I
need a little bit of it if you use too
much pepper then that doesn't going to
be good right well for some people it is
but for most people it's not so spring
has something which is called spring AOP
which is what I would like to call a
lightweight version of AOP and so does
Java EE with interceptors in both the
EJB specification and also with CDI
interceptors right so we have that next
thing is
do I need heavy tooling I mean probably
some of us still having nightmares from
you know booting up WebSphere
application developer right so you came
in the morning in the office
you started your PC you started that's
application developer and then your PC
just got trampled upon for the next 30
minutes or so right so your PC would
probably feel like the white car and
Anita months of track there right so
after it was done booting up it wanted
to take a shower
right so do you still need those in
order to be able to run like a Egypt B
wizard no I don't I mean about every IDE
out there is able to produce artifacts
for Java EE because it's a POJO based
model so you don't need
much of the wizard you just need a
couple of annotations in order to get
things running right so you do not need
any heavyweight to and you can just pick
your favorite IDE whatever you like and
you can start building Java decode with
that so just to do to round this up we
create a little of a capabilities matrix
which compares some of the core features
of spring to those same features within
Java EE so it's not an extensive list so
it just gives you an idea of the most
important reasons for people to choose
for spring in the past oh there's the
counterpart in Java EE on the right hand
side of the slide so I think it's fair
to say that we cheated a little bit
because there's actually there's one
point where Java EE 6 does not feature
anything out of the box and this is the
case with integration testing so we
added a framework called our curly into
this slide and our quillian is something
which is started by JBoss it's a testing
framework for doing integration testing
in container integration testing is
really really nice if you have a look at
it you should definitely take a look at
it it's not limited to 2 to the JBoss
application server you can use it on all
application servers and it's a it's a
very good way it's a very good addition
to Java EE 6 in order to do integration
testing right so just use this metric as
a reference so apparently everything
that you want to do that you did which
spring in the past can now also be done
with Java EE so ok so here's our recipe
for migrating your spring application to
Java EE 6 alright and it's fun
especially if you can prevent it from on
a conference but I mean it's not very
realistic right so what we need is some
sort of a recipe that will take us there
step by step and I just well a couple of
slides back I talked about having a
business case in order to do so and I
think that's that's really important so
you must have a business case and in
order to do it so some of your business
cases will maybe not take you along our
migration path all the way right so you
might say ok well I can do a few of your
steps and you know improve my
application and then I you know I just
quit and then then it's fine for me
I mean I don't have the money or the
time or my boss won't allow me to do it
so we came up with a process that can be
followed up to like a number of steps
and if you really want to know if you
have the business case you can follow it
all along and do the entire conversion
so we'll show you how to do it step by
step so the victim here is our typical
spring application which is in this case
an old school spring applications of the
spring one or spring two application
which is in production for like a number
of years and typically such applications
feature lots of complex ml doesn't
feature any annotations yet probably it
has an older outdated or EMM solution so
maybe some JDO stuff or some code or
toplink or JDBC templates god forbid and
maybe you might have a deprecated
extension based web MVC web player on
top of it as well so that will give you
some problems to start off with and then
maybe well just after adding
functionality in functionally it's not
you to it oh you have another if some
more technical depth in your
architecture may be so this application
space is some steadiness some challenges
and it needs maintenance now so we're
going to show you how to convert an
application like that into a fully a
full-blown Java EE 6 application without
spring so in order to do so we came up
with a migration part of five steps and
this is the part where I hand over to
Paul and Paul is going to take you to a
migration bar alright so let's start
migrating so this is our five step well
program or the step by step program to
go migrate from spring to geography
and the first step might be a little bit
strange to some people because the first
step we're going to look at it upgrade
our spring version as we said this is a
step by step approach so we're not going
to just jump into an application server
and start writing geography coat and
just forget about spring it's just not
realistic and the first thing we're
going to do we're going to upgrade our
technology stack within spring and then
slowly we start moving towards Joffe so
the first thing I'm going to do is just
upgrade my spring version that should be
as as easy as just upgrade well the
spring version in your maven phone files
luckily backwards combat
in spring framework is in general pretty
good so even if you're using an old
version like too low or 2.5 or something
like that
I've grading to the 3.1 or whatever the
latest version is that should be pretty
easy
note that we're not changing any coach
yet for just upgrading the dependencies
just dropping in dropping in new jar
dependencies we're not changing any
coach yet and we're not changing any
configuration yet that's the next step
that it should take about five minutes
um next we're going to look at some old
frameworks that we are using within
spring and this is where the real pain
lies because this is actually our well
technical depth that they have been
building up for the past few years
let's take a look at a typical spring
application so we are from web layer and
in the web layer using well spring web
embassy but we're using the old style
spring web PVC the one that was
deprecated a few versions back there is
still the controller extension based the
web framework and it has been deprecated
and completely replaced in spring
framework by well a much better
annotation based programming model which
is better but well not really compatible
with the ultimo old model so we yeah I
should probably get rid of that because
spring is not going to support it
anymore so well who is there not at the
bottom we are using some kind of well we
are object or object relational mapping
framework like code oh who remembers
code Oh
it used to be long I feel for you I mean
the governor used to be one of their
like cool solutions six years ago but by
now everybody just forgot about it and I
don't thing is maintained anymore at all
and at least if you're looking at new
developers well they probably don't even
know what Kodo is and it is not just
about machine code is just about law all
kind of object relational mapping
solutions that are just well not
necessary anymore and people just start
to forget about them since we got JPA
people have been standardizing on jpn
that they roll
people like JPA and well the other
solutions which are nuts might move from
to JPA are just well they stop to exist
so we have to get rid of them because in
the future nobody will actually help us
building code or code anymore besides
that of course we even use some spring
beans that's just our dependency
injection that's where most of our
business logic probably lies and maybe
use some spring JDBC templates next to
our object or object relational mapping
framework maybe some JMS and some other
frameworks maybe so the real problem
here is not spring itself but the
frameworks around that it's not Springs
faults that Cotto is deprecated now and
Korra doesn't exist anymore it is
Springs faults that I deprecated as
premium cheaper for good reasons but I
mean you can't really blame spring for
it but this is something you have to
deal with in your spring application so
the first thing we're going to do is and
this is going to be a lot of work is the
majority of work we're just going to
replace in this case code oh by JPA and
luckily spring has excellent support for
JPI and a programming model is very
similar to JPA in a java application the
first thing we're going to do we're just
going to throw away or migrate slowly
away from code out to JPA and because
the same thing for spring rap MC near to
JSF you could use something else
depending on what what you need exactly
but we're just getting rid of those
deprecated frameworks while still using
spring and well that's nice spring
spring has support for most of the
geography specifications anyway so this
will work um you should note however
this is just an awful lot of work this
is painful
migrating from one framework to another
framework just painful it's a lot of
work as well if you have to go to the
future it's something you have to do and
no matter if you're what one stay in
spring world or going to the Yaqui world
for now we're not going to touch any
spring specific API yet besides of
course the API that we used to use the
other deprecated frameworks but our
application is still running in spring
it's still spring container we're not
even running in a geography container
yet this is just all spring
an updated version of the spring
application so this will probably be
most of the work the next step is that
we want to start writing some new codes
because well probably this migration
will take a number of weeks maybe months
even depending on your well your team
and the work you have to do on it and
while doing this migration which might
take a long time well the rest of your
team maybe and has to just add new
features to the application do some
maintenance on it and it would be a
waste to pee well keep on writing our
code in a way that we want to move away
from so we want to start writing the new
coating application in a geography model
so we want to start using the Jaffee
programming model besides things like
JPA etc but we also want to start using
CDI for example well there's a challenge
m2m to understand this challenge and
also to understand a solution you have
to look at our spring application
actually looks like if you're going to
deploy your spring application and it
pretty much looks like this yet your
service container and the server
container might be part of jothee
application server I've seen numbers of
customers that use a full-blown web for
web for instance just to run spring and
they just view surplice well that's
weird but that's that's what you see but
basically you just need servlets I mean
a surfer to just deploy your bar file
and it is well different from Joffe you
can use spring you basically package an
application server within your bar file
the application server is just part of
your application so what the spring guys
say well you don't need this happy
bloated application server involved sure
but they just packaged it in a war file
which is to me exactly the same thing
just different place to put it so we
have a transaction manager we have a
opie support we have dependency
injection support we have JMS report and
etc etc etc all packaged in our
application next to the code we actually
write our shop well this is not really a
problem this is not really bad it gives
some flexibility in deployments if
you're not not both you're not very
flexible yourself it's dealing with
application servers but this is the
model spring users if you look up at the
Jaffe application
it actually looks very similar the only
difference is is that our codes
that's what he packs in a war file and
the rest of the stuff all the container
service services like the transaction
manager security support interceptors or
AOP whatever you want to call it
JP a support and all that kind of good
stuff is already in application server
because we're not just using a servlet
container but we're using all those ERP
API is building into the application
server instead of packaging packaging it
in the end of our file I prefer this
model because my VAR file gets a lot
smaller and deployment start to be
faster and if I have two different bar
files well I don't have to duplicate all
those spring dependencies in both bar
files to get lost loading rights well
it's already in application server so
yeah that's shared shared already so
deployments are smaller and faster what
we're going to do now it's just a
temporary that temporary approach so
what we're going to do I say well we
want to have our spring code because
we're not ready yet to throw away spring
but they also want to have some java
code that's the new code I'm writing and
I'm going to well let them live together
and to do so you're going to deploy the
spring framework within our application
server there's actually not very strange
because what I just said I've seen
numbers of customers who actually use a
full-blown WebSphere WebLogic so for
instance just running Serpas it still
does make sense but in this case it's
good we can we can actually use that so
we start using our ETB container a CDI
container in application server and in
our bar code is throughout the spring
container this is not an ideal model
because we have well two different
transaction managers and well they don't
really know about each other so they
don't play well at together we might
have two different AFP solutions we have
two Jaffee interceptors and we have
Asperger or something in spring so this
is not ideal but well it's migration
so what does what does this actually
give us this is still the same
application I didn't actually change
anything yet but I want to add some new
code now and this new code I'm going to
write using Egbe and CDI and all that
well new Java 6 stuff but I still want
to use and leverage my existing job
might make sexting sprinkles so for
example I write some new JSF code using
CDI beans but I still want to use my
existing spring the IPC templates
because I'm just not ready to throw them
away and well redo that in JPA for
example though we will discuss it later
on but at this point I just want to
reuse my existing spring codes
maybe my data access objects from my jar
vehicles well let's get to one more
concrete example let's say we have this
spring JDBC template no this is all
modern spring just to keep a little bit
more concise but doesn't really matter
how you would write it so we have some
gel you see template and we go to the
database here of course I need some
configuration here and a configuration
here is the problem because we can't
just say well I'm going to deal with
this book JDBC de they text object like
it would be a junkie object now without
this configuration it doesn't really do
anything it doesn't work so we have to
keep using this stuff including the
configuration including the spring
container so I'm not going to touch this
code this is my new code
this is JSF been just as an example and
I just want inject using CDI
million books JDBC the day text object
and from this new code I don't care if
that data access object is actually
spring bean or a judge 36 component like
an eg be I don't want to know I want
decoupling here I don't care about
implementation details of my data access
object this is just plain Java EE 6 but
how is that going to work because
somehow I have to start well working
together with a spring container get a
reference of my book JDBC that detects
objects from spring
diner and start well working without
using dependency injection in Java EE 6
am I going to use CDI for that and we do
need some trickery here but it's well
based on on the CDI standard and it's
actually just the CDI extension they are
going to write the CDI extension that
get activated when the container starts
and we actually going to bootstrap the
spring container like you would normally
do when you start your wire following
your servlet container so the bootstrap
the spring container and then we're
going I'm going to ask the sprinkle de
novo give me all the beans that you have
and I will well republish them as CDI
beans so that the CDI container actually
contains references to spring beans um
that sounds way more difficult than a
list because this is all the code you
would need for it and actually you don't
even have to students actually use these
codes because this is some just some
something to make you understand what's
happening but the JBoss guys are working
on the same project which is now Delta
spike and they're actually doing this in
a much better way so you can just do
this completely by the by configuration
now but just make you understand what's
happening here and this is CDI extension
and what what we wait for here is well
we're going to wait until the container
starts whenever the container starts I'm
going to instantiate my spring a
container like you would normally do for
example from from your web dot XML and
I'm going to instantiate it using a
configuration file application context
to the XML then when the spring of
tenerife started I'm going to look at
all the beans at s in this case I'm just
going to look for one specific thing but
it's just a simple example and I'm going
to republish this bean which is just a
spring bean I'm going to republish it in
a CDI context so that that the CDI
contact actually knows about this
reference but whenever I inject it so we
are I'd like to go to the spring
container and ask spring contain of all
give me that been including all your
configuration and that would
okay
so now we have a way to both write Java
codes and sprinkles next to each other
but in the end we what we wanted to get
rid of spring because we said well we
came this way this far we got rid of all
those those deprecated frameworks they
even started writing some new Java code
and I don't really have that much spring
code anymore so why not just get rid of
it and start well being based on
standards only instead of some
proprietary proprietary framework so the
next step is and this can also just cost
time this is not something you have to
do in an afternoon we just replace all
the components by GRT components because
well like dirty or already everything
you can do in spring you can also do in
geography well hold on what about spring
JDBC templates there's not really a
solution Joffe for until you see
templates which is probably good because
jealousy templates suck but well if you
have a lot of codes using daily BC
templates it might be painful or at
least time consuming to migrate to some
other solution I'm going to get back to
that I have two different solutions for
that but let's forget forget about as
per second let's look at some other
issues you might run into but we see
seeing a practice is that the hardest
part of the migration here it's probably
the transactional layer so migrating
away from spring-based
transactional bins to e gb which is the
javac' equivalent of that that's where
people run into into issues and actually
it's pretty easy so I'm going to show
you something so we're going to migrate
away all those transactional spring
beans to well basically jeebies and that
well each bees are using the transaction
manager already insulting application
services we don't need corporation for
that and the other nice thing about
ECB's is that it has very strong JPA
support
oh wait wait hold on EDB seriously
wearing those that evil things that's
war well we're difficult to configure
and took like two days to well either
set up or never get working well no
they're not a lot of things has changed
if you look at the rpe right now at the
RPE six they're just pojos pojos with a
few annotations those annotations give
you a lot of container container
services not so different from Spring
beam spring Venus also just suppose
you're with some annotations on it or
XML giving you some container services
so let's get to an example again this is
spring beam once again it's a spring
beam modern spring using annotations but
it would be the same just a lot more
codes for cell spring there is a
transactional spring beam spring also
has support for JPA and we already
started using JPI so probably using ad
processors context entitymanager
and well our transactions are started
and committed or rolled back
automatically the code looks pretty good
I like this programming model but I
don't like about spring is that I need a
bunch of XML configuration that sets up
transaction manager sets of my JPA
implementation I hooked everything
together and well people get is wrong if
you don't do this exact exactly right
for your application server with your
implementation of an API implementation
small things go wrong things that are
fair a hard to debug and very hard to
will get rid of so I don't really like
that let's look at an eg be example
that's it
programming model looks very very
similar there's even less configuration
in code because role by default you're
already transactional because we are an
eg B so that's easier protection
management works the same transaction
gets started whenever I call the list
books method then gets committed if
there's no exceptions at the end the
method method I have my JPI integration
and no just works I don't see any
external configuration you know what
that's because we use an application
server
a JPA and protection manager is already
working I don't have to do anything for
that I don't need to set it up myself
and it come get it wrong that was
actually a lot easier um okay so let's
them that the basic cages of course but
what about dealing with lazy loading if
you look at the spring forums especially
a few years back people are complaining
there to the spring guys well I'm using
spring and I'm using hibernate and it
breaks because as soon as I well I I
start rendering my few I want to do some
lazy loading on my my entities and it
breaks and it tells me something like
places context closed-door session close
or something like that and um well
that's something difficult to deal with
well the solution they have and on the
spring side of solution entitymanager a
few pattern or if you use hibernate
specifically they call it the open
session in fuel pattern and probably if
you if you're creating a web application
in spring you're using that how do you
do that any jeebies well in which we
have the absolution for that too so
let's first look at the problem and in
this case we have an Annie GB and it HP
is referenced directly from a JSF being
I'm not saying you should but just to
keep the example simple so code example
at the bottom it's just just a JSF
example but it could be well show more
technology does really matter and the
problem here is that I have my book
which is an entity and the book has
multiple authors and by default multiple
authors will be well Delpit lazily
so if I ask JP I Evo gave me a book it
will not automatically automatically
join the authors with it because that's
all they are you just get too much data
for me but because as soon as you start
rendering here
well I'm outside of my transaction and
and I'm outside of my outside of my
entity manager it would throw a lazy
initialization exception what tell me
what I can't do lazy loading anymore
because there's no transaction and
there's no entity manager anyone so I
just give up and break
how do we deal with us we can do with
that completely automatic like you would
do in an obsession you feel better by
making it an stateful session be instead
of Stabler's session bean but the stage
is only bound to the request so it's
very short
well state full state and on the
precious context configuration we say
what is an extended Precision's context
which means the transaction is still
going to be ended at the end of the get
books method so when I call the I get
books method it was still and my
transaction automatically but when a
transaction is ended I'm not going to
throw away my entity manager that's
default behavior of a stateless session
bean throws away the entity manager who
the transaction is committed
well for an extended context we just
keep the empty manager open em that's it
they are our opposition if you pattern
I'm not saying this is the best solution
to deal with lazy loading but it's at
least the easier solution to deal with
lazy loading of course if you want to
have more performance should actually
write write your own joint queries but
well it's not always convenient and we
can even solve another problem with this
if you look at spring every time a
request is rendered well we have to well
at some point close to entity manager
which means all my entities are going to
be detached so let's take the scenario
that we have from a screen that we show
something to the user some data to the
user the user edits something on the
screen and then submit submitted back to
the server and expect it to be saved in
the database first pretty typical spring
application we would have to call first
loads the entity and then when a user
saves it again we have to first merge
the entity before we can save it you
have to attach it to an entity manager
again well that's just one method
college you could say so what's the big
deal oh yeah it's one method call but if
you have for complicated graphically
relationships it's kind of tricky it's
really not easy to do merging you can
get a lot of tricky problems with that
so why not just avoid
altogether that we could take them
stateful approach a little bit further
it would say well this is not the
request sculpt stateful session bean
there's a conversation sculpt session
bin and we're going to say that by
default we're not going to start and
commit transactions
I'm only going to deal with protections
when I tell the containers to do so so
what happens here
um I start a conversation here and the
conversation is something that's about
smaller than a session in a web
application and I can have multiple of
them but they are multi requests what
happens here I load an accounts from the
database using the API and that's the
end of the first request I just show to
the user show it on the screen user is
going through some interaction but the
important thing here is that is not
going to be detached my business context
is going to hang around there until it
the the conversation is ended so I never
have to do any merging and even when I
go to the finish maybe after running
through a whole visit without ever
merging I just say well now I want to go
back to the database
I started from section again by
specifying that I want have a fight fine
during the transaction required I end
the conversation the absence context is
going to be closed and everything is
going to be well I've saved back to the
database but I don't have to do with
merging because I was never detached and
in complex scenarios this is much much
easier the other nice thing about this I
have less database run trips because I
don't have to do transactions all the
time to do well things that I actually
don't want to do okay so we can do with
the API that's easy but what about those
JDBC templates well the first advice
with one of the give you is well just
get rid of them they're just not not a
right abstraction on top of your
database you tie yeah very hard to your
database you're writing a sequel and
you're in your java code you have to do
object relational mapping yourself which
is a lot of work you have to deal with
all things like relationships
in your object mapping it's kind of a
lot of work um but still there are some
some pellet cases you might say for
doing this kind of stuff if you have
very well thumb stand specific queries
maybe using specific database features
that are not compatible with API anyway
or maybe just have a whole bunch of
codes that you have no idea how to
migrate that's possible because those
things tend to get very well difficult
and hard to understand so if you decided
not to throw away those JDBC templates
and stay there maybe we could use them
from Joffe and actually we can so what
we're going to do what we are going to
do is use use the jealousy templates
which is just a spring API and we're
going to use them within Joffe this does
of course mean that we are we are
pulling some spring dependencies in a
java application but it's just about the
api's we are not going to boot up a
spring container because and JDBC
templates just don't need a spring
container the nice thing about jealousy
templates is that well you actually just
need a datasource to construct a
jealousy templates you don't need a
spring container for anything else so
let's do that using some CGI magic the
top right code example is a CDI producer
but what we are doing here is we are
injecting a data source using the
genuine name this is very similar like
how you would well inject data source
and spring and the data sources itself
is not a spring classes just well the
JDBC volatility I'm not sure I think
it's same JDBC then we have to produce a
sanitation and whenever we inject
something from CDI CD I'll actually go
look at produces methods and save all
SRA met producer methods that can
produce some kind of instance of this
type and they are we're just going to
create a new instance of simple jealousy
templates using the injector datasource
and that's all we need to create a
simple jealousy template and it's
actually very similar
what you would do in spring application
the bottom code example is just some
Java code it's just shown well maybe
need to be or there's some CDI bean we
just inject a simple daily PC template
which is of course spring API you start
using it like the woods from from spring
and this way we can well use this stuff
within our spring applique the fee
application nice so here are our
jealousy templates well then in the end
we don't have any spring code anymore
which is good and then we can get rid of
spring altogether we don't need to start
up the spring container anymore so we
can't get rid of the other configuration
files and we also don't need all those
well jar files anymore and it is nice
because if you look at a typical spring
application they have like 40 50 60
dependencies defined in methanol kind of
frameworks and all kind of spring api's
and if you look at a typical deployment
a typical bar power for example they're
easily like 50 50 megabytes or even
larger because you have to package all
your frameworks in your in your bar
phone we're just going to replace them
by one they're just going to replace
them by well the the API from Joffe and
as you can see the Scopes provide us we
have to use them during build time
during compilation we are just using AP
ice not implementations
implementations implementations and
they're already an application server so
we yeah get first more waterfalls then
there's one more thing and this you
should probably not do this at the end
but just makes more sense for this talk
um what about testing geography pretty
much used to suck at testing because how
are you going to test need to be for
example and spring on the other end was
pretty good at that we can do some valve
say in container tests in spring and you
give an example how would you test this
code this needs to be do some
transactions is doing some JPA of course
you could ride the unit test for this
and for a real unit test you could say
well I'm going to mock out manatee
manager yeah great and what are we
testing exactly that we can call a mock
object correctly that doesn't make any
sense the only thing interesting in this
code is the query itself because that's
the thing that I'm going to mess up and
that's the thing I want to test the only
way to test that is using a real
database using a real application server
tower can also test my transaction
management and stuff like that so we do
need to deploy something to a real
application server and for that we're
going to use achillion akin is a tool
created by JBoss it's not part of the Rd
specification but it doesn't have to be
because just - and what were you doing
in inner Killian it's great micro
deployments so instead of packaging up
our whole application application in a
var file and deploy that and then run
some tests like well probably the thing
you would do in the past we are just
going to deploy a few classes with a few
configuration files deploy that it just
like takes a second or well probably
less actually and am I going to run our
tests in the application server like
just part of our production cuts let's
take an example this arquillian well
this is a test in our trillion so
basically there's just j units the only
difference is we annotated that
arquillian at the top i'm so that
actually you can actually control the
lifecycle the next thing we have to do
in actually in is the final deployment
methods and a deployment method
well actually defines what I'm going to
deploy for this test to the application
server and it's just a few classes in
this case is just my single entity
MSA single data access object but I also
want to use CDI and I also want to use
precision Val jph I'm going to deploy a
bin selection optional XML and that's my
deployments it's almost nothing what's
going to happen if I start a test using
a kellian it's actually going to package
this up in well depending on on what
application server you're using but it
might be a real war or jar file it's
going to deploy that automatically and
because the deployment is so small it
just takes well microseconds
deployed and our test case itself so
this class will also be part of the
deployment so our test is going to be
deployed in the application server and
because of that the we can start use
using CDI to use at inject it's actually
well get reference to our data access
objects which might be an eg be Emma
Casas need GP and is running in the real
application server we have our
transaction management and our data
short with our real database and
everything just works like in production
but we can of course just write our
asserts just basic unit testing but this
runs in the container hope that's
exactly the model we need and this makes
it very very easy to do integration
testing so he used yaffe well take a
look at our Killian by the way they are
sleeping on plugin or integration for
for spring at the moment so even if
you're using spring you should still
take a look at the Karelian problem ok
thank you Beth okay there's a couple of
minutes left to do wrap up so the
important question to ask is none of you
that you've seen the way to migrate your
spring application to Java 6 is if it's
all worth it right so actually all right
so you know where this is going so like
I said in the beginning of the
presentation of course we can do this
for fun and being an avid like a very
religious discussion about which
framework is better but I think there
are some real business cases out there
where this can be applied and in fact
we've done had a number of times so the
question if you want to do it is oh it
all depends on your situation so do you
have enough pain in your current
application that you are facing series
upgrade and if you have to put in a lot
of work anyway why not take the extra
steps and bring it to the standard right
so in my case I say well you want to
stay in blissful ignorance or do you
want to face a painful truth of reality
right so it's about taking the blue or
the red pill it's always the case in
life so the other interesting thing is
if you migrate it away from spring and
you've migrated all your applications
away from spring so is there still a
live
after spring or so to just die or is it
still interesting that we have the
spring guys around so I think it's
really important that everybody
understands the difference between
innovation and standardization
I think Java EE clearly is the product
of standardization so it's it's like a
process of vendor sitting together
looking at different implementations and
coming up with a standard implementation
to solve today's problems right and so
for a whole number of things that you
need to be able to solve today's
problems the standard is excellent but
then of course there's also some
customer assignments where we need to
have actually we need tomorrow
technology in order to be able to solve
those problems so there should be
another process where we innovate right
and innovation is really important
because it's it's trying to make
implementations for ideas of how to
solve all the problems of tomorrow
essentially or maybe the for today so
open-source has played an enormously
important role in that over the past 10
15 years or so so I mean that shouldn't
go away I believe it was a quote by Adam
Bean who said premature standardization
is the root of all evil right so if you
take a look at entity beans for example
you know exactly what I mean
right if you put things the in the
standard too early and you haven't
really thought about the impacts of your
standards then well things will get
really messed up and it will take well
10 15 years because before they can be
pruned out of the standards right so do
not mix up innovation with civilization
so we need the spring guys around we
need actually I think we need their R&amp;amp;D
dollars just like we need Jay bosses and
reds or IBM's and Oracle's I mean R&amp;amp;D
dollars in order to do innovation and
then as soon as idea is starting to be
picked up and starting to fly they
should go to the JCP forum an expert
group and try to standardize upon those
different implementation take the
Batchelor implementation and take the
best for implementation B and then put
it into the Java EE platform in a future
version of the Japanese platform so it's
really important that we should not mix
up innovation standardization the spring
guys have played an important role and I
they should be doing so in in in the
near future but I encourage them to go
to the GP some more right so in an hour
you can just cover just well not
everything that you want to talk about
migration so there is more if you're
interested in migrating Paul and I have
been writing up a very extensive and
elaborate article series it's a four
part article series in which we
completely migrated an existing
application from spring to Java EE so we
took the spring pad clinic application
the demo application from spring and we
completely migrated it from spring to
Java EE 6 just to show you how it's done
so if you're interested in looking at
that the article series published by
JBoss on the website called how to JBoss
comm so go to that side just search for
spring to Java EE migration and you find
the article series so there's a lot of
background reading in there as well and
it comes along with a link to a github
with a link to a github repository where
you can find all the codes and all the
steps for performing the migration so
you can see some actual examples of how
it's how it's being done so if you have
any questions then please feel free to
reach out to us we are both pretty
active on Twitter and we also I will
also show you our email addresses in a
bit so please send us your questions and
I think we have like a couple of minutes
left maybe four five minutes left so we
can open up for questions anybody have a
question
so the question is can you also use CDI
in Java SE yes so the reference
implementation of CDI is wealth and
world can be bootstraps in a in a Java
at the environment so you can also use
CD ing up as weakness so to add to that
in Java EE 7 it will be standardized to
run in in se so CDI will be running in
SE standardized in Jack the g7 and you
can already do it now sorry well I can't
repeat it the question is is there an
alternative for at configuration in
spring not in a standard but there is in
some I see di extensions and so if you
look at I think it's now in Delta spike
but you doubt the spike you can well use
it's based on CDR yeah
yeah this is right and it really depends
on what you did wall in spring so it's
hard to say well it's it's easy and and
just do it and it really strongly
depends and some applications might be
very difficult it might well be better
off looking as an alternative for JSF
something that I'm doing myself a lot on
a moment is just using Jack's arrest
Jack's arrest web services on and
together it with html5 JavaScript user
interface they're different sort of
question is how do you set up test data
if you use arquillian so there are
different answers to that one of the
most easy ways is to use an e GP that's
a start up set start up singleton beam
that gets started automatically when you
deploy something I use that myself lots
for this kind of purpose
there's also integration anarkali and
for DB units so you could be using that
well if if you're not going to get it
any time soon soon I'm not so sure you
should be migrating because that will
always be like a lot of trouble if
you're not going to be on the full stack
it is possible you can bootstrap most of
the frameworks like CDI and using welts
or JPA etc in a circuit container but
it's never going to be ideal and if
you're well facing this problem and
you're going to be sure that that is
going to be problem for a long time
wouldn't these are sure you should
migrate to add to that I think the true
power of Java is only Unleashed if you
use all of the api's together I mean if
you can use jcd ie to be together that's
where the true power of Java EE lines so
if you can just have like a partial
implementation of that I think then you
should consider not to migrate
okay so the other thing is well Joey
your secrets of standard which was
published in I mean 2009 so if you're
still on the if I mean it's the same
thing well soon know always shout it
from the from the stage well our peoples
still on Java a 1.4 right it's a weather
thing it's it's I think it's about time
that we address the fact that you know
being on jj2 e 1.4 word Java EE 5 then
you're really really outdated for
building enterprise applications that
you bet your business on it's about time
to upgrade and I mean those application
servers have been around for three years
now the actually none of them are still
a diversion so most of them also haven't
had a great releases so I think it's
about time to migrate to a full staff
generally server if you want to go there
right well I think it depends on the
under case actually but that's it I I
know from my own experience that it can
be a tough discussion I think the
recommended version is to grant on JDK 6
but it also runs with JDK 7
you want an honest answer to them okay
so the honest answer is that I didn't
like spring from the beginning because
of all the HTML configuration so I
really just hate XML that's that's just
one reason and then the other reason is
that I saw and I saw the use case of
spring for a lot of customers and then
the the architect in charge of the
project just use spring as an excuse to
drag about every framework in the
application that was out there so I've
seen a lot of very bad implementations
not because of spring but just well they
use spring as like an excuse to open up
the application server and get about
every framework in that that was out
there and that led to horrible
dependency management problems and stuff
like that right so those were two
reasons for me not not not to really
like spring so I wasn't really promoting
writing spring our applications and then
the other thing is and I mean just
that's something for me as well I've
seen a lot of presentations from spring
guys where they were just bashing
bashing the hell out of Java EE and j2ee
and I think it's good if you want to
have changed but if you do not work with
the effort with the expert groups in
order to bring change I mean then well
some reason somebody has to say well
well maybe wake up people there's also
the other way around and so well we woke
up some of this and we decided we're
gonna do a presentation like this just
to you know get the message out there
that is not only just a way of bashing
Java EE but there's also the other way
around
now that Java EE finally is on par with
most of the spring stuff so that's that
that's yawns and
sure yeah without them I think it's a
fight I think it's it's important that
we have like a standard which you can
really build some of the like 80 90
north your application with and then you
need innovation in order to be able to
address the most problems but I would
wish that all of the DDD innovation that
is going on is eventually being brought
back to the specification okay thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>