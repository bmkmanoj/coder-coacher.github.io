<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Meet the Java Language Team | Coder Coacher - Coaching Coders</title><meta content="Meet the Java Language Team - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Meet the Java Language Team</b></h2><h5 class="post__date">2013-02-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/R06AgsUF3I4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Michelle Trudeau I work in
the Java language team as the manager I
have a few members of the team as with
me as well we have this bath too for you
to ask questions about what we're doing
for the future of Java and etc so you
want to introduce yourself hello so my
name is Alex Buckley I'm the spec lead
for the Java language and vm in java SE
8 i'm the the specific features i'm
working on i'm the co spec lead for jsr
308 annotations on types and I work with
Joel Frank who is hiding over there so
he knows he's really in the language
tools team as well so we're working on
various features to do with metadata so
annotations and parameters and sort of
things which will be useful to you once
you see them but they're not as exciting
perhaps as some other features that
people are working on fressy aids hi my
name is Joe Darcy I worked on punch a
coin in jdk 7 and I'm also working part
time on the annotation features of jade
gate I'm Brian gets some java language
architect and for the last two years
I've been working on project lambda
which is almost done yay so without any
further ado questions we don't have any
slides yeah time yes yes we're going to
repeat the question because there are no
there's no mic for the audience so
justin is loud but so what's happening
with annotations so in se8 there are two
things which interact which means there
are three things so so I'm in 23 so
there's jsr 308 annotations on Java type
so as we all know in Java a c5 you could
annotate declarations class declarations
method declarations field and other
variable declarations etc and so it
turns out to be useful to be able to
place annotations on type names in
various locations for example if you
have a variable of type list of string
it might be useful to declare this
variable is an effective type list of
non null string
and there is a lot of research work that
goes into the definition of non null and
these pluggable type systems to express
null ability or immutability concurrency
properties etc but the first step in
allowing a Java program to express those
properties is to allow and we think
annotations of the right way to express
those properties most of the time you
have to be able to express those
properties through annotations on on the
types that occur in all possible
declarations rather than the
declarations themselves so jessa 308 has
been working on that for a few years
changing the language grammar class file
reflection APN etc and then there's
another feature which is a sort of
playing catch-up with with what should
have frankly been in the language in an
se5 which is just that simply you cannot
have multiple annotations of the same
type in a given location you cannot
write at foo at foo on a declaration
it's it just wasn't allowed so we're
removing that restriction but in
removing that restriction we're having
to preserve compatibility with the way
that the Java EE guys have been handling
annotations multiple annotations since
2004 for things I jpa and then so you
have type annotations you have repeating
annotations than these things interact
so you can have repeating type
annotations and this is really all about
squaring off sort of rounding off the
corners of the language so that it's
more consistent and annotations are more
useful for whatever the domain that
you're using annotations for is and if
you're interested in hearing more about
those topics there's a talk by Michael
Ernst the co speculative sr3 regulator
in the conference I believe that Simon's
they sovanna dietl please stand up
verner is also a jess r 308 type
annotations experts and implementation
lead is it ten o'clock tomorrow 11
building your own type system for fun
and profit
and apparently we have a related
question because you look you cited
about this so so the question is what is
the future for Jess are 305 Jess are
three or five it's I can't remember the
title of it but it was jsr that bill
Pugh started a few years ago actually
around the same time as jess are 308 to
define standard annotation types and
their meanings in the language non-null
nullable read-only immutable etc I
believe it is true that jsr is currently
dormant the expert group is not working
on it that has been true for some time
the and Jace are 308 annotations on
types is explicitly charted not to
declare the standard types they were
very much it was a strawberry strongly
partitioned world when these two Jess
ours were set up so do not look for at
nullable guarded by at read-only in in
se8 as to whether those annotation types
get standardized in the future maybe
brian Joo want to talk about pluggable
typing and things like that so you know
one of the things that we like about the
approach to jsr 308 is that it makes a
very clean separation between the
language changes and the kinds of things
people would want to do with annotations
and so most of the interesting stuff
that is related to 308 is actually
outside the JDK s the checkers framework
which is an open source project where
they've implemented a number of
interesting potential type systems no
ability taint checking you know things
like that and it's a very nice
laboratory for you know people can go
and create their own pluggable type
systems for checking various aspects of
their program you know some of which
might be interesting enough that we
would want to bring it into the language
and so it's an opportunity for people to
experiment with things that could be
eventually part of the language in the
wild to get experience with what's the
right way to do this and such and
and potentially we might bring some of
those in in the future as as as features
of the language some of the parts of the
Java language that have been relatively
difficult to evolve over time like the
definitive the unassigned and definitely
assigned analyses are in the sorts of
analyses you might want to explore
variants of outside the language before
you standardize them so I think it'll be
an interesting time when the framework
for these sorts of analyses is put into
the platform and people can experiment
more with these analyses before their
standardized as part of the platform and
and you know some of these analyses
might never become part of the platform
but might be incredibly useful
internally within an organization to
represent you know programmatic and
variants and things like that so I think
it's something that has a lot of runway
for people to do interesting things with
make you know Bend Bend their version of
the jaw language to solve you know their
problem better
Michael's forgotten this question
so the question is what about method
literals and annotations so in Java 8
we're introducing a method reference
syntax is part of lambda and so it's a
natural question to say could we take
this concept and extend it to reflect
reflective method literals method
literals and field literals and then
it's only a short hop from there to
saying could we represent you know could
we use these as values constant values
that would be permitted in an imitation
so this is actually a question that
comes up in number of times you know in
the course of lambda we spent a lot of
effort making sure that that was
possible because we might want to do
that in the future we're not doing that
now but we made sure that the decisions
that we were making now a bad method
references would be consistent with
several possible futures that might
support reflection method literals of
both you know within code and
potentially within annotations so it's
something that is possible for the
future we've done some of the groundwork
but is not going to be coming with
method references in Java 8
I heard about union ties into section
title
and since there is already sort of very
small support in areas like multiple
and type underneath
greater I was wondering if there is any
I any plans or ideas can spot that make
it
system
so one of one of the members of our of
our team who's not here today actually
the subject of his PhD thesis was adding
Union intersection types to the Java
type system so there's actually been
quite a lot of research in the academic
community on the feasibility of this
it's something that turns out to be
feasible but it introduces a lot of
complexity for the user to reason about
and so it's unlikely that we would be
introducing intersection types or union
types as first class types we've we have
compromised in a few areas where you
know multi catch is an example where we
have a union type there might be a few
other places where it would show up but
it is unlikely that it would be worth it
will be a worthwhile trade off to expose
full-blown union and intersection types
and one of the reasons is that this
starts to interfere with a lot of other
things that the complexity starts to
infect other aspects of the language so
there was a number there was a lot of
some research in Oracle labs on the
language fortress I'm not sure if you're
familiar with it but what they one of
the things that they discovered was that
having explicit union types causes all
manner of other problems to show up in
type inference and so the incremental
benefit that you would get would show up
as a penalty somewhere else and that
didn't seem fair to do to people
Cylon
I think they're having a lot of fun
hacking I'm not sure there's a
theoretical basis underneath whether
what they're doing but you know all
power to them and have fun with the guys
rotations
annotations can only be an hour
the class declaration will then I'd
change so I can inherit annotations on
technology
so the question was regarding annotation
inheritance so currently annotations are
only inherited along the superclass
chain not along the super interface
chain and not on over in methods so we
don't currently have plans to change
that one of the reasons the jsr 175
expert group who defined annotations to
find it only long the superclass chain
was to avoid having to define many
interactions you would otherwise have to
define what happens if you have
conflicting annotations in a diamond
pattern especially at the time if you
have only single annotation what happens
if you have conflicting ones from
multiple sources and they just kind of
punted problem we feel though that with
other work we're supporting such as job
x line model back bike or reflection
which our colleague joel will be talking
about later this week amongst some other
annotation changes that this would
potentially provide a way for other
parties to have their own semantics for
something like annotation inheritance
that they could write their themselves
on top of the platform and they could
maintain you themselves and they would
have to talk to us and it would be a way
to get a fact of that sort of thing when
we talk to our EE colleagues they often
don't use annotation inheritance because
it doesn't have the semantics they want
so the containers and other generalized
annotation processors do that sort of
thing informally and we expect that to
continue the case
other question
I thought you had the best
but I don't know yes so Brian mentioned
yes the sobriety Brian mentions so p.m.
yes like a microphone water
with type annotations and
second live outside
yes LOL explain it's two separate things
one is just the syntactic extension
which will be contacted to communicate
and ejector pin work is the tool change
filling up our
chain
Sun comes up
hey guys
some pieces
so just to repeat part of the question
the observation was the checkers
framework depends on some combat
sunglasses that are pay in this case
there's no back when we were doing at
jsr 269 for annotation processing that
includes several language models in it
one is to model the declaration
structure from the type declaration up
to the method or constructor boundary
there's another set of hierarchies which
models the types themselves separate
from the declarations the missing third
piece is a abstract syntax tree API we
chose not to standardize that as part of
269 for a few reasons one for it was it
was impractical for both Java Sea and
Eclipse to agree to a mutually
satisfactory a low-level API for that
purpose so there is no standardized
abstract syntax tree API across
compilers for that reason we have a
common source API this part of the API
the JDK but not of java SE so it evolved
under more or less the same rules that
we evolved java SE AAP is in the jdk but
it is not itself standardized as part of
the JCP and eclipse has a similar API
that is you know as the cooling
functionality so check our framework
will not work
so much so so question is that heard
about including the support for you know
things like vector simdi instructions
hmm and and and and how are we going to
have access to that so I I think there's
a couple things going on there there
there are a number of vm optimizations
that are strictly just you know compiler
cogeneration optimizations of the forum
if this processor supports this you know
this instruction then generate code for
it I separately there's project sumatra
which i think is what you may be
referring to which is an open jdk
project that was just recently formed
sponsored by prime that was originally
proposed by gary frosted AMD which is
about exploring the possibility of
generating GPU code as a form the JVM so
this is something that's in the very
very early stages and you know is aimed
at addressing the question of to what
degree is it practical for the you know
to just let the vm figure out when it's
when it's sensible to move a problem to
the GPU are you know for COD to be
solved as opposed to solving on the cpu
or decomposing it you know across
multiple cores etc so that's just
getting started you know it's going to
be a long time before you know stuff
like that goes into the product but you
know we're starting to look at that
bringing some
designed by contract in Java is anybody
still discussing it I don't think we are
discussing it as a matter of fact
amongst ourselves right now they want
still want it okay straw poll who knows
what does i love that lovely billet we
do the drill pulse just like that who
knows what design by contract is roughly
okay who has used it in other languages
obviously say Eiffel Oh some hands even
who misses it of the people who got
their hands up who misses it okay Furner
doesn't you know we never were here we
have made a video yeah some people so
yes for a long time support design by
contract was the number one java
language are fe supporting our
preconditions and postconditions and
various people had quite strong opinions
on it you know how do you have can you
really enforce object in variance and
the presence of multi-threading if you
can't guarantee that everyone
synchronized it's not i don't think i'm
giving anything away if i say it's not
actively being worked on though i think
you could you could profitably use to
check a framework to simulate a lot of
it this is the same thing
take a friend
for example if you have
so when it's quite an enormous
configuration and that just comes out of
the box today for analytic and reporting
workloads we're having were closed when
we achieve in athlete is 100 gigabytes
per second of properly we have the radio
running right now I don't know if you go
back just a few years that's what it's
required ten gigantic storage arrays
sounds very distracting yes on a house
because it's not even coming through the
way lien man yeah so Michael is saying
in order to enforce the invariants you
will need runtime need to generate code
at runtime so you know throw the illegal
argument exception because the
precondition is being broken that's true
though I think the Cheka framework
ultimately reduces to annotation
processors which can if they're the
right super low level of the compiler do
that kind of thing but to be honest it
like I say it's not it's not something
that's in Java Yates I don't know if we
can say after that yes that no one is
written a jdk enhancement proposal for
the language and language extension for
design by contract
to the fortress Tyler so so fortress
didn't have designed by contract
facility but it had a very powerful type
system that let let you make assertions
about things in the type system and so a
lot of the things that one might have
done through design by contract were
expressed as rules in the type system
instead
yet the trouble modeling language DML
mmm
hmm
dotnet also has reification I saw that
on a slide in the keynote plenty of
stuff to do before design by contract
by means of an annotation possessor
it's possible to achieve much of that
effect if you generate the superclass of
the annotated type so if you go to my
blog logs oracle com / Darcy I have a
entry from a few years ago with some
sample code showing how to do that for
variety of reasons we did not support
full rideable access abstract syntax
trees as part of annotation processing
but you can generate both the superclass
as well as subclasses of the annotated
type and that allows you to achieve a
partial amount of that mutability and
you if you check the Java one schedule
there are a number of other talks about
annotation processing at the conference
including a hands-on lab this friday if
you'd like to play around with that a
bit more did we fail to repeat the
question
Oh fuel blog blogs oracle com / Darcy
dar see why the the sample code is to do
properties in Java via this technique
that was almost like a plant so the
question is are there any plans to
improve type inferencing so in java SE
aight ty print printing is getting a big
overhaul largely motivated by lambda so
the one of the things that we're doing
is when you have a lambda expression you
can fully specify the types of all the
the arguments or you can choose to let
them be inferred and you know so so if
you let them be inferred they are going
to get inferred by the the target type
and you know the the compiler can do
quite a lot of cleverness about figuring
out what the talk you know what the
target type is based on the parameter
types of say a method that you're
passing the lambda 2 and and you know it
can speculatively spectively evaluate
multiple overloads to figure out you
know which one of these would be a
better provider of type information for
lambda type of type formal so there's
quite a lot of new work in that in type
inferencing also some improvements to
type inference in generic nested generic
method in vacations nested in vacations
of diamond within generic methods and
type in better type inference within
conditional expressions so a lot of work
in type inference going on so you should
go download the binary from a project
lambda and try it on some of the type
inference problems that it doesn't work
on it hasn't worked on traditionally and
see if it addresses addresses some of
those
introduction statement
yes there's a jet draft that was
published on my blog actually and it was
not officially submitted the jet process
so I don't think that one will be
showing up but anytime soon yeah that's
true there may be follow up so that
proposal next April so I keep a lookout
for that that's right honest in this
role he can turn in his grave
so the question is are there any plans
for generics improvements so this is a
loaded question some people might
believe that that's yeah that generics
are just perfect as they are and and
can't be improved so we're very
interested in exploring the feasibility
of reification of generics and not only
reification of generics but reification
of other structural types like function
types and tuple types and the ability to
do things like genera Phi over primitive
types have user defined value types etc
so there's a fair amount of research
going on into those problems now I
guarantee it will not see light of day
before Java 10 but we're working on it
now these things take a long time so
we're looking into these things we very
much want to improve this we'll see what
we can do it's worth pointing out that
in jdk 7 the error messages generated by
java sea for generic situations are much
improved from prior releases so we had a
project where that was a conscious
effort to make them more comprehensible
before that they're even hard for
compiler engineers to understand and
things like diamond were also in jdk 7
were done to make generics a bit easier
to use so you don't have to type out
those a type arguments all the time
um currently as I understand at the
annotation for us of the API allows you
to access classes that are on the
compile class now not not in in your
classpath inspect them it doesn't allow
you to access resources
are there any is there a reason for that
and might there be a team there is a get
resource method to find on the filer so
I believe that should allow you to get
at things find on your classpath okay
let's get resource not hit resources I
believe it's Khepri so it's a job X out
annotation processing filer would write
it I think that may only get returned a
single resource so if you're looking for
type of resource that can hear from
multiple jars in the same location ah
yes that might might be restriction okay
reason we thought that the functionality
provided was efficient at the time so
you might want to file a handsome
request for that it's possibly might get
small additions to the API in eight or
nine you see java is fast enough to the
job itself
maybe good idea to say be sure there
should be something like a new Java
release that will not give a very high
priority detective community and for
example menu verification say no more
thought I'd support really get rid of
off deprecated saying with the biggest
team cut and then say to all the
customers is if you use this then it's
not
alright so the question is you know what
are the prospects for saying all right
we're going to throw all the baggage out
we're going to define Java plus plus or
something like that that keeps all the
good bits and throws out all the bad
bits it sounds like a good idea doesn't
it but the devil is in the details and
you know for every thing that looks
terrible I you'll find people who have
bet their company on that you know the
one one of the one of the great things
about Java is you know what what is
people there are so many people who have
done so many things with it that it has
tremendous momentum and that's a
double-edged sword right so there's you
know trillions of lions of Java code out
there in the world and you know that
that's something that keeps Javas
momentum moving forward because there's
so many people who are doing it on the
other hand it makes it exceedingly
difficult to make incompatible changes
our approach is we're willing to
consider in incompatible changes on a
case-by-case basis but we recognize that
breaking compatibility is a source of
tremendous pain for the people that have
made Java successful I meant not just
rolling away or stopping to support
so gentle so the track record on that's
not good right so there are many people
who have invented cool new languages
thinking it was going to be the next big
thing and an improvement on the last big
thing and lightning doesn't strike twice
uh thank you i'm i'm not i'm not certain
that we would be successful so that's
not that's not the direction we're going
right now i think there's a tremendous
amount of life left in improving java
without breaking compatibility it moves
more slowly it's harder that's okay i
think you know if you look at the effort
mere that we've done in java 8 adding
lambdas it wasn't easy it was a thread
the needle through a lot of existing
constraints there were a lot of
interactions that we reasoned about and
had to make some course corrections on
but ultimately it's doable and I thank
you I think we'll get a better result
doing that so quick poll show of hands
how many people are using jdk 7 in
production jdk six well jdk 7 came out
last year why aren't you using jdk 5142
will anyone admit to pre 142 so we've in
the java community there's there's
always been a lot of value to keeping
especially old class files running
that's the basis of the binary
compatibility policy we've had for the
jdk that you can take a very old class
file run it on a much newer jdk it'll
still work it'll still link and still
work we've placed somewhat less value on
keeping sources being able to compile
over time but you can still compile many
very old sources from late 90s on jdk 7
or 8 builds and the work just fine and
there's a tremendous amount of value in
keeping that the case and I don't think
that will change anytime soon
so I saw code from 2009 that used red
stuff you come shouldn't we tighten the
screw the Philippines I determine Pilar
it is true that with the JDK
motorization starting and dedicate with
the profiles and then moving to full
moisturization with the jigsaw module
system i should say the java module
system for which chicks or is the
prototype API is with which people have
been if not familiar that perhaps
over-familiar internal AP is some misc
etc which have always had big warnings
attached to them will start to have even
stronger warnings and ultimately errors
attached to them and I often find that
when people say oh I move you know I was
running my program on 85 and I moved its
jdk six and it broke and I say but there
were no language changes between five
and six what are you talking about ah
yeah but we were using this API and some
changed it but but you should never have
been doing that in the first place so I
think you all without much doubt see
aggressive is the wrong word but a a
strong move towards cleaning up the
boundary between the internal and the
external parts of the JDK in Java 9 in
some sense the module system adds a
enforcement Beckett mechanism to
policies that are 15 years old now like
we've long said don't call these
internal parts at the JDK we know
they're tempting if you want to call
them you know apply for job to work on
them but otherwise don't call them and
since mechanisms were not in place to
prevent that from happening many people
have done that and continue to do that
do that despite our Vice not to so
companies do some discounts a fellow
ironically they call themself Club safe
and you know it's possible school
libraries and conventions
that should maybe go
things could you be say another
so so the question is um you know it is
you know would we in the future see
support for immutability in the language
so I would love that I think it's a good
idea the devil is in the details right
so immutability is not an absolute in
Java you can you know change final
fields through reflection and
things like that but I I I think there
is room for you know for giving the user
stronger tools for declaring and
enforcing immutability final is pretty
weak but it's it's not a not a trivial
thing John Rose has an instant blog
entry about larval objects that expound
upon this possibility John Rose has a
log around blog that vocal calm and the
essence of that you know that post is
there's a lot of objects that start out
their life mutable and then want to
transition to a I am immutable
thereafter for example if we would ever
have arrays whose elements are final
well in order to initialize the array
you have to write them once so they have
to start out mutable and then you flip
the switch and say it's immutable from
here on after and so it what's what's
needed is something that allows you to
indicate lifecycle transitions and an
object from a proto stage where you're
willing to mutate the values and then a
final stage when the values are frozen
yeah oh yeah good good go ahead along
those lines
of named parameters for constructors
smoother what Scala Dave's happens the
Builder pattern doors were says there's
been consideration of named parameters I
have a lot finally I have a blog entry
about named parameters logs oracle com
/b Buckley from a while ago object
construction a raise if I mentioned but
just plain object is clearly too
flexible most of the time in the Java
language you can do things in
constructors such as method calls being
dynamically dispatched which because
you've got the full power of the
language there which are unnecessary and
mostly not used and you can see objects
therefore an inconsistent states and
thus color pattern of you initialize an
object by passing the values in and you
don't get to writer why would you want
to write a custom constructor subset all
those boring fields every time and once
the objects being constructed it should
be immutable I agree that should be a
that should be that should be a pattern
in the language the fact that the
parameters are named I mean name
parameters are a more general thing than
just use object construction right ten
fields
have an instructor taking ten parameters
unless you can give them names I don't
disagree but you get into the same
argument too far that lets me have a if
I have a method with ten parameters then
I need name parameters I can see the
quip I can easily see that question be
asked and the the come back to some
extent is you shouldn't have that many
parameters on your method now object
construction might be a little different
maybe but if you've really got ten
literal values that you can write that
that's that's a lot of object
configuration and then you're getting
into dependency injection and then those
values coming in so I would actually
like to look more object construction I
would also like to look more main
parameters but I think they're largely
independent things there was a question
of why over here
so the question is are is there any plan
for multiple inheritance and classes and
the answer is no we have in Java 8 I you
know it introduced default methods which
give you the effect of multiple
inheritance of behavior from interfaces
multiple inheritance of state is just a
rat's nest and where we don't see a lot
of value in that some more recent
languages have had success with traits
traits are very cool at this point
trying to nail traits on the side of
Java I think would be a mistake so even
though it's attractive I don't think
we're going to go that way
hasn't come to mind yet you should never
be able to call more than your immediate
superclass anyway or their cancellation
you get security flaws cloneable
and flex
yeah so as you know as we said earlier
that's something that we're looking into
it's non-trivial it's you know a
long-term research project but it's
something that we're starting to look at
now and the reason to reify type
arguments to parameterize types isn't
just so that we can say we've done it
it's that the language is I won't see
materially but somewhat more
inconsistent today given airasia because
there are all sorts of edge case rules
about you can't do this you can't do
that and you're smiling so you must have
met these things precisely because what
you're right and source is not actually
what ends up being represented in the
class file or the VM and so therefore
the language has these arbitrary rules
about provably distinct super types and
overloads and classes rules and it just
goes on and on and on it writ and it
really is quite obscure where you're hit
by air asia and way or not and so if
only to make the language more
consistent that is a good argument for a
reification no it wasn't done when you
know when Phil wat Allah and Martina
dusky proposed a feather well Phil
worldlet proposed Pete Sir Martin and
then for the way Java you know back in
the late 90s they didn't not only did
that they they didn't know how to reify
the type arguments and they knew that
they didn't know how to do it and they
were concerned that if we try something
and get it wrong then it's enjoyable for
all time now it is true over 10 years
later Scala has got user land
reification of type arguments you know
Martin finally worked out how to do it
and if you ask Martin a dusky what you
think of reification in the vm he says
it's a bad idea because it means
committing the JVM to a particular
generic type system which let's say
would have variant and invariant
generics that's what java's wild cards
are in the vm for all and that affects
one way or another all source languages
compiling to the JVM and so there is an
argument which we recognized for keeping
reification out of the JVM I'm modern
adair ski who
you know I think is a recognized expert
in this world when people say to him at
Schuyler conferences why don't you beat
up those oracle guys to reify generic
she says I don't want them to do that I
much rather and rich Hickey with closure
says the same thing I'd rather have it
in my compiler then get the vm to try
something out and maybe get it wrong in
ten years later you wish you hadn't done
it that's why reification is a much
harder problem than just the engineering
of bind type arguments to class names
one of the reasons reification was not
chosen as the implementation strategy
for Java generics was that at the time
no one knew how to have a system that
was simultaneously reified as well as
had migration compatibility meeting the
ability to reuse the existing class
files the existing set list and whatever
mapping so the the choice available at
the time was have a flag day for new
collections that are genera fide versus
the old collections and we chose to
value of the existing source and binary
compatibility over that also the if you
look at the c-sharp papers that discuss
their reef occation techniques they've
certainly done some interesting work
there they tend to emphasize that there
really an allowable types what they tend
to emphasize less is that they introduce
a second level level of indirection
between a class and its V table because
they use what they call a near class to
store the common information among list
of integer list of string list of object
in an intermediate position so they're
adding more dependent loads on the load
chain so there is a lot of vm
technologies that would be needed to
keep equivalent performance in a reified
vm if i can just let me just finish this
this thought the reason dotnet was able
to reify their generics was precisely
because they did introduce a secondary
set of collection types which we didn't
do and the reason they were able to do
that is because they had a versioned
module system internet since version 1
and they didn't have any users at the
time
okay so so one more aspect of
reification that i think is relevant so
you know people look at reification and
they they see the inconvenience of not
being able to say implement comparable
string and comparable of integer or
something like that but the the real
pain of reification is 0 is the effect
it has on our ability to extend the type
system so you know for those so for you
know those you've been following project
lambda a number of people were extremely
disappointed that we chose not to expose
function types in the type system so
that there's no way to denote a function
from you know integer to string for
example and the reason for that is
basically the tool we we would have had
for representing that was generics and
generics are erased and erased function
types would have been horrible and so it
makes it very difficult for us to extend
the language and interesting directions
like say adding function types or adding
tuple types or any number of other
structural type typing things because we
don't have a way to represent that type
information in the VM and so I'm much
more interested in reification for what
it gives me as a language designer than
what it gives me as a Java programmer
whether little pause yeah we're out of
time so thank you very much for coming
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>