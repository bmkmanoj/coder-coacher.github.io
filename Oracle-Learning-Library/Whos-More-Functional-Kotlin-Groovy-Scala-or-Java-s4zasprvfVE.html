<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Who's More Functional: Kotlin, Groovy, Scala, or Java? | Coder Coacher - Coaching Coders</title><meta content="Who's More Functional: Kotlin, Groovy, Scala, or Java? - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Who's More Functional: Kotlin, Groovy, Scala, or Java?</b></h2><h5 class="post__date">2013-02-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/s4zasprvfVE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">today we have a provocative title who is
more functional groovy codling scale or
Java and I have a disclaimer so I'm not
actually doing any language comparison
I'm trying to tell you something about
what functional programming is how how
we can benefit from it and how it's
supported in modern languages and what
we want ok a few words about me I work
on project Catlin jetbrains so it's
another new functional not really
functional language for for JVM so it's
supposed to be like a modern language
for industry that will let all of us be
more productive with our existing
environment and I also serve as an
expert group member working on project
lambda so I'm guilty of having a hand in
lambdas for Java 8 okay
so I'll try not to be too biased towards
Scotland but of course I'll present my
language and tell you a lot about other
languages as well so a prologue imagine
your five-year-old son Jimmy coming up
to you and asking dad or mom is Java a
functional language well I don't know
what you answer but I would be really
surprised and say don't you know your
dad from your mom
well if you think about this question
seriously it's a good one
I mean to answer it you at least need to
know what is Java and what is functional
language so well I assume you know what
is jela so I'll try to tell you
something about what functional
languages and what functional
programming is like here okay
so let's go back to 1936 no computers
around and this is the time when
functional programming was actually
conceived so it was definitely not for
programming any computers it wasn't
called functional programming then it
was called lambda calculus it was
created by a mathematician Alonzo Church
who worked on some mathematical problems
of mathematical problems of decidability
of higher order logic or first
first-order logic actually and he came
up with this very interesting very neat
way of writing down algorithms basically
only ten years later the first
production computer was was available
and it was totally not functional in its
architecture it used for nine Monica
tech chure which means that you have a
huge piece of state your memory and you
mutate it with commands so your your
program is a sequence sequence of
commands and every command main with may
mutate
any place in your memory then for Turing
came about ten years later and it was
again structured after this phenomenon
architecture where you you're supposed
to write out statements and every
statement is that command that may
mutate the global memory Fortran was
developed by a team of engineers led by
John Backus oh I'm sorry I'm a little
bit behind my slides there so Fortran
came and 1956 it was developed by a team
of engineers led by John Backus how well
in 20 years from that time tell us
something very interesting
first two words about Fortran this is
the probably the most interesting
language on earth today because it's the
most long-lived one it was developed in
1956 and it is used widely up to now so
it's it's one of the first languages and
it's still around isn't it cool
so John Becker's received he is Turing
Award in 1976 and in his during lecture
asked an interesting question cam
programming be liberated from the Fontan
von Neumann style and phenomen style is
this idea of having one huge piece of
memory mutated by concern by a sequence
of commands and of course he was meaning
this functional programming which was
not around at that time so there were no
widely known functional languages and
almost no function languages at all so
functional programming at that time was
existing only on paper and since that
time the research started about real
functional programming on computers and
since that time we have these two ideas
of phenomenon architecture and
functional programming converging to
meet and really integrate with each
other your head
what about Lisp Lisp there actually were
a few function languages already yeah
but you're right about list the Lisp has
something to do even if the early list
had something to do with functional
programming but let me skip on this I
mean it would be too many details to
tell so another question from your son
what is good about functional
programming any ideas
go ahead it's good for parallel
programming any more ideas okay so it's
immutable state functions without side
effects so on so forth okay well we're
told that it is good for for our
complexity yeah for our parallel
programs what I would say is that it
makes it look smart almost like wearing
glasses
but there definitely is something to the
idea of using functional programming
concepts for managing your your compact
complexity and for making your parallel
programming easier let's have a look so
if you compare this phenomena style and
functional style one is again mutating
the common state and you cannot really
take your program apart and just take a
piece of code look at it and see okay
this is doing this particular thing and
nothing else may interfere since you're
mutating the same piece of memory with
many other commands and pieces of code
even if you're not parallel you can't be
sure that nothing is changed while
you're making some procedure call or
something as opposed to this in
functional programming the the main
concept behind the the initial idea was
that you take your inputs
you'll never rewrite anything you just
produce new values reading the old ones
and in the end you give out a result so
there is absolutely no mutation of
anything and your programs are
compositional so nothing has any
side-effects and if you take any piece
of code nothing can possibly interfere
so you can analyze things piece by piece
and mathematicians like this so much
because they tend to work with
lacks prior problems not like us right
our problems are easy compared to
mathematical ones so they knew in 1936
that they needed something really pure
to be analyzable to be reasonable in the
sense that you can reason about it and
so this is like a clean concept that
bring some order into our lives and with
this order we can manage our complexity
this is why functional programming is
good for say parallel or multi-threaded
programming because it's just too
complex without it we have to abstract
to to do all this and the technical
nature of this order is yes being
immutable nothing has side effects
nothing you taste anything so if you
have a state of the world
it will never be altered it will be only
appended added to okay let's have a look
at what price this comes it mm-hmm I
have a sequence of numbers for you 1 1 2
3 5 so and so forth what is that it's
written there it's Fibonacci numbers so
a Fibonacci numbers is just a prominent
example for you know for a school task
so here is a function written in common
can you read the code ok so here is the
first piece of carbon many of you ever
encountered so I'm introducing the
syntax here is the function declaration
I have a Fibonacci function of one
argument n returning an int and the body
says this is kind of a switch statement
when n is 0 or 1 it returns 1 otherwise
it returns to sum up to previous
Fibonacci numbers so it makes two
recursive calls ok so this looks pretty
much like a mathematical formula more or
less so it's probably the most important
thing you have to have to be functional
right you need recursion because this is
how you define functions in general so
and this test is passed by all our
candidates everybody has
obviously now what's very bad about this
function right it never ends why well
some recursive functions do actually
terminate Stack Overflow may be a
problem but not really
yeah it's horribly slow that's correct
it's so slow you can't imagine that so
if you didn't know about it please don't
write your Fibonacci production code
this way so let's have a look why it's
so terribly slow here is a cold tree if
I want to compute a Fibonacci of 5 I
have to compute it for 3 &amp;amp; 4 &amp;amp; 4 4 4 2 &amp;amp;
3 again and 4 3 2 again and 1 so every
Fibonacci number gets computed many many
times in the course of execution of this
function so it gets exponentially slow
and this is actually the price would pay
for this very simple definition here so
you it seems like you either have a
clean code or good performance it's not
really like that but it may be like this
sometimes so a very functional
definition of this is very slow on
phenomena Kotak sure of course if you
have some great other machine it will be
very fast or if you can do a very clever
optimizations targeted primarily for
functional techniques you can also have
better performance here but generally it
will be slow anyway ok let's compare
this one to a classical imperative very
bad looking code so here is my another
implementation of the same Fibonacci
function without actually imperative
still one argument two variables here
and a loop so if you think about it
every next number is just a sum of the
previous two right so what I need is to
store those two numbers and as I compute
the next one just to
throw out the the trailing one and shift
the beer right so the third one is one
plus one next one is one plus two and I
only need those one and two and don't
need that the first one so that's what
I'm doing here here's my fear and I
compute the sum and then replace the
beer basically shifted one position to
the right and this code is terribly
narrative it mutates the state all the
time and has a loop instead of recursion
so it's very non-functional but it's
fast it consumes a constant amount of
memory as opposed to the previous one
that takes linear memory on the stack
but you will never run into stack
overflow because it will run forever
before it gets to any stack overflow and
it will be linear in the end which is
good any questions okay so now let's see
about how effect free we can actually be
in real life so again I have a question
from your son then how do I print hello
without side effects well you think
about it you have your functional like
purely functional program no side
effects no mutation you take your inputs
you produce your output you're not
allowed to affect anything around you
how do you print anything well I can
just to get rid of the boy you know I
can say okay let's make a deal
whatever you give as an output I will
print so your program actually produces
your console output and what we've
printed okay then
how do I write to a file well I can
write the same thing to a file again
your outputs like go to a file but then
how do I do both I want to print
something and write something to a file
well in contemporary functional
programming this is the point where
monads came in and other very
interesting stuff but in the on the
conceptual level is this just not
possible
so the
idea of not having any side-effects
contradicts any altering of the outer
world Network communication writing to
the file system reading anything from
the file system bringing to the console
is not possible so being really purely
functional having no side effects
whatsoever is a test that's failed by
all four of our languages we actually
can mutate the state we we do not
enforce any mutability on anything any
purely on anything so we are not really
functional anyway make sense any
questions here
yeah so the question is is there an
analogy with storing our state and a
database in mutating it there basically
yes of course because you have your
again they're mutating state there are
those appending databases that don't
mutate anything but it's a different
story like not in sequel database go
ahead yeah let me repeat your comment so
yeah I'm being a little bit unfair here
because if you think about a functional
language which is usable in any way it
definitely can write to a file or print
anything so and so forth this is being
approached by either monitors that
isolate mutability or by having a little
bit of mutability on the side like ml
has but but our languages don't have
even this so we cannot in any way
control the mutability in our compilers
all we all we can say is okay you can be
voluntarily immutable if you write an
immutable class it will be immutable
thank you very much for your comment
okay so I'm finished with my
introduction and there are a few points
to take away a functional program makes
things simpler by abstracting many
things away by getting rid of
interactions sometimes it comes at a
price and our languages are definitely
not ideally purely functional or even
practically purely functional any
questions okay so now we'll talk about
the higher order that functional
programming brings to us here is a test
I wrote for my Fibonacci function it's a
silly one but still so I'm just
asserting that for
every input my Fibonacci gives the right
output it's fine but I showed you two
implementations of Fibonacci right and I
want to test both of them on the same
data how do I do it do it I can copy the
code and just change the name of the
function there or I could do something
like this I could say okay I have a
function that takes another function as
an argument and applies it to those
inputs here and check the results so
here what I say is my parameter has a
type that is a function from int to int
right so it takes an int and gives an
end out so this is the story of famous
whatever lambda expressions were
closures or anonymous functions but the
proper name would be a higher-order
functions when you can pass a piece of
code basically as an argument to this
kind of function so this is definitely
something very important for functional
programming because in the very pure
pure sense all you have there is
functions variables and function
applications nothing else so if you want
to do something like this in common
here's the function definition and here
are the two usages so I have my test
Fibonacci and I'm passing an argument
here which is a lambda expression or an
anonymous function or closure if you
want so what it says here I'm creating
in place a function which takes one
parameter n and returns Fibonacci of n
and here is just a little bit of syntax
sugar where you can say that there is
already a pair of parentheses so I don't
need this extra one any questions okay
so this is the concept of a higher-order
function and in maybe a year from now or
so all the languages I'm presenting on
will have this thank you
the Java team and Java eight we're going
to have lambdas that's great so we're
all higher-order in this sense and where
we all have recursion now isn't that a
little bit familiar like as my
grandfather told me in 1995 they used to
have this book Gang of Four that was
talking about patterns and there was
this very interesting pattern called
strategy that everybody uses all over
the place and even other patterns in
this book used this pattern like if you
think about what a command is it's a
special kind of strategy what an
observer is you're submitting those
reaction strategies to to an observable
object what's an abstract Factory it's a
strategy for creating objects and even
state is changeable strategy and visitor
is a strategy for implementing a
polymorphic function so we're all full
of strategies like all our Java programs
are full of them so since very long ago
even in siblings plus this old book was
for C++ we knew this idea of
higher-order functions so it's not like
a groundbreaking thing actually and
actually you all know anonymous in their
classes that simulate those nicely
rendered anonymous functions in the code
so all we get with Java eight or any
other language with that supports it is
just decent way of expressing this idea
in the code and by the way the immutable
pattern was also in this book so it's
not like we're discovering this wonder
wonderful world of functional
programming for ourselves we're just
making things easier to type into the
system any questions thank you now a bit
on practical aspects of this so with
higher order functions for example when
you transition
Java eight or when you switch from Java
to Catalan or to Scala or to groovy you
get something like this this is a
collection of users and I call it for
each function to each rate over those
users and send everyone a message by
hello from your admins one not why am I
not using a for loop here
what's a huge difference between this
which is called internal iteration
because the collection handles the
iteration by itself and a for loop which
is external iteration because the
collection gives you an iterator and you
call methods on that iterator the key
difference is that you can implement
this differently for different
collections and it may be a say
sequential or parallel without changing
the mindset of the client so for normal
ArrayList it will be user one say hello
user to say hello in in a sequence but
if you have a parallel collection of any
sort you can say okay this thread or
this machine will be doing this set of
users the other the other set of users
so and so forth we can do that in
parallel because this is a function that
abstracts your control over and lets you
put this thing into the library and this
is I think a huge point in modern
programming languages being able to put
something like this into the library
because this is where the most nasty
boilerplate comes from you repeat the
same pattern over and over again your
code not because you're lazy or stupid
but because you cannot just abstract it
over and put into the library and this
is the point of having those modern
languages they help you do this
any questions okay
so the summary of this part would be
that I was talking about those very
familiar callbacks or strategies which
have very important abstraction that
lets you put your control into the
library now I have a question for you
what is ADT a what data type abstract
data type any other ideas
algebraic day today well thank you so we
have options here and I'll just give you
an example so here is my server and it
climbed and they will exchange messages
a client can ask the server's search for
whatever word lambda and server well
send messages back saying I found an
exact match at this position or a
similarity at that position so if you
define what those messages can be you
can write something like this this is
not Kotlin or any other language this is
just some notation so I say that my
message may be either search for and
then a term or exact and then an item or
similar and then another item makes
sense so this kind of definition is the
ideology behind an algebraic type and
this ad T stands for two things and
maybe even mixed up in some context it's
either an abstract data type which is
saying that okay I have a type and I
have these operations on the type but I
don't tell you how I implement them and
I can switch that somehow without
letting you know so this is more or less
like an interface and it may be in this
algebraic type which is basically a data
class if I have my abstract class for
message then I can have my subclasses
for this message that message in that
message and they will only hold data and
don't do anything make sense so this is
also very at least very traditional
concept in functional programming
so normally function
languages rely on algebraic data and use
abstract data types for abstractions
over data so if you want modules there
for example or good libraries what do
you do is you say okay I'll have type X
out later define what it is here and I
have those functions I'm not telling you
what they are so types there don't
actually own the functions but it's
still the same idea as an interface and
then when you specify what the type is
it will be algebraic so you will just
say what the cases are and we have a
close analogy in object-oriented
programming and all of us of course have
the same thing now here is what it looks
like and cotton will be very much the
same in scale and very close and groovy
as well but imagine what this is in Java
by the way so I have an abstract class
called message and three cases search
for term exact match at location
similarity application they all extend
message so here is my emulation of an
algebraic data type in object-oriented
programming this is what Calvin does
what Scalla does and then I want to
process a response from my server so
here is a bit of a synchronous
programming so I say server
I'm sending you a message search for
this word and also I'm giving you a call
back
this function here you remember this is
an anonymous function right I'm giving
you a call back that you should call
when I receive a message from you
basically so this is not like the remote
server server itself but it's the
representation of the server on my
client side and inside this function I
say okay I received a message m and if
it is exact match I just print that I
found something at this position and if
it's a similarity I say that something
is similar at that position otherwise
it's an unknown message make sense so
this is if you know about pattern
matching this is close to pattern
matching not really bad for measuring
because the patterns are trivial here
but
for very many applications this is about
as much better matching as you need
unless you write compilers so I need a
lot of pattern matching really every day
and I don't have it I'm sad but it's my
problem so here this is basically just a
sequence of if if this is an instance of
that statement one interesting thing is
that you don't have to cast like in Java
you would say if am instance of exact
match then come up with a new name cast
and then use that name here you don't
have to do that just because the
compiler is smart enough but this is
about the whole thing
questions is it obvious
nobody cares all right okay so now there
is one question so I'm mostly done with
the like functional story how functional
is your language
it's about as functional as you want to
make it because it supports all the
tools there and if you want to make it
side-effect free or immutable in your
program you can otherwise you just don't
use this capability
so the real functional Ness in your
language is in your head
and now of course you can be like
formally equally functional but you
won't be equally usable right so what
makes one language more suitable for
this or that kind of programming than
some other language let's talk about
what Java eight brings you and whether
Java eight will kill say coffin or
Scalla or any other language so Java
eight brings you higher-order functions
isn't it cool so finally when I have a
collection of something I will be able
to say filter me that collection or
sword with a predicate or something like
that
and without having to create anonymous
inner classes so on so forth this is
great
how many higher-order functions do you
give get for your collections
well maybe 20 maybe a hundred Oracle
people are not mean and they will give
you all those interesting functions but
they can't put all of them into the
collection interface and this may be a
problem because if you want some other
function you have to again go collection
utils dot whatever of collection and a
lambda and this has a problem to it
so you look at this what I want to say
is I have a collection I want to take
those elements that are greater than
five and make squares of everyone okay
but and this is how I write it with
static functions in Java as a map of
filter of collection of the filtering
predicate and then pass the map function
that squares every number makes sense
okay now what I have here is reading
backwards as a map a filter of
collection but what I actually want to
say I have a collection please filter it
with this and map with this so I'm I
have to jump with my eyes from here to
here and this is unpleasant isn't it so
this is I think this is a rather
important difference we get in Java 8
compared to what we have in column for
example so compared to this collection
that filter of predicate map this
squaring function this has the right
order here's my collection filter Eden
Abbott so you can express function
composition in the right way when when
you write the composition operator in
mathematics you may wonder why it's
backwards there but it's actually not
backwards it's the way it should work
what else is good about it
yeah it's thank you very much it's
composable so you can say okay what is
filter return it may return say a lazy
collection that is then lazily processed
by the map and you don't have to
evaluate everything if you don't need
all the values there so this is possible
here as well but here it's much easily
expressible if you want to say an
iterator from a filter you can just take
it here and you will see the sequence of
the functions another thing is that if
you're using an ID and of course you're
using an ID it's so good for programming
right you're exploring your api's with
heading control space right you say okay
here is my dot I had control space to
see what functions do I have in my
collection and you know it doesn't give
you those here because it can't figure
out what's applicable here and with this
it would be so there is a huge move in
all the modern languages except for Java
eight to have this to be able to add
your methods to your classes and then of
course there are options like how you do
that do you think you can like add a
method to the string class for example I
have my string on the class path from
the JDK and I want like the last
character a last word function on that
string can I do that not really because
string is protected by the JVM gdm
depends upon the string so much it won't
let anyone touch it even with aspects
seven with any hacker right so if I want
to do that I have to play a trick of
some sort and different languages do it
differently for example groovy will use
say an expander metaclass or some other
dynamic mechanism to extend this or
Scalla will wrap the collection object
here to create something that actually
has that method or Colin will do
something else we just do the code
transformation that basically transforms
this kind of code
all into this without you seeing that so
I think our ways the least intrusive and
the least overhead but still it's just
different approaches to the same problem
any questions
yeah so the question is how do you
compare the two basically if I got your
right yeah so this is the way you write
it in Java basically now you and Java
eight you can't express it the other way
around because all you all you have on
your collection interface is the members
of that interface of course the members
will have a map and filter there but if
I have my own map one and filter one
that won't work
yeah yeah okay so let's have a look at
how you implement extension functions
which are which is what we call these
extension functions because you don't
actually attach touch the class but you
add functions to it you extend the
existing interface with those extension
functions let's have a look at how you
implement them go ahead
yeah the question is can I have my
laziness in this case or in this case
and what it depends upon so basically
technically you can do it both ways but
the question is how you read it because
you can of course produce a lazy
collection out of here and feed it into
the map and it will stack one upon
another but if you say one an iterator
the iterator will be somewhere in the
middle of this expression when here it
will be in the right place like you know
that you operate on iterator which is
lazy right after this filter function
makes sense okay okay so if you want to
extend your class whatever class it is
so here I'm extending just to get rid of
most of the generics I'm extending a
collection of int not general collection
so here is my filter for a collection of
ends I say that I have a receiver type
in here
so this collection of int is a receiver
type this is the type who are extending
now I say filter of whatever function
that takes an int to return a boolean
and I spit out the list event then the
implementation is straightforward you
just create a list and iterate over this
and this is of course the receiver that
I get here on the left of the dot and
then if your F accepts the item from the
list you just add it to the result in
the lesson that's it make sense
okay so in this straightforward way you
can have lots of useful operations on
your existing collections and what
carbon actually does it takes Java
collections as they are without altering
anything there and just adds all the
useful stuff on those collections so we
don't have this problem of having to
convert all the data or adapt all the
collections to pass data back and forth
between carbon and Java
yeah that's a great question so I have a
little bit of time
you're pretty shining questions so my
space for questions is not philia so
thank you very much for that mmm the
question is does coven use those ugly
mutable collections from Java like
really can you think about it well the
answer is yes and no we use the same
collection classes so we're 100%
interoperable with Java but we play a
trick there so if you look at what
Coughlin's collection hierarchy looks
like you have read only collection
interfaces like a list is read online
Kotlin so you don't have set there you
don't have clear there and it's
covariant and you have all those like
iterable collection lists set map
they're all read-only and then you have
interfaces derived from those like
mutable lists mutable collection mutable
set so on so forth and your normal Java
util erased is seen as if it extended
the mutable list interface so we have
split the Java collections it's all the
fictional I mean it's all in the
imagination of the Catalan compiler so
we didn't order any of the JDK but we've
ujk is if it was properly designed for
immutable collections or read on the
interfaces so you can have your own
implementations of those read-only
collections you can use the existing
implementations of mutable collections
and it all interoperates properly and
all lives together
make sense mmm go ahead
a great question so the question is okay
you have those read-only interfaces but
doesn't doesn't give you the false
expression a false impression of this
being immutable when it's actually
mutable by somebody else you just don't
hold a mutable reference onto it it's a
fair point there are two answers here so
I think they're the the design of say
guava is very good where you have
basically things saying immutable lists
explicitly so this class is not mutable
and so I think when I finish Caitlyn's
library there will be those read-only
interfaces mutable implementations and
immutable implementations immutable
implementation just guarantees you that
nothing mutates and if you want
something really immutable if you want
to pass it back and forth between
threads for example you want an
immutable class not just a read-only one
but the read-only thing gives you
another very important advantage because
assume you want to print a list so I'm
running a print function that takes a
list of any objects and prints them out
so how do you write that in Java you say
I take a list of question mark extends
object right or just question mark this
is something about calling
contravariance because otherwise java
won't take you your list of strings
where a list of objects is expected all
right and if you have those immutable or
that story those read-only interfaces
they are already covariant in Kotlin so
you can pass a redownload list of
strings where a read-only list of
objects is expected so this is the dream
of everybody can we have that already
like I want just a list of something can
I say a list of any yes you can make
sense good go ahead
given our
completely unaware
now the question is since we know about
what'swhat's immutable and what's not
can we optimize anything to help JVM
optimize at runtime the answer is I
don't know so it will definitely depend
on how you write those implementations
for immutable collections and I haven't
looked into it yet so I suspect that it
won't be much more efficient than what
guava can do for you because it's no no
hints in the byte code just the
implementation that's it go ahead
yes so our there can be different
approaches to making things lazy but our
approach would be say that you operate
on an iterator rather than a list and
you produce another iterator as a result
so it will be a lazy operation which
takes an iterator during iterator this
is how we distinguish between lazy in
your computation column okay so the
summary of this part is you can extend
existing types and that's very important
because you want your own libraries you
want to be able to read the text from
the file after all even if JDK doesn't
provide you that function and you want
that without changing the classes so I'm
coming to the ending and it will be the
last question then
should I use functional programming what
is your problem and this is the very
important question if you think about it
because any technique comes at the price
so if you want to be super optimal in
one core you'd better not use any
functional things because the super
optimal thing will be a fun lineman
thing mutating everything consuming as
little memory as possible using loops
and everything if you want a large-scale
application that should scale up you
probably want abstractions that will
give you an opportunity to change the
underlying implementation so that you
are able to scale and if your peril you
want to guard for all the problems you
know about or don't know about just to
eliminate them altogether right so you
I'm not giving you a recipe you have to
use functional programming for your
problem it depends on your problem and
the same applies to any language like
people would come and say ok should I
switch to Kotlin switch the government
from C no no maybe not and your benefit
dependent depends on what your own what
your problem domain is if you are Oh
like if you're trying to write the
shortest piece of code that makes the
work done you're probably better for
skeleton for Kotlin because Scala is all
power possible if you want something
that will be compatible with and
understandable by everybody in the world
you want Java if you want something
written very fast but working you don't
care how slow you're probably one groovy
if you want something for a large scale
code base understandable by many people
but still very performant and modern you
probably want goblin so a path script
unto my talk is goblin is cool thank you
very much for your attention and if you
have any questions go ahead and ask them
excuse me that there is someone behind
you okay
yeah that's that's a good point
so there is another definition to what a
higher order function is this is this
has nothing to do with mathematical
definition of a higher order function
button list for example you would be
able to introspect your code and change
what's there but I think this is too
extreme for for any practical for much
of practical program there was another
question
what about JavaScript okay we we do
compile to JavaScript so if you if you
want your cousin to work in the browser
and on the on the server it can do that
so you can have the backend written in
cut length for Java and the front-end
written in column for JavaScript it's in
the works but we're already compiling
mark questions the question is what
about frameworks like play they're great
we haven't started any real work and
integrating with them but there is a
plan to integrate with particularly with
play ok thank you everybody I have some
Colin magnets here in the table grab
some if you like
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>