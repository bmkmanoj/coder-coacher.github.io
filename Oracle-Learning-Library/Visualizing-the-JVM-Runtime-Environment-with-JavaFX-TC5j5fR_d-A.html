<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Visualizing the JVM Runtime Environment with JavaFX | Coder Coacher - Coaching Coders</title><meta content="Visualizing the JVM Runtime Environment with JavaFX - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Visualizing the JVM Runtime Environment with JavaFX</b></h2><h5 class="post__date">2013-01-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/TC5j5fR_d-A" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello and welcome to the visualizing GC
with JavaFX talk this is a very slightly
different title from the one that was
actually advertised which was
visualizing the the JVM runtime the
reason for this is because when we start
this project as you'll see in a minute
we thought we were going to write four
or maybe five of these applications and
just step you through a whole a whole
raft with these things to to visualize
all of the runtime however we started
with GC and GC kind of got away from us
as you'll see it started out life is
over a simple application but as we got
into writing the project we realized
that there was a lot of sophistication
we could bring to it and we're having so
much fun with it that we decided we'd
just do one big application instead so
hence the slightly different title so
people that don't know me i'm ben evans
i met james cough and how do we have you
each other what supports the basis of
this talk well we don't munch of things
together we helped run the london java
community we both worked in banks over
the years we both like beer yeah
definitely and how i actually met Ben
was my first job interview when he was
technically grilling me across the table
I'm and we then met up two years later
when I recognized him from my nightmares
in there in a bar I was actually after
our own conference at the limited java
community so that's how we got to know
each other and start working on a few
type projects ok so this story about
where there's application and where this
project came from starts as with so many
things we are British after all it
starts with beer and pubs so we're up
late at night and we were just talking
about about the JVM what makes it
special and why we think it's a good
platform and you know some debate and
some back and forth which is I guess
kind of typical for when developers get
together later night and Evan bear has
been drunk and really what we came to is
that this does an important design
principle underlies such a vm which
people don't often talk about will
recognize and that's the whole purpose
of the JVM what makes it unique is the
extent to which it uses runtime
information to influence the management
of jvm processes themselves so if you
have C or C++ which is you
tactically compiled ahead of time
language which doesn't do any kind of
dynamic compilation you're actually
throwing away an awful lot of
information yeah you all you have is the
type of information that's available at
runtime and you don't have a lot of a
lot of good numbers as to how the code
is actually going to be used because you
know you just have no idea around the
runtime and Java in the JVM designed
with with a very different principle in
mind hmm and part of this comes out of a
lot of the software engineering that was
done in the 1980s in the 1990s where
people realize that if you analyze the
runtime behavior of software there was
all sorts of strange and unexpected
empirical things that you found out
about the runtime behavior of software
so I think things like you know the
younger generation illai poth assess for
garbage collection things like more and
more fect dispatch in terms of which
methods get get dispatched or inlining
or all these other techniques which are
just not there a compile-time you only
you and you see them if you analyze
runtime information so the Java platform
really is an attempt to harness that
dynamic information and to make the
runtime more efficient so we thought
about that and we thought about the fact
that in many cases there aren't a lot of
good teaching tools and a lot of Java
developers grow up without really having
been introduced to that as an idea and
in need of some tools to help illustrate
this and we do a lot of speaking and a
lot of a lot of teaching so it seemed
like a very natural fit so yeah juicy
just started to acquire more and more
complexity than more we got into it so
we decided to just do this one the code
is all available and github so that's my
username there and that's the that's the
project head so if you want to go and
grab that and go and find it then feel
free will step through some of the code
of it later on but if you want to play
along at home we'll start right now then
then you could totally do that yeah so
when we first started we originally made
a flash demo and that was basically
because we weren't sure we were actually
really building we knew we wanted to
build some teaching tools and and one of
our other friends Anna actually was a
very accomplished flash designer so so
she actually built us a flash version
just take a quick look at that so for
people that know the Java memory model
this should be working in Chrome perhaps
okay well that's the first probably and
hopefully only sacrifice to the demo
gods try this again in Safari shall we I
swear this was working in crime this
morning maybe assisters I old something
sigh okay let's try this in firefox
firefox is my my reserve backup browser
there we go there we go try this again
there we go can one see that ok so here
we have a flash demo which represents
main memory we have an object Ralph
which collapses into a single block and
this is a very simplified view of memory
and now you can see that we've got a
whole bunch of different allocating
threads that are allocating on different
T labs hands up if you know what I tlab
is in the context of memory allocation
only one person ok so let me tell you a
little bit about this as well the demo
is running so at elab is one of those
horrible acronyms which actually has two
separate meanings it can mean a
translation lookaside buffer from the
point of view of dealing with with
memory and Colonel paging or it can mean
a threadlocal allocation buffer and
that's the the context
we use it in when we're talking about
the Java memory model okay because
there's a secret about John memory
management that you may not know and
that is that you know if you're if
you're familiar with C and C++
programming hands up if you've done me c
or c++ programming okay so how do you
get a new object or new block of memory
and C or C++ well you use the mallet
system call now that means you making a
call into kernel space but if you've
ever SAT and looked at the cpu
utilization of a java process while it's
doing heavy allocation you may not see
any any colonel traffic tool any any
common space or context switches to
colonel the reason for that is because
the the Java Virtual Machine actually
allocates its entire memory space up
front so it reserves a big block of
memory which is the whole area and then
it just manages its pointers in user
space without ever touching kernel space
so what that means is you could divide
your memory area up into chunks you
could give a small piece of the memory
area to each thread that needed to
allocate and then allocation for that
thread would be incredibly fast because
all you have to do is just bump up the
point to buy a few bites so that's just
an off celebration so that means that in
the eden space and hands up if you know
terms like Eden and survivor space for
memory measurement good pretty much
everyone excellent so in Eden that means
that you can allocate in order one
because all you're doing is bumping the
pointer yeah occasionally you might need
to go and get an extra to lab but that's
that's basically all you have to do and
then what happens is when memory fills
up well you garbage collect it you take
all the dead objects you swap over the
survivor space and both even and the
existing survivor space that you are
currently using are now completely free
so it's just watch that one more time I
promise that with some driver effects
and so build the object graph start
allocating notice how all the other
spaces start off empty and then when
this collects will see that those
objects are transferred over into one of
the survivor spaces okay when that when
this refills again that was walked down
to the second space
and this is a this is basically how Java
deals with the young generation of
hypothesis which is the the runtime
observation the most objects die young
and what you need to do is you need to
size your pools such that you want you
will do a lot of young cheap collections
and basically try to try to make as many
of those objects die while at the same
time making the trade-off that anything
which is really going to stick around
for a long period of time you don't want
to be constantly flipping it backwards
and forwards between spaces okay so
that's the Java effect that's the other
flash demo here one thanks Donna flower
so why convert this to Java effects well
as a teaching tool it's pretty good you
know we SAT there I hope couple people
in your insulin than something and it
was you know it was a good a good
talking point it was nice graphic light
but there are a whole bunch of problems
with it first and biggest is that it's
quite dumb you know it's just an
animation it just loops it goes through
the same thing each time it can't easily
be changed because yeah we're not flash
developers we don't you know even if we
had the source for it we probably
couldn't modify it very easily but
mostly is it has no real awareness of
what's going on so we started to sink
could we could we do something a bit
better what would happen if we started
to think about this I think well jar
FX's you I technology we've had a bit of
play with it seems quite nice what could
we do well how about if we just
redevelop the whole application as a
Java and Java effects up hmm that's
interesting because we know how to write
Java and that means that we could
actually do some things like actually
model the memory we can actually have
like a real version of the GC algorithms
wouldn't that be interesting so that's
what we did and see these are some of
the design goals that we that we had so
we wanted to actually model juicy we
wanted to have a proper domain model so
we're in the code that we're going to
show you we have actual memory blocks we
have actual areas and real memory calls
which model the exact ones that are
inside the Java Virtual Machine we have
we have objects which model actual
threads allocating data and actually
running computations that was great so
we started with that and then we started
to get a bit ahead of the house
ourselves and this is where the
complexity started to snowball we
started to realize that this was
probably the only one we were actually
going to get to right before java one
because we wanted to do things like we
will just have a clean UI encode split
we want to do headless unit testing of a
javafx application it's quite quite a
novel goal but if you've got a proper
domain model then you could you could
see how you could do that and then we
saw us to think okay well it's almost
like you could script this thing it's
almost like you know what you need is
some sort of interpreter loop like you
might find in a video game wouldn't that
be interesting how could we how could we
do that what could we what could we do
then well we could have multiple
implementations of the sorts of memory
operations we could have random ones we
could have ones which read for files we
could we could do all sorts of things so
then we sauce interpreter modeling and
then of course not only do we want to
teach about the Java memory model and
about the way that GC works we also want
to showcase some Java effects features
and we want to learn we won't have some
fun at the same time yeah and then as
this is being developed in the open as
an open source project the code should
be clean and relatively well documented
I'll leave you to decide for what you
think as the hell well we achieved on
some of these girls when you've read the
cave okay so that's kind of Jim he's
going to walk us through some examples
from the from the code itself thanks Ben
so we started out with this and probably
around six months ago and I'm from in
the last two years I've been working a
lot with flex so I'm going to walk you
through some of the complexities and
some of the bits and pieces that we did
and if you haven't used Java effects
before this these next few slides will
give you a good starting point into how
you can just go and try and develop one
of these applications so let's talk a
bit about F XML it's very similar to how
flex skins work in terms of an iteration
on top of that and and just to walk you
through some of the syntax that you see
here and we've got basically a V box
which is just a layout that water ski
you a vertical pain that you can then
put things inside and you also have
things like H bolts which is then you
can line things up horizontally so you
get this V box and age box kind of make
a very flexible layout system that you
can then add components into and this is
really where we start to see our first
improvement on writing swing you eyes
you you effectively here can start to
break down the layout into something
that can then be generated by oh I don't
know say something like a scene builder
so this kind of thing is is usually it's
not written by humans it's generated so
this is the first nice thing that we get
so in this example I've highlighted some
things in bold and and what we can see
here is we have a controller that's
attached this so what what happen is
with as we start to interact with this
separated model and View and controller
as you interact things on the view it's
going to call back to the controller and
what we have also is these IDs and these
IDs come quite become quite important
when we look at what's actually in the
controller itself you'll also see some
things like label and combo box and if
you're not familiar with UI controls
it's worth just having a quick look over
and dapi so all these things are very
similar in all different languages so
what about those IDs well in our
controller class we can actually use
annotations and we have the text field
in a combo box in the last slide which
will be where it's laid out on the
screen what this will actually represent
now is is where what is that inside of
controller this is actually how you tell
your controller that okay here is your
text field so if you want to see what
text is in the text field do you have a
reference to that at the start of the
application you this will be bound
together we also have you can also do
this on methods so for example at bottom
of the slide here there's a begin button
and what happens is when you click on
begin in this is this is the FX mole
line you call the begin simulation which
would then call back into your
controller and then execute that method
and that's what this kind of on action
hash begin simulation is now you think
about that in comparison to swing when
you're actually right
that stuff and setting it all up you
would have to have quite a lot of event
handlers and dispatches and catching
events in your controller so this is a
really nice way of getting these things
connected together so how is the f xml
invoked well the starting point of any
flat MF any javafx application is going
to be your main class which extends
application and there's certain things
that you can override in that class
which then get you up and running and
the main one is start so effectively
what you're doing here and there's some
javafx terminology that i'll introduce
you to if you're not familiar is you set
a route which is then the parent which
is where everything is going to be
contained in so at this point why I'm
doing is I'm saying take that F XML file
which I showed you at the beginning and
use the loader to sort of make that into
the root you also have it is the analogy
is kind of like to going seeing a play
so what you can do is you're going to
set the scene here at this point so the
scene takes the route and you can
imagine this as being effectively as
seen that you're going to show in your
application and your application is kind
of the stage so you can move scenes in
and out depending on what you're doing
that becomes important when you do fees
why are you dynamically switching
through different scenes may be on like
a tab bar at the top and one important
thing here is as well is that all things
in javafx skinnable so you actually have
a massive CSS option to make custom
components and we'll go into custom
components a bit more later but you can
actually define this in your CSS this
becomes quite important if you want to
do stuff like white labeling so
basically giving your product to
different companies it means that you
can actually apply different styles and
different sizes depending on who's going
to pick up in the company it also means
you can stuff it's differently depending
on what platform you're on as well so
things may be skinned differently on Mac
OS to windows and what we do then is we
say we set the scene and we set a title
and then we're ready to go so there's
one drawback that I see with this at the
moment and just to skip back slightly is
this is all really cool in terms of you
have your memory controller and
how private field so it all hooks this
together but it makes testing this quite
difficult because you effectively got
things that are private of variables
that get bound everyone type so my
question and which I'm trying to find
out this week is how can we make
controllers more testable and how can we
maybe you know start to mock some of
these stuff so you can really start to
test the functionality that's in the
controller so it's my mini project the
other thing that's about controller
which I miss is you implement initialize
ball and what this does is at the
beginning when your controller starts up
you could set the initial properties on
some of the objects as some of the
components so for example what you might
want to do is put hello in the text box
and you can set this from here or you
might have a default selection on the
combo box so this is our custom
component it's been was saying and
showed on the flash demo we have this
concept of a memory block and we also
have a concept of a memory block view
and the reason for this is keeping the
actual model that Ben's got a show where
we're allocating stuff to to the actual
underlying model and the view separate
and that's really important when it
comes to keeping really nice clean and
maintainable code so our custom
component here memory block view extends
a stack pain and the reason for this is
we just take something already exist
since I've JavaFX and build on top of it
so what we have here is so we have a
rectangle and we have a text property on
top of it and also we have then here the
memories status so as you saw from the
demo the memory can be in different
states depending on what's going on it
can either be free it can be currently
allocated or it can be dead so what we
do here is if you'll see that this has
got an object property wraps around the
memory status this is our first
introduction to bindings and it's also a
way of getting around having to fire
events manually for when things change
and update and reflect it in the UI
which is what you would have to do as
far as I'm aware in swing so this is a
recognized of the change without having
a whole array of listeners and anonymous
inner classes and let's just go through
how we use the bindings here in the
constructor so when we initialize one of
these memory block views we set it up
with some with some styles so we
actually use the style property
which is on the rectangle itself and
then we do some bindings so what we
actually do is we use the static methods
on bindings to say well when the memory
states is equal to free then apply this
FX fill style of gray and when its
allocated say that to green and when
it's dead let's say it too dark red so
what actually happened here is as we
interact with the model that's hooked
into this those states will be reflected
without us having to go and do anything
about it so just a bit more on the
concert to obviously if you're extending
something in the Java effects API or
anything for that matter you need to
call the super the wise you're going to
get some really crazy things happening
and all the books we then made it so it
wasn't it wasn't just a rectangle we
applied some more styles so I guess the
other thing to note here is where we do
in CSS styles before you can actually
also call these methods directly in code
so you as well as you having this F XML
way of representing things you can also
build the stuff up from scratch you can
declare it you can declare a scene and
you can add things to a problematic
programmatically using add children we
then for the first time step of our
texts and then we add we get the
children which is a call to the super
class and we add the box and the text
onto the stack so where are we now so
I've gone through a few things and we
have some blocks that can change and we
have some states that could be set on
the block so this is a very early
screenshot of what we started to build
here the controller again how do we I
guess the thing is now so we discussed
having the memory block view and the
memory block how do we link those things
together so we actually do that inside
the controller using them small method
that we've got here called the
initialized memory view and you can
imagine this is in effect allocating to
like a 2d array you basically go across
the width and the height and basically
set each of the individual items so what
we're doing here is we're using we're
creating a man with memory block view
from the pool and adding it into the
grid pain so again going back to what
we're seeing here we're using a lot of
the stuff that's inside jar effects just
out of the box so these are these memory
block views are actually set up in grid
pains so another important thing is back
reading and we've got two different
varieties of this in the application the
first one is what actually controls the
allocation freds and basically this is
on an executive service and I'll let
them go into more detail that as we walk
through the code in netbeans to discuss
how it works with relevance to how we
are care memory a Java we also have one
of the cool thing which is the platform
run later and this is the javafx way of
dealing with animations or transitions
so what I found is when I started
writing the code and putting all this
nice stuff in where we were updating and
allocating memory was very quickly
things started to freeze up and it was
taking there was a lag in things being
flipped around and all these fancy
animations that we tried and I realized
that I committed a cardinal schoolboy
error of trying to ruin all these
transitions on the UI thread so platform
to run later provides you a cue in which
you could just say run this when you
have some free resource and usually it's
pretty quick sits just stacking up those
animations one after another so to do
that we just put our transition onto a
runnable and then we just run the
transitions as it goes through so in
this example which is this is just a
small mechanism of fading out the block
that you have here so let's jump into
the walls of the code or handy back
codes been to walk through how it works
okay thanks Jim right so let's let's
start off with the main classes how's
how's the code looking for equal as that
will screen that is that is that
readable yep okay well first of all
should we should we see it in action
yeah
so it's kind of similar to before this
is actually with one of the random
interpreters in place it's the same idea
as before as you can see in the
background actually we're getting it's
actually trying to get new T labs and
actually performing young collections so
we'll step through the act the actual
model the way it works one of the
problems that we do we have with us we
need some more interpreters because
these don't actually model the way that
memory actually gets allocated because
all it's doing is it's actually killing
off a slightly slower rate than its
allocating actually more things need to
die um but you know hey that's just us
to view to the way this has been
designed is that we can we can actually
fix some things and I think this one
will probably give us amount of memory
exception finally yeah we go okay those
are our memories cool okay oh yeah so
let's take a look at that the code in
some more detail okay so this is this
was the slightly tweaked version of the
the Mac the main class which the only
thing we've done is we've also
implemented stop method and basically in
order to have a good shutdown hook on
the on the controller basically you use
this trick of actually get a of getting
the controller back from the loader and
then calling a halt simulation on it and
then the whole simulation shut down to
thread pool so this is the main
controller block and from that when we
actually run the application you see
there's a there's a two-phase thing
first of all we set up the values that
we want for the different memory sizes
count of three
and then kicking off the begin button
activates the grid paints so the grid
planes are basically are added
dynamically after you've chosen what
what what values you want for them and
then from this basically it's been
factored out so there's a there's a
height constant which which we need to
change at some point basically the idea
is is that when we get some more cycles
will make it so the height of the
simulation is also variable and then
that way you can you can show to more
allocating threats so here's the calls
to the initialized memory of you that we
showed in the spice yeah I now here are
the allocating threads so basically the
way that these work is like this these
these are basically implement callable
because what's going to happen to them
come back to the controller is that
they're going to get submitted to an
executor service so the executor service
is just a standard Java util concurrent
it's nothing special to javafx it's just
a standard Java util concurrent thread
pool and essentially in the current case
I've got only got two allocating threads
but we're going to carry and working on
the application to add in the ability to
have more different kinds of threats
with different kinds of interpreters so
let's show you what an interpreter it
looks like ok so inside here you can see
i'm importing a couple of classes both
miss class called opcode and these are
basically the basic operations that we
might want to perform on a memory model
we might want to do nothing we might
want to allocate a block we might want
to perform a large allocation now a
large allocation would be one which went
straight into tenured and that's not
actually implemented yet but there's
flexibility in the model to do that as
well or we might want to have some sun
block style
okay so like any good opcode the
instruction might come with a parameter
so there may be a parameter which tells
you which block to kill off that's
typically the use case for that and you
must have an ID which is the thread ID
because if I come into the memory model
this too is runnable okay so basically
when we wrote this to your
multi-threaded it worked great in single
threaded mode but actually when we try
to generalize it into writing a good
multi-threaded version of this it was
actually very difficult and what we
found was that there were huge
visibility problems actually trying to
make sure that the actions taken by my
one allocating thread were visible in
the UI and to the other threads was was
actually very very difficult if the if
the allocating threads had true
visibility of the model object so that
choose to be a very difficult
concurrency problem to solve so instead
of which we decided we would cheat when
when faced with bad concurrency problems
cheating is usually the way to go so
what we actually do find a bit of code
is we have this thing called BQ and BQ
is basically a blocking queue of memory
instructions so what happens is each
interpreter interprets its file or does
whatever it's going to do in order to
generate the next instruction and they'd
play system on a queue which go down to
the model object and then of course the
model object itself now has to be
rollable and the actually runs in its
own thread and it just basically reads
off the queue so if you're familiar with
other languages like like scholar or
closure this is actually quite similar
idea essentially rather than rather than
trying to have a reference to the model
object and directly manipulate it you're
actually parsing instructions over to it
which it's going to handle a bit like an
actor word okay so that's that's quite a
neat pattern for doing that and then
that way there's never any visibility
problem because the the things which the
model is holding maybe the memory pools
never never
12 two other threats so that means that
the model of memory that we have is
always held completely consistent so in
most cases we don't really have to do
any synchronized okay so let's look at
the big run method from from the from
the model object this is also how we're
able to simulate this and to do testing
of this outside of the JavaFX part it's
because we've got this mortal object
which is which is separate from
everything else so what do we do well we
pull in instruction off the queue
there's just a big while loop here with
a switch statement and as you can see
I've got and is shut down flag which
will be a volatile but bulleen which
indicates that we want the thing to shut
down yeah and so this is just basically
a standard interpreter pattern for for
handling instructions which come in and
then basically for an allocation I call
the applicant method and for a kill I
call destroy so let's have a look at
those so basically allocate i call it
with a throw by d and says this thread
marks to allocate a block so i've
actually got a memory block which i'm
calling from a factory so inside here
we've got a volatile sequence number
which is basically used to to get a new
block there's a couple help constructors
in there as well so I've got this one
which is get free walk as well as as
well as a get block and so this is
actually the only bit of code where I
need to worry about threading
particularly I just have to make sure
that it's not possible for two for two
threads to end up with the same block so
the rest of the block is very simple it
just denotes the ID the oval our
allocation idea of the block the
generation of longs to whether I've
touched it so what I'm doing doing mark
and sweep which I'll show you the code
for in a minute we actually do go
through and actually touch them things
and we have the memory block view so
there's a reference between the memory
block and memory block view and the
memory status
so it's very but via code now and then
this actually has a back reference
speakers both both of these objects need
to be able to communicate with each
other to 14 when they die here are the
bindings that Jim was just showing you
earlier and yeah alloa cyst is really
very very simple stuff so how a code for
that let's come back after the memory
mark so yeah so we're allocating so this
point we've got we've got a nice memory
block it's not attached to a view at any
point so we add it to our allocation
list which is the global list of all the
objects that the JVM has and this is an
exact model the way that the JVM does it
that it has a global allocation list of
every object that's ever allocated and
it uses that to walk through when when
deciding what to sweep bit lower down a
bit of java effects stuff here in order
to actually trigger proper bindable
behavior there's there's get value and
the get method and it's really not clear
from documentation but you always need
to use get value if you if you're going
to actually have the binding work
properly if you use get it just won't do
won't trigger bindings from that we find
we walk through we find the first so
basically what this loop is saying is
this is Walt currently lab so for this
thread it walks along its current t lab
and see if it hits the end of the
Pacific and find a free block if you
can't if it finds a free block great it
allocates this memory block is just
created to that thread and if it can't
well now we allocate a new T lab and
then if we manage to get the new T lab
that's great we know that offset 0 is
empty so we put the block there and then
return from this method ok alternatively
if I can't get a new tailor that must
mean the evenings for
so if he evens full I bet a collector
and then at this point if even is reset
to the young collection so we get some
log lists saying just try to do a young
collection so we've got a thing called
evacuees and basically but the young
collectors are all evacuating so what
that means is they're going to step
through the the memory pools they're
going to find any live objects and then
they're going to move them somewhere
else so the space which gets left behind
is always totally blank and that that's
modeled by this just local variable of
that evacuees here step through that if
we ever find an allocated one we mark it
to say I've seen you and a popular DJ
evacuate list the reason why this
marking business is here is because it
didn't quite get it working but the aim
is to also have the young collectors run
in parallel so that at the moment
everything you know is single threaded
because the model Reese events one at a
time off the queue but in practice in
the real garbage collection that the JVM
does actually it stops all the
application threads and the collections
running parallel in this model it's
slightly different the moment because
events are still building up on the
queue so the marking is really there for
for dealing with multi threaded and
assets of garbage collection which are
coming soon okay at the end of the at
the end of the pass we've got bunch of
actuaries and we send them off to
survivor space and once we've done that
we reset even talk to free space we
reset all the all the T labs because
we've got this thing which we call
thread to current t lab so that
basically you're threadid maps against a
row in the grid pain and then it would
see which the end of the the to leaven
you need a new one you get the first
next one that's free and that's how we
handle the T labs and so this is how the
resetting of the teal apps work
so you throw this your end value of the
teen um and then you just put so the
zero thread starts off with the 0th row
of the grid pain first starts off for
the first etc and then at this point you
have to walk the entire allocation list
for everything which is not now undone
market okay and this this again is some
isn't it is supposed to model the
equivalent phase of GC okay so we just
try to move stuff to survivor space and
at this point we then have to check with
your space to put things in and if
that's not the case because this check
here is a bit probably is explaining but
if the number of acuities we've got is
bigger than the size of the one of the
survivors faces that means we won't all
fit in some other spaces and we've got a
pushed off into tenured so if we do that
then either we just we just shove
everything to 10 yet but we just check
to make sure that we don't have to come
to compact the 10-year t'kul space first
so let me just show you this this is a
lot easier to see on the on the actual
natural demo so basically you know we're
allocating objects objects are dying
everything's fine get our first sound
collection starts dying epic deal budget
stuff ended up in tenured but notice
only it was the only the generation two
objects so this is an example of what we
call premature promotion so objects are
supposed to reach a count of four before
they actually make it into into the
final it's the tenured space but if
there's a lot of pressure coming from
even space like there is this example
then it can actually be the case that
objects promote
before they before they make it now at
this point it's going to compact the
tenure generation ya know it's just
enough space in that to make everything
fit ok so the tenured space the old
generation has to be compacted if it's
if it's if it runs out a size ok and
then whether we have two compact nu it
or not at this point everything should
be fine and let me show you so these are
how we we deal with memory pools
themselves each Mary called has got a
factory and we can try basically we have
very simple methods to add a block to to
a memory pool to return a value to reset
and then tenured has this additional
changes like a special subclass of
memory call and it has this this way of
trying to compact yeah there's some
detail about how the how the premature
promotion works so effectively if we if
we find ourselves down here this means
that we basically we need to we need to
promote so this constant is a tenuous
hold and that's normally for if you play
with the garbage collection subsystem
flags 20-degree something weird happens
and that number jumps to 15 and that's
not very well documented so if when
you're actually doing this with with a
real garbage collector that's one of
things you just need to know and then
basically you will only move stuff if
they're actually if they're actually
factually thought but then for the
premiership promotion you can find
yourself having to move entire
generations of objects are just because
there's no space in what's left behind
and this is how we do that
yeah it's in this code does need to be
slightly better documented so so please
send me four requests and a lot of this
is is actually very very similar to the
way that the garbage collector actually
works the algorithm is not precisely the
same because we're doing with a
simplified situation because we don't
have to do a complete walk of all the
object trees none of these blocks refer
to each other each one is just a
free-standing block I will s do a little
more than the interpreters one of things
I have in here a bunch of test cases so
here's an example of a completely
deterministic my memory in temperature
basically it's very straightforward once
you've triggered it all it does is on
the fifth and the third of every five
blocks issues to kill instruction and
otherwise issues and a lock so so out of
every five blocks that you that you get
you get to live three live ones out of
every five so here's a random one
basically depending on its its
particular probability it just cause my
fandom and then I'll gates you either it
does it does something slightly sneakier
because what you always want to make
sure is you always want to make sure
you're allocating slightly more than
you're leaving behind so it sets itself
up so that it's the sequence is either
allocation allocation or allocation kill
and exactly which sequence you get
depends on just some random numbers and
if flip back to the controller we can
see how that works so my typical value
here is no point to
mandame go yeah so if i run this now we
should end up with a situation where
allocating about only about half as many
XS blocks so i should lead to a few more
collections before actually turns out
actually that's why that dancing so the
other thing that we really want to do is
I want to extend this to actually deal
with real garbage collection mugs I want
to it to actually basically take in the
garbage collection log and output a
stream of instructions that can be run
through the simulator I'm still haven't
quite figured out how we're going to do
that yet but it's one of the one of the
next term next priorities for the
project
you can see that it's actually it's like
it's going to take a lot longer to
actually run out of memory all the all
these examples will actually eventually
always run out of memory but this one
should now take a lot longer because
it's now killing a lot more does anyone
have questions about the code other
areas people want to see you want to see
some more of the test cases yeah oh I
like this one so these are all just
actual general general regular j unit
tests there's nothing special or magical
about them we just use the countdown
latch to land on a particular starting
point so they can execute a service we
provide these these sets of strings and
these passed into the classical that's
called the memory interpreter file
loader and this is just a very very
simple partha which basically say well
it works like this essentially there's
the whole of the parsing is taken care
of inside of the scene on so I've got
the opcode types and the way that I've
set up their constructors or an alpha
and then basically you construct the
token compile the pattern inside that
and just checks to see whether it
matches
so that basically allows us to do all of
them all of the file parsing for the for
the simple interpreter format in just
like 20 lines of code and then that
means that we can have test cases like
this which say a bunch of Alex whole
bunch of kills a bunch of kills shows
are all this stuff completely
multi-threaded wait till the thread
pools are shut down and still pass the
assertion okay think we're about out of
time questions from memory will be where
else
okay so in this would be in the
allocation so so ah yes that's true but
we don't actually touch them from here
so basically if you get value and that
just Dutch returns of a little stack
frame yeah from that point on we call
set block yeah oh I see you mean here
because it's the actual absorbent
property is this thing is the memory
status so so so okay okay so basically
you're saying that this line ought needs
to be called from the FX read Rowland
yes that's probably a bug hmm haven't
noticed any so far but it probably is
worth having a better investigation that
line of code yeah yeah that made I may
even obscuring this behavior I mean all
bothered this just line of code here
maybe I'm scaring that behavior because
it just though there was nothing about
it why should be working on it was just
trial and error and it was just like
right the getvalue works
children no no that does guns fine i
meanit's patches are always welcome one
thing I would be interested in is just
finding out where we use platform run
later because kind of based on your
point that web doing stuff on the
background for it i'm pretty sure that
by by using platform dog run later to
sort of hive off some of this animation
is that possible without being on the FX
road right so we do use that um i'm not
sure where ok so i think i think what
we're doing here or at least logic
behind it is we update the binding and
then we run the transition on the
background on the FX spread on the run
later it is foremost to ever there are
places where it's actually doing more
than that ok so toilet person so good is
there a method Hamels interface to the
to the platform to run later if there
isn't we should talk about that
hey any other questions and we want to
send me a pull request hey let's go</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>