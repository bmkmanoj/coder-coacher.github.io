<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>All Power to OpenJDK: Porting the JDK to PowerPC and AIX | Coder Coacher - Coaching Coders</title><meta content="All Power to OpenJDK: Porting the JDK to PowerPC and AIX - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>All Power to OpenJDK: Porting the JDK to PowerPC and AIX</b></h2><h5 class="post__date">2013-01-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/rwt4GIiLeVo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this is cool oh I can hit that's right
now I'm very loud haha way can you him
know oh yeah okay think so it was okay
so IBM versions bane of their own based
on the same code base don't don't touch
it down okay so yeah okay this was like
day 4 of Java one you know rather than
sort of day two okay so I be inversion
is based on the same code base I do that
on the same code base as the one used by
Oracle so it's the same kind except for
we have a different vm we have j9 and
that's ibm's vm and it's been around for
a long time and it's the the one that
you'll get if you're using an IBM
production version on on any platform
that we provide you get j9 and it's also
the same vm is also used in our linux
powerpc offering as well so j9 is the vm
we use everything else which is ok sa p
needed to to do more than that they need
to take the whole code base they were
looking for I think more similarity
across platforms etc and they also do
more more architectures and hard way
that we do and I believe I've missed one
out which you told me about it i'm
afraid i forgot that zed architecture
sorry some new thing that date john do a
bitch announced on on on sunday so
basically we're in the same both SAPT
and IBM are in the same space we're
using the same code base and what
openjdk started it was pretty much a
no-brainer at some point we have an AI
exporting project because their
similarities with linux because it's
linux powerpc there was obviously that
we were going to start doing the same
sort things together so the initial
goals of the project
obviously the first thing from from
anybody's point of view when you're
going to start a new piece of hardware
is to get the interpreter working and I
believe that was the first step provide
a full set of tools and classes for AIX
on linux on power PT 32 so you let's get
it all working provide a complete
certifiable jdk 7 on linux so that's if
you look at the terms of goals you start
off with what you've got you make it
work you get it certifiable so you need
to do that on linux may I X and then
move on and these aren't necessarily i
think goals that you might argue are
going to be done in order it depends on
circumstances but there's also move up
to making sure that you use the latest
and greatest hot spot technology get
everything running and eventually when
we can demonstrate that the exporting
project has a code base that includes
you know the hot spot Anna and the class
libraries that's good and its production
quality then we would obviously want to
come and start talking to the other
parts openjdk the head guys and start
saying can we get some other changes in
can we what do we do to merge them
together so ultimately we'd like to be
in the position where there is no
porting project it's all gone away and
that AI x and linux powerpc come
straight out of head and we're all
playing in the same space so then we
said we'd be worthwhile just explaining
about starting an open jdk porting
project and the three simple are not
simple steps so i write down what i
think the three basic steps are so
there's the first thing which is getting
agreement and project sponsorship I
think like all these things is lots of
smoke and mirrors you have lots of
conversations you talk about it and then
suddenly it all happens so I think if
you were starting a Ponting project
yourself the mechanics are getting a
project going as far as OpenJDK
concerned quite straightforward the
rules are properly defined it's easy to
understand what you have to do I think
the important thing is with all these is
getting
the the supports behind the scenes you
need to have everybody convinced that
this is something worth doing and that
the sponsors are going to support it and
those sorts of conversations you tend to
have not on email but face-to-face or
things like that so there we go so I'd
say that's probably the hardest bit is
to get that sort of consensus going then
you've got actually creating the project
the proposal which I think we did pretty
quickly I don't think that was that was
fairly straightforward to describe what
you want to do I think it was quite
clear what we came up with its we're
going to port the code base to a new
architecture with the objective that at
the end of the day it will no longer
exist because the codes moved up into
head IBM added an extra a extra
requirement which was to find ways of
supporting the J'naii vm in the mix
because that's where we're competing
with Oracle and that's important to us
and that mentions things like the CV of
my project which if you're really
interested is happening in this room
after this session as a hint so we have
the proposal which says what we want to
do and then we had the vote and again
the vote was again very very quick I
don't think we had any real issues for
standard two weeks the standard two
weeks but I think the point is the
mechanics of getting a project nope
jeddak a running is really simple the
hard bit is the bit that's not written
down is talking to people to make sure
that you're going to get the necessary
sponsorship that you need so I'm now
going to hand over to hop to Volker
who's going to tell you about the hard
bit of the project and then we'll come
back and we'll talk about some of the
other challenges we've got
so actually I will say some some words
about the historical recipes perspective
so we support the 15 platforms which you
can see here and yeah we our focus not
on the tips of our support so many
platforms you also support many java
version like four five six and seven and
really support him until the end of day
so our customers they request from us
very long support times and for example
jungle for Michael I don't know how long
do we support java for next 5 20 70 so
five more years so it's 27 t 17m
swimming 17 okay I feel like seven
awesome climbing all right yeah so our
whole JDK is built on the source code
from horik oh and we have built in Simon
hands with most in this portability area
but also some also in the area we also
build their own profiler for example so
and as you already work on this VM since
about seven years our code base already
diverged quite significantly so that
that's one of the reasons why we decided
it would be a good idea to to bring our
port into the OpenJDK so that we don't
have this much hell which probably other
people which do openjdk parts view as
well so I think you promote that you
have the same problem is iced tea that
you have big patch sites which always
have to integrate with every new version
so that's I mean it's natural to to get
us the the change-up stream
so it also took us a long time
internally to convince our our
management and our developers it should
be a good idea to take part in the
OpenJDK project and when we want nearly
there oracle acquired sun which didn't
make things easier but finally finally
you really managed to get approval for
all this and then it last year donut
helped really a lot to bring together
the people from IBM which doesn't yeah
as Steve mentioned we finally announced
the project so now I will see some more
technical details about the project so
the hotspot virtual machine is quite big
it's about 1,700 files about 340,000
lines of code and it's mostly written in
well it's completely written in c++ and
assembler the hotspot is quite well
organized it divided into share part and
then it has a special architecture
specific parts for all the CPUs it
supports and it has specialized specific
parts for the operating system it
supports and then there are even parts
which are depending on operating system
and architecture
the java class library it's not
organized that well unfortunately they
only have a distinction between Windows
and not windows and not windows is
supposed to be all the UNIX
implementation and Mac OS and this is
one of the difficulties people like you
from IBM place when you put it to ax
because all the not windows code is a
huge bunch of if depths for every single
architecture and that's was this is the
way how we did it as well when we
started because it's ok in the solaris
branch they have if there's for linux
okay we put in some for HP weeks when we
started and then we put in some form ax
and then you put in some point is 400
and well that's how the code looks now
and I hope that we at one point in time
we can really fix this and make the
class level is the native part of the
class library at least as nice as the
hotspot so the hotspot vm itself it's
also already quite old it appeared in
Java 1 dot 3 and since then evolved a
lot so it contains not a single VM but
it leads many VMS which are inside it
has two interpreters the template
interpreter into c plus cos interpreter
the oracle supported platforms all use
the template interpreter now the c++
interpreter was initially created for
the Itanium port which then was dropped
in one dot for they have to just in time
compilers to see one client compiler NTC
to serve a compiler one compares faster
the other does better code and well a
lot of different gc's which they also
want to get rid of now and all that
stuff in there are and all these parts
which I meant mentioned they are of
course highly architecture dependent
then there are parts in the hot spot
which are more operating system
dependent like for example the memory
handling the sweat handling signal
handling and all this stuff but this is
at least or or C++ code and of assembly
code and then there are genetic part
like the garbage collector and the class
loader which you usually can just reuse
on hopefully just reuse and new
platforms so about the F up to port the
hotspot TM so I took some numbers for
the Linux 686 port so as you can see the
share part it's about some what 1,000
files and 100,000 lines of code is the
same which you can the same code which
you can use for architectures but then
then the Linux part is about 9,000 lines
of code the linux x86 specific parts
three thousand lines of code and the x86
cpu specific parts ninety thousand lines
of codes so this contains a lot of
assembler code and actually the code is
not written in assembly itself but the
hot spot contains a macro assembler
which is written in cincy and we just
used inside the hot spot to generate
code for the template for the
interpreter and also for the JIT
compilers so for historic reasons well
actually when we first when I CP first
started to evaluate the hot spot we
started with a port of Java one dot for
on hp-ux and reported the template
interpreter for that architecture that
worked pretty well but then for some
time we experimented with other VMS and
when we came back we had to do new ports
for powerpc and italian very fast so we
decided to go with the C++ interpreter
so all our new ports like Italian
powerpc and that architecture they all
run with the C++ interpreter C++
interpreter is a little bit misleading
because it still contains a considerable
amount of assembler code it contains a
frame manager which is used to push
intel to prevent it for every java
invocation we have to build up a new
interpreter frame on the on the stack i
also show a sense it's some more detail
on the next slide so the just-in-time
compiler we disappear because SI p
supports server deployments mostly we
decided to implement the sea to serve a
compiler which is considerably larger
than the c1 but which produces faster
code which is better in the server
environment so as you can see the JIT
compiler alone has about twenty-five
thousand lines of code for x86 if you
have to implement it and then for
example the OS specific part for ax that
again fifty thousand lines of code this
is mostly because I X differs
considerably from from Linux in things
like memory management sweat handling
signal handling and things like that so
as I told you we started to with the C++
interpreter which has this so-called
fray manager and it worked like this
that every time a new Java frame is
pushed on the stack actually to see the
but the C++ divider contains a big
interpreter loop which is written in C++
but every time it does an invocation of
a new Java frame actually the C++ in
Twitter returns to the frame manager
which is a piece of assembler code which
has no frame it's a fabulous method and
this frame manage just pushes the new
Java frame onto the stack and then
invokes the C++ interpreter loop again
so you you end up with a stack off of
native Java frames and have only one C++
interpreter loop on top of
strike which saves a lot of space and
leads to a continuous tag so the
colleagues from Earth which did the zero
port they actually wanted to get rid of
this assembler code to make the ports
faster but that leads to two different
stacks where you have Java invocations
in the sea heap and native stack in C++
which makes it not so fast like the this
technique with the frame manager but of
course you save the implementation of
the C++ of the assembler steps frame
manager so the first step when starting
a port is of course to implement a macro
assembler which as you can see here is
alone about a thousand lines of codes
with x86 and for powerpc it's about
9,000 lines of code so once you have
that you can use it for the C++
interpreter for the file manager for c1
and c2 c2 they all use the same frame
manager at the same across embla well
some words to the sea to server compiler
it's the biggest and most complicated
part of the vm the biggest part is in
the directories I notice I showed and
the C++ other the c2 compiler works in a
way that you have to define your
processor architecture and you're
calling conventions in a so called ad
file with the architecture description
file and the hotspot itself contains a
DSC compiler which is absurd
architecture definition language
compiler and it parses this ad file
where you define special assembler
encodings for your abstract nodes of the
of the java AST so the java bytecode is
passed and
the Java compiler the compiler builds
abstract syntax tree an ideal graph of
your java bytecode and then this ideal
graph gets get match gets matched
against the nodes which you define in
this abstract definition language so for
example you define a note for for ad
which takes two registers as input and
this can be matched against the add node
in your ideal graph and every node in
the ADL see in the ad file has a mid
method which emit machine code for this
node so this is basically how the sea to
serve a compiler works and this is the
biggest part which has to be done when
the sea to serve a compiler is ported to
a new platform so I try to write to
remember some of the plat for 6 which
bothers this as most so one of the
problem is that we support three power
architectures five six and seven so six
was a little bit different because it
had it switch to in order execution five
and seven they head out of order
execution so this forced us to implement
a scheduler for power 6 to avoid
performance regressions and for this we
had to implement an extensions to the
aad 88 absolute actual definition
language which so-called with so-called
late expand nodes yeah we also had
implemented trap a star checks cause an
egg on powerpc you have a trap
instruction which is much cheaper than
comparing against now so it raises traps
and then you can handle a notch XOR out
of out of bounds exceptions faster this
was not in the hot spot code when we
started with the port yeah well PowerPC
is a weak memory model which is also
which was a big problem in our ports
because all the architectures and
platform supported by sun at that time
who are not weak memory models so there
were a lot of places where we had to
insert memory barriers to make the code
correct and we even had to insert some
memory barriers in places where they
were not strictly necessary Nessus
necessary for from a correctness point
of view but if they were just needed
because ASAP as well most developers
they work on x86 systems and they called
it a programs in a way that just
expected total store order and so we
think we've gone the way to put more
memory bears the necessary to the
coaches to make it behave like on x86
for example for object initialization we
did this so because many times
developers they don't protect shared
variables they don't declare them as
volatile or don't protect them with
synchronized blocks to access them and
then they are very surprised about the
effects they get so office eggs I exit
the same there's a lot of difference
compared to Linux and another problem is
that we have to support old ax versions
starting from X 5.3 and also the as400
operating system where we actually use
the ax portability be portability Billy
library like Cinco space or something
like this so actually it's the same
binary which ones on IX and is 400 but
nevertheless we had to do a lot of
specific things for a s400 as well
yeah for example there are things like
shared memory handling which is
completely different or large page
support also this text i'm not page
aligned on ax so this gives you a lot of
problems with the shared code which
didn't expect that to stack this the
memory stick is not page aligned and
then you have problems placing the guard
pages around the second things like that
so what are the lessons we've learned
hotspot has a very steep learning curve
so you don't find a lot of documentation
for it the only only way to to find out
what is happening is looking at looking
at the source code reading the source
code and trying it out that's what
you've done yeah building is hard
testing is hard there is no test
infrastructure for for the hot spot in
the jdk so we just get a bear source
code from from oracle now of course
there is the tck which is compatible
java compatibility test but that's not
really a good test for code quality you
can pass the tck but still have a vm
which crashes every now and then so on
yeah and also the to support on exotic
platforms it's is very limited so you
may think that Linux is Linux and you
can use all the Linux tools but if
you're run on Linux powerpc a lot of
tools which you are used from x86 like
Oh profile for example like the gdb
debugger they just don't work that
stable or ended way that you are that
you know it from from x86 and the same
applies for ax they have some very good
tools for example profile is very nice
but actually we never got the bigs
running stable so
perhaps you can help us here yeah we
also notice that convergent evolution is
really evil in the software business
what I want to say was this is that we
realized that in this five or six years
where we developed our subsidiary
parallel to Oracle they developed a lot
of features which we developed on our
own as well and this this makes the
support and the integration of new
versions really very hard and we really
hope that we can consolidate now our
changes which we have done with the ones
from Oracle bring the one hours which
are good into the openjdk and throw away
the ones which Oracle has implemented
themselves so he had the first milestone
to have a interpreter only way I'm
running the we've reached at in in July
on Linux powerpc so we can bootstrap
with our own vm now on ax you are still
struggling it compiles but crashes very
early but I hope we get that fixed
within the next few weeks in parallel my
colleague guts lindenmayer who is also
working on this project has already
started to see two compiler port so he's
ready working on the ad file of Power PC
and I think he was submitted soon to
into the repository yeah then we also
have actually I told you before our main
goal is to integrate this port into the
Java main line because only this may
really makes sense for us and we have
already started now to contribute small
changes in shared code which are
necessary for our port into the OpenJDK
and we hope that this will move forward
smoothly as it did until now so we
of a project page where you can find
some information about the project and
the mice goals we have a death wish and
we also have
yeah what I wanted to say is that you
have a prime paneer preliminary project
side where we can see the nightly build
results of our Linux and I export and
can download the build log so ever ever
it we've done this so that our
colleagues from from IBM
so you can go to the site from the
project side and you can see we will
build we will currently we build lean
excited linux x86 just to see we get no
regressions it will be built Linux
powerpc and ax powerpc 464 you also will
add windows so we can be even more short
to don't so we don't need to don't
create regressions in the in the shared
code well actually that's that's all if
you have some questions I will be happy
to answer them you want to say something
i'm going to read I get a restrike
something because I just I point go back
to the other charts but the biggest
problem that we have with doing this
we're doing this work is the testing
right and it's the fact that if we want
to show the this hotspot build on AIX or
Linux powerpc is good enough what do we
do so it's okay for a cool they can go
off and test their stuff and they can
run all the tests they can and it's okay
actually for idea of an essay p to go do
their internal testing but the the
ability for the openjdk community to do
this as a whole just for somebody else
to come along and say as an individual
I'm going to port the openjdk and hot
spot to some new architecture it's that
it's problematic you can do the co you
can do all this work but how do you know
it works you know so our biggest problem
the thing that we have to deal with is
the fact that we don't have the tests
that need to be run and then beyond that
there are simple things I build
infrastructure etc which is being worked
on but it's it'll take time but I think
the key the killer is as we have to find
a way of bootstrapping a set as
sufficient set of test cases that we can
all feel comfortable that it's just
doing what it's supposed to do and that
anybody else he wants to the
project and go off and build hotspot on
some new piece of hardware has a
fighting chance at making happen and
that I think is pretty much it unless
you want to deluge us with questions
which I will redirect to
volker because they other we about
possible
yeah actually we did the c++ in the pot
interpreter plots much before you
started with zero so it's already five
years old so when Gary stopped it we
spoke with him and we looked at this
work it was very interesting for us but
at this part time we already have it so
actually many people when they hear
about the powerpc project says says I
think that they don't understand why
they don't understand that you already
have it i think we've stopped to promote
it now in the openjdk which is not true
because I say P has this port and when I
explain them that you have it they don't
understand why it takes so long but the
problem is really that there is code of
seven years from us in there and we have
to to divide it out and to reshape it so
that it has as few share changes as
possible so that you can integrate it
more easily into the openjdk and and
this well it's not rocket science but
it's really time consuming problem to do
this yeah and I'd like to write the
other things we've discovered because we
tried getting shocked projects here are
running on AIX just ourselves and the
simple ones we couldn't figure out how
to do it we talk to Frederic when he was
doing the the new build systems that it
was older like this now still couldn't
figure out and I was sitting in going I
don't know whether the build errors i'm
getting why should be expecting I don't
know I I have no comparison so this is
my other bugbear currently with openjdk
is I have no way of knowing whether my
build results are what you're getting is
that what is happening in totally right
so I can't compare so if you have other
warnings or errors that you're bypassing
and I'm getting the same things I'm
sitting there going what ever done and
in fact it's not a problem because you
ignore it so yeah
block but for us it's really important
because you can see you can see our logs
at least you can see you know yeah yeah
yeahs beautifully yeah and and and since
I'm angry about this I would point out
we fixed it right what we did was we
built it and we put the results for the
buildup on the CR that you do your
results were you yeah I were publishing
them it's it's easy why can't Oracle do
it please you know they don't just it's
not just esoteric platforms either yeah
having having build logs of what the
build looks like our windows would be
immensely useful yeah as you're trying
to set up or Windows environment to
build a community yeah so we won we want
to know what what scripts use to build
things so we can copy them and then we
can have an agreed set you know so that
at least we can say if we caused me to
change and I built it using the
instructions that you use a nice i'm
confident and you're confident that does
the same thing and if my build log looks
like you're bored log then we're all
happy you know it's a good thing to do
and I really frustrate me that something
that is as simple to solve which is
you're already doing it you already have
the information is just stick out on a
web page please you know it's just not
rocket science we did it I mean I did it
myself and focus on a much better job
but it's it does just take your time at
all you know ok I'll get off my high
hopes now
good keep them coming keep them coming
yes
or
I
what I don't know
those little areas
where there's like
predicted
actually the good news is that you have
very good conversations with the hotspot
team and perhaps you notice that they
introduce the white box testing
framework into the hot spot some time
ago also it's empty until now and you
are really planning to extend this and
and provide some of our tests which we
have to the openjdk it will need some
time what we are really willing to do it
and I hope we can push it to the English
in the shared code and in the main line
this could help you as well
of course
yeah yeah it's called standard operating
environment and you put some checks in
your code that says have your all you
expected and yeah or at the very least
that you capture what vegetables you're
using yeah as part of the star to be
available I'll get and then by
publishing the world of people can
compare and adjust and say are actually
use inverse of fresh mex I'm using brush
why yeah that might be why it's failing
at this point
No
or
right yeah but it's easy it's a
diagnostic capability of being able to
because it basically you only care about
the differences at the point of which
it's causing the builder not to succeed
properly and at that point you can you
can determine you can you know if you
have the information does capture the
gold logs it's normally fairly
straightforward determine which of those
things is actually there no the short
list of likely candidates but the other
thing that I'd just like to point out go
and reach the fast audience the other
thing that I'd like to point out is that
is that the work that was done with the
mac OS export as you know yet yet one
more unix into the mix has actually been
it's been both a disrupter too because
you know our hex code was sitting on
something that didn't have that but also
it's kind of been there it's been a in
some ways a creative disruptor they've
done some really good stuff there about
about you know recognizing that the
point of which you're you're moving from
two different types of unix that your
your your effing for the three types of
unix at your effing for and you know
there's a possibility of probability of
more coming coming along that's the the
increase that that's really useful in
that the increasing number age you know
the the work that's done by the mac OSX
folk what has has helped us and will
help us in the in the work to integrate
the xcode in a way that's then will help
the next the next type of platform that
comes comes along
so so that's that's just like to say
that because that's been really useful
yeah yeah I was going to bring on the
changes maybe 30 40 changes in the class
libraries I mean obviously the
architecture is different but in terms
of what we made the class drivers get to
build and basically run I think really
small things you know where's they had
to file things are that
oh ok Wow okay thank you very much for
coming yes</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>