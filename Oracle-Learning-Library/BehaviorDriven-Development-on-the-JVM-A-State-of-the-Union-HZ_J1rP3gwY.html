<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Behavior-Driven Development on the JVM: A State of the Union | Coder Coacher - Coaching Coders</title><meta content="Behavior-Driven Development on the JVM: A State of the Union - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Behavior-Driven Development on the JVM: A State of the Union</b></h2><h5 class="post__date">2013-02-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/HZ_J1rP3gwY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thanks for coming everyone today I'm
going to be talking this session I'm
going to be talking about a topic which
is close to my heart behavior driven
development my name is John smart if we
don't know me from other talks or
whatever I come from Cindy Australia
where I help organizations out with the
technical side of agile development so
things are continuous integration
continuous delivery test-driven
development behavior driven development
test automation that sort of thing and
today I'm going to be talking about
behavior driven development in the
broader sense of the term who is
familiar with behavior driven
development everyone good who practices
behavior driven development a few that's
great so I'll be going through what baby
driven development is about at least my
from my point of view and then i'll be
taking you through some of the tools and
some of the techniques that can help
when you're using behavior driven
development right from requirements
analysis right down through to
development and acceptance testing so as
we'll find out behavior driven
development is not just a development
practice it's actually something that
can be applied right throughout the
development process which involves
virtually every member of the team so
behavior driven development there are a
few key concepts that come across fairly
frequently one of them is the idea of a
common language between developers bas
testers customers users whatever
everyone in the team really a common
language that that helps helps make
sure everyone is on the same page really
so it helps helps ensure that if you're
talking about a client in your
specifications when you're actually
implementing the code you're still
talking about a client you're not
talking about a customer or a person or
a user little things like that can make
a big difference sometimes this can
involve also
writing a sort of a dictionary which is
a fairly old concept other dictionary
where you actually describe the terms
are you going to use in the in the
domain language so it's somewhat related
to domain driven development if anyone's
familiar with that concept very simple
concept it's all about communication so
as in a lot of aspects of agile
development this is about opening up
communication channels in the team
another really key concept is that in
behavior driven development both of the
acceptance tests and the unit test level
you don't actually write tests I like to
annoy people sometimes I say I don't
actually write tests for my classes but
my classes get tested anyway but in
these people because I don't write tests
to write specifications so they just
happen to be implemented as tests just
happens just so happens that writing a
automated test is a really convenient
way of writing an automated repeatable
specification document this is really
applicable for acceptance tests very
true of unit tests as well as we'll see
so behavior driven development is about
specifications you are writing
specifications but you're not writing
them in the traditional hundred page
word document format you're writing them
as something that can actually be
executed and verified at each point and
that will produce what we call a living
documentation a living document that
describes your system we'll have a look
at some tools later on that can help
produce this living documentation so
reports that take your specifications
execute the tests produce a
documentation of what your features
actually look like when they're
implemented in the system so that's
really important another aspect is
structuring your requirements in such a
way that this can that they can be easy
to navigate and
and document so it's not just a matter
of having a whole list of cucumber or g
behave stories in one single directory
you need to be able to structure things
a little bit better otherwise it becomes
a huge mess behavior driven development
I think dan north talked about it being
an outside-in in something something
something outside in means that you're
starting from the user experience and
you're working in words so when you do
behavior different development you're
thinking in terms of what the system is
supposed to do what goes in and what
comes out is what's really important
what delivers value in a system it's
what comes out it's the outputs so it's
only very rarely do you come across a
case where the way you input data ads
business value to your application users
don't necessarily get business value out
of the way they input data they can add
business a can add business value by
making it easier for them to input data
but what they're really interested in
what the system does with the data in
most business applications may be game
to be an exception but in most cases
what you're interested in is the outcome
and on the other side you're the users
aren't going to be interested in what
happens inside they're interested in
what they do the system what comes out
so what do you want to test when you
demonstrate to a user hey this feature
works you want to demonstrate what the
user does and what the system produces
so it's very important thing to think in
terms of inputs and outputs not in terms
of implementation details and what
happens under the hood it's all about
value so we're all about trying to
figure out where the value comes from
when you implement a feature when you
implement a system what features you
can't shrine
implement to get the most value out of
the system so this is taking BDD into
the requirements analysis space where
you try to figure out you've got to
certain number of features which ones do
I have to implement which one should i
implement if I have going to get a limit
amount of time and resources what should
i do first so BBD is not just a
development practice it's actually
spreads out into the requirements
analysis space as well so in a nutshell
why do we now why do I think BDD so cool
it's all about well it's all about a lot
of things better communication less
waste so reduce eliminating waste that's
a really important one I've seen a few
studies that come up with figures along
the lines of if you have an application
that you develop you write a whole stack
of specifications and you write a
million lines of code to implement those
specifications it turns out that roughly
half of the specifications will never
actually be used I'm a developer I don't
care they wrote the VA's wrote all these
specifications for nothing now I don't
care bas might care now seriously that's
waste on for the business analysis side
of things but what's more interesting
for a developer's perspective is that
half of the million lines of code that
you wrote are never actually executed in
production that's kind of more annoying
I mean you could have been at the beach
instead of writing those five hundred
thousand lines of code and I've seen
those results in several different
independent studies so it seems to be
fairly consistent even the figures to a
couple of percent so traditional project
approaches produce an enormous amount of
waste another study us or recently came
out with projects using techniques like
this well it was TDD and acceptance
history
development and agile practices like
that now they you'd think that you'd
have to write more code because you
write more to made a test now that's
true but nevertheless these projects
were delivering thirty percent faster
than traditional projects and with four
times less bugs so less waste is a
really important thing and where does
the less where does reduced waste come
from it comes from improving
communication within the team improving
traceability so that you know why you're
implementing any given feature right
from the high level features down into
the details every line of code you know
what feature you're trying to implement
and what value the is expected to come
out of the system from that feature
which allows you as developers to make
judgment calls when you're implementing
features on the best way to do that
unless well encourages bas to get away
from the more traditional approach you
see a lot of big organizations where the
specification documents will be so
detailed that they will actually
describe the implementation which again
is as waste and the end result is also
incidentally it's sort of almost a side
effect you get really well tested
products because you have all these very
effective tests so you get very high
current code courage but i don't use
code coverage as a metric to aim for
just to have a high code coverage i use
code coverage is a negative metric if
there's a low code coverage i'll look
into it but when do you do this sort of
approach you get very high code coverage
very naturally but it's significant
higher code coverage and if you you can
generate reports to figure out not only
what code has been tested but what
features have been tested and how how
many features have been tested and
implemented so not just in terms bottom
up what code has been tested but what
features have been implemented top down
so on the Isle of these transitions on
the business analysis side everyone here
a developer are there any testers or the
AIDS or non developers out there this is
nevertheless interesting for to get a
picture of the global so the globe of
your thing so typically a project you're
going to have some sort of goal to
implement yeah a project has a goal
high-level business goal so the terms or
bit fuzzy here depends on your
methodology and your whatever is in
fashion this month but generally you can
talk about things like capabilities
features elf tandon agile projects
you'll be talking about stories as well
have some so you have some sort of
breakdown as the requirements that
support those goals or requirement the
point of a requirement is to satisfy the
business goal of the application so the
business goal is a very high-level
concept and all of your features are
supposed to support them now when you're
doing behavior driven development in the
broader sense more specifically what's
known as acceptance test driven
development or example specification by
examples another term you start from
examples of how the system works so you
don't start from vague specifications
you start from concrete examples you ask
really dumb questions like okay so you
want to build a payroll system what sort
of employees do you have do you have
employees at work for give me an example
of an employee that works for a
department give me an example of an
employee that works for more than one
department and so forth so you try and
come up with concrete examples of what
you're supposed to implement and how
it's going to the system's going to be
used and those examples become the
acceptance criteria more or less more
pretty much a direct correlation between
the examples you use will
see examples of this later on this is
just a high-level overview see examples
become the criteria that decide whether
you actually implement a feature or not
so at the start when you decide you
going to implement a feature you'll come
up with a list of acceptance criteria
very concrete cases that the testers and
the bees will say okay if the system
does this and I'm happy it should work
it doesn't mean you're going to not test
other cases but it means that that's a
general example of what the system
should do so start off with a general
very high level vision so this is
actually based on some real projects so
online classifieds where this is a
client they big media company got lots
of newspapers and whatnot they do
classifieds ads in newspapers which is a
bit of a dying industry that they want
to convert all that to online
classifieds so one of the things you do
with behavior driven development is you
come up with a vision and then you come
up with goals between to define the
reason so for example we've got a goal
you want to increase advertising revenue
by liking it easier for people to sell
stuff online that's your goal
then you might have you might come up
with the idea okay well that's going to
make that goal achievable to make it
easier to implement we're going to make
it easier for people to find out so
that's a feature we want to implement to
support this goal so these goals goals
of funny things they're all actually
they're pretty simple a goal is very
high level and you can recognize a goal
at least in commercial organizations you
recognize a goal because it's got
something to do with money as a rule so
I business goal that you try that when
in terms of the features you're
implementing your high level goal is
going to either increase revenue reduced
costs protect revenue or possibly avoid
future costs so very fundamental
business concept if you're anyone
working in public public organizations
government agencies government agencies
would be different they don't know about
profit they do know about sake us
cutting costs though that's a popular
one and value in public organizations
can be defined in other terms other than
money so there's the concept of public
service which comes into play so what
service are you providing to the public
and how can that add value provide value
to the public so that's a similar
concept when you're in a nonprofit
organization but in any business
organization that's typically about
increasing revenue reducing costs or
protecting revenue so avoiding future
costs is a variation on those as well so
if your goal doesn't have something to
do with if your feature doesn't map back
to a goal that has something to do with
one of these general goals you probably
want to think carefully about why you're
actually implementing it so that's
that's really important now the
interesting thing is that when you ask
your customers they won't what they need
they won't think in terms of
increasing revenue or reducing costs not
all of them some well if you ask
high-level executives there'll be more
at this level sometimes sometimes not
they should be more at this level but if
you ask a customer you'll prob often get
very concrete requirements does this so
ring any bells and ask customers what
they need those a chi want red button
here and when you click it it'll come up
with a PDF that prints itself
automatically and then sends an email to
Joe over there so they come up with
really concrete requirements so the
trick here when you're doing this sort
of approach is you have to basically
keep asking why until you get to one of
these business goals so you get to
something that's good to do with money
so you keep trying to what the term that
the some people use is popping the why
stack so you keep asking why until you
can figure out what the actual value
they're trying to get out of out of this
out of the system so here we've got our
fundamental requirement is what they're
asking for its they want to be able to
search by keyword so you go up the stack
eventually you'll figure out that it's
actually the core requirement is that
you want to keep earning money by making
encouraging people to put ads online so
it's quite indirect but if you from that
you can say okay that's the core
motivation sometimes there are several
motivations for feature but that's the
core goal of this feature and that gives
a perspective that gives a context of
the best way to implement it so
when you do this you can get a you can
get ideas of other possible ways that
might be better to implement to achieve
a particular goal and you can push back
and ask a is this maybe we could also do
it this way because what are the
problems with implementing what the user
asks is that's usually not what they
need initially because the whole
development process is an ongoing
learning process and it does take some
time to figure out what exactly you do
need so that's just the high-level
business analysis side of it that's a
technique that some people call
dependent feature injection it might
hear that term around anyone heard that
term no they that that's a term general
term that describes this approach now
getting closer to the actual code got
this you're going to come up with
features features in the generic sense a
feature as in a requirement you need to
implement so a requirement here we've
got a feature let's get more sales by
making the ads easier to find so from
that requirement with say okay our goal
is to make it easy for people to find
ads online so that they could the
sellers can sell more so the sellers
will post more ads with us so that we
can earn more money that's so we can
trace it all back to our business goal
you always want to be able traced up
back to the business goal so from here
we'll come up with a few features so
we've got notified potential buyers if
there's a new item that might be
interesting for what they might be
interested in be able to search for
stuff do you want to search by keywords
or tags or full text you could so there
might be different things you can do
different features you can implement to
achieve those goals and it's a judgment
call to know which features are going to
provide the most value in terms of the
goals you're trying to deliver
so the idea is if you have a good
picture clear picture of what the
business goal that you're trying to
achieve is it's going to be easier to
make a judgment call to say hey this
feature is sort of going to help but
this other feature over here it really
going to help so we'll do this one first
so the idea is that you're going to have
a set of features a minimal set of
features that will allow the business to
achieve the goal that you're trying to
achieve and then some other features we
more marginal so there will be a
diminishing return on the features that
you implement so this is fairly typical
of agile any agile projects of people
familiar with this format the in order
tool who are you who uses that format
for requirements there quite a few so
often you see it the other way around
you see as a seller I want buyers to be
able to blah blah blah so that I'll can
increase sales I find it more effective
to use this approach you say in order to
increase sales then use as a seller and
then the actual feature comes at the end
so why do we do that it's because you
want the emphasis to be on the goal the
goal is what you're trying to achieve
the person the seller as are the role is
pretty much secondary so this is how you
describe your features using a BDD
approach and now features can be at
several layers you can have several
nested features until you get to
something you can tangible it you can
implement so you're going to come up
with different different stories or
examples that will help you implement
these features so we might come up with
searching by keyword and location we
might say hey we want to search by
keyboard what's an example of someone
searching by keyword and someone might
say well my cousin Sally wants to look
for a puppy online and so they'll
go through that example say yes but if
they find a puppy that's a thousand
kilometres away that's not going to be
much you so maybe they only want to find
them in the city where they live so
maybe they want to be able to search by
keyword and location so you work through
these it come up with examples and come
up with features to support or feature
low-level features to support the
examples that you work through so it's
the fact that you're working through
concrete examples that lets you tease
out the features that you need it's not
the other way around if you come up with
sort of general abstract features and
then implement them often you miss
things and you have to rework them
afterwards if you start what I find is
if you start from the examples and your
work outwards and you say okay well
here's this example but what happens if
we do this come up with maybe another
feature that you need to support this
other example you can work your way out
and discuss exact concrete examples and
ask questions you come up with something
a lot more concrete than if you try and
imagine more abstract features that's
sort of a fundamental concept behind
this whole big dedee approach the high
level anyway so when you're coming up
with these features you can either just
find them in these sort of story
notation given when then so given Sally
wants to buy a puppy for a son when she
looks for puppies in the pits and then
it was category then she should obtained
a list of ads for puppies for sale and
sometimes you might want to make that a
little bit more general so what's often
used is this table format we have a data
more a data focused approach data-driven
approach where you have a set of inputs
and expected outcome so here we've got
given selling us to buy a present when
she looks for the present then she
should have attained list of matching
ads so this is a more general expression
of our requirement but then we have a
whole lot of concrete examples of how
that would work that's really good for
darfur anything to do with numbers so
anything to do with calculations that's
really useful to sort of approach
so both approaches are quite common and
you can use both and so these become
your acceptance criteria these are what
validate the the features these are what
demonstrates to everyone that the
feature has been implemented doesn't
mean it doesn't have to be tested
afterwards but it means that you've
implemented what everyone thinks needs
to be implemented so as I was saying you
come up with all these features but it
usually isn't enough just to have them
in one massive list of features you need
to structure them a bit so often in the
simplest case you can just structure
them in the directory structure so here
we've got a few high-level requirements
we got post ads purchase ads view ads
and so forth inside view ads we've got
search for ads and view details and then
in for the certain search for ads we've
got a few stories to the common more
concrete cases searching by location by
keyword by category and so forth so this
is just a way of structuring them so
fairly arbitrarily here i'm using the
one structure you we call the top-level
capability then we talk about features
and we talked about stories at the lower
levels now there are variations on that
and it's not particularly important the
idea is that you're going to have some
sort of breakdown some sort of structure
in your requirements so of course they
don't have to be in a directory
structure lots of places you can get
requirements but when you start thinking
about storing them you want to think
about how you're going to structure them
otherwise it tends to become a fairly
humongous mess so that is what I wanted
to talk about just from the business and
analysis and structuring side so BDD
actually starts way before you do any
coding but now we get to the fun stuff
so now what I want to talk about is some
tools that
support these now our people will who
will say the bdd is independent of tools
which is true but I would say that if
you don't automate your tests you're
losing a lot of the value of BDD because
you don't get the automated validation
the executable specifications there is
value in that business analysis exercise
of figuring out your requirement in that
sense but there's also a lot of value in
actually automating the specifications a
huge value in fact automating the
specifications once you've got them to
find so that do that every time anyway
so I'll go through a few this is a java
conference i'll talk about some of the
more java centric tools there are heaps
of them out there first one i want to
look at is jay behave who is familiar
with jay behave quite a few people who's
used to behave at school so Jay behave
is a fairly old frameworks been around
for a while it's been a in fairly
actively developed NJ behave you define
your stories concrete a story with
acceptance criteria in a dot story file
so here you can have a narrative section
which is optional I'd like to put it
there because it gives context and then
you have these pretty much exactly the
same text as we saw earlier on so given
Sally wants to buy a puppy and so forth
and give and when then you can also have
the data-driven approach that we saw
earlier on so have a set of examples so
given Sally wants to buy a present and
so forth she should obtain a list of ads
for the expected for expected for sale
so here we've got the present the
category and the expected so you get
different values being tested so
from there J behave is a Java framework
so you automate it in Java Sea start off
with your story file and then you
implement that in a just a normal job of
pojo with some annotations given when
then j behave matches the text that you
put in the given annotation the wind
annotation so forth and to figure out
what method needs to be run at each
stage so it's quite sophisticated you
can put variables in the given when
there's you read wild cards and so forth
passing parameters into the into the
methods it's a very rich and my fully
featured framework zone just sort of
scratching the surface here but just to
give you an idea now the disadvantage of
j behave is attacks quite a bit of
setting up so there's a fabulous code
you need to write just to get it running
so that's just an example of the sort of
code you need to run once for your
application to get all the tests running
and that's a very flexible framework so
there are heaps of things you can do but
it can be a bit overwhelming it at first
what I tend to do will be looking at a
framework on that i use on top of all of
these frameworks called thucydides and
that makes a little bit easier because
it reduces it to a one line class which
takes care of all the details for you
and when you do that you can well we'll
see the results later on but up on j
behave quite effective quite a nice way
to work when you're starting off with a
project be doing it if you try to add
these sort of stuff to an existing
project so you can do it in g unit as
well that works but it's a little bit
you don't get all that nice the nice
given when then structure for your
requirements so cucumber who to use
cucumber a few yep so cucumber is very
very very similar to j behave
almost indistinguishable in fact in a
lot of ways the stories in files called
dot feature as opposed to dodge story
but the syntax is pretty much the same
almost yeah on this side on the story
side is pretty much the same so you can
also have tables so that's pretty much
the same as well and then there is as of
recently a JVM implementation of
cucumber so in which does things a
little bit differently to j behaviour
more recent a little bit more annotation
based very j unit centric so you've got
it looks basically a j unit runner so
run with cucumber and then you provide
some cucumber options and then the
implementation looks pretty much like
the like the j behave one except it's
got lots and lots of reg ex so you have
to lie craig exes if your pearl
developers you'll be really at home here
so that's the big difference i actually
prefer the j behave notation because i
don't like regular expressions very much
but there might be just me yeah as far
as functionality goes they're very close
very similar so the third be DD to or
the acceptance test Levant level though
I wanted to look at is one called easy B
who uses groovy yep a few so this easy B
is a groovy based framework so the big
difference with easy B and the other two
frameworks is that in easy bit in j
behave on cucumber you'll have your
story file where you provide your
executable specifications and then you
have a java file that actually
implements them an easy being you have
both mixed together so you have here you
have your story file effectively that's
a DSL a groovy dsl so the syntax a
little bit more complicated than just
the plain text file you get in
J behave or cucumber and the there you
can do data-driven stuff but it's a bit
clunky are and then the difference is
that when you actually implement it it's
code that you put inside the inside the
story itself as opposed to in a separate
file so here we have the given Sally
wants to buy a puppy for a son and so
forth inside you put curly brackets a
closure and then you put the code that
actually implements that test so some
people like that some people don't so it
depends on your the nature of your test
as well the one disadvantage is that
this can get quite complicated and relax
readability so you're limiting the
excessive how accessible this is for
non-developers whereas when you're doing
such a behavior cucumber your
specifications remain in a very pure
text format on the flip side the you've
owned you're only storing the
specifications and the implementation in
one place so it's easier to keep things
coordinated yes
when you run both cucumber and Jay
behave if there is not an implementation
it will generate I won't generate it or
print out the the Java implementation
that you'd have to write that's both
cucumber and Jay behave do that so you
don't have to write the vector that's a
good point when you execute you're
basically you write your specification
and you run it and it will print out the
methods that you need to implement to
implement any missing steps so you may
or may not use them you usually use them
as a starting point and then maybe
insert your variables and whatnot the
fourth tool I want to talk about is a
tool called sue said it is which is tool
that we use and that we lead the
development on its don't worry about the
pronunciation just think of two CDs and
you it's more of this close enough it's
a tool that sits on top of BDD
frameworks like Jay behave cucumber ECB
and it also works with j unit as well
and what it does it it helps structure
your requirements and the reason is
called to acidities is that facilities
with a Greek historian he was the first
historian who actually participated in
the events that he wrote about so he
parties he was involved in a very big
war between two cities in greece athens
and sparta he was actually a general in
that war and when things were going on
and people were speaking and their
battles and whatnot he took notes and
then he wrote it all up afterwards as
opposed to previous historians who said
oh I heard a traveler who said there
were some dragons over in that country
over there so i'll write that down so
the idea of to see that easy is it
observes your tests tests as they get
executed and it reports on what actually
happened as opposed to saying this is
the specifications you
actually says I can hear the
specifications and here's what happened
when it actually got executed so what it
does is it recall at what observes your
tests and produces reports about what
actually happened so you get aggregate
reports of how many requirements are
actually matched to executable tests the
tests were executed how many tests were
pending and so forth and then you get
detailed story reports we'll see later
on with screenshots and whatnot if
you're doing web tests so in suse that
is well it works with you saw those
given when then annotations in Jay
behave and cucumber or works with them
but typically what you'll do is all you
will add a separate library where you
have your own your own more detailed
steps so here we've got given Sally
wants to buy a puppy when she looks for
keywords and so forth inside each of
those very high-level steps you have a
certain number of action some things
that happen so you don't want to put all
the page interactions here you know one
of the one a good takeaway here is when
you're writing acceptance tests make
sure you're very careful about your
levels of abstraction because the if you
have an acceptance test with chopped
it's very very common in all the
tutorials you see an acceptance test you
say ok then given the user wants to
search for cats on the Internet ok
they'll open the Google page and they'll
enter this into the field q and then
they'll click submit button you get all
that in the top level you don't want
that in a real acceptance test that's
your mixing levels of abstraction it
makes it really really hard to maintain
this into what this is what should be
happening so you don't want any details
about how it's being done so that's the
point of making a layer of abstraction
here so we've got this class called
buyer which represents what a buyer can
do so the buyer chooses category and
keywords and perform search so that's a
very very simple example but
and you'll have made more steps than
that and then in these details there you
actually talk to the page object so it's
familiar with page objects so page
objects a technique that you use in in
web testing to encapsulate your webpage
behind a class that gives a sort of a
DSL that describes basically how users
interact with the class so you don't
expose IDs and CSS selectors and xpath
and things like that outside the page
any code the talk straw page is within a
particular class and all the details are
hidden there so that if that page gets
changed you only have to update it in
one place and all the other tests remain
stable now this takes this concept takes
out a little bit further so you have the
concept of steps for a particular role
or a particular functionality or sends
on your application how you group the
steps but you have a set of steps and
those steps will contain calls to page
objects so interactions with pages so
the thing about this is it makes it
really really reusable so it might take
you two or three hours to write a first
test then we'll take you 15 20 minutes
to write a second test because you re
you're basically reusing steps and page
objects and putting things together like
lego makes it very if you write them
with a night with proper levels of
abstraction makes it very easy to reuse
and very easy to maintain so if
something changes again it makes it
easier to update with a minimum of
impact so that's why we do it this way
so that's what this step annotation is
about so in the reports so we get this
idea of a global report which summarizes
all of your requirements so you've got
this concept with these reports of
top-down requirements reporting and then
bottom-up test
results so from so you see these will
look at the requirements that you've
defined in Jay behavioral cucumber or
whatever it's okay you've got all these
requirements I want to see which tests
actually map to these requirements so
and then if you as I was mentioning
earlier if you structure the
requirements in a reasonable way so you
you don't just have a list massive
directory full of requirements but you
also have your features your
capabilities in an organized way then
you can drill down into particular areas
and see which features how well certain
capabilities or features are implemented
which ones how many tests are done for
each for a particular feature and so
forth makes the report he a lot a lot
more relevant so here for example we've
got posting a new ad nothing's been done
at all so that means no tests have been
reaching it all there or some tests have
been written and they're all pending but
it can also mean that there are no tests
you've said here's a requirement that we
need to implement but we haven't done
any tests whereas the search for online
ads we've got some tests that are
passing and some tested appending or
maybe some tested some requirements that
have not been tested at all so this idea
of it's a soda like coke arrangements
not to do with coders to do with
features and feature coverage if you
like now take to your requirements and
figures out what's that what tests
actually work for those requirements and
that's really powerful because you can
come up with a very good idea of
progress in a particular sprint get a
reverse burn down chart get an idea of
how far you're progressing so it's
taking the test reporting a lot further
so here for example we've got a list of
the capabilities of a particular
application then we might drill down
into a particular story find the
acceptance criteria for that story and
then also saying in the story you'll
have a key given Sally wants to buy a
puppy for her son so she opens the home
page you chooses region chooses
categories and so forth you see exactly
what was done to test the particular
features the testers really like this
because they can say okay you develop a
folk you say that you've implemented
this search feature so I'll have a look
at these tests and see what it actually
does and whether I'm happy with that and
then the tester can go and test that in
more detail or try and break it
basically but saves a lot of time gives
a much clearer picture of what has
actually been implemented and yes so
those screenshots are captured every
that's something you can figure but what
I typically do is configure it so that
the screenshot has captured every time
button gets clicked or a something gets
entered into a form so you can see the
if you're watching the user filling out
a form and then clicking buttons if you
want it to be a bit more succinct you
can tell it to take a screenshot at the
start and the end of every step but I
find it more interesting to do it on
every interaction so yeah the
screenshots basically tells the story of
what happened during the as it was
played you can also so you also see as
it goes there you get the textual
description of the step that was being
played out so you can get some context
of what's going on so that's what I
wanted to talk about as far as
acceptance testing goes i also want to
talk about BDD from the pure development
point of view so you got your acceptance
criteria you know we need to implement
typically what happens then so yeah what
happens then so you got maybe some
screens you need to implement you know
that you need to implement a particular
screen maybe you got a UX person will
come in and figure out how the screens
you'll hang together the designer or
whatnot at some point you're going to
say okay we've got these screens that we
need to implement but we need to make
them do something so again have to
implement some code under the hood
so that's where the developer side of
things comes into play so here we talk
about the distinction between TVD and be
DD so who practices TDD test-driven
development yep quite a few people cool
isn't it so this is what i'm doing here
is I want to distinguish between well so
explain how to DD relief to be DD really
so in test-driven development you
classic test-driven well you write a
failing test you make it pass and
refactoring you and you loop on that
yeah that's TVD the question is how do
you know what tests you want to write
and that's something that often in the
examples it's really hard to figure out
okay they come up with this text where
to come from when it's okay if you're
doing a stack implementation or
something but for real code that to be
trickier now the answer is the it comes
from the acceptance tests or the level
above so your TDD is your low-level
features and your acceptance tests talk
about more high level features so at
each level you have different tools that
you can use and the idea is that your
acceptance tests give you a list of
specifications of what you need to
implement at the lower level say the
first you're going to know have some
specifications or you'll have a UI then
you say okay this UI has a list of
categories how do we get the categories
we hardcode them to get them for a
database file whatever so there you can
have to come up with some requirements
about how to make those how to get those
categories so you're too how to make
that web test actually work you're going
to have to look at your service lay your
database layer and so forth so you have
to drill down a bit and start to think
about how you're actually going to
implement the lower layers so at each
level you're going to come up with a
test by an executable specification
which is in fact a specification for the
next level down
now so that's your implementation of a
test at one level ends up being the
specification for the test at the next
level so you end up drilling down until
you actually write some code that does
something so on the way down you'll be
mocking stuff out so that you don't have
to so if you're doing TDD you'll be
familiar with mocking so on the way down
you mock stuff out that you're not
interested in doing at that point in
time until you get to the code you have
to actually code you write your code you
work your way up getting rid of the
mocks so the answer where the question
where does the tests come from how do
you know what tests are I they come from
the acceptance test and however the
acceptance tits come from they come from
features that are designed supposed to
provide value so getting back to that
goal of providing value all about
providing value so anything and it code
you're writing you should have the
context of what business value trying to
implement so that's very true of the UI
level but even at the database level
you're going to say okay is this
database that we're going to be doing a
lot of queries on are we going to be
more doing a lot of updates depending on
what the goal of the application is
you're going to make certain design
decisions so you have this distinction
between your acceptance tests and then
taking a bit further your low level unit
tests and they are very different so the
unit tests have a different flavor to
them they're much more tactical they're
not designed for outside consumption
really they're designed for developers
for other reason for other developers
really they're low level specifications
that you're writing so that the next guy
next developer coming along can
understand what's going on acceptance
tests are more for everyone else so
acceptance tests give a vision of where
the application is at as far as the
development goes and is everybody happy
with what's being developed so got ten
minutes left I just want to run through
a few except low level ddd
testing tools I won't talk about j unit
because i think you're probably familiar
with j unit i'll just talk about a
couple of others that i found useful
first one spark is you spot you and you
spoke a couple of people Spock is Spock
Rock Spock is really really cool I like
Spock Spock is a groovy BDD framework
nice thing about Spock is really really
easy to use and it's very intuitive so
it works for your IDE it's a J unit test
so it can run like a J unit test app up
centres in groovy you can do a lot of
really nice stuff so you have this given
when then so given we're filling a shirt
when we calculate the price including
GST then the price should include a GSD
of ten percent so you've got use instead
of just having a unit test with asserts
at the end you structure your tests
using the given when then pattern that
as very very effective in BDD and it
does change the way you develop at the
lower level too because you start
thinking in terms of okay of what is my
expected outcome so you're thinking
terms of behavior more than the tests so
it's very a really nice way of
developing and it's very intuitive so
you got this wet then the total price
should include a GST and then total
price equals equals 11 you don't need to
worry about a search or assert that or
whatever it's much more lightweight and
when you get used to it's very obvious
what's going on so that assert if it
fails it will act it will show what was
given and what was expected in in great
detail so the reporting is really nice
but just making it makes it very very
readable makes it easier to write tests
more quickly faster than just plain old
j unit so if something goes wrong you
get something like this a little
description of okay this didn't work and
what was what was happening on each side
of the equation
you can also so if you're doing TDD
probably familiar with mocking
frameworks makito easy mark things like
that yeah in Spock Spock comes with its
own mocking framework which is a little
bit weird to start with but it's really
really powerful and quite intuitive once
you get used to it now it's not very
precise is it that's easy to use when
you learn once you've learnt it so here
we've got for example get rate siggy
siggy 0.125 but you know basically
mocking out you creating a mock GST rate
provider and saying that get when you
call get Raider it's going to produce
0.125 that's all you have to do and then
the rest just happens so it's really
really lightweight even more like wayne
than makito this is Lester type so you
can also do mocking in the sense of
mocking as well so here we're saying
okay we're expecting so what are we
doing with sales we're selling a sales
we said when we sell us shirt we expect
that why the delivery service should
have been called once the dispatch
method on the delivery service should
have been called once with any parameter
taking you also a lot more complicated
stuff than that you mean put closures
and stuff like that but the the point is
it's really simple stuff and it's very
lightweight and even for more
complicated stuff it's very concise so
it makes it easy to write tests and
another really cool thing is the
data-driven side of it so we saw those
table based examples in Jay behave you
get something very similar and in Spock
so here we are testing a library that
converts a signal form of a word to
plural form and so to test that I've got
a whole lot of examples of words
converting being converted from see
you'll to plural or from plural to
plural in a couple in a couple of cases
so when you look at that you can it's
very easy to see what's going on in j
unit you'd have to do a parametrized
test which always puts me off a bit so
that's Spock I would highly recommend
playing with Spock if you're doing even
just TDD it's really really worthwhile
if you're scouring anyone use scholar
okay I'll skip this bit please this is
pretty much the equivalent in Scala
that's a library called spec too and
it's sort of like Spock what with Scala
syntax so the syntax is kind of weird
but if you're working with scowler that
won't put you off so it's very very
similar it's yes you've got funny
symbols in more places and in the groovy
version so you can also do but sir
what's the difference it's very very
similar really i'd say i prefer Spock
Spock I find more immediately readable
but if you're doing a scholar project
them this makes this would make perfect
sense as well so just and you also get
the data-driven stuff again family
symbols all over the place but I'm and
as I said if you're doing scholar it's
used to that yeah
dress
Garrett works really I know you testing
groovy code with Java mocks is pretty
much impossible very very difficult
Spock works well with xboxing groovy so
it's happening to block out groovy
classes yeah yeah any jbm classes so
grew I chest I use Spock to work with
both Java and groovy so I typically
write all my tests in groovy I used to
say I used to have a work only got two
minutes left but listen important I used
to have a philosophical objection on the
grounds that you should write your tests
in the same length unit tests in the
same language that you write your code
because they are examples of how you use
your coat but writing tests with Spock
is just so much easier that's what it
overcomes that objection so I just try
and make sure my examples look like Java
code if the application code is in Java
and everything around it is in groovy so
last thing I wanted to look at is
JavaScript anyone do any work with
JavaScript yep anyone use jasmine just
mean a couple of people so it's a BDD
framework for JavaScript which is kind
of cool very at simple doesn't do a lot
but as you know it doesn't that's got a
fairly simple structure you just say
describe some function and then you
create a function it does something and
then expect so expect to convert 50f to
c 2 equal 10 and so you just build up a
whole lot of tests using this it expect
format I think the great beauty of
jasmine jazmyne as it exists so it means
you can actually test your javascript in
a in a meaningful way you can also do
more complicated stuff if you're good at
javascript we can do more much more
funky stuff than this obviously at the
testing level but
that's a general idea you can structure
your test as well and nothing it even
works with maven so you can actually
integrate your JavaScript tests in to
your normal maven build which is kind of
cool that's just some examples of the
reports running now so you can have a
look at the details on the sides which
will be on my website on the job on one
website as well I think that's all we've
got time for but I think the general
message I wanted to get through with
this talk is in fact be DD is not just
something you apply at a particular
point in the development lifecycle it's
actually something you apply right
through from the business analysis right
through to the development and also go
float back up to the acceptance testing
so really is something that has right
applicable right across the development
lifecycle so questions yes sorry
story
I yeah the you get that can be an issue
you will what typically I'll get people
to do is when they write those tests a
given when then they don't just get a BA
to go off in the corner and or user to
say okay write down some tests and we'll
see what we can do with them you work
through them with a BA they use a
developer as well to make sure that the
tests are actually done in a reasonably
disciplined way so that they can
actually be testable and that they use a
consistent vocabulary and whatnot yeah
and you've got to refactor things so
that you get maybe one test with some
data-driven examples another thing when
you get testers into the testers tended
to go overboard on the examples they'll
say okay we'll enter an age of 10 here
but what if it's at age of 11 okay we'll
put 10 and 18 but what about 15 and so
they'll try get exhaustive examples
where as what you really need for the
acceptance test is a high more
high-level overview some key strategic
examples but not going into the
exhaustive depth if you really need to
do with the exhaustive stuff you usually
do it at a lower level otherwise sort of
a trade-off but otherwise your
acceptance tests become overwhelming and
hard to maintain as well the other
questions yep
sometimes depends our technical they are
but yes sometimes I do usually it's
collaborative there because the story
files are in version control and the
customers often don't have enough
technical knowledge to actually go and
background version control system least
the places I work some sometimes i do
but usually it's collaborative it's so
the value is not so much that they write
physically write the text but they're
involved in writing it and when they see
the outputs they actually see what they
wrote now Spock is more a unit testing
tool so Spock is not so much focused on
the reporting it's more focused on as a
developer communication tool so when
you're riding the given when then the
actual text given when then is actually
optional but Spock is more for to help
you express your ideas and
specifications in technical terms but
express them in given in a given when
then structure so it's easy to
understand for other developers whereas
J but so you wouldn't use spoke for
acceptance tests user for unit tests cuz
it's not so focused on communication and
reporting whereas things like j behave
and cucumber and whatnot I'm more
focused on the reporting side of thing
so they're more heavyweight Spock's
really lightweight you just do it J
behave requires a bit more setup but the
benefit to get out of it are in the
reporting side of things for beyond the
developer team yep
oh yeah definitely always run the BDD
tests on earth so on each commit your
you run your acceptance tests on each
commit here you do it as a pipeline so
you run your acceptance tests after even
as integration tests but each commit
will get acceptance s running
good &amp;amp; fri
so that's where you use in pending
pending tests so you mock test is
pending so your specified say okay we
need to do this and then but it's
pending until you actually implement it
so in the reports that won't break the
build but it won't marketers passing
either it will mark it as pending so in
BDD of these three state concept trinary
state or they were yes have a news
fitness in a while mainly because mainly
because I haven't it's fitness is the
big difference with witnesses it's
wiki-based so the users can contribute
directly to the tables and developers
have to scramble to write the fixtures
behind the scenes I find a little bit
harder to do the version control and
integrate it with the CI and whatnot I
find is easier to have it all in version
control all versioned and manage that
way that said there are a lot of people
who do use fitness quite successfully
for for acceptance testing so it isn't
it's a very fitness as the so everything
as a table you get you tend to get
everything expressed as tables which may
or may not suit the way you're doing it
it's also go i five got the disadvantage
of a wiki in that wiki's are a great
place to brain dump information but
they're terrible for structuring things
it's a little bit too freeform so I like
that the I like being able to structure
the requirements so that you can drill
down in different function different
features different capabilities and know
where each capability is at so that's
what I tend to prefer things like Jay
behave or a cucumber all that sort of
tool
yes
J behave has reasonable not J behave as
a reasonable intelligent not sure about
cucumber which will actually tell you
when the labels Eunice in a scenario
don't match a and implementation
somewhere but the general recommendation
is that's an issue of to her these are
can be a problem but if you can leave
the level of abstraction fairly high
that can help so you see not touching
the descriptions too much yeah so that's
where you're in fact when you're writing
except that's I was talking about those
steps step libraries with the CC duties
implementation where you do layers of
abstraction you really need to write the
acceptance tests as if it wasn't part of
the application code so at the same
discipline so you wouldn't you'd be a
bit annoyed if sorry developers wrote
the same code to do this pretty much the
same thing in different places in your
application so it's the same thing in
your acceptance tests so you need that's
a reflex to have the discipline to
refactor and make sure before you
implement a step to check whether it
exists already so let's say yeah it's a
discipline coding exercise same you need
the same discipline as you you apply to
your normal code that's really is the
same level of quality as production code
yep
yeah so we're just talking about sucio
do these because it's really use the
most what we do is we hook ups acidities
with JIRA for example so that you add an
issue number whilst all the requirements
in JIRA as story cards and then there
will be a structure in JIRA often as a
custom customized card structure with
features and whatnot so you get a link
in this in the reports back to the juror
card but you also get you can also set
it up so that the test results will
impact the status of the jura card so
that you can if an acceptance criteria
fails the jura card will be passed into
a failing broken state see can get that
too and get that sort of integration
that's what we do quite often you could
do the same thing it's just a plug-in so
you can do it with pretty much any issue
tracking which has an open API but it's
highly recommended to do that because it
helps keep everyone in the loop yes
I try and write as many as feasibly as I
can feasibly but I'm not fast if I've to
add more ones it's just a question of
traceability so that you get a better if
if you're doing con man doesn't really
matter for doing scrub you want to have
a reasonable idea of what you're what
you're expected to implement so it's
easier if you have as much possible up
front it's also a question when you do
the examples you're usually doing them
collaboratively with testers on the BAS
you have to actually get them and get
hold of them and work through the
examples but it's not a hard and fast
rule you can if you write as you
implement stuff you often think of
examples that you need to test as well
and so you might want to add extra cases
so if you're doing the data-driven
approach with tables that's really easy
you just add a new line yeah</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>