<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java Embedded Goes Modular: How to Build Your Custom Embedded Java Runtime | Coder Coacher - Coaching Coders</title><meta content="Java Embedded Goes Modular: How to Build Your Custom Embedded Java Runtime - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Java Embedded Goes Modular: How to Build Your Custom Embedded Java Runtime</b></h2><h5 class="post__date">2013-02-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/IulwX9ehkNc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Bob ban debt and I'm the
architect for the java SE embedded
product at Oracle we're going to have a
nice intimate setting today this is a
repeat of my talk that is actually
scheduled for later in this week that
got scheduled only like last week so
this thursday is going to be a lot more
people attending but we'll have a nice
intimate setting here so i'm going to
cover java SE embedded just a couple of
slides just to review for those folks
who may not be familiar with the product
I mother to spend you know two slides on
that and talk a little bit about where
we're going and how we're going to
reduce the size of the product to make
it more adaptable to lower lower end
embedded devices I want to talk about
how we're going to modular rise the SE
embedded product with compact profiles
some new tools that we're using to give
you more flexibility on how to build
your custom embedded runtimes we have a
new graphic stack which is really
exciting that I want to talk about in a
little bit of detail but there's
actually a full talk later this
afternoon that I'll go mention and I'll
talk about our roadmap even beyond JDK 8
and the plans for jigsaw and JDK nine
modules and how that's going to impact
the better and will I've got a couple of
demos that give you along the way and
hopefully it'll be somewhat entertaining
so let me just give a quick review of
what what is java SE embedded it's java
SE emitted is a full java standard
edition implementation that has been
customized to reduce the amount of
footprint required if you take the linux
x86 java runtime it's about one hundred
forty megabytes today if you download
the binary and it exploded onto your
file system we've actually taking the
x86 version and we've gotten it down to
42 megabytes so that's a sixty percent
reduction in disk footprint we've also
reduced the memory requirements down
that sese normally needs we reduce the
memory usage down so to the point where
you can run it in 32 megabytes headless
and 64 megabytes head full we have on
our web today we have two configurations
for each of our supported architectures
have a binary that you would download
for the headless and one for the head
full for forearm especially and of
course we need embedded uses different
architectures than typically are
available for java SE we have arm
powerpc and the reduced version of the
x86 and it's full javi SE compatibility
we pass one hundred percent of the tck
and it's available today here are some
of the unique platforms that we support
we support arm version 6 there are
different architectures and chips for
arms and Power PC and we have to provide
different binaries for binary
compatibility on those architectures we
support arm version six armed version 5
headless with different floating-point
options for soft floating-point ARM
version 6 headless and head full with
the with the vector floating-point unit
and just this year we released the
server jet for those customers that are
trying to target the server market with
the armed low-power processors
multi-core processors so that now allows
you to use both our client jit if you'd
like for smaller embedded and surrogates
for high performance throughput and
server applications we have two PowerPC
implementations I want to make that it's
a little bit confusing if you are
looking out you see e500 MC versus e600
chips we support standard bookie with
classic floating point with this e 600
release if you're using the freescale be
500 MC don't be confused with a 500 v 2
you actually have to use the e 600
version on the e 500 multi-core platform
that freescale's offering that's because
when they went to the multi-core chip
they switch back to classic
floating-point the traditional IBM
defined floating-point instruction set
but if you use an e 500 v 2 core for
your device you need to use the e 500 be
too specific binary because it uses the
embedded floating point at the auxiliary
processor that that freescale is defined
and finally for x86 we have a headless
version that is you know much smaller as
i mentioned than the standard SC
binaries
so going forward to jdk 8 what are we
doing to try to you know crunch down
that those binary is even smaller so we
can get into lower end devices we are
converging the best features of the Emmy
CDC product and SE and providing a jdk 8
compatible implementation we're going to
bring the critical features of cdc2 SE
one of the major benefits of cdc was the
fact that it's much smaller and could
fit in much lower end devices and in
order to achieve that goal we're going
to get our static footprint down to 10
megabytes and we're also reducing the
memory even further than we've done with
SE embedded the version 7 today or
getting it down to 16 megabytes for
headless applications and 32 megabytes
forehead full and as I mentioned earlier
we have a new embedded FX stack that is
going to provide an alternative stack to
Java 2d swing at awt which does consume
a considerable amount of memory and disk
footprint static footprint so how are we
going to get there we're going to reduce
the size of the vm today we have four
arm we have a client vm we have a server
vm we're now going to add a third vm to
the mix which is really just a specific
module erised version of the client vm
and we're going to get that down to less
than three megabytes this three
megabytes is actually the target on x86
on our mat we're hopefully going to get
that down to even less like two and a
half we're going to try to get done as
close to two megabytes as possible but
our our high water mark for all of these
platforms is try to get it down to three
we're also reducing the amount of memory
that's used by the JIT we're doing some
tunings so that the JIT memory consumed
by embedded applications will
dynamically adapt to the underlying
platform and alter some of the JIT
characteristics so that we reduce the
size of the JIT code and we're also
going to try to eliminate and remove
jaded methods that are no longer used so
that we can keep that memory as small as
possible and for more memory reductions
we're actually taking the class metadata
as as you load classes into memory we
create C++ objects for these classes
we're actually taking fields out of
those classes that are not frequently
used their use may be for serviceability
or debugging or
Oh file monitoring or symbol table
resolution and we're putting those all
into exhilarated structures so that we
don't have to allocate them for the most
frequently used product versions of your
application and since we're merging all
of these features into the standard
hotspot virtual machine that's used for
servers and x86 spark and 64-bit all of
the features that the hotspot team is
doing our are going to be available for
our embedded application this new jsr
292 work invoke dynamic which allows you
to run different languages on top of the
virtual machine they're moving the perm
gen out of the heap so that we can have
better management of that metadata so we
can free it much easier we don't have to
do garbage collection in order to free
up class metadata and that even helps us
in the embedded market we're doing nmt
which is native memory tracking to give
us a better idea of the memory usage of
the vm it's been very difficult to find
out how much memory beyond the heap that
the virtual machine is even using and
this new technology is going to allow us
to do that and finally we will help
finer grain could better control on
compiler will be able to
specify you know specific methods or
subsets of methods that we want to
compile we don't want to compile so
we're doing a little bit better job in
that to give you better control over
what you want to compile where we always
are pushing the envelope trying to get
better performance out of the newer ARM
processors and new and newer powerpc
processors that work we do in every
single release and we'll continue to do
that for JDK 8 and finally we're adding
additional surface ability which we
haven't had forearm and PowerPC there's
a serviceability agent which allows you
to do better diagnosis of crashes and
segfaults the serviceability agent will
now be available on those platforms so
how are we going to get even small down
to this 10 megabytes so we got the vm
down to three so that means we get seven
Meg's left so one of the biggest
consumers of that additional discs
static footprint while the class files
of course RTI jar is 50 megabytes in the
standard release we've compressed it
down to 25 megabytes but we need to get
it down a lot smaller so how we going to
do that we're actually going to define
different pro
files for se8 which will be subsets of
the full se the benefits of this is will
have a smaller headless runtime than we
we could even achieve today with se
embedded will have a new graphical stack
that will only consume 6 megabytes all
of these things will contribute to a
quicker download quicker start up time
for your application and this is the
basis of our Emmy NCDC converge product
for those of you that are familiar with
CDC this is similar to the foundation
profile this the small set of classes
that you can use to run an embedded
device and here's a picture contrasting
that the existing se embedded full Jerry
on the right where we have the VM and
all the base classes and the UI toolkits
on on the Left we see that we will have
three different profiles which will
build upon each other we will have our
new smaller vm for the smallest compact
profile and then we'll have the base
base set of classes which are equivalent
to the foundation profile for cdc that's
we're calling these things for now
compact one two and three but as we go
through the JCP and the expert group for
the JDK 8 specification these names will
undoubtedly change to something a little
bit different but we're using these
simplified words for now the next level
compact to will add additional
functionality these are things like the
optional packages that you might have
found in cdc rmi jdbc etc compact three
adds the rest of the API is that we
think will be applicable to a net to an
embedded device and finally we'll have
some optional components that you'll be
able to add to any one of these tears
that's things like our FX stack some
optional security providers etc here
kind of our current estimates of where
we think we're going to be with the
sizes of these different profiles for
the contact one profile where our goal
is to get down to that 10 megabytes now
JDK isn't done yet and the lambda team
is still you know adding more stuff in
and we're still trying to pull stuff out
so this 10 megs maybe you know 10 11 but
we're goal is to try to get as close as
possible to that 10 megabyte limit
compact to profile we think we're going
to require seven more megabytes to add
the functionality in it twenty four
megabytes for this is our new headless
JRE where we totally eliminated swing
awt Java 2d in our headless se embedded
today those classes unfortunately are
still in there because the past the j ck
i need to throw a headless exception
when somebody tries to create a swing
frame so i have to carry around all
those classes just to do that it so
there's a lot of dead code in there that
we're finally able to eliminate that
allows us to get half the size of our of
our SE vetted headless release in this
compact three profile so the SE embedded
headless today is 43 Meg's I believe
something like that soar almost half the
size which is going to be great so
what's in the Bears profiles as i
mentioned compact one is equivalent
roughly equivalent to the cdc profiles
we have your basic java.lang I oh ni o
text processing math the networking AP
is we're adding logging in here because
we've had a lot of requests from the
embedded folks when I sent information
out requesting you know what other
things would you like to see in it they
wanted logging and of course you know
Java has to have the security classes in
there now compact too has all of the
packages that are in compact one but we
were adding a few additional packages
similar to the CDC optional packages
Java SQL or at you know JDBC support our
mi support transaction api's are going
to be added in in the compact to profile
compact 3 we're adding a lot pretty much
everything else that's in the standard
se set of packages today we're adding
management support the rowset api's
which are not as frequently used in in
the SQL the bottom set of classes are
the compiler API so we want to be able
to enable folks that want to make little
web servers that want to possibly run
Java Sea to compile their classes
they'll be able to do that at the
compact three level the preference API
and scripting languages these are all
the things that we're going to be adding
to
compaq 3 and finally we'll still be
offering the full JRE for those
customers that want to use you know the
remaining classes that we've eliminated
from the compact 3 those things are
things like jax-ws you know for large
web server we figured these if you're
building a web web services server
you're going to need a lot of disk space
a lot of storage for your classes you're
not as concerned about size as some of
the lower tiers api's might be we've
eliminated the desktop api's all the
swing awt java 2d and imaging api's are
all out of compact 3 and you need the
full a full JRE in order to support
those and Korver is finally out of the
embedded JRE yes which one just one
before okay these slides are available
will be available on the web and they're
actually available right now if you just
go and search for my name and and then
there's actually 11 tabs you can click
on for all the presentations and it's up
there it's posted so so you don't have
to take notes but so we're going to as I
mentioned we will have some optional
components that you can install on any
one of the profiles the FX embedded
graphics tak that I'll get into more
details can be added on top localization
support by default will put us only but
if you want to put all of the rest of
the locales you can add those in and of
course at the cost of additional
footprint we will have some optional
security providers that are there less
common security providers things like
the elliptical cryptography and pkc s11
which isn't even used in the linux
platform and if you want to add
debugging support will allow you to add
debugging support to any one of the
profile so you can run JVM TI and debug
your java applications so what are we
doing in terms of helping developers to
get ready for profiles well we're
planning on enhancing java sea with some
options so that you can verify whether
your application at the source code
level will be compatible with one of the
one or more of the profiles so when you
run java sea will be adding a new option
profile where you can specify compact
one and if you're compiling your Java
code and it's using a class it's not in
compact one you'll get an error warning
you that you either have to rework your
code to eliminate that or bump up to the
next profile level we're going to add a
new jar option which will allow you to
specify which profile you intend your
jaw to run on it will mark the jar file
in the manifest with a minimum required
profile we're only going to do this for
the mange our application since some
developers may bring in third-party jar
files and they they don't you know they
have to not necessarily know what
profile it might run on we're also going
to provide some tools that you can run
on a jar file to tell it would tell you
which profile this jar file requires and
finally during the loading of an
application we will be very verifying
that the current profile that's running
can actually run the jar file that that
you're pointing us at and finally the we
obviously have to give you a way to
figure out what jar what profile you're
running with java dash version and i'll
show you that in in a demo
well I probably should have put this in
here but in the javadocs we're planning
on having you can uniquely identify
which method is in you know if you go
for a method it will tell you whether or
not it's in compact one two or three
we're talking with the NetBeans folks
about how to hook that in we're going to
be providing like a CT sim which will
allow you them to to tell which profile
but you know they're a separate team and
so we have to go kind of negotiate with
them to get that done so the download
image is going to be different than
which what you're used to today instead
of having a headless bundle that you
download and you install or a head full
bundle forearm we're actually going to
put all of the profiles into a single
package and we want to give you the
flexibility to pick the features that
you need and the size you need rather
than us making the decision for you so
we're going to provide this tool called
Jerry create which will you'll have to
run if you want to create your custom
embedded image in this package that you
download and expand we will have one per
architecture there'll be an arm v5 arm
v7 and eventually the hard float for the
Raspberry Pi users but inside each
individual download will be the four
different profile levels they'll be
compact one and I should have put to
their three and the JRE and any of these
extensions that I talked about that you
get ad on top of each one and you would
then run jerry create among and provide
it with some input and it will select
from those different profiles the
binaries that you've asked for and
possibly modify those binaries based on
these options that we're providing you
and it would generate the profile the
JRE that you want and some of the things
that we're going to allow you to do are
to include Java debugging support and
that means this in order to strip down
the JRE as small as possible we're going
to pull out all of the symbolic
information line number table and symbol
tables that are not needed to run an
application but they take up space and
so by default if you ask for some of
these smaller profiles we're going to
strip out is but
as we possibly can to get it small but
you can put it back with this option the
dash D the destination just specifies
where you want to write the output to ej
DK home will default to where you're
running the JRE create from but you
might want to pick a different one for
different versions if you want to keep
we strip out the debug information this
is I'm sorry this is the debug
information from the the stripping if
you want to keep it as dash que des G
says I want JVM TI support please add it
to my my run time I mix those up dry run
will actually not produce the output
it'll just tell you how big this is
going to be dash p or dash dash profile
this is how you tell it which profile
you're interested in the target
architecture is is a for a future if we
want to bundle all the arms into a
single package you would we would have
you know linux arms soft flow vfp you
will be able to pick which architecture
you're going to target and this dash
dash vm is where you'll be able to pick
amongst the three different VMs we have
this minimal small BM that's the three
beg the client vm and the server vm for
those architectures that support it we
don't have a server vm today for powerpc
and the extension option is where you be
able to say i want the FX support to be
added to my package I want one of these
security providers of the locales I want
to add this is how we're going to allow
you to select those so here's a couple
of examples of how you run this tool you
use Jerry create dash D or dash dash
dest with a directory where you want me
to write the output to pick the vm i
want the minimal vm that's that small vm
that i talked about and you tell me
which profile you want so this will just
give you the smallest vm would compaq 10
by default if you tell me I want compaq
one you're going to get the minimal vm
anyway because we assume that if you
want small you're going to get small but
you can override that if you want to run
the server vm with profile one just put
server in there instead or if you want
all the vm so that you can run java desh
server Java desk client you would do
dash vm all and we'll put up
all the VMS into the java runtime so
here's the example of the server vm you
would run jerry create my full JRE dash
profile full Jerry though you'll get
every class it's in java jdk 8 and dash
vm server tells me you just want me to
create the server vm oh they do was this
diplomat so let me try to do a
demonstration now of the JRE create try
to get my font as big as possible here
now I'm running this on on a Mac you can
run Jerry create on any platform that
has a Java Runtime Jerry Creed is a java
program i'm going to build an e jdk
forearm if i go in the bin directory you
see Jerry creep that's a properties file
that has information that we need to run
the program there's a Jerry create shell
script that actually runs java with the
JRE create jar file and if i just hit
return it basically gives you the help
screen the information that you saw
earlier now if i want to write out let's
say i want to do a compact to compact to
so i say write it out to comp do
directory dash dash profile compact to
oops can't spell and let's see what
happens here oops can't spell
the all right so it tells you what it's
going to do it's directory is this in
the Armed set of binary so it's going to
do an arm vfp version it's selected the
minimal vm by default on compact one or
two since they're fairly small we just
decided by default we're going to give
you the smallest vm and you know you're
not going to have debugging you're not
going to have any of the debugging
information in the class files I'm not
doing a dry run and I'm not giving you
lots of extra stuff and there are no
extensions but if I want to let's do a
cop too and I want the server via let's
put that in comp to server directory
let's override that when as you saw
compact to is 14 megabyte side it tells
you the size is going to be created so
jess vm server now i'm creating over the
server vm you notice the size goes up
considerably to the server vm is much
bigger so that's pretty much how you
would run jerry create let's let's build
an an x86 version I just want to show
you that the version string and we've
had this warmed up sorry
this is a Linux 10 dot 10 virtual
machine running on my Mac so I can
generate an x86 java runtime and
actually run it on the same machine
because it is an x86 device okay
oops my way
and just sit for high-resolution all
right so let's see so I'm in the
directory that I named labeled x86 so i
know that i'm generating the binaries
that can be executed here Jerry create
dash dash dash let's do a compact one
dish profile one
and here again we're generating the
minimal vm and it's a little more than
10 megabytes in size so if i go into the
compact one directory i see I've got a a
bin and a Lib directory and in the bin
directory all i have is java small java
program so let's go in there and do a
java dash version and you probably can't
see it because i didn't stretch the
window enough but it's so you can see
that in the top line we're identifying
the profile as compact one that we're
running and the vm is be identifying
itself as the minimal vm so this is the
small 10 megabyte compact one that you
would run on your betta device so that's
our tool for JRA create i'm now going to
move on to the give you a brief overview
of the new stack since we don't have a
WT swing available in any of the lower
tiers if you want to build a graphical
embedded application we're providing you
with a new graphical stack that's a more
modern stack based on the JavaFX scene
graph implementation it will allow you
to have high quality graphics on a small
embedded device with much lower resource
consumption it's it'll provide you with
a common graphical API that you'll be
able to run an application on a desktop
a Mac Windows or Linux and also want a
small embedded device it's the same
graphic same API is that you would use
on your desktop one really great thing
that's needed in the embedded market is
hardware acceleration using gpus I want
to give you a demonstration to just to
show you the benefit that the GPU does
provide it doesn't have any dependencies
on atwt and swing the UI is scaled down
for smaller screen sizes we've added
touch supports and that's important for
printers and other devices and a pop up
virtual keyboard we will use platform
media decoding for playing any media
video clips or audio
and the great thing is that it's only 6
megabytes of static footprint in order
to provide this rich graphical stack
just to show you contrast you know where
we were before we had compact profiles
with this new embedded stack on the Left
we have 52 megabytes for our head full
armed stack and that all that size comes
from the SE runtime that we had the vm
is larger the native toolkit the X
libraries even the platform has
additional requirements we were running
we were requiring an X Server that then
typically you would have a window
manager all of these things take up disk
space and memory footprint and the new
embedded stack all all we have is our
compact one profile if you want the
smallest implementation we have our
minimal vm that three Meg or less and
the JavaFX runtime and that all will fit
in 16 megabytes so that's a considerable
savings of disk footprint for your
graphics deck our reference board for
the first release is the BeagleBoard XM
we have three other boards that we're
working with and trying to validate but
the initial release will only be on the
BeagleBoard there is actually an
implementation on java.net forearm
devices for this big aboard XM that you
can download today and and play around
with it's an early access you know not
for production use but it give you some
idea if you look at these kiosks that
are around the various hotels you can
play around with it and that's basically
this FX stack running on top of java SE
7 we also have support for the Raspberry
Pi and I'm going to actually demonstrate
the Raspberry Pi today this great little
device is only thirty-five dollars if
you have an ethernet or $25 if you
eliminate the ethernet so it's really
inexpensive arm v6 processor with 256
Meg's of memory ethernet GPIO high def
output hdmi output and it's very
inexpensive and pretty powerful little
device we also are looking at freescale
I mx-5 series in six series boards and
the Panda board is actually the board
that's running in these kiosks out here
in the hall that's running that schedule
wrap that and stop by and play around
with one that's se embedded running this
graphic stack this is the Raspberry Pi
that I showed you just in case you can't
see from from me waving it around and
let's see so where are we going in the
future so in SE seven we've reduced the
JRE down sixty percent from a full Jerry
and that has been around for for a while
jdk 8 coming out next year we're going
to have these profiles that i
demonstrated for you to reduce the sizes
for JD canine we're going to be
utilizing modules which will give you
much more flexibility in terms of
selecting the specific packages that you
need rather than us having only three
different smaller profiles for you to
select from so you'll have a lot more
flexibility if you happen to need you
know a package that's up in tier 3 but
you don't need everything else today we
still you know are somewhat rigid in
terms of what you can deploy in jdk 9
you will have a lot more flexibility you
can basically pick which vm you want
what modules you want build up your
solution using jigsaw yes like you like
to be in a bougie
yes if you take the full JRE we still
have the legacy swing aww dawt graphics
deck yeah it's still there but it it
requires the full JRE that the new
graphics tech has you know has all
imaging api's and i'll give you a
demonstration in a minute as to what its
capabilities are it's you can basically
do everything in FX that you could do in
a WT and swing it before yes yes f FX is
a much better implementation that for
embedded devices to take advantage of
GPUs for a WT and swing oh it requires
the full OpenGL and does not run on top
of OpenGL ES the embedded subset and for
for it to do that you have you know
swing and awt on top of java 2d on top
of the OpenGL pipeline plus it as its
own pipeline there's a lot of code in
there and utilize yes everything's all
down to the 6 megabytes and we're
calling directly to the OpenGL GPU
libraries so it's much more efficient
and better suited for embedded as down
here our requirements are that you have
an OpenGL ES library and that's it and
we can draw directly to the library and
the frame buffer so we don't have X live
and an X rendering engine and then X on
top of dr I on top of OpenGL so we've
cut down a lot of layers to make it more
efficient for embedded devices yes
correct for Mouse events we're reading
directly from dev input on Linux there's
def input mouse and Devon put keyboard
it there's they're actually multiple
will most likely be putting out at least
some port part of the sources so that we
could people can adapt to different
platforms at some point today we have
multiple different rendering paths
there's a software renderer that doesn't
even use the GPU that all it needs is
dev FB you know maps into memory we've
right from Java and our native code then
there's the egl frame buffer which is
OpenGL require we have you have to have
OpenGL es2 we don't support one dot one
and there's actually an implementation
of egl on x11 so if you have X and you
want to run some other X applications we
have egl it will open punch a hole
through X and we'll go directly to the
frame buffer so but all of the x11 of
course will increase your memory because
X wants to keep backing stored it's kind
of a copy of the screen so you're going
to double amount of memory you need so
the most efficient and high-performance
solution that takes a less a month at
least amount of memory is just egl
director to OpenGL ES I'll show you the
frame buffer demo without OpenGL let me
just close out on JDK night and I'm
going to go over to the FX stuff so
before we run out of time so in the
future jigsaw will allow us to pick any
one of these modules this is a
preliminary module list that is
available in jdk and i don't know if you
saw the keynote mark demonstrated the
fact that you can do j mod install of a
application on an arm device and it
brings in all the dependent modules
automatically so you don't have to worry
about what the dependencies are so it's
a it's a much better cleaner more more
robust solution for those folks that
want to pick and choose just the modules
that they want but in the interim at
least we're going to give you this 10
megabyte solution which you don't have
today which is a I think
great step forward we're also planning
on providing a graphical tool since
there will be so many things you could
pick and choose among if you want to you
know have the the desktop api's or or
the compiler or add core bruh we'll have
this jerry create GUI tool that will in
addition to a jerry create command line
tool like you saw 4 profiles we're going
to have one of those for jdk nine we
also have this graphical tool that we've
been working on that let you pick which
vm do i want which user interface where
I want headless headful the embedded FX
stack do I debugging to watch
serviceability or jmx support it will
automatically pick those features out of
the module library and build you a JRE
that has those those capabilities so let
me switch over now to give you some
demonstration of javafx switch hope so I
have one of these raspberry PI's
connected over here I wanted to wave
this around it was harder to do with all
the wires connected to it but it's
connected to the screen and hopefully
it's not going to go to sleep so this is
a Raspberry Pi after the colonel boot so
there's no X running nothing and i'm
going to start up our first show i want
to show you demonstrate the difference
in performance between software
rendering and using OpenGL ES so let's
let's do the software rendering first so
this is just a Java FX bench program
that I'm going to load up and it's going
to draw take an image and move it around
the screen and that's going to go
crisscross so here you can see it's like
kind of jerky it's moving this flower
picture around the screen and I don't
know if you can't see my screen but it's
basically reporting that we're getting
1.21 frames a second
yeah it's basically just you know Java
dashed you know desh jarv oh yeah this
javafx dot platform equals FB frame
buffer just you just set a property and
so now I'm going to use the one that has
the GPU cpu its most likely one hundred
percent a little different taking this
image let's see how many frames a second
we have here mo come back so we had 56
57 frames a second so we're you know
like 50 times faster taking this GPU and
I'll bet you the cpu utilization itself
is much much lower because the GPU is
doing all this work we just say move is
here movies here we take that image we
we put it into the texture buffer and we
say move it around so that's pretty
dramatic whoops so let's go beyond just
a basic you know benchmark and let's try
to run something real so I in the demo
grounds there's an application of a
printer a simulation of a printer they
have a scanner connected to it I'm using
that same exact application here but
I've cut out all the device in and we
have a simulation set of frames that
we're going to go through this it's
designed such that it has a lot of you
know really good interaction when the
app is up and running so it loads every
image before so it takes a few seconds
to get going but we should see it here
in a sec there it is so here's the
printer application that that our team
developed just to give some idea of how
you can take this small little embedded
device and actually use it to drive the
console of a printer the tab at the top
this is actually designed for a
touchscreen so it's you're supposed to
swipe to pull down so I'm going to have
to play around with the mouse a little
bit to do that so we can take a look at
the supplies
come on pull it down okay come on all
right so this gives you a simulation
that we went out and queried the ink-jet
how much ink is left and if you saw that
the image the imaging of words drawing
that that's that's all javafx effects
that we're doing there also shows you
you know we had some printer jobs and
they've completed and this one was
cancelled we could also you know see if
the printer has the ability to put SD
media and pick pick from a file must
have clicked this place but it has some
nice animations to show you where you
would actually plug the media in a
pretty slick little app considering how
much resources it has in this system I
also can simulate you know actually
doing a print so I want to pick how many
copies we want to do do want to color or
black and white I pick color so here's a
simulation of what the printer might be
doing and this is all javafx running on
this little device and the JavaFX stack
is you know a little more than 6
megabytes we're still working on getting
that down it's like I can show you the
screen over here exactly what I'm
running here so my javafx run time that
you would include in the JRE is actually
right here this lib directory if I do a
das of live so we don't have a lot of
junk in there we're like it at like
eight megabytes but I have every one of
the rendering paths available I've got
the x11 the phrase of dummy frame buffer
and I've got the GPUs and those things
would would save us you know about
another megabyte so we're at seven
megabytes now and still trying to shrink
this down even further for our target
yes
talk to to all the devices through the
park Evelyn 40 syllable they are going
to the device it to a pci bus can you do
that in java without proper without
using any rapper without using J&amp;amp;I it if
those devices are available as a linux
kernel driver using you know java i owe
you can you can certainly do though
access those devices that way but you
need a you need to be able to open a
device and read and write from the
device so that's it baby to be a
communication Farkle something like I
did too much yeah today we have the
comms API that we can use and some of
the demos on the show floor or showing
that in use for jdk 8 we're actually
looking at other you know more
sophisticated device api's that you can
add there you know they're not committed
at this point but we're we're
investigating so that you have a full
set yes okay okay great
and so that's about the that's about it
for the demo I'll just show you one more
what quick demo that I happen to have
for those of you that are interested in
possibly doing some gaming on on this
one of the FX demonstration applications
that happen to be there is brick breaker
so this is you know playing games on
your Raspberry Pi I'm not very good at
it but well helps get the key
and if you can even see the paddle on
the screen oh yeah it's chopped up on
the bottom sorry about that oh well
anyway you can see that I I cranked up
the performance you it up normally
starts out really slow and I don't want
you to get the impression that it's
really slow it's just the way the app is
designed so I sped it up anyway that's
gaming on the Raspberry Pi it sorry it
was true chopped off a bit so that's
basically the end of my presentation any
open it up for questions you know just
to summarize okay my slides back I'm
just to summarize with the introduction
of compact profiles we're providing it
with a much smaller stack that we can
hopefully target smaller and smaller
embedded devices and we're committed to
continuing to push the envelope and get
SC embedded as small as we possibly can
and and so Duke wants to know if you
have any questions
that's currently only targeted for
desktop applications and not for
embedded applications our assumption is
that you would use this Jerry great tool
to create your application and bundle it
together and and deploy it yourself on
your on your own media and it's you know
we're not going to enable you know FX
downloads for embedded devices on the
web or anything of that nature because
they tend to be closed systems and and
so you you will include FX yourself and
you can build it on NetBeans on a linux
x86 platform and produce the package
then bundle it with rj re using the jari
Kurri tool and then push it off to your
device any other questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>