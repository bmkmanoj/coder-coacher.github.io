<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Polyglot Persistence: EclipseLink JPA for NoSQL, Relational, and Beyond | Coder Coacher - Coaching Coders</title><meta content="Polyglot Persistence: EclipseLink JPA for NoSQL, Relational, and Beyond - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Polyglot Persistence: EclipseLink JPA for NoSQL, Relational, and Beyond</b></h2><h5 class="post__date">2013-02-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/r_MrAwa-8l0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">ah so my name is Shawn Smith I'm speak
today with my my buddy from eclipse
foundation or eclipse gonna bag and
connect and we're going to talk about
eclipselink jpa for no sequel relational
and I put it beyond because it asked me
some other stuff that we actually do
that comes out of this work and I'll
just introduce who we are and then we're
going to do a bit back and forth in
terms of the content so so I'm with
oracle and i'm a product manager for top
link and i work on a number of areas in
comp link top link grid which is scaling
out jpa into large clusters using oracle
coherence the goal oracle goldengate
adapter which is synchronizing databases
and in-memory coherence caches using jpa
and on the work we're talking about
today here the no sequel stuff you can
see from the slide template that this is
an eclipse oriented top we both work on
a clip spinner I myself an eclipse link
which is where we have to develop
toppling majority of top link is is
built in open source the Eclipse Link
project is the project at eclipse that
we do that work in and I work on
eclipselink and a number of associated
projects that come up for example the
Dally project which is JP tools I work
on that and everything else to do with
jpa had to get involved with and gunner
yeah hi I'm gunam I booked at a Cheeto
we're a club Swadesh member and have a
couple of Eclipse project when I'm
committing on and contributing to as our
daily business we're doing internet web
applications and the e-commerce world
and that's why i'm also i also got
interested in two clips link and
investigating especially the stuff we
are talking about today so I'm gonna
just give you some contacts setting here
so we're talking about Java persistence
and for most people they think of
relational databases but on the
eclipselink team we have a broader
definition of persistence so for us
taking an in-memory live java object and
persisting it or putting some sort of
durable format like database or xml file
or JSON document that's persistence to
us a bit more general so the idea that
we go from a java object like customer
there into a table or international
document makes sense their specs for to
the
sort of transformations as jpa the java
persistence api for relational there is
jack's b for xml of course and it turns
out it if you think about what the
relational side is it's ori mapping
right o our and the xml mapping is 0 x
mapping and you put 0 r + 0 x together
you get x are all right so xml
relational and so the DB WS feature of
eclipse link is an XR service so if you
want to get a relational database data /
web service you don't really care about
objects use one xml then that's what
that feature covers but I won't talk
about that today we're going to focus on
well we will start with relational right
so the relational component for Eclipse
Ling but today the top can be about no
sequel to so what we've been working on
is a jpay support for mapping java
objects obviously into relational and
then mapping them into no sequel
databases and you see for my little icon
icon for our con Agra V down there
there's more than one kind of no sequel
database right so we're talking about
different different shapes I'll talk
about that I think coming up it'd be
great to have jpa access where i can
take java objects and just put them into
relation to no sequel databases get them
back work with them change them but I
don't want no sequel to be a
second-class citizen I want to be on a
first first class basis with relational
and so what we really want is that I
want java applications talking to JP
layer in Clips link where data is coming
from different types of data sources so
this is sort of a polyglot sort of
discussion right I want data to come
from no sequel relational I don't really
care but I want the programming API for
me as a developer to be nice and simple
end to be a singular API so JP itself
it's a standardization of common
practices so it's been around a while
now I work on top link which had his own
i guess proprietary or native API and
call the native API those hibernate had
its own API and still as hanging around
right people keep for some reason people
keeps people still using the table API
even though they support jpa and what
happened was these people came together
in the e5 time frame and EGP under the
jb spec auspices and created JP 10 so
sort of a best-of-breed what are the
common practices it was a non ivory
tower solution to a problem
because we've all if you've been around
long enough you saw egb cmp container
mantle persistence kind of heavy weight
people didn't really only use it they're
using toppling that using hibernate so
JP a standardized or came up with the
standard for the core functionality we
all agree upon for projo persistence and
so instead of a meeting of the minds he
works in java SE SE e eclipsing works in
osgi we're also us to part of the osgi
enterprise JP a spec so we're pretty
available everywhere pretty much so
these are the moving parts and we'll see
them how many people here are actually
JP a developer to use jpa they're almost
everyone okay so for the five of you who
aren't this is sort of the high level
right you've got your classes you've got
some Matthew metadata xml or annotations
get your tables and of course you have
the provider the JP provider in the
middle you know going back and forth
right what's nice about of course is it
has a nice straightforward API the AP
I'd actually fairly small the query
languages bit more complicated or more
full-featured but the API itself is
pretty small you know remove persist
merge you know commit we have the j PQ
el which is actually is very nice very
handy and we'll see how that fits in and
it works in in both container and out of
container right so we have a contract so
if you're in a container you get certain
nice nice integration with JT and so on
so um did you busy ok we're going to
fight over who says what ok ok we're a
book with a no sequel database oh the
five-dollar fights they were they don't
know about GPA likey yeah so new sequel
databases became be are becoming still
come increasingly popular so there are
many around and that's actually the
difference the challenge it's very
difficult because you have to learn
every database you have to learn a new
API and it's kind it's kind of
challenging in especially if you're
developing like we are consulting
business and you have many clients and
then trying out different technologies
you have to educate your people every
time you're just trying or using a new
no sequel database
and every database is different there's
no common like definition there's no
standard right and it's it's not a
negative thing they are pretty new and
they are innovative and that's actually
what what happens when new things appear
so so the thing so it's actually very
interesting to have to cover all those
new sequel databases into into the GPA
standard or actually to support them
using eclipse link that's not an easy
task to do but eclipsing found a way to
do it right right so so we've done is I
thank you it's fun sana its benefits
good day a lot ok ok so are there's a
bit of a history here so eclipselink has
been around a while it was open source
from Oracle top link I use top link for
small talking like 9607 time frame so
the sort of the the architecture of top
links been around the idea of arm has
been around it's part of the evolution
of eclipse link or a bedtime top link we
actually introduced support for we call
the eis feature enterprise information
systems so we talked to through jca
adapter you know mainframes we could
talk to packaged apps you know sort of
your financials whatever through jca so
we were able to transform java objects
into xml or structured data to persist
them interact with these these non
relational systems so I believe gunner
was harassing us at Eclipse con saying
you know why don't you guys have no
sequel support like worth a no sequel
support and so we went back to the
development team and one of our senior
engineers James Sutherland basically
said you know the EIS stuff is just like
this this no sequel stuff is very much
like our EIS support and so in short
order James had come up with a basic
implementation to support no sequel it
turns out that this code that we had
lying around for years which we really
weren't using is exactly suited to do
what we want to do with no sequel and so
what we're doing what we've done is
we've introduced a little bit of
extensions on jpa for example we have an
annotation that's at no sequel you can
stick on a JP entity to say this is an
entity but in addition to
entity I persistent Java object it's
also going to be stored in no sequel
database and the reason we have that is
because there's extra information we
need to know and I think we'll see it
coming up but the formats are differing
different databases so you know you have
map structures like in Mongo you have
columnar stuff you have graph databases
that all the different in terms of the
format so we kind of need to capture
what does that target format look like
so we have an annotation lets us
configure that the key principle that
we're supporting here is that we want to
leverage what's available so I'll
contrast is later on with high rain ogm
which has a different philosophy and
their our approach is if you buy Mongo
or you by cassandra your goal is to
leverage Mongo and Cassandra that's what
you you're investing in and so we're not
trying to provide some sort of magical
compatibility layer across these
databases so we're going to go with what
we can do with that database if your
database has a free language then we'll
times like JP ql into the query language
if we can do that and to whatever extent
that that language express ability
captures you know JP a semantics if it
doesn't have one well then you're
probably stuck with gets input you know
so basically primary key access so we're
not trying to take over the world here
and provide this magical you know
interaction layer it's trying to let you
get a no sequel database data so we
started off with MongoDB and Oracle no
sequel mungo at this point has a pretty
good market share and i will for oracle
so that makes sense on the second part
that is so who already heard about the
MongoDB who already heard about our
Oracle in the sequel database that's the
pocket a5 is a consequence okay so
that's a checking for marketing yeah who
here works for Mongo dizzy no okay this
one
so you say whatever we want to say so
the final point is we also want to mix
things together right so we already had
this ability for many years and support
this in any clips link where you can
actually have multiple relational
databases all sort of merged together we
used to call it session broker but it's
we call a composite persistence unit so
some objects are some entities are
living in sybase some of them are living
in oracle and we can have them all in
one persistence unit you can lazy load
across database technologies and all
that kind of thing you can use you know
transactions across database is all this
kind of stuff so we want to send that
over to no sequel database they've why
not so I can I have no sequel source
data and relational data it's all just
to have objects in memory so why can't I
mix them together so this is the sort of
the polyglot persistence right and if
you follow I think you have a slide with
a quote made us next one that's not okay
I'll say it anyway so you know if you
read like Martin Fowler and the book
just came out right all about the
realities of enterprises have lots of
data we know that like Oracle you have
lots of data in different databases you
want to get at it and use it and this is
kind of the reality right this is not
you know you should just buy an Oracle
database in your life will be perfect
that's never going to happen you're
going to have departments and companies
you require and Oracle's really good at
this we know you know prior company
they've got some database you're going
to have to just live with it and deal
with it so we need a way to have the
sort of polyglot support in JQ right
right and so as Sean already said the
goal of exception is to leverage what's
available and not all concepts
automatically apply to you to the new
sequel book so there are their core
concepts of but there are core concepts
of to pay that applied very well all
right so so you have the edge ities the
objects that you just persistent into
the database right and in some of those
sequel databases you actually you can
embed the objects that you can persist
complete object trees and into the
database and that's actually quite a
quite benefit for some data
and we have a couple of slides later on
to explain when to use or one or the
other technology right some concepts
depend on a database like a.j b ql the
query language some no sequel database
don't have a very language HS support
would get booed and others the
relationship don't make any sense at all
and in the sequel book now let's look at
some yeah we already talked a little bit
about the aquarius so with eclipsing all
the GBA you can to you can do two types
of queries shape of course there's j PQ
el it's a query language and there's
some support in the eclipsing to to
actually translate that into queries
that work into them in the new sequel
database amal would it be for example
right you can do simple queries and
check y'all and that work in manga but
there's also the possibility to do
native queries optimized queries if you
actually know you're sticking with that
technology you can we can always do a
native query which actually means that
Travis could query and more in the
Mongol case right and in obviously
relational world it's just you know its
sequel call truck sequel call right so
you supported the JK expect is the place
that says putting some some string here
and it's going to pass this to the
database in kind of the results so that
made of that string with a query could
be anything in fact in our case it's a
say Mongo query so here's an example
class of brief intro it doesn't look
that strange to some changes here
mentioned before there's no sequel
annotation in this case we're going to
map this to Mongo so we've set the data
format type to be mapped as that is it's
got key value structure is not indexed
for example structures actually named
the properties of names there's a we
have support for I degeneration so if
you just say generated value we're going
to use the Mongo native uuid generator
which is a nice feature because it's
easy to use and you'll notice a monk
also has this likes to call the ids
underscore ID so in jp-a as you know
there's a lot of defaulting so ID in
this case this the ID no no prefix will
be mapped to a property called ID we
want to be actually mapped to the field
ID we put in the field the reason we put
an airfield there with mostly because at
column doesn't make sense you could use
it and we know it actually works so if
you have verdicts if you put an add
column the name is this it's kind of the
same thing as saying the field name of
the metal object itself is this but at
column has a bunch of stuff on that
makes no sense you know field length
database data type all kinds of stuff
this relational so we said okay let's
just keep these two things effort
because this is a very simple
requirement other than that it's just
this is just jpa basics one to one
element collections it's not too strange
so if you're JK person the students
scare you right great yeah buddy talk a
little bit about the quarians so here's
some example queries that are
automatically translated into Mongo no
sequel queries right you can also use
the energy manager to actually create
native queries that use a Mongo
construct and you write in the class get
the single result back and then you
execute a native como debe courier the
most nice about the native career
support and named query support is
declare them in the file might determine
the time we've hired them in a mapping
file you can declare them on the objects
but if you declare them as named Chris
then the caller's don't know so you
could hide these native queries off
behind the name like you know do this
query and insulate the end user so if
you're migrating this is I think of the
topic that going to talk about if you're
moving between these two databases there
are some strategies for keeping your
Mongo or your Oracle no sequel coupling
contained right
okay so I prepared a little demo demo
that shows one of the projects that i'm
doing is i'm doing a lot in shy and we
using gemini to actually persist data
just pass it off to an osgi service that
that stores it in a memory right and
using some osgi services to actually
replace that service at runtime with an
eclipse linkback service that persists
the the data into Mongo database okay so
it that's a jpa project it's actually an
oci bundle but you have to persist into
XML and where you specify the data of
the persistent unit you give it a class
or house the house the font way back
there it's a little bit as well crank it
a little bit we didn't get the big
screen you know
you
so just need to find right oh
I thought four million solar driven no
it's it's a text editor it's a text font
it's done into the general phrase off I
know this Thunder general gates text
font yeah next one there you go
let's try
bit better in the back ok anymore
improve it yeah so it's actually a very
very simple persistent unit you give it
a class and then you specify the
database connections and that's that's
actually the difference right into just
set the target database technology which
is a Mongo platform right and say hey I
need a Mongo connection spec which
basically knows how to read those
properties for Mongo giving a host name
of the manga database server and a port
right in the name of the database and
that's it right so there is a an entity
over here that is persistent into the
database and I actually used I actually
used intentionally i used the column
annotation over here just to not only to
demonstrate that it still looks but it
also allows a very very great setup
because when you start developing
applications you can and use your object
model is not fixed right you're still
prototyping edited actually very
convenient to to use Mongo for that
because you don't need to deal with
schema issues right on once your your
object model is kind of set up you just
start actually working on the grenadier
model for that so if you're using mostly
confirm or project for prototyping ok so
let's just look at a demo
starting dose UI framework okay
so it's a very simple web application
actually is just a servlet or Chuck
Torrez in that case or it can just enter
some green submit them and they are
actually collected in hashmap right so
far east at the sober they are gone and
what i have here i have just started to
chip a bundle that i have over here
which actually brings into service and
then so the evangelist GIS is
dynamically swapping out the persistence
support yep by swapping out a jar of a
circus at runtime a runtime so and so
what actually happens as soon as i
swapped it out eclipselink kicked in and
started the persistent unit just to
refresh and i actually have some days
I'm dead already in the database from
previous exercises and now let's look at
the how this data is laid out in an
Mongo
so it creates a Mongo has this concept
of collections which basically map a
little bit to tables so create it
creates a collection for the entity
right and also defaults to the entity
name like a dust and relational world
and then it creates the documents and
Mongo right and it actually has the
attributes right as they are all right
so you have the ID that's auto-generated
you have some text and other attributes
of the entity that are persisted
one-on-one into MongoDB alright so
there's no serious ational or XML data
format it's just put in the Mongo as the
object really is rate you can use mobile
queries to go over the data ok so
another den will come up in a second
here about polyglot but the issue here
is that it's funny yo I'm doing his
class using my slide somehow this is
working on so anyway your slide says
that there's different kinds of data
basic knowledge right so we're a citizen
early on we won't be able to get access
to all database technology if you don't
really care what is in your enterprise
you're going to want access to it it's
going to be maybe interesting data in a
MongoDB database or some of those single
database like image stuff film who knows
what it is it just happens we captured
more naturally in that database
technology so you want to get at it so I
think your point is around the choices
so how do you make the choices right now
so yeah that's a that's a very important
choice and actually it may turn out that
the choice you made once in a time may
may just not be amid maybe another
choice in the future so right if you're
actually mutton follow made a good point
in the question is not where to store
the data the question you really is
about how i'm going to menu plate or how
i'm going to query the data because then
that actually gives you an indication of
what what capabilities today but data
store must offer right of course and if
you go Polly clock there is a cost of
complexity in your application in
because it's it's not it's not that you
can separate it like I have this
application into that data in large
corporations you actually have to you
and have a similar application working
with different persistence technologies
right and you're the thing with crane is
very key right and Martin far does cover
this I think on the website and then he
has a new book come out no statistical
distills where he's basically doing a
survey at different database technology
is sort of what's the rationale what do
they do it's pretty good overview so far
but the question of what are going to do
how do you access your data so the old
used to be old is it mostly insert most
to read or mostly query or whatever so
you still have those concerns our
relational databases are awesome at
large complicated queries right that's
what they're really good we're gonna do
large you know Multi multi table join
type queries that's great for relational
it doesn't work so well in in the
network or in say document-oriented
right this is not the way they're built
for if on the other hand you're
accessing data frequently through
relationships like once I pull in the
customer i want to quickly get at
associated stuff and it's in a database
you can easily navigate very cheaply to
those things good choice but one of the
things that were offering here with this
approach of using jpa is the application
doesn't look much different right so
we're offering it's not reaction layer
for sure and then we're hiding the guts
of say the mongo API or the Oracle no
sequel API specifically you don't have
to learn that API if you move between
data database technologies over the
course or project maybe through
prototyping to production or even over
time you need to move a certain piece of
it to a different database technology
because your boss tells you that's the
core per standard and you're going to
like it it's you much easier because
you're working through a relatively
standard or extended standard API you're
familiar with so this is really the goal
here again it's not it started so too
it's so to enable choice right we're
trying to give you open this here right
so so we thought I said this each has
their own their own
strengths and weaknesses but this
multiple database is very interesting so
I I think I mentioned this earlier week
we have always had this multi database
support we originally wrote it way back
before the JPA when JP a came out it had
known it didn't have this concept of
multiple database connections it was 11
persistence unit gets one connection we
actually had customers pushing us to add
this jpa because we didn't really have
it and the old technology old stuff we
had and the top link didn't quite work
with jpa so we came up with this chrome
visit persistent unit and i'm going to
give you i think that is the next slide
here so it's demo it says demo okay so
i'll give you a demo of a composite
persistence unit so i'll show a
composite looked like and i'll show you
what the the application code looks like
and what it looks like in terms of what
you see in your in your application and
i'm not as talented as good air so i
will be showing you sexy console output
2 i'm a server guy so okay so what i've
got is I've got a a Mongol database
persistence unit okay that doesn't look
it's not particularly exotic it's got
some classes like addresses I've got
customers orders zoo up here so I got an
order see this is actually the author of
James fell into this this and this
example or at least the fully manga
version of this is currently available
in Eclipse link examples git repository
the the polyglot version actually having
committed it yet but this you can
download this most of this code here so
it's a no sequel entity has generated
you IDs it has collections of order
lines notice their element collection
when you say as we said before when you
say element collection and JP that means
these are an aggregate structure right
they are part of their owned by their
parent and in a no sequel database in
the document database case of mongo that
means that the collection of order line
objects will be co-located in the same
document inside of the order document so
it's one thing right one key for all
these guys and so we have to be
basically honor this this annotation by
things together and we'll see that so we
have this simple technology just four of
them looking at the persistence.xml
similar what to get her head before the
same thing I database target is Mongo
the connection information and then the
usual top plane stuff so re closing
stuff so i turn the logging levels up
pretty high air and turn off some of the
stuff to show in each logging entry just
for cleanliness but it's pretty pretty
normal and so that's one persistence
unit that will produce a jar so it might
build I'll get a jar Mungo PU jar and I
have a relational persistence unit
project in Eclipse has a couple classes
the discount and product and if you
notice what I've done is order lines
have rowing in here has a 1212 product
so every order line has a product the
products are actually not in this
persistence you that they're actually
going to be in the relational persistent
these are going to go into in this case
into Derby embedded Derby database so I
have these two objects and different
technologies and I have a relationship
across and I was using I use the Dally
tools here as bettering Eclipse and
dally complained bitterly that you are
referring to an entity that is not in
this persistence unit like you know you
were wrong red marks so I brought up the
just so you know this if you try this
out you can bring up the properties
using actually I'm sorry I give it to
you it's not jpa within using using
dally when I was building this you would
see jpa here and you can actually
control the error so I went and I turned
off that error so every single error
that dolly puts out like target entity
is not in the persistence unit I changed
it from error to info like yeah I get it
you know I believe included that for
doug clark who really hates to see red
marks in code he knows is fine or even
yellow marks so so we can dial down dial
down the messages so dolly doesn't
understand you've got multiple
persistence units in the composite so we
can just
it's okay so anyway so i'll have Mongo
have relational here and relationships
between the two both of these produce a
jar and they build and I have this
competent persistence you know this
where i put these things together so
just to point out these persistence
units here I don't think they have the
setting they they don't know I had this
guy does we have to have a property here
saying this Mongo PU he's a member of a
composite so you don't have to declare
this but you can for documentation
purposes say this persistence unit
should not be run by itself it's going
to be a piece of something bigger I
think if you try and run this by itself
eclipselink will tell you hey this is a
component persistence unit you didn't
really want that but up in the composite
is closed over the hero second just you
know and the competent persistence unit
I have a list of the jars all right so I
path them if I'm an ear or in a near
environment for example I would have
these like this in this case are just
here on the file system and I say this
is a composite persistent unit this guy
composes together sets of math entities
and it has no notice there's no
connectivity that no classes here this
guy just is really truly composing
together these things and i have a small
example so what i'm going to do is I'm a
run I think it's also to go right yeah
Frankie so i'll just show you this den
with us that's it this is this is as
sexy as it gets so you know bear with me
here I'm going to do some plain old jpa
create a manager factory for that
composite persistence unit imma create
any manager begin it local java SE
transaction right create a new product
so i have three of them installation
shipping or for the net machine i'm
going to create a customer which is a no
sequel it's mapped into a mongo i'm
going to create an order which is also
going to be put in Mongo and then right
here is where gets interesting so I'm
going to create three order lines for
that order and I'm going to associate
with them these objects that are not
actually going to be stored in that
database right they're going to be in
the relational database they're going to
in Derby I'm going to persist a lot of
it and just commit
okay so I'm going to run that for size
unless they're going to put this
debugger so we can watch it to watch it
happen here so let's run this now this
is really real estate challenged here
okay so what you see in the console
there you go sexy console okay so you
see us doing some stuff sequence number
generation this is the relational side
so we're getting that for these products
and you'll see here we see a map
direction we're seeing us persist into
the customer collection we're doing an
insert into Derby into dirty Mungo I'm
putting in the customer whose ID has
been auto-generate to that and that's
the name we gave them we see some
interleaved interesting laughs in the
console anyway we see some inserts into
the Derby database and these numbers is
the primary keys here are being
manufactured by that the sequence
generator table base sequence sequence
generator and we see here now the order
goes in so we see an order get inserted
also we know it's order ID with all the
info here and notice down here this the
really cool part order lines has a bunch
has an object I noticed that it has a
product but no longer it doesn't a
product anymore it has product ID so
just like when we do jpa defaulting on
column names were forging joins and
foreign keys we're a pending ID on here
and you notice the object is replaced
with its I with its number so if we look
in the Mongo Explorer here any to that
is not it
here we are at the disconnect to hook up
any 2012
okay so I have the order and there's my
single order so down here I have these
border lines and you'll notice they have
product ideas tool when so I I've broken
the the links I've broken the physical
well memory pointers right between the
objects and replace them which is the ID
of the target object so I can go and we
could recover this later you'll also
notice that would that go here the the
customer that actually owns disorders
also referred to by its ID so the same
thing even between documents and now
have inter document links essentially by
embedding these the IDS rather than the
actual full objects on the other hand
order lines are actually embedded right
inside of this order document so jumping
back into the debugger again what I'm
going to do is I'm going to close off
that ND manager and I'm going to clear
the cache is so eclipse link is very Pro
cash right we very aggressively cash so
all that data we just created is all in
the l2 cache the shared cache and
eclipselink so to force eclipse link to
go back and create a basis i'm going to
just clear the cache is out so we don't
get any any hits so they're called a bit
cat that's a JP to standard API call to
clean up the the cash I just step down
here so we're going to what I'm going to
do now is I'm going to create a new any
manager I'm gonna go find that order and
it will query them from from Mungo and
then I'm going to iterate over the order
lines and print out the order lines okay
so we'll just take a look at what that
does i think it'll clear the console
here just let this go actually okay so
let's take a look so we saw there was we
see a query we're going to find on order
with a primary key we know we get it
back then you see a series of selects
and I'm not trying to make this
efficient what's happening here is as
we're iterating over these objects these
order lines we're resolving the
reference which was we had the ID where
we have in Eclipse link we had these
little value holders proxies we touch
the proxies the prophecies fire they say
I need product 203 and what's nice about
the way clips length works is at this
level it doesn't know where that's
coming from it just knows I need to
resolve
203 it goes off to a certain layer a
certain point in the clips think we go
you know left or right we go down the
tours Mongo versus rational we prove we
produce the appropriate query in this
case a relational select we pull it back
in we put the objects together and
you're none the wiser right so printing
out the the order and the verse order
lines we have the results are the
descriptions from these guys this is
very you know it's kind of weird to see
these weird-looking interactions
happening but in my application which
I'd rather focus on the application then
then sort of the weirdness of console
but this is just jpa there's really
nothing sexy here right this is not
rocket science all right so i think i
think that's that section yep okay yours
either yeah I'm just talking a little
bit more about the best practices or
experience here from from using the
stuff because that that wasn't just a
phantom idea of project that that I came
up with it it's actually we really had a
need for this in one of our projects and
actually we use it in a couple projects
now it's productive in a in a smaller
application but we're also looking to
put another application into production
with eclipselink 2.4 so um as I already
said in written
yep
I I talked about that in just that
slight actually so so the question is
that the transaction model MongoDB is
not the same as in relational databases
and and that's actually very very
important thing to remember it our it
are two worlds that that you have you
have the relational world and you have
the no sequel world and within music for
every data at every no sequel databases
is different so Mongo actually works
like when you're working with a Mongol
you need to think like autocommit right
it's it's there's no transaction even
though you have to transaction API and
in jp-a you know let you call begin
currents actually called commit
transaction right so all you're doing
there is really staging the changes yeah
it's just stating they are really as
soon as the command is executed it's
right in Mongo there is no rollback or
something right but then again there are
among go there is additional API that
actually allows some fans the atomic
operations flight replace or whatever
there's no there's no such thing in jp-a
yet right right um so but for for the
simplest case especially for the same
sandbox development if you're thinking
autocommit it's a very nice way to start
prototyping your model to start
prototyping your application and once
you have the domain model all set you
can start working on the Rhenish
relational schema right so that that's
one one way the other ways of course the
polyglot great and very very important
statements don't be cool just because
you can you really need to look at at
what your clients can do what your
colleagues your co-workers the people in
company actually can do and sometimes
it's it's better to stick with
relational databases right just because
the knowledge is is already there
especially when you are transition and
application into production and suddenly
we recognize that none of the operators
or administrators has any mongodb
experienced and you are
actually confronted with a new problem
so we had this with one of our clients
and so thanks to JP I we were able to
quickly exchanged that or migrate the
application to my sequel again in a
controllable amount of time yep so Sean
already talked a little bit about the
tools yeah so the tools i'm most
familiar with the courses they're
tooling in in netbeans jdeveloper
eclipse i'm involved with the Dally
tools which are part of the web tools
platform so if you get the java edition
of of eclipse that's that's web tools
platform release and Dahlia is quite
useful to degree I mentioned already
that it's going to give you complaints
about certain things that it can
understand about no sequel but
fortunately you can sort of suppress
those those warnings if you're working
with dolly it's very smart because it in
a relational world it looks the
relational schema it looks at your Java
object structures that looks at your
mappings and put the whole thing
together and says you whether you've got
it right or not right so how do primary
keys right are you referring to call
them to join exists all the things you
want to make sure correct correct so
it's really synthesizing the three
models together in the no sequel world
is no schema so we can't do that but
fortunately dally will work in the
relational world anyway today with or
without a database connection so if you
have a no database connection on the
project it just doesn't try and do the
validation against the schema and so
basically if you don't have data base
connection and using tape using no
sequel database target it actually
doesn't hurt just don't put in columns
and all these things and you just really
can't help you but it doesn't hurt
either so it's actually pretty good it
will still tell you things like you know
you referring to things don't exist your
configuration is wrong you have a class
that you percent as an entity but it
isn't in your persistence.xml accepted
so there's still a lot of value there
but it's not a perfect fit at this point
I would still use it yeah and then then
of course they are the database specific
tools like we use among go exploring our
demo there's also a nice plug in 1 gb
for for eclipse that i use in
development
okay so um anyone heard of morphia no
just a couple so I am I hadn't heard of
it till recently enough totally recently
the funny thing is the first person I'm
talking to a job of one I mentioned
there's no sequel sets they go have you
heard of morphia I'm like oh I just
heard about this so I went looking it's
a google cloud project it's a fairly
small project and it's focused on
MongoDB specifically but it's it's
taking a JP approach or JP like approach
so here's an example from I snapped off
of the the morphia webpage it looks
almost like a JP entity it has entity it
has ID has embedded the object ID type
is a bit funny there they use that for
for you ids although you can just use a
string in eclipselink but they have a
special class in morphia but what's
strange about is it looks like jpa until
you look at the import right that's
where things go kind of weird it's
really similar except for the imports so
it's a few things to think about this
right it's Mongo specific so if you're
on Mongo you've got a JP like API on
Mongo that's great but you can't mix and
match with anything else right so in
terms of this of the clips link
comparison it's a Mongol only solution
you couldn't mix in relational you
couldn't use other no sequel databases
you're married to this the other thing
that I found in looking at more fear was
it makes you manage the the order of
persist so if you go persist persist
persist in the wrong order it's going to
blow up on you and I remember years ago
looking at castor which was an older ORM
framework had the same thing and I
immediately left like the moment I have
to worry about what order I do things in
I don't want to know I just want to be a
Java guy who writes some objects and
goes commit at the end and the world is
all fine so Eclipse may we work out the
order of things have to be done in two
to make sure your databases in the right
state so it's a bit it's a bit of a
limitation there it means it's just more
of a manual technology with a bit of
sort of sugar coating on the top there
so in terms of comparable features
eclipselink is obviously more multiple
databases independent of that I things a
lot easier to use given this issue with
the ordering thought that was really
quite limiting the real issue is they're
almost the same thing except that
Eclipse things actually based on an
actual standard whereas these guys are
sort of making up stuff to be like the
standard and we're trying our best
obviously we're interesting things are
beyond the standard too there was some
discussion you know should we
standardize no sequel is kind of like
the g ee stuff with cloud it should be
standardized cloud and everyone said
like it's a bit soon you know let's try
things out let's see what's working
right so we're looking for feedback on
this for sure then there's a high rate
Oh G M there any one part of OG m yeah
ok but few more so this started off so
project led by a male bernard very smart
guy focused on plugging in infini spam
as a datagrid product from jboss as a
in-memory cache so it turns out that's
just like top leg grid top link and
coherence it's jpa with coherence for
caching is a scale-out solution it's
very similar kind of solution the thing
is that hybrid ogm imposed a very
specific data structure format on your
database contents and it's really not
obvious initially and so I start trying
I trying frames praise this and it's a
bit subtle the diff tension so high Rio
GM is trying to use no sequel in this
case initially infini span no sequel
database to store entities that sounds
reasonable eclipselink is trying to let
you get access to no sequel data through
jpa in other words if you've got JP I've
you gotta know sequel database will let
you map your data your objects onto that
and get it at data and hibernate ogm is
saying no no the database will look like
what we say is going to look like
because your job you're trying to store
your persisting your entities and I'll
show you a screenshot from their site
the one thing they have is very
interesting it's kind of a plus and
minus in terms of philosophy they like
they're using a hybrid search that using
leucine to do crowing so one of the
problems with these no sequel databases
and no
joining is hard to do complicated
queries the high rate regime guys are
basically indexing all the data in the
database right they both massive indexes
and machine and then they use leucine to
do the very resolution so they're trying
to in this sense to manage the earlier
terms of philosophy they are trying to
add on a layer a query layer on top of
these databases kind of normalize them
and our approach is if it has
probability will let you get it that's
what you bought and if it doesn't have a
query framework well then it doesn't
have one that's what you want so we're
not trying to augment these databases
probably you get access to them so it's
a subtle a subtle difference um here's a
shot from the if you have no GM side and
pull this down what they're doing is
they're actually deconstructing the
objects at the couple's and I don't
really know if they're doing this in
Mongo yet I think they must they might
be they must be doing this way because
that's where it works this is reflective
of the way in fitness bands stores data
as sets of tuples so breaking all the
enemies down two tuples and then they're
also reifying the relationships as
separate tuples so the associations
between objects become another object in
a net with another cache or another
database that they use for resolution so
it's it's really if you just want to use
passivate your objects into a database
ogm is ok if you and your enterprise had
a department who said to you hey you jpa
guys in EE we've got this database so
because you want to get at then we're a
better fit so it really depends on what
you're trying to to achieve that said
both of us are still in development
really I mean we have we all have some
basic functionality and I think that we
have a core in in eclipse in 24 but both
project still evolving so this can all
change right this might be they decide
after a while that this is working for
infini spam leading found a good idea
for something else so we're at the end
where we we're pretty good okay so um
this is new stuff right and we're our
team we're relational guys so we have a
lot to learn so we're looking for
feedback so we make us some things right
something's wrong something's not quite
right hopefully close and so we're
really looking for for help with this
like it
is interesting to you like dinner we're
doing this because gonna told us to do
it together easily have you have their
own sequel database as well we have only
assumed a writer's trip but at the time
I don't think we did okay so I'm also
huffily yet no so so you know gooder had
a business need as consultant both in
the first community we know each other
so he kind of drove us to get something
done go beyond some idea so obviously
you know people with ideas can have a
very strong influence on what our
engineering team is doing question it
yeah on your example earlier hot you
have been a relation with dependency
between these two projects yes which was
one way it was only basically you could
depend upon some entities in one project
from the other yes so the obvious
question is can go round you can go
around technically but the compile time
thing is a problem that was my room that
was the problem I have because currently
the way clips link works with composites
and wants jars this is the way we
implemented this composite persistency
the thing is like take these jars
compose them together so we have two
jars and have circular references yes
problem and reducing problems it's
problematic now the upside is the way
around this d that occurred to me later
on a after playing with actually trying
to build this not circular but just
dealing with the dark manufacturing was
have the domain model in one project and
put mapping files in the jars just
napping files right so yeah at work so
just move the data into XML and that way
you have a model project that you
include into
inter path and then to project to
contain persistence.xml files with just
napping files an image and that should
work because there's I believe that will
work so yeah fingers are the problem is
it was that you'll get an explosion of
yours just because you want this
assistance in a separate jar yeah and I
guess a this is the current
implementation like because we had a
need to beat so it works but must mean
it's the institution good feedback yeah
okay he's with a right to clap up so we
only talked about two databases there
are more out there we're looking at
others so far these names are appearing
on our list of interest if that's not
your list we're in to know what else
you're interested in and can you help if
you look at the code for Mongo the
database platform of after we have it's
really small like there's not a lot of
code it databases after it's impressive
all right ok and long term maybe Italy
standardized one day but not now</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>