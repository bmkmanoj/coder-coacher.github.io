<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Road to Lambda | Coder Coacher - Coaching Coders</title><meta content="The Road to Lambda - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Road to Lambda</b></h2><h5 class="post__date">2013-02-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/X2MtmIa7YSs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so let's talk about lambda so some of
you if you've been to Java one before or
other major conferences you've seen
presentations on our progress towards
adding lambda expressions to the Java
language this is the latest installment
and such so we because Java aid is
coming into the home stretch but not yet
shipping hopefully it'll be shipping
this this time next year summer 2013 so
we've titled this year's installment the
road to lambda and in addition to
talking about the features programming
language and library features of for
Java 8 we're also going to talk a little
bit about the history and some of the
decisions that brought us into where we
are here obligatory legal slide there
will be a quiz on this at the end ok so
let's talk about why are we doing this
at all you know one of the questions
that mark to ask yesterday at the
keynote is you know aren't collections
and for loops good enough we've been
doing it this way for 17 years it can't
be that bad right and that's true you
know Java is turning complete you can
write any program that's worth writing
in Java but it's possible to make it a
little bit more pleasant and more fun
more powerful more expressive more
readable less error-prone etc and that's
and that's why we go through the effort
of continuing to improve the language in
the libraries so Java 8 is going to be a
big step forward in the programming
model it's there's a coordinated set of
language improvements and library
improvements so the language
improvements include lambda expressions
or closures and also a mechanism for
evolving interfaces compatibly over time
the library features include some big
improvements to the collections for bulk
data operations and parallel operations
on collections and increased library
support for parallelism and these
features all work together the language
features that we're adding are an aid of
being able to implement the library
features we want and and together these
are a pretty big pretty should be a
pretty big upgrade to the programming
model I've been programming with this
stuff now for the last six months and I
have to
I really like it and I think you're all
going to like it as well so I you know
in obvious comparison for the work we're
doing now is the work we did the
generics in Java 5 that was also a
pretty big change that was a change to
language and libraries as well and just
as generics enabled us to better
abstract / types the goal of lambda is
to enable us to better abstract /
behavior and as I mentioned yesterday
how many people here with the keynote
yesterday some a lot okay the you know
the name for lambda expressions is kind
of a funny one it's one that actually
predates the dawn of computing it goes
back to the 30s in Alonzo churches work
on the foundations of the theory of
computation for some reason in the last
80 years we haven't come up with a
better name so the name stuck we call
them lambda expressions all right so
what is a lambda expression a lambda
expression is simply an anonymous method
like a method it has an argument list it
has parameters as a return type as a set
of thrown exceptions has a body so it
has all the things a method has except a
name and it's not a member of a class
it's just a free-floating expression so
here's an example of a very simple
lambda expression that takes as its
argument an object and whose body turns
around calls object up to string and
returns that you'll notice you know the
a lot of the syntactic overhead of
methods have been compressed away
there's no return statement there's no
braces it's just an expression and this
expression like like inner classes can
refer to names from the enclosing scope
so in the second example lambda here
that takes a person turns around calls p
dot get name and compares it to the name
variable name variables defined from
outside of the outside of the lambda so
whatever value name has outside of the
lambda it has inside the lambda and a
complimentary feature that we're adding
for lambda xpresso lambda expressions is
method references which is behaves just
like a lambda expression but if you
already have a method you just want to
represent that methods behavior as an
expression you can refer to the method
directly so this method reference here
object to string is I
identical and behavior to the first lamb
do we see they both mean the same thing
take your argument and pass it to object
to string so why do we do this the
reason we do this is we want to be able
to treat code as data we want to be able
to take behavior stick it in a variable
pass it to a method treat it as
something that can be passed around
rather than a fundamental property of a
Klaus so this may not seem like a big
deal like after all we've done is like
taken away a methods name what's the you
know what's the big deal but in reality
this is a huge deal it's going to change
the way we program in a pretty
fundamental way and it has a huge impact
on the way we design libraries so brief
history lesson so in 1995 when Java was
invented most popular programming
languages the time did not have support
closures at the time I it was believed
that closures were too complicated a
concept for ordinary programmers and a
productive language didn't need closures
and that was the that was the trends of
the time things have changed today Java
is probably the last mainstream
programming language that doesn't have
closures even C++ added them recently
after how many years of spec Committee
wrangling 11 years something like that
c-sharp added them in inversion 30 as
part of their link upgrade any any
credible new language being designed
today it's just a given right there's a
nice quote here from marc jayson dominus
as one of the architects of parole
basically saying you know at some point
in the in the future not having closures
it's gonna be like not having recursion
it's just table stakes at this point ok
so the relationship between Java
enclosures has been a little bit of a a
colorful history in 1997 there was some
experimental work done by fuller and
Martin oder ski that went into a
prototype called pizza that had that was
added closures among other features to
Java in Java 11 we added inner classes
which was an attempt to do to get some
of these benefits
they're there a fairly weak form of
closures they have a lot of syntactic
bulk they have a lot of complexity and
baggage and limitations especially given
the way they're implemented so fast
forwarding to about you know six seven
years ago there was a pretty vigorous
debate in the java community first over
whether there should be closures in java
and then between multiple competing
proposals about how to add closures to
java so if anybody remembers the closure
wars of those days you know there was a
proposal called bgg a champion bunny
okay after and a proposal called cice
champion by josh block and you know it's
what's interesting is they both have the
same goal or they both had the same high
order bit goal but they actually had
very different approaches for how they
thought what they thought add enclosures
to Java man and it's a lot like you know
the old story about the blind men and
the elephant right you know everybody
has hold of a different part of the
elephant and they each have an idea of
what closures in Java should mean and
you know that that's uh you know there
are a lot of different aspects of it and
different different people think
different ones are more important so bgg
a was largely focused on adding a
control abstraction through libraries
whereas cice was mostly focused on let's
just make the syntax for inner class is
better and call it a day so things never
really converged here and there was a
sort of long period we're really there
was no discussion on the topic and then
in December 2009 sun announced that okay
we're finally going to do it we picked a
nice middle of the road position uh you
know between the extremes of some of the
proposals that had been suggested in
November 2010 we formed a JSR after we
had been working on the design for about
a year in the context of openjdk and the
you know current status is actually
getting fairly close to completion we
have we've done two early draft review
specifications that are available
publicly there are there's a prototype
available in OpenJDK both source and
binary available for download and this
is going to be part of java SE 8 you
know which hopefully is shipping
you know in about a year so the features
that we're adding here lambda
expressions interface evolution support
in the form of default methods and bulk
operations on collections all right so
let's take a look at some of the
features and by way of background let's
look at how we do things today sorry to
repeat the same examples I did yesterday
but there's a little bit I have have a
little more time I can spend a little
more time talking about them so here's
an example of how we code every day in
Java you have a collection of things you
want to operate on some subset of those
things so you loop over the elements you
pick out the ones you want and then you
do something for for each of them so in
this example you have a collection of
shapes you pick out the red shapes and
you color them blue and this is how we
do it today it's really the only tool we
have for doing it today but it sucks and
I you know I can't criticize people for
programming with this because it's the
only tool we have for iterating over a
collection but it's a very limited and
limiting way of dealing with aggregates
and the reason is the semantics of the
for loop as burned into the language are
very strict they're strictly sequential
you have to do the first element first
and then you can't start the second
element till you finish the first
element etc and this is something that
didn't cost anything to specify this way
20 years ago when all systems were a
single processor systems but today we're
giving up a lot of potential performance
we're giving up opportunity to use
parallelism to use out of order
execution to exploit locality so the for
loop is really pretty heavily over
specified for today's hardware at the
same time there's a lot of accidental
complexity under the hood that you don't
see because it's all covered by the
syntactic sugar of the for each loop so
what the foreach loop does is it expands
out to ask the collection for an
iterator and then each time through the
loop ask it if it has any more elements
and if it does ask it for the next
element and keep going and how many
people here have ever had to write an
iterator right is it harder than it
should be right it's like it should be
so easy right and you start writing and
you say oh I must be dumb I'm getting
this wrong it's it's this a lot of
complexity to it you end up duplicating
a lot of code between next
next it's it's there's a lot of
accidental complexity here and you don't
see it from the client side but it
introduces not you know not only a
complicated mechanisms that the client
can drive the iteration but also it's
inherently racy because control is
switching back and forth between the
client and the collection and the client
in the collection alright so this is the
tool we had it's called external
iteration the client drives the
iteration arm but it's not really a good
match for today's hardware and it's not
really a good match for how we really
would like to program but it's a
workaround for the fact that we couldn't
do what we wanted to do which was to
hand a bit of behavior to the collection
and say do this for every element you
figure out how so you know what's being
conflated in the in the for each loop
example is the what do I want to do you
know test each shape to see if it's red
and then color it blue with the how do I
do it get an innovator iterator take the
first one you know it's it's etc and we
would like to move the responsibility
for the how fully into the library and
leave the client in control of the wad
ok because that frees up the library to
use whatever bag of tricks it has its
disposal you know parallelism out of
order execution what have you to get the
right answer without bothering the
client of mechanics so I've taken the
example I've rewritten this to use
lambdas it looks almost identical it
looks like it's just a syntactic
reshuffling of the symbols but the
reality is you know a lot has changed
here because now the library is in
control of the iteration here's a bit of
behavior do this for every element we
haven't specified in what order we
haven't specified what what happens if
there's an error we haven't specified
serial or parallel now obviously it's a
fair amount of work to specify what the
libraries behavior should be in all
these cases but the client stays in
charge of the wat and leaves the how to
the library and that's a good thing so
the another night another thing that
you'll notice here in the lambda syntax
I didn't have to write down the type of
the the argument s
I'm de the compiler just figures it out
it looks at the signature for each says
for each takes a block in this you know
in this case a block of shapes so asked
of us must be a shape the compiler just
figures it out for you it's not dynamic
typing it's just a compiler being smart
and helping you out so like I said this
looks like a tiny syntactic change so
why are we making such a big fuss about
it wise Oracle spending millions of
dollars on this well the reason is that
you know this has a fundamental effect
on the way we program and in particular
it has a big effect on the kind of
libraries that we can design it has you
know so it enables API designers it
gives them better tools for building
libraries that are powerful expressive
easy to use etc because they have more
ability to abstract / behavior okay so
details expressions in Java have type so
what is the type of a lambda expression
so historically the way we we did things
was we created libraries where we had
these interfaces with one method
runnable comparator callable etc and so
if you needed to pass behavior into into
a library you passed one of these one
method interfaces and that's been
working pretty well for us so we decided
let's just do that we'll give it a name
we're going to call these special
interfaces functional interfaces you
don't have to do anything special to
declare them as a functional interface
they just are by virtue of having one
method and then we can say a lambda
expression the type of a lambda
expression is a functional interface so
if I assign this lambda expression to a
predicate of string the type of that
expression is predicated Strangler and
the compiler uses the type information
on the target to do type inference to
figure out what the types of the lambda
the formal variables are if it can't
figure it out or you don't want to you
know I don't want to leave it
unspecified you can put explicit
explicit types there if you want but a
lot of the time it's perfectly clear to
just say you know predicate of string is
empty equals you know string is empty
the nice thing here by using this
existing mechanism which is the way
we've been writing libraries for a long
time all of our existing libraries just
work with this new language feature so
that's great we didn't have to go write
new libraries if you have
libraries that take things like you know
like the anti Oh libraries have like a
you know directory filters and things
like that you can just pass a lambda n
as long as those are single single
method interfaces okay so you know the
examples used a new method that what on
collection that wasn't in collection so
that's kind of a problem you not
supposed to be able to add methods to
interfaces and this has become more and
more of a constraint over time as you
know as our collection library is going
on 15 years old you know the way we
would write it today is not exactly the
way we wrote at 15 years ago but we're
stuck with the way we wrote at 15 years
ago so we decided it's finally time to
have a mechanism for evolving I'll take
questions at the end unless there's a
technical problem we decided it's
finally time to let libraries evolve you
know with usage patterns with language
with language evolution etc because
otherwise if libraries can't evolve they
just become brittle and and eventually
they become irrelevant and you know then
we would have to throw out our libraries
replace them every five years which is
very very disruptive so in order to let
libraries evolve we have a mechanism for
evolving them you can put code and
interfaces using these what are called
default methods you say this is the
default method here's the body in the in
the event that the sub sub type doesn't
provide an implementation it uses the
default implementation so these are full
virtual methods just like any other
interface method and this is actually
the code for collection for EHS all it's
really simple if a collection
implementation wants to provide a better
implementation just override it okay so
so in a full method lets you provide an
implementation with the method
declaration in the interface so a lot of
people look at this and say oh my god
you're adding multiple inheritance to
Java and well no we're not because Java
always had multiple inheritance Java
always had multiple inheritance of types
a class can implement multiple
interfaces and can inherit from multiple
interfaces what we're adding is multiple
inheritance of behavior what we're not
adding
is multiple inheritance of state and
almost all the pain of multiple
inheritance and languages like C++ comes
from multiple inheritance of state so
this mechanism it bears a sort of
superficial similarity to extension
methods in c-sharp it's actually
different in two key ways or is a
virtual there's our static or is our
declaration site there's are you cite it
also bears you know some resemblance to
stateless traits in languages like
fortress it's not exactly traits and
Scala if you're a scholar programmer and
you were hoping this is this is the
traits you wanted you'll be disappointed
but you'll find that you can use these
as a very effective inheritance
mechanism on their own even though the
primary reason we added this feature to
the language was interface evolution
okay so let's see how they work it's
single inheritance very simple right
we've had no trouble reasoning about
that multiple inheritance is a little
bit more complicated but there's a few
basic rules so that you can reason about
what what super type am I going to
inherit my behavior from so the first
rule is a straightforward one if the
superclass has an implementation or has
a declaration the class wins don't even
look at what the interfaces do if the
class has an implementation or it has an
abstract declaration that's what you
inherit done end of story okay in the
event there's a conflict between two
interfaces if one of them is a subtype
of another the subtype wins so if you
have a for each method in collection and
a for each method and list you are
because list as a subtype of collection
you inherit the one from the more
specific type and if you can't if we
can't disambiguate by one of those two
rules then it's just as if the method
was an abstract and you have to broaden
implementation okay so you don't have to
do an awful lot of reasoning about which
one of these a magna inherit we try to
manage the complexity of multiple herons
by having some really simple rules for
for this so the first question everyone
asks is you know when they hear multiple
inheritance is what about diamonds
diamonds were a really nasty problem in
C++ so
that must be an inherent problem with
multiple inheritance well it turns out
when you take stayed out of the equation
diamonds are easy okay so you know the
top example here I've got an interface a
with the default method and B and C both
extend a and D implements B and C well
there's only one method I can inherit
from right I can inherit from a or a I
happen to have two different paths to it
but that's irrelevant so d inherits its
definition of em from a if i modified
the example a little bit by giving you
know be a default implementation for em
as well then the rule about subclasses
comes into play b is a subclass of a
therefore B's takes precedence over a is
and again d inherits the method from be
and there's no ambiguity even though d
is implementing both B and C and so it's
indirectly implementing both a and b b
is a more specific type b wins the order
in which they appear on the inheritance
line is not around not relevant the
weather a appeared redundantly on the
inherits line not relevant simply a
matter of inheriting for the most
specific interface okay so this should
be fairly simple to reason about and you
know in the case where you have to super
types that both provide a default well
you just have to provide an
implementation on your own so you
override it as if it were an abstract
method and if you want to call back to
one of the inherited implementations
there's a slight extension of the super
syntax where you can say instead of
super damn you can say a dot super m or
be that super am so pretty
straightforward so why are we doing this
well like I said we want to be able to
evolve our ra p is the collection api is
you know haven't changed in a long time
when you add a feature like lambda to
the language now they look even more out
of date right where's my for each method
why can't I you know for each over the
elements of a collection and and apply a
lambda to each one okay so you know here
are some examples of things that we're
adding to collection the first one is
pretty obvious for each method you
hands in a block you apply the block for
every for every element and the second
example is that too small to read in the
back can can anybody read that raise
your hand if you can read that all right
looks like bet the first two thirds of
the room to read that so the the second
the second method here is a remove F and
you pass it a predicate which is you say
to a collection remove all the elements
that match this predicate now we had to
remove all method the first time around
but you could only pass it an object it
was remove all the elements they're
equal to this object that was the best
we could do without without closures but
obviously this is more powerful this
gives the client an opportunity to say
what remove all the elements that are
blue without having to manually iterate
through them sequentially and do all the
work itself okay and you know a an
interface can provide a default
implementation that is weak that's okay
subclasses can provide better ones
because these are virtual methods so if
you're an API maintainer this is a very
powerful mechanism for evolving your AP
is as you go along it's also a nice
mechanism for just building better API
so coming back to iterator before one of
everybody's pet peeves with iterator is
you have to implement has an X you have
to implement next almost nobody ever
implements remove except you have to
implement it with a body that says you
know throw some kind of exception so if
we have a default implementation that
throws that exception well now if you
don't if you're not looking to override
that you're not looking to provide a
better implementation of remove now you
don't have to provide the implementation
that's kind of nice it means that life
is a little bit easier for the people
implementing the classes that you've
written so you know again even though
the mechanism was designed for API
evolution it's also a mechanism for
making API is better so here's some here
are some really nice examples I really
these are these are really pretty
examples we have the the interface
comparator from which you know compares
two objects to see if one is less than
or equal or greater than the other and
common things that you might want to do
with comparator
our reverse the direction of the
comparator sort ascending versus
descending or take two comparators and
compose them so if you have a comparator
for first name and a comparator for last
name you can compose them into sort by
first and last name so these are a pain
to implement without lambdas so people
don't do it but they're trivial to
implement with lambdas and so we can add
them as extension methods or default
methods on to comparator so we added a
reverse method to comparator so if you
have a comparator you can say comparator
dot reverse and it just reverses the
direction of it and the implementation
is trivial the implementation is you
know call the compare method with the
objects in the opposite order similarly
we added a composed method to comparator
compose this comparator with another
comparator and again the implementation
is trivial call the first comparator if
it's not zero return that otherwise call
the second comparator and return that
okay so you know if you have comparators
force a first name and last name you can
make a you know decent you can you can
make a descending comparator by calling
the reverse on it you can make a
composite comparator that is by you know
first and last just by saying bye last
compose by first all right so you know
the and that doesn't affect the fact
that comparator is one of these single
method interfaces because default
methods don't count against your
abstract method limit okay so this is a
really nice thing as again has nothing
to do with interface evolution but it's
a it's a really nice tool for library
providers you know to add things like
predicate and and such you know as
instance methods on ok so let's um let's
talk about the what we're doing with the
collection collection api's because I
kept saying that lambda is a tool for
making better API as well let's see what
we're going to do with with collections
so I gave you this example earlier where
I said ok shape stuff for each here's a
lambda that selects out some of the
shapes ignore some of them and acts on
others really what we'd like to do is
decomposed that a little bit because
there's two things going on and things
are always cleaner
if you can you break things down to
their sort of most basic representation
okay so we can transform this from just
do this for every element to take take
the collection and then filter the ones
that meet this criteria in this case
being read and then for each of those
apply this action to it turn the blue ok
so this code isn't necessarily shorter
than the previous code but it's better
it's more expressive it's cleaner it's
simpler if you make small changes to the
problem statement you end up with small
changes to the resulting code you don't
end up with changes rippling through the
structure of the code just because
you're doing something slightly
different you know each put each thing
each part does one thing that thing is
clearly labeled plus also we've moved
the control of the color of the the
process into the library who can then
use parallelism etc ok so you know we
can keep going with this you know let's
say we're collecting you know not just
you know pick out the blocks that are
blue but ok that's gift an example so i
have i have my shapes example i say i
want to collect the blue ones into an
hour into an array the way I used to do
that is I create an empty array I do my
for loop I do my test and then the ones
i pick i stick them into the collection
a more declarative way to do it is to
say take the shapes filter the ones that
are blue and stick those into this
collection ok and similarly if i wanted
to collect not the shapes but some
metadata about the shapes let's say each
shape is contained in a box i wanted to
collect the set of boxes that contain a
blue shape i can make a very small
change I've made a small change to the
the problem I can make a small change to
my code I say take my shapes filter out
the ones that are blue for each that are
left replace that with the box that it
contains and stick those into a set ok
and similarly if I want to add up the
sum of the weights of the blue blocks
take my shapes filter them filter the
ones that are blue
replace each one of them with its weight
add those weights up okay and I showed
you earlier an alternate syntax for
method references perhaps a slightly
more compact way to write this rather
than having to write a lambda that all
it does is go and call the get wave
method I can just say map at using this
mapping function okay so this is a sort
of more natural way to express
collections when you have an easy
lightweight mechanism to pass behavior
from the client die into the library
okay so uh you know the I've said a few
times I've said I'll say a few more
times before I'm done it may look like a
small change but it completely changes
the character of the library as we write
and I would much rather write this code
then write the ad hoc code that we've
always been writing it's a lot clearer
to me it in fact its factors a lot more
cleanly if there's no mutable state in
the client it's just a lot cleaner okay
so the key thing here is these
operations are composable I can compose
these complex compound operations by
stringing together simple basic building
blocks where each block does one thing
and the net result is the client code
ends up reading like the problem
statement take the blue blocks color
them red stick them into a into a
collection also one of the things that
goes away when you program in this style
is a lot of the extraneous noise from
intermediate results right you know so
the old way you would say you know
collection equals new collection blah
blah blah blah collection dad and the
declaration is in some sense extraneous
right you end up its declaring all these
intermediate variables that just hold an
intermediate result and then you're
gonna throw them away by restructuring
the year you know the look at the code
like this all of those all of those
intermediate variables get out of the
way and you could see what the code is
doing and again you know library can use
parallelism it can use out of order it
gives laziness whatever it wants to use
okay so i mentioned laziness what do I
mean by laziness laziness is a measure
of when the work actually happens so
when you call you know so if i say
filter the the elements this collection
it's a valid question to ask well when
does that filtering
and this two choices so an eager
approach is do it immediately by the
time the method call returns the
filtering should have happened the lazy
approach is well do it at the last
possible moment when somebody asks for
the results okay and a lot of operations
like filtering or mapping can be
implemented either way and they have
pros and cons of both but if mechanisms
like iterators that we've used you know
for years for iterating through
collections those are inherently lazy it
the it doesn't have to know what the
next element is until you call next and
so we're kind of used to the idea of
working on elements one at a time and
letting them be computed on the fly and
laziness can be a source of significant
efficiency if you're for example let's
say you have a collection of a million
elements and you want to say get me the
first one that matches this criteria if
everything was eager you'd have to apply
the criteria to a million elements and
maybe that was a lot of wasted work
because the third element match the
criteria so if you're doing the
computation lazily you're only doing the
computation on enough elements to give
you your answer so as a mechanism for
adding these bulk operations to
collection we've added a new abstraction
to the collection library which we are
calling stream represents a stream of
values it's not a data structure it's
not a linked list it's not an ArrayList
it's just an abstraction for the values
are flowing by and you can act on them
and you can use existing collections or
arrays as a source for your stream you
can use existing collections as
something to dump the results of a
stream into and the stuff in the middle
is just computation so operations that
produce you know on streams that produce
new streams like filter and map those
are implemented as being lazy so you
know if you look at the the signature
you know of the the filter method it
returns a new stream so I've sort of
written it out sort of in a more verbose
way than we ordinarily would which is
assigning you know given a variable to
each of the intermediate elements the
calculation take the collection turned
it into a stream take that string and
filter it take that filtered stream
apply a mapping function to it and at
this point nowhere
actually happened we've just set up the
calculation that we're going to do and
then when we say take the last thing do
do it for each apply this this lambda to
every element of the collection that's
when the work happens because now the
users asked for something now we
wouldn't generally write it like this we
would normally write it more like this
just to make it clearer but I wrote the
example out full so you could see what
all the intermediate types were to see
that filter returns a new stream it
doesn't return new collection okay you
know that this is um you know this style
of API writing sometimes it's called
fluent some things that claim to be
fluent or more unless fluent but the
idea here is you try to eliminate the
noise of setting things up so that it
reads like first do this then do this
then do this okay so like I said we have
some operations that are lazy and some
operations that are eager the the terms
we actually use our intermediate and
terminal and you know so you can chain
together as many intermediate operations
as you want and you're just setting up
the calculation pipeline and then when
you do a terminal operation that's when
all the work happens and that and that's
when the library commits to house a
canoe of actually implement this is it
going to get an iterator is it going to
call for each you know what have you so
let's see let's walk through the stream
API briefly so you know there's the
methods we've seen before filter map
flatmap are you know those are all
intermediate operations some more
complex intermediate operations sorting
duplicate filtration slicing the stream
you know chop off all the elements after
the tenth you know discard the elements
up to the 100th etc and then some
terminal operations for each do this for
each element in to dump this into a
collection turned it into an array
aggregate by this aggregating function
like add them all up or take the maximum
or what have you or find the first one
find the you know find any element that
you can find etc
and even some more complicated things
like group by take this classification
function and produce me a map whose keys
are the results the classification
function and whose values are the
elements the original collection so this
is a pretty rich API and I'll just give
you sort of one you know one sort of
more sophisticated example of what you
can do with it let's say I've sort of
written a problem statement hound I've
written out in sequel because after all
this is an oracle conference and there
must be some sequel in every
presentation you have a collection of
documents each document has an author
you want to add up the sum of all the
pages of all the documents by author so
the old way to do that is you create a
map you iterate through all the
documents you get the author for each
document you look to see if there is
something in the map for that author if
there's not you have to put an initial
element in and then you replace it with
the sum of what was there and the page
count of the new one this is you know
pretty straightforward okay this is how
we would write it with the streams API
we would use the aggregate by function
which is a little tricky to read so I'll
walk through it a little bit more slowly
I'm saying take the set of documents and
aggregate them using the author as my
classifier so I'm going to like whack
the documents into bins where all the
documents in one banner one by one
author all the documents in the next
banner by another author etc and then
rather than just having a collection of
documents by author I'm going to
aggregate across a bin and though the
initial value for any bin is provided by
the the first lambda in blue which is
just returned 0 so when you have no when
you have no documents in a band the
value associate with that author is 0
and then if you add a new documents that
then you combine it using this combining
function that takes the previous some
and the new document and adds the sum to
the page count of the the new document
and replaces the value with that so at
the end of all of this you have a map
indexed by author of integers
okay you haven't created intermediate
collections you've just said you know
here's how I want to slice and dice
things I want to aggregate by this
aggregating function it's pretty
powerful it's a little you know this
isn't you know takes a while to learn to
read these examples but it's it's a lot
a lot clearer and cleaner once you do
okay so I talked about laziness you know
if you if you look at the kind of code
that uses for loops today because we're
trying to replace as many for loops as
possible with bulk operations on
collections it turns out that you they
correspond to these pipelines that are
take a collection do zero or more of
these intermediate operations and then
do one terminal operation so take a
collection do some filtering do some
replacement and then add up the elements
take an array apply a function to its
sort the results and then you know print
them out etc so you can think of streams
as being lazy collections but what we
haven't done is added the complexity of
new types for lazy less lazy collection
lazy sorted synchronized map etc okay
all the laziness just sort of happens
and it's it it's it's not xsplit it's
not explicit in the code but it uh it
gets you the result you want okay so the
other thing that I talked about that
moving the control of the computation
into the library does is the library can
use parallelism and this has clearly
been one of the goals from the outset
you know the one of Java strengths has
always been its libraries and the best
way you know to write better application
is to have better libraries and so if we
want to make the Java platform more
powerful we want to encourage more
powerful libraries and specifically
parallelism is one of those things that
we would like to not burden users with
so if we can hide all the details of
parallelism like task scheduling and
load balancing and all of that in the
libraries we all win it's hard to do
these libraries can be written by
experts you know there's no reason why
everyone should have to do that by
themselves so we have libraries for
parallelism
in the JDK now we have the fork John
library that we added in Java 7 which is
pretty powerful library but it's really
hard to use how many people here have
tried to use fork joiner okay was it
easy how many people here to think fork
join is easy okay few a few crazy guys
like Charlie and me and right okay so uh
what what ends up happening then is
writing the serial code is easy writing
the parallel code is a pain in the ass
so try not to write the parallel code
because we're all inherently lazy right
so we end up not going parallel just
because it's inconvenient and you know
that uh that means that our programs are
not as efficient as we'd like them to be
another problem with the fork join
libraries is there's so much code to use
them that the serial version of the code
and the parallel version of the code
don't look anything like each other and
it gets hard to see that you know the
the forest for the trees so we would
like parallelism to still be explicit
we're not going to inject parallelism
into your applications but we'd like it
to be unobtrusive so fork join is based
on recursive decomposition the idea is
you solve a big problem by chopping it
into two smaller problems and then
recursively chopping it into smaller and
smaller problems until the problems are
so small that the easiest thing to do is
to solve the subproblems sequentially
and then combine the results of the tree
and this tends to be pretty efficient
and fork trillion offers a pretty nice
mechanism for writing those algorithms
so that they work whether you have one
core or a thousand core is available to
you so fork join code typically looks
something like this take the problem if
it's small enough just solve it
sequentially otherwise wackit and to
solve the left and right half in
parallel and then combine the results so
if your problem is pick the biggest
element out of a collection well all
right you divide it into you pick the
biggest element out of each sub
collection and then you take the biggest
of those two and that's your combiner so
the parallel some example I had you're
not supposed to be able to read this
you know a few slides ago writing that
with fork join looks something like this
and the stuff in red is the stuff that
you'll recognize as the business logic
of iterate through my collection you
know pick out the ones I want add up the
sizes etc and the rest is all
boilerplate to keep the framework happy
ok so I would much rather write it like
this say I want to do this pipeline of
operations I'm going to do a filter
MapReduce on this on this collection I
want to do it in parallel but the
parallel code and the serial code are
almost identical they're different
enough so that there's no magic
parallelism but they're similar enough
that you can look at it and immediately
see what's this code doing and by the
way it looks like we're doing three
operations here it looks like we're
doing the filter and then a map and then
a reduce but because of laziness we
don't actually have to do them
explicitly the library will fuse these
together into a single parallel pass so
it only touches the data once that's
pretty cool ok so we don't actually have
a separate abstraction for parallel
stream we just have streams streams can
be serial or parallel it wet which one
they are depends on where they came from
take a collection give me a stream
that's sequential take me a collection
give me a parallel stream that's
parallel some data structures decompose
better than others arrays decompose
really nicely linked lists decompose
really badly but we abstract away the
decomposition mechanism we can try to
apply whatever parallelism we can
extract subject to however well the
collection can decompose itself so we
have an abstraction for decomposition
where the parallel analog of iterator is
splitter ater right iterator serves up
the elements one at a time splitter ater
decomp occur sively can decompose the
collection into small smaller splittable
chunks so you can say I want to risk
this chunk sequentially give me an
iterator for it I want to divide this
chunk into smaller chunks let me split
off a chunk and then each you know now I
have to splitter aiders and I could keep
splitting or I could
to stop splitting etc so once you have a
splitter ater for a data structure all
of these parallel algorithms can apply
on them obviously if you have a lousy
splitting approach like a linked list
you're not going to get as much
parallelism as if you have a much
cleaner split like like an array but you
know at least we can we can execute
these parallel operations on any data
structure that knows how to split itself
okay so let me get to the good stuff
here so why are we doing this we're do
we're doing this you know for a lot of
reasons you were doing this because of
parallelism we're doing this because
we're modernizing the language but we
also just want to make things better and
the reality is that having lambdas in
your language makes it easier to build
better libraries and this is not new
right we didn't just discover this last
week this community has known this for
50 years you know we're not breaking new
ground here but you know the the
relationship between the clients and a
library really changes when you're able
to pass behavior from the client to the
library it's not just here's a bunch of
data go do something and let me know the
result I can pass bits of behavior of do
this and then when this happens call
this function and when that happens call
that function and it makes for sort of a
much much more equal partnership between
the the library and the client the
client remains in control of the wat the
library remains in control how it's a
much better factoring so as an example
let's take a look at what this does to
sorting api's so here's the old way if
you want to sort of list today you write
a comparator now comparator is actually
conflating two different things that you
want for sorting elements one is
extracting a sort key and the other is
comparing those sort keys and we can
factor those out we could just replace
the inner class with a lambda but that
doesn't actually get us very far so
instead we're going to separate those
two aspects out so here's a method we
added to the library we have a class
comparators it's a static method called
comparing and this is the kind of thing
that land
does encourage you to do the generics
are a little nasty but don't let that
throw you because what's going on is
really simple this is a function
comparing that takes a function and
returns a function okay so the function
that I pass in is extract my sort key
the generics nastiness just says make
sure the sort key is comparable okay and
so I pass in a function that takes that
that that lets say takes a person and
returns last name so it takes the thing
you want to sort and it returns the sort
key and it returns you a comparator okay
so as long as the thing that the
extractor returns is comparable I pass
in a function that say takes a person
returns a string and then it returns me
a comparator that compares that string
using its natural compared to ordering
okay now you don't have to write this
method we write this method okay then
this is part of the libraries it means
that if you want to make a comparator of
people sorting by last name you can say
comparators dot comparing take a person
return his last name which is a lot
closer to the actual problem you're
trying to solve all the details of
actually writing a comparator that's all
accidental complexity okay so this is an
example of a higher order function it
takes function in returns a function out
the function in extracts the the sort
key the function it returns is a
comparator okay so so here's a simple
way to use that I want to I want to sort
the people by last name so I say give me
a comparator that sorts people but sorts
person objects by last name I pass it in
a function that extracts the last name
for a person it returns me a comparator
i can say sort that so that's already
better than what we have today but we
can do better still um it's actually
compact enough that I can just I don't
need the intermediate variable I can say
sort people comparing last name all
right this is getting a lot closer to
the problem statement because now we can
add methods to interfaces I can put the
sort method where it belongs on the list
and say people dot sort comparing last
name
in fact like this lambda is kind of a
silly lambda all it does is turn around
call some other method so why don't we
just name the method directly using a
method reference and all of the goo of
comparators is gone by adding one method
to the library okay and that method that
we added aside from its nasty generics
was a pretty simple one okay if I want
to sort people by last name backwards I
just take the comparator i got from
comparing and call the reverse method on
it you saw the definition of reverse you
know 20 slides ago it wasn't that nasty
if i want to sort by last name and then
first name i say make me a comparator
that compares last name compose that
with a comparator that compares first
name and sort by the combination okay
having lambdas in the language makes it
a lot easier to build api's that look
like this and you know so that the user
doesn't have to contribute all of the
goo associated with with sorting they
can just contribute the little bits that
they want okay this is a much nicer
relationship between the client and the
library so we could have written this
method with inner classes but will be
the point right no one want to use it
anyway would still be I it would still
be nasty okay so having language in the
library and having lambdas in the
language lets you write api's that are
more composable okay if we can write
better libraries we can write more
readable and less error-prone user code
okay so that's the big picture so
there's a lot of reasons why we would
rather evolve the programming model by
law braised rabbit the language
libraries are easier to write they're
cheaper to write there's more people
that can do it it's decentralized if you
screw up you can change libraries more
easily than you can change the language
so we prefer to add language features
that support library is rather than
support user code because that's the
rising tide that lifts all boats okay so
wrapping up why are we doing this well
first of all it's about time all the
other cool kids have done it already you
know Java is really the last you know
language of any serious adoption that
doesn't already have closures and adding
lambdas so Java is no longer a radical
idea it was a radical idea 10 years ago
times change it's not anymore providing
libraries a path to multi-core huge
driver for this work parallel friendly
parallel api's need to have internal
iteration internal iteration needs to
have a code as data mechanism that's
what lambdas give you empower the
library developers that makes
everybody's life better okay so where
are we now like I said we have a spec
available we have an implementation
available and come hell or high water
it's shipping next year and with that
I'm happy to take questions yeah
yeah so the question is why did you add
things to collection why not to iterable
so we explored that in fact in an
earlier version of the library design
that's what we did which is exactly what
microsoft is done in their CLR libraries
they they load all of the interesting
methods into iterable it turned out that
that was confusing for people we we ran
some focus groups and we found that
people were confused about what that
meant because you had lazy methods mixed
in with eager methods because you had
the lazy method you're inheriting from
iterable and the eager methods in the
collection and it was confusing the
users so we separated them out into a
stream abstraction where you have the in
place methods on collection you have a
way of turning a collection into a
stream and the lazy methods on stream it
turned out to be less confusing oh let's
let some other people ask questions
so um you know so I you've seen examples
where you call a method it returns a
lambda so obviously if you just want to
return a new function you can do that if
you are if you're talking about how it
is that we implement that do you want to
know to evaluate the Atlantic special
multiple times is that yeah oh you want
to do it reflectively um not yet so one
of the reasons why that's not there yet
more questions I there yes you yeah
alright so the question is do these
things get in line by the JVM so who
here is a performance weenie raise your
hand all right so you should all come to
my talk tomorrow morning at eight-thirty
horribly early if it makes you feel
better I have to get up earlier than you
do and I'm going to talk about the guts
of how this is implemented in the vm but
very quickly the this is built on top of
invoke dynamic and method handles so for
a lot of the common cases of lambda for
example like when you're not capturing
anything from the local context the
capturing a lambda expression boils down
into a constant load of a method handle
that the vm then knows how to in line
right through so the the capture cost in
the common case are basically zero and
because this is built on method handles
the vm understands how to in line
through these things so we've been
working very closely with the other vm
folks who did jsr 292 to make sure that
this stuff is not only fun to program
with but fast yes ma'am
so so the question is why why why do we
need this abstraction for splitter ater
there it is right because we've already
added parallel operations you know to
the collections well the reason is this
is our mechanism for adding parallel
operations if you want to be able to do
a parallel operation on a collection it
needs to provide a way of splitting
itself so all the collections in the JDK
implement their own splitter ater but if
you have your own collection that you
want to do parallel operations on all
you have to do is implement splitter
ater for that and everything else comes
for free yes but the number of people
who have to implement this is much
smaller right so iterators are a pain to
implement but they're um they're also
not something that you should have to be
doing all the time right I the reason we
end up having to use iterators all the
time is because we didn't have a
mechanism for internal interation right
so the so every collection had to
provide a way of getting at the elements
sequentially and then we had to define
all of these rules about interference of
what happens if the collection is
modified between calls to next and then
has next etc all that complexity goes
away when the iteration is contained
within the collection itself so yes you
know the some people are going to have
to write this mostly you know Mike and
Joe and Stuart and you know guys on the
library's Tim this is not this is not an
API that we we could get away without
even exposing this API you know in the
in the JDK but this is at the low level
how how it is that we end up getting
parallelism across all of the different
collections over there sir
correct so the question is right this is
all cut so when could when can we have
it and why can't we have it yesterday is
the question and so you can have it
yesterday if you're willing to run with
experimental you know builds of OpenJDK
which you're absolutely welcome to do
not only welcome to do but please do all
right the only way we're going to figure
out whether we've done it right is if
people download it now if you wait until
after eight comes out there's much less
that we can do to change things so the
most valuable thing that people can do
if you're interested in this is go
download the binaries try it out if it
works for you you know post something to
lambda dev saying hey I tried it and it
was great if it doesn't work for you
post bug reports you know there's lots
of people you know you know who chatter
like to chatter about language design
and library design on lambda dev but the
most valuable contributions we get from
the community are the people who say I
tried it out and I ran into this bug
those people are far more making far
more of a contribution so please be one
of those people we had questioned over
there
so certainly you know lambda expressions
are part of the language perfectly safe
safe to do I don't know about the the
parallelism I don't know what the rules
are I know the rules for parallel you
know for you for creating threads and
ejb containers are complicated so I'm
not sure if it would actually be able to
create the fork join pool that needs
will have to work back but i suspect it
will be you know ee containers you know
have you know want to exert more control
over what complete computing resources
you use we haven't worked out the rules
for that yet right yeah so the question
is now interfaces are looking more like
abstract classes so our abstract class
is gone and there's still a big
difference so you're right the set of
you know so the style guidelines have
always said if you can get away with an
interface use that instead of an
abstract class the one thing that you
can do with abstract class is now that
you can't do with interfaces is have
variables right so if you want to have
state you have to do an abstract class
but a lot of the things that we would
have done with abstract classes today we
can do with interfaces tomorrow what's
the right so one of the disadvantages of
using abstract classes as you still only
get one one class inheritance so more of
the things that you might have done
within with abstract classes you can now
do with interfaces alright one last
question someone who hasn't asked before
yes
yes okay so the question is wouldn't it
be great if I could take that method
reference syntax and assign it to a Java
lying method and in fact wouldn't it be
even greater if I could put that in an
annotation and the question is has there
been any consideration given to that and
the answer is yes there has been
extensive consideration given to that
anybody else's so the answer is not an
eight maybe a nine ok we have been
exceedingly careful to not get in the
way of doing that in the future but we
have not committed to doing that now
similar question field references same
story all right thank you very much
everybody</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>