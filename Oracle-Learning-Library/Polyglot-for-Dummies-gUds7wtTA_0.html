<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Polyglot for Dummies | Coder Coacher - Coaching Coders</title><meta content="Polyglot for Dummies - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Polyglot for Dummies</b></h2><h5 class="post__date">2013-03-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/gUds7wtTA_0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay we're going to get started the
first observation is holy crap there's a
lot of people interested in polyglot
programming today if you consider that
we're up against the script bowl a
couple rooms over those are also people
are interested in seeing multiple
languages together five years ago we'd
probably have a hard time getting 15 or
20 people out of off to talk about
polygons so I think the java community
has kind of turned this corner now and
you're interested to see more about
using multiple languages together and
hopefully we'll provide that today all
all dummies books always start with
definitions so we popped open a
dictionary and looked up polyglot
knowing or using several languages of
course we're only talking about
programming languages today so a little
pedantic but it is a dummies talk so the
things we're going to talk about today
is why you'd want to consider using
polyglot and we'll give you some sample
ideas maybe to spark some creativity and
how to use polyglot and then we'll get
down into some details of how to
actually communicate between languages
we both work on JRuby as our day job we
both really like Ruby this is sort of an
interesting challenge for us because we
like to sell Ruby but we're not going to
try to actively sell Ruby over any other
language in fact we shouldn't because
every language has its own benefits and
they all play nicely together you will
see a little bit more Ruby than other
languages but that's just because we
know that language quite a bit better
and I'm Tom in a bow by the way and this
is charles nutter and charles not oh yes
actually one thing I wanted to say about
the the the polyglot aspect here it
seems like there's a lot of folks that
say you really want to be a polyglot so
only use my language and it really does
make any sense we live on a platform now
that has lots of languages available
they all have their own special areas
where they fit and different things that
they are able to do so we need to find a
way to to make them all work well
together and
you know I keep the polyglot dream alive
because it actually does work a lot
better than just saying we're going to
switch everything over to one language
so perhaps the phrase isn't use the best
tool for the job it's to use the best
tools for the job I've never seen a
carpenter build a house with just a
screwdriver so this is sort of the
vision that most people have of Java but
there's just one language but actually
Java was designed with two languages
from the offset from the outset you
would write something in Java it would
compile it down to java bytecode and
that's actually what the JVM knows how
to run and that's not polygons unless
you're unless you're mixing a lot of
byte code and j and java directly in
your projects which i don't think a lot
of people do so by mid nineteen
ninety-six there were several languages
that we're starting to appear there
directly targeting java bytecode and all
of them know how to talk to the Java
language well and so by 1996 we already
had some form of polyglot in existence
so why would you want to use polygon the
answer is surprisingly mundane basically
job isn't the best language for
everything if you think it is then you
probably are a dummy a more nuanced
retort to this would be but isn't java
java good enough for all the things i'm
doing and we obviously can't answer that
it could be but more than likely some
portion of a large application you're
writing it's definitely not right and we
want to emphasize that we're not trying
to push the idea that you should move
over to these other languages just
because they're available if java does
everything that you want it to do
exactly as well as you need it done then
you're fine you know what these are
other tools for solving problems in
different and possibly better ways if
you don't need those up better ways then
if you're doing okay
so who are the polyglot is today you are
a little cheesy but the truth is if you
write any web application you're already
working and in many different languages
and you can look at this these this list
and go all well they're all
domain-specific and this is actually a
really good clue for when you actually
want to use polyglot in your own
application you need to start new yep
this is a reason to not have mere
displays you can actually look at the
domains within your application and
figure out the best piece the best
language for the best piece so for
example you can use scholar closure for
concurrency they're functional
programming languages and second someone
has their hand up oh no no is there any
way that we can turn down the pajama a
little bit on these displays
you know generally the the problem isn't
that it's too bright it's usually that
it's too dark
this most of these slides have a white
background with darker text for the
actual snippets like you have no
problems reading ideas up up at the top
right it's just this bluish on white
thing okay we'll just keep going there's
not many of these so that's it's all
right just go so you might use a
functional programming language for
concurrency because they have a better
concurrency story than using new thread
at the top tendrils of your application
you might decide you want to use a
dynamic language to have a more mutable
layer yeah that's no problem oh I should
also point out that the guy who gave the
talk right before us van cats her Venkat
this is actually his his picture from
his learning Scala book good book oh
yeah basically you know the way same way
that should break up any typical
application into sub domains or sub
libraries for different pieces that's
really the best way that you look at
doing polyglot programming to find the
right domain for a particular language
and use it there you don't have to have
all of the languages all the time in
every part of your application you find
a place where it fits well and then
isolate it as a service or a library
usually the cleanest way to keep being
separated and we'll come back to this
this slide and show some examples of
what we mean for a couple areas venkat
got his inspiration for this slide from
ola beanies fractal programming blog
will put this URL at the end if you're
interested in reading about it so what
are some benefits of not using Java
syntax actually does matter I don't know
how many times I've looked at a Java
class and it was devoid of a lot of
actual information it was mostly just
boilerplate in fact I hear people talk
about oh that's no problem I have an
idea
just generates you know thousands aligns
the getters and setters now if you go
and look at the classes on the right
they're much more concise and pretty
easy to read now this this is a totally
trivial Monday an example but syntax
really does matter if we if we go to a
slightly bigger example we have
something that gets a list of it
addresses and then we sort those
addresses by name and then we print them
out isn't too much code we do have to
implement our own comparator and that's
not too much code by itself but now if
you compare this to pretty much any
other language that's on the JVM today
they're all basically one line
statements not only are they one line
statements they're fluent they read nice
database addresses sort by name for each
one print the addresses name I think
that looks at a lot better than this the
closure one doesn't read quite as nicely
because the functions are up front but
you spend a day with closure in this
this will look beautiful as well
closures do matter I just wanted to
point out something had head list
actually had a sort method on it instead
of forcing you to use collection stats
sort than this Java example would have
looked a lot nicer unfortunately we
still have that well at least until Java
8 but Java hates what a year away and
it's probably going to be at least a
year after that until you can use it
however you know even if you can use
closures in Java the other thing is
paradigms also matter the primary
paradigms of your programming a language
affects the idioms that your community
makes for the language and those idioms
are based on the strengths of those
paradigms so for example you can do
functional programming in Java but
you're actually working against the
common idioms that the java community
has already developed and it might not
be so easy
whereas if you used closure the language
versus the features is talking about
everything about the language tries to
encourage you to not have mutable state
most of the data so all their data
structures are immutable when you do
actually have something mutable they
force you to put them into a transaction
so this is this is sort of the opposite
of what Java would do as an OP story in
language and so if you decided you
wanted to paralyze a task enclosure it
might be incredibly easy to do that
because you know that there's no mutable
state and you're off to the races
however there is a mutable state because
it's explicitly marked in your code you
actually know what you're up against so
paradigms really matter quite a bit
another nice thing about all the other
languages is they have a read eval print
loop you run groovy type print line
hello world you can see a print of the
screen and those triple equals greater
than null is the return value of
evaluating that expression now you get a
prompt back you could set variables you
can load in libraries and play with
things interactively instead of having
to create a project or constantly saving
things to a text editor or create a
build file and run for an ant or maven
every time to run stuff exactly oh look
you can do the same thing in Scala ah
you can do the same thing enclosure and
I just want to point out that closure is
pretty cool because it's fairly
reflective here I was curious how the
trampoline method was implemented so I
just asked for the source and I printed
it out another another extra cool thing
about the list variety of languages is
that they typically have documentation
as a first class citizen of language so
i could added doc trampoline and i would
just return that that string to me which
is a great thing to have in a rebel and
so we're experience with one ripple in
particular
is our own all right so I'll just run
through the the typical Ruby demo to
kind of show how you can really get the
interactive feel by by having a rebel
all right everybody can see that okay a
little bit all right so here we are in a
JRuby rebel pretty much the same sort of
set of features that you have in any of
the others you can still call into job
you can call into all the Ruby features
uh you know we can print out hello yes
there you go and you know all the
typical things it's it's much easier to
play with all these languages because
they have some sort of interactive rebel
and a lot of them actually when you
deploy on a server there's ways that you
can get into a rebel that connects up to
the server and try stuff out now of
course if we want to play with java
objects we can do that too ja bags yep
in a while all right so we can create a
new frame and we've got access to it and
it's all still live again let's get our
frame up here so we can see it off in
the corner there somewhere and that'll
be annoying and one another thing we'll
talk about a little bit later is a lot
of these languages have easier ways of
accessing java api s rather than doing
sets and gets maybe we have it as
property access so we can do something
like always on top equals true and it's
been just call to set always on top
method as well for you let's make this a
little bit bigger now I notice we also
do like we convert the Java skating into
Ruby casing to kind of make it feel a
little bit better 300 by 300 all right
so we've got a bigger frame now we'll
just run through and create a button
all right add that to the frame and back
screw that first time Alvin so Java hex
you can go and save expressions the last
expression to a and so we'll finally
will actually make it do something you
can show that this is all still really
interactive and we're adding new
behavior to it as it runs it's all just
still in the same jvm here and we'll
just set the text to something okay and
so we're doing add action listener here
which we've also snake k store
underscore case for Ruby but in Ruby as
in most of the other languages it's also
possible that just take a closure take a
piece of code and pass it in as an
implementation of an interface Oh stuck
down there there we go so we run that
and then if everything works as its
supposed to oops it doesn't demo God's
not with us today did I do wrong oh
that's what it was yeah caps locks there
we go try that so we get our error but
we've got the additional action listener
on there that works for for you and it's
all live so you can imagine if you have
this on a server and you're all you're
doing for polyglot wise is having access
to the objects on the server be able to
see what the services are doing it's a
very simple and quick way to get into
polyglot without even making a dive into
a specific language all right back to
that
alright so what reasons might you not
want to use polyglot this is sort of a
joke you can make a big technology
decision that can backfire on you and if
you make any technology decision you
might be incredibly afraid um this is
patent I guess hitting someone who broke
down on the battlefield that not cool
but if you do I have a poor relationship
with the rest of your team you probably
shouldn't be making any technology
decisions Nina probably repair some
bridges and get buy-in first although
for most of us we actually have a pretty
good relationship with the rest of our
team it's probably better to ask her
forgiveness than permission you don't
want too many cooks in the kitchen and
Gandhi loves polyglot if you are a team
leader and architect and you make a
decision and you're sitting there saying
tomorrow we're going to start using
Scala and there's a bunch of frowns on
everyone's faces you should take that as
a serious warning that they're not ready
yet because we all know as programmers
if you'd make a unpopular cultural
decision odds are it's not going to work
out it's just the strange side effect of
programmers being very
independent-minded another thing is you
might jump on the bandwagon too early
it's just too awesome so you use it too
soon you won't be able to hire anyone
there won't be any documentation you'll
find yourself asking obscure questions
on forums and reading through source
code and a year later you'll be one of
the three people are still using it
don't don't use that technology unless
unless you really want to be on that
Vanguard and that has improved a lot
over the past few years to the languages
that we're talking about here have
several books each large communities
there are folks out there they're
looking to work in
languages and looking for jobs using
them it's it'll could improve over time
but these languages in particular are
doing pretty well in those areas yeah oh
yeah nothing we're talking about today
is going to be dead on the vine next
year good good qualifier so one thing we
run into personally is people be going
across language boundaries and then
they'll get an exception they'll get
this stack trace in the stack trace will
be like you know 3,000 loan or something
and there'll be a lot of artificial
back-trace frames for the implementation
of the language itself now over time
this is another thing that's gotten a
lot better the number of frames have
greatly reduced and it's getting easier
and easier to see what language elements
you're actually hitting and invoke
dynamic this is and get quite a bit
better more more frames are going to
disappear but there's always going to be
some slight difference from just using
that single Java language that might bug
you and if it does bug you you know you
should get over it but if you can't get
over it then don't don't do it probably
a more serious operational issue is you
might decide you want to use the
language and that language pulls in some
other dependencies and there's a version
mismatch because you're already using a
different version of that same library
of course that's not it it's not a drop
dead issue assuming you can go and
update those other dependencies but it's
kind of a serious issue if you can't get
around it it's not even an issue
specific to language applications you
pull in the library X it probably
depends on a few others that you may run
into so this isn't unusual yeah it's a
generic Java problem right yeah and in
likewise this is also a generic problem
you might decide that you really like
this language you're going to put on a
cell phone and then it pulls in you know
30 megabytes of jars that's probably not
going to work this one's totally a joke
you know this polygon for dummies you
might think you have an awesome idea
whenever you want to go and introduce
some new technology that most people
don't know about in your team you really
want to go and bounce it off them in co
then before you actually make the
proposal have them play devil's advocate
so now we're on to the next so we
thought we break this up by kind of
talking about a couple of these domains
that you can split your application up
into and probably the quickest one in
the in the first one that you might run
into is some sort of DSL written in one
of these languages especially written in
the dynamic languages for example so
tools are where as we see a lot of
people start to get polyglot into an
application or into a dev shop because
it's pretty easy one of those tools that
that's gotten more and more popular
recently as Gradle great offers build
automation it's written with you write
your builds with groovy basically does
everything that maven or aunt does for
you with a lot of additional options for
automating the rest of the system
automating deployment and so on and of
course you know a rather than using XML
we're using groovy in this case and it
still does have all the features of the
typical build tools you're used to but
even better than that you can do simple
imperative code in here so building a
having a build tool that is also a
scripting language and internal DSL
gives you the opportunity to be able to
do an imperative loop or an if statement
things that are much more difficult in
declarative setups like ant or maven and
pretty much every language has their own
option for these tools so if you're
interested in starting to play with
closure are starting to play with Scala
maybe you look at lining it the closure
build tool or you look at this SBT the
Scala build tools and this isn't
necessarily a bad thing each of these
languages does have their own ways of
expressing particular concepts the the
various options that we have across all
these languages may be better at
particular domains and of course if you
want to use one of these languages it's
nice that you don't always have to go
back to Aunt to build things or that
you're all not always forced to use
Gradle for example they also bring their
own flavor and their own way of doing
things to each of these different
domains so once some things that rake
does well maybe leiningen doesn't do as
cleanly as or as nicely and tools really
are probably the easiest way
for you to start getting polyglot stuff
into a shop you start building things
that aren't on the critical path of your
application scripting the build process
scripting other parts of your your your
deployment aspects and it's it's D
capital from your application so you're
not as worried about breaking the
mainline application it's a lot not as
scary for decision makers or for the
developed day-to-day developers to bring
it into the system and it helps you get
a quick feel for how the language works
and whether you would want to start
using it to write services and critical
path code in the application another
quick way that you can start getting
languages into a given shop is to use it
for testing and in large in a lot of
cases dynamic languages make it far
easier to do testing of even regular
Java applications than if you were to
try and write all that in Java I still
have not heard a good answer from
anybody about how you do test-driven
development for real in a statically
typed language if you can actually
compile the test and run it there's lots
of excuses and other ways that you can
get around that but writing these tests
in a dynamic language you can actually
do your behavior driven or test-driven
development entirely ahead of time and
is this going to say for the JRuby
project over time we started with a lot
of j unit tests and those are just
slowly getting eaten away and being
replaced with our spec right so here's a
here's an example from from ruby from
JRuby using our spec which is a behavior
driven development tool and we're just
testing a standard java class here i
pull it in call methods on it give this
nice fluent interface that list should
be empty list add content and that
should be true get 0 should be whatever
we put into that list another way a nice
way of looking at how you do testing
first of all but we could write this
entire test against a class that doesn't
exist and just see that it fails and
then build out method after method that
actually will finally make those tests
pass don't have to worry about the
compile phase makes it a lot easier to
really do test-driven or test first
development it also has really good air
output because that described at the top
arraylist when first created should be
empty failed right exactly so rather
than trying to come up with cute names
for your test methods and then digging
around in a result to find out what
actually failed you can have individual
lines of text that say what failed what
didn't fail and and why it failed within
that particular piece of code and again
every language seems to have their own
testing technology right exactly I think
all of them have pretty much both a
straight up unit testing sort of
framework in Ruby it's test unit and
they also all have this sort of behavior
driven or specification driven
development tool now when we're talking
about dsl's one way that you can start
to use them is finding a server or a
framework that already provides it some
servers and platforms actually have
native support for these languages that
build their own little DSL or their own
little wrapper around the services that
you would write write directly to in
Java but then you can start using the
language without a lot of the
integration concerns we'll talk about
later for example torque box in a mutant
are basically jboss combined with Ruby
or closure all the typical services that
you'd expect from a jboss application
server with a nice Ruby or closure face
on them and we're kind of expanding that
out to other languages and grails when
you look at it is really a DSL around
spring and the various services that
spring provides so you'd do a grails
application you can write everything in
groovy deploy it and use services
written in any other language and not
have to ever really think too much about
how would it integrate all those
together which i think is probably the
cleanest way to do polyglot keep things
separated keep things behind service or
interface layers and ideally if you can
find servers or frameworks that wire
that stuff up for you so we'll look
quickly a couple examples here from from
the the jboss versions of this so torque
box is basically all of the enterprise
services within jboss wrapped with nice
Ruby front ends it kind of fits the Ruby
sensibility so if you're trying to be a
ruby program around the JVM it fits a
little bit more how Ruby programmers
want to work and it provides services
that rubyists use and it provides
services that you use with a nice face
on this is kind of the general structure
of both
torque box and mutant all of the typical
services you see but with a new API on
top of it a new front end and a way of
working with them so things like domain
friendly configs that you can have
within this setup Ruby and closure both
have this rather than doing it an XML
file we can have either an intern dsl
that lets us do standard Ruby code or
yeah mole on the other side which is a
markup language but a little bit less
verbose than XML very clean ways of
getting at Qs and topics or any of the
other services on the Left we've got
configuration for a couple for a Q and a
topic in Ruby as the dsl and on the
other side the same thing in a yeah mol
file that you want to use more of a text
driven thing again this is just a very
thin veneer over Java API right exactly
all of these are still doing the same
sort of configuration within the server
to set up cues and topics but providing
it in a way that fits Ruby or feels
right for a ruby program here we're
actually using the cue and the topic
pretty clean cleaner than the code that
you'd probably have to write for this in
Java and it focuses on what you actually
would want to use that the key features
the default features your normal e going
to get at are the easy ones rather than
everything being equally difficult so a
mutant kind of the same thing but for
closure with closure sensibilities again
the configuration here you know code is
data and data is code and configures
data so code is config that makes sense
this is a way you set up the server you
have all of your dependencies prepared
here's a more a longer example of
basically an entire application that's
written for a mutant enclosure we're
loading in messaging we're loading in
scheduled jobs demonization of stuff and
then we have it all available as a
closure dsl to build and use this stuff
and remember what i mentioned before
some languages and some servers actually
set up ripples for you hear about
halfway down we have a rebel started up
on port 4321 so if you connect into that
you actually can use a closure ripple to
see what the applications doing try out
the message
system tryout schedule jobs and make
sure everything's working properly
something that polyglot is kind of
bringing to what's normally a kind of
black box of a server all right so we'll
talk a little bit about concurrency new
threads sucks setting up synchronized
blocks sucks so use a better concurrency
model the one we're going to show today
is haka it's actor framework that's
written in Scala you set up a series of
actors into a space and they just send
messages and receive messages
asynchronously we're not going to
actually explain how to write concurrent
programs using actors this is really
just meant to give you a feel of how
this different model will look if you're
if you're coding unlikely like we've
been talking about breaking up your
application into specific domains acha
has a Java API that they shipped they're
also also Scala API and show that but
but it's basically just a Scala library
that has been wrapped up and you use it
and you're basically doing some polyglot
work so if we if we look at what this
API looks like or this framework looks
like in Scala I'll just read down from
top to bottom we define a simple
greeting class that has a who filled
followed by we define an actor you can
see that extends actor and we load in
some logging we have a receive function
that if it receives a greeting message
then we'll log that at the bottom we set
up the system for to put actors this is
kind of a lame example because there's
only a single actor in it but on the
next line we set up the greeter and
stick it into the step that space and
the last line we fire off a greeting
message to that actor asynchronously and
that that ! is kind of a fire-and-forget
operation so if there was some more code
right below that then
it may or may not execute next because
we fired it off asynchronously we don't
know when the actor is going to receive
it or if it's ever going to receive it
for that matter here's what the Java API
looks like it largely looks the same we
have a struct class again at the top the
greeting actor extends a slightly
different class and receive is now
called on receive but it's the same the
bottom is almost exactly the same except
instead of an exclamation point there's
a towel method which is this does the
same thing now my experience with using
Jaquez through a library called mica
it's it's a thin API around akkas java
api again Charlie just explained that
thin wrappers are great for dsl's and
this really does feel like a ruby API to
me so let's let's look at an example
wonky music it's it's a little bit crazy
I only have so many jokes in here so
Elise heard originally wrote this I kind
of rewrote it a little bit so there's
four actors in this example you have a
conductor and you have three instruments
the conductor comes into being first and
then the three instruments come into
being as soon as they come into being
they asynchronously fire off an event
with a message of themselves and here's
what the basic setup looks like we
create a system called wall of sound and
then we first register our conductor and
then we register the three the three
instruments and pass them as a message
to that conductor asynchronously so now
instead of bang or tell we use less than
less than because that feels better from
a ruby perspective another nice thing
about Ruby I just want to point out
guitar drum and bass are actually
classes in Ruby classes are just objects
so we can pass them in and assign them
to variables and just use them however
we want what
I think is a lot nicer than I wish Java
had it all right well here's what the
conductor looks like you can see that it
extends actor but it's not an acha actor
it's a mica actor this was a strategy
that the author used to make his thin
layer isolated from the actual acha
class so he's using a little bit of
delegation here this allows him to add
additional methods without cluttering up
the actual haka class if we look at the
receive method itself if the message is
in a string called finale we just assume
it's an instrument registering itself
and then we send a message saying hey
start playing and that's exactly what it
does now all three of these are also
asynchronous now the thing you might be
thinking is the instruments
asynchronously said hello I'm here and
then this said sent back each one say
you can start playing asynchronously we
have no idea when these instruments are
going to start so this is arguably one
of the worst conductors ever here's what
they here's what an individual
instrument looks like there's really no
behavior in it but if we look at the
base class there's a receive message if
it receives a play message then it calls
play receives finale does play finale
the actual class name is used to figure
out which mp3 to play basically the drum
is a little bit special when it gets
done playing its little song it tells
the conductor that it wants to play
finale conductors not very smart and it
just goes yeah go for it maybe it's just
jamming and here's all the drums
implement play calls its instruments
play and then after it's done it sends
its finale message to the conductor and
as we saw earlier the conductor if it
sees a finale it just says yeah play a
finale so let's see if this thing works
oh yeah okay you'll see some stuff on
the screen here as instruments come
online so we've already got the three
instruments will put to the conductor
and already received a play message back
good plan free jazz now the great thing
about these demos is really really long
there's not the finale yet sweet there
we go nice so hopefully that gave you an
idea of what it would be like designing
actors and passing messages around right
how to do that safely as a different
different talk and it really does it
really does help show that putting a
thin wrapper in a particular language
around whatever library you're using
gives a little bit better feel so it
makes makes polyglot fit a little bit
better even though you're losing using
different languages together okay so now
we've talked mostly about having these
isolated as libraries or separate
domains separate services but there are
going to be cases where you want to
actually directly integrate two of these
languages together call directly from
Java into groovy or Ruby or Scala and so
on so we'll talk a little bit about
strategies for that so the simplest
answer is that all of these languages
speak Java so passing java objects
around or focusing on having an
interface somewhere usually ends up
being the cleanest way you can go
directly from one language to another
but in almost all cases Java's kind of
the substrate the the common medium that
we use to actually to get data across
that boundary so if we look at a simple
java class here implementation to get
name omitted we've got a simple
structure and you know to exam or two
examples of how the language is actually
call directly into the length into the
Java code from the language itself
closure has the the dot operation here
dot get name on the address object and
then in Ruby's Scala and groovy is
pretty much just a straight-up call like
you would have in a regular piece of
Java code and now of course like we
mentioned in JRuby and in groovy and to
some extent in Scala there's also
modifications or improvements for how
you call it so when Ruby and groovy it
might be addressed that name to access
it an address that name equals as a
assignment that actually calls the
setter so we've got little shortcuts in
Ruby also if they have a boolean
turn value we create a version of it
that as the question mark it's a typical
way of doing a boolean return value in a
rubia method so now sometimes what
you're going to run into here is that
the values are going to be slightly
different when they go across this
boundary the way that scala's lists work
are a little bit different from the way
java's lists work so getting us Java
list into Scala is going to be a little
bit different for JRuby the Ruby string
has a different implementation and is
mutable and has different behaviors so
the string that comes in from a Java
call may actually be turned into a ruby
string for Ruby purposes there are ways
in most of these languages to do an
explicit coercion so turning a list that
you've gotten from Java into a scholar
list or into a closure sequence or to
going the other direction if you want to
call a library that explicitly requires
a java string or a java list being able
to convert it back from whatever the
language users i write a lot of code
between Ruby and Java and this explicit
coercion is incredibly rare because in
most cases will actually appropriately
convert back to the Java type right so
that's kind of the simple way is doing
the language drives everything and the
language calls into Java libraries and
calls through java to other languages
but if you need to call from java into
the language it's usually a little bit
trickier in pretty much all these
languages they have their own quirks
there's differences in how they dispatch
if they're dynamically typed if changes
to types can happen at runtime types are
mutable if there's differences in how
the type systems actually fit together
for example closure doesn't have as much
of an object-oriented feel for most of
the things that you do so you don't
always get an object that you can work
with you may get a function or a
sequence that you can pass stuff too and
there's there's a few alternatives for
how you work with this so the first one
would be just to use one of the api's
that are available like jsr 223 the
scripting api or a raw native API 223 is
it's an okay API it's a little coarse
grained what it's really useful for is
if you have a chunk of code that you
kind of want to toss over to a language
have it run a bunch of stuff and then
give you one result back doing it more
interactively as possible but not as
clean so here we're creating a new
script engine
manager for ASR 223 starting up a groovy
engine in that manager and then just
basically passing it some groovy code to
execute for us and this could be loaded
out of a file somewhere or generated by
another piece of code and Charlie spoke
about this earlier but the the big
pattern here is that you eval into the
host the other language and it returns
something that implements a Java
interface and then you can use that from
Java or another language however you
want because it appears to be just Java
a little bit more complicated example
where we actually are calling into an
individual function that's been defined
in groovy so we evaluate this groovy
code now we have the groovy version of
factorial that we can call from Java
through the scripting API using invoke
function or invoke method now there are
benefits to using jsr 223 it obviously
allows you to do multi language very
easily because it's the same API no
matter which language you're using
obviously the code you're sending is
going to be different you get to learn a
single API and you don't have to learn
each of the individual api's and it also
makes the polyglot boundary much more
obvious for folks that are coming into a
system and trying to understand where
Java starts and where groovy begins or
where closure begins you can see with a
scripting places where you're actually
calling this but there are a few
detriments here jsr tooting 3 is
designed to be kind of opaque so it's
not very transparent not very clear what
happens on either side of that boundary
you're throwing code over getting one
result back and if something else
happens or if there's an error you kind
of have to dig a little bit it is also
kind of a lowest common denominator API
there are features in each of these
languages that aren't represented well
in jsr 223 or don't make any sense so it
can sometimes be cumbersome to get at
those features from Java using this API
and so at least on JRuby we've often
recommended that people just kind of use
a whatever the native API for embedding
the languages whatever they whatever we
provide it gives all the features you
expect so all the obvious benefits here
you get tighter integration with the
language how it's types are structured
the various values and objects and data
structures that it's familiar with how
the language features work
and this viewer set up issues as well
all you need is to have the library for
the language call into it construct an
instance of the language and you can do
a lot more operations than you could
with 223 there are some detriments that
are basically just the opposites of the
223 API language specific everyone has
their own API so if you want to use lots
of different languages you're going to
learn all of those ap is and it does
require a little bit deeper knowledge of
how the language itself works how the
runtime that runs the language works and
what the types are that are available
probably the street most straightforward
way from a Java perspective to access
any of these languages to have them
generate their own regular Java class
files Java obviously likes to work with
classes and it hides the fact that
you're even using another language most
languages can generate a class file of
some form so that you basically have no
no visibility that it's written in
another language some as in the case of
groovy and Scala if you compile them
ahead of time you just get java classes
out there are still some mismatches
sometimes groovy and Scala can define
methods that Java can't call directly
syntactically won't won't compile but it
does make it a little bit easier to use
some of these languages if you can just
generate regular Java code look at the
examples that are a little bit more
interesting or a little bit more unusual
a closure has the ability to generate a
class based on a piece of code a closure
script so here we use the gin class
feature and generate a class called some
example that has to string on the left
or implements a particular interface on
the right a little bit longer example
here actually implementing
java.util.iterator entirely enclosure we
have our closure examples as our package
the class there is going to be in called
instance and we've got an init to
construct it has next and next
implementations all written in closure
now once you what you get out of this is
a class file actually a couple class
files because closure generates all of
the method bodies into little classes as
well but you get a normal-looking class
file that Java can then Stan she ate and
call casting to the iterator interface
and there's no concern about what's
actually behind the curtain you get to
use it as if it's just a regular Java
library regular Java class
you have something similar basically
throw some signatures in here with a
little ruby magic compile it with our
compiler and we get a normal Java class
out again still implemented in Ruby
behind the scenes but you don't ever
have to know that if you're just handing
this off as a library to someone to
include into their application and in
kind of the half way ground is rather
than generating Java classes at compile
time or at Build time is driving
everything from the language and just
implementing interfaces on the fly
sometimes this is a little bit easier
fit the language can stay its own feel
its own way doesn't have to use Java
signatures or or bend bend to the will
of the JVM and it's also kind of more
polyglot friendly in some ways by always
working towards a specific interface
you're setting up a clear contract if
the language implements that nobody has
to carry has to worry about the fact
that it's written in some other language
you've made it clear exactly what you're
looking for example from Ruby and again
all of these languages can implement
interfaces and provide an implication at
runtime so here we're just implementing
a comparator sort of like the first Java
example that we had we can do it in one
of two ways we can either just create a
normal normal looking class include that
interface in and implement the method no
requirement here for Java signatures
because we can get all that out of the
interface information and then just pass
an instance of that in we create a class
that actually implements the interface
the object implements the interface and
as far as Java as far as the code we're
calling knows this is just a normal
piece of Java code we also have another
syntax at the bottom there where we can
pass in a closure that implements that
interface and again it still just looks
like it's a normal comparator nobody has
to actually care or worry about the fact
that's written in some other language
okay close it out so the conclusions we
want you to get from this is that you
know Java is not always the best
language and there are good reasons to
start looking at other languages and
pulling them into your applications but
when you do it really kind of consider
the domains where these languages would
fit if you're doing a front end if
you're doing
web interface may be one of the dynamic
languages and the frameworks that go
with them works best for you if you're
doing a lot of concurrent data
processing maybe that's where you want
to start putting closure Scala to work
and isolate them into their own domains
keeps the integration hassles much lower
and likely make your developers a lot
happier to your fellow developers all
right that's all we have so we have some
time for questions thanks all right
questions anybody yeah here
without maybe
dollar classes
right yeah you definitely can and in the
case of Scotland groovy in particular
there are cross compiling features build
features that allow you to have a
portion of your application written in
Scala build it all together and then
call through like it's a normal java
class the only tricky bit that you have
to watch is like I mentioned the
mismatch making sure that whatever API
you're exposing from Scala is actually
callable from the Java side and keeping
that in tune over over time not using
Scala features that Java can actually
express or call into well Scott looking
to find pretty much any operator syntax
for example plus minus and whatnot and
those become methods that sometimes are
not exactly directly referenceable I
think I think they do see a kind of
encoding of those names for first Allah
yeah I think you can make I think you
can make an object that represents what
that symbol would be or something but I
think you have to do it reflectively
well you another example is doing the
the asynchronous calling you don't have
the same syntax features so this is this
is actually problem that the aqha guys
have run into it's been a bit of a
challenge for them to continue to
maintain a Java API while they're still
using all of the Scala features they
kind of have to keep a set of tests off
to the side to make sure that they're
not breaking the Java API at the same
time all right
not necessarily Scala I believe has a
cross compiler that can do both Java and
Scala at the same time of course if you
if you are any other languages and build
a set of Java interfaces everyone has to
implement that becomes your common build
in the middle and they don't have to
actually know about each other's build
processes yeah there's there's a dilemma
with cross compilation because let's say
you decide you're going to use skull and
Java well that works fine now you decide
you want to use scala java and groovy
and they all they all kind of point at
each other then you're in trouble yeah
modular izing definitely makes it easier
and it's where we recommend trying to
lean when you would start to use a
different language in a project but it
is possible with all these languages to
get everything compiling all together
too so yeah you
there's a book by devashish gosh that is
kind of the polyglot dsl book it
actually does a very nice job of talking
about all of these languages and fitting
them together that's that's one that i
would recommend other ones venkat has
several boom cat has I can't think of
the title right yeah if you search for
search for some of the books that are
out there on polyglot jvm stuff there
there's a few good options check the
reviews anything else all right thank
you thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>