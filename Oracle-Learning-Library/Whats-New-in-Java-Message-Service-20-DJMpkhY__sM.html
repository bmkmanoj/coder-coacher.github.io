<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>What's New in Java Message Service 2.0 | Coder Coacher - Coaching Coders</title><meta content="What's New in Java Message Service 2.0 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>What's New in Java Message Service 2.0</b></h2><h5 class="post__date">2013-01-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/DJMpkhY__sM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning everybody welcome to Java
one on this was the first proper morning
and welcome to my talk on what's new in
the next version of JMS gemma's 2.0 as
it says there my name is Nigel Deakin I
about follicle
I'm developer in the last few semesters
the GlassFish team at Oracle and I also
am a specification lead for Gemma's to
point naught that's Jase are three for
three and we start as you probably get
used to by the end of this conference to
a short short message from my employer
so we'll click to accept and the next
commercial message is just to advertise
I'll be speaking with a number of other
members of the JMS 2.0 expert group
tomorrow a tab off in the that's not
this room I think the one just around
the corner tomorrow afternoon so please
come and I forgive it please come if you
have questions and may want to make
comments but we probably have more time
to talk about those then than we do now
than we will today so let's just get
straight in and talk about JMS I suspect
that well does everybody who knows what
JMS is so I don't think that that's good
so I it was good that I deleted my my
slides to tell you what JMS is but just
a few basic what is and what isn't
which is worth remembering in the
context of talking about a spec is
there's a Java API for sending and
receiving messages with many completing
implementations which actually makes it
quite different for quite a few other
specs with a fewer implementations
there's a long there's a large number of
commercial implementations of JMS both
open source closed source commercial
community and people are making money
out of it as far as the Jamis it's
consume itself is concerned there's it
might not be completely obvious when you
come across it but it's actually -
slight variance distinct variance all
the JMS API there's the API that you use
in Java SE applications and there's the
API using Java EE applications and that
distinction between the two is
always a parent that's one of the goals
of JMS is to make that clear but the
just to elaborate slightly is that the
use the use of JMS within the Java EE
application by which I mean the web
container jb's the application client
adds support that XA jto transactions of
message driven bean z' and perhaps
somewhat confusingly it also removes
some things that were considered
inappropriate for use in a managed
application server environment just one
more slide on what it is and what it
isn't it's a standard api but it's not a
journalist messaging it's not a
messaging system in itself you know some
people say where can i buy JMS it's just
an api and it's not it's not a wide
protocol it's purely what the
application developer writes to send
receive messages it is a Java API as
it's a JSON standard and it doesn't
define a API for non Java clients like
C++ clients or perhaps a web web api
that does mean they could you can't have
mr. uses McCann to have those clients
and indeed many if not most
implementations do have something like
that but that's not sort of within the
scope of what JMS itself is the J is a
bit for the giveaway there and one final
thing is is perhaps describing what it
is at the moment rather than what it has
to be it's an API applications to to be
developed in it's not particularly an
administrative API it's not for writing
management tool it's not for writing
monitoring tools all these api's exist
but they're not standard within JMS but
that's not in this there's no reason it
has to it doesn't have to be like that
but that's how a that's what Jeremy says
at the moment is basically an
application a people
okay Jeremy's to point naught which is
what we here to talk about well JMS is
quite a long established in fact the
possibly one of the most longest
established the Java EE or did the Java
specifications it dates back to the turn
of the century and rather unusually
amongst very well I'd say a successful
well the used API is it's not being
changed for a decade now you come to
your own conclusions about
with why you think that is well but I'd
like to say the reason hasn't been
updated for ten years suggests that the
people who wrote it got it pretty well
right and because not being updated but
that doesn't mean that there isn't I
mentioned in the previous slide that
there's a lot of existing applications
existing implementations already they're
still being developed so it's not as if
it's moribund
I think it shows the success of the
original JMS API and in particular
actually its simplicity its small size
the fact that it just is proven the test
of time but time goes on and things do
change in the Computing's
quite a lots changed in the last decade
particularly in terms of programming
features and it's time for Germans to
point naught which as a specification
initiative it's been being it's been
worked on in the spec in the well as the
expert group for a little bit little bit
over a year now it was launched I said
Jason three three four two last year as
gemes took one nought and there's an
expert group containing about 20 members
including most though not necessarily
all of the chemists er vendors and it's
not finished the there has been an early
draft available there's a link there
that tells you where to find more about
it and I'll be telling you more about
what's available on the that website gem
aspect or java.net but it's not finished
and the so what I'm describing here is
relatively settled but it's not you know
it's not finished it's not an approved
standard quite yet though though after a
year I'm feeling quite confident about
what I described is is what schemes been
there subject to that display let's
start the final release is planned to of
the spec I should say and therefore the
SDK and the ri it's gonna be line -
Jennifer you 7 and the its SQ 2 there
and the my managers managers manager
said April yesterday so I think I'm
allowed to say that as well April next
year for the respect to be released in
the SDK obviously commercial
implementations will come later than
that
so the goals of Gemma's to point naught
have changed over the year but it
started off but well the goals now
aligning with some extend the goals of
Java EE 7 which those of you acts but
most of you who went to the technical
keynote yesterday our simplest TVs of
use is the one that's highest on the
list in the keynote yesterday for Java
EE and that's the same for Gemma's took
or not and in particular to catch up
with these views features that's that
have overtaken the like the rest of Java
EE in the last decade but objects a
messaging system there's a scope for new
messaging features I think the scope for
the far more than there is at learned
Java integration was something that I
think is is basically ignored by the
existing aspect and even though
obviously all Java EE application
servers do contain JMS it's not terribly
well defined in every case how they
should interrelate and exactly what the
API is when you're writing an
application in a in app to run an
application server so clarifying that
standardizing that and making JMS
providers more pluggable between
application servers is another goal
finally minor Corrections and
clarifications never to leave any speck
that's ten years old but there's small
features but I'm not I'm not really
going to talk about that that was there
that if you want to read those their
list in the spec one change since the
project was set up initially is that the
a year ago the goal of Java EE 7 was to
embrace the cloud and platforms of
service but in to reflect the changes
made in Java generally is that the move
towards cloud and paas features has been
deferred to Java yet right so issues
like multi-tenancy within the Germans
provider that's been which we had been
discussing earlier on that's now
deferred until basically that V the
platform as a whole is addressing those
features okay that's it gets more let's
get on into the the the detail then and
and we spend quite a lot of time talking
about the
what we've been to what we the expert
group have been doing to try and
simplify what actually is quite a simple
API already and although I think with
Jeremy is one point one that's the
existing version 2002 is a pretty good
spec you know that yeah I've said it's
proves the test it's the test of time
it's it's worn well but there are some
things that I'd like to say it's a wrong
Gore in hindsight perhaps could have
been better and Oh some code about time
to slide 11 we've got some code on the
screen that's better
this is just a trivial example of a I
suppose it's a little bit of a fragment
of a session being running in in Java EE
to send a message and I just like to
just simply just I hope everyone is
familiar with with this I think but I
just like to take through take you
through a few could make a few comments
on it so 13 lines just to send a message
obviously that depends on exactly how
you whether you put your clothes braces
on separate line or not so I don't want
to labor the point of numbers of lines
of code but there's quite a lot going on
there given that the reaction is in red
which is when you're actually sending a
message so let's just look look at this
a little bit more detail is that what
you're doing to send a message this met
this method that basically takes a
string text string which I'm calling a
payload of the message and try and
wrapping it in text message and then
sending it to to the JMS server so what
you've done you've actually got to
create a connection a session a message
producer and a math text message object
all just so you can send the message so
that's format for objects you have to
create just to send the message and I'm
going to say really that does it really
need do you really need to create so
many objects one of those objects you
have to create is a session Jemma
session and to do that you API is to
call the create session method on the
connection and you pass in two arguments
and there's a lot of scope for
confusion there - two main main issues
with us two arguments one is that
they're actually not independent
arguments the first argument specifies
leads transacted and the second it
specifies that if it's not transacted
what the ignored replayed is and those
two are not clearly independent so
really why the two separate two separate
arguments do several parameters it's a
fairly trivial fault rather more
important is that actually if you read
the EJB spec it actually says in that
particular case where you've got a jerk
JT a transaction those arguments must be
ignored so what your fault so what the
poor developer does is he thinks out I'm
specifying to be all to acknowledge but
in fact that's always by according to
the JB spec that's ignored and the the
session you create actually follows the
JT a transaction so the very least even
if you know what you're doing you've got
to lie
basically because you've got to put
something in there and and that's just
again it's just an untidy earnest but I
hope you can clarify just lay the point
slightly is boilerplate code because
this code is almost the same whatever
you did you know you're always crazy
creating in connection with connection
factory always creating a session
probably with the same arguments or none
always creating it in this case percent
if you're presenting a message you've
got to credit producer and then well
it's actually more you've actually got
to create the message itself which is
the line first on your black below it
and then you could send the message and
then perhaps yeah almost almost got the
end of this yes then you have to close
the connection after use because a
connection is a valuable resource it's
other reflects a connection to the
server or even if they're pooled you
have to return it to the pool after use
otherwise you run out of them so you've
got to call clothes in a finally block
which is all bit just clutters up the
code it's not complicated but he just
cluttered it up and then finally you've
got to do exception handling almost
every single method in JMS no matter how
trivial even if it's just getting a
message property is always declares that
it throws germs exception which means
you're forced in the code to catch it
there was even compile or else declare
it as being thrown by the method so it
just splutters up the codes
quite often when you don't actually know
how to handle message because every
single methods potentially shows them it
could throw an exception there's you
don't know what what you wouldn't know
how to handle it even if you you would
know how to handle it so all you can do
is just log it or else possibly throw it
just bail out there's nothing not very
much you can actually usefully do quite
in a lot of these exceptions okay so
what are we doing to simplify the JMS
API for Gemma's 2.0
well the first first thing is the brand
compatibility is an issue here we've
obviously we have to what we can't do is
just change the existing API that sort
of nine rule of any of these specs is
that we don't want to say rest assured
expect anybody to change their code for
it to work in the JMS to environment
that's you know that's that that's a
that's a criterion for the spec and if
we discover that that it had been
necessary than that's a mistake
so we gives us it gives us limited scope
to actually change the existing API
because if we can't just delete okay we
just can't remove methods for example so
there's a sort of two to two pronged
approach one is to try and simplify the
existing API write what the phrase
existing course implies there's a new
one coming up but basically so a
simplified existing API where it won't
break compatibility but also to find a
new API which is basically easy to use
which we hope and the objects that the
interfaces that I'm gonna be talking
about are all called gemma's context
Germans producer James consumer and I'll
say more about that fairly soon and the
the third prong of the strategy is to
exploit injection of resources which you
see new as made available by CDI context
dependency injection technology which is
now part of the Java platform so
exploiting that to allow these objects
the germs context object to be injected
and managed by the container which
rather expecting the application to do
it
so I'm just going through those quickly
the taking the first of those then is
what can we do to simplify the dermis
API itself
Jem's 1.1 api you know those things that
are already defined there's limited
scope but the but one small change is to
perhaps tidy up that method i complained
about earlier which is create session
taking two arguments still exists will
always exist forever but a new i said
those two methods are sort of not
independent so actually you could have a
single argument version which had just
contained at the same information just a
little bit easier to to understand and
in java ee you can actually use it in
any case a method with no arguments
which just simply has a follows the
default behavior which in the case of is
java re' transaction if you that's the
method you could use because that just
means I want my session to follow the
chart the JTA transaction so it'll be
committed when the container comes
transaction all transaction manager
commits transaction still talking about
how we can simplify an existing API I
mentioned the the need to actually call
close whenever you've used any of these
objects they're really the closing the
connections of all the matters what we
can do here is take advantage of a new
feature called
in Java SE 7 called alter closeable api
and what that does it allows you to use
the syntax like this to save the but
save you the bother in the application
of actually calling clothes so I'm not
going to describe in detail how this new
that basically the try with resources
all too close will feature of Java 7
basically allows you to do use that
syntax where in a try block so there's a
new between the round brackets of the
try block
Juden new in Java 7 is you can actually
create these closeable resources
connects your create session create the
connection and the create the producer
and then when the block in braces comes
to an end the JVM we'll just call closed
on those objects so use its own a sense
it's just you still have to define where
it's closed with the closing closing
brace but it just means that the
container that the JVM will take care
of calling clothes for you so it just
makes it a little bit simpler then you
if you didn't want to close it then
don't use a block like this just use use
the same API use now so you know yes
this is not removing the ability to call
clothes yourself if you wanted to cash
it in a field somewhere yes you can
still do that but then don't use
essentially that that syntax has gotten
implicit close at the end of the first
brace it also means that if you get an
exception when you're closing it it gets
handled with a single exception block
and it's nested not nicely just some
it's just generally a little bit tidier
but so that's one but basically any book
Java SE Java EE that that's just an
optional new feature you can use as well
so let's just talk about the new
simplified API then so I've talked about
how you could change the existing API
let's talk about the new features for um
essentially the new API that's going to
be made available in Jonah's to point
naught which as I mentioned earlier is
is based around three new interfaces
three new objects a germ is context a
JMS producer and jams consumer and
here's an example I'll just give the
example initially of the use of the well
I keep calling the simplified API which
is probably one of those phrases that is
sort of firm the hostage for tuned but
I'm calling it I'll call it simplified
API to compare it with these existing
API they'll both run alongside each
other and when I quote the centerfire
API somewhere to be simpler to use it's
not simpler and functionality everything
you can do with the old API you can
still do with the new API and you know
you shouldn't have to quickly switch
back to the old API just to do something
advanced so but I think I just wanted
you to see here as you're sending a
message there's still a method send down
there and but the number of lines is you
know if we're trying to have a heart
headline figure what were thirteen lines
before or is now five lines
it's Dalton exception handling there so
let's look at this a little bit more
detail now are the busy slide but the
main thing is is we're using this try
with result result with resources syntax
I should
first of all because this new object
James context you need to close it after
use but because it influenced all to
close abroad we can use this in tax to
to save you having to write that so
you're creating a Jamis context from a
connection factory so instead of
creating a connection you create called
a method to create context to create a
German context and that's so the James
context is basically in terms of the old
API you can think of it as combining the
or encapsulating a connection in a
session the next
so that's you've got Gemma's context
then what do you do you want to send a
message and a sent anybody you want to
send a text string in this example
you've passed in and you want to send it
so well the next line code the line of
code below context dot create producer
dot send and you pass in the name of the
queue or rather the queue object and
then the payload notice the list text
string directly not creating a message
here so you're not creating a message
object here you're just passing in the
string and saying send it so the idea is
is that you've got you didn't have to
create the text message there basically
we've still got the catch block here
because you might want to catch
exceptions you know the same exceptions
will be thrown except it's a different
type of exception that's close now
called a run touch Jamis runtime
exception which is an unchecked exact
exception that's the type like runtime
exception that you don't actually have
to the compar does not force you to
catch it if you don't it'll just get
passed up to the caller so so in some
cases where all you do is log it you
don't quite know how to handle it log it
or possibly throw it then you can
actually often leave the exception
handing out completely so now it was
basically giving that capability to to
just ignore exceptions essentially and
let the calling method catch it if you
want to use it or you can just catch it
like it is now and then finally I think
the last point was yes there's no
clothes here because we're using the
auto plausible feature of a German
context and wrapping it in a try block
like this tribal resources block hello
yes please
yep
yes that the project the I will just say
I'll talk with a producer in just a
couple of slides time but they it's like
hey you could think of in terms of
anonymous producer under the old API
where you you pass in the name of the
destination each time I'll just come
back I'll talk about abuse in just two
slides if you if I may but I'll just
talk about that just recap the gems
context first so this is new object so
you can think of it encapsulating a
connection and the session of course
exactly how it is implemented is up to
the provider but I think it's sadly
logically you can think of it as being
the connection and accession together to
one objects or two and also an anonymous
message producer as I was just saying is
the you can in the old API a message
producer the OL is the object that used
to send messages when you create it you
can either basically hardwire it with a
particular key or topic or else when you
create it or else you can create to be
anonymous which basically means you pass
in them the name the cure topic in the
send method and in the case of a jammers
context you can think of the gems
context of having inside it when it's
created or lately a connection and a
session and a message producer ready for
use as it were when you to send a
message have you created from the
connection factory we're not trying to
bootstrap it from anything else so the
new method on connection factory create
context and you and we passed in a
session mode which is very much like the
acknowledge mode when you create a
session so you can say strip transacted
or technologies okay oh client tack just
look you know effectively you're
creating a session there so you have to
specify what it is and is actually an
argument there's a variant that doesn't
take any arguments this is because it's
wrapping these valuable objects you've
got to call closed after use or indie or
else you just wrap it in a try with
resources block and then the JVM will
close it and then I'll say a bit bit
later is the other useful thing about
this is you can inject it into a jar
very web or EJB application now I just
said that it because it encapsulates a
connection in the session in one object
and that's a perfect fit for Java EE
because in Java applications you're only
allowed to have one session
every connection so but in Java SE or
indeed the application client you can
create multiple sessions on the same
connection just remember that point
about a session is that effectively
defines a thread of control access to
the the resource of the connection so if
you want to have two threads working on
the connect using using a connection to
send or receive messages you have to
create to two sessions but you only do
in Java EE but if you want to do that
you can do that you basically want to
create a second journalist context that
basically reuses the same connection of
existing one so just the way the API
works is you create the first connect
context as described in the previous
slide and then you can just say give me
another context using the same
connection so that's a method create
context on the first context so and
finally what do you do with this gemma's
context obviously what you really want
to do is you want to use the send or
receive messages so you need to create
Janus producer objects for sending
messages and Gemma's consumer objects
for receiving objects receiving messages
and then finally I mentioned that a
design goal of these new API is that
every method it's not as far as possible
methods are not forth don't force you to
catch exceptions in the code so all the
exceptions they throw will be unchecked
subclasses of runtime JMS runtime
exception okay moving on to the GMs
producer then this is this is the method
this is the object that holds the
methods to send and configure the
messages you're sending it's intended to
be a lightweight object and essentially
it's very similar to a message producer
in the existing API so what you do you
can see is two examples which are not
the same so from a session you call the
method create producer it gives you in
Jamis 1.1 it gives you a message
producer and you can call the send
method on that send the message do you
do the same Germans tip or not the
difference show the difference though is
more evident if you want to do a bit
more than just send a message if you
want it for example set various and I'm
calling delivery options like you want
to specify whether the message you're
sending is persistent or non persistent
or you want to send the JMS message
priority or you under send the Germans
time to live on the message the expiry
date
X parrot i m-- or how long the message
will live until it expires in Jamis 1.1
you've got to you've got to have a
variable that contains the message
producer and then you have to call these
methods one by one on it and then you
can use it to send the message that's
jonas 1.1 so the forces you to have the
api forces you to have the variable
which is the message producer because
you've got to call several methods on it
and in Jamis to point north the API is
just very slightly since it's different
in that the all the methods on on the
pecan the producer object will return
the producer object so you can chain
them all together so set delivery mode
for example it whereas in Gemma's 1.1 on
the MSB so that just that's a voyage
method doesn't return anything James to
porn all it returns this it returns the
context so you can just check trading
them together it so it's sort of
syntactic sugar I suppose but it doesn't
mean you don't actually have to tell me
where there declare a variable which is
going to be the producer object another
feature of Gemma's producer is just
slightly different to this is that if
you want to send message properties in
Jamis 1.1 you send a message message
property you set message properties by
creating the message objects and then
call methods like set string property
set boolean property to to set to set
them and then you pass the message into
the send method Germans to point not
were actually allowing you can still set
those properties on the message
however as were convenience you can also
set those message properties on the
producer object so that means you can
just add the method set property to this
chain of calls so that example in this
example here at the bottom where we're
creating producer and we were setting a
property food to bar that what that's
and then sending a message and what
that's actually doing is saying when you
send the next indeed subsequent messages
we want the message is to have its food
property set to bar whether that these
are just arbitrary properties now why do
we need to do that well it's I suppose
it's perhaps a little bit to make it
more consistent with the other ones
but it also means is that it then allows
us to have some new fact I'll go talk
about them just a second it allows you
to create some new methods that allow
you to pass in the message payload as as
appearance directly so that example
there the bottom your that when you get
to the send call your passing
destination and then just a string hello
in that case so what that's that what
that what that method will do is it will
in turn this will create text message
and set it to payload to be hello it'll
also set its property food to bar and
then they'll send it so again so we're
saving the need to actually create the
text message here in silk road's if you
want to those method ap are still there
but you can just this or you're not
forced to by the API so in a sense in
that whole line the only variable you
actually have to have declare is the
context the beginning you don't have to
declare the message producer it just
gets created it's a lightweight throw
away object you don't have close it and
then you don't have to create the
message object as well these are the
methods on producers to send the message
payload directly this is a feature for
four out of five existing Jamis message
types you may remember while just going
through that the the you the if you pass
in a a map of a string against an object
it will create a JMS map message for you
if you pass in a serializable object
other than the string it'll create a
german object message if you pass in a
string get off to cradle it message a
text message and if you pass in a byte
array it'll create a base message the
one missing there is a stream message
which doesn't quite fit in if you want
credit stream message you just have to
create a stream message and write to it
that's using the api and as i said be
because you're not actually creating a
at any point in the actual mess you
don't actually a visibility of the Jamis
message object here that's why if you
want to send things like message headers
message properties you you can set these
all on the pajamas producer object okay
that's talking about consuming objects
this is actually there's let's change
here essentially the new object called
the Jamis consumer object which in many
ways is really much the same as a
message consumer object
so it's much the same functionality so
if you want to synchronous events
consumer object you have to pass in the
destination just like now and there you
can call the receive method to in that
case that receives a message with a time
out of a thousand milliseconds if you
want to receive messages asynchronously
you create consumer dermis consumer
again and in that case you set it to you
you set a gem it's message listener its
existing API so there really is no real
difference one difference with this
though is that if you create a gems
consumer here it also madly start the
connection I don't know whether you've
hit it but in my work one part of my job
is to monitor some of the user forums
for users of our products Oracle and one
of the Communists there is is people
particular people who haven't used it
very much so and GlassFish of course has
a lot of students and people who who
want for me the JMS who they they call
all the api and then they're waiting for
messages and they say why don't I get
you know what you know here's my code
and they give you a few big code sample
I want I'm Sydney messages what I always
do is even without looking at the code I
say do you remember but I do look at a
code you remember to call connection dot
start that's the method that actually
turns on message delivery to a consumer
so it's just a trivial thing that we all
get used to remembering but in terms of
simplifying it is that the Jemez
consumer is that that connection has
automatically started for you if you for
some reason don't want to do that you
can't configure it so doesn't and
conversely would i mentioned that you
could send a payload directly using
Jenna's producer therican conversely you
can receive when you're receiving a
message synchronously you can receive
the payload directly so in that the way
the API works there as you pass in the
name of the string that you name of the
class you're expecting essentially so if
you're expecting it to be a text message
you can call receive payload and you
pass in string class and no receives as
to text then it receives you receives a
strip and then what it returns as a
string
you don't need to cast it so what you're
saving here is the need to reciprocate
to cast it to the appropriate type and
then to get the payload out if you know
what the payload type is you can just
call receive payload and we'll go you
well spotted that's the the main
drawback of this is that you because you
don't see the message object you can't
access the message headers this way so
you have to decide that tell me whether
you think this is useful but it's so
whereas with sending the payload
directly you do you hat you aren't using
the functionality here you are losing
the ability to look inside the message
headers do any suggestion is to have
simplify the API so you could please
tell me and there's an example of
receiving message payloads directly okay
now so I've just talked about the
jammers context object which in create
explicitly using a create context if
you're running in a Java EE web or EJB
container is a new feature that's going
to be added as the ability to you inject
it into your code so yep so that that's
and that's a simple example and I think
if you wanted to sell this you'd say ah
you remember it went around from nine
lines of code to five lines of code well
now it's gone down to one line of code
though I've skipped the message the
there's no there's no try or create here
there's no try block to create it to
create the object here what you've got
here is just a is let's go so the
picture is that what we're doing is
we're injecting the Gemma's context into
the application at inject then there's a
annotation that defines the connection
Factory and then private gems context
context so so that's injecting the gems
context in your object you've specially
it that's injecting the gems context
into your session being say you're
specifying the connection factor you
want in this normal J the normal EJ
normal Java EE way through the gender
gender I name of the
connection factory and then once you've
done that the container will take care
of creating it for you when it needs and
the container will also take care of
closing it at the end when you finished
with it essentially so there's no needs
for an explicit call to clothes there's
no need for an explicit try with
resources block to basically tell it
when to close it the container will know
when to close it what do you mean yeah
I'll explain why it knows when to Innis
in the next slide but so that's just so
look just a little bit more in the at
the API to injector gems context first
thing is is the first the simplest
version of it is just at inject private
say James context context you haven't
specified a connection factory here
that's using the new feature of Java EE
which is a platform default connection
factory which is going to be built in so
obviously nine times out of ten
particularly simple examples is you is
that the container knows where the JMS
is because the geminus is part of the
the app server so if that's what you
want
you don't need to bother the connection
factors at all you just say using jet
context and it will know to slightly
less common our variants is that if you
want to pass it in the specify
effectively arguments to create context
especially the session mode is you can
declare them using a session of JMS
session mode annotation and if you
wanted to pass it in user name/password
which again effectively parameters to
create connection at the moment is that
you can pass them in with a germ as
possible credential annotation so that's
really just I mean the reason those are
there is because existing API the null
injected API requires those to create
connections and sessions so we don't
want to lose any features whether you
that or not so that's how you can
specify those if you inject it now I
said that when you inject a Gemma's
context the container will take care of
when to close it and when to create it
and I don't know I can ask how whether
half a minute
would people here describe themselves as
knowing what CDI is
okay fair fair number of people
essentially context and dependence
injection it is the technology that is
being used to implement the injection
injection of this germs context and the
key thing about so basically c d---eight
c VI concepts are used in you know
either the spec is defining this in
terms of CGI con concepts and the
missing important concept here is the
scope what the scope defines is
essentially once once the container is
created the jambs context how long does
it live before it gets closed and the
other thing it the scope defines is if
you created essentially if you have two
different beans for example you know one
calling the other and they both inject
Gemma's context if they're both being
called in the same scope and all the
annotations you collected it to qualify
it are all the same you actually get the
same object so you can have one session
being sentiment injects a context and
use it to send a message calls another
session being which also injects a germs
context and use it to send a message if
they're in the same scope then you
actually get the same object under the
covers and what that means is you're
effectively you get the same session
which can be more efficient within a
transaction
essentially the essentially the the the
contact the connection in which this
wraps which effectively pyjamas Contin
capital aids can be pulled by the your
container if it wants to since since
that doesn't change so so you say so
well you said you said pool so obviously
that's the reason if it's pulled object
is basically the Gemma's context has a
pulled connection in it the fact but
that's why that's why you need to call
clothes after use because that's what
returns the connection to the pool and
so what I just jumped over the third the
first bullet points there is what is the
scope well in JTA transaction the scope
is actually the transaction so
affectionately the Gemma's context our
transaction scoped
CD only does not define such a things as
a transaction scope at the moment but
the JTA API will do as part of the Java
EE so what this means though is that
then you would inject it it when it
first it gets injected about you when
it's first used a Jones concept created
and then it won't get close until the
transaction is committed which obviously
will be typically in the session being
at the end of an effort and that's when
it gets returned to the pool if there's
no jdi's transaction what we can't have
transaction scopes so it's just request
scope where request scope is has a as a
clear defined meaning in CDI so that's
basically the what has going to say
about the new simplified API this is
introducing Jonah's context object Jones
producer object Jonah's consumer object
effectively doing much the same thing in
fact I'd exactly the same things
existing API but just a few small
changes to the API that we're hoping is
making it simpler a little simpler to
use in particular to reduce the amount
of just boilerplate code you have to
call you reuse every single time yeah
please
okay yeah okay
I'm sorry I can't quite
yeah absolutely so that's so this is I
did slightly gloss over that is that
I've said in a Java very transaction the
the argument to create session are
ignored
therefore in if you if you weren't
injecting the Jenners context what you
you wouldn't actually specify a session
mode one session that I'm talking about
that it's transacted whether it's client
acknowledgments Jeep's okay or auto
technology so normally you don't need to
specify the parameters great session
however in the missus um with something
that I was gonna talk about but in the
in the gemma spec we're trying to
clarify a little bit is that if you're
not in a JTA transaction then the
parameters are observed in particular in
particularly you can specify whether
it's dupes okay or all technology and
that's when you would want to specify a
session note well you might want to be a
specified session mode but yet in the
normal in the normal if you only jjt an
transaction even if you specify session
mode there that would be ignored
yeah sure
yep
the second you don't see the session
objects that's encapsulated what if
you're using this API you never have a
session object intellect led in your
code that first of all I'll say that
there are what that this is not the only
way you could have invented the API but
this is what we've come up with but that
if I can ask you I just had them do you
heard the question is basically you were
said you were saying can you simplify
the API even said even more well I have
the answer is Ken can you come to both
tomorrow and that's what that will
probably live but all time to explore
some of these issues I think I probably
ought to carry on I mean you ask a
perfectly fair question and indeed
that's one of the things I bet I'm
asking is is getting to some feedback on
on what you what you think of that and
because this spec will go out formal
draft and I've interested to see what
the feedback is to this obviously one
point about this is this case this is
meant to be complete it's implementable
but again this above tomorrow where
there should be time for more discussion
basically what I like to get across in
this this talk is just what basically
going to be written is written into the
straw spec as it stands at the moment
and then please do then I'd love to have
lots of comments on it so thank you for
that point so I'd like to move on from
because we had well I've taken some
questions so I presidential worries
about too much time at the end but the
before I finish I do want to talk about
some real messaging features that we're
adding to Janice
so this is this isn't this is just I
suppose they do
this one is so so we've got a mixed back
in it basically if features now I just
like to go through one by one there
aren't too many of them the first one is
about an easy-to-use feature for durable
subscriptions is to make job
descriptions easy to use at the moment
your subscription to a topic is defined
by client ID and your subscription name
you have to specify and the change we're
going to make is you no longer need to
specify the client ID if you don't want
to so but it's a tuple that defines the
job description name at the moment and
that will still contact continue if you
want to but if you if you if you really
can't think of why you need client ID
the API won't force you to set it so you
can leave that unset and if you in over
in Java Eiland is that for an MDB the
container will actually generate your
prescription name for you if you want it
to be the name of the MDV so that's just
an ease of use something that a lot of
vendors already do another new feature
delivery delay you can think of this is
this is an example of feature that a lot
of vendors already have and we just want
to standardize it and this is basically
allowing Jamis click application to
specify that a message won't be
delivered until a certain length of time
is elapsed and the API is very similar
to expiry setting the Jamis expiry
there's a method on Gemma's producer or
indeed on Janus but I'll message abuser
or Gemma's producer to just pass it in
another feature that's coming in is an
async send this is actually Java SE
feature because it's rather than an app
server feature and it allows you to what
at the moment what happens when you send
a message a persistent message is that
the contract quality service contract is
you call send and then what should
happen is in a typical client server
implementation we don't define exactly
what this is going to happen is that
you'll send the message to the to the
server and then the server will write to
a business install when that's finished
it'll sending knowledge of it back to
the client
meanwhile while all that's happening the
clients call to send is blocked and
waiting for it that's a typical
implementation and what we'd like what
we want to allow is for the
acknowledgment to come back
synchronously so what that means is that
you've got you you your call send you
send the message and then effectively
once it's on the wire that the method
returns and the application carry on and
do something else
whilst the acknowledgement is coming
back and then when the acknowledgement
will come back a bit later you can get a
notification by calling a completion
listener callback where a condition
listener is a simple callback method
that's got a on completion and on
exception methods so basically when
acknowledgement comes back that the on
completion is called assuming successful
and then you know that basically the
message the message was delivered and
sistered with the same quality of
service then if you just called enough
and all and ordinary send so the idea is
that is that that can allow that you can
either allow users to send a whole
stream of messages without waiting for
the axe to come back before you to the
next one you know they can come back
they synchronously so you can be quite
useful when streaming a hot large number
of messages together and it can also be
handy if you actually did know you
wanted to do something out some
computation while wedging for the
acknowledgement I can I actually just
carry on because I think I'm running a
little bit out you know gonna run a time
I said there will be time tomorrow to
talk about any of these issues another
new feature is a modest change to make
it easier to handle what I think
generally called poison messages the
issue about this is that if you're
delivering to an MDB or indeed to a
message listener is that if the if for
some reason the application doesn't
quite can't can't handle the the
exception can't handle the message like
for example trying to write up to a
database and the database is down all
you can do what how can it handle that
typically what you do is throw an
exception back to the JMS provider and
then what happens is then the Jemma's
producer just gems provider sends it
again and again and again and at the
moment JMS in the Jamis spec is
effectively that's all that happens is
that no so there's no way of saying I
can't handle this message can send it to
a dead message queue or something like
that and I want to carry on receiving
the next one
now there is a I think there is a scope
to add say dead message queue handling
to JMS but this isn't it this is a much
more modest feature which is to
basically allow an application to
implement that themselves and that's to
say the change that is coming is Gemma
swamp add one to point naught is to
actually force the require the Gemma's
providers to actually tell set a message
property to say how many times have you
actually deliver this message well
that'll do using that for the property
it's already in Jonas 1.1 is an option
and what that will do is will allow the
application to be able to say hang on
I've had this message ten times now I
clearly don't know what to do with it so
I can now write it to a dead message
queue of my own something like that so
it's basically a way of allowing
frameworks or applications to develop
their own dead message handling on top
of dermis and the last of these small
changes to new messaging feature is a
way of making consumption messages from
a topic more scalable at the moment you
if you want to receive messages from a
topic you receive it through a
subscription you know it's basically
represents your copy of all that of all
the messages on the topic and at the
moment in JMS you can only have one
thread consuming messages from that you
know be only one session consume
messages from that subscription and it's
what we're going to do in James DuPont
is allow you to have multiple consumers
multiple threads all consuming messages
from the same subscription whether it's
durable or non durable in the case of
julep scription existing API is all you
need you don't even new API for that we
just allowing you to create a second
consumer on the same existing
subscription at the moment will cause an
error in the case of non durable
subscriptions you need need you do need
to be able to say which dual
subscription are you trying to create
the second C over to so we need to
invent a new concept called the shared
subscription name so that's what that
API is called
so that's so that's just a quick summary
of some of the new features new gem new
messaging features I could say there's
also a a set of features in the set new
set of features to improve the use of
JMS within Java EE and I think I'm just
going to just go to a couple of specific
examples so I don't run too out of time
and the first is in this is Java EE
application now there's a new I
mentioned this before there's a new
feature called a doof platform default
connection factory so in getting if
you're running an app server the you
know an app serve always has a built-in
Jamis that's part of the contract of
being an app server so it knows where
it's JMS provider is so it's always dry
slightly pointless in that case of
expecting application to create a
connection factory that actually just
said well use your own because the app
server knows it already so they will now
always be at least one built-in
connection factory called JMS with that
name which the application can just use
so you know if you want so basically you
can just if you want to inject that
connection factory who's now that
resource and that connection factory
it'll always exist you don't create it
the other new feature that's coming into
gems tip or Norton java re' 7 is a way
of making it easier to for an
application developer to actually define
the Jamis resources their application
needs at the moment the application
defines the just says I has the Aten at
resource annotations that says I want a
Gemma's cure @qq or topic or connection
for actual TB at this jane di name but
there's n't but the job of actually
creating them is just left to the
deployer or the administrator what these
annotations these are now will do is
allow the application to actually in
define what Jeremy's resources they're
expecting so in this case
the top one is to define the Germans
connection Factory the bottom one is a
cure topic and tip and essentially the
the idea here is that the you could is
that the application developer could
define enough information to completely
define the keyword topic here however
the that's not terribly portable because
that would typically part of the
definition of these is you know is
implementation is dependent on the
installation so the general idea is that
the application developer specifies the
the sort portable aspects of it like for
example they're expecting a connection
factory of a certain class or expecting
a queue of certain name and they do that
using annotations and then the deployer
fills in all the gaps all the missing
information using new JMS elements gen
so xml elements in the jablome
descriptor so in that case if at the
bottom example would be the connection
factor they're defining the host of the
port of where the genesis for example so
so the idea is then is that the generic
information is provided about the
requirement is provided in the code
using rotation and then the the rest of
the deployment specific information is a
debug deployed by the deployer at
deployment time and then those pieces of
information together can be used by the
container and deployment times
automatically create the resources you
need rather than having to use
initiative tools or whatever I'm going
to go through these fairly quickly but
one of the things another feature that's
coming in gem is to open door is just
catching up on some standardization gaps
so I think I'm going to go through this
fairly quickly but basically there's a
number of properties of a NDB that are
just not standard at the moment even
that which is perhaps of a surprise so
I'm just going to standardize some of
these things you probably thought was
standard already which is an API to
define the so this is message driven
annotation for NDB and RBE and there's
gonna be a new standard property define
where to find a connection factory a new
standard property so that was the
so the the queue or topic that you're
coming from and here's a new standard
property to define what connection
frankly to use here's a standard
property defined the client ID in the
job description name these are all
things that you might thought we
standard already and indeed most
generous vendors already support those
but they weren't standard they weren't
mandatory before to support them these
now will be I think the final thing that
we want to say about Java EE there
Jameson Java EE is one of the key things
about JMS is that it's a it's a
technology to allow one application
server
well one system to talk to another so
each is uniquely the one use case where
you might actually want to talk to a
foreign application server you know if
you want one application running in one
app server want to install to another
application in another app server you
might actually need if these two
application serves are using different
technology one was classifications
WebLogic you might you might actually
want to send a message to it like the
foreign app server and the the key thing
to to enable that is we want to make it
easier to to basically plug in for it
into an application server to actually
plug in a some other foreign app JMS
provider so for example you might want
to have if you've got a glassfish
application if you wanted to send
messages to I know WebLogic JMS you
might want to from your glass dish code
that's something that is not that we're
trying to make that much more isn't it
as an expectation in the code the
ability to basically use one JMS
provider in another app server and we're
going to do that by basically making it
mandatory to for it for each Jamis
vendor to provide a resource adapter
that can be plugged in so this is the JC
a this is the JC a architecture defines
this concept of a sought this component
called an assorted out to which
basically is is a sort of portable unit
that you can plug into an application
server and so a lot of journalists
providers already provide a resource
adapter
to allow at least in principle their gem
has to be used in applications running
in different application servers and
what we basically do is to give that
give that the full supported JMS by
actually requiring it so this is summary
of what's new in Jerez to point naught I
mentioned sympathy ease of use some new
features scope from for many more some
some better tools and specifications for
Java integration some clarifications I
didn't go into detail if you're
interested this is where you find out
more there's going to be a demonstration
at the fact that this afternoon at the
demo grounds in Hilton of some of these
features in in action at the simplified
API there's a boss tomorrow where those
of you who had questions that I haven't
answered please come back and give me a
hard time and the others hard time about
those then because that's a good
opportunity to talk about these features
and all the things that are lit that we
haven't done the draft API is available
on that website the slides of this talk
will be at their website Jonas Martin
spec java.net and there's a benefice to
come get involved if you want to and
please do try the latest GlassFish bills
and I think oh there's just a reminder
that there's above tomorrow I think
that's probably I'm out of time so thank
you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>