<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Case Study: Rewriting an Open Source Music Program in Scala | Coder Coacher - Coaching Coders</title><meta content="Case Study: Rewriting an Open Source Music Program in Scala - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Case Study: Rewriting an Open Source Music Program in Scala</b></h2><h5 class="post__date">2013-01-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/cCG1Uv61whY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so this is a case study of rewriting an
open source my open source music project
from Java in tuscola and it was actually
sort of an accidental experience in that
I had taken dick wall of java posse
fames stairway to scala class and you
know thought okay what next I need to do
something I decided to rewrite my own
project into Scala and I got a
ten-to-one reduction in lines of code
and I'm like okay now I got my attention
because this is sort of my first real
scholar project so I'm not even you know
any kind of expert in the language and
so I thought you know let me dig in and
see what happened how did I get a
ten-to-one reduction of lines of code
and almost more interesting when I I
didn't really set out to do this but
when I looked at my at the code that I
had written there was only one mute a
table variable everything else was what
would call final in Java and I would not
have predicted that that was possible
but I did it without even sort of
meaning to so I'm hoping to give you if
you're if you're new to scholar or
thinking about doing Scala I'm you know
15 feet ahead of you but I've seen 15
more feet so we'll take a look at that
the obligatory background I relatively
recently changed jobs from motorola
motorola mobility where I did video and
demand for a bunch of years to a small
company called cabot research that does
financials so some of the materials says
motorola muslim says cabot but i'm out
of the big company down to the little
company and i do a bunch of writing and
like i said i think of myself as a scala
advanced beginner and good experience
with a bunch of languages so you know
been around the block with languages but
still pretty new to to scala so what
we're going to do here is we're going to
basically say you know some what are
some of the reasons that that we did the
rewrite i'm going to give you some
background about
the prop about the system that was the
target of the rewrite I'm going to give
you some description about it I'm going
to give you the world's smallest primer
on Scala and then we're going to walk
through the code basically the gist of
it is we're going to go back and forth
between Java in Eclipse and Scala in
IntelliJ and we're going to see what
what the what the differences are and
similarities and then we're going to go
you know do conclusions takeaways and
stuff so hopefully anybody know what
this acronym stands for ok it's learn a
new language every year it's a it was
coined by Dave Thomas one of the
pragmatic programmers and he basically
said that every year try learning a new
language not that you would actually
start using in production and not that
you would actually even go to the point
of becoming proficient in it but you'd
get yourself exposed to it and so you
would just learn some learn some new
things you know there's a lot of
languages out there they all take
different takes is they have different
takes in the problem space and sometimes
just by being exposed to one you can
bring the concepts over the second point
here sounds a little weird why is
functional programming like no SQL at a
certain level it's it they're not at all
similar but functional programming is
one of the backgrounds of Scala and if
you've done any job hunting like I did
recently functional programming and no
SQL are the buzzwords that you're
required to have on your resume and
you're required to say that you've been
doing these things for ten years even
though they may not have been around for
10 years so I looking for some with four
years of iOS 6 6 experience so these are
good things just to even be able to be
aware of and the other thing is that
thinking differently does make you
smarter and there's been a lot of
research that says that keeping your
brain active is actually a very good way
to stave off Alzheimer's so although the
type say
people don't approve of me making the
statement skala prevents alzheimer's
advanced calma syntax may cause
Alzheimer's but the point is we don't
have to go there okay this so I'm going
to assume that most of us here have
learned any language we've learned it in
language periodically and we type in you
know hello world we type into something
into the ripple and woohoo hello world
I'm an expert and what do I do now and
you can sometimes get these you know
500,000 page books that walk you through
an example but it's hard to take that
and go to your boss and say I want to
start using Scala or Ruby or how school
whatever you need something in the
middle I think of I became a private
pilot and the first time i soloed i took
off when i landed and the next time they
let me in the plane they didn't say go
on a cross-country trip with your
friends they said take off and land
again and then take off and go 10 miles
out and come back to the airport and
land and that was a good thing I got
lost but I made it back so small
advanced beginner step step by steps are
really a good idea in part because
advanced beginner problems like you work
on us on just a subset of the language
like to say that in in if you think of
like C and C++ is the feature set being
about like this I'd say we use about
this much safely i mean out here in the
edge there's the template libraries and
all kind of crazy things java maybe you
know this is the feature set and this is
what we use we use we use most of it i
think of scala as bigger and we have no
idea yet what the best practices are for
the parts to use but i'm here to tell
you you can productively use this little
bit that isn't scary and it's a it can
give you a lot of power so advanced
beginner projects are good so my open
source music project was built upon a
base of my friend Dave Coley's open
source project called Jeff you some of
you may be familiar with it he's given
about for talks here in past years
basically the problem that he set out to
solve was if you do midi programming
it's horrible you have to read like 60
lines of code to write a single note and
Dave didn't like to do that so he wrote
a system that lets you basically just
say you know you know plays cdef nigger
and you run this and you get dddd dddd
so it's a very simple wonderful concise
project and he got a lot of traction out
of that so being a smart guy decided to
ride on his coattails so he had j fugue
i decided to analyze log files so it my
project was log4j fugue so the idea here
is a lot of us work on big applications
enterprise-scale applications and a lot
of them get to the point that we don't
know what they're doing you know they're
large they're distributed that they're
written by lots of different people even
knowing what your own program is doing
especially in the middle of night can be
challenging when I was working at
Motorola as doing video on demand so
when do people watch movies nights and
weekends so when did I get the sport
call nights and weekends our project was
our project team was relatively
undisciplined about writing log files so
we would be writing you know 100,000
lines of log you know an hour okay and
since it since it's a running system you
know doing movies you know for comcast
so you can't just slap it a bugger on
comcast we had to do log file analysis
and that got to be very very challenging
and I didn't want to have to be looking
at log files so what log4j few does is
it takes your log files and it turns it
into music okay
what the idea is that just like your
auto mechanic can listen to your car and
hear what's going on you can actually
listen to your application in here
what's going on and if the demo gods are
kind to me like I said if the Dimmick o
has where did it go ok there we go ok
this is my rendition of comcast new york
saturday night video on demand
and what I'll say for a minute is what
the system does is it looks for verbs in
your log file verbs like someone ordered
a movie every time if we see an order a
movie string in the log file we
increment a counter for bass drum every
time we see someone finished a movie we
increment a counter for snare drum you
know when it fails we get the symbols
and so you can hear the pace something
different happening something different
happen there do something very different
happens oh that's bad okay
so the idea is that you can hear what's
going on as over time you can hear you
can hear pace differences you can hear
unusual events you can attend to that in
the background while you're doing
something else so you can decide whether
I'm really just being silly or not but
you know it was a it was an interesting
application as interesting after 2010 I
got a Duke choice for a word for it and
you're a few of the remaining people on
earth that I haven't mentioned that too
so so that's log4j fugue in Java okay
and so basically we associate verbs we
basically look at your application as
nouns and verbs we associate verbs with
musical counts and we do it at tempo
based so if you get two of two of an
event per second that's two half notes
if you get four of the events per second
it's four quarter notes and so on and so
on okay so that's why we get the rhythm
based system ok this is the architecture
for the existing Java based
implementation so on the Left we have
the the message listener it gets the
listener from a variety of places this
can work listening to or processing an
existing log file or you know a live
stream it sends it to the message
scanner that looks for these interesting
verb strings and then it's it put it
sent that to the instrument counts
basically midi elijah to have 16
channels so we have an array of 16 for
each one of those verbs and we're just
incrementing a counter and then once a
second we switch this is actually a
two-dimensional array we switch and we
say play the strings that I counted up
in the last second and start
accumulating the next second and then we
send it off to this pattern builder that
figures out how to turn it into
something that jf you can understand so
that's basically the gist of it ok the
main point being that the core of the
system is
everybody modifying this central data
structure and we'll get back to that
word modifying the central data
structure if you've listened to any of
Brian gets his talks or you've read his
book or van cats book on concurrency
shared mutable state that's exactly what
this is so I don't do multithreading in
this case but if I did it would be very
difficult because I got a lot of people
sharing a state that's being mutated
okay in the Scala version I took a
similar but somewhat different approach
in that I have the central message
processor that's an actor that basically
listens to messages now you may have
heard of acha which is scala's message
processing library but there's also a
default and simpler message processing
library just built in called actors and
I really wanted to use acha because I
wanted to see out Sam resume that I'd
use daca and I could not find a need the
simple default actor was sufficient them
and so my so the data Gator gets data
and it sends a message to the message
processor that does the increment and
then periodically the sound builder
sends a message to message processor
asking for the data so the idea here
that you can already see is we're not
mutating shared state we're sending
requests to the message processor to
change its view of the state he's the
only one that has the view and then
occasionally he gives a copy of it off
to the sound builder and again we can
get data from an existing file we can
get it from a socket talking to a live I
/ j and then just for kicks i decided
well why can't they get it from from
Mongo you see how functional programming
and no SQL and resumes all go together
I've done mango the idea is that mango
with its you know schema-less approach
actually there are a number of people
who are writing bog files to Mongo
because it's a high right capable system
and as long as you have a column
someplace that equates to message and a
column someplace that equates to when
the message came in a timestamp you can
actually trivially you use the Mongo API
to get the data I mean turned out to be
about 10 lines of code to interface with
a bongo it's actually very cool and on
the other side we have a simple sound
builder that lets us build very simple
types of music but then we went ahead
and went to the rhythm sound builder
that mate gave us those really hip hop
kind of music you heard earlier ok so
now is the world's smallest scala primer
and i'm going to preface this by by
quoting obi-wan who said you know
everything we know depends on your
perspective and so if you're a scala
expert you may find this simplistic but
from our from our point of view it's
sufficient so on the Left we see typical
java class that has a method and there's
a fair bit of boilerplate there Scala
you can pass a parameter to a class
definition and these two will
essentially generate just about the same
bytecode the Scala says oh I have a foo
and it has a it has an x and i can get
and set it and so be it the second line
is probably the most interesting one in
terms of learning to and read some of
the code we're going to see in the you
know we say i have a public class it
returns a type it takes a parameter and
there's a return now scala tries to
infer the type as much as possible so i
actually don't have to donate in this
the second case i don't have to say
float and i don't have to say in
and because I don't have to say them
Scala makes you say them last so instead
of saying float my method in Scala it's
def my method method float and I don't
even need to say that if I don't want to
sometimes this is actually a segue a lot
of times in Scala you can omit things
because you know the compiler is going
to supply it for you there are times
when it's a very good idea to leave it
there both because someone else can read
it and they can figure it out and just
in case you got it wrong I mean in this
case it's pretty clear that we're
returning afloat but when Scala gets a
little complex you can say oh I know
it's a returning of this and you put
that that type in the return type and
Scala says you're not returning that at
all so it's not a bad idea to put things
in even though the compiler can infer
them let's see on third line java of
course methods take have perimeter lists
scala methods can have multiple
parameter lists which sounds kind of
weird and it can be kind of weird and
again it's an area just to be a little
careful love but if you've it anyone
ever heard of currying okay occurring
right so with multiple parameter list
you can say here's here so here's a
function and I've got multiple parameter
list I'm going to bind some of the
parameters and then i'm going to call
this curried function that on the second
set of parameters it's kind of an
advanced topic the place that I'm using
it here is for dependency injection and
we'll get to that in just in just a
minute I don't want to talk about
closures although I i will say in all
the talks the last couple days where
they've said closures are in Java 8 and
everyone's already moved to Java 7 so
it's all good and then I talked to
people around me I said you guys moved
to Java 7 no no no you know you guys
moved to java 6 or
it's been scary how many people have I
mean I actually heard someone here
saying that they're still on 14 which is
so go java 8 i'm sure one day most of us
will have access to it in our companies
but i don't think that's today and so
the last one is a dependency injection
i'm a big spring fan you do dependency
injection through spring and life is
good in the scholar world it's still
kind of early days we're still figuring
out what are the best practices there
are a lot of different ways to do
dependency injection since I learned
scholar from dick wall and since he has
a dependency injection framework of his
own called sub cut I use sub cut and sub
cut uses a kind of scary scala feature
called implicit so in java if you've got
a function and you use a variable that
doesn't exist the compiler says it
doesn't exist compiler scala says well I
don't see it here do I see it anyplace
else and what you can it looks around
and so it tries to help one of the
things that dick wall says is when he
programs in Java he feels like he's
working for the compiler and when his
programming Scala it feels like the
compilers working for him so you can say
I have a variable and maybe that
variable oh I don't know is my
configuration and I'm going to mark it
as implicit now I have in the same scope
a method that uses something out of
configuration that you never mentioned
before scala says yeah that'll do and it
implicitly uses the thing okay so it can
be it can be overused you can I have a
term for this that I'm trying to get
people to adopt called invisible
spaghetti
so you look at a nine of code and
perhaps not sure sure what it does but
implicit used cautiously can be very
powerful I mean why should I pollute my
whole call stack by passing my
configuration all through when I can
just say here's my configuration just
use it just figure it out so that's
that's what that is okay let's look at
some code now let's yeah besides
switching jobs recently I also switch
from the pc to mac so i'm just still
learning the oneness of mac so Steve so
so the first place to look is where do
we store in the Java version where do we
store the information about the
association between the verbs we want to
look for and the instruments that we
want to play well it's in i called it
instrument voice and basically it has
hear a voice number which can be you
know 0 through 15 because you have your
16 midi channels it has the search
string that you want to look for and it
has the instrument name you know bass
drum piano whatever okay so and then we
have some constructors and we have some
accessors there are some more accessors
we have some setters and mutators so if
102 lines to not do a lot okay so but
you know that's cool no no big deal if
we go to the scholar version it's that
line this is it easier if I don't
highlight it yeah it's that line that
line is equivalent to the hundred and
six lines of Java code a a case class
says I'm one of these things you're
going to have a bunch of them you know I
want to be able to switch on them later
and it has essentially the same thing it
has the message i'm looking for this
string and then the MIDI voice so so on
my first day of coding I said 106 lines
21 no Shazam it's doing okay I rock you
know that's what I say let's go back
okay so that's the that's the instrument
voice so now let's see what we do with
it so we have this message receiver
class going back going back to the job
code okay okay and so of course I have
to do a whole bunch a whole bunch of
setup you know I get my my my map of
those instrument voices i get i set up
another map i said a whole bunch of
variables i said a constructor I said
where I'm going to get where I'm going
to read the data from I said the music
object was which is something I want to
play later I have to loop through the
messages and set them I have to
initialize another message map and I
loop and I loop over them and I set them
so they can easily parse them I have
this guy swap counters which which
should scare the heck out of you because
it's like okay I noticed later that it's
not synchronized I'm just randomly
switching the counters out from under
things but I figured its music what
could go wrong and then eventually I
process the message now processing the
message this is sort of the guts of it
so I get him I get a message in you know
just some random log message I get
myself an iterator over my messages I
walk through the iterator I get the key
I get the pattern I search for it if I
find it i increment the key okay nothing
terrible i mean this this code is not
going to win any awards but it's also it
would pass most code inspections I mean
it's you know it's it's kind of boring
so let's go to the Scala equivalent so
here I have message processor and it
extends actor and here's this auto
injectable thing okay this basically
says hey if you see anything you don't
recognize it's okay you'll find it
someplace so we inject the messages and
we just inject them from implicit space
basically we have our set of of the
counters and basically here this line
right here is the equivalent of all of
this okay so what we do and just see
thee okay basically any time this actor
receives a message we come down here and
we try to switch on it and ignore these
two cases for the moment and let's just
say we got a string well what do we do
okay we say hey for all of our messages
and remember up here we got the messages
that's the the possible messages for all
of the possible message if the message
contains this message then increment
increment the counter for that voice
that's it that's all the processing
whereas in the Java version of sorry oh
come on Mac yeah in the Java version I
told it explicitly step-by-step how to
do it in the Scala version I'm or unless
said what did what I wanted to do I mean
if you think about what do you want to
do you just want to say well for all the
messages if this is one of the messages
i want increment well that's essentially
what it does now you notice I've got a
commented out line right above this is
sort of the yin and yang of scala in
that scallop always has multiple ways of
doing things and we're still learning
out we're still figuring out what the
best ways are so another idiom for all
of this is to say hey messages filter
and then we pass this is this is
essentially a closure right here message
contains log message and then for each
one of those do this other closure
current second current second increment
but go away Thank You system for helping
me hey demo God's outstanding oh come on
come on be nice okay there we go so
there's basically two ways it two ways
of doing that and there are people who
passionately believe that this way is
right and that anyone who believes the
otherwise is is you know clearly an
idiot and there are just so many people
who go the other way so after presenting
this a few times I put them both in in
Compton went out and you can decide
which is which but the idea is that
you've got one line of code that kind of
reads like if you were writing this the
pseudocode it's like well take all the
messages filter them see of a match if
it matches increment you know at a
certain level I think that's just a lot
simpler than this so anyway so we get
the messages now let's look at building
up let's look at getting the data let's
say okay so here is our simple data
getter we're going back to the java java
version and you know i extend a thread
because this is happy you know basically
have to have a thread to get the data
and then a thread to play the data so
you know I have my setters I have my
getters clearly I was a little
optimistic or pessimistic there I
probably should take that out we'll
pretend I did I never show that you
didn't see anything and then in this
simple case basically I wanted just just
to see am I getting anywhere when I was
first writing it so i said i'm just
going to have an array of messages so
just walk through the Ray you know write
them and see what and see what happens
okay again you know 80 lines of code no
big deal the ID will generate a lot of
that for you but it's still you know
there's still 88 lines of code so let's
go to the simple data getter and Scala
well if essentially two lines of code
you know it's basically you know take
take take my sample data which I've
injected and you know it erate through
it and then this this bangs symbol is
send so basically send the message to
the message processor so again I'm not
saying that the 88 lines of code in the
Java version is so hard to write or hard
to read or anything but one line of code
just says message processor bang message
i think is simpler ok so now let's look
at the the decide where we're actually
processing the data ok ok so we're going
to look at a sound builder sound builder
ok ok so we're back here and we're back
here in Java band ok and again I've got
I've got a you know a variety of
variables that I've said you know I've
got my player I've got a synthesizer
I've got a bunch of setters satyrs and
get her setters and getters and part of
the trick is none of this none of this
is hard and like I said the ID will
generate it for you but then when you're
running it you have to go find the
interesting bit of code we're in all of
this IDE generated code are the good
bits ok so here's here's some good bits
ok so we've got the run method for the
java music music processor ok so the
first thing we do is we swap we swap the
we swap the index because now we're
ready to play we want to say i want to
jen i want to look at the ones that i've
just generated and switch them ok i
build my music string right here we'll
go into that in a sec and then i play it
and so in a certain level that's best
pretty cool that's pretty simple
okay build a music string okay basically
I walk through you know all of my MIDI
voice is 0 to 15 i get i get the voice
if there is a voice you know i
explicitly pull out the pieces and then
you know I build a voice string so again
this isn't you know trivial code to
understand but it's very imperative this
is how you do it okay and then we can
come down here and build a voice string
is not all that terribly interesting I
mean here's where we get into some of
the guts of JP JP expert ick Euler's and
all of this codes online okay so let's
go back and let's go back to the scala
version sound builder okay sound builder
okay now one thing you'll notice in here
and is there's no run method so how does
this work and you'll notice that we have
with auto injectable but also with sound
sound builders and let's go let's go
look at at sound builder sound builder
is a trait trait is is it is new to us a
trait is an interface with the default
implementation now they've said that you
know Java 8 is going to have that with a
Java 8 or Java update for java I mean I
don't some Java will have that um but I
mean because of and and I'm glad to see
Java getting it because we used to have
the you know you have the standard
paradigm if you'd have your interface
and then you'd have your abstract base
class that would have the things that
you your default implementation they
need to extend that and you've got three
you get three artifacts why do I want to
have three artifacts just so I can have
a default implementation so my sound
builder basically accepts all these
these implicit parameters and then he's
got his run method and he says you know
while i'm running build and play the
music string ok now this line again is a
you know equivalent to
do that and I think it's simpler I mean
again what it says is hey message
processor I'm going to send you a
message called next data and when I say
bang it's an asynchronous send when I
say bang ? it means I'm sending this to
you you give me something back okay so
hey message processor please give me
some some next data and then pass the
data off to the music player okay let's
see how that works message processor so
now we come back to our main the main
body of the Scala code which is this
this one loop statement essentially so
you know this line of code 947 is the
one that did the increments and this
line of code 43 is the one that sends
the data over so he says current second
and clone a copy of the data surma it's
always important that I'm cloning it so
no one else is touching it I'm not
sharing mutable state i'm making a copy
for someone else to touch and then I
zero out I zero out the the data and
then I can keep keep going so I've got
one line for getting the data two lines
for processing the data and then a line
of code to exit I mean that's the guts
of it so I think that's pretty cool
again this isn't hard but this is an
impaired of style this is saying what to
do as opposed this saying how to do it
as opposed to what to do it so this is
the simple sound builder so let's go
look at the rhythm sound builder because
that's where it gets really scary and
this is where i have to say i wrote this
there's a little funky so again i have
my i have my run method and basically
when i'm doing rhythm instruments in in
in JP you i have to say i'm basically
Kreutz constructing a string and the
string will be you know dot one
too little mobigo basically for each one
of those for each musical instrument i
have to say a letter that's going to
represent that instrument so I do I have
this rhythm substitution down here yep
rhythm substitution we're basically I
walk over all the instrument names I
turned them into into a string and then
I put this this this instrument name
inside the racket so I saw that Jay if
you can play it and then I have to
remember a rest if anyone hears musician
you know the space between the notes is
also no it's very interesting negative
space all that cool stuff and then we
have a bass drum which is the underbar
so you always have you always have a
beat okay um okay now sort of the scary
part is so now we're going to walk
through all the layers okay we're going
to get the voice then we're going to get
the play count then we're going to
decide should I be playing this layer or
not because one of the tricks with j
fugue is if you start playing if you
play a measure and it has a bass drum
and then you play the next measure and
you don't say anything the bass drum
keeps playing just kind of cool kind of
bad and so I had to have all this logic
and just look at play this layer how
many times it's highlighted to tell
whether in the last iteration I had used
this instrument so I needed to clear it
on the next one or I need it to set it I
mean I look at this code and I'm like oh
this is this code is getting pretty ugly
so I didn't didn't really love that so
maybe was a good thing I rewrote it in
Scala anyway the the see the scholar
version okay again build rhythm I tried
to keep the names the names as similar
as possible and again I used closures I
said message filter and what am I
filtering on well I'm filtering on
everybody who had a count there's no
sense in playing anything that doesn't
have a count
then build a layer string set the layer
and play it now 10 one of the things
that's kind of interesting here is this
is an example of some place where I
didn't need to specify the return type
so I'm building up so right here I'm
saying the return type of this guy is a
rhythm and that's how you do a return in
Scala the last statement in a method is
the return value okay so i actually
could take this off but my own style
rules sort of say don't because suppose
I put something after this line if I
left this off I mean so one of the one
of the tricks that actually has has has
bitten us is suppose I come down here
and I put you know you know you know you
know log info info blah ok this will
fail to compile because the the return
value of log info is a string okay and
it will actually give me an error here
saying you're no longer returning a
rhythm but if I had taken this out you
would say okay you want to do that so be
it and hopefully it would blow up
someplace else but it might not because
somebody might have defined a converter
from string to rhythm because rhythm
really is at a certain level just a
string so so I'm a firm believer in
explicitly saying what the types are now
build the layer string again you'll
notice all these vows vows are
essentially finals okay so when I build
a rhythm string I said okay I've got a
silent note I've got 16 beats a measure
you know how many beats do i have in
between notes because if I've got you
know if I'm trying to do for you know if
I've got a count to four then I've got
four beats in between I've got a count
of two that's 16 x over 2 or got you
know eight and so I essentially only
have one loop you know I've said
right here I mean this is actually kind
of an interesting method I say make me a
string using string builder and what
should I do I should do silent note
which is the dot right here the rest
times beats per measure okay so I've
essentially put in in one line all of
the places where they're going to be
rest notes and then I just have to put
in with this one loop all the notes that
aren't rest ok so again you compare that
with build rhythm string Bill Blair
string I mean here I took the imperative
thing of saying okay I'm going to have
16 beats per measure I'm going to have
this many notes between the beach walk
through from 0 to 16 if the count is
this put in the silent know it otherwise
put in the other thing and reset the
counter of how many beats it's been
since the last beaten it's like oh this
code is easy to get wrong okay I mean
it's it's I mean maybe I should be
better maybe I shouldn't be easy to get
wrong but it is easy to get wrong this
code is is a lot simpler so where do we
go next so we can walk through some more
but that's basically that's basically
the gist of it I want to just give you a
sense of what you can do you know with
Scala and with Java and you knows you
know I didn't do a lot of the scary
things that you can do ask allah i use
basically just closures I used Val's
instead of bars vows mean essentially a
final variable of arming something you
can modify and it became very
straightforward ok so let's actually a
switch switch back switch back the other
way
okay oops oh come on okay so basically
the gist of this is by using a very
small subset of Scala you can get
incredible efficiencies similar to but I
think better than the efficiencies you
can get from Java 8 we didn't really
touch on it in this case because it
wasn't multi-threaded but because i was
using essentially final variables if i
needed to make this multi-threaded i
wouldn't have to put synchronization
primitives on it because since
everything is a vowel I don't have
shared mutable state so i could
multi-thread this trivially without
having to worry about collisions so one
of the other things is that a lot of us
won't be able to just switch to scala
because of business environments but
what we found is using scala helps you
adopt this functional mindset and so I
mean right now in my current job i'm
actually not using scum we're using java
but my boss and I who are the two the
two coders we both are prepared familiar
with Scala and so we're writing Java in
a more functional way we're trying to
write the what we wanted to do as
opposed to how so even so this goes back
to the notion of just learning a new
language gives you basically a leg up
and functional programming is something
that's turning out to be very
interesting so whether you encounter it
now with Scala or eventually with Java 8
with closures it probably will be in
your future so that's that's it so any
questions
okay yep oh thank you oh sure sure sure
it's um sorry that was the yeah okay
this is a little hard to read but the
the it's on the Java version is on wwl
ugh forge a few org and the the Scala
version is at github so these these
slides will be available so and I'd love
contributors I mean there's there's some
interesting things there that we want to
do I mean one of the things is as I said
if you get you know two instances of a
thing you get two whole notes if you get
16 you get 16 sixteenth notes one of the
things I've wanted to play with is well
what if I'm an environment where I'm
getting you know hundreds of events you
know per second it would be great if I
could implement some kind of logarithmic
scaling you know to to to pull the
counts down and I just haven't haven't
done that another interesting area is
we're wanting to try to do chromatic
music as opposed to just beats but
that's you know those are those are
future future examples you also have the
ability adding a chance to show it to
you but you also have the ability to
replay a log file at different speeds so
yes actually there there was this very
very interesting one in Boston that I
heard on NPR in that emergency rooms
apparently have always been unconscious
when I've been in there but emergency
rooms or operating rooms rather have
lots of medical instruments and they're
apparently more medical instruments than
then the doctors and nurses can attend
to so they came up with this very cool
system and I've written to them but I
haven't gotten an answer back where they
will play an orchestral music piece you
know doesn't them did it and they will
tie the medical instruments to the
musical instruments so if your patients
blood pressure is crashing don don and
so people notice that now I I think this
could get a little extreme and if your
patient is having a really bad time
tundra you know you don't want your
music to be freaking out on you but but
the idea of everyone is very interested
in application visualization but vision
is our is our primary sense we don't pay
a lot of attention to our other senses
since we have mon i'll just a segue in a
previous lifetime i used to be a dolphin
trainer and so their primary sense is is
acoustic so i got very interested in you
know acoust acoustic tasks and oh all
the research says the multitasking is
bad but if you multitask across
different modalities you actually can
get away with it a little bit more and
while the music that we're that we were
playing you know it's not going to
where'd it go you know it's not going to
win any awards necessarily except for
tix choice um it's not going to win any
worse but you can listen to this in in
the background and you can be doing
other things but you can still notice
when
something happened so if your system
administrator system monitor you can do
your regular task and have these things
going on in the background and still pay
attention you can be doing other tasks
you could be playing games you know
whatever so I mean the the whole notion
of using our other senses I mean we also
talked about code smells I haven't
figured out you know log log for smell
smelly log but but but there but there
should be things there I mean we get we
get you know that the system vibrates
you know there's no vibrate sensor in
our max but I think it's in it's an
interesting area if we're going to
handle multitasking and all that I think
it's it's going to be in there there's
room for there's room for exploration
there so other questions okay oh good it
is to is totally fine i could I couldn't
tell a difference yeah I mean it's me
Scylla compiles down to bytecode so it's
it's just bytecode so
nope not really because I haven't done
anything insane is it I mean it is in
this context you know well you can I
mean it's you just mean in I mean it's
funny one of the one of the things about
Scylla is that some of the really top
Scylla people say oh I don't need a I
don't need an IDE i'll just do it in in
the eye and back in Boston we have we
have some really amazing scala folks and
I there's just one guy brunner i went
from 2,500 minds to 250 miles i'm sure
brunner could write this application in
three lines but none of us would
understand it so don't do that I'll take
ten to one you know I don't need a
hundred to one so you can I me let me
let me go back to I mean you can the
Scalia I mean here you know step step
step you know step over this i mean into
it then the the IntelliJ support for
Scala is really quite nice and things
are only going to get better so so right
now if you're using some of these
implicit and you hover over something
that has an implicit I don't believe it
automatically tells you oh by the way
there's an implicit here but that's
coming okay so so I haven't found it to
be a problem in part because it's it's
it's simple you know when I when there
are 250 lines there are 250 places my
bug could be and you know more or less
there is another question
absolutely absolutely all of the all the
ideas are getting better just from my
own sake I keep you know I keep eclipse
java over in this brain and scala
IntelliJ in this brain and but but
they're all fine so so yeah the tool the
tilt the toolings find the compiler sir
compilers are great anything else okay
it was it was a 10 days and so the funny
thing is i came i did this over the
Christmas holidays and i came back to
work if people said i would need to do
for front over the holidays and i said i
learned a new computer language and I
rewrote my open source project in the
new language and they said what did you
do for fun and I said I just told you
what I did for fun I'm a geek yeah / I'm
gonna have a job next year so so yeah I
mean I mean here's here's the thing this
is this again is the message you can
spend your life doing scala and learning
all these things but I took a course and
then I took you know 10 days and rewrote
the thing and it worked this is the cool
thing so I have my unit tests and it end
when I finished writing it and it passed
all my unit tests I went home I went
downstairs not tomorrow whoo-hoo I'm
done and she said what did it sound like
and I said oh it never occurred to me
actually run it if passed my unit test i
figured i was done and so I went
upstairs and played it and it ran it
rammed the first time so so you know go
unit testing and go Scott so so yes
alright thanks very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>