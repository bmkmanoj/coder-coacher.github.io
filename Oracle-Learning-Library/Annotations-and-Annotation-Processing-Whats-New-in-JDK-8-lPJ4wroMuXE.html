<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Annotations and Annotation Processing: What's New in JDK 8? | Coder Coacher - Coaching Coders</title><meta content="Annotations and Annotation Processing: What's New in JDK 8? - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Annotations and Annotation Processing: What's New in JDK 8?</b></h2><h5 class="post__date">2013-02-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/lPJ4wroMuXE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Joe working the language
group here at Oracle and doing
annotations annotation processing work
on the LC and also related language work
I used to come from the J rocket
engineering I used to do hacking on on
the a-ok java virtual machine previously
and then I joined lantus a year ago so
I'm here to talk about annotations
annotation processing and what's new in
a decade and this is going to be in a
little bit of an overview talk because
we have three major features that we are
doing and they are mostly related at
least of the surface by by by by being
annotations features so I'm gonna jump
sort of go through all three of them and
here is two standard Oracle disclaimer
don't make business decisions based on
this and in this case I also want to add
actually that that this is stuff we are
currently working on so this is a
snapshot view of what we have today it
will probably change hopefully for the
better so this isn't finished yet so I'm
gonna start with easr 308 type
annotations and this is this is
something there was a talk about this
yesterday that you might have seen so
I'm gonna keep this a little bit short
so today we have annotations on
declarations you have declarations
introduce a new name into the into your
program so here are some some example
declarations very simple a class a class
and a type parameter or type a type
parameter and in the last example I
actually introduced three new names a
method named V
parameter and I and the long named L and
those all those you can annotate today
and but with them with 308 we also bring
you the possibility to annotate type
uses and this is something you haven't
been able to do today until today and
I've included some example of type uses
for example a constructor call you see
the my object that's a type use and I'm
not declaring the type my my object I'm
using the type my object in a
constructor call and also for example in
a cast
you couldn't previously you couldn't
annotate the cast now you're going to be
able to and this is also a type use of
string not a type declaration of string
and in implements closest a read-only
list or read-only elements in exception
in thrown exception decorations for
example a critical temperature its
exception so these are all new new
places that you will be able to add
annotations to your source with three
weights and you might ask why do I want
to do that and it turns out that that
the annotations themselves in this in
this case aren't the really cool thing
with through eight but the checkers are
so the annotations in those places are
an enabler for the checkers framework
and the checkers framework is a way to
write your own type system on top of
Java's type system this type system is
it's sort of it's based on a plug-in
that you write so when you run the
obviously with your plugin you can type
check your program with the properties
for the properties that you are
interested in
so you write the checker that you want
that you need to be able to prove the
property that you're interested in and
in order to prove those properties it
turns out that sometimes you need to
annotate the code and that's the basic
reason we're adding these type use
annotations because they're needed in
order to prove in turn interesting
properties about your program it turns
out that on average the the checkers
framework guys and they have they had to
add two point six annotations per
thousand lines of code so they don't add
they don't need to do they don't need to
add too many type annotations you can
find more information about the checkers
framework here it also includes a bunch
of those pluggable type type checkers
I've included here three of them or
mention three of them there's an ominous
checker that can prove the absence of a
null pointer exceptions and I think we
can all agree that's pretty useful
there's a lock checker that proves that
if you have a variable that's supposed
to be guarded by lock it can prove that
you only access that variable while
holding the lock so it proves that the
proves the absence of one type of
concurrency issues that is pretty far
from from saying that your program is is
free of concurrency issues but this is a
small step and also there's the the
regex
type system that can prove that a
regular expression is well-formed and
also that you don't use capture groups
that you haven't introduced so this will
also this will give you the property to
to verify the absence of a class of
common errors that that you could
otherwise have so right and we're also
doing this to me this looks like a
little bit like Python acceptance in
Python it would be named self instead of
and it turns out that in a virtual call
when you're sending a message to an
object or invoking a method an object
that object itself is sort of always
present in that method and you need you
sometimes you need to annotate the
receiver of that virtual call and we
couldn't figure out where to sort of
actually do that so so we allow you to
have an extra parameter named this that
you can annotate with with type
annotations for the receiver virtual
calls hopefully this won't be that that
common because it's sort of them I think
it looking I think it looks a little bit
weird but if you need it you need it and
then we sort of we have to be able to do
that right and yes there this slide so I
added some random annotations to a lot
of type users here and with this I want
to say that there is there may be a cost
to overusing type annotations this is
storing to me this is storing that the
annotations are starting to detract to
distract me from the logic of the
program but I mean so we are giving you
the ability to shoot yourself in the
foot with syntax here and it's up to you
to use it with moderately and of course
type annotations you're free to use them
without using this Checker's framework
you can if you have the need to annotate
type views then just go ahead there is
no this isn't tied to the checkers
framework
so type annotation summary we want to
extend the type system Yahveh give you
the ability to write pluggable type
shakers and sometimes the type checkers
need a little bit of help and in order
to do that we add type annotations and
of course they're there to use even
though you're not using the checkers and
that leads me to repeating annotations
so this is the the second feature that
we're introducing in in yo8 and I've
been working on this type annotations
has been done outside of Oracle and
that's I think that's a great thing as
well it proves that that it's the
perfect example of being able to do work
in the open outside of Oracle and bring
it to us and say hey this is cool we
want to do this and and then do it
repeating annotations I've been working
on that and I've been doing the changes
in the EOC compiler so and this comes
the repeating annotations comes the need
comes from the fact that today you can
only have one instance of an annotation
of of a certain type per declaration so
you can't write at foo at foo and we
think that was a mistake and it has
turned out to be there is a need to
write multiple instances of the same
annotation type for example I think you
might have seen this in the EU world I
think it's it's it's quite common that
you have to wrap the annotations that
what you want to have multiple times
inside a container like this here's
another example schedules in I think
this is
now I don't remember where I got this
example from but you want to trigger
your reaction at multiple times so you
you have to wrap your multiple schedules
inside a scheduled container so we
prefer if you could write it like this I
think this is much neater and this guide
this example would look like this I
think it's much more readable so the the
repeating annotations figure feature
helps you to write more more concise
code we want to help you to get rid of
the sort of the boilerplate code so
given that you want to use this how do
you do so you take your your your
annotation type that you want to use in
this case the schedule and you annotate
the schedule declaration with a
contained by annotation and the value of
that annotation is a class in this case
schedules that is the container for your
multiple instances of schedule so you
take your schedule and you write a
container contained by annotation saying
here's my container and you can name it
whatever you want but in this case it's
name schedules and on the schedules side
you annotate your container with an
annotation called container for saying I
am the container for this this
annotation and also it needs to have a
value element that is an array of the
the annotation it is a container for so
in this case it needs to have the value
the scale area valued scheduled value
and there are also there are rules for
example how if you for document if your
schedule is documented the container
needs to be documented and there are
targetting rules but this is the basics
so if you do that you oversee will
transform this source code into sort of
a bytecode representation that looks
like the example below so we will take
your two schedules we will pack them in
the container for you and we will
include the container in the in the byte
code and the reason we do it this way is
that there is as I showed you there are
a lot of examples of where you already
have this this idiom of abusing a
container so we want to sort of ease we
want to make it easier for to continue
to use that with less boilerplate but we
resolve we recognize the fact that there
is this source this is already used in a
certain way and we want to continue to
build on that so we we just we
synthesize the container and we packed
two or two or more annotations there yep
no contained by is not repeatable and
neither is container for so and actually
and there's also the there's the
requirement of this this is an exact
type here so you can only be the
schedules that the area valued value
element that needs to point exactly to
the type of schedule so you can only be
container for one annotation
right and we also need to add some
refreshments support it turns out and
first I thought well this should be
rather you see we we sort of we have an
existing idiom they shouldn't be a big
deal and so this leads to to sort of my
rules for evaluating language changes so
there are a lot of proposed features to
yoga we are not going to do all of them
but we sort of we have to have some sort
of criteria how do we choose and and
personally I these are sort of my rules
for evaluating how I feel about a
language change so for example if you
don't use a proposed feature is you
shouldn't suffer at all and I think this
is pretty reasonable I mean you're
sitting you have your code here you're
writing you don't use the feature and
and suddenly someone introduced
something over here and and and it
starts you start to suffer that is sort
of I really dislike that ID and II my
other sort of criteria is that the users
of the feature should should find it
intuitive and and easy to understand and
my colway colleagues always say that
backward compatibility is important to
and I agree with them so so in adding
reflection for this feature these are
sort of the criteria we've worked with
try or I've worked with trying to figure
out how to best do this
because it turns out that if we don't
change reflection at all adding one more
scheduled to your schedule and over to
your action in in the river if you look
at the the annotations in reflection you
would lose them and to that do access
what there's not the way we want to do
things and the explanation is this so
I'm going from one schedule to two
schedules and the compiler is is going
to so and that means that on the on the
class action previously there was an
array of annotations and that contained
one instance of a schedule annotation
and now that that array of annotations
on the class is going to contain one
instance of a schedules annotation so
that is why we lose the schedule when we
are looking for schedules or sked when
we are looking for a schedule we lose it
because race schedules there so we need
to unpack the containers and the spec
says basically if a if an annotation a
that you are looking for by doing the
annotated element get an annotation or
get declared annotation if you're
looking for a and a is meta annotated
web contained by then if you can't find
it directly go and look for a is
container if a is container is there
unpack it and take the first one so and
that will give you given the declaration
you have to schedules on action and you
look for a schedule you get the first
one and while we think this is pretty
reasonable
but turns out we're not that we're not
done yet so it's the same example you
have a schedule you add the second
schedule and this time you're doing the
call get annotations and it turns out
here you lose your schedule as well
before you will get an array of that had
a scheduled instance in this case you
get an array that has a container
instance so again
doop says what so it turns out that we
want to unpack containers if when you do
the get get annotations call as well so
Oh what did I mean by by that yeah so
given the declaration they're doing get
annotations on action the class should
give you the array of of schedules and
as it is actually a container there we
we find the if the element if if the
instance of a schedule of a container is
annotated with containing four this is a
bit tricky so when we find something in
that array if it is a container which is
which it is if it's annotated we contain
four then we unpack it for you and add
all the individual annotations from the
container to the return value of get
annotations so in this case you will get
your two schedules on the gate
annotations call so here are the
proposed updates to annotate an element
and as you can see there are three new
methods there is the one on on the top
right that we we felt that was sort of
it was missing it should have been there
from
from the beginning basically why why
can't you do get declared a mutation for
a single type of annotation why why do
you have to do do it with inheritance
taking inheritance into account so that
that is added for for completeness and
the other to the middle line those are
added because they are interesting when
you have repeating annotations and those
are the ones that that we think you
should be using when looking at
annotations because this takes repeating
annotations into consideration and will
give you I'll let me get to next slide
so then the the two the two ones in the
middle they are the sort of the
repeating annotation counterpart to the
old guest annotation with a class
parameter so they will give you all
annotations of of an others of the
instance you are of the type you are
looking for so you get an array of
multiple annotations back
right this is the intended semantics of
the get annotations looking for type so
if your class action is is annotated
with single scheduled you get an array
containing a single schedule and if it's
annotated with multiple schedules you
get an array containing multiple
schedules
all right so that was the the repeating
annotation part so we think it was a
mistake to to just allow one instance of
an annotation on a declaration we want
to fix that we have decided to fix it
taking compatibility with the existing
idiom into consideration so we transform
your repeating annotations into this
container so we synthesize a container
for you so we we put them in a container
and then we've updated reflection to
where it makes sense
unpack the container and give you back
your original annotations so my my idea
of how to do this has always been that
and even though this isn't the case
today in all cases but but if you have
annotations in your source file I think
it is reasonable to try to give them
back to you when you do reflection as
well so that is sort of the the
underlying principle here and for
example that is that since class
retention is always is the default for
example it isn't it always the case that
you have that today but I think I still
think it's it's good a reasonable goal
to have in mind
all right that leads me to the next part
Joe likes lying mobile backed by core
affection and that is a long title um
and and here again I'm gonna I want to
make the point that this is this is
working progress this is I have this
running on my computer
I'm not going to demo it because I tried
to do a demo yesterday and it turned out
it required network access and it all
sort of went boom and I I while I
strongly believe that the other C
doesn't require network access I am not
hungry presenter so I've included that
the demo in the slides but so this is
something we are working on we we want
to give you this we don't know when and
we're not sure exactly how it's going to
look either but but I'm gonna give you a
snap snapshot view
so how many of you have used your
excellent model in the source world five
and one of them is a original
implementer of the API all right I have
a short introduction to the of Iceland
model API and I perhaps I should try to
make it a little bit longer but so I'm
gonna start by saying that that this API
today lives or before this work
this API lives in the source world this
API runs as a part or you are using this
API today with annotation processing and
that is done at source time so this API
sort of lives in the java c compiler and
you are using it when you compile your
source not when you run your program and
this effort is basically the we want to
take this API to the runtime world or at
runtime time or program execution time
instead of at compile time
so that is basically the what we are
trying to do
Joe excellent model or maybe I should
just say the model API and it's an API
to talk about your Java source and it's
it's unlike for example reflection that
also sort of talks about your program
but is a sort of a hybrid source
bytecode view
reflection is is very much based on the
how the code looks for for the VM while
the RX line model looks at the T at the
source and also this API is let's say it
at a higher abstraction level than their
affection for example visitors are
included you don't need to do it eration
yourself this is for example and most
users today or yeah most I would guess
that most users of this API today are
using it for annotation processing so
when you do annotation processing this
is the API if you're not using apt and
you shouldn't be using apt so if you are
using the yeas are 269 annotation
processing tools this is sort of your
way to talk about the source when you
are doing annotation processing so
included in this api is a nice set of
visitors to extend for example there's
what's called an element scanner that
will just iterate over all your elements
in a source code and you override a
method for for for the visit you all
read the visitor that you're interested
in for example visit method and it will
do the rest there are a bunch of
utilities to to reason about or query
about our source code and types for
example overriding which turns
to be surprisingly tricky at runtime if
you're not a VM for the VM it's quite
simple but but if you're looking at byte
code trying to figure out if something
overrides something is it's actually
quite hard and you can query about
hiding for example and there's also
utilities for they're sort of the type
part where you have you can you can ask
inquiry about bounds and wildcards and
subtyping and all that so this is a much
more complete API to talk about Java
source code and just a certain extent
the other semantics so for example yes
this is my I think this is my favorite
example and Oh overrides so given you
the three class interface declarations
you have class a with a method M your
interface B also with a method M and you
have just see that extends a and
implements B but doesn't declare any
methods thus a dot M override B dot M so
and this turns out to depend on on which
perspective you have because a dot M
will be the method executed when you
call C dot M as well so if you take on
your own class a hat then a dot M does
not override P dot M or in this cases
since it's an interface does not
implement bid of them but if you look at
the same declared method in the source
code of a but instead look at it from
the perspective of being a C which
inherits the method M then that M will
actually override bead of them
and there is one one reason why this is
so tricky and this is a horror to figure
out using refraction today I've done it
trust me but this is one of the things
that is really easy to do with your
baseline model API
right so the model API consists of a
bunch of packages you have your X line
model element dot element this is sort
of the base this is the base class for
elements in the source code for example
you have a type element and that would
be that corresponds to a class you can
have a package element that corresponds
to a package you have method elements or
it it's called executable element and
then you have sort of and this
corresponds directly to source code for
class string you have exactly one
element string and then you have what's
called the type view of it and this this
becomes a little bit tricky but this you
can mostly view it as sort of what you
need to do to talk about generics so for
example there is only one string there's
only one type element for string holder
so forget that so take lists for example
you have list of E in in the ADK
so there is one and this one type
element for list but there are many
instances of tight mirrors for example a
list of string is is a type mirror and a
list of integers is another type so they
all correspond to this one source
element but but they have but you have
multiple types dealing with this and
sometimes you need to use this sometimes
not but but it is there in the API so
you can actually talk about generics you
know I'm sort of if it makes sense to
you to do that
and then there's the util package that
gives you utilities to reason about your
source code for example code to figure
out if you override or hide the method
is in element utils and there are tools
to help you with types in the type in
the types in class and we've also
included or a lot of visitors for
example you can do you can have this
type visitor that you can just extend in
order to to easily do things with types
and yes as I said previously the way to
sort of start using this today is by by
plugging into this from annotation
processing and this only runs today it's
in source time so here's an example I've
I at one point in time I needed to find
out the some of the the Desai's for
unique parameter names in the entire ATK
and this was sort of the perfect tool
for that job if I if I want to look at
all the parameters in a given source
file
I just override the element scanner
eight which is provided to you by the
API so I used override visit variable we
and that will get called both for four
parameters and possibly something more
so I over I'd visit variable and that
gets called on every variable and then I
used to a query is this a parameter if
so take the parameter name store it in I
in my case I used the map or something
that I store it in a map with the class
classified name and
and go on basically and then I just ran
this using in the annotation processing
plug-in on the entire jdk source base it
was actually really it was really easy
and other examples I've used this for
this is this is kind of my favorite API
actually I've I think I have like 10 or
15 visitors in on my computer at work
for doing sort of language query
features I used it for as a mention
parameter names I wanted to do an index
of all interfaces implemented by all
classes I think I even wanted the
transitive closure wall interface is
implemented by all classes and you can
perhaps use your IDE for this but since
I work on the JDK source base it is not
trivial to fit all that into your ID
because we have a lot of there are a lot
of we pull in source from a lot of
places so I just hacked into the
compiler and to do make scripts and I
ran my visitor and and that's sort of
the data I needed I think I also done a
calculations or I have done calculations
on average era the arity of method
declared methods in the ADA K for
example and those have discipline that I
needed to do for my work so the
observation here is that there is a need
to do annotation processing at runtime
for example with transactions your e
container or your when you compile your
your ie beans they might not be fully
aware of your container so it might have
had to delay parts of the transaction
encode for example
and what I claim is it's the better tool
to do to do this it's only available at
source sign and so of course we want to
change that and here's a here's a bunch
of the the pain points I've had working
with reflection trying to work on the
other source it to start with
there's only erase no lists so every
time I want to print something I have to
do list is it as list or or and then to
get them a list that actually has sort
of a useful printed out but instead of
of the array that just prints the the
address in the VM other problems with
reflection when looking at code is
generics are sort of bolted on and and
of course generics were added later in
in Java so so it's what I assume it
wasn't trivial to so unify the
reflection API but but still so if you
don't want to deal with generics well
then you do get return type if you do
want to deal with the generics well then
you do get get your narrator turn type
and as a user that is somewhat painful I
don't want to to make that distinction
at at that point in time and there's
also a lot of irregularities in in
reflection for example you have get
component type it's available on all
class objects although it's only
meaningful for a race and if you want to
navigate if you want to navigate the
this this source structure you if you
are looking at the method you do get in
closing yeah you have to
navigating your way is sort of you have
to know where you are in order to know
how to navigate there is no easy way to
navigate the source declared sore
structure without knowing where you are
so the yobics line model at runtime and
again this is something we're currently
working on so what we have is we give
you a factory to get direct line model
instances from reflective objects it's
currently named Cora faction Factory so
I have two examples here I do I get type
element from a class and also I get an
executable element from a method and
this is all I need to do to sort of jump
into the the model world and hopefully
our intention is to make this as as
close as possible to the source your
excellent model so that most of your
hopefully a wall but most of your code
will work equally well on on the runtime
model and on the source model but we do
not yet have have sort of hooks into
annotation processing and tools and I am
not sure if we are going to do that or
not so here's an example right here I
just want to I want to print all the all
the members of I want to print the class
basically of annotated element so I
create a mirror an element mirror from
the Ya'alon reflects annotated element
class because and I choose that because
it's sort of it only has four four
declared math
so it wouldn't help it wouldn't be too
long and then and I get these elements
utility and and using this elements
utility I I just print the entire
annotated element element
perhaps I should have shoes in an
example that don't have element in the
class name and and this is the output
and this is this is running purely at
runtime so this yeah this is the output
from from the example and you can see I
noticed when I did is that it's probably
not finished yet because the if you look
at the the line forget annotation it
says class you have a long class and
then yell in class which isn't looking
like valid yoga to me so I've probably
done a bug here or there in this code
the nasty next example is is the
overrides example that I that I showed
you previously you have these
declarations class a with a method am
interface B with a method M and Class C
that extends a and implements B and if
you want to to query does does M
override M this is how you would do it
in the model first you get an executable
element for a dot M there's the line one
or where the comments as one and then
you get the executable element for for
the interface method that you want to
see if you override B dot m and then you
get to type elements the on line three
you get the sort of the the class a the
type element for class a and then you
get the title
for Cassie so and then when you do this
query for example a time for if a dot M
overrides billet M first you put on your
I am class a hat and then clearly it
does not and on line five we do it
saying hey and I'm actually Class C does
does the declared method eight of time
over I'd be dot M and it turns out
luckily this is working so a dot m over
eyes B dot M that is false but as a man
when you look at it from from from the
perspective see a the time actually
override speed of them so this would
have been a horror to write using
refraction and our hope here is that
that you will find this useful doing
source expiration or or whatever and one
one thing that that that showed up this
Monday was someone asked if if they
could get annotations that didn't
heritance not only on classes but in
other cases
so perhaps method annotation some
methods could connect could inherit and
the answer is probably not but given a
suitable API that you can use to to
reason about source you can do this
yourself and this is one of the sort of
ideas we have with this that this will
hopefully be useful to you if you want
to experiment with interesting
annotation semantics unusual annotation
semantics
so Java X line model backpack or
reflection it's my favorite API we think
it's a great API to talk about the other
source at a much more suitable
abstraction level we are working to make
it available at runtime and you have to
stay tuned for more details all right
that's my last slide questions yep
sorry I can't hear you can you get
closer or hands
that is one of the things we so the
question was my first example had a
package that said calm Oracle model
where this is currently living and the
question was where will this end up and
the answer is we don't know yet it
hopefully it will be not only in I know
it I'm certain it won't only be in the
Oracle VM whether or not it will be a
Java API or an API in open JDK or that
is but but the intent is is that it
should be this should be available for
for all users of Java that's thank you
yeah contained by and contain for
yeah
so we the question here was could we
couldn't we just skip declaring the
container so say this is repeatable and
then you ever see would would make the
container for you and yes we have
considered that and it's it's it's very
doable in sort of a technical
perspective but we wanted to preserve
the the the previous usage of the
container is very important for for for
a lot of EE software so there is there's
a lot of software that have manual
containers and we don't want to go in
there and sort of obsolete that or make
it difficult to them so this has to be
this feature has to take into account
that the previous usage of the container
feature
otherwise any certainty the repeaters
natively
right we yeah so we did because or at
least I did consider this for a while
but but we choose not to do this in
order to to be sort of more backward
compatible yep
let me turn that around and ask is it
that horrible to have to do two
annotations right so I guess there's no
no technical reason why we can't do it
but I'm I'm not sure it's a good idea I
mean I'm not sure
so there are right now that would be
possible you can just through with the
annotation processing to do your own
annotation called synthesize container
that would that you would annotate the
same declaration with them
you bet complexity to some of the
annotations things like that so to me
the jump from well doesn't seem to be
that big of a benefit that's right so
but so so that yeah
so from my perspective this I want to
make it easier for the annotation user
that's the I want to to make it as easy
and clean cleanly looking as possible
when when you're actually using the
annotations that's my main perspective
yep
so it turns m's turns out to a
surprising amount of genetics
information in in the class files you
just have to pick it out from say a
failed signature there's our method
signature so you can actually although
if you look at an object on the heap it
doesn't know it's a list of foods but if
you look at there there are sort of a
middle view point where you declare
class and from that class you can
actually infer that that a return type
is a list of foods so you can you can
work around that to a certain extent and
I think that that one of one of the
problems the bug that I mentioned when
with the wherever I'll put the annotated
element that is due to me miss parsing
the generic information in in the class
file there's a type parameter there and
I think I just forgot to parse that for
example so it turns out you can work
around this but there are to a certain
extent there are there are there is
there are limitations and hopefully they
won't be there's you can go a
surprisingly long way without tasting
them
okay thank you for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>