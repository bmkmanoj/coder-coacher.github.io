<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Why There's No Future in Java Futures | Coder Coacher - Coaching Coders</title><meta content="Why There's No Future in Java Futures - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Why There's No Future in Java Futures</b></h2><h5 class="post__date">2013-02-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/L-rKLSdPEMs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi my name is Brian Oliver thank you for
coming along to future talk so a blogger
tree what we are about to say may or may
not happen or has happened or will
happen who knows as with all of these
sorts of slides as I said my name is
Brian Oliver I work for Oracle I
predominantly work in the coherence team
or with a parent's group that's my
colleague Mark is also on the coherence
team coherence you don't know as a
memory data grid product product
clustered and so a synchronous program
is something that we we focus on
constantly yeah we do a lot of this
stuff in fact I think in order to like
be in the coherence team you basically
have to think asynchronously all the
time and we're actually going to present
this talk asynchronously so this this
talk came about through just some
experiences we had migrating some of the
coherence internal security has been
around like 10 years you know I started
using it as a customer about eight years
ago marks been on it for ten yeah so so
mark has an internal knowledge of the
coherence product and I've sort of come
in from the outside and we basically
built while mark built and and the rest
of the founders built like all the
concurrency stuff basically themselves
so things like executor service and
futures just weren't around I think
we're on chopped up 1.2 Java 1.2 yeah so
a lot of the stuff we had to build and
then eventually is you know Java 5 came
around we you know started refactoring
and using some of the you know stuff
that building on JDK and obviously if
you build your own stuff you get to make
it the way you want it to be but when
you start to pick up someone else's API
even someone else's API and JDK then you
know it's interesting because it's two
completely independent designs so so
this talks in the talk we're gonna talk
a little bit about this
if you're sitting here and you're
slightly confused this talk is not about
the future of Java and it's not about
predict future predictions about the
future of Java so we're gonna talk about
concurrent programming and and our
experiences of the Java future and
obviously that stuff that's related to
that so so you have two options you can
go and have a free mark or you can sit
there and suite or use Internet and so
we thought it's somewhat I don't know
irony that we've got make Java the
future on one side and why there's no
future in Java yeah Joey futures on the
other boat okay let's get let's get
started so that's of a survey who does
concurrent programming really like
creates threads wow that's a lot of
people I thought it was looking like
mark does it okay it's quite a few
people so who uses the executor service
most people who's actually read the Java
doc API about this stuff okay less which
is scary considering there's probably
20% of you doing stuff and never
actually read the doc which I would then
assume you've not actually read the Java
language spec on this either okay so
this is actually taken from the doc
believe in art this is what the doc says
you know future represents a result of
some asynchronous computation that
sounds cool Oh quite Alex a bitch from
last night Alex you wrote part of spring
net and a lot of stuff with spring and
Java arias behind you there is and I
think alex has said it's all good when
you look at the API but the Devils in
the details when you start using it and
that's exactly what we felt so this
looks good right represents a single
computation methods provide you know
check if the computation is complete
wait for its completion and tree results
well this is all very good and then we
get to this one it's a boy
if necessary we're gonna talk a little
bit about that okay hey yeah it's the I
thought it was an asynchronous API right
so it's a synchronous API but in the
doctors were going to block so let's
have a look what we have get cuz you
know it's a you know it so uses generics
and get get out value weights if
necessary so there's a weight if
necessary wallet what it's if necessary
mean well it means block and last you
get an exception or you interrupted well
you can say wait for a certain period of
time unless unless some give up wait
some time and then give up so again
another sort of blocking call you can
cancel because I have as a canceled or
if it is it done so again this is taken
okay I added some comments but this is
exactly out of the ape out of the
Javadoc I just copied in so imagine we
have this you know archive searching
thing we want to do we want to be able
to you know search some archive for
something and it's going to return a
result and it could take a long period
of time and maybe there's you know let's
store in some buzz with this big data
behind it or there's a database you know
but we're going to do something and take
a string and say find this and return a
string and that's good but this is this
is a not an asynchronous a pro this is
just an interface to something that will
search fair enough we would like to do
asynchronously again I just totally
copied this out of the out of the Java
Java doc and it was sort of bolded bits
to highlight it so you can imagine let's
just say no one probably does this year
but let's just see who does any sort of
GUI programming yeah there's a few I
know put your hand up if you do so if
you imagine you've got a button you
press the button that button then just
runs on a thread and it calls show
search and you're passing the thing you
want to look for when you're passing it
an executor service that's going to use
to be provide some you know async work
async workers are going to pass in the
searcher
and you'll do you know execute submit
callable do the do the search so very
good this will kick off the search with
our search archive searcher in the
background gives the future and then
what do we do do other things
let's do other things what would we
typically so do do other things or maybe
won't do anything but then what we do is
this last bit future dot get which does
what blocks so if anyone is doing like
GUI development is blocking the event
thread a good thing to do
he'll know now let's imagine this is a
this method comes across restful
interface do we want to block the thread
that's receiving that request it's like
a hell no right so sort of challenging
here that the the in if the sort of
infrastructure we have in that language
says yeah you can do suffer async but as
soon as you want to try and get the
results one of the things that we
typically do is just block and one of
the things that gets me on the slide so
when this is one of the ones that Brian
put together I didn't realize initially
that it came out of the Java doc and I
looked at it and my primary problem is
actually before the future get it's the
display of the thing so what's the point
of that line it's it's because it knows
that you're about to block right so
we've gone async and we don't want to
just you know turn around and waste this
thread so let's do something else but
for how long is the display the things
we're just trying to fill on the time
and so that when we get to a future get
hopefully the results already there so
it's it's this filler like it doesn't
belong in this it doesn't belong on the
screen right that should be down on the
floor edits we care about doing that
independently of this thing we forked
into the background so I was happy to
find out that Brian didn't write this
slide yeah yeah don't do reviews with
mark code reviews as well
mark knows is asynchronous and this is
like he's exactly right like they're the
whole point of what this is like show
the result of the search and we go try
to do the search and then do other
things well I'm trying to show the
results of the search so what's this do
other things and this sort of as Mark
said like he thought I'd made this up so
no I just copied this no I had to
convince him it he go on the java table
this is what the Java doc says this is
like an example so it's sort of out of
flow it's out it out of whack a little
bit here so let's have a look at the
executor service you don't have to use
features and the talk is about you know
this Java futures we have to actually
look at it's sort of related class which
is executor service and I mean you can
use create your own features and do a
lot of other things but predominantly we
get them from the executor service or
some so class or something
implementation of it so what we're going
to talk a bit about the executor so an
executor you know provides methods to
manage termination and produce features
tracking process of some you know async
tasks and by tracking process we mean is
done like that's basically it are we
done
I'm not sure about you but you know
you've never seen a GUI every once in a
GUI you copy file you want to see a
progress there just imagine it just sits
there you guys know I'll tell you what
I'm done then after a while it gets done
like this is not tracking progress so my
personal dislike of this but okay
it it has some methods to help us out so
we have yes we can submit a callable and
we know call the balls are things that
will return values or you can submit a
runnable which returns a future of I
don't know which all we do is use it for
saying are we done yet so you can you
can monitor that and then we can do
invoke all with a whole bunch of tasks
returns a list of those features how do
we know that all of those things are
done is an exercise for the reader
it's not you know you you have to do
that JDK doesn't providing any help and
invoke any is I think quite a strange
thing I've never used it but I just want
to know does anyone actually use invoke
any no yeah like here is some stuff I
would like done asynchronously and you
just tell me when one of them's done and
I don't care about the rest I mean that
I don't know but I'm curious how about
invoke all so but we had everyone are
almost everyone using the executor
server so most please submit yes okay
let's submit well so we could carve that
one out of JDK 8 we can just take care
of Oh Kenny it's a pretty good
population the sample so so stalls of
adoption we see two stalls right mark
you want to yeah so this is the blocking
right so hey executor service submit
which is what everyone is doing
eventually we do the future get and in
the middle we try to you know make this
thread useful so and then let's block
now and answer we feel we could also
block with the timeout but I see very
little use cases for but very few people
do that because it actually thought
turns out to force this yeah so so here
right so now we'll we'll pull rather
than them blocking or at least well
we'll pull up front so we can continue
to try to do useful work until the the
result comes in but again back to my my
previous problem like I'm doing I'm
intentionally like polluting my code
trying to do unrelated things or I may
be doing nothing at all right it may
just be spinning on is done instead of
blocking and of course there's potential
value in that right the the act of
blocking itself has a has a cost and if
you're going for ultra low latency
spinning until the results there could
could save you you know some some time
but unfortunately it also wastes the
core so yeah I think I'd missed on the
previous one we had the the blocking
wastes of thread and the next one is
polling waste of core well they're both
bad but I'd much rather waste a thread
than a core but unfortunately we see we
see a fair amount of this where people
will just you know
try to improve performance by spinning
and it works really well for them and
sucks for everybody else in the VM and
you know we're talking about lots of
like cloud stuff and like multi-tenancy
you want someone spinning a thread and
wasting a call for you because you're a
tenor inside that same JVM like yeah we
should just stop this stop this if
you're doing it don't do it in yet you
don't need the little latency
you don't need low latency yeah so it
this this actual example this is a
similar example out of Java Doctor Who
scene
it just gets worse so it's a invoke all
I get all these tasks and I got them in
a list and then what I do I want to
iterate over them to see that they're
all finished and I'll just block I'll
just pick the first fusion I'll wait the
others may have finished I may actually
could could be able to do something with
the other results let's say Map Reduce
cool I needed to get Map Reduce into the
talk so MapReduce is someone going to do
stuff in parallel but I'm just gonna
pick the first feature and just block on
it forget about the rest we could
probably do a complicated algorithm like
block and then or spin one through and
then then didn't use one to block and
then get before a timeout and then spin
again spin through the list we won't use
all the CPU then no safe very safe
so again not not not helpful not very
helpful but you know semantically
correct code but and I have to say again
this doesn't feel a synchronous to me
it's like something happened we put
something in the background but our
thread is completely synchronous here
and and that thread could be as I said
like a thread from the UI thread from
web service thread from you know maybe
it's in a thread pool though we thought
we can waste those voices because
they're free yeah so if you think about
like if everyone loves MapReduce if you
think about MapReduce this is not
MapReduce friendly right okay so let's
just step back and go what are we really
trying to do here
so when when we get to the point where
we have to do something in the
background
what are the usual use cases other
things well you either don't care if or
when it completes all you do care I
don't think there's any other options
you you you don't care if the tasks that
you've you've said to do asynchronously
completes because it's going to carry on
do something else you don't care about
the exceptions it's off on its own and
you've you know fought that thing off
and it's going to go away or you
actually do clear it do care in which
case you want to do something else now
if you do care when it completes you
actually want to do something with the
result or maybe the exception or
actually you don't care right you care
that it completes but you're not going
to use the result and they're the sort
of use cases that we see so in summary
you you know do you want to you in
almost all these cases you want to do
something after something has completed
and that's what the previous examples
have tried to show it's like do this
start doing the search and when the
search is done display some results but
we try and inline that and it forces you
to block and you've got no other way
around that so the API unfortunately
forces that style of programming even
though what we need isn't that that's
not actually correct so there's a bit of
a mismatch there so really continuations
of the key so really you know the idea
of a continuation do they look we're
gonna do some stuff and then later on I
want to continue on with same state plus
some other state and continue working
so using continuations is very very
helpful Java doesn't really have them
yet but you know we can we can get
around this using abstract inner classes
so so that's the way to reserve to
represent like future work is to use
continuation thoughts I think moving
moving forward well okay so yeah what's
what's missing from the future and the
what we need is a call back from the
future right so so far
we looked at you know how do we know
that the result is there we have is done
and we have we have get but what we want
is some way for the future to call us
back and say your result is ready if we
have that then what do we get
it allows us to know when it's complete
and impact upon it and and act
immediately so only talked about the why
would we want to spin calling is done
it's to save on that latency but if it
calls us back we get those same benefits
by knowing immediately being able to act
immediately but without you know wasting
the CPU for the entire duration of the
execution so that removes the Polie need
and it removes the blocking need as well
so now we're not we're not wasting a
thread either and it it allows for as
Brian was talking about the continuation
style when we we take action when the
result comes in as part of that callback
it starts to very much resemble
continuation style programming which is
everyone saw the looking Java right yet
you should download it there's some
really cool stuff in it particularly the
lambda stuff you can get that build and
drop it and it had dropper on your
machine it's pretty cool we actually I
actually ran the entire coherence test
suite on it and like you know we were a
little back from the the future but yeah
it was it was really cool but when you
start to look at lambdas and you start
to see this and continuations yeah ah
this stuff starts to fit together now so
yeah so let's look at what it would take
to to fix the the executor service API
into fix future to support callback
style processing the key thing is
actually who's in control of the future
in the first line there where we have
executors submit returning future is the
current executor service but what we
proposes instead you need to inject into
the executor service your own future
implementation inject an observable
future rather than have one returned to
you and kind of a fundamental tenant
that we found as async methods should
return void if you're not returning void
you're returning something
which doesn't sound very asynchronous
and as it happened it applies to the
future results as well so we end up
switching to the pushing pushing it in
model and this this you know this whole
concept of ASIC methods must return void
once you once you start doing that and
apply that change to your code base it's
really interesting what like what
happens that you naturally start using
continuations and you look forward if
you start to look at Java eight you
start look at Lam doing oh wow this code
is actually going to become a lot
simpler and you as I said like you're
not blocking you're not polling so what
would observable future look like so we
thought well observable future extends
future because it's got to be future and
we'd have two methods on result of T so
that the executor service implementation
would call us back and call that on
result with with the result and it or
something happens we'd you know it it
would call value with the exception that
occurred fixed it's all fixed right
seems fairly reasonable so let's rewrite
the Java doc example so a few things
like in the previous example in the
example we had throws interrupt
exception that goes away right we're
doing this async handling the exception
is just you know part of a callback so
we have observable future we create our
observable future you know it's gonna
return a string when we do our result
then this this laser pointer is not
gonna no it's not gonna work so when we
do our result we display the result
that's pretty cool and on failure we
clean up so nice nice and simple now we
submit that's pretty much from before
and then we get to my favorite part of
this slice we get to remove this display
other things mess from the the earlier
example that's no longer the concern of
the show search method right that's what
happens after we return that thread just
continues on to do potentially unrelated
work we don't have to try to fill in a
gap
we don't have to make ourselves feel
useful between like submitting it and
getting the result and this is like GUI
friendly right you're not blocking
anymore this is very friendly for user
interface it's very friendly for service
right and you know your talk on you
actually have a whole talk it's not
obvious but but yeah the work on the X
illogic exa bus project and it's it's
about doing asynchronous networking and
really applying patterns a lot of this
came out of that that project applying
patterns like this to be able to push
the network very hard in parallel
without leaving a bunch of threads
idling or spinning so you know you you
buy sigh expensive ecologic Balch and
it's got all its really cool and beanie
InfiniBand stuff in it and all this
awesome memory what don't you wanna be
doing blocking and polling right because
often what happens is that expensive
cool infrastructure is just sitting
there going you know just waiting
because the CPU is doing some stuff it's
you know so this is as Mark said like
came out of out of that work not this
example yeah so yeah it's the key here
is is a bit what we talked about on the
previous slide so one we made the change
from having the future given to us by
the service the executor service to
injecting it and then the other key
changes what do you do after you've
submitted your work well it's either
future get you know wait or you just
return so that's the you know these
these keys inject the future return void
and then be able to just return
immediately rather than then turning
around and waiting we so we with the
observable future we actually are now
both non-blocking and on polling good
stuff and mocks come up before about
returning the thread to the pool I just
returned the thread to the pool right
can now carry on and do some other work
which by the way makes it much easier to
size your thread pools when you're not
wasting them blocked so for instance we
talked a little bit about X of us where
we try to push too
limits of InfiniBand and you know we
want to use all the cores inside of X
logic so 24 core so how big should our
thread pool be well 24 ends up being a
pretty good number because we don't
waste those threads they're either doing
work or there's no work to be done and
so we don't need to say have 256 threads
to try to do IO processing 24 1 per core
is the just about the right number
except if you're doing blocking in
Poland we we explicitly disallow which
is its the other thing that comes out of
this is you adopt this model and it
becomes I'm not gonna do any blocking
code and I'm gonna call I'm gonna call
your call back but you're not allowed to
do any blocking code either and you can
call other people's callbacks but they
can't do any blocking code and if
everyone embraces this then all of a
sudden that your threads become really
really useful they are just executing
instructions they're not sitting there
waiting and you can just push things
through and this again it gives you
really big savings on latency because
you don't turn around and have the
thread go into a state where it's
waiting for a notify which just to take
this side tangent we found that it's
about 15 microseconds is the cost of
trying to wake up an idle thread at
least you know on Linux x86 which again
going back to InfiniBand that becomes a
significant portion of a network
round-trip call this is 15 microseconds
it's just completely in in process and
if we can shave that away by doing a
call back and continuing the execution
from there so it's a noticeable win so
yeah so the cost of going from one
server to another server over InfiniBand
you can do that on a reasonable sized
object in like four micros yeah
so if you don't really want to add on 15
now you're like forest like super low
level but you know even if we're talking
about a hundred where we've pushed very
happen the application stack 15 is still
that's you know a sizable percentage
well I could do a lot more yeah notify
just yeah notifies wasting time as well
so okay so can again we go back to
continuations of the key and if you look
at it you know this is the the huge
bridge of being inventive and it's
basically like you becoming an
event-driven it's becoming an
event-driven sort of dealing with
threads and I seriously so your future
becomes a continuation so
okay yeah yeah the aggregating future so
we started to look at you know let's
have some fun with our our new toy and
so imagine you take this observable
future and you create a collection of
observable futures and you hand those in
his tasks and each of their own results
method add to a shared results list that
shared by all the users of rule futures
and then once all the results are in you
aggregate and proceed it starts to look
like MapReduce and far more efficient
than you know block block block block
block and the list we're actually making
forward progress as each result comes in
and the last guy in says okay I'll do
the reduction stage so it's like oh this
is this is nice we can actually get a
little MapReduce style action with with
the pattern but it's also kind of clunky
it's a little clunky well what's wrong
fixes so who-who noticed that what we've
just been rambling on about for ten
minutes doesn't actually work oh one I
wish I had a gift but you can get the
gift of knowing that you're the first
okay so we didn't implement like a
blobel futures extends future but
there's a whole bunch of stuff that we
just sort of wave to hands and just left
out totally so we forgot cancel is
canceled when it's done but do you
actually need them I have been
complaining about them I don't want them
right when you actually have to
implement feature yourself having to
implement those methods is really
annoying
especially if you only need the first
two so do we actually need them who
votes yes ha actually who's awake
there's a few away okay so we don't need
these methods so let's let's do
something and this is this is um this is
this is actually some mock work yes this
is what we use in in exa bus rather than
future and well the interface certainly
looks looks simple and it's it's more
generic than just trying to fill in the
gap of what an asynchronous result looks
like it's simply
when something is available so it's a
it's a fairly generic callback but when
we try to use it to replace future when
you go to the next slide we'll talk
about what these methods are supposed to
mean
so ad is kind of synonymous to on result
it's it's here you go I have the result
of your computation and flush means I'm
done giving you results which goes back
to ad which is apparently you can have
ad called more than once in the EXA bus
case we use this for streaming results
in but in other places where we're doing
aggregation style you know ad could be
used to give you partial results and
then flush is the indication that I'm
not going to give you any more any more
results and you can see or potentially
see how that can lead to a cleaner Map
Reduce style right each ad is giving you
a part of the mapping and finally the
flush is the good indication that it's
time to to perform the reduction in the
if if you're in the Map Reduce that is
like everyone seems to want to do Map
Reduce okay so let's let's go back in
refactor again so now we use a collector
with credit collector and we have ad
this is what we had on result and now we
have the call ball but now we also
submit and we pass in the collector and
the the executor service would call the
caller will get the result and then call
ad and put it into the collector for you
and then our collector would then do the
work so all in all very similar to the
observable future style but we we left
something out so yeah we left something
out again
so exceptions and this is one of the
things that was interesting when we we
started using collectors how do you how
do you indicate failure and it's
somewhat of a the problem is specific to
the where how you're using collector but
in the case of futures the first thing
that came to mind as well you know
normally we're collecting some object
why don't we just collect an exception
when there's a failure okay so I can
have you know collector of question mark
and great you know type safety and I'll
shove an exception in there when there's
an error so an ad I can always do
instance of that was the the first
inclination and pretty pretty quickly
seen as a very bad idea not only is it
ugly but you know sometimes might
actually want to use an exception object
for something other than to indicate
error and to just say Oh any exception
that means something bad happened and we
really it's totally lost Top Safety yeah
yeah this let's go back and make
everything object yeah didn't want to do
that so then the the next thing and I
think this is so we argued at length
like I really argued at length on this
so it's like well why don't we just have
it like a on failure because we like
what we didn't before in the observer
future was like you know the executor
service or whatever's doing the
executing of the task if an exception
occurs it can just tell the collector
hey I got you know here was a failure
and it looked okay I think I managed to
convince mark for a few seconds it
really ugly DUP the collector API yeah
had him flushes just gorgeous
I didn't for she's gorgeous and then I
started thinking about what would happen
in Java right if you notice the previous
slides we had flash declared with it as
a default method so it's stuff you can
do in Java right if we had on failure
that would completely not work with
lambda so I started losing the battle
this argument that we're having so I so
and well I still don't like it come up
with a solution so so the the kind of
generic solution becomes you have to
define a protocol between the service
which is performing the execution and
the user which is requested it but you
know we also don't want to say that's up
to you guys so what we do is we say well
you don't you don't collect simply the
answer you collect the result
of an execution and the result can
obviously be either the answer or it can
be the failure so we have collector of
results of tea rather than just
collector of T and from result you can
just call get and get your answer or if
it failed calling get throws an
exception
unlike future get is non-blocking and by
the way you didn't get the result until
it was there right you started with
collector collector ad was called giving
you a result you have it now you just
don't know whether it's an answer or an
exception and trying to obtain it gives
you the exception if there was one
what's beautiful here versus using the
on failure case is that your exception
handling looks exactly like it wouldn't
kind of traditional Java right you get
to use try cash versus on failure what
do you do you instance up again shut up
which was more suggestion that's the
last thing you pass the exception let me
do instance off hang on Java has
try-catch blocks and in seven we have
Multi multi try catch block so yeah so I
lost that total in that argument I think
I still owe my could be it but so now
let's go back now look what it looks
like
so okay you have a result of string why
didn't we just call it a result
collector well actually we do have an
implementation which is just called
result collector it returns T but we
wanted to show that the steps that we
went through so we have a collector of
result of string and now we add a string
result and we can say display gap so
obviously result that gets non-blocking
feels like future but it's not and then
if there was an exception we then get
the exception in the same way and this
is exactly the same semantics that
future has when you call get right so we
borrowed a bit of the concept and use it
in here and so starting to clean up like
we now can handle exceptions but I we're
still missing some concepts that future
has so cancellation interruption and we
still don't yet agree on this but we
thought we'd argue it out and we will do
a survey to see who wins
so what we what we do fundamentally
agree on is that no
everything is cancelable or interruptive
or so future sort of gives you the
chance of what's it called canceled and
may interrupt you can pass in and
parameter and and if you read the
Javadoc it's sort of a bit loose like it
may or may not cancel the penny if it
was started yet or not or and it's sort
of up to the implementation what the
behavior is it's not completely you can
call it you can call you can you can
call cancel and it may or may not do
anything we really want to make it a bit
more explicit and you know that some
things should you can be canceled or
interrupting something it's current but
who's job is it so this is what we
started like design the API again it's
like whose job is it when you go to
cancel something should it should the
request be on the task or should it be
on the result or should it be on the
executor and it's actually it's kind of
funny right looking at future it's
bizarre you you cancelled the result it
really seems like you should be
cancelling the task although I think
that the continued point of debate is do
you cancel the task or do you ask the
service to cancel the thing that it's
running right and so we said well if we
want to can't if you ask the service so
execute Service cancel this task how do
I know what task and then to know what
task could probably need a ticket which
means that half my submit would have to
return a ticket but yeah async stuff has
to be void so I can't do that so we we
basically think while you need a way of
doing this you have to be able to cancel
and we have to we have actually two
concepts we have three concepts here
like the difference between cancelled
and interrupted so you know I think
there should be separate like to you
know if I if I cancel something it means
make sure it's not done but you can
cancel something before it started or as
if something started you interrupt it
and this is where we sort of disagree
so so we introduced this notion of
interruptible so you know interrupting
to say was it interrupted and and I
wanted to add a bit more and I'm slowly
losing this battle as well but
essentially you have a rapper that you
know we can have an interoperable
callable and interrupter honorable and
what's probably important to see here it
may not be obvious is that's our cancel
method right we have one method it's
interrupt this task and it's it's
dependent on how far the task is made
whether it feels like a future
cancellation or feels like a threat
interrupt but it's the I don't want it
to happen anymore
stop it wherever you can okay I agree
with you so now if we go back what we
need to change result now before we had
you know get through his execution
accepting exception
you know we can throw out and I this is
where I wanted to throw a cancelled
exception or interrupted I want to know
if yours if it hadn't started yet in
which case I'll get a canceled exception
or if it had started I get an interrupt
exception and I want cancel the
exception to extend interrupted
exception because that's too many throws
so who agrees with mark too many throws
that's most of the audience crap well is
again okay so how do we use this well
you have any interruptible tasks and we
just wrap it and then I could submit it
with the collector and then oops
I only sorry to say TAS not interrupt
okay so now we can handle exceptions we
can handle canceling and interruption we
can handle catching them knowing knowing
how to deal with them but there's a
whole bunch of other things that I you
know I'd really like to I personally
like to see that you start to do with
async
what about timeouts so when you use
future the only real timeout you can say
is you can timeout on waiting for a
result you can't give a timeout for the
task so imagine I have you know huge
amounts of tasks to do and I'm cueing
them all up so some of these tasks have
a like a time to live now we we sort of
could argue that the
time to live should be passed a part of
the task and the task itself could have
bought all you could be able to say look
I'm going to submit this you know submit
this callable here's a collector and
here is the time out and then if the
executor service gets to gets to execute
it can look at it and go well actually
no this is timed out and I can it can
then basically create a result which
when you call get will throw a timed out
exception which I think should also
extend interrupted which because you
notice I'm just adding more and more to
me it's interrupted means it didn't
finish you can you can catch timed out
if you want but I'm only going to throw
you're only gonna throw right we don't
have to agree this is how you improve so
this this is another sort of one of my
slight dream so you know you do
something asynchronously that first
thing you know is hey how much has been
done like because with the future method
use like hey go and do that and then
wait so you can see in the log right
they submitted asynchronous job doctor
thought waiting like job hasn't finished
because I called future got get and I'm
just sitting there it's not like no idea
like where is that thing how do I get
feedback so we sort of there are two we
think there are two approaches and we
haven't sort of you know to be honest I
think we've nailed the solution here but
when you have a set of serial tasks
you know task 1 task to task three tasks
for you can you know up to and you can
pretty much see some progress but you
can measure some measure some progress
through that but that's extremely
difficult if you have n processes and
they're all done in parallel how do you
know how much is complete so we haven't
come up with a solution one one solution
was I thought was I think progress is a
part of the result it's part of the
protocol so I would say look progress
extends a result and I can like in the
case before like you can add multiple
results to the collector I can add
progress
the collector as well and then I can you
know yeah instance so this is progress
how much how much have you done because
really the task now is how much it's
done but that sort of falls down when
you have lots of concurrent stuff yes I
want to go parallel so in my world you
you know that you broke your task up or
your job into ten tasks and once you've
got five of those tasks back you might
claim 50% done you might be not quite
right but the sliders going to be moving
just the same but either way it's it's
the the feedback into the cut the
feedback via callback that that gives
you some indication of how things are
proceeding that's that's important and
and the ability to do actually be able
to do that you know I think that's
that's one of the nice things about the
result and collector that you can
actually put stuff into collector and
you can add semantics into collector
around around capturing these things so
we've been talking a bit about you know
call levels and runner balls but Dewey
yeah I sort of do we really need them
and we've really been using the word
tasks so really you know you know tasks
you know it's provided with a collector
and the tasks can then add the results
of the collector you know do do we
actually need coal and ronimal I'm not
there yet but it it looks like I could I
could see going there I still see this
the callable is a nice kind of atomic
unit with its with its result value what
I do like with this so pushing the
collector and it lets the call will
continue to push it along which is which
is nice yeah : any return one thing like
cool we're telling one thing tasks
because he given a collector the toss
could actually extreme results back by
the collecting just say collect to add
add add add toss gets the end flush dump
so and if it's if you want to model
runnable because runnable doesn't return
anything it's like do staff collector
flushed finished which by the way
executor service right that had a future
of question mark which when it was a
void return set a result to null
to see I know Colleen just calling flush
which is the same as calling flush this
time cymatics but we don't have to
return null yeah so arguably cleaner the
go parallel and continue so when we look
at our using a collector to do
aggregation now it's I think it looks
quite a bit cleaner than the earlier
result in the early example we tried to
do with observable future here we have
two very distinct phases we have when
collector that ad is called and at that
point we're just collecting our various
partial results and then finally the
framework is responsible for calling
flush one that knows we have all the
results at that point we can aggregate
and then proceed which is really the
continuation part so same abilities you
had with our observable future result
but kind of it breaks it up in such a
way that it kind of promotes it promotes
the the MapReduce style programming a
bit more than than with cobble ena
together with a bunch of observable
future sharing a single list result so
remove back we had the loop over a list
of futures and we just call get and grab
one and wait and grab the next one we
had the version where we had add but
then we said if this is the last one
then proceed and then this is the clean
version so you don't need that if
statement haven't got the last one
because we know flash is going to be
called at that point and we clearly
break up the aggregation function of
that list down to one value and we split
out the continuation and in this case
like both of these two things are those
two methods or lambda vary lambda
friendly because it's stateless it's a
perfect for Java aid so this we I think
this may be our our last slide almost
close to it so here we kind of say you
can have it both ways if you want so if
we didn't convince you that you know you
should ditch future in the point out
that if you have a collector style API
nothing prevents you from writing
something called a future collector
which implements
future using the collectors callbacks
just like okay big whoop
well what's nice about this is you you
implement this once I guess we could do
it for you
and anything that takes the collector
API really any callback based API you
can just shove a future collector into
and you have your future based API you
can't do it the other way you can't
build callbacks at a future there's no
there's no hook point so that was one of
the if you do it's very very inefficient
well you have to be girlfriend's pole or
book yeah so this is this is one of
those that kind of winding all the way
back when we first started looking at
how did how we wanted to do async
programming and we looked at at future
or callback we saw we you know it's like
let's provide both people like future
and they're familiar with future and
then we said no no if if we give them
collector and we give them something
like future collector they can choose
their style but kind of as the provider
we only have to support one form of
async processing and let you then choose
your style and obviously as I said if we
chose the future out you can't you can't
go this way so and it's one of a pet
peeve of mine you'll see in some async
api's they can't make the decision
between callbacks and future styles so
they do both so as you may have noticed
from some of my gripes early about too
many things in the throws clause or too
many methods at at the collector I want
the API to be crisp so when there's two
variants of every method in an interface
that is definitely not crisp so I can
just blow a lot more tasks so again with
this it gives you that bridge in case
you know you need to provide something
more like a future API it's it's there
for for your users but it's I mean it's
also there something else takes a future
and you have to pass it in or if you
call it you've got a some data structure
with existing futures and you need to
keep that you know we need to keep the
same type safety then this this still
gives you that gives you all of the same
semantics so we thought about I think
I'm uncomfortable would collect the
executor service but I think you get the
point
right you you want to go to submit a
task and you can pass in a result
collect a submitted task and
maybe you have some timeouts but if you
know in terms of what you know mark
saying being Chris we probably take that
method out as well and then you know
essentially in bokor we get rid of
invoke any okay so that's that's all we
have to say and now we have questions
yes absolutely so we could we could
actually just make an extension to
execute a service keep the existing
methods and they just proxy them on and
and do the wrapping is absolutely we'd
probably mix the two we have callable
executors service as a separate
interface and then just mix the two into
the implementation yeah
yeah that's that's key it's a question
well so technically it would be up to
the implementation of the service you
know the executor service in our
implementations we call back from the
same thread that just finished running
your task because as I mentioned we
don't want to have to wake up another
thread to do the call back we want to do
it immediately save those in our case 15
microseconds and we've stipulated that
your call back can't block right so go
ahead use CPU all you want but don't
don't block and one of the one of the
interesting things that we've done is on
the executor service sort of our
implementation of this is that that
callback let's say we know by some
runtime instrumentation that we know
that the that the tasks that you're
submitting execute immediately and
there's no point based on just runtime
stats there's no point in putting it on
a queue doing a thread context switch
giving it to another thread executing it
then calling back on your callback we
can actually just use the calling thread
so the the thread to use can we can
actually decide right we could use the
calling thread it's like yeah calling
thread actually execute a task then
execute as well
I knew someone would ask oh I think I
think it would be fair to say no it's
the if you if you looked in the in the
jar file for coherence you would find a
lot of these classes but it's at this
point we're kind of using it internally
so subject to change not reference
implementation but we've also kind of
shown you
I mean it's there's not really that much
to it it's more it's it's a pattern
but yeah formalizing it for sharing
would be would be nice too so there's
two there's two other projects that are
going on one is actually a spin out of
the coherence incubator it has pretty
much exactly this and that that hasn't
been released open source yet but it's
coming out on java.net it's called
Oracle tools you can actually look it up
but the sauce hasn't where them we have
had a chance to push it up yet and it
has parts of this and there's another
project inside of GlassFish again which
hasn't been pushed out which also uses
this it has exactly the same interfaces
so it's sort of like okay we have three
four different projects using identical
interfaces so we're now like okay how do
we get this together and like you know I
personally like it'd be cool just to put
this in the JDK right because then we
don't have to write the interfaces in
all these different projects it's in the
JDK
that's a different experience just
getting stuff putting the JDK but that's
obviously where where I'd like it to go
but if yeah if you're if you want to
contribute us or you know move this into
open source that's very easy we can we
can work on that drop us an email happy
to help another question
it's well it's basically the same style
all right it's it's really it's a
presentation on callbacks right and what
we what our team tends to do is invent
it ourselves specifically for what we
need but then try to do it in a way that
we aren't just doing it for that
particular task at hand we want it for
the product as a whole but basically
it's its callback style but yeah its
completion handlers it's very you know
it's same same concept what what bug
this is like executor service and
futures like that's the place you go to
to do a sync in Java or the starting
place and didn't see it in there but
yeah yeah from what I said it went well
as a couple so yeah it's an interesting
conversation which we probably could
have off-topic the same with there's a
observable task as well but the which is
for use with the executor but the whole
point of that is to implement feature
even though the interface looks exactly
the same and it has completion handles
the whole point of it is to implement
future right
cool thank you Thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>