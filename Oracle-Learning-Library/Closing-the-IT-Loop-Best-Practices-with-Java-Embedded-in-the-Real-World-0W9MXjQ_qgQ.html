<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Closing the IT Loop: Best Practices with Java Embedded in the Real World | Coder Coacher - Coaching Coders</title><meta content="Closing the IT Loop: Best Practices with Java Embedded in the Real World - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Closing the IT Loop: Best Practices with Java Embedded in the Real World</b></h2><h5 class="post__date">2013-01-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0W9MXjQ_qgQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so what we're going to do today is
to talk a little bit about Java embedded
sweet which is a new product that I
recall has announced just recently but
we're going to focus on Java DB which is
one of the components of that sweet so
the Java embedded suite
trip over this cable if I'm not careful
is is a package of a Java runtime and a
collection of middleware for that is
targeted at embedded gateway type
devices so you've got a jar I see
embedded runtime a special version of
GlassFish called GlassFish were embedded
sweet Java DB and Jersey which is a
framework for restful Web Services and
essentially what you can think of that
we're doing here is bringing Java EE
technology to embedded gateway devices
we've taken so we've taken these
components done some squeezing we'll be
doing more
squeezing and crushing and cramming in
the future to continue to size reduce
and optimize the components of the
embedded suite and obviously they're
supported together as a whole product so
Rick why you know as as a Java DB person
yeah why Java DB well I'm glad you asked
that question
Joey DB is a full relational database
the codes been around for 15 plus years
it's the same bits as Apache Derby it's
being developed in the open largely by
Oracle shoulder-to-shoulder with IBM in
the Apache Derby community it's as I
said it's a full-featured sequel
database comes with all of the sequel
object types that you expect and all of
the the sort of sequel security expect
all of the crash recovery you expect
transactional behavior
but it fits in a very compact 2.6
megabyte jar file thank you
so I guess one of the points here is
that Java DB is actually easy to use so
all you're doing is including that one
jar file if you're it actually has very
very extensive SQL support and so if
especially if you're a you know an
enterprise Java developer then and
you've done any sequel with a bigger
database then I think you'll find that
you've got a very very familiar sequel
dialect to deal with yeah absolutely
it's a Java DB that the code grew up
after the sequel standard been approved
so we had the luxury of implementing the
most portable of the sequel dialects
which is ANSI ISIL sequel standard and
suddenly when I used to I I found that I
actually got very good performance from
for the the things that I was writing
without really having to do anything
other than you know implement the JDBC
calls that that did what I wanted well
excellent that validates the story we've
been telling so so there's a there's a
lot of you know code in there that
actually looks at the environment and
works out appropriate defaults for page
sizes and things like that right that's
right it was originally designed 15
years ago to be an embedded database and
to be a database that could be dropped
into shrink-wrapped applications and not
need a database administrator so the
whole idea is that the database should
be able to tune itself configure itself
and come up with reasonable defaults for
your environment okay and we'll we'll
talk a little bit more about that later
on in the presentation as well and then
flexibility is another important point
because one you know one-size-fits-all
solutions don't often fit
well sometimes they don't for any right
absolutely
and and with Java DB you can being a
pure Java database means that all sorts
of features can be coded by you in Java
and plugged into the database and
there's a there's a list of these
features up here yeah so you know the
the encryption is a good thing for for
an embedded database and that's
extremely flexible because for the
implementation of that it relies on the
underlying Java platform so and that is
a pluggable framework so if you're on a
device that say has some hardware
encryption capability then you can if
there's a plugin for the JRE for that
then Java DB will benefit from that
automatically okay so we've actually a
little bit of code here so can you um
just tell us about what's on screen
absolutely so what this shows you how
you go about creating how simple it is
to go about creating a an encrypted Java
DB database and then reconnecting to it
later on all you have to do is add some
extra little attributes to the
connection URL you can see that there's
a secret password there in the
connection URL clearly you wouldn't hard
code that string in your application but
anyone who is bringing up in an
encrypted data store its familiar with
what they have to do to protect that
password yeah so actually getting a code
yeah an encrypted database really is
that easy it's that easy you just have
to add a couple extra bits to the URL
cool sure
are you going to cover later multi-user
or like any couple of offices connecting
to the same
we can we'll be talking about how how
Java DB fits into the system and we can
certainly cover multi-user during so if
you bear that in question in mind
yeah when playing a playlist ringtone
yeah when we get to the right slide so
what we wanted to do today was just to
run through a use case and talk about
how we would use Java DB to support that
this use case at least in outline so
think of you know a gateway system an
embedded system which is monitoring
monitoring controlling sensors and
devices around a campus so there's a lot
of a lot of information that you're
accumulating you want to be able to
process process that information
intelligently use it to make decisions
and process it and forward it to to
ascend for a location potentially you
know we have to generate alarms and
warnings and then ended up with
processed information rather than just a
big stream of sensor data so this is
kind of a you know this is where you
know this is kind of showing showing the
the overall architecture that that we're
talking about here so on the left-hand
side you can see a bunch of different
representations the different kinds of
sensor and control device and in some
cases then you don't want these devices
connecting directly to the back end in
other cases then those devices may not
physically be capable of connecting
directly to the back end so you need in
those in those circumstances you need
some sort of gateway or aggregator
system and Java embedded suite is really
targeted at that kind of system and Java
ME embedded is is the the the Oracle
Java product that would be targeted more
at the the edge devices over on
left hand side there excuse me I've been
into too much talking today I think so
Rick can you take us through talking
about the database schema and you know
it's kind of a first thing that you need
to think about when you're thinking
about using a database to store
information yeah absolutely so since
this is a full SQL database you have at
your disposal all the sorts of sequel
objects that you would expect in a real
database you have tables you have views
you have triggers who have constraints
you have functions you have procedures
you have user-defined types you in a
coming release we're going to have
user-defined aggregates not in this
first release of Jes and you have the
familiar SQL fine-grained access
controls that your from the you may be
familiar with the grant revoke and roll
management so that you can protect
certain operations or assign them to
particular users and limit the
privileges that you give to other users
okay
so the kind of information that you need
to store in this use case then is
obviously the data that you're receiving
if you want to you know secure access to
the system then you're going to need
some sort of you may want some sort of
credential store in your database it's
obviously are not the only way to do it
and then you know device metadata and
configuration is you know something else
that your application will need and as
mentioned then you can use access
control to partition these things and
grant access preferentially to to the
different kinds of information that
you're storing in the database so on to
some sequel Rick yeah yeah absolutely
so one thing to point out is that Java
DB comes with a very rich set of
built-in data types there's basically a
data type corresponding to each of the
Java primitive types with the except
the 8-bit byte data type in addition
there is there are a couple byte array
types there are large binary and large
character object types there are
date/time and timestamp types and as I
said before there are user defined type
so any Java type which extends which
implements Java IO serializable it can
be used as the type of a Java DB column
or function parameter okay so so what
we've got here then is is base you know
a simple table that you can use to store
the kind of information that you'd be
receiving from sensors and you know this
is this is kind of an example use case
that we put together just to show some
of the capabilities of Java dB so you've
got you know a timestamp field in here
waited the day to come from and what
information did you gather about that
location when you sampled it so often
you want to you want to persist Java
objects into a database obviously there
are you know object relational mapping
technologies you know GPA and hibernate
and we'll talk about those a little bit
later too but if you're just wanting to
if if you decide that that's overkill
for your embedded application and you
just want to you know simple way of
storing your objects into the database
then you know seems like you've got a
couple of options Rick sure you can
certainly flatten the objects yourself
and into rows which is of course if if
you think that you're ever going to need
to search or sift based on the fields
inside your object I recommend doing
that and I even recommend doing that if
you don't think you're ever gonna do
that because you may not think you're
going to do that in Rev one but you may
discover in rev3 you really want to do
that but if you truly don't need to ever
search or sort or query on the the
fields they're embedded inside your
object then you can just as long as the
object implements serializable you can
store it in a column now suppose you
have a very large object graph that you
want to store in a column and there's
maybe one or two little bits of
information squirreled away somewhere
inside that object graph that you think
you want to index on well in that case
you can use something which we call
generated columns in a generated column
is an expression that is run at insert
or update time which can be used to
pluck those indexable fields out of your
your your object graph and put them into
their own columns in the row that you
can then build indexes on and this will
cause your queries to run very fast even
though what you've got is essentially an
opaque object there in the column so see
you're kind of using using the you know
a column in the database is kind of a
cache a stuff out of the objects exactly
another way to look at it is that your
pre compiling your query results yep yep
okay so basically two options here key
value storage or flattening the object
into into different columns so moving on
to a sort of a JDBC topic you've got a
one class called statement that you can
use to just run some sequel there's
another class called preparedstatement
what's the difference between those
ratings well the importance of the
prepared statement is that it allows you
to to pre compile your query plans and
it basically what happens when you
prepare a statement Java DB compiles the
runtime form of the statement and puts
it in what we call the statement cache
and the key on the statement cache is
the statement text so once you've
compiled a statement and it's been it's
in letting in the cache then the process
of reusing that statement is really fast
because it's just a key lookup you
don't have to to recompile it and and we
highly recommend that you do this and
that you use prepared statements and if
you have variables that you that
distinguish your statements from one
another
use a prepared statement with a question
mark parameters and just before you
execute the statement plug the specific
values that you're interested in to
those question mark parameters well
we'll see an example doing that in a
moment so essentially what you're saying
is that you'll get better performance
and better memory usage absolutely if
you if you use prepared statements
instead of instead of plain statements
yep and as it says up there you'll also
get protection from sequel injection
attacks please know we don't have an
example of that but if you come up
afterwards we can we can write it out
for you yeah okay so on to some some
more code examples so we talked about
one one piece of using the database in
this application would be to just
accumulate sensor data so what we've
said here is that you know imagine that
we have a class that will just call
sensor snapshot and that gives you you
know is stuff that you just received
from somewhere somehow so as with most
you know most code that's going to do
anything with the database then this is
going to be able to throw a sequel
exception which you you either have to
swallow and deal with inside here or we
have have your methods throw that and
someone else deal with so and here we're
using a Java 7 feature here you know try
with resources so if you're not familiar
with that syntax then this you know
where we're actually allocating this
prepared statement here
and if the if there's an exception
thrown inside the try block then the the
Java compiler will automatically tidy up
this resource for us and it avoids us
having to actually explicitly code the
you know catch and the and closing down
this statement so it's a shorthand
that's kind of nice and you know
syntactic sugar that the compiler does
for you it can it could be remote if you
have if you introduced the right driver
into yeah yeah I mean it's Java embedded
suite is is is full is full embedded se
so in an embedded se is essentially
headless Java SE so you've got a full
JDBC implementation so any any JDBC
driver that works with se will will work
with with Java embedded suite so brick
can you um can you just take us through
the prepared statement sure there's it's
actually very simple everything that you
could possibly use as a variable has
been replaced in this statement with a
question mark parameter and then I think
on the next slide you're going to see
how you actually poke the specific
values into the statement that just
before you run it hmm so so based on
going back to the prepared statement
versus statement thing then it's
actually this string here that the
starts with insert and finishes with
this bunch of question marks that would
be the the cache Keitha that's right for
this for this statement so anytime that
you you know as long as it long as you
don't as long as still in the cache
anytime you prepare this Thaman you then
Java debugger just go back to the cache
and fetch it again that's right and
avoid you overhead exactly sure
right but every time you execute this
you will get the current the the sequel
interpreter inside Java DB will look up
the current timestamp and plug it into
that particular column in the table
that's right right think that the it is
the current timestamp at runtime not the
current timestamp at compile time okay
so yeah you referred to the next slide
so there you go okay so there you have
it you're using the the JDBC setter
methods to to just poke to poke your
sensor data into the question mark
parameters and then you execute the
statement very simple so anyone else
feel please feel free to ask questions
as we go along if you if you have any so
you can see here how how those question
marks in the prepared statement actually
get you know actually get to have real
data values associated with them so this
another of the things that you want to
be able to do on the gateway device is
to do some kind of processing of the
data and that doesn't necessarily have
to be Java code that you write because
you've got you know functions built into
the Java DB sequel implementation allow
you to do a whole bunch of things and
this the sequel statement in here is
actually these rows have be short but
it's actually a little bit subtle I'm
going to ask Rick sue to explain that
all right so what we've got here is a
kind of a gnarly query and the back
story behind this query is this so you
imagine in this application that your
sensors are waking up once a minute or
once a second or something and they are
sending their snap
snapshotting their state to the gateway
device so that goes into the the gateway
java DB database so the idea here is
that you don't want to send that whole
firehose of data to the to the server at
the at the end of the day what you want
to do is you want to boil it down you
want to aggregate it you want to
summarize it and come up with a single
row a single summary row an average row
over an entire hour for each room with
all of its sensor data so that's what
this does it's it an ingest uses the
standard SQL average aggregate to do
that to do that work so it's this is
what you get for free for having a full
relational database ion your gateway
yeah so it wouldn't be that hard to
write the Java code to look through all
this data
and group things into hours based on the
timestamp and whatever but you know even
so you can do it in one line of SQL yes
yeah and it will be done efficiently
because all of that aggregating is done
in the in the database where you can
take advantage of things like indexes
yeah yeah so you're not having to read
read every single row of your of your
table process it and then then end up
with the data you really wanted in the
first place yeah and so the you know
another way of looking at this is it's
going to run through internally you know
select all the rows where the timestamp
is between you know you'll stop here in
your in period and then it's going to
take those individual rows and say well
these five rows here all belong in the
same hour so we're going to group you
know group those together and run an
averaging function as described here
across the across the different columns
and then you end up with one row per
hour of in the result of this
so and then there's a slight you know
this is a little different in terms if
we go back to the previous code where
the previous example where we were doing
the insert then we saw you know setting
to you know give that assigned values to
the question marks in the update we're
doing something slightly different here
because we're actually doing a query not
an insert over to you Rick right and and
once again you've got another try with
resources block here so that eliminates
some some boilerplate that you don't
have to write when the when you're done
looping through the results that the the
Jerry will make sure that the result set
is closed and your resources are are
freed up so essentially what what
happens here is this what this while
loop will simply run through each of the
rows in the the come back as the result
of the query of the Select that you that
you ran and then you know this is this
is entirely made up code but you'll want
to do something with the result of the
query
so device metadata and and you know
preferences and you know configuration
for how you won't meet the application
to operate today that that kind of thing
by storing that in the database then
then you have the very easy ability to
change that and potentially even change
it remotely so we've got you know this
looks like an example of of key value
storage right absolutely
so I'm you frequently find when you're
writing a data rich application that you
need a table of odd bits odd little
configuration environmental facts about
your application about the device where
you're running and so just it's it's an
excellent pattern to create this this
very general key value pair table and in
this case that the table has got a key
which is a string and the value is a
user-defined type which is bound to Java
IO serializable so you can store
anything in that payload column
obviously a big idea to pay attention to
all the usual you know concerns about
making things serializable so that if
you end up having to change the classes
that you're serializing into the
database then you'll be able to unsee
realized you know old classes that are
you know that are pre-existing in the
database
so then reading stuff back that looks
pretty simple to that that's pretty
simple you're just reading everything
out of your your key value table and
well you're printing it out which is not
what you do in a real application but it
you can see how easy it is and there
again is your try with resources buck so
in this sort of contrived example then
we're actually just reading all the
metadata rather than looking for a
specific piece of information by by the
key sure
right that's a good question so now you
certainly can you don't in defining a
user-defined type you could bind it to a
more refined type than just serializable
and if you did that then yes and the
advantage of doing that is you will get
runtime type checking in this case of
what we've defined is is the most
general kind of payload possible just to
serializable
you probably define some you know
superclass in your in your application
and that kind of type safety is a good
thing
yep read object yet worlds
okay gonna move on from that if you
meant to delete that slide before we got
here be so I know we talked about the
fact that Java DB is kind of self you
know pretty much self configuring but
there are always going to be cases where
you do want to you need to set something
some non default thing for your
application so how do you do that right
so basically there there are a number if
Java DB's defaults turn out not to be
the right ones for you you can you can
customize those defaults by setting
system properties and you can use system
properties to customize things like
cache sizes and security settings as I
said those are you set those with system
properties you can store those system
properties in in a single tidy file or
you can you can store them in the
database itself and if you store them in
the database itself then you lock them
down which i think is a good design
pattern because that protects you from
people making mistakes
if someone boots your application with
the wrong command line and it also gives
you some considerable protection from
security exploits so basically you you
can figure this through a properties
file yeah and when you're done yep so
again pretty easy now I'm sure your code
is always correct first time Rick but
Tom you know when I was writing some
code recently then you know I had to do
some debugging so the fact that so in
the java DB that we ship as part of the
java embedded suite is using the
embedded JDBC driver right what yes
trying to explain what that means the
embedded you do use it
right so javi to me comes with two JDBC
drivers one is a driver which you use if
you're running the database inside the
same VM as the application okay
and in that usage mode there is very
little context switching when you go
between your application code and the
database engine so there's no process
switching there's no thread switching
it's really fast Java DB also comes with
a network JDBC driver although this is
not included in the Jazz bundle okay and
if you and then if you are running with
the JDBC client and the the Java DB
network server then you can connect from
multiple different machines to a single
database and and you have multiple
connections note that even when you're
running embedded this is a full
multi-user database so you can have
multiple multiple connections multiple
transactions all going on at the same
time and your concurrency is well it's
basically limited by your application
design your data design now I don't know
what it means to put that on top of
gesso I don't know whether that voids
your warranty but I don't think so okay
good so one of the things that I found I
was writing some code recently and you
know I the whole thing wasn't quite
working and I wasn't quite sure whether
it was my GlassFish configuration that
was wrong or whether it was my database
code that was wrong so I wanted to know
I got to the point where I just wanted
to know are we actually even touching
the database and so you know I found
that found that it's really easy to you
know to set up the the properties file
that you use for configuring page sizes
and things
and just by putting a line or two into
that properties file then you can ask
Java DB to tell you what queries it's
executing so you can actually tell that
it is executing queries you can it can
tell you about you know any exceptions
that are being thrown and things like
that and then I'm sure that as you
develop more complex applications than I
was developing recently then performance
can can be a become a concern absolutely
absolutely and one other point I want to
punch up on this slide is which I think
you touched on briefly is that if you
plug in your own code one of the cool
things about being an embedded job
database is that you will be using the
very same debugger on your application
code which is running outside the
database and on your functions your
procedures your types your aggregates
which are running inside the databases
so this is a very powerful programming
model and it makes you very productive
so you but you can also when it comes to
you know looking at how the database
itself is performing then you can you
can look at how you know how query plans
are being set up and the performance of
individual queries if you need to get to
that level of detail yep okay so I guess
the performance tip we really ought to
come from you as the the java DB expert
right and I think that at the end of the
slide deck you give a pointer to just to
some extra material on how to how to
fine tune your java DB performance so
they big first and foremost use prepared
statements use question mark parameters
bash your updates into transactions
don't commit after every row these
things things may seem kind of obvious
but it's worth pointing out it is it's
it's worth pointing out also that in in
there are applications which don't need
persistent data they just need train
data for instance if you're if you're
processing a firehose of sensor data it
may be that when you turn the devices
off you don't care that the day that the
the data goes away it's only while the
fire hose is going by that you're
interested in plucking information out
in making decision in that case you can
run Java DB purely in memory and this
gives you an extra performance booster
but you can also do this kind of dual
mode thing where you run the database in
memory and then periodically you you you
essentially copy that back out to a
persistent store and that's another
interesting design pattern absolutely
well that would youwould you or you're
at so you mean if you're running with an
in-memory database and then you want to
snapshot it to - to disk just before
your application exits yeah you you need
to adds a little scrap of code to make
that possible I think that at the end of
this slide deck there's a pointer to the
talk that dog gave earlier this week on
an introduction to Java DB and he shows
an example of how to do that of how to
snapshot your your in-memory database to
disk as your during application shutdown
and how to read it back in when your
application comes back up in that's
right
that's right and and you when you run in
this mode you just have to make sure
that in the event of a sudden cabin
depressurization you you you you know
what to do it you know if someone turns
off the device in the middle before
you've done an orderly shutdown you have
to have some way to your your
application has to tolerate a disaster
like them we don't have any built-in
checks for that you'd have to code that
in your application itself it's an
interesting feature that might be worth
them built building out for more support
yeah yeah but as far as as far as
implementing that based on what's there
today
then provided that you build that you
build the majority of code based around
a connection then it's really a question
of is that connection pointing at an
in-memory database or or a persistent
database right and then so
you could you could see yeah exactly
so even yeah so even without even
without any special functionality in the
database you can actually build your
application and you could put some logic
in there that could switch switch
connections out underneath based on oh
it's it's Wednesday I want to be
persistent or we have okay so there's
two whenever you talk about logging with
Java DB there's there's two logs to talk
about there's a transaction log which is
not what we're talking about here and
then there's a diagnostic log and the
diagnostic log is something that is well
it was it was developed fifteen years
ago before these other packages who are
out there now it is you can plug in your
own your own print stream to to control
where where the diagnostic log goes but
it doesn't use any of these packages
that you just mentioned although it's on
our it's right it's it's it's it's on
our radar screen yeah
yep yep and and and by implementing your
own print stream for for the for the
logging you can you can do that
filtering yourself within that stream
but your eye I hear what you're saying
about about the nice some filtering
features that are built into those
logging packages absolutely yep yep okay
so if you're ready to get started using
Java embedded suite then you can
download a an email copy from the Oracle
technical network it's been available
there since last week and there are a
bunch of places you know Oracle and
Apache where you can get more
information about both the embedded
suite and specifically about Java dB
and there is as Rick mentioned you know
there's a presentation online now that
dark here gave earlier in the week which
is a more basic introduction to to Java
DB and there's also a lot of information
there about you know where Java DB is is
is used that could give you some ideas
to please
to nature's own question for you we we
have been developing Java DB in the open
shoulder-to-shoulder with IBM since
ninety what 2005 and so far they the two
databases have been bit for a bit the
same we haven't needed to we resist the
urge to fork but we do have clearly we
have our own name Java DB and we reserve
the right in the future to to fork or to
add features to to an Oracle product
that would not be in the open-source
version but right now same bits ok well
that's the end of our presentation if
you've got any more questions then we'll
be happy to take those yeah the back
there
right so the question is do you have
access to the statement cache that's and
so that you could tweak the query plan I
believe that was the question there's
two answers to that question there's
always two answers to a question yes and
no so let's start with no you don't have
direct access to the statement cache but
by using certain procedures which set
the the database in a certain state you
are able to snapshot what the query
plans are and then when you understand
what the query plans are you can tweak
your queries not that not the plans
themselves while you live but you can
tweak the queries and you actually can
tweak the plans themselves using
something that we call optimizer
overrides did that answer your question
okay thank you other questions not quite
sure what you're asking
well you can always pre prepare your
statements yeah and so and that that
that's a design pattern that some people
follow so when your application comes up
it warms itself up before anybody
actually uses it and all of your
statements are prepared yeah but but we
don't provide you a way to pre prepare
the statements and store the compiled
forms in the database though the the the
people who worked in the in the the
sequel interpreter had a very bad
experience with that at a previous
database and so we avoided doing that
that is correct
you have to warm up the the database in
before you let your users in if you want
to get if you want the first preparation
of the query cannot incur the the tax of
compiling it but not for dramedy B in
Java DB triggers and procedures are
written in Java but once you but a
there's plenty of there's plenty of SQL
that you can include in a trigger by
itself but once your trigger calls the
database procedure then you're stepping
out into into Java code that you've
written yeah
other questions okay so um please accept
14 minutes of your life back from the
job invited sweetie</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>