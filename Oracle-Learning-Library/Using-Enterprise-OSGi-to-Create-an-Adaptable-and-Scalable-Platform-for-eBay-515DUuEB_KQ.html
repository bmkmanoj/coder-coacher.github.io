<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Using Enterprise OSGi to Create an Adaptable and Scalable Platform for eBay | Coder Coacher - Coaching Coders</title><meta content="Using Enterprise OSGi to Create an Adaptable and Scalable Platform for eBay - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Using Enterprise OSGi to Create an Adaptable and Scalable Platform for eBay</b></h2><h5 class="post__date">2013-01-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/515DUuEB_KQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so my name is sakura and i'm here with
kamal and Tony right in the front row to
talk about how we use a osgi based
platform to build like an extensible
platform and by extensible I think we
spend a good amount of time talking
about this adaptable scalable extensible
platform for the organization how it
solves our problems right so let's let
me just jump right in and go to the
agenda so I think the first part I'll
talk about is why we do this what are
the philosophies behind it what are the
problems we are trying to solve and then
quemado take you into the platform
itself how Raptor is done what kind of
assumptions we made with this platform
okay of course are an organization like
eBay that has got that has to release
software frequently very frequently
actually once every week less than once
every week for many cases the PLC is a
very important piece so Tony will talk
about DP DLC how we make network ok and
I'll come back and talk about our the
rest some logistics here I mean I try to
go through this a little fast and it's a
lot of high-level information feel free
to ask but please let us finish the
slides and i'll try to leave as much
time as possible for any questions and
if you still have further questions you
can catch me outside as well ok so jump
right into the problem ok so what is
eBay I don't have to tell you what oops
what the site is let me see now it's
just a connector here that's going wrong
ok so very clearly I hope everybody
knows ebay we are an e-commerce site ok
and the content that we surf is all
dynamic so you do something you put in
the URL twice you get different results
right you search for the same item two
times you will see new bidders
coming in new cell is coming in for that
same item and some other bids expire or
some items sort right so it's all very
dynamic the consumers are the uses of
our system is usually web browsers and
mobile devices but that doesn't preclude
things like Google BOTS that
occasionally jump in and crawl outside
so you have to deal with all that
scaling is massive we are talking about
thousands I'm I'm not sure we are
probably at the edge of thousands or
tens of thousands of servers at this
point okay billions of hits per day even
that single application has got a huge
number of hits okay and each of these
it's a small we have to respond to you
within a couple of milliseconds okay
because the internet takes your time if
you respond in 200 milliseconds it will
be probably be like a second or two
seconds until you see it on your browser
okay so performance latency is very very
critical and all our systems for
flexibility of allocation and
reallocation it they are all which lized
ebay as a site from the application
standard standpoint we are talking about
hundreds of applications you go into
ebay you go to the homepage you go
search for something your view that item
you'd go bid for that item okay or you
want to sell something these are all
actually different applications than by
different teams so how do we pull that
together and make ebay move as a side
while we do not stop ebay if we want to
change something is the challenge that
we are trying to solve you so agility we
roll out code all the time if you have
to wait for two weeks four weeks or
really cycle of six weeks to roll out
code ebay would be obsolete by then so
coat goes out all the time right we
based on that people cannot work with
systems that are really in their way how
do we build systems that are not in that
way I think that's that's the key issue
okay the systems should always help
people and not create more friction
two for developers to use so if your
developers come in or out their lungs
come in and say I one technology XYZ you
have to think about how can we make that
happen okay because probably that
technology is what solves the problem so
we cannot say okay we've got this thing
whatever it's called and you have to use
that for your problem no matter how hard
it is this is what you get that's no
longer the case right from the
complexity standpoint we are talking
about 40 50 million lines of code
roughly and also you know we hire people
hire developers all the time if you need
to spend three months training
developers to be productive in ebay we
have lost a lot of their time already so
the concept is you have to be productive
coming to ebay you have to be productive
on the first day which means the
technology has to be familiar you can
look at it outside okay you can apply
your knowledge that you have learned
outside in ebay and vice versa whatever
you learn in ebay you can go out and
applied outside as well right instead of
maintaining a huge stack of
documentation you should rather be able
to google for your answer right should
everything should be under internet
besides a couple of things that deal
with how we operate as a site disruption
is not really easy to deal with right we
cannot say okay our system is old let's
stop ebay and rebuild the system i'll
let not work on the old system for a
year two years and build a new system
that's a lot of what enterprises do
basically they have got their erp system
coming in and they use it for five years
ten years and then they say okay this
this thing is no longer workable so they
go hire somebody very expensive and
build a new thing in their purchase and
customize right so when you should make
these kind of changes if they are very
disruptive
you have to change the whole arc because
people are used to what they they were
working on you cannot just go and say
tomorrow the way you work is going to be
different let's work right so that's why
we be say okay since we have got so many
different units of work units of
development team each team can choose
what they want to use and they can
choose based on well we have to have a
portfolio we probably cannot form a
support standpoint support all the
technologies but also try to make it
very easy for people to say I have got
this kind of problem and this is the
framework that solves my problem the
best and yes you should be able to do
that okay so unfortunately these changes
that we are trying to do other people
try to do and non disruption is not
compatible and we are trying to make it
work philosophies real quick so anybody
in the jail world knows about things
like Jax is jax-ws for web services
spraying okay java ee i didn't list it
because joey is also a big umbrella of
so many frameworks players coming in we
have got skala based frameworks
javascript-based frameworks and you can
name it you know there's plenty of those
the problem is if I give you a framework
and I say you live with it right what is
your reaction so first of all use
message okay well if at it and then when
it doesn't quite work for you you will
start complaining if you need so much
code to make it work for you you'll come
complain more and at the end you'll say
no forget it okay so there are teams
that I like that too in the past so we
try to make things easy for the teams we
don't want two people to run into a
framework itís and you can read the
definition out here by yourself
frameworks am I on to mikes yeah so each
framework is designed for a certain use
case
right you use a most MVC frameworks they
fit very well with certain kind of pages
if you need a lot of interaction you
might want to go for frameworks like jsf
okay now also let's say you want to work
on mobile there might be certain
JavaScript frameworks that are good for
you certain other things might be in
your way so we don't want to define
which framework is good for you we want
to make sure that everything is working
for you that's that's whether the key
message here how do we choose no we
don't choose right we choose the minimum
and let me say what's the right choice
for you okay if we say go for ABC
whatever it is by the time we decide
that that framework is obsolete so I
teashops tend to do that we did that
mistake in the past as well this is our
Grand use framework that does everything
and then soon after that this grand use
framework is obsolete okay and now you
have to build swing all the power works
building yet another grand years
framework okay so we don't want to build
our own if you need to revamp that
that's going to be very costly right I
just want to put this quote out with joy
at your one I don't remove the year
probably in the mid-2000s said that
innovation it happens elsewhere so no
matter what we do no matter we put the
best engineers out there that will
always be better ideas somewhere else so
putting the whole knowledge into one
engineering team it's like putting
Europe all your eggs in one basket and
if that breaks to know what's happening
right so instead we decided to deal with
open source try to integrate open source
technologies and allow for integration
of open source technologies right and if
that's new open source technologies
coming in we can integrate those okay so
this area when we say minimal surface
area meaning that eBay
api's should be minimal you should be
able to learn that in a very short
amount of time okay and of course we
need to think about how we roll how we
allow people did to develop now and get
things onto the side by the end of the
day that is when we define agility that
includes all the Deaf cycle test QE
cycle quality cycle okay to getting out
on site so with that that's kind of good
lead into a raptor which is the solution
that we have come up with wrapped it is
more like I made a platform and I'll get
a Kemal to talk about wrapped in more
detail right
you
hi everyone so I'll get into the details
of Raptor so to summarize what acara was
pointing out it's like instead of a
frame of being a constrained environment
where it makes you to work within that
constraint a raptor is more of a
framework which allows you to be it's
like an enabler which enables to build
on top of it so that's a key philosophy
here instead of constraining yourself we
become the more they can enable which
enables you to do more so to go with
that again we cannot it is no one
framework which can satisfy everything
but we try to put effort that we can
suffice as much as possible so the
minimum assumptions what we took here is
we took some criterias the one of the
criteria was for our code where we had a
millions of lines of code in a
monolithic codebase the first thing was
to make it more modular so when you talk
about modularity the first thing comes
into mind is osgi so that's the first
thing which we brought up so we went and
our apt at osgi and on top of which we
are up to j2ee basically for all this
web applications and servlet AP ice for
doing web based applications and then we
thought about making our apps more
loosely coupled with in our code and
things like that so the dependency
injection is needed and obviously spring
was a choice and also one more thing is
spring not only comes with dependency
there's a lot of suit of things
available in spring like you have a 0 P
and things like that so we thought it
would be a good suit for people who want
to develop on top of it so being this
this is what is a basic the assumptions
so what it allows you to do is it allows
you to build any JVM based dynamic
languages on top of it at this point you
can have choices like you can bring
scalar extend or any spring based
application Grails on top of this
platform and you can build it as long as
they constrain to some of the minimum
things like it should be an osgi bundle
as long as it works within the
environment so as I told raptor platform
itself is more modular
it is divided into multiple smaller unit
the first thing is like in rapid is
called as a rapper corner which is a
core which is built on top of osgi
itself so one philosophy what we wanted
to adopt us we want to prevent
application developers to getting into
OS j AP ice so we want the code to be
more at a top level as an application
level instead of they're getting into
OHA api's and exploring into all the
osgi think so we act as a layer of
abstraction and we control a lot of
things so raptor kernel is a layer which
interacts with all the underlying
systems like interacting with osgi is a
like we use a extender pattern where we
talk to bundle listeners bundle trackers
so this is like a core layer which on
top of it all applications are built so
some of the key features of raptor
canales we use a osj extender model so
weaves a bundle tracker to track the
lifecycle events of the bundles so
whenever the bundle comes in and goes we
use some mechanisms to track this bundle
even and make some decisions based on it
so we are going to see what all in what
all areas we are using this and how we
benefit from that some other things
which is part of chorus initialization
you know any app which has to be running
needs something in during the
initialization so how do each of the
applications which contributes bundle
can define their own initialization and
how do we make sure that all these
initial happens in the right order to
make sure that everything comes up and
ready for serving the first request so
it reduces your first request time if
you take if you do a caching and
everything during the initialization
lifecycle management again it's about
how do you manage the bundle is how it
comes up how it goes down how do you
know that if a nap maybe consisting of
ten bundles how do we make sure that an
app is up and running only when after
all ten bundles are available that means
you need to have a knowledge of what has
to be initialized what is up under so
that's a lifecycle management so
operations support infrastructure is
like once you deploy your app how
operation is going to monitor this app
in order what always we can provide data
whether the app is running successfully
or is there any exceptions how do we
communicate it back so rapper Connell
provides a way of exposing all this data
to the operations for doing any any kind
of
validation of things like that pipeline
and the annular it is a similar to an
interceptor concept where you want a
request and you want a request to be
going through a kind of a pipeline where
you have multiple channels and your
bundle may want to do something for
example a simple thing is you want to
get your response gzip too far
compression so this could be one handler
in a pipeline so we have a mechanism
where you can inject your handlers for
any request or response and we can
process on the data so I'll talk about
that and osgi we use oj to figuring out
when the bundle comes up and when this
should be used and things like that so
case for is GI so a lot of people ask
why ohci so esseker I was pointing out
when you talk about a company enterprise
company the first thing you will see is
a monolithic codebase like the reason is
very simple because people wants
integrity like if you give it to
different people that if you divide a
code base into different modules it
requires discipline you need to know how
to give your dependencies how to version
things so there's a lot of challenges
which comes in with it but as well as
you have benefits so when you talk about
any code base which is monolithic which
is one single big bunch it's always a
problem so we wanted to go in a route
which is very a modular easier to deploy
applications independently and scale
them independently instead of creating
one big chunk of code so osgi is one
solution which gives you the modularity
aspect of it modularity is one aspect of
hrs lot many to that so one thing is
like I can given simple example there
are a lot of use cases one simple
example is let's say that we had a
functionality in the colonel colonel is
mostly interacts with the JVM so we are
an implementation and which is not
supposed to be exposed to the
application steam but since we were in a
non OS j world there is no way to
control that so what happened is people
who are using that implementation
somewhere in the code and once we change
the colonel implementation every app
broke the reason is very simple because
we were not able to encapsulate it you
know when abstract it in a way that
people don't use it because it was an
implementation detail so these are
things which were very clear like
unclear AP is there is no defined
boundaries and backward incompatibility
problem so because of this you need to
keep on maintaining the backward
incompatibility because people are not
going to breaking hundred halves not one
hundred ox is going to fix it so you are
going to go back and do something to
make it work so these are things which
gave away and we thought that OS j is a
solution to move towards and how is a
solves a problem so it gives you a
bundle lifetime dynamic nature run time
later where you can bring in bundles and
take out bundles during the run time it
gives you a dependency which is very
valid during the run time that means and
when two bundles comes up each bundle
should know what it depends on and also
what it can expose so that capability is
not available in the normal j2ee world
where any bundle can be fine hey I have
around 10 packages what i am going to
dis is I'm going to only expose the
interface packages and not the
implementation details so what this
allows us as a platform team you can
always go back and change the
implementation at your will instead of
breaking any app because the interfaces
are safe you can change your algorithms
you can change something you can improve
performance without breaking anybody
because nobody can access that piece of
code so it is not used by others and
then finally as I said it requires some
discipline and that's where semantic
versioning comes into play if you use
semantic versioning properly actually we
can solve a lot of issues which is
related to backward incompatibility the
way code gets dependencies are like Y or
things like that so this is a
granularity of modularity basically you
can see that how all you can modernize
your code if you talk about in a very
general architecture level people talk
about separating your services and your
UI it's basically front-end and back-end
so that's where your service
modularization comes into play and then
if you break an application itself its
consist of multiple modules so in j2ee
terms you called us jars jars are not
actually modules but still they act as
an boundary for the current code in osj
world we have a call as bundles because
it provides you another Briton mechanism
where you have other levels of
granularity like packages mi bundle can
consist of multiple packages and each
package can have multiple classes a
class is a more granular level that's
why osgi choose a little bit high
a level which is packages so you can
control your modularity at the packages
level so whenever you define a bundle as
owner of the bundle you are going to say
hey I have five packages should we
should i am going to expose all the file
or no I'm having three implementation I
do not want to expose all the 5 i'm
going to only expose the interfaces
which are in the two packages and
implementation is going to be hidden so
you have a control as a bundle owner to
say hey what is going to be exposed and
what is not going to be exposed and
similarly you need to define your in
dependencies I am going to say hey I
need these packages for my execution so
it is a very it defines a very clever
clear level of dependency thing which is
not available on the current system so
these are like some features what you
get by going into modularity so
currently Raptor has a platform on top
of this minimal assumption we provide
some capabilities so couple of them are
like we support spring MVC for
developing their baths which is
basically the view is a JSP we also
support jsf with limited capabilities
and then we have a jax-rs which is it
Josie we hover or we have a rapper /
Jersey which provides our infrastructure
things along with it future as I said we
want to be the enablers so that as long
as the platform is evolving and it
always provides a way for people to
bring in new technologies it's always a
possibility we can go to other things
for example we have already prototype
scale as extend and things like that so
it is nothing which stops you from going
on top of it so that is a key thing
which you want to bring a thief key
feature of Raptor so this are going into
details of what r after I talked about a
pipeline so what is a pipeline is all
about so the lot of things which you
don't want application developers to
deal with for example aspects right
normally you have something like
security logging things like that which
you don't want the application developer
to get into for each and every service
he writes or every web application right
so how do we manage these things so
whenever a request comes and how do you
make sure that the security level is
there for this particular request to
access this daughter ization part of it
how do you make sure that this request
gets logged what all is a payload of
this thing so these things can be
achieved by you
this methodology called pipeline it is a
very interceptor pattern like your
filters where you but it has more
flexibility where bundles can say that
high I need these handlers so as a
platform team we have a set of handless
like as a ebay as a company we need some
infrastructure some things which needs
to be by default like authentication
authorization logging all security
aspects but other than that there could
be any number of things what application
teams may want ad so they can have their
own handlers so which means that
whenever a request comes in it goes
through this pipeline and every handler
and that particular pipeline will be
executed before the request goes through
the actual application so in this way we
have a more easier way to control things
or if you want to do any processing like
we have a we can improve the performance
by doing a gzip on the response so the
payload gets wrestle on the response so
things like that and we use MVC on the
backend and also we use something like
cross contacts app so your app itself
runs in a different context and we
communicate through cross context so
infrastructure on demand this is nothing
but how we use osgi saw extend the
pattern so we use bundle tracker which
is a way to a synchronously monitor all
the lifecycle events of the bundle so we
have a mechanism in the kernel where it
tracks every bundle and we figure out
that for this particular bundle we look
into their manifest and if there are any
special headers we do some pressure is
passing like for example initialization
if a bundle wants to do initialization
they will write an initializer and they
will provide our editor which will
basically there in the kernel
understands and take into consideration
and we also have priorities and things
like the non that but the mechanism what
we are talking about is always
extensible so you can use it for
anything we use it for identifying
bundles which is exposing resources we
use it for a lot of purposes but the
pattern is same but the purpose would be
different so the some of the examples
are what models are getting initially
what all weather an app for example you
may have ten bundles for your half which
may depend on hundred things but how do
you make sure that your app is up and
running only after ten of them are
initially so all these things can be
controlled by this so
of the infrastructure thing is data
accessing so you need a layer for that
security logging tracking
experimentation it's like identifying
how many clicks happen all these things
can be done using this off I think for
example tracking is a mechanism to say
like for example in this page how many
people access this fit so you get the
data it's better like matrix all these
things are possible and it is all part
of the platform it is enabled by default
so apps need not do anything on top of
it so they can just control the
behaviors but it comes as a capability
so ebay is a service already BR and the
service based the strategy but with
Raptor one of the main philosophy is
that we wanted to separate all web
applications from accessing the database
so we want to have a clear separation
where services are going to be the sorry
so we want everything to be a service
and all the data access all things
should be motor service and web
application should perform what it
should perform so this was a strategy
which we are up too long that but with
Raptor we are enabling it a lot more and
also we are pushing people to go into
this architecture so that whenever they
develop an application they don't have
to do all this data access and
everything in the web application it
should be a service so that is a key
idea about it so this was one one way of
modularizing your whole code and as
occur i was finding out ebay is consist
of hundreds of apps if you go to ebay
homepage it's actually another it's a
actually a pool of missions which is
serving the request if you click on an
item what you see as a view item is
another pool of service which is
actually serving that request so
everything what you see in ebay are
loosely coupled applications which are
independently running on the node pools
which means that people can roll out
code and scale and accordingly instead
of waiting for somebody else to roll in
and things so it's not one single code
base running on one set of missions it's
a different application running in
isolated manner and communicating
through links and services so it means
that it then
this case what happens is if there is a
web application like view item and if
that view item is like it's a page where
you see the item in ebay they can a wall
on their own independently without
depending on edible at any other thing
as long as the platform provides all the
capabilities for the evolution so this
is a architectural layering of how ebay
is so we have an infrastructure layer
which takes care of all the
infrastructure like your cloud for
deployment and we have data sensors
compute basically network all the
infrastructure pieces and on top of it
we have a technology platform so this is
where you have all your key pieces like
your data access layer you're so us
frame work your presentation framework
messaging framework logging framework
all the infrastructure technologies
which is needed for any application to
build and on top of which we have
services so this is what I was talking
about the service strategy so everything
should be available as a service so when
I app comes in it's about orchestrating
the services together and bringing up a
vertical experience or any particular
app which you want to develop so
applications builds on services so as a
technology platform what we do is we
enable people to develop applications
faster and also his services oriented
company if you have everything as a
service the application is like a thin
layer which just orchestrates everything
together and gets a app as soon as
possible so it allows you to do a faster
p dlc prototyping or to an
experimentation in a faster manner
rather than on if you are going to do it
from scratch up it's very difficult so
the basic as i told in the first we want
to be the enablers so we are not
restricting people saying that hey if we
are choosing to our framework you can
use only a 0 ABC as long as it ideas to
ja base any dynamic language as long as
it is an osgi based thing we can always
choose your own framework and from a
supported list basically because I
cannot say hey you can go and run
node.js on this or as long as it is
supported yes but if it's entirely a
different platform we needed another
mechanism to accommodate it not with
what we have the current capability so
new apps always we so what the way we
are going for
Sakura was pointing we cannot go for a
disruptive change where we can say that
hey we are going to stop ebay today
totally whatever is there and we are
going to build on it it's not possible
because it's a huge effort if you are
going to do that so we need to do it in
phases so we need to start with moving
some apps first litter that if there's
an application which is has both the
codes together we need to separate out
the web app first and then we start
slowly migrating them creating services
and building on top of it so the idea is
that V&amp;amp;A any new app comes in will be
always starting in the new environment
and the old app still resides on the
other one and we slowly migrated them to
them as we have more services and
environments coming on so it's a mixed
environment where we have applications
running on the order framework which is
a monolithic code and we have
application which is running on the new
one which is a raptor which is basically
a very modular application with this I
handed over to Tony to talk about the
PDL city
you
okay so I think Camille and her eyes
talk to you a lot more on the technology
side sort of the platform right what
frameworks and how we support it anyway
HR way now I think the other part that
we actually spent I would argue equal
among of energy and efforts is really
how we kind of redo our application
lifecycle or PDL see right taking out
developers from just developing the code
and all the way to how that application
get role in production right and in
order really to have a really fast
turnaround for us we really need to
optimize that whole life cycle right so
that you know the goal that we really
have is that you know we have some new
hire coming in maybe they make a small
change in our app and how they can go
from there in the Eclipse IDE to
production right within an hour right so
that's all our work that we have done in
this area so this diagram kind of show
you some of the main stages that that we
have looked at throughout the whole you
know p dlc right so the developer part
you know kind of a camaro has talked to
you a lot about it like what technology
work frameworks we have we have a lot of
tooling around that as well to help the
0ffice be productive right on the
workshop control we have you know
actually make a switch right on in terms
of what SCM we are using so we're using
it as well as github in a way which we
felt you know ebay you know has a lot of
distributed teams actually and we felt
that you know we used to be using a much
more centralized type of source code
development kind of product and we felt
get this much more suited for kind of
more distributed dearmond and we call
our performance benefits all of that as
well and that's also so the social
aspect I think that we got from github
as well which we are in a ways to
experimenting but you know we kind of
see that you know could be some benefits
to sort of a large organization like
eBay in terms of how to share and be
aware of what other teams are doing okay
the register step here is really all
about okay you know because in anyway
right all your application in the end
to go on to some front and phrasing
right edge right something that can be
accessed by our end user right so you
know you know I'll company what happened
is when you you know do a new app way
okay you need to now host it somewhere
then you kind of have to submit some
tickets right some IT op scope is going
to like you know take their time to
create be lackluster for you and all
this stuff way so we we don't want that
at all right because you know as you
notice we have hundreds of applications
from different groups like if every time
we need to do a new app we have to go
through that multi-week kind of cycle
that that just doesn't work try to try
to get to work in one hour so we had
this tab which is a self-service tab and
essentially you register your
application you provide some metadata
like which team you are what kind of app
it is and we would we basically have our
machinery automation to essentially
start kick-start the creation of the
pool and I'll talk a little bit about
that you know environment that's sort of
our cloud environment that we have
developed at ebay to enable that okay we
are heavy usage is like I think many
companies right of C I you know is
Jenkins hustling so do bills there's a
lot of stuff that we do with that and we
try to automate a lot of that the
assembly step is really more about
taking all the aspects that we really
need and package it in a way so that the
same artifact can be used to deploy in
different environments in QA environment
the allman environment production
environment and can provide that
isolation so that you know we know that
that's sort of like a golden kind of
copy so that you know you know if
there's some changes in the element or
whatever that's not going to affect that
copy unless we explicitly kind of we
regenerate that golden image and unless
I we saw the deployment step that I
would talk about later so from a kind of
assembly point of view I guess so we
definitely use CI to do that right so to
us see I give us all our advantage one
is really the biggest part is really the
consistency part you know so you know
before sometimes but what might happen
is sometimes a developer's right would
build some library on their box and then
somehow they will check it into some
repo and eventually that were made out
to production
right but that you cannot lose that
consistency right there if it was this
bill using the Roman environment and
maybe you are you you might actually
have trouble rebuilding that artifact
later on right when there's some issue
that you need to fixed right so
essentially we enforce the fact that you
know all the artifacts that goes out to
QA or production a woman has to go
through the CI way that's really no
other way and also the sea I also do
more than just feel right we run all
kinds of tests on the artifacts as well
as some of the static analysis right
like Feinberg's we have unit test
coverage all this stuff right so all
those are built into the different
pipelines you know in our CI and we also
i think inject talk about it library
that you know before the the code would
go out the production we also insert the
humans that which is our QA essentially
you know has to officially blessed a
particular version and those would be
the only version that you can select to
roll out to production in terms of
actual artifacts that we deploy we have
the you know so we are osgi based right
so our application consists of typically
our number of osgi bundles right and and
then at the top level where we basically
have this enterprise bundle archive EBA
which essentially describe the top-level
bundles that are used by the particular
application okay and the other important
part is what we have which is a
configuration files and the key here is
really that we have built in in our
configuration mechanism so that we can
distinguish different environments so
that we don't have to rebuild our app
just to deploy to QA environment versus
a production environment because
sometimes your configuration might have
to change right when you're in this
different environment you have different
host name maybe your capacity is
different maybe you want to be actively
but you know because we build that in
the environment support into our
configuration mechanism so you don't
need to review anything right because
you can inherit that maybe your
production environment can inherit from
the QA environment or you can / I some
of those things and then
the last step is really you know to
generate you know take all these
artifacts and create this golden image
and as I mentioned all this this step
can only happen if we pass all the tests
that we deem necessary as well as having
the QA certification so this picture
really just solo explain a little bit on
the osgi bundle creation that we have so
we have kind of taken the approach where
we as you have have we actually try to
minimize the exposure osgi a little bit
from our end developers so you know we
kind of taken an approach where you know
out there feels very familiar with maven
and palm so we are start taking the
approach where we are generating the
osgi manifest actually from the palm
definition right with some of the power
plug in right so for the most part they
were opportunity to have some larger or
if you have a for the most part they are
almost kind of assembling the
application through palm dependencies
okay and then through those pound
dependency will generate the
corresponding osgi manifest right and
then we would actually store those
bundles into our maven repository right
so we are not directly using kind of the
osgi bundle we possibly etc right we are
still in a way relying on maven as
repository for our bundles okay now you
know in terms of you know how and and
this part is sort of the deployment part
right how we can enable our individual
teams right when they have a new idea
they only create an app how can we get
them to production as quick as possible
right so we have actually invested you
know in solid building multi-tenant
private cloud type of infrastructure in
a way I think that the key here is that
we really want to make this to be self
service ok so the Roman team actually
you know does not need to in a way try
to submit some tickets and wait for
multiple weeks in order to get the
cluster right they just go to a
self-service Paulo they can put in a few
parameters on you know how big the
needs to be which day is any day one and
we would we have done all work to kind
of optimate solid a web float is needed
to position this type of poo we actually
found the custer automatically for them
as well so we would like configure our
load balancers so that you know all the
machines will be put behind the lb and
then ten actually surf traffic alright
and we really just in a way try to make
it just like you know a lot of companies
using this you know external cloud type
of service we want to provide the same
kind of frictionless environment within
ebay okay in terms of scale you know we
you know we are actually leveraging the
cloud to position over tens of thousands
of vm today and and serving hundreds of
applications so it's a pretty large
scale and and we feel that you know this
internal cloud really have give us both
the agility right in terms of right from
an idea to production they can get their
Putin you know within an hour I saw at
the efficiency by kind of centralizing a
lot of these resources and virtualizing
them we fell we better efficiency than
every team just try to get their own
boxes right and try to configure them
right in the future we're also looking
at you know how we can do some of the
scaling part as well alright so today
the scaling is still done like you will
need to request right when you feel like
your application is reaching the
capacity you may you can go through this
self-service portal and say okay I need
to add a few more notes to my cluster
but we also looking at how can we
actually even do that automatically
right by looking at the traffic and and
be able also we remediate our machines
right when something goes wrong how can
we take out that note and replace it
with something so that you know it can
continue to function so that's sort of
the infrastructure part right so you get
your compute right but I think you know
for the office that's only part of the
equation right the next part is sort of
how we can help them to get the code to
this big cluster of machines right in a
very seamless way right so again we are
finding a self-service path here right
so there's no
like a central release team per se that
developers has to like you know tell
them I'll roll out some stuff to
production right so we are in a way and
powering out the element team right so
they can individual doin team can decide
when they want to roll out their
particular applications and you know as
long as the CI pipeline is all green
they can actually roll out a new version
right to the production right again
through a cell service type of machinery
but in order to do that we are chair the
building our intelligence right into our
deployment mechanism right for example
right it is not acceptable for ebay like
to roll out some the wish of a co we
take down that part of the site right
under maintenance in a updated code etc
right so we're actually building things
like rolling up great automatically so
our deployment knows how to take boxes
out of the rotation from the load
balancer right and do it only a small
chunk at a time right so that you don't
impact the overall capacity for the site
right and then you roll out the code and
then you put it back to live and so all
this is saw handle automatically right
the opportunity to worry about doing you
know this one step at a time we also
have what we call different kind of
rollout strategy so a lot of times what
happen is you know it's all maybe you
know some kind of big change in our code
so we don't want to just like roll out
to the whole production site right what
if there's some issues right so we have
ability to let's say let's roll out to
just like a couple of boxes and then
pause right there and just let this
summer run and bake maybe you know over
a couple of days and we observe like the
log and monitoring to see make
everything is good right before we
resume some of the overall rollout right
to to that right so there's different
kind of things that we do or or we can
do a be kind of rolled out so like we
direct half of the traffic to this new
version and maybe some to the 01 and see
how how that perform okay the other
important features we have is sort of
the fast rollback right so sometimes if
in the end something's there's some
issue with a new code we can actually
roll back very quickly by you know
having the older version on the boxes as
well so we just sort of flipped the
pointer in a way
a to the code base so that we can have a
very fast roll back okay and and in the
end I think what we truly end fast right
with this mechanism is that we have that
consistency of the code like versus the
many way where you know sometimes you
know when you have a really big cluster
that there's a lot of time what happen
is you might actually end up slightly
different versions of cool and different
cluster if you're not careful but with
with this automation I think we pretty
much ensure that we have this eventual
consistency of the code version even if
you're Custer is like several hundreds
notes across different data center and
this picture in wages is sort of a
summary of what I kind of mentioned
right so on the left is sort of the
packaging golden image units that we
have right so we talked about you know
the top part we have the applications
right at the osgi bundles the EBA etc we
have the configuration files and then we
also have the container as well as the
you know the Java Virtual Machine as
well right we really want to create this
isolated golden image so that it's not
going to be affected by the derailment
activity so we can repeat we have that
repeatability so that we know when we
deployed this department unit you know
it will be the one that we have blessed
and as I mentioned you know we can go to
different environments the same piece of
code go to different environments across
different data center and we have the
whole rolling upgrade type of management
our deployment and with that i'm going
to hand it back to accra
you
so summarizing I'll give you some look
back here we started this project on the
most complicated application and that I
think was a big plus and basically
tackling the the beast the most
difficult case first right only focus on
that use case and we actually resolved
all the issues in a reasonable amount of
time because of it is a big success as
the event live now they are a raptor is
serving a hundred percent of that
traffic on eBay at this point I'm okay I
think one of the things that causes us
to go through a lot of headaches is
different principles part okay basically
when we came up with new ideas we don't
say oh it has been done like this in the
past we say no that's not right this is
the way it should happen and we focus on
solving all these issues including all
the process issues okay on the other
hand the code because the OTB code was
also java-based you can kind of refactor
the code in some cases copy or even
repackage the code in some cases to make
use of what we had before right while we
are adopting the new technology well the
front end is changing a lot some of the
car business logic has been taken from
the old code that was kind of an
official challenges tooling is the
biggest challenge in osgi okay because
our GIS well it has been around for some
time but it is also fairly new so how do
we build how do we package all that come
out and tony has been talking about the
runtime is probably the easiest part but
it to leave hard to make it work
together and know how to resolve issues
you get some users exceptions users
errors container that's about to come up
how do you deal with that those are the
biggest challenges right osgi also
create certain constraints you cannot
just go and load classes dynamically
from somewhere you don't know okay so we
have to care for that that that was one
of the at the challenges okay the
project was involving not only the
container but also the whole PDL see the
whole build system the whole packaging
system so all of those were very complex
systems and I'm really glad that we got
here in the way vbr and soft most of
those issues if not all of those issues
by now okay so this is another big issue
once we went to production with this new
service oriented architecture you think
that services are like method calls like
you go to a service and it is response
well the dead bug is unreliable so you
have to say that services are unreliable
to and not too many application
developers know how to write code to
deal with services so we are still
facing that challenge at this point and
we have our roadmap how to solve that
but I think that's the biggest learning
curve that we went through as well as
how to deal with services and how to
solve that in a way that application
developers don't have to come back and
say how do I write code to do to deal
with this you know right and the sauce
space it was a model it before Raptor so
we start to untangle but not everything
is untangled yet right the developers
tend to not think much about modularity
they say oh I need this quote from that
place you just go and grab that code
they don't think about is that the right
place to grab in the recent cases they
went to another application and say I'm
pulling in that code that bundle from
another application they don't know that
that bundle has got a 100 more
dependencies okay so training that and
dealing with it is going to be a
challenge we are talking about many
hundreds of bundles in this case right
still I still consider this project to
take us the way we want to go and we
have to a separate movement of the old
code to the modular code rather started
on the front end so one of the customer
facing apps took the traffic first but
also we are moving Raptor to the service
layer in the back end right there
basically we talked
mostly for the further up there will be
rest services to the back end okay we
need better instrumentation better
tracing so when a request comes in and
goes true makes the service call that
service call makes another service call
and finally arrives at some persistent
business store right how do you trace
these calls from one environment to the
other environment say that oh the time
the the car took too long so the time
was spent at this layer at this place
right we need to build all that coupling
the tracing billion together so that is
still work in progress we have got a lot
done where we can say we can identify
the bottlenecks at this point but we can
not dynamically change this so that's
really the next step we dated our
instrumentation part okay and that's
pretty much it let me just try to go to
the summary so certainly I think we made
this happen we made osgi happen with all
the odds that came against it but I
think ebay as a whole benefited from
that and I hope that a lot of people who
are going this path also would benefit
it's a pain before you start to see the
benefits but I hope you will see the
benefits okay so from the osgi from
services from proud okay and I think PDL
see we had to revamp the whole PDL see
in the past it was rolled out as pretty
much one chunk to the whole of ebay so
you can you would know how that release
management looked like okay just think
about that right so what do we get as a
result of this is our ability to move
forward to adopt new frameworks and
actually come a lewd it a little bit
about java based or jbm based frameworks
we are also dealing with non JPM based
print books and dealing with it from the
Raptor platform using osgi to understand
the dependencies and figuring out what
has to come together in order to serve
that application right last night we
took from open source
okay we take all these pieces from open
source we are looking at the problems of
all these frameworks input open source
and we are actively contributing back to
open potent source on those fronts you
might not see an ebay label you might
see that the committee or the
contributor of that code was be be right
there is also some other effort going on
that we are talking about EB open source
that arc which is saying any invention
any open source project that started
from inside ebay this is the outlet
where we make our technology that we
invented inside PP available so these
are two different two separate ways one
is already existing project we make use
of them we contribute our findings and
our improvements back the other one is
we contribute new things and we hope
that you can also enjoy part of that in
the community all right and with that
I'm just closing this and yes please rap
to it well how many people is very hard
to tell the Raptor car team was probably
about six seven people only but from the
PDL seaside from the build site from the
developer experience side all together i
think it was at least about 30 to 40
people okay yeah we started this journey
formalized it in January of 2010 and our
code ment life in October actually that
year yeah about 10 months to get the
first piece of code life and then
another yes and then another six months
or so to get the first application
full-scale right
we are looking into that router itself
because our Raptor is a meta framework
if you think about it right so it has
this pack ability of ebay components in
order to make that book and sauce we
have to make the component framework
that goes underneath the pipeline
handler that everything that goes with
it open source we are looking at it I
cannot come into it at this point okay
but hearts yes exactly and parts of it
is coming out on here all right ah just
please actually it's reality right now
we do for certain applications right
actually no we for most applications not
every application meet compliance
another part of ebay paypal has got a
lot more compliance and they have to
move slower but if you are talking about
pages that like homepage of you item
page that are non critical non-critical
in the sense that are and not say it go
down could never go down ok because
every bit looks at it but in terms of
compliance there's no money you are
paying on that you just view the page
and then you jump to another application
to pay for it ok that doesn't it
compliance right there's a selection
criteria and it is also a whole slew of
automation that happens so that it lays
socks if you are familiar with socks and
we have our ticketing system which is
invoked automatically in this process ok
so a lot of the compliance pieces are
already automated that is applying to
the whole of ebay anything that's
specific to applications are due with
money for instance ok dad they have to
do decomposed by themselves people go
and create an app in a couple of days
you can put it out and see what is the
response and they turn that they can see
how can we say for we have
lingual ebay Clarence very put things
which is like why notify users and if
things are good they needed connection
so cal tronica faster prototyping and
flying it about your far you want me to
go over just i'll get you actually did
this nice to be online sorry yeah we
have configuration right so your
computation particular so we have
written a packaging mechanism where it
packages code and constellations
separated and the configuration itself
is basically for all n months so we have
to a reproduction reproduction whatever
environments will have confirmation on
that and the code is the same we don't
change the port for different up so when
we build a deployable unit itself it
contains everything so that means the
deployment mechanism knows that you are
deploying in 2q it so to do this fewer
complications when you deploy two
products and it is just for example i
think you further just before
no all right back there yes the
continued service Equinox here right the
server integrates so we use at your
honor mode 3 a pre-production of
pre-release the autumn or three at this
point and we are moving to the released
one back here yes publishing those we
are we are still working on that right
for development we use their oh yes it's
all ours yes</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>