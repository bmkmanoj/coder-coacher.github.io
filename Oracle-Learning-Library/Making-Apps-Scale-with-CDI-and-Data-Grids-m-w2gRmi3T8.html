<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Making Apps Scale with CDI and Data Grids | Coder Coacher - Coaching Coders</title><meta content="Making Apps Scale with CDI and Data Grids - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Making Apps Scale with CDI and Data Grids</b></h2><h5 class="post__date">2013-02-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/m-w2gRmi3T8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm basically going to show you how easy
it is to make applications scale using
using a datagrid and for the sake of
argument I'm going to use a web
application today keep in mind are not a
web application developer I'm not a web
app guy but I'm still going to do it
just me just to just to have a bit of
fun right I'm specifically going to use
CDI our people here are aware of CDI do
people here know what CD is yeah lots of
nods good good I'll talk about a little
bit anyway as we go on and primarily
this talk is about like I said building
a web app I'm making it scale using a
datagrid now we all know that data grids
are good to help things scale out but
you need to use specific api's you need
to know what you're doing it's it's not
that easy for your average web developer
what I'm trying to show is that it can
actually be kind of easy in certain
cases on quite a few cases anyway so
it's not specifically a datagrid talk
I'm not going to talk too much about
these great someone introduced it with a
little bit i'm going to talk about why
they're good for a scalability in a very
very high level but if you do have any
questions about data grids in in depth
as well we can always feel that at the
end okay so just get things going is
that on as well a little bit about me my
name is Malik certainiy I am an
architect at jboss Red Hat's
middleweight division I'm on the expert
group of Jace or 107 and Jace are 347
who's heard of these 2 j's ours any
hands who actually cares about them
who's interested in them they
interesting useful kind of boring no one
cares about the JCP anyway no now
they're very very good things trust me
and if you're not involved you should
get involved they'll leave some URLs at
the end we can learn more about them I'm
also the founder of infinite span which
is an open-source datagrid who's heard
of infinite span here he hands ok I mean
for those of you who haven't I will talk
a little bit about it as well to
introduce you guys to it there's the
details of my blog and twitter feed if
anyone's interested and we've also got a
book on in finished plan if anyone is
interested it's down to the redhead
booth come down there if you're lucky
you might give you a copy all right
so CDI getting started a few hands went
up that you are familiar with CD are you
know what CD I is for those of you who
don't know what it is it is a very
standards based programming model you
might say to standardized form of spring
that's easiest way I have ever been able
to describe it it is an injection
framework it wires up applications
together it makes things very testable
clean and easy to build applications now
the good thing with CDI is it is a part
of java ee 6 which means that everything
you have everything you need to build a
CDI application already exists in a java
ee 6 server you don't need any
additional libraries any additional
dependencies you get essentially a DI
framework that is typesafe standardized
portable etc lots of good things right
in some ways it's the preferred way of
building any java ee app today that that
logo is is a little weld weld is a
reference implementation of op CDI the
next thing I'm going to do when I build
this web app here is I'm going to use
something called awry now a lot of you
may not have heard of air I may be a few
gaps yeah it's a funny name I know any
hands over I ok a few people see not
that many there i is is a rich client
framework it is it's essentially ee 6 in
your browser it rhymes builds on top of
on top of GWT so you end up writing java
code right object-oriented java code
which is then compiled into javascript
and runs in your browser the reason why
i'm using awry in this particular demo a
couple of reasons one is it is
compatible with CDI so you have all the
CDI annotations on top of arrive which
makes it very easy very clean to use the
second thing is awry is the javascript
effectively a javascript framework it
does generate javascript like i said so
i'm going to use it to generate a lot of
data a lot of interaction between your
browser hand you back end right so
without using i mean i could use long
polling I could use web sockets I could
use 200 different things out there but
it's a pain in the ass to sit and write
all that makes it all very easy to do
right
the next thing I want to talk about
infinite span I mentioned very briefly
again it's a distributed in-memory data
grid it is open source it's been around
for a long time now for a few years
pretty active very active community
actually of everything from developers
and users OEMs people who are extending
it embedding it doing all sorts of cool
things with it right so so pretty pretty
popular project out there it is often
used as a no sequel key value store as a
database replacement it's also used in
front of a regular database as a
performance-enhancing mechanism as as a
cash either a standalone cash or a
distributed cache things like that so
how are we doing so far introduced three
projects here well happy with that I
mean I will go into more detail of any
one of them if you want me to later on
yeah but for now that's a very quick
intro to the three projects change gears
I'm going to talk about scalability who
who's ever had that problem before I'm
not talking about being tied to a cart
or anything here but you know oh you
have okay I feel sorry for you man okay
now essentially right you try and make a
system scale you try and overload it and
then it all comes to a grinding halt
right we've all seen this problem before
we know how it works and and building
things to skills you need to think about
that right from the start now why why is
scalability so important today well we
live in a world where everything is
always on right internet access is
relatively cheap it's globally available
everything from the rise of machines
people using mobile devices all the time
fast growing middle classes and some of
the most populous countries in the world
all basically points to one thing people
are always using any any of your
services all the time right you don't
you can't afford to have downtime you
can't predict spikes sometimes and you
need to be able to scale out on demand
so very very important things in
business today a part of the driver for
this again is also cloud because cloud
servers are very easy to to well
provision and then scale outwards one
most apps do that now just because you
can
because you can skate out and do you
would do with additional load and all
that you have to do that but it means
your application needs to do with it as
well just having the infrastructure
isn't enough just having servers that
scale out isn't enough you need to build
your app to take to make use of that so
before I go into more detail again a few
a few thoughts and scalability in
general I just want to kind of step back
are people familiar with the term
horizontal and vertical scalability yeah
okay so essentially i am talking about
horizontal scalability here vertical
scalability is essentially getting a
bigger machine that's what it means if
you need more processing power if you
need more capacity you just buy a bigger
machine now that works to a point until
you get to a limit where you can't get a
bigger machine you got the biggest
machine on the planet already or what
else can you do right also that's a very
expensive approach I mean big machines
are very very expensive compared to
cheap commodity hardware and horizontal
scalability is all about adding more
cheap commodity hardware into a cluster
and getting an aggregate amount of
capacity or processing power right so we
all know the terms are familiar with
that I'm specifically talking about
horizontal scalability in in this in
this talk now one of the other aspects
of horizontal scalability is the ability
to scale back in as well the scaling out
is one thing getting a you know getting
more capacity is one thing but what if
you don't use anymore if you're dealing
with an application that's very spiky
that's got lots of lots of peaks and
then troughs you don't really want to
have everything running all the time you
want to be able to scale back down again
and save costs right so again again that
that's an important consideration so
what prevents us from from scaling
outwards usually what's a real challenge
here usually it is data storage right
scaling out for processing power is
relatively easy if you want to have more
cpus or more cause it's gone to ec2 and
fire up spin up some more nodes your
load balancer will take care of it
you're fine it's not that hard right the
hard part is actually dealing with data
storage dealing with some form of
persistence now most useful apps store
data right who's got an app out there it
does not store any data it does not
persistent it at all right nobody right
so I mean anything useful you're doing
is going to store data at some point
whether it's whether its long-term
persistent data in a database or
something whether it's transient session
data useful storing stuff you're still
maintaining state right and that's the
hard part that's a difficult thing to
scale especially maintaining consistency
and everything else now the traditional
way of storing data and applications
have always been the database I'm the
relational database it's been around for
a long time we know how to use it we're
familiar with it the problem with the
relational database though is is that it
acts as a single point of failure
firstly but it's also a very big
bottleneck you can't scale out a
database very easily horizontal
scalability and database is very hard
mainly because the relational model
around it around how you organize and
structure your data now some some
databases have attempted to do it some
have succeeded to some degree but
achieving true scalability with the
database is very very difficult nigh on
impossible this is kind of where no
sequel comes in a lot of the no sequel
engines you see the no sequel storage
engines you see have been built to try
and solve that problem to try and solve
the problem of horizontal scalability
and the way they've achieved it they're
looking very various techniques around
that in some cases you loosen up the
structure of your data right you use
things like documents or simple key
value stores so it's not as complex as a
full relational database your data's
more loose if you will it makes it
easier to scale outwards the other thing
is consistency models and this again
helps you scale out but it means that
your data may be well the correct term
is eventually consistent but it means
your application needs to be aware of
that and its people to deal with that so
again makes things a bit more
complicated data grids again another
very good option when it comes to
scalability and the reason why data
grids are actually interesting is
because they work both as a no sequel
key value store but also as something to
sit in front of a database as it's in
front of a traditional database or even
a traditional or not traditional but a
no sequel store to to act as a
performance boost so I'm going to talk a
little bit about data grids here what
are they really I kind of look at data
grids as
Lucien of a distributed cache all right
we're all familiar with caches it's a
useful pattern we all know about to try
and remove bottlenecks right you want to
see what you feel if you're doing an
expensive operation or hitting an
expensive database to retrieve data all
the time you can scale your reads by
caching stuff in memory right quite easy
not that easy you also need to think
about whether the data is stale and the
data expires you want to clean it up
what if your application is
transactional you need to be able to
make sure that fits within your
transactional scope what about warm
starts if you want to preload a cash
again more complexity right it's not
that simple but the hardest part with
with a simple cash is is that the moment
you start distributing your application
like I said scaling out is easy for
processing power spin up a few more easy
two nodes you're good to go stick that
in your load balancer you're good to go
but your caches need to be aware that
you're running in a distributed manner
you need to go to invalidate things that
other servers are changing if you don't
do that you're going to have a lot of
inconsistency in your data and that's
bad for most cases right right so that
that's where distributed cache has come
in now data grids are a step beyond
distributed caches there is step beyond
in the sense that it's not just a simple
put and get and remove API that's not
all you do with the data grid you can do
other stuff as well you can do other
stuff like you can query a datagrid you
can write filters you can do things like
mapreduce against your data which is
again very useful things when you're
thinking about a distributed environment
why is that because the most expensive
thing in a distributed environment is
the network is making that work calls to
try and find your data and retrieve data
from across the network right so it is
cheaper sometimes to push your
operations or your computation logic
into the grid and just pull back a
result that often works really well and
then this is one of the one of the
patterns that datagrid is tend to do now
one of the other things with data grids
is they are distributed by nature right
the distributed data grids are clustered
by nature so you get a few things free a
few pretty cool things for free like
elasticity you can actually scale out
and back in it's built that way that's
the means designed you can you have you
have fault tolerance again high
availability again for
free because you have many nodes in a
datagrid if some nodes were to fail
that's not a problem you would not have
lost any date so you can still continue
running your application and so on and
so forth ok how we doing so far on
boring theory of data grids yeah ok
everyone happy so I'm not going to talk
a little bit about standards as well
before I continue on um a few hands went
up when I mentioned these these Jace
ours earlier I think they're both very
important j-stars the first one now is
is scheduled to be in java ee 7 so Jace
are 107 now it's about time we had a
standardized caching API for java i mean
we've been everyone's been using caching
a lot but there is no standard way of
doing it which is kind of crappy and at
last we've got a standard way of doing
it and hopefully that's going to make it
into ee 7 that's going to help with
scalability a lot 347 is a fairly new
Jace are under speculate on 347 we're
talking about trying to standardize data
grid API is not just simple cash api's
here we are talking about things like
standardizing the way you do MapReduce
the way you write queries against a grid
the way you would do two operations
asynchronous operations and futures
eventual consistency all of that and
this is all really useful again for
young I mean a lot of datagrid vendors
do this stuff anyway they all
implemented any radius do it in a very
non standard in proprietary manner
having standard API is always a good
thing for portability and everything
else right now who here does not like
standardization good
that that little slide there that that's
by the smart people at Gartner they talk
about how data grids are really
important in the enterprise essentially
by 2014 at least forty percent of large
organizations will have deployed one or
more in-memory data grids the reason why
purely because of scalability you need
to be able to scale data grids are
probably one of the best tools out there
to help you do that okay how we doing so
far well good now all that was a boring
stuff right that's the introductory
stuff about kind of setting the scenes
DD believe the land if you will I'm
actually here to to show you guys how we
build a web app and how we then make
this web app scale right what I am going
to do like I said I've talked about how
scalability and high availability is
very important I've talked about how
data grids can help you achieve this
talk a little bit about CDI but now
specifically i'm going to show you how
using a data grid in CDI is very very
easy it's a fairly contrived web app
unfortunately like i said i'm not a web
app developer usually this is
essentially a very trivial app that's
going to read stock prices from
typically a rest service or something or
database essentially on expensive data
source right and this web app is going
to render this in a web page using awry
and you can then go type in a stock
symbol it's going to give you stock
price and it's going to update that
periodically by pushing updates into
your browser and this is where i'm using
awry again to create that connection
between browser and server without
writing too much code and you're going
to wire it all together using CDI
alright so let's switch to my ide and my
eye watering the painful color scheme
can you guys see that is that all right
that make your eyes bleed no okay
essentially what i'm doing is yeah so
this is an application entry point it is
it is a GWT based application writer I
is GWT based
as I said about people here familiar
with GWT yeah okay good that's more than
me because I actually am not familiar
with GWT but anyway I've created a page
here with label a button at Xbox dot
this is where I build the UI I put it
all together and they got a couple of
horizontal panels I'm adding the UI
components there and i've added an event
here whenever I click a button to submit
a stock symbol that I'm interested in it
ends up firing an event now this bit
here this is a little bit of a little
bit of CDI going on I'll show you in a
second the first thing is I've got this
stock type it's a very simple being here
it just basically is a wrapper around a
string right a stock symbol nothing
nothing too complex going on here the
one interesting thing i do want to point
out is I've annotated this as portable
that's a little bit of a rye going on
there what portable basically means is
it's a bit like saying implements
serializable or something like that it
basically means that that object can be
marshaled now the difference between
just using serializable and using this
air I annotation at portable is that
that portable means that that can be
serialize both in Java and in JavaScript
and that beam is going to be
automatically translated into JavaScript
and going to run in your browser as well
right so that the the javascript is
running in your browser has access to
this beam as well and is able to have
all the rich functionality around that
so you can do some really cool stuff
with arai that way yet there you go
let's see the importer therefore at
portable so that's an arai annotation
the next the next class of there that's
that's response that's the response that
I get back every time I submit something
to the server I'm going to get a quote
which is a price i'm using a string here
instead of a float just because I'm
formatting it on the back end before i
submit it to the browser so this way i
can do my number format and things like
that
like I could pass in a float as well and
do the formatting of the front end but
that just makes a code a bit more clunky
again very simple being nothing clever
here this is portable as well because
this again is is going to run in a
browser as well and I've marked it at
conversational which means that this
lasts for the entire duration of my
session it's actually not an entire
session but until I change this this
symbol again that means going to exist
okay we're so go back to the app over
here I've attached a handler here to to
the button that I've got so every time I
click I click the button on my webpage
it's going to fire this event fire
message and essentially I'm just taking
the the text that's been sent back so
this is this seems a bit like
request-response something real familiar
with but it's not really it's you might
say an evolution of that every time I
see a response from the back end I'm
going to basically update the label on
my front end on the browser now this is
a CDI annotation here at observes it
basically says that every time I get a
new response from the back end I'm going
to update a label in my front end the
server can send many response to does
not have to send one it's not a request
response sort of style even though i've
called it responds what it really is is
the server doing making a change to your
session to your conversation and then
your browser knows about the changes and
can update stuff right that's pretty
much it the rest is just boilerplate
over there which one observes this
basically is that that that event is
fired every time there's a change to the
response type within that conversation
so every time another component makes a
change to that response type which is a
part of your conversation that method is
going to fire now the interesting thing
here is i mean this is a standard CD I
annotation it runs within within a CD I
container
so two different components in the back
end would would communicate this way but
this particular case this is interesting
because we're actually looking at a GWT
application here this is actually
JavaScript this all gets compiled to
JavaScript runs in your browser so your
browser now as a part of that CD I
conversation with the back end which is
what's really cool and as far as the
code is concerned this just looks like
bog-standard CDI there's no it doesn't
look any anything more complex than that
um let me actually show you this as well
oh then what I was actually going to
show you the various parts that are
compiled to JavaScript but anyway okay
so this is the actual application here
what you just saw was the JavaScript
application the the GWT application that
runs in your browser this is the backend
component over here the simple CDI
service I've called the simple CDI
service I've made this application
scoped which means that only one of
these is going to exist for the entire
lifespan of the application I could make
a conversation scoped if I want to store
state about a particular conversation I
could make it session scoped I could do
a lot of things with it but in this case
like ice it's a very simple contrived
example so this is just going to be
application scoped what i'm doing here
is i'm injecting well i'm setting myself
up with an event here now with this
event i can now make changes to it and
anyone observing that event is going to
get notified of changes so this is the
apt observes that you saw in in the GWT
application right so that's observing
that event there now I've got a handle
message method here and that observes
the stock symbol now this is this is the
same thing happening the other direction
so whenever the GWT app changes the
stock symbol it notifies this back-end
saying the this conversation is now
interested in a different symbol go and
do something else so that Meg fires I've
got a simple bit of logging over there
tell me what I'm looking for now what
I'm specifically going to do here like I
said it's really contrived example but I
wanted to be able to push prices to the
browser of whatever symbols someone's
interested in
and I also want to be able to update
that periodically in this case my update
frequency I've set it to one second
that's a thousand milliseconds over
there and I'm using an executor service
here to schedule this in fixed rate to
to fire a response to the browser every
second with an updated price right so
very simple way of having browser server
communication here the actual method of
the hair yeah so I'm calling this method
get quote to actually get an updated
price for that for that given symbol I'm
going to fire that event so let's have a
quick look at get quote I've not
actually implemented this as the rest
service could've I didn't really want to
trust the internet connection here so
instead it's just going to generate a
random number and push that up to the
browser right now use your imagination
again imagine this a very expensive
method it's doing a lot of hard work
there it's not really assess generating
a random number but you know right it
could be a rest call it could be a
database called whatever right and that
is pretty much it so let's have a quick
look and see what this looks like I'm
going to build that yeah it's kind of
tiny but essentially all it's doing is
I'm just doing I'm even installing I'm
copying the war file into jboss to
deploy it that's really all I'm doing
and well that builds let's hope that
does not download the internet we're
good to go okay now this is my jboss a7
directory i'm running 711 final here i'm
just going to start up my app server now
just like any other java ee 6 compliant
webs app server all the CDI components
that I need already exists in jboss so I
don't need to have any extra jars and so
if I show you the pom file i'm using
it's all provided basically that marked
everything is provided so it's good down
to my browser now zoom in on that a wee
bit that was a previous run okay there
you go whoops GWT there's not like
zooming can you believe that
let's try and get a quote on something
and there we go whoops what's going on
there something's not being wired
properly
there we go right so it is generating
random data like I said pushing it out
to the browser and and again like I said
use your imagination imagine that's a
very long complex expensive operation
that's going on right so let's stop this
for now let's head back there so that's
kind of what we've seen so far basic web
app right very simple kind of contrived
but you kind of get the idea right right
so what have you actually achieved I
mean does that does that app scale does
anyone think that I full-scale not
really right I mean those rest calls are
slow how do you deal with that how do
you want you don't want to do that every
time also when it comes to clustering
how are you going to deal with that as
well the more servers you have the more
clients you have you just go to saturate
and overload your wrist server or a
database or whatever right so very very
expensive not very scalable so what can
we do about that now we can we can try
and cash the quantity the results of
that look up to that rest service right
that's an easy way to do it we can add
some exploration around it to make sure
whatever we cash does not live forever
we want to invalidate it after a certain
period of time and then go and fetch a
new copy from from the service we want
to make sure it's cluster aware so if
you want to scale our app out and deploy
it more app servers in front of a load
balancer we want to make sure if any one
node was to invalidate that data
everyone knows it's invalidated right
what keep things consistent and coherent
so we all know how to do this this is
all stuff that we've done before but it
was in it involves quite a bit of code
right and was writing quite a lot of
extra code trivial code granted but
still a lot of stuff and especially if
your your application is anything more
complex than my trivial app here you're
actually doing a lot of things in your
caching a lot of things everywhere
you're writing a lot of boilerplate code
which is a real pain sometimes but it's
not really it doesn't have to be that
way and this is what I want to
demonstrate now using CDI the
annotations i'm going to show you here
are all the part of Jace or 107 there's
nothing proprietary nothing specific to
infinite span i'm going to use infinite
span in this particular case but but the
annotations themselves are all standard
non-standard annotations okay so how
many lines of code do you think I'm
going to need now to do everything from
making this cluster we're storing stuff
in a cache the first time I look at it
and then and then retrieving it from the
cache subsequently adding exploration as
well to make sure things I've got an
about a one minute oh sorry one second
update frequency there so I want to make
sure nothing lives in that cache of more
than a minute right how many lines of
code do you think I'm going to need how
about one actually no I'm not yeah you
think all the configuration that's a bit
more but yeah essentially what i want to
do is it is as simple as saying i'm
going to that method that's going to get
cold get quote over there I'm just going
to annotate that with at that ok so
result that's it now that is a like I
said a standard annotation that is a
java x dot cash mana tation right spot
of Jace r107 it what that basically
means is that the first time that method
is cold it's actually going to get
invoked the contents going to get
invoked any subsequent time it's going
to get cold we're actually going to look
in the cache before invoking that method
and see if that result already exists
the cache key that's going to be used by
default is the parameter in this case
the stock symbol if I have more than one
parameter it'll be an aggregate of all
those parameters I can control which
parameters are used as a key by adding
the again let's just as you we've got
more parameters here let's just say int
i'm going to parameter it's going to be
ignored and I don't want that to be a
part of my cache key so in this case I
can say okay I just want that to be so
in this case just that is going to be
used as the key and not that that's
going to be ignored so I get to control
some of that as well there are a few
other bits and pieces to these
annotations and i'm going to show you
oops I've left the go a few other bits
and pieces I can specify the name of the
cash I want to use so for example if
I've got several
different caches in the system if I want
to store my stock symbols in one cash
and some other data somewhere else I get
to control which actual cash is going to
get used here I get to specify a few
other things like key generator and
things like that if I have a more
complex way of creating aggregate keys
now in this case as I'm only going to
use symbol as the key is simple if I
have more than one parameter it
basically uses creates a list of the
various components but I also can
provide my own key generator if I want
to have my own complex mechanism of
creating a key out of those parameters
such a lot of customization you can do
there let's get rid of that and it
really is as simple as that so let's
call this I don't know right that's
that's your basic annotation sorry
question I'm sorry
right now that I'm just going to show
you that right now the next step is how
do we actually configure that cash by
default it's going to create the default
cash that that your implementation is
going to provide which may or may not be
what you want most most implementations
their default cash is is not clustered
it's not distributed it does not have
expiry does not do very much it's a very
simple in-memory cache i will now
configure this using CDI as well so at
one more question metrum essentially
Jace r107 does not define anything more
than these not so put any constraints on
your keys you can do it you can use any
object as a key so yeah in this case
that stock type is going to be used as a
key yes yes yeah you will have to
implement equals and hashcode and things
like that on stock to make it work
properly which I may not actually have
done in this example I will have a look
at that later so yes now how do you
actually configure this again this
becomes there are two ways to configure
to configure your your cash one of them
one is provided provided dependent it is
proprietary to two different Jace or 107
implementations provide an XML file
basically or something along the lines
or programmatically do it the other way
is to use CDI again to actually build
your configuration Celia is actually
very good at doing that as well now in
this case I've created a component to
see dr components that holds my
configuration for my stocks cash right
I've got this method here called get
configuration actually before I look at
that let's have a look at yeah I've got
this method here to create a
configuration I've annotated it as a
producer so that produces this is a CDI
annotation which says every time
anything in my
CDI application asks for a configuration
object cache configuration object this
is a method that's going to produce it
right so it knows how to wire it how to
wire up your application and I'm using
that I'm hijacking the wiring system to
build my cash as well right so welcome
this has that producers this is an
infinite spend specific annotation which
makes it easier to do with multiple
caches in a single system so i know that
this producer method only produces the
stock symbols cash not any other cash
because i can that have different caches
in the entire system and hawai them up
different could be different
characteristics if i want again this is
now the stuff you see in here this is in
finnish band specific we're actually
building a configuration builder i'm
setting some exploration of setting a
lifespan of all the data in there to
have a life span of one millisecond
again that's it very simple nothing too
complex and I build the configuration
pass it back and against EDI is able to
actually not cedia in this case this is
actually an infinite span component as
well which registers itself with CDI if
it's running in a CDI environment that
if anyone asks for a cash it will look
for a configuration like this grab that
configuration build it for you and give
it to you so now at this point if I go
back to my application whenever that
method gets called CDI knows knows what
to do with that cash results so it will
then look for a cash within the
application with that name and it is
able to get ahold of it and then use it
basically it's quite simple as that it's
nothing too complicated now if I
suddenly wanted to make this a clustered
cash I can just change stuff here in
this configuration I can add more
characteristics to I can make it
clustered I can make it transactional I
can do a lot of other stuff with it all
right how we doing so far okay now I'm
not really used to many I've not really
explored too much of CDI hair or the CDI
Jase r107 annotations I'm going to flip
back here and show you some of the
others as well
that black this is pretty much the tip
of the iceberg that's kind of what that
pictures might show you some of the
other annotations that we have we got
out cash results we can also annotate
methods with appcache port at cash
remove that's all of this stuff these
are all again jsr 107 annotations so
they are very the idea of standards
basically I'm sure you can guess what
they do it basically means that you have
a more you have more fine-grained
control over what's actually happening
in your cash what's happening in your
data grid all via very simple CDI
annotations of your viewer of your
application right so just flip back here
so any any questions so far on on this
how this is working which we just won
one line of code there too yeah Jace
r107 does not define a standard way of
configuring a cash unfortunately that
that's where there's a bit of a gap in
107 107 leaves the configuration part of
it to vendors which kind of sucks really
but yeah
well this I did not use any XML it was
all programmatic yeah it was all here in
in that producer over there that
produced the configuration been for me
it's your CD I container that why is it
for you yeah yes absolutely in the same
application where it is in the same CD I
application
I'm sorry
um so just just for in case no one could
hear that the question was whether
whether that ties the lead the stock
object from the back end and the front
end essentially you're kind of asking
whether I'm cashing stuff in the browser
right no the reason why I'm not doing
that is again for this specific example
to demonstrate to demonstrate a lot of a
lot of load on the back end I want that
to be there because it makes sense for
this example I could cash it in the
front end to you you're perfectly right
but this is a fairly contrived example
so
the events yeah i mean so there is an
event in my GWT application there I'm
sorry yes yes
yes that's it if you have multiple
methods well that's that to be a CDI
specific thing which they're always to
specify what you want to observe what
you don't want to observe I've just used
a very basic example here I'm sorry if a
cache is Ben yeah so how do you verify
its already using it well you can I mean
you can see how fast it's moving firstly
that things will actually move a lot
faster because you're reading stuff from
memory rather than going to an expensive
data store so yeah you can add further
logging to it you can do a lot of stuff
to it yeah
anyway
ok
okay well you can you can add logging
statements to it every time it's created
it registers with jmx as well so you can
use jconsole something like that and
actually look at your infinite span grid
that's running in the same environment
you can use that to query what's in the
grid as well yeah you can do stuff with
that no unfortunately so that again is
is vendor-specific the jury saw is quite
thin on things like that it is just API
really yeah
no it doesn't do that but you could you
could do something like let's assume in
this example is doing lazily so the
first time you request for something
it's going to do the hard work and then
store it in the grid afterwards you
could do something like create another
method and annotate that with opposed to
create or something like that so when
your application starts up you can do
all the hard work at that time and
populate your cash yeah I mean which is
why doing something like preloading
isn't always useful because you don't
know what your application is going to
need
yes absolutely absolutely I mean that
that is the benefit of doing something
like this so you have multiple sessions
looking for the same symbol you're not
going to sit and have different retrieve
that data multiple times yes of anything
else all right now this is where things
get a bit interesting actually I'm glad
you asked that question on a trivial
level to actually configure it to run in
a cluster i'm just going to change
things here in that producer what
actually happens is in this case again
talk mode and phyllis pan the the actual
cash nodes start talking to each other
form a cluster we store anything at any
node it's available to any other node in
the cluster as well but more importantly
if any one node was to change something
or invalidate something again every
other node is aware of that and you are
consistent so yes it definitely is is
plus terrible in that sense and that's
an important part of being able to scale
out very important part of it yes there
are different ways of configuring and
finish plan to do that we can do a very
simple replication mechanism where where
every piece of data is available
everywhere very good for a very read
heavy environment where the actual
volume of data is not that big but
that's not very good if you're doing a
lot of updates as well because every
time you make a change you need to tell
everyone else in the cluster that you
made a change that gets expensive so we
have a different mechanism as well cold
cold distribution which is which is a
little bit more complicated than a
simple replication model where you pick
certain nodes as backups and make sure
there are enough copies in the grid but
not too many copies and if there's a
mess you know where to find that details
elsewhere in the grid and things like
that
Oh
two versions of you entities themselves
the beta
no one's proposed it so far but like i
said the j-stars young and if you are
interested in bringing that up please do
i'll leave you with some URLs at the end
where you can participate in the jsr and
yes it's certainly an interesting case
people do talk about that with infinite
span and jboss datagrid as well they
they used in such environments the our
usual recommendation there is is to
provide a custom marshal ax you can plug
in your own civilization framework and
that's kind of a key but it means then
that you can plug into to any modular
system or osgi or whatever provide your
own class definitions for serialization
and deserialization some folks use wire
that up using apache Avro or Google
protocol buffers where you have version
away marshalling if you will but that's
not a standard is very happy it's
non-standard yeah I don't see why there
shouldn't be a part of the standard yeah
make sense um yes you can I know that
Greg locks got some demos using eh cash
as well and terracotta I think you can I
think I've seen a couple of coherence
demos as well doing the same thing like
I said the annotations are standard the
only non standard bit so with this that
little bit now i'm configuring the cash
so that could be anything really so I'm
sorry
well those are just implementations
after that because the annotations are a
part of Jace are 107 and a part of CDI
if you want to call yourself 107
compliant and CDI compliant you have to
implement them in the same way what
actually happens may be different but if
you have the same effect that's an
interesting thing mind a little bit too
no sequel or no sequel in general
because they have the same problem as
well a lot of no sequel databases deal
with that are you familiar with the
Brewers cap theorem a few nods
unfortunate time I should really be
talking about that here because that'll
be another hour maybe have a chat with
you afterwards about it is it is it is a
very complex issue that the the industry
standard of dealing with it is eventual
consistency where you weaken consistency
for the sake of performance and dealing
with split brains they're not shutting
down in that case but that makes things
complicated for the application
developer because you suddenly might
have two versions of a given entry how
do you with that in Finnish man
specifically by default we are strongly
consistent we are not eventually
consistent which basically means we
don't deal with split brains if you see
one we shut down are we going to read
only mode and at that point it's
something the system admin to clean up
although we are working on an eventual
consistent model as well where you get
to choose between the two in your
configuration whether you want to be
highly available or not in that case
anything else okay so now that happens
screensaver came back on okay going back
to these i also want to talk a little
bit about what we're going to do next i
mean this is this is all the stuff we've
seen in Jace r107 which is quite useful
as we've seen right makes it very easy
to to to help your application scale
what are we doing in future with Jace
are 347 now I'm not going to talk so
much about the the API part of it there
is a lot we are going to
there as well like standardizing
MapReduce and querying and things like
that but in terms of CDI I actually want
to be able to wire this up again as well
to be able to say have produced the
methods and have a query in that
annotation of a producer method to say
this is how you can actually find this
data and create it which would be quite
cool things like become to do MapReduce
and remote code execution again via CDI
to be able to annotate for example
methods as mappers and reducers in your
CD I application just to kind of make
that a little bit more fluid a little
bit more you know you're using one
programming model for everything now
these just a few ideas none of this is
carved in stone like I said 347 is quite
young so I'd love to hear your feedback
on that especially on the mailing lists
as users how what would you guys find
useful what would you guys find
interesting him so so kind of some
things up basically we talked about why
scalability is important we looked at
building a web app using CDI and awry we
showed how we added a two edged with a
few quick and easy annotations to boost
performance or via CDI we talked a lot
about Jace are 107 and 347 with that I'm
sorry oh yeah absolutely that's a good
point who talked about it actually run
it okay well yeah we've got the I'm
sorry
stocks cash and what am I called it
there oh you are right well spotted
there you go okay
let's rebuild that and push that out
again
yeah that one there but this this yeah i
mean i don't really i didn't really need
to do that i just did that actually
don't know why that's useful if you
actually want to inject the cash into
another part of your CD I application
and use the cash directly use the cash
api's directly I'm not actually doing
that this application so i shouldn'ta
bothered with this but yeah that's
actually distraction code I should get
rid of that there you go I'll get rid of
that
have I got one no I don't you know well
let that thus far that I'm first and
what's going on there something's broken
their happen the last time as well
I guess those updates are a bit slower
one more thing we could do to them to
demonstrate that a bit better is maybe
change my exploration characteristics
configuration to have things expire I
don't know every every 10 seconds
instead of every second so that things
won't update is frequently
let go
it's doing that weird thing again I've
got to restart the app server I have no
idea what's going on there I'm not a web
app developer like I said say observers
what are they and you know right
I've no idea what's going on with the
apps over there
all right fine I'm giving up on that but
yes so okay so I'll leave you guys with
a bunch of URLs over there you can find
out more about stuff specifically I
think the the to jsr URL 0 interesting
quick quick note about 347 who here
participates in the JCP so anyone doing
anything with any other Jace are no okay
well a quick note about the way j-stars
work I mean traditionally at least it's
been quite good quite a few hoops to
jump through to get involved you got to
get become a part of the JCP get
approved by the existing expert group
and things like that that's exactly not
how I'm running 347 I'm an open-source
guy I'm used to work in an open source
community I am running 347 as a
community effort so the the mailing
lists the everything else is all in the
open you don't need to be a part of the
JCP anyone's allowed to express their
ideas I don't want this to be a vendor
driven jsr i'm tired of ended revenge as
I wants to be a community-driven one I
want people to actually tell me what
they want as opposed to vendors saying
what they want to build right so so yeah
with that well if any other questions no
more there
yes yes I so infinite span is sort of is
very close to 107 the reason why we've
just not finished it is because one of
sevens not in final mode yet eh cash
again is very close a lot of them are
very similar so yeah I expected be out
very soon it's it's in legal hell at the
moment between IP lawyers but that that
will get out very very quickly now
hopefully 8 is my target but yeah I mean
it should be ready long before that so
I'm under if you're familiar with the
adopter Jace our program so Java user
groups around the world can adopt Jace
ours and the houston java is could have
adopted 347 what that means as they are
contributing their building and
contributing a reference implementation
and the tck for it so again it is a very
much committee driven effort and that
means that you're going to see an RI and
the tck out quite soon they actually
people commit into it which is great
yeah absolutely yeah yeah okay well with
that thanks listening guys enjoy mr.
country</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>