<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>First Do No Harm: Deferred Checked Exception Handling Promotes Reliability | Coder Coacher - Coaching Coders</title><meta content="First Do No Harm: Deferred Checked Exception Handling Promotes Reliability - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>First Do No Harm: Deferred Checked Exception Handling Promotes Reliability</b></h2><h5 class="post__date">2013-02-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9BDZACVu92s" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so the topic is first do no harm and
that's by deferred checked exception
handling and that I think promotes
reliability and so I have I'm pretty
probably pretty controversial and saying
that there's kind of a problem with
checked exceptions except well we'll get
into that but it is recoverable okay so
first of all we'll we'll talk about the
advantages of exceptions over return
codes that were used historically and
how exceptions still help but in fact
return codes are still used some degree
and then the motivation that that that
the designers had for for designating
checked exceptions which has some
interesting one interesting problem and
then why exception handling is best
deferred and I and I go over well the
reason that the checked exceptions are
controversial I think in the community
and then how we can deal with the
unattended issue that they caused and
then so there's two steps the deferring
means that we as a separate step we
factor the exception handling and then
we'll talk about some of the ways
guidelines for exception handling and
then well in with this hybrid error
reporting through a validity queries
which is a newer thing in the Java
libraries it's being used I think
probably to avoid checked exceptions so
let's get started
so back in the old exactly remember when
everything had a return code I
programmed on the mall tech system years
and years ago you may have heard it's
like a research system or something and
everything at a return code and so half
your program on more than half was
checking return codes and doing the
appropriate thing and in fact we had to
check them for things that where we
expected that it might go wrong
something to user input and maybe a file
wasn't found or something but we also
had to use them for everything even if
we didn't expect something to go wrong
if we didn't say if it goes wrong stop
and report this then it would go ahead
and any we lose track of where the air
was and the bugging would be horrible so
most of your program was checking error
codes and that that really wasn't good
and then dr. good enough and that's
interesting name good enough proposed
actually than the notation we even
basically use today he proposed that in
1975 as a way to better handle errors
Becca before that with PL one you could
you know you could do similar things but
it was more general exceptions are only
intended to capture errors and that's
that's good we wouldn't want to program
normally things that raise exceptions it
would just be too complicated
okay then we turn code versus the
conception so exceptions are always
handled right is that true exceptions
are always handled even if you don't
have a handler for it yeah because
there's a default handler in fact you
can set your default handler very easily
that I actually have a vote in the
footnote on my paper that says how to do
that but the standard thing people
always say we have to capture the
exceptions because you'll give a bad
user experience because you'll print out
debugging information when you shouldn't
to the end user and that's wrong because
yeah you can you can have a blog the
error information and send a nice worded
message to the end user about contacting
technical support right so because
everything stops immediately when the
error occurs the debugging mix and that
makes debugging easier and since you
only have to now handle irrecoverable if
I mean sorry you do you don't handle the
default handler handles all the
irrecoverable exceptions but you'll
still put your exception handler in for
things that are recoverable maybe well
we'll see but the problem with them is
that ok so that reduces the code volume
a lot but they're harder to use in
return codes how many I just was telling
someone about my talk over lunch
yesterday and he said oh if I had my way
I would just get rid of checked
exception because I hate doing that the
try-catch block and so forth and because
that's true and so not not everybody is
a you know a designer of sofia a lot of
programmers aren't quite as may be
knowledgeable on the exception part of
it so anything you could do with return
codes where it makes sense they probably
already do in the Java library
and then you can just use if-else coding
you don't have to use exceptions which
are pretty bizarre to the to the typical
program or they make some kind of
bizarre with what they do so there's
still common so we still have both
exceptions have a great advantage for
the unexpected and that the beauty of
them is that you don't do anything and
if it's unexpected it will give you its
stack trace if it happens right
wonderful sometimes you have to use it
for expected errors and then that's when
the program was complaining I was going
to say does anybody know why you have to
use exceptions for some errors but
because you know we do in my classroom
but the reason is that the the interface
might not have a way to tell and this
will get to the hybrid interfaces
sometimes we can avoid using exceptions
the place where you actually have to use
an exception is for something you can't
test ahead of time because asynchronous
processing is going on so you don't know
for sure at the time the calls made so
return codes still popular especially
good for expected but if you try to use
a return code for unexpected things you
can feel problem of having to check the
return code even if it's not expected
and that's problematic so each one
probably has their place for what
they're better at okay and so some of
this i took my paper and I this think
about the blissful state of affairs it
was nearly a blissful state of affairs
because things were so much better when
we got exceptions the code volume went
down but the only problem was that what
well how do you know which accepts is to
catch and which not to catch right
because you only want to really catch
the ones that are due to user problems
probably maybe environment problems
we'll get into that but you only need to
catch the ones you can you can do
something about and so you can't do
anything about a null pointer array or
something so you don't to catch that one
so how do you tell and so you have to
carefully read the documentation but of
course the author of the system has to
also have written the documentation to
tell you which ones to catch so the
designers of Java's side well let's just
have this definition that if it's
outside the immediate control of the
program if it's not another program bug
or a system but well done a minute if
it's outside of your control then
probably you want to catch it or at
least you might want to catch it and so
you can do something about it since you
couldn't control it happening within
your code it was something external
you'd like to catch it probably and then
therefore we that's why I checked
exceptions were put in they have to
catch them and it was for at least the
documentation reasons if you look at the
Java tutorial I say it was for
documentation reason in fact that quote
comes from the Java tutorial there's an
interesting evolution for that
recommendation to ask me if I forget so
that's a direct line of communication
between a PID I designer and the
application programmer so if an
acceptance checked it can happen even
within a bug free program so therefore
you might be dealing with it in the
context of your program and not
reporting it as a bug which will be the
alternative if the network's down and
you can't run the system you don't want
to know we put that as a bug right
and so then we get to the question in
fact it's a more general question we've
talked about checked exceptions or the
fact that you have to cover them but
that really brought in this to me a
problem that they create because of
what's happened historically which there
was a pointer on here okay there's a
there's a direct path that that actually
provides a function of the application
and then there's things that can go on
alternative processing that are things
that went wrong and they perhaps need to
be corrected and the thing is that those
two items have different demands and if
you try to do two different castes well
let's get into two different cast at the
same time in fact here's some I go
through a quick list of different things
one is there's two types of concern with
direct path you're thinking about the
application domain and you're focusing
on the getting the thing working with
alternative processing it may be the
application or maybe implementation
domain the network we're dealing with
the network being down and your concern
is more focused on the user experience
with that they're going to receive with
this thing happens and so the two
different concerns there's two scopes
the direct path is just the method being
coded usually but alternative processing
you might have to look at the entire
system or at least all the methods in
the epic that could be on the stack on
top of you are you on top of them I
guess so the scope of what you have to
look at is totally different so I'm
trying to convince you that it's bad to
do these two things at the same time and
there's a different skill set for the
direct path it's just basic structured
programming to implement the method and
with alternative processing it's not
structured for
anymore you have these go tues basically
are the non-local transfers and you have
to have things like finally blocks to to
maybe rollback things fortunately with
Java it's not so bad so usually because
the memory garbage collector will take
care of it but you still might have
things like opening a database and I've
had it where the day there's only so
many times you can open the database and
if you don't close it you run out of
sessions with the database so if the
release resource is perhaps so it's a
very different skill set for doing those
two tasks and of course there's two
levels of interest it would at the
beginning you're interested in getting
thing working and not so interested in
it not working in white my network an
alternative processing at the beginning
it's a little level interest but the
thing about alternative processing is
it's unnecessary for the initial
debugging right you could get the thing
working as long as you give it good
input and it doesn't encounter any
problems it will provide the
functionality if if something goes wrong
you're guaranteed to get a stack trace
and then you either know I have bug or
oh this is something that it could take
care of so either way you get
information and if it's something you
could take care of you can note it in
your log that oh we need to make sure
that we take care of that later on in
fact I recommend doing some stress
testing to see all the places it could
blow up since you'll be given the exact
line that we're blowed up because of the
default prosody fault handler ok so I'll
turn
ok so the controversy so checked
exceptions would have been widely
accepted i think and included in other
languages like C sharp I shouldn't
mention it except it became very
controversial because of an unfortunate
decision and the decision was that they
said okay it's such a good idea we're
going to force the programmers to do it
we'll make it requirement before they
could even run the program they have to
put the exception handler in there and
and they didn't realize that what they
were doing to get rid of these
significant advantages of being able to
debug before you put those in if you're
debugging before you put them in a fact
you're debugging less code and if all
those other things that I listed and and
so putting them in first is really
varied it very destructive and why
didn't they realize that the advantages
well I think it was just because it was
a natural way to do things before you
had checked exceptions people just
naturally didn't fool with usually doing
the exception handling they just got it
working as a first step and then they
put the exception handling and soak
because it was natural nobody realized
that that was important but but all at
once now we're kind of forced to deal
with it leaving the two together if we
actually try to to do the two at the
same time but they're there they seem to
be asking us to do that unfortunately
and so many people didn't like a checked
exception but they they just said
they're bad somehow and they really
can't give a convincing argument so if
you go online and look for the checked
exceptions controversial fine dreams of
different websites that have talked
about that and and really some important
people in the in the community have come
out one one side of the other and they
all give arguments but they're not
convincing enough to convince each other
so they're you know they're like 5050 or
what
ever so in the problem with the argument
they were actually a good idea so it's
hard to argue against them and they're
they're helpful after the direct path
has been written in debugged but before
that time because it's catch or specify
their kind of a nuisance and if you
actually try to do it it's harmful
probably because you're going to not
spend enough time thinking about it
you're going to handle inappropriately
you may inadvertently swallow it or so
it's likely that that negative impact on
reliability was actually triggered by
hit making that to requirement and
there's anecdotal reports that in fact
Java programmers create systems that
tend to be unreliable I don't know I
shouldn't say that here but I've read a
few sources that say that that's true at
least in some shops and probably it's
because they try to mix writing the two
together
so I've a methodology I'm calling it the
ear code refactoring methodology for
lack of a better name so the two phases
I've alluded to the direct path you do
first the default handlers relied on to
report and abort if any error arises and
of course the second phase is to
actually put the air handlers in but at
that point the whole thing is written
and so your focus is all on the air
handlers and you'll do a better job
okay so the name of the talk it starts
with first to do no harm and exceptions
in fact if you put exception handler in
and it does the wrong thing it destroys
your ability to debug it's very harmful
and so we need to not put the exception
handler in so that it's going to harm us
but we have to put one in and so how can
we put one in that's harmless that will
help us with debugging that will abort
with a message which is what we would
like during phase one you want it to
abort on any error user error system
error and give us a stack trace so
there's three ways to do it you can
actually say that throws exception at
each level and that some actually I use
that in one of my pedagogical tools but
it's of limited use I think you can also
have a method body surrounding you can
actually put around the method body the
try-catch block that catches exception
that's another way and actually I do
that some places too and then the third
way is actually what i recommend unless
you're creating a tool of some kind to
handle it automatically is the
individual method implications are
surrounded by a try-catch block and
we'll see that let's see you go the
wrong way
okay so each way I've gone through this
already kind of I deleted that the third
one is the one that will talk about
today and the advantage of that the one
around the individual statement is you
can actually start doing that anytime
even in later in development if you're
just doing it like a new subsystem you
can do it this way without impacting
anything else in the system and do your
testing and because the structure the
block will see in a second you know what
methods are being thrown just by looking
at your code so you can prepare yourself
that I've got to refactor that and be
thinking about how you're going to
handle it and then it also allows you to
refactor just one exception at a time
and not get involved with doing several
things which is good right I always tell
my students you should do one change at
a time and test it you know if you do
this how to do five changes in tests bad
thing right so here's the code block I
recommend so just a try catch and
contains one statement now you
technically you could just catch
exception in all cases but then it
wouldn't be self documenting about
what's there is that so I prefer to put
in the exact one and the compiler will
tell you the exact one right so that's
not a problem to find out and there
might be more than one you just have
several catches and the beauty of it is
it throws this runtime exception and
sorry about that I thought that was
going to be the pointer
it throws the runtime exception and why
do I put the exs of parameter the
original exception into the runtime
exception parameter list can anybody
tell me okay it will be chained the
exception handling in fact the the
listing from it will look very nice it
will tell you the original error was
this when you do the stack trace so that
works out very well I've been using that
for a while it's the most like the
compiler was giving a warning because at
least it's we typed it on herself but we
know what exception it's throwing and
let's just go ahead and debug and have
the exception being reported so it's
like just about like you the compiler
was giving a warning and letting go
ahead and then of course you could you
can just take that that one block out
and have the exception thrown and then
take put the compiler and error mode so
that you can figure out how it can be
handled ok so now then the second phase
the handler refactoring phase we've got
it we've got to look at each checked
exception basically and say well what's
going to be the appropriate handler we
also have to remember though that during
this phase you have to look for
misclassified exceptions and my paper I
report some misclassified exceptions
from the Java library fact the one I use
is the integer dot parse int to a static
method to parse an integer from a string
into an end and it doesn't throw an
exception and invalid input and that's
bet it's got to be coming from the user
it's this coming in as a string so why
wouldn't throw a checked exception we
should always my students are always you
know I was like I always break their
programs by just typing something and
wrong
it's an exception so you actually need
to do those during phase 2 also so we
implement a test one handler at a time
and actually your experience from
debugging might tell you how to get this
how to get it triggered so you're going
back to your debugging log when you were
running all your tests you probably had
many times they blew up and those will
tell you where to find them also well
it's it yeah it has a similarity to it
but the beauty of it is that without
doing any well with just doing that one
thing at least it will blow up and step
up going on but and the compiler won't
let you go ahead without putting
something in so it's not as bad as
return codes you really can't forget to
do this
okay so now we have to decide for each
one you know how to handle it and so
there's four types of exceptions and
three types of handlers and so there's
12 combinations and and we'll see those
probably in the next slide almost the
next slide here's the four types it
could be a program bug a system error
javis distinguishes between those two
more could be an environment fault
networks down or something or an
application domain error the user and a
bad input so the exception is it's got
to be in the one of those four things
usually program bugs or sometimes a
runtime exception some some descended
runtime exception system error actually
I think there's an error class of that
those would derive from and the rest
would derive from checked exception
well you probably already knew all about
that but here's a new one so there's
actually a taxonomy of handlers and
there's three basic kinds the message
terminate and that's the default handler
does that with a stack face but it could
be a message to terminate if you decide
you're not going to handle the network
being down you're not going to recover
from that but at least you'll tell the
user nicely the network's down and
you'll abort or something okay so that
one comes up message rollback is that
you can't do exactly what the user asks
you to do because of some problem
probably invalid input or something
something wrong in the application
domain and so you're going to send them
to give them a message you couldn't do
it but then you're going to go back like
to the event loop you're going to ask
them from what maybe you could process
other commands especially if it was your
input error they could just do that same
command again so that's the second kind
basically it's called roll back because
it has to get rid of anything that you
did so that it doesn't build up cause
some problem with a future execution
because it's going to continue and then
the third is that retry fall back where
it reached rise and maybe it tries the
same thing again or maybe it has a
different implementation for doing the
same thing that will might work in some
cases and so after some limited number
of failed attempts you don't want to do
this forever it falls back to either one
of the other two a message roll back or
message terminate so we call it retry
fall back and so here's the the grid for
the what to do across the top we've got
the the types of air handlers and along
this left that we have a the types of
errors I notice at the on the left i put
unexpected types which would be system
error and program bug and then the
expected types would be the application
domain invalid input for example or some
kind of environment fault I remember
using network down
so some of these makes sense now now
that I will relate it the ones that are
gray or darker gray are things that you
usually wouldn't do and so you don't
have many choices if it's a program bug
you you always report the debugging
information and inform the user I
suppose and then if it's a system error
basically the same thing those two kinds
of things really don't differ much
except system error might be well yeah
the Prince the same but the environment
fault is where the questions come in if
it's an application level domain error
then you probably want to do a message
rollback if it's possible that would be
the best user experience but this this
one that's all white across all across
you actually make a choice there and
it's a cost-benefit analysis there's an
environment fault there's something
wrong do you want to spend the time to
actually code to overcome this kind of a
problem and it depends on your
application so you have to look at its
cost benefit of course the the best
thing is that retry fall back because
you'll actually get to do it eventually
but that could be pretty expensive or at
least you'll try to do it probably the
middle one is the most common providing
the best possible user experience is to
inform the issue and roll back so maybe
maybe they can do something else with
that environment being bad or if it's so
severe and you don't have the ability to
continue and and you're not going to
code just all this retrying stuff then
you'll just report it to the ite and
inform the user so that when you
actually think a choice the other one is
pretty clear exactly what you're going
to do
well I'm winding down here I'll have
time for a few questions at the end
hybrid error reporting so it would be
the optimal case of all exceptions who
are unexpected because then if their
unexpected you don't have to write
handlers for them right so that's nice
and it seems like that's a pipe dream or
something but actually it's possible and
the Java library has been doing this
more recently the eight if the API can
provide you a test routine to verify
it's a correct request you can say if
it's a quest for the correct then do the
request else do something else so you
don't have to have a handler you can do
with an if-then-else and it works out
pretty well let's see you so in fact
scanner does this with scanner you could
actually decide how you're going to
handle the errors each method that is
going to get something from the scan
from the input it's like it's going to
ask for integer or ask for a double or
string and so forth you there's a
pretest for each one is there an integer
at the next input and if there is you
can go ahead and get it and if there's
not you can complain okay so you can do
if then else or if you want you could
just go ahead and ask for it and it will
raise an exception but that's okay
because you knew you did that and you
saw the method was there you said I
don't want to do that because i know i
want the exception reported so like I
can go up the appropriate level on the
stack to handle this problem so
sometimes it's easier to have an
exception depending on the problem and
in that case you can go that way so it's
up to the programmer then which way they
want to handle it and that's wonderful
because
a lot of programmers don't like
exception blocks tried catch blocks and
they can avoid them entirely and it just
depends on the context if it makes sense
or not so this is the latest thing that
this hybrid reporting and I have a
common here that it provides cover for
the API designer to throw a runtime
exception for otherwise expected
situation and then they meet the
guidelines so no one's going to
criticize them for not throwing a check
exception since the user could have
asked if it was correct or not so I
don't there's no question so that's one
way to get rid of checked exceptions and
people want to get rid of them right the
other way is to look at the latest java
tutorial because the recommendation for
doing checked exceptions has changed
over the years back in 2004 I've told by
a reliable source it said virtually
anything that could happen outside the
control of the programmer should be a
checked exception that's pretty severe
the latest one says it should be checked
exception if the application can
reasonably recover from the problem so
the new guideline is a lot looser and so
you're not required now by the guideline
to do nearly as many checked exceptions
okay well so we'll get to the conclusion
now the exception handlers are best
coded independently from the direct path
because of the two concerns and the
different skill sets and this lets us do
the first do no harm because each
handler is going to be so simple that we
know it's not going to make a mistake we
don't swallow anything everything it's
known as runtime exception and well I
got to get my criticism in that that
above practice naturally happens usually
and and so the catcher specify
requirement really brought it to the
front that why you can't really do it at
development time it before debugging and
now we have a workaround for java that
works okay it's not pleasant if I could
somehow get it changed I think it would
help Java a lot I don't know how well
that would be received but I'm going to
ultimately try to do that and that this
talk is my first attempt I suppose that
getting the word out okay well we have a
few minutes left if there's any
questions yes
I'm not familiar with that I'll look
into it though oh and please take take a
paper before you go if you like i have
several here any more questions okay
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>