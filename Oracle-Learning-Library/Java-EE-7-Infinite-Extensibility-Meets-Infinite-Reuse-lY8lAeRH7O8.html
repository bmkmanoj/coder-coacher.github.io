<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java EE 7: Infinite Extensibility Meets Infinite Reuse | Coder Coacher - Coaching Coders</title><meta content="Java EE 7: Infinite Extensibility Meets Infinite Reuse - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Java EE 7: Infinite Extensibility Meets Infinite Reuse</b></h2><h5 class="post__date">2013-01-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/lY8lAeRH7O8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this is a great size audience is perfect
for this talk because it's very marine
are you doing it's a it's a very focused
kind of experimental talk this is these
are I want to stress that these are
concepts being discussed they're not
official parts of the specifications we
are talking about the mat the spec level
and your feedback on this is is also
very welcome the two concepts that I'm
showing our sort of a way to reach the
potential of two parts of Java EE that
have gone on they haven't reached their
their true ability to affect the
platform in a way that they were
intended to so the first one is the
concept of extensibility and that is all
really about the promise of the
connector architecture and how it came
just real close to being able to do do
the things that it can do now to be fair
it does do the things that's designed to
do it's just not very modern so inbound
connectors are specific type of
connector and when people say inbound
connectors what they really mean is MDB
so message-driven beams the two are all
indistinguishable from each other so the
promise of the connect architecture
specifically inbound connectors is
infinite extensibility such as that you
can have communication coming in from
any other source and you can push data
into your applications from an external
place via this connector so
theoretically you could have a corba
connector you could have an HTTP
connector you could have in every
connector so when you want to expose
basically a protocol or something the
connector should be able to provide that
functionality for you and for the most
part question is does it do that
well fairly yes it does it does do those
things what spoils it really though is
the connect the inbound connector was
created after the connector one point 0
specification was was in existence it
was reverse engineered from the message
driven beam concept so originally
message of in beans were part of ej be 2
point 0 and then in 2.1 they became
discs disconnected and decoupled from
JMS so the connect architecture was got
the task of solving this problem seemed
the most logical place to put that work
so connectors became this inbound
connectors behemoths connect to anywhere
from anything type of system but then
mentally everyone's thinking JMS so it's
really difficult to get people to think
about different paradigms because the
mental model because for a couple years
it was true that md BS were only JMS but
after they were disconnected and
connectors became inbound connectors
became the drivers of md B's the mental
picture didn't change i mean there were
no there were no article is about it
there was there was no talks about it it
was just sort of was almost invisible
from that respect and then also inbound
connectors are vastly much more simple
than outbound connectors outbound
connectors have pooling and all sorts of
there's a lot more API classes for the
outbound connector the inbound
connectors fairly simple having them in
the same spec is not bad but it does it
does make it a little more difficult to
to see the simplicity when there's all
that other stuff going on in the
specification then also there's a stairs
that I have a got a particular
philosophy that if you abstract
something out you've got one use case
for it oftentimes that abstraction won't
reach its true potential until you have
a second use case to really to really
challenge it and
was the primary and almost exclusive use
case for inbound connectors for a long
time I'm I'm aware that you know some
years ago people from jboss a quartz
connector and then i wrote a quartz
connector and that's a really good idea
i don't know why they didn't even occur
to me you know but there haven't been a
whole lot of inbound connectors and so
that really never hit home how different
things could be by having simply a
different connector and then the worst
part is is you know the first ones are
our mental problems they're not actually
technical problems the last one is that
is an actual technical limitation and
that's the metadata pass between the MDB
and the connector is basically a hashmap
and so it's not typed then amount of
properties in the hashmap is completely
unknown to you have to go read
documentation and things like that and
then the amount that you can express in
that fashion is a little bit limited so
what cripples this hash map what makes
that such a bad thing well when you have
exactly one method in your message
listener interface having a one hash map
is not terrible because effectively
everything in a hashmap could apply to
that one method so you could effectively
be configuring that one method with that
hash map but if you have two methods and
then you have no way to distinguish
between one method or the other and so
now your your hash map only applies at
the class level and you start to lose
expressiveness if you had ten methods
configuring those ten methods to behave
differently with one class level hashmap
rather difficult also the fact that it's
you know not strongly typed string to
string it it really does really does
hold it back in a lot of ways you don't
know it's it this sounds like it may be
a number but as it support desk
as it is it an int is it a float you
know things like that it does become
difficult and then fixed method
signatures not not allowing users to be
able to decide for themselves you know
what they want to expose can be
difficult I'll show you you know some
some examples and will become painfully
obvious how having just a standard
interface that you have to implement is
not exactly the way today we write
software okay so first dispelling some
myths which of these statements are
always true
well I mean with the exception marina
and I will argue about the last one none
of them are always true to my opinion at
least we'll agree on four of the five
effectively md bees are not JMS beans
there the better name for them would be
connector driven beans that's a you know
they're called message room beans
because the legacy from JMS we probably
should have renamed them or or made some
more expressive name to to to
communicate what they can do now but we
left a message or in beans but in fact
whatever the connector wants to drive to
the MDB it can md bees are not
necessarily asynchronous or synchronous
the connector is the one that decides
what the messaging style or
communication style is jay messes is
asynchronous but you can have other
types of calls and they don't have to
necessarily be asynchronous the message
listener interface doesn't have to have
exactly one method you could have 10
could have 100 methods it's really
undefined and the return type doesn't
have to be void it could be a string it
could be some other object it could be
an HTTP response if you wanted to get
crazy it's it's fine it's up to the
connector it's the connector has the
complete control of the API it exposes
to the beam and then as far as them
being pulled a stateful or stateless
it's actually the connector that does
the pooling anyway if it chooses not to
pool it can choose not to pool it could
create the beam and do one method
location destroy it and throw it away or
it could hold it into a pool for a while
it you know it's really the spec does
have words that still have the JMS
legacy to it like the beam does not hold
state but there's actually no way to
enforce it it's sort of like well that
goes against the spirit of the
specification but there's actually no
technical way to stop a connector from
saying I like this beam for these kinds
of implications I'm going to use it all
the time technically there's nothing we
can do it at prevent that
happening and we probably shouldn't it's
fine to allow them to be linked to the
caller and anyway that the connector
wants them to be linked so seeing the
simplicity I think is a big limiting
factor for this whole API and that's a
that it's really not difficult to write
a connector people always say oh it's so
hard to write a connector know it's hard
to write an outbound connector but to
write an inbound connector you could get
that done and a half a day if you've got
already some some code that does message
you know some sort of communication it's
not not a lot of work so if you're
writing a connector you need to supply
the you know the basic contract between
the connector and the MDB are two things
first the connector supplies an
activation suspect class this is
basically a javabean and then it
supplies a message listener interface
the MDB implements the message listener
interface I know it's getting really
complicated now I hope you can stick
with me as a little sarcasm there and
then the MDB uses the activation config
which is basically here the values i
want injected into the activation spec
and now you have the two hooked up
together so we'll try and sew them
together so there you go connector md b
activation spec activation config the
connector defines the listener interface
the MDB implements the listener
interface or rephrased one is a
configuration class the other one is an
instance of the configuration class one
defines a communication API and other
one uses a communication API so when you
really get down to it there are two
sides of the same coin and you only have
two things to worry about you've got the
configuration and the invocation and now
we're talking about all software and the
face the planet so how do we catch this
up so it can be like all software so
first of all I'm going to show you how
to write a connector if you want to
write a connector you supply the
resource adapter and the RA xml file
which is what i didn't mention in the
previous two things so they're actually
four parts for moving
to writing a connector okay so I'm going
to show an actual use case now this use
case is a telnet connector and it's
intentionally very different than your
standard JMS kind of connector and I
realize that don't have intelligent open
I hope it doesn't spend forever trying
to open let me get my watch out here so
I can make sure i'm not running over
ok
and I might need to increase the
resolution on this we can all see
ok that's i could probably do better all
right so
here i have my connector implementation
and my MDB implementation in the same
little project now these would typically
be two different groups of people
although if we do these changes to the
specification and people start writing
connectors all the time you might just
find them all in the same project so
step one is you need as a connector
implement ate someone creating a
connector you need your activation spec
which is I saw as I say a javabean come
on I IntelliJ let me there we go okay so
it implements activation spec and then
you have basically two properties in
this but in this particular activation
spec which port do you want the
connector to listen on and what prompts
should you give the people when they
connect via telnet and we have getters
and setters for that and then really you
have a validate method and that allows
the activation spec or aka the connector
implementer to look at the data that the
user supplied via the activation config
the hash map and say is it good data or
is it bad data and if it's a bad date it
can throw an exception the deployment
will fail and everyone's happy and all
tools are good and and everything works
you can ignore these bottom two parts of
that of the activation spec that's just
a sort of a standard little meme that's
that got into the respect that doesn't
have a significant design impact okay so
step number two is you implement well
maybe probably step number two is the
message listener interface so here we're
going to have a message listener
interface with these fixed methods so
someone's going to implement this and
they're going to have to you know figure
out a good joke to tell know how to
print a date and get and set something
and add something and then a resource
adapter now I've let a
left the guts of the telnet part into
other code so that we don't have to get
confused by it here so you implement
endpoint activation which is basically
your deploy method you implement
deactivation which is aa run deploy
method and then any activation you get
this thing called a message endpoint
factory which is basically a bean
factory create new instance of this beam
and then you have that instance of the
beam it's not necessarily the insets
itself it's actually a proxy much like
ejb session beans when you look up an
ejb from JD I you get a proxy to that
being you don't actually get the actual
beam it's the same thing here so this
message endpoint will implement the
message listener interface and this
particular connector interface and then
you can cast that as a connector
implementer to your message listener
interface and go ahead and invoke it so
here we're just going to you know create
a little telnet server and then it'll be
up and running and then in our
deactivate / undeploy we just find the
telnet server and we say deactivate on
it which is basically start and stop
okay that's the entire resource adapter
the actual plumbing to do the telnet
stuff different area but this is the
entire resource adapter not a lot of
code so we've got a javabean and an
interface with like three methods on it
22 that urn are significant really not
not not difficult to write a connector
ok so our MDB implementation looks like
this we've got our activation config at
the top and you notice we're using
annotations but the annotations are
essentially annotations that say my name
parameter is this and my value parameter
is that so it's still string to string
basically we have an annotation way to
configure a hashmap and this is the part
that we want to change and then we just
have some very boring
implementations of these of these
particular methods do add is you know a
plus B tell a joke where your hamburgers
go to dance to the meatball all of my
childhood favorite jokes and little
little properties object in this MDB to
do get in set so you can do a sort of
ian v like type of programming all right
so like we can actually run this so I've
got a little lay this is a little bit of
our Killian code that sets up the actual
ear file and so on and so forth and just
boots up Tommy which is a server that I
will work on
due to do okay
and now let's listening on port 2020 so
here we go say telnet host 2020 and then
we get a little prompt and then we can
say help and those are the commands we
have available to us and we can say add
3 plus 5 and so on I can say joke where
do hamburgers go to dance and we can say
set joke equals not funny and then we
can say list and we can get our get our
data pack now this is intentionally
showing state in the MDB this would run
on any server there's really no way for
not to run any server it's not doing
anything that's against the actual API
classes it may be against the intention
of the spec from its original version of
messaging beans but post connector it's
totally kosher there's it would run on
jboss glassfish you name it okay so this
is neat but it really sucks to have a
fixed number of methods that hash map
thing and the top is not really that
great so with a little bit of tweaking
we can get this thing to look so much
better so here's an alternate project we
open that up
yes ignore
don't care okay so first thing you'll
notice as my message listener interface
is empty weirder no methods in it and
instead of having a fixed number of
commands I have a command annotation
let's zoom up on that it's a basic
method scoped method applicable
annotation and then in my adapter I've
changed the activation spec only
slightly this is looking to look very
similar because I have done very little
different I have a beam class attribute
so the proposal is that the container
hand the connector the beam class so the
connector can look at the beam class
analyze the annotations on it and then
use annotation data in addition to the
hash map data to figure out how it
should be invoking the MDB very subtle
small simple change huge impact the
other part 2 of this proposal is that
the container when the connector calls
endpoint create endpoint that this
endpoint must implement what you know
what is identical to a no interface view
of the beam so an ejb 3.1 we added at
local beam which basically means we're
going to subclass that beam treat that
as a proxy so that way when you hand
that to somebody else they think they're
invoking the actual object but it's
really a proxy they have access to all
the public methods of that beam and they
don't have to have a business interface
as you had an ejb three-point oh and
before so they're actually no interfaces
at all I mean we have a telnet listener
interface but you'll have to suspend
belief on that one for a while anyway so
though
two changes are all that's required and
then our MDB can now look like something
like this so we don't have the fixed six
methods that we had before now we just
have three and we could actually add our
own methods what we're doing now is a
very jax-rs type of thing or just taking
plain methods and we're annotating them
with at command and that is our contract
to our connector to say what we want to
have invoked or what commands we want to
make available to users when they log
into the telnet shell now this is real
subtle we've only changed a couple small
things so it's very difficult to see how
this would be impacted but for example
we don't even need this little
activation suspect anymore if we wanted
we could have an appt port annotation
and a net prompt annotation and the
connector could simply pull that from
the beam this is currently impossible
currently you got to do it all with the
hash map and now you can have metadata
at a method level you could have
metadata in parameters so if someone
types help they could get a list of the
parameters that are available to each
command so really you could do jax-rs
with this new style of of connector MDB
relationship small small tweak so I
actually implemented this in Tommy it
was three lines of code change to Tommy
and implemented it last tight actually
so i'll go ahead and run this i think i
have my stuff my other server up and
running yeah I do I got a ship down
okay so now we'll go ahead tell that
back in now when we say help we see only
the five methods that we had exposed to
that beam and it's going to go ahead and
immediately exit this thing and kill the
server and we'll just do something fun
and do some live hacking just a at
command hello
and then we'll run that
and there it is hello currently
impossible with the current connect
architecture you would have to go excuse
me mr. connector can you give me a hello
method will think about it will issue a
new version of the connector in another
year oh thank you I mean you can't as a
user of this thing you can't use modern
style ap is with the way the connect
architecture is written currently it's
fixed number of methods fixed number of
metadata at the class level and the rest
of the expressiveness is simply not
there ok so the two changes as i
mentioned connector gets full access to
the beam class to scan for annotations
and look to see for the things that it
wants you can now use really modern api
styles to expose services to any ee
certified platform full full profile and
you know the user and the connector
creator can have these very expressive
modern api's like jax-rs and really
anything that comes along like that so
let's take a moment and think what might
you be using today that you would
potentially want to expose to your
application maybe you're using thrift
and you were saying well we can't really
use Java because we like thrift and
there's no way to get thrift
communications into my application well
yeah write yourself a connector and then
half a day you've got yourself a thrip a
thrift connector you make yourself a
message listener interface has got
nothing on it and then you can go ahead
and voc any method on those beans just
like you can with thrift and thrift has
its own annotations for for doing this
style of message you know method
invocation there's a swift which is a
newer version of thrift and and guess
what like jetty is maybe a Meg jar these
days if you don't like the HTTP server
that's in your platform add another one
there's nothing stopping you from doing
that as a connector you have complete
control over the kind of protocols and
number
ports you have open threads all these
things you typically can't do in the
platform you can do at the connector and
it's portable and you can expose that to
your application so if you simply want
to use jetty for specific HTTP
communications instead of like say
whatever is in the server go ahead write
a connector boot up jetty deployed into
any certified platform and you're off
and running stomp if you want to do smtp
or email you want to create an API that
has like you know at subject and header
/ am that's almost identical to two
jacks or sgx rest is basically a name
value pair programming with the body
well that's what email is so you could
probably lift a lot of the concepts from
Jack's rest and write your own email
connector that has a very expressive API
sky is the limit really now that's just
protocols what if you wanted to write an
implementation of chron that a connector
that took cron notifications and just
sent them into your app now we have the
ad schedule annotation in ejb but maybe
you just like ron better maybe like
being able to log in and edit with the
text file and you want that to be your
your notification mechanism you could
have system events being sent into your
application server via inbound connector
you could have cloud events we have
launched off a new node in the cloud you
get of all those things if something
wants to send you an SMS and you want a
connector to be able to receive SMS
messages and then invoke your MDB you
could do that jabber so on so forth I
mean really it's a miracle that we get
by so much with just HTTP as our only
mean transport for the Java EE apps that
we write it's remarkable how many other
really great protocols and services are
out there that we don't use because we
simply have no way to plug them in in a
way that we find enjoyable so the
connector architecture currently can
plug them in but you're limited to this
very hash map API it's no one's going to
do that like if you wrote that connector
no one would want to use it but have a
full breadth of Anna
patience to write in a really fun jax-rs
style yeah you could do some great stuff
all right if you have thoughts on this
topic now is a good time to share them
as well you can comment on the JIRA we
have there's also this entire project
plus this code that runs is at that
github project and so you can snap a
picture of it if you if you like as well
you can go to the users a list for the
ejb spec and and send your feedback and
comments in and Marina's right here so
if you want to tell her directly that
works too and then I'm happy to listen
so does anyone have any comments or
questions about that yeah I the the yes
that was the MDB class yeah exactly
exactly so before the connector what
we'll go ahead and take a brief look at
that connector class so before the
connector was a kind of in the
activation spec looking to say where is
it yet he's using the validate method to
finish deployment so to speak it was
taken the telnet listener interface
iterating over and collecting all the
methods that started with do now this
was the current connector stuff so
obviously this this particular telnet
listener interface has a fixed number of
methods with fixed number of parameters
so it's dine at the dynamic work that
was being done in the inactivation spec
is completely unnecessary could have
just assumed the parameters but it just
made it really easy to write the more
dynamic version where instead of the
connector doing that it grabs all the
methods and says is annotation present
command takes that method turns it into
a command that's available and
this is the kind of code that you would
write yourself if you were doing some
modern programming and now you can do it
in a connector or hopefully soon we'll
be able to do in the connector you know
you can do some really cool things yeah
so we added a two-hour MDB here my mdv
implements to tell no sir but there's no
you know we just we went ahead and added
that hello method darn it IntelliJ stop
go all around and yeah so it was it was
pretty easy when if we commented this
out it would go away and if he added it
would change the name it would chant
have different name all they did was
redeployed the connector was deployed
with the app so you know we can take a
look at I have this set up to print how
packaging for connectors work we propose
no change that but I have a lib jar
which with the actual telnet server code
in it and then I have a 0 to do to make
a RAR file which is a resource archive
that's got that lib jar in it plus an RA
dot XML file and then here's my
application it's got the 1mdb class and
I put my test rawr my test jar in an ear
i deploy that in a server on everything
works
yet the support of the portables the
portable way is to put the RAR in the
ear regardless of where it comes from
most vendors support having the resource
archive deployed separately and I don't
know if they're actually need tests for
that in the tck but there might be i
right right so if once you know that
there are two sides of the same coins I
mean you know you could play them
separately but then you would still be
able if you deployed them separately
with this style you would still be able
to change your MDB because it's using
the dynamic reflective nature to look
for annotations and things like that in
the previous style that would require a
conectar change so you would have to
redeploy the connector redeploy the
application and any existing
applications that didn't implement the
new do hello method they would all be
broken any other questions on that yeah
what whatever you want it to mean it can
mean so sure I don't see why not a JMS
has header parameters like Jack's arrest
does and so you could have annotations
to say automatically pass me in these
header parameters and you know use a
jax-rs style ID type of thing and then
jet you know it would take the parameter
out and co her sit to the right data
type for the free for the for the
parameter that would be really great
object messages and things that could be
passed in as objects rather than object
message than having to pull the object
out there's a really no limit to the
number of expressive changes and
improvements that could be made by
having the ability to allow users to say
but they want out of the message not
just that they want the message which is
really what the difference between
servlets and jax-rs is servlets you get
the whole thing you take what you want
with jax-rs you say what you want and
you don't get the whole message do you
just get what you want coerced to
strongly typed data types that you want
and so that's a really significant
change takes a lot of plumbing out of
your code and i know tons of people who
use jax-rs to do plain old HTML because
they simply just don't like to do all
the pulling out of the query parameter
is take this string and make it into a
long and you know it's really tedious
programming jsf helps with that in some
regard but in a real sense jax-rs does a
pretty good job of a to you could do the
same thing with with JMS definitely I
definitely see the possibility to do
that I mean I don't know how much time
there is to achieve that we have I guess
was it q213 or something is the current
date aya can't remember but certainly
there's potential to to do some very
creative things if there was will to do
so yeah and again you know as you said
at the beginning I'm not forcing that
stuff on anyone yeah yeah but certainly
it it's it's possible are you interested
in doing things like that yeah yeah cuz
it like I said might be too yeah
wonderful
Yeah right Yeah Yeah right giving users
the ability to like I say what they want
out of the message rather than the fact
that Jade they want a message and that's
a really significant change because
instead of writing code to pull things
out you can just say at whatever give me
you know you can get very specific yeah
it would be very nice anything it would
be nice to have like selectors on top of
you know you could have three methods
and a three selectors on top of each
method instead of just one method you
could do some really great things
putting at select your annotation on top
of methods and and really cool stuff
could be done I think people would
really really like it but I completely
have sympathy for the time constraints
probably one of the more pragmatic
people that I know when I'm proposing
something very large it's not realistic
to expect the whole world just jump so
probably 80 or you know you know who
knows if if JMS is already kind of
disconnected from in general in the
sunset is connected to EE through the
connector architecture so who knows
maybe this maybe with the the way that
connectors could work it's more
realistic to have individual
specifications rev by themselves I mean
certainly if this was part of the
existing like EE 7 you could have had a
JMS spec out that did it last month and
then do another one may be done you know
it doesn't work like that technicals we
had to write T CK's and that's a whole
different process but but yeah you know
I I kind of hope because this would open
up the ability for users to write their
own connectors fast that that kind of
improves the model potentially for how
we develop things at a platform if the
platform is extensible and maintains
extensibility and and there's a new
version of the platform like every three
years that's
fine as long as there's the ability to
iterate and do no more dynamic things at
a smaller scope through perhaps like
something like a connector could be
could open up some logistically some
good logistics for faster turnaround but
obviously that's also depended upon
resources and getting TCK is written and
and all sorts of things like that and
then what sort of what a certified mean
if they're all happening at different
times and so that's that's and that's a
different discussion any other comments
we have a most have a lot of spec leads
in the room so if you want to you want
to talk directly to the JCP a lot of us
are here listening okay all right then
I'm going to get on to the second part
and check my time
okay all right so reuse let's get right
into it what I see reuse I mean
annotation reuse ok I think I'm going to
skip into the middle of my thing and
just talk about where we have gone the
whole cycle of configuring things so
here we are in 1998 and we've got an XML
file for everything that's the only way
to configure your stuff and all of your
metadata is outside your application in
XML now obviously the hard part of this
is that in that XML file our
million-in-one references to methods and
and classes and things like that so when
you change your code your XML file
always has to change it's a big pain in
the butt so we go hey let's create some
annotations that's great X doclet they
proved its good idea let's add that to
Java let's add that to the ejb standard
and the java ee in general so now we
took all the XML we made a one-to-one
mapping from annotation to xml so there
every element in Java EE there's an
equivalent annotation and they map
together one for one so in fact the XML
can override the annotations so you can
still configure things externally it's
just still a pain because you still have
to reference us to class classes and
things like that where we're at now is
if we have a an annotation that says
your timeout is four minutes and you use
that five million places in code and you
want to change it to five minutes that's
a lot of updating and if you have an
annotation that says I'm using data
source foo and you want to use data
source bar that's a lot of find and
replace code it's unnecessary so we
don't we're not fully realizing this yet
and this is the point of this talk is
this 2009 thing and in our
specifications starting in Java EE 6 we
started seeing concepts
annotation reuse being able to say this
annotation has lots of parameters and
it's very complicated when I say foo it
means all of that stuff so now I'll just
use at foo on my methods other places
and I don't have to worry about
maintaining that one very large
annotation I'll show you what I mean
specifically and at the end of this talk
if we have time I'll show you just a
little bit of a glimpse on where I see
we could go from here to actually get
the metadata back out of the application
and into XML and a very simple way that
doesn't create code change headaches why
I do that okay so here's what we have in
EE 6 the first and most popular
annotation Reese I don't know if its
most popular but the most used form of
annotation reuse is being validation and
being validation you create an
annotation that implies a certain number
of constraints like a zip code as a
certain number of digits a certain
number of characters and those
characters have to be digits that to be
numbers and then you can stack these up
and so now if someone uses at french zip
code on a particular object in their
class it implies all of these rules so
those rules are effectively inherited by
french zip code and this is where the
bean validation works so it's very very
very the most used form of annotation
reuse that's out there this is it's
implied there is no annotation envy
invalidation that says you must reuse
these annotations it's sort of if it's a
bean validation annotation and it's on
another annotation you must want to keep
it you must want to use it again CDI has
an identical concept it's taking an
explicit approach there is an annotation
called at
stereotype and when you put aunt
stereotype on another annotation the
annotations are inherited so here we've
got at named and at request scope on at
model so whenever someone uses at model
on on a class it implies at named and at
request code the very same way it's done
in being validation except here we have
an annotation called add stereotype
which says do this thing for me if you
use at named and add stereotype on this
on this and you removed it's give me at
named annette request scope on model but
removed at stereotype then when you use
model it wouldn't imply named and
request go so it's an explicit way you
have to say i want this behavior yes
because i know it's a it's very tricky
as so so in this example we have at
model if we're to put it on a beam say a
beam class that beam class by virtue of
the ad stereotype being there will imply
also at named and at request at request
gold if you were to remove at stereotype
from this at model annotation said beam
that uses at model will no longer be
considered to be request scoped and it
will no longer be considered to be named
because it's an explicit versus implicit
design contract a not the order but the
fact that it's on the patient at all
yeah so it's explicit existence on at
model gets this sort of inherent my
other annotations effect removing it you
don't inherit any annotations and that's
good that's a better way than doing
implicitly because not all annotations
that can be applied to other annotations
are things you want to inherit you don't
necessarily want to open that Pandora's
box and now you need a way to say i
don't want to inherit these things
like what if there's an annotation on
there says it's a security role or
transaction are cheap and you don't want
transactions but you you know you need a
way to be able to say do this reuse you
you don't want it to be implicit so CD I
got right and the terms of that it
decided to go with an explicit way to
say inherit these other annotations when
i use model yeah it was implicit there
is no annotation in bean validation that
you must put in the mix of other
annotations that says you know inherit
there's nothing that says when I put
this on here you should inherit not
empty you should inherit not know each
and you should inherit sighs it just
happens the you know the downside of it
is that if you put non bean validation
annotations on here no inheritance it's
a lot of work yeah it and yeah and it's
not even you know the flaw of the
statement was the container when really
the actual the true the reality is
you've got a whole different group of
people that wrote bean validation code
and a whole different people that roots
wrote CDI code even if you put the two
of them together on the same class it's
like completely separate eyes looking at
that code and acting on it differently
yeah so so and that's kind of one of the
limitations jax-rs has annotation reuse
in it as well so most people don't know
that at post is actually an alias for an
entirely different annotation which is
HTTP method post and they did that
because well having to put strings in
your in your code all the time you know
it's kind of a pain in the butt so they
decided let's create an alias for HP
method post and we'll call it post and
they can use that instead when they use
post it implies HTTP method post it's a
cleaner way of designing api's I mean at
a very specific level when you have a
you know you can't use the same
annotation on the same method or target
twice so if someone were to put HTTP
method post an HP method get on
something it would be illegal because
you can't have that annotation
linguistically in Java twice so there's
some times where you have mutually
exclusive options like an ejb you have
at transaction you'll be required and
that transaction tributon never you
couldn't put them both on the same
method and have that making sense if we
had designed them differently so that it
wasn't at transaction attribute with a
genome that said required in a different
medium that said never and it was just
at never and at required there would be
two different annotations and you could
put them together on the same method and
then as a container we got to write a
lot of code to make sure you don't do
things like that it's so it's a it's
difficult to see all the really truly
useful ways it is to just be able to
summarize annotations all right well
let's let's talk about what makes this
not very useful we have these great
annotation reused concepts but each spec
has a slightly different concept of
annotation reuse so everyone's so it's
starting to crop up more specifications
but people are doing it just a little
bit different being validation does it
one way CEO does it with the explicit
way with add stereotype and jax-rs does
it by sort of this mysterious we just
happen to know it works kind of way and
the reuse doesn't span across
specifications so if you put a bean
validation annotation and a jax-rs
annotation on another annotation put
that on a parameter say you wanted to
have an ID you want to have a at query /
am I d and and eject and a bean
validation to validate that the ID was a
number and you wanted to always use both
those annotations every place so you
want to summarize that with say your own
annotation called a tidy well you can't
do that because being validations
annotation doesn't
mix with jax-rs concept of annotation
doesn't mix with any other
specifications form of annotations
because I mentioned these are different
specs there are different implementers
they don't have this level of
cooperation it's not as uniform as you
would want it to be then the most
important one is that the concept of
reuse is only as useful as the number of
annotations that you can reuse so you
can reuse a lot of annotations in bean
validation that's why people use it at
stereotype even though it's just as
powerful doesn't have hardly any usage
because you can't reuse any of the
standard specifications the standard
annotations don't allow you to use that
form of inheritance so it's it's sort of
like a neutered concept you know it's
like great I can reuse all my own
annotations but I want to use the ones
that do all these cool things that the
specifications have put in front of me
like you know I want to go jpa generated
for my ID field and I want it to be at
bean validation not know and I want to
put all this stuff and I want to reuse
those annotations but I can't there's no
way to reuse any of the existing Java EE
annotations so that is the really big
thing that needs to change and if you
want to add this annotation reuse
concept into other areas of the
specifications for app for example ejb
this is really small but you know you
have a trolls allowed manager what would
be sure nice to take a page from jax-rs
and allow you people to say at manager
and at manager has a trolls allowed
manager on it and if we have at schedule
is an invitation that does cron like
syntax well even cron these days has an
at daily at hourly at nightly and you
could put that in a text file it would
be nice and ejb builds the same thing
and have that be part of the standard
standard way of doing things I'll
actually
forget enough time but i will look let's
uh let's just keep going alright so
here's what we're considering at the
platform level this is these are being
discussed and we need a lot of feedback
from people so definitely on this one
pipe up so we could potentially allow
all the specifications to use at
stereotype to imply inheritance we would
then change all of the Java EE
annotations so that they could be
applied to other annotations so
currently you can use for example at the
transaction attribute on anything but
you can't use at schedule on a class so
you couldn't put it on another
annotation and you couldn't use it as a
meditation so we have to change that so
basically all the annotations would have
to have at target type annotation type
added to them so that we could specify
Luka so we could even make it possible
for them to be used as meta annotations
so we have to have a sweeping change of
the platform annotations and then we
would say stereotype is the driver when
you put stereotype on on something you
inherit those other annotations so that
would be one way to do it the trick is
that then you have to enable cgi
everywhere and that's perhaps a good
thing or two perhaps a tricky thing
there are two limitations for doing that
one is CDI is a kind of heavy API for
scanning it you're required as a vendor
anything that is CDI abled you got to
load that class you're not to load it
but you have to create an you have to
you tell the user do you like this class
do you want to change it in some way no
do you like this class you want to
change in some way to dip for every
single class in the entire web app so
that's a lot of time spent doing nothing
so this performance is a problem then
the second one is that CGI is very very
very strict on ambiguity so if you have
at inject and you have the the type list
well if you only have one jar that
seeing CDI enabled in your application
that implements list you're fine we know
what you want you've got one potential
implementation of lists you've got one
injection point that wants a list that's
what the one you get now if we write you
actively just say all the web app is CD
unable then you have like perhaps a jpay
implementation in your thing well
they're going to have a moment ation of
list because you need it to do see jpa
collections well then what happens to
that list now it's an ambiguous
parameter and your application won't
deploy so there are some technical
difficulties that we would have to solve
to use at stereotyped as our driver for
this type of annotation reuse so one way
that they'll completely change all the
annotations which will have to do anyway
so that's fine but then we would have to
say or do you make CDI a like basic
mandatory part of the entire platform
that's not ever optional so that can be
that can be that can be tricky and then
also if other specifications want to
package and give you their own standard
you know derived annotations like Jack's
arrested with at post you know would
those specifications have to have a
dependency on CD I does that make sense
what if you wanted in jp-a to have ID
and at generated as generated ID does
jpa now have to have a a cgi dependency
such that no one can ship a JP
implementation unless it also passes the
CGI TCK well that would be the implied
requirement of using CDI to drive this
so it's a kind of a tricky we're not
sure how to solve it we need feedback on
that another approach is make a new
annotation that is like at stereotype
and doesn't pull in CGI but does all the
same that other annotation we either
being a separate specification or we
would throw it in to say the common
annotations API those are two potential
solutions for that the good part is that
now you can offer annotation reuse to
all the specifications they don't have
to worry about dependencies to other
specifications where they might not want
it it may be easier to convince them
that it's a good idea to do it the cons
is that then we have that situation
where sometimes we create something one
year and the next year we decide it's
not cool anymore so then what happens to
add stereotype do we need it anymore is
it deprecated what's are we going to
tell people and ask us why we got rid of
at stereotype so it it it that's not
also a perfect solution that's the only
solutions that we can think of at the
moment if you guys can think of anything
man let us know and if you have any
thoughts at all you know please please
please send feedback to the e spec list
bill Shannon the spec lead Co spec lead
and he sent out something just a week or
two ago saying you know let's get some
feedback on this proposal when when when
the you know retreat from the cloud
stuff was announced a couple weeks ago
on the e7 platform the proposal that was
brought up that very same day as
something to focus on was this was this
so it is possible and likely that we
will see some sort of platform wide
annotation reuse concept to be the one
that is the one that rules them all and
you will be able to do amazing reuse
concepts but we're not real sure which
path we should go down so if you're the
kind of person who likes to go all those
idiots spec people they had the
opportunity to do it X or Y or Z well
now is your time to be an idiot spec
person so please help we would love it
the feedback be fantastic I don't know
how much time is left I have some
I don't think we have any time anyway
definitely get involved in the specs
this I have a project they're called
meta types also the tiny little library
it does all these annotation reuse
concepts in a very small little jar you
can play around with it yourself I now
so i'll have a whole thing in that
project that shows how ejb might look if
it was allowed to have met annotations
and things that we could make part of
the standard ejb spec in a similar way
that jax-rs but anyway it's great stuff
for thinking about how we want to be a
platform in another you know a couple
years and you know like i said i like
that this is a small group because it's
only a few people who think that way and
realize that yeah you do have a voice
and ability to reach the people and make
an impact and i really encourage
everybody to participate and see what
you can lend to these musings that were
there going to be the rules from the
future so now is the time to you know
now is the time to make an impact and
thank you very much I appreciate it
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>