<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Building HTML5 Web Applications with Avatar | Coder Coacher - Coaching Coders</title><meta content="Building HTML5 Web Applications with Avatar - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Building HTML5 Web Applications with Avatar</b></h2><h5 class="post__date">2013-01-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/MGoBR8p_ztE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon thanks everybody for
coming to this session on the last day
of the conference today I am Sumati
gopalakrishnan amber senior managers and
project avatar is one of the projects
that map that we are managed in my team
project avatar in simple words targets
the best possible options of pearl
averaging and embracing the html5
technologies in the Java and Java EE
world so project avatar comprises of
multiple moving parts websockets service
and events and the data services from
the toppling site and most of the
implementations are in progress is
available on the open source and is
available in the next releases of both
glassfish and weblogic fall 12 at the
main focus of today's session is to
introduce the new programming model that
we have as part of project avatar which
is basically an incubator project it's
an R&amp;amp;D in progress project and it is
mainly targeting for coming up with a
good programming model for developing
the next generation rich html5 based
applications so whatever we are going to
talk in this session is you know going
to in a kind of evolve and change and
part of this will become the java e8
standards what will become is kind of a
to-be-determined activity but the main
focus of today's session is to kind of
thing use this current forum to
communicate what we have so far because
we are at a pretty good milestone at
this point of time to share what we have
so that we can communicate and gather
feedback from
session the couple of days we had
technical keynote and we had the Dhamma
grounds sessions and based on the
feedback what we got on the angry bits
demo which is an Indian application
enterprise application that we have
built using this new programming model
we have slightly altered our agenda
today to mainly focus and deep dive into
the technical details of a project
avatar which is focusing on the
programming model so without further
delay i would like to introduce santiago
and cockle for our a couple of guitar
leads out here who will dig by and show
that well you know befriend the band
show more details of what project avatar
is well thank you Sumati over the last
few days i talked to some of you at the
booth and in other places especially
those that were at the keynote on sunday
and many people were asking me whether
you know avatar is real or is just smoke
and mirrors or what it is it and I been
telling people to come to this talk so
hopefully today we're going to be able
to put some beef into the bun so to
speak so that you can see that it's not
just not just bread here all right so
this is the the agenda for today I
intentionally have a very short agenda
because I want to do a deep dive on the
code and so that you can see some of the
demos running and we can play with them
a little bit that's sort of the feedback
that I've been getting you know stop
showing me slides I want to see the code
and that's what I we're going to try to
do today so we're going to start with
some introduction we have to have some
context before we look at the demo so
that we understand what's going on we'll
talk a little bit about you know what is
avatar what's the syntax and how we
arrived to the syntax that we have now
which is still sort of evolving and then
at the middle of the presentation we're
going to switch to the IDE and we're
going to start playing with some demos
and once we look at that we're going to
go back and sort of review the
architecture and try to understand what
we learn from those demos all right so
let me start with a definition I
typically don't like to read slides but
i think this slide is something that is
meant to be read so avatar is a modular
end-to-end web development framework for
building enterprise mobile and desktop
applications using javascript HTML 5 and
a thin server architecture as you can
see we'll try to squeeze as many
buzzwords as we could in here and I
think we did a pretty good job so i'll
i'll start with the blue parts i think
the the parts that are not in blue are
pretty straightforward we all know what
the web developer framework is and you
know what's mobile and desktop and so on
so the first part is the modular part I
don't think I attended any talk when
where the speaker has said you know we
have an architecture that isn't modular
but in this case is particularly useful
because we're talking about JavaScript
and if you have any experience with
JavaScript it's very easy to write
non-modular code in JavaScript in fact
JavaScript doesn't support modules out
of the box and you end up having you
know really long and hard to maintain
code I think technically known as
spaghetti code so the modularity here is
particularly important the next part is
the end to end there are some other
frameworks out there that also support
end to end and the idea here is we're
not only going to be worried about the
view part but we're also going to be
worried about the services so in fact an
avatar application has both and then
lastly the thin server architecture this
is what makes avatar different from some
of the other frameworks it's some of the
more traditional frameworks and we're
going to try to come up with a
definition for that in a couple of
slides so let's start with the modular
and the end-to-end part basically an
avatar application has its comprised
comprised of modules some of them are
view modules some of them are service
modules so naturally the view
modules are going to be targeted to the
browser and the service modules are
going to be targeted to the server in an
application is going to contain zero or
more view modules in zero more service
modules which means that you can have an
app that is just services or you can
have an app that is just view modules
and we're going to package all that
together and deploy that application
we're going to see how we do that and
naturally the avatar runtime is going to
look at those modules and say okay so
these modules really belong to the
browser and I need to package them and
send them to the browser these other
modules are really for registration
inside the server ok so then server
architecture there's a few different
definitions of this this is the one that
I like the most and I think the one that
hits the nail on the head so to speak so
let's start with the traditional model
or non TSA architecture so in this
module we have I'm sorry in this model
we have a a view and the model there on
the server side and then we have an
application running on the client a
browser typically that requests a
certain page and so what happens here is
that we take the view we take the model
and we sort of merge them together
there's sort of a marriage process here
I'd like to call and then the result is
what we sent to the application and the
result is going to be a combination of
HTML and JavaScript that the browser is
going to execute for us but the key here
is that that merge between the view and
the model happens on the server side now
on the thin server architecture that's a
little bit different I mean we can see
already from the diagram there are some
differences there first of all we can
see that the server is a little a little
thinner right on the diagram okay so
that's why we call it a thin server
architecture but but the basic idea is
that we take the view and we're going to
essentially ship the view to the client
and then we're also going to ship the
models to the client and we're going to
do that merge between the view and the
model on the client rather than on the
server and doing that has a few
advantages it may have some
disadvantages as well as everything we
do in computer science but one of them
differences here is that once we
download the view especially for a small
application we can like download the
entire view in one shot all the
communication we have between the
browser and the server is just for data
so you can see that we have an arrow for
the view which is HTML and JavaScript
and another arrow we that is labeled
Jason because Jason is really the format
that makes the most sense to work with
browsers and the one we use by default
so the models are going to be connected
with what we call services and they're
going to get the data from those
services and once that data comes to
decline then we need to do the merging
between the view and the model so that
so that we can update the the
application and what we're going to be
doing that is using a technique called
data binding and we're going to get in a
little bit more detailed now but the one
thing to remember from this slide is the
fact that the merging happens on the
client so some of the advantages there
is that essentially the DOM is going to
be built only once on the client the DOM
is going to have some placeholders for
the data and once we get the new data we
just go and update the Dom we don't have
to rebuild the Dom if we do the merging
on the server side and we're not using
Ajax we're getting a completely new page
then we need to build a dom every time
we get a new page and so that's
something you see latency wise when
you're using a traditional type of web
server architecture all right so let's
dive a little bit more into the
programming model obviously a little bit
different from client and server but
let's start with the client side so in
the client side we have extensible
component views basically any time you
build a modern web application you're
going to be using components you know
it's like when you're writing in Java
you don't you don't you need to use a
library to write your program you don't
want to start from scratch just plain
HTML I mean it may work for a simple
application but as soon as you get into
the more you know business type of
applications especially you want to use
components and this is something that we
know from jsf and other frameworks so we
have that we also have we make a
distinction between a component and a
widget
so the component is what we define in
avatar the widget is usually part of the
implementation of that component so in
fact we have a pluggable widget sets we
can we can exchange we can change the
underlying widget said and keep the same
component and that's going to change
obviously the look and feel of that
component so I'll talk about that a
little bit more and then when it comes
to the models so we saw in the previous
slide that the models are going to be
client side you know client on the
browser what we what we run is
JavaScript therefore it made a lot of
sense to just use JavaScript for the
models and that's what we decided to do
and then we're going to we're going to
understand where the data binding comes
in place when we talked a little bit
about the UI style that we have so let's
leave that for later and then naturally
we're going to have HTML and CSS I mean
this is part of what building a web
application is all about now on the
server side we have a couple of options
here so in the one hand we can use Java
EE to build our services and in many
cases that's going to be the best option
we can use jax-rs for the rest services
we can use the new web socket API to
build web socket endpoint but in
addition to that we thought it'd be
interesting to explore the idea of using
javascript services the reason for that
is that there are a lot of JavaScript
developers out there that don't know a
lot of Java and in many cases they can
put together a JavaScript service pretty
pretty quickly to support their
applications and this is one of the
areas that we're exploring so avatar
supports the idea of services written in
JavaScript we have some simple api's for
writing rest services servers &amp;amp; Event
Services and WebSocket services all in
JavaScript we're running all this on the
Nashorn javascript engine you may have
heard about this engine at javaone this
year it's going to be open source in the
future and it's going to be part of se8
it's a very fast JavaScript engine that
uses all the new features of the JVM
invoke dynamic and all that stuff and of
course because it is running on Java you
can also use any of the Java API with
in the you can access the Java API
within your JavaScript program and we're
running all this on top of a modular
system called AMD which is becoming
increasingly popular in the JavaScript
community we require Jas and some of the
other frameworks use it it's a very
simple model system for javascript but
it works really well and we're using the
same technique for both the client and
the server all right so let's just
review the concepts that we have before
we run into the demo so that we can
understand what we're seeing so this is
so these are the important concepts on
the client side so let's starting from
the left we have what we call the UI
nodes these are the what I call earlier
the components these are these are the
components you expect to have in any web
at least modern web developer
development framework we have things
like pages forms input tables containers
you know everything you saw in the angry
bits demo it's a un you i know'd in
avatar and as i said before we make a
distinction between the component or the
UI node and the underlying widget that
it's implementing that note and then on
the right hand side we have our models
and this is where we deviated a little
bit from the the traditional way of
defining models so we decided as we
started playing with this framework that
we wanted our models to be a little bit
more intelligent than the usual models
that we build in many frameworks that
follow the MVC pattern you define a
model and then you define a controller
for that model so you always have to do
basically two things so in this case we
decided to say what if our models are a
little bit more intelligent since they
are written in JavaScript you know they
can have methods they can do more things
than just storing the data and as a
result we came up with this idea of
saying well what if we have different
kinds of models that you can you can use
and those kinds of models come
predefined with some behavior that is
useful for your application and so we
went ahead and define these four kinds
of models you have the local model this
is a model that is not connected to any
service it can still be stored it using
html5 storage but it cannot be easily
sent to a service because
it doesn't have any connection with
services then we also have a rest model
for rest services push model for SSC and
socket model or web sockets so what
about controllers well controllers play
a lesser role in avatar for two reasons
one reason is because of this
intelligence that I just mentioned that
we added to the model so there's less of
a need to create a controller all the
time the other reason is that avatar
provides data binding and one of the
reasons why you would create a UI
controller many times it's just to copy
data from the view to the model and in
this case that's going to be done
automatically for you but there are some
cases where you do need models for
complex navigation I'm sorry controllers
for complex navigation or for listening
to you I events and things of that
nature now at the core we have avatar
with the services that it provides
namely data binding navigation we're
going to see that the type of navigation
that we do it's a little bit different
and also things like local storage as I
mentioned and obviously all this is
going to be running inside the browser
there are no plugins or anything like
that it's just JavaScript HTML and Dom
so a server-side a similar picture but
obviously very different here the
underlying infrastructure here for
running these services is NASA worn as I
already mentioned so starting from the
right hand side this time we have
services that correspond to the models
that I just introduced so we have a rest
model a push model and I'm sorry a rest
service a push service in a socket
service and these are the ones that are
going to be serving the data to the
models that we have on the client then
on the right hand side we have what we
call data providers and this is also an
area that is still evolving and we're
analyzing how to do this right obviously
when you write a service the data has to
come from somewhere you know it doesn't
just it's not just there so there are a
few different providers that we're
working on so that you can retrieve the
data if you're implementing your
services in JavaScript in one of the
examples we're going to see the file
provider but we also have things like
JPA providers and are working on a
coherence provider as well and then the
avatar core on the server side provides
routing making sure that whenever you
get a request there's the right handler
for that request either rest a poet or
socket as well as some basic
serialization as much as we could we
went with the convention over
configuration style for avatar so we're
using Jason we're swimming serialization
is always Jason unless you indicate
otherwise so so that's how the the
server side is built so with that I'll
move on to the syntax a little bit we
spend a lot of time talking about syntax
well I always thought developers didn't
care too much about syntax but that's
certainly not the case if anyone says I
don't care about the syntax I care about
the semantics he or she's lying so the
first thing we had to decide is whether
we wanted to do declarative style or
imperative style and it turns out that
they're both good and bad depending on
where you use them at least that's the
way we looked at it so we looked at the
problem of declaring the user interface
first and we thought that we play with
declarative and imperative styles and we
decided that the declarative style was
actually a little bit easier it's also
better for tooling is better for things
like templating that we're going to talk
about and the main reason for that is
that when you write the clarity of style
think HTML or XML or anything like that
you have elements that are nested inside
another element and so on and so forth
and the nesting gives you containment so
it's basically establishing a
parent-child relationship between the
outer element and inner element when you
have to do that programmatically then
you need to create an object and then
create the other object and then say you
know at child and things like that and
then it becomes really boring really
quickly so the declarative solid really
made a lot of sense in our opinion for
the UI and in fact there are many other
frameworks that also use that approach
certainly JSF has a declarative style
for DUI and even javafx has F XML today
now we also thought that there are some
cases where the imperative style makes
more sense
the declarative style and for us those
cases where whenever we had to do models
and controllers so we could have gone
with a declarative style for models or
controllers but then it would it was
very hard for us to add all the
intelligence we wanted to add to those
things so instead we decided to go is
just pure JavaScript for that and
basically take the full power of a
turing-complete language so it's a
little bit strange that I wrote what you
see is what you get here but basically
what I mean here is when you're writing
imperative you look at the code and you
know what's going on sometimes when you
do the clarity of style you know it's a
little bit less it's a little bit more
confusing what's going behind the covers
and we thought that for the models and
the controllers is really something that
you wanted to know what's going on ok
and with that so let's dive into the
syntax so we looked at a proprietary
syntax we looked at XML we look at just
plain HTML we looked at XHTML and we
still haven't looked at creating a whole
new language but I guess that's the next
thing that we should look at and we
decided that at the moment we started
with XML and I'll tell you why in a
moment and but we're also investigating
the HTML route now as you could as you
can tell there's an X in XML and there
isn't an X in HTML and there's a good
reason for that XML is really designed
to be extensible you can define your own
language on top of it HTML isn't there
are some extensions now html5 defines
the data extension in a way to overcome
this problem but unfortunately that
extension is not good for structure data
is only good for non structure data and
we really needed the structure data
extension so we wanted the ability to
use namespaces for those of you that are
familiar with JSF facelets it looks very
much like that and we wanted the idea to
mix components with HTML all within the
same page and that's something that XML
allowed us to do now then the question
is why not XHTML and the reason for that
is that we wanted to have a multi-page
format we're going to see in our
examples why we decided a multi-page
format was better so within the same XML
you're not going to be limited to
defining
page you could define multiple pages and
connect them somehow but as I said
before the HTML is something that we're
still investigating there are some
advantages there you know people know it
they're very familiar with it and it's a
little bit less structure than XML
obviously well the Java is on the
service on this earth when you write the
services yeah that that's right
okay let's let yeah well that's that's
partly true yeah that's partly true i
mean we try to run java on the browser
before it kind of didn't work so I mean
the browser is really designed to to do
javascript and we really didn't want to
introduce another layer there but let's
hold on the questions until the end if
we may so at this point you know raise
your hand if you're tired of looking at
slides and you want to see some code
okay that's what I thought yeah I'm
raising my hand as well so at this point
we're going to switch to the IDE and
take a look at some samples and with
that i'm going to introduce torical here
all right so I'm going to show you some
examples to make you understand a little
better what the heck he was talking
about here and 20 say data bindings what
does that really mean that's dive into
some examples the first app I'm going to
show is called hello and this can be
interesting because i accidentally stuff
the server before the presentation so
see if it works okay so this is a very
you need to make it doesn't look as nice
yeah anyway so this app has two input
fields and some labels and then a text
underneath and a button and you can type
your name in here and the text will be
updated extremely useful application so
and this is a pure client application
there is no server side to this at all
it's all in the browser and that's part
of the whole TSA architecture right as
much as possible with
I executed in the client let's look at
the code okay yeah maybe read a small
can you really hopefully you zoom maybe
I can okay well you'll have to command
option command option + anyway well well
I'll try to explain it from them
hopefully you can see something so this
is this code has two parts to it it's
the UI and then there's the data model
the UI is declarative and declarative is
really superior for building you ice for
when it comes to models and manipulating
data and business logic imperative
programming is more intuitive right and
javascript is ideal for that and here we
were actually bringing the boat the best
sides of the two worlds together in a
really nice way and the one of the main
features in avatar is dead
bi-directional data binding and if you
looked at the example app when I type my
name the text underneath underneath was
updated automatically and looking at
this code you can't really see any logic
here that you know does that that acts
on this event and updates you know a
field and so on and what happens really
is that we're using al the expression
language to bind
new component to a data model or
actually it's binding it to a property
of a data model like in this case and
what happens is that when I edit this
text in the input field the framework
will automatically update the model and
furthermore the model when it's changed
it will also update all the view
components or the UI components that
it's bound to and that's why we call it
a a two-way data binding extremely
powerful and al is here acting as the
glue between the UI and the models so
let's look at next example I can you
know I can try down all right you did
you get the whole thing colors and fonts
right edit let's see how that
I saw better all right that's what we're
gonna have to modify okay so the next
first I'm going to show you the app
actually the next up is called add sub
it's essentially a calculator how about
that it only supports plus and minus and
now there happen to be a bar girl
because in fact is out there is not the
sound but the product and that's because
I was playing around with this just
before the presentation but the point
with this app it's not that it's to show
navigation this app has two pages and
there's an X button which takes me to
the next page which has subtraction is
that and it works the same way and I can
go back and forth this way and for those
who paid attention here you might have
noticed that when I go to the next page
the URL up here is actually changed it
says addition here and then it changes
this abstraction and this is important
because that actually makes the back and
forward buttons work and that's how a
web app should work here when it comes
to navigation so avatar is using URLs
and links for navigation which is
important and again remember this is t
is a which means that all of this is
happening in the browser there is no
network traffic at all when i switch
page like this it's purely in the client
right and that that's what makes is you
I so fast and that's the whole point of
T you say you give a really fast and
and responsive UI and actually Osho the
code of course you want to see the coat
huh and this is again just a client-side
application again it has the UI it's
declarative it has two pages instead of
one here is the navigation it's just a
simple link right that does this for you
and then we have the data model written
in JavaScript and again we have the il-4
binding the UI components to the data
model
it's so the binding is two properties on
this model which is a JavaScript object
but we're also using al for performing
actions and one example is the recep
button here where we're actually using
Yale to invoke a method on the data
model so the e l can be used for both
performing actions and for the data
binding yea ye Lisa standard it's a
special expression language it's part of
what days are ya we have the spec league
right here oh right behind you buddy
perfect oh and there was a bug here I'm
going to just show you that I'm not
mocking all this I'm going to fix this
bug and I do ctrl s to save and eclipse
will automatically redeploy this app so
when i refresh the browser it should now
be edition is that so it's a very fast
turnaround here when you develop thanks
to eclipse in this case and avatar
because we're actually recompiling in
real time or deploy time okay next
example the next up is called store and
now we're going to see a app that also
has a server-side this little
funny-looking app shows a collection of
items and you have the possibility to
delete items and add our times
what did I delete now sorry and this
list this collection is stored on the
server and I can show you that by
starting a different browser store oops
typo
so we have the same collection there so
let's look at the code we start with the
server side so this is the server side
code it looks a lot like the client side
it's XML is JavaScript and so we're
running JavaScript on the server using
NASA horn just like something you said
and this is part of our end-to-end
strategy so you have a framework which
uses the same format the same java
programming language for both client and
server and this opens up of course for
all you web developers out there that
has done HTML and also you probably mean
for your whole life and you love it so
you want to stay there right you don't
and you don't have to leave the
framework you can build your whole app
from end to end without moving to
another framework or leaving this
framework okay and let's look at this
code quickly now I think we don't have
too much time so we're declaring a rest
service and this rest service list
listens to a URI URL for HTTP requests
and it has the option to you know return
in the data or do some kind of
processing in this case we're getting
some data from a database and returning
this and avatar provides a number of
data providers which gives you access
into jpa for data storage or you can
store into a file or something like that
which makes it really easy to build a
day
centric application which which is
processing data you don't have to move
over to Java to you know access the data
you can do it simply by declaring a data
provider in this case it's storing into
file and you can access this data
provider either excuse me imperative Lee
or declaratively depending on what
you're doing so if we look at the client
side again we have the the UI its
decorative we have the data models and
in this case their rest models and
instead of the local model in the
previous examples and the rest model
when it's loaded it will get the data
from the server and it receives the
response and it will automatically
deserialize this data and update itself
with that information typically it's
JSON data and thanks to the again thanks
to the data binding this model will now
populate this data to all the UI
components that has a binding with this
data model and this is done using this
very powerful eel based data binding and
another feature I would like to mention
which is not in use here so in html5 and
there is a new feature called local
storage which is useful if you want to
store state locally on the drive while
you're offline you can keep working with
your application and when you go off
online again you know you still have the
data there and in avatar by simply by
simply adding an attribute called local
store to a model instance declaration we
will automatically store
your state your data in this model on
the desk using local storage and when
you go back online we will automatically
fetch the synchronize with the backend
server data and if there has been
changes on either side or both we will
take care of the merge and all you need
to do is declare which merge policy you
have so you all you need to do release
add two attributes to your data model
instance and automatically you will have
local storage really a powerful feature
the next example I owned up to to
example left this one is called tickers
and it is going to demo how avatar is
using sec servers and events this will
app sorry there we go is basically
pushing out data / sse and in this case
its stock prices of course they're not
real they're just generated and if we
look at the yeah look look at the source
again we have our XML and JavaScript
that's all we have and in this case it's
a push service not a rest service and
this push service again it will listen
to the declared URL for incoming SSE
connections and this service based on a
timeout it will use the push context
here to send this data to all the
connected clients to this sse service
this is oh I should mention that thanks
for asking so right now we have an
avatar plug-in two clips which is giving
us syntax highlighting for JavaScript
and XML and it also gives us some
content assists and some other features
like that well there are some IDs that
already have this I know intelligent I
think actually can do this already with
their standard XML editor and and I'm
not sure about we can leave the
questions to the others that we can
finish the demo fee let's let's all that
question will do the questions
afterwards but it's a good one thanks so
let's see here is the client code again
we have the view and we have the mole
and then we have the binding between you
in the model this is a push model works
just like the rest model it will connect
to the given URL that you declare here
on your instance and then it will
receive events when it receives the
events it will automatically deserialize
the data and update itself and then
thanks again to the binding it will
populate this data to all the UI
components that is bound to this model
okay last example
is a chat application which will use web
sockets it has a login page and then you
log in and get to chat room and I'm
going to use one more browser here to
see if we can get some communication
going so here excuse me we have two
clients connected to this web socket
service on the server side which I'll
show in a second and we can type
messages back and forth like this yeah
you get the point so look at let's look
at the service code chat service exactly
like the other services except this is a
socket service and you declare your URL
we will listen for web socket
connections coming in and here we're
using the socket context to send when we
receive a message send the map that
message to all the connected peers and
finally let's look at the client side of
this and again we have the Goo Goo ease
and that's the carry and we have the
models in JavaScript this is a socket
model and it receives it connects to the
WebSocket service and it receives events
over this socket when it receives in
event it destabilizes automatically and
in updates itself and then populates all
the UI components thanks to this
powerful two-way binding and yeah to
summarize this T is a gives you really
fast GUI
declarative UI superior and JavaScript
for imperative logic business logic the
best of two worlds we have the powerful
bi-directional bindings and it's an
end-to-end language the same language
for client and server you don't have to
leave the framework and then we're using
rest and SSE and web sockets for
communicating between 5 and service
thank you and I will be here if you want
ask but with the questions that's it
yeah okay Thank You torkoal running a
little bit late so I'm just going to
skip this one because we looked at it
already so now that we looked at the
examples it's a lot easier to explain
what the architecture is of avatar on
the right hand side we have the server
architecture architecture sorry we're
running on top of Java EE namely glass
place for we have a couple of specific
components from avatar that are serving
these applications we have something
called a view service this is
responsible for delivering the UI to the
browser we have the data services which
are responsible for the implementation
of all the JavaScript services as you
can see both services are connected to
the Avatar compiler the source as you
notice is XML and JavaScript the browser
doesn't understand that it doesn't
understand yell or anything like that so
some compilation process needs to take
place and we're also using NASA one as I
indicated before or the JavaScript
services but of course you know you're
running under Java EE so you can write
this using jax-rs using WebSockets API
etc on the client side we download the
other application which may have
multiple pages multiple modules even and
we custom-make a Navitar runtime for
that application so if your application
only uses 5 UI components then we only
send the code for those UI components
and then naturally we're running inside
the browser which is an environment on
its own and that provides the Dom the
local storage that Torico alluded to
as well as all their UI functionality
and you can see the communication is
HTTP HTTP or web sockets depending on
whether we're talking about view or data
so we mentioned data binding data
binding is actually very powerful and
almost essential for any framework of
this kind the idea behind data binding
is that you have the model you have the
view and you need a way to merge them
and you don't want to write controllers
to always do that because it's a very
repetitive work avatar supports two
types of data binding one-way and
two-way this depends on the type of
component that you have an input
component would typically be two-way an
output component would likely be one way
there's also like a zero way data
binding if you will where we only have
an action associated with that with a
property we've seen some examples of
that if you click a button or something
like that interestingly we also support
data binding for HTML you've seen in
some of the examples that we support you
can embed HTML inside those examples and
you can also also use IL expressions
with other examples it's also supported
in the framework and we actually use
that quite a bit so here's an example of
data binding we have a model at the
bottom call MDL with two variables name
and school and then we have data mining
with two different UI components
naturally this happens a lot you have
multiple UI components that are
connected to a model in Waikiki in one
case we have an output component which
provides just one-way data binding from
the model to the component you see that
in the arrow in the other case we have a
checks checkbox which is actually
two-way sort of an input component so it
provides both way which means that any
time we update the model the check
checkbox gets updated and vice versa so
we looked at models and services and it
was a little bit of magic behind all
that there were some cases where the
model like in the tickers case was just
defining the variables but there was no
logic behind it the way we do that is we
use JavaScript prototypes if you're not
familiar with JavaScript prototypes they
are similar to base classes in java
javascript is not that class based
languages language and therefore if you
want to add behavior common behavior to
multiple
objects you use what it's called a
prototype so here's an example of how we
use prototypes we have a socket model in
this case on the client that is
redefining the on message and thus and
methods we're using the the convention
of using a dollar sign in front of those
to indicate that they are framework
methods and they're intended to be
overridden but then there's a lot of
other behavior that comes from with the
prototype and in many cases you don't
have to redefine that for example as i
said in the tickers case where we're not
doing any redefinition we were just
taking all the defaults for example the
default in a model is when you get a
message DC realize the message and you
update the model and exactly the same
technology is used for the services we
have the notion of prototype for
services and this is the reason why you
have to specify what kind of service it
is or what kind of model it is so in a
way what we're doing is we're using XML
as metadata for JavaScript in these
cases JavaScript doesn't have a note
something like annotations if it did it
would we would be using that and so that
the XML that we provide gives us gives
the framework the information it needs
to set up the right prototype and the
right default behavior for that model or
service so here's an example in code
I'll just go over this very quickly on
the left hand side we have a chat model
and we're redefining one of the methods
the one of the methods from the
prototype and we are also calling the
prototype method in this case because
there's some functionality that it
provides that we don't want to write
again in the same way you would do super
dot in Java and on the right hand side
we have an example of a service that in
this case has to override this method if
it wants to do anything interesting with
the message that it's getting we see a
we saw a little bit of a navigation
navigation is a little bit different in
Avatar because as as I mentioned the
view can be downloaded all in one shot
it actually downloads it one module at a
time but you can have many applications
that are just one module so navigation
happens in the so called hash scheme of
the URL which means that we don't
actually go to the server to get
whenever we update the hash scheme we
don't have to ping the server and that
our avatar supports a lot of components
many of those components support support
the notion of a pain which
can think of it as being apart in a page
and and some in some cases those pains
are not shown they're not visible for
example if you have a tab container that
has multiple tabs some of the paint's
may not be visible at a particular time
so if you want to make those visible
what you can do is you can use this hash
scheme to indicate that you want to
navigate not only to a certain page but
also to obtain within that page in
addition to that we have parameters just
in like in the traditional way and those
are particularly useful for example if
you have a table and you select an item
on a table and you want to get a
detailed page of that item many
applications would actually use
parameters to pass that information to
the next to the next page and in fact
that's so convenient that we define a
global model in avatar called dollar
location that is cut it always going to
be bound to the value of this hash
scheme as it's always going to be
parsing and updating itself whenever the
hash scheme updates and the nice thing
about this model is that you can use it
anywhere like in a URL or in a place
like that and whenever the navigation
takes place the model gets updated and
because of data binding so get so does
your component get updated so this is a
little bit about the java the avatar
archive it's at the moment it's just a
zip file we have a top level directory
avatar and then we have a directory for
the view on one for the service and
within that we have directories for each
of the modules that are in the system we
don't actually have a hierarchy her
article directories here so we only have
one directory poor or good example hello
and now not three director is nested
wanting into each other and then
depending on whether it's a view or a
service we have different places to put
the different components and the reason
for this is that when you're writing an
HTML application there's a lot of
boilerplate that you need to generate on
the client side so by us having all this
structure we can do the generation of
that boiler plate for you for example
setting up all the loading all the
JavaScript resources CSS images and
whatnot so on the server side we
basically have this as the same
structure except that obviously we don't
have CSS or images or any static content
like that in addition to that we have a
properties file where we indicate a
couple of things whether we are in debug
mode or not
for example and also the type of the
widget set that we want to use so we can
go into the archive change the widget's
said and then change the look and look
and feel of the application and I don't
think I have time to go over the
advanced concepts so why don't we open
it up for questions and if you want more
detail about this where we're going to
stay a few more minutes thank you very
much for coming so I don't think we have
microphones so if you could speak up
yeah yeah you say again what are we
using yeah we are currently have support
for three widget set we using dojo
jquery UI and jquery mobile not at the
moment no harm yeah
good question you have a couple of
options there one is a project easel
have you seen anything about it yeah so
that's one option the other option is
using tools that are provided in the
browser the browser already has
debugging and all that most browsers do
so you can actually use the debug in
there
I
an issue meaning it gets disconnected or
something or what you said our client
may have an issue well that's something
that you need to work ahead of time but
I don't think that's specific to client
too thin server architectures I mean
even if you have a thick server and
you're generating JavaScript you know
the client may not take it I'm not sure
if it's next I'm going to go here
okay so so dojo is a completely
client-side solution there is no server
piece there's no computation out the
server they actually do have a
declarative style but they process the
declarative style in the in the browser
so it doesn't help you with boiler
plating and all the other things it
doesn't have a declarative data binding
or any of those things is is more like a
JavaScript library if you will yeah yeah
we're still exploring at this moment or
all of our testing is done using
selenium I don't know if you're familiar
with the UI yeah oh you were talking
about the services or
yeah no we don't we don't have anything
specific for that just yet yep good
question good question ya know you don't
want to put the business logic there
right so you put it behind your rest
services
yep
unfortunately it's not available just
yet um as we said at the beginning it's
just an incubator project I don't know
maybe someday it will be it will make an
announcement when we make it available
does that mean that you liked it or
sorry there's one there yep that's a
very good question well we just think
that there are JavaScript programmers
out there that they want to have the
same programming model on the server
side and there are some other you may
have heard about other talks about
JavaScript on the server side this is
not the first one so so there's this
thought that there's a community out
there that wants to do services with
JavaScript so that we you know we're
thinking of providing as an option as we
explained here but it's not you know if
you don't want to do it you don't have
to yeah
no no we're using in fact the
implementation using is using al to the
two is to dot to we hope to upgrade to
el3 when it becomes available that has
lambdas and other cool stuff in them but
we don't know we haven't changed the L
at all if one more question yeah go
ahead ok good question so you meaning
there in the JavaScript service ok right
so JavaScript nastran runs on top of
Java which means that you can access any
Java API from JavaScript there is an
interface to do that it's quite easy
actually
well there are a lot of stem there are a
lot of powerful things in JavaScript on
itself you don't always have to go to
Java and in addition to that we have the
data providers which in many cases are
going to solve your problem without
going to job yes there is this would one
data provider was JP a that's why we
provided that's what we give them a
provider you don't have to write it
yourself that's the whole point it is
that's that's that's what we get paid
for it no no the providers is it
providers is completely server-side it
no no it's not no no no you got that
wrong we don't you have our own module
system we're using the AMD module system
which is becoming a standard in
JavaScript no no no for at runtime the
JavaScript it's all generated AMD
modules which is a AMD modules requirejs
many other javascript frameworks are
using it we haven't created our own
module system for that I think they're
going to be posted I'm not sure where
but you know this like all the Java I
want slides are going to post it in the
same location anybody knows that sorry
yeah
you mean other than using HTTPS or
something like that
not at the moment but as we said we're
an incubator project so we're a little
bit far from there but obviously you
know SSL is going to be supportive
good question we actually have a story
for that because we have a compiler on
the server side we have the ability to
do i 18 n for you and what the way that
works is all the components have I
didn't get to that slide actually it's
this one here when you define a
component the component has a number of
properties huh some of the properties
are going to be of type data bind they
want to be connected to the model other
properties are going to be more like
labels okay and then we have metadata in
those properties that say this property
is an i 18 property so when we do the
compilation we generate essentially an I
18 table for you and we can also because
we're server-side technology when we
deliver the view we can look at the
initial request and determine what's the
right language for to deliver to exactly
yeah and we actually have a process for
generating those resource bundles by
just inspecting the the program so you
don't have to write them by hand so we
try to avoid this style of having to use
a key and then having to update a table
we try to generate some things for you
yeah again I have to ask you the same
question did you like it all right
please send us feedback I don't know
where but yeah we can set something up
you know Twitter i'm on twitter if you
like it or you just like it or you like
this part or not that part I've been
more persistent on Twitter yeah yeah
yeah we can said something else you
think we can set something else yeah but
not public at this point there's no well
thank you very much for staying</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>