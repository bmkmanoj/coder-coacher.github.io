<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Patterns for Modularity: What Modules Don't Want You to Know | Coder Coacher - Coaching Coders</title><meta content="Patterns for Modularity: What Modules Don't Want You to Know - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Patterns for Modularity: What Modules Don't Want You to Know</b></h2><h5 class="post__date">2013-01-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/iBp0lbK0mxE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everybody and welcome to our
session for Pettis form of modularity my
name is Lauren shahadat and I'm
assistant professor at the effective
organizational science that's University
of Belgrade Serbia and together with me
or else I our stock to lock he's from a
NetBeans a team from product working
Oracle and Anton Anton Apple his from
company appleton IT consulting today we
are going to talk about various
experiences of while developing modular
applications and I guess all of you are
aware of them and during your work e you
got to them but it's a good way to
summarize them in some way and to show
you how you can use some interesting
tools so you can discover patterns and
dependencies that you might not be aware
of during the development of your
application so maybe we can ask hope you
is using with you using modularity in in
some some way yeah okay okay osgi that
next is few Oh netbeans module system
what else do we have like spring okay
wait cool thank you yeah so the next
tier session should be focused on screen
right you can imagine so those are that
we mentioned not too few popular modular
system and our approach that we look at
the patterns that we are familiar with
in UML design a class design and we met
them on the onto the modules just on to
the higher level basically the game is
same just at the higher levels of
abstraction so what the definition of a
design pattern is the general reusable
solution to
commonly occurring problem in start to
design which simply means that some of
mistakes we are many of us are making
the same mistakes and we should be aware
them and avoid them and some good
solutions can be also applied to
different context and that that what
auntie pad pattern is exactly auntie
pattern is a pattern that may be
commonly used but it is ineffective and
counterproductive in practice and is
some kind of best practice that people
tend to use because at some point of
time it is easier to just make something
work and deliver the application so what
are the commonly occurring problems when
creating module applications well we
always want to make our design reusable
so we don't have to create the same
things again and again we want to make
it flexible so when trying to request a
change we can easily apply the change
without changing too many code and we
want to have a good dependency
management between modules so we are
taking care that the application design
and overall structure is maintainable
during the application lifetime so here
is the key to the modularity which was
defined by Tony two years ago and
up-to-date they're still stands so I
will kindly ask Tony to explain to us
he's 65 principles of modularity well
thank you very much
well I just scribble down these five
principles of modularity which are
actually six and you will have to
comment and explain why Utley why hits
why it's only five because one of them
is inherently present in another another
so it's really quite fun so maximize we
use I mean they're they're quite they're
quite obvious so you we are supposed to
maximize reuse and pattern is nice if we
if it helps you to maximize reuse
minimizing coupling is another thing
there are a lot of deeper coupling
techniques like using service provider
interfaces service infrastructures
dealing with change that is also very
important so there are a couple of
patterns especially in the NetBeans
api's that help you to develop your API
to increase your API to improve your API
and change it without breaking
compatibility so dealing with change is
very important for modularity because in
module systems you have like these
contracts between the individual modules
each maintenance that is probably
inherently present in do with changing
deal with change yeah these
extensibility so patterns that help you
like creating plugins and safe resources
those are patterns that deal with for
example lazy loading you could think and
only instantiate about only instantiated
stuff if you really need it so those are
the patterns that those are the
principles that should be applied to
assess if pattern is good or not yeah so
if you're wondering sometimes should I
do this or not you can evaluate
according to these principles and see
what are the gains and water the losses
sometimes you may gain
for your reusability but that mail
actually leads to the code that is easy
to maintain in a long term for some
reason so this is the game actually
there is no perfect modular design
because the requirements are changing
and 4 during application lifetime you'll
be adding new features and changing
existing and it's the design of
application which may be solid in the
beginning may become very messy over
time and it's very hard and sometimes
unpredictable in which way it may go
yeah that's true but I saw a study that
75 requests for our changing your code
base usually comes with feature requests
something at new functionality and only
the 25-percent are restructured the code
switch to different technology so for
example for us River I to javafx it
would be the technical change but that's
not as common area often nature's that
was the point you are not changing the
structure for vacation just because you
want to change it because it is nicer
and that's the way it should be done
it's because you need to add new
features and you need to change the
existing one yeah so when but when you
are about to estimate the future
evolution of your application but on the
new feature requests yeah so our idea
one of the things that we we did is to
use some graph mining techniques to
discover dependency dependencies and
issues in large modular application and
it is a pretty simple approach we
extract the module dependencies we we
are using netbeans platform application
and then load those dependencies into
some graph processing application we
have used the GFE
which is often at this platform
application and then play with the
algorithms that are presenting a fee to
discover to show you what you should be
looking for so i will show you how it's
done so this is doing some back project
scanning still oh it's not it's gone
mine we have slave fun so let's open for
start one simple application it's called
Europe studio step in platform
application for creating neural networks
and since I've been working on this
application I know what its current
issues so it just is it open it
tofu
ok
but there is it
but concedes
this week
shut down this from Owen same
I will sit here or just maybe I should
turn off this right yes now for this
year
okay so this is the graph dependency
fancy graph from our application and
here what we can do now is to view these
algorithms and say it show the notes by
using degree and we say that it's using
size say minimum size is 5 and maximum
30 and we can now identify the modules
that have how do you center distance
Travis okay okay the family that have
are lots of dependencies using layout
algorithms and let's turn on module
names so we can see what's going on it
can even make them bigger right like
this so this is the project suit it's a
model shoot so all other models depends
on it so it's okay this is the biggest
one red but the other one data read our
potential issues will they might not be
but they have a lot of dependencies and
when they had a lot of dependencies
those are the one that you should look
at so I know what's wrong with this
design and it's also clearly shown on
this graph because when we were creating
this application it was a swing
application and removed everything from
an existing application to the main
module and some of them some of that was
in the next iteration or development
extracted into the IDE module so these
are two modules that most other models
depends on so if you we do this we can
see what
depend on modern man and you can see
that those are mostly almost all modules
in application so we should be hearing
some issues you know well I guess the
more modules use the more other modules
use certain module the more careful you
should be when you are making a change
that yes you can influence a lot of
other stuff yeah two things then that
might be a principle that you very
simple that you should always ask
yourself is if I change something in
this module what else do I have to
change do they have to change a lot of
things and if I want to deliver this
module into some other application what
other models do I have to deliver let's
how I figured out that this design is
pretty bad when I realize that when I'm
delivering for example support for image
recognition I also have to deliver
support for stock market prediction and
ken writing recognition which is
unrelated maybe someone donates because
of the dependencies to the main model
and the IDE module yeah I use the term
heavyweight a module is because the
outgoing dependencies of a module
basically described the environment that
is necessary for that module to be used
and especially when you are trying to
take certain module and bring it from
one system to another like we are doing
when we are sharing functionality
between netbeans and jdeveloper or
between red beans and Eclipse then
basically we don't we are interested in
us in one module but then we would like
to we also need to get all the
dependencies so the more heavyweight the
module is more parabolic reuse as well
so what we came just loaded is the model
dependency for the Wizards API from the
NetBeans all right okay so yeah there's
more complex application that's more so
you see was issue when you give a simple
application with the ten modules then
it's kind of obvious and you know but
when you have this situation then Kevin
just picture in front of you I'd be a
very useful especially when you have a
tool like a gay fish so you can say okay
let's do a degree so we can choose input
a degree and output degree and degree is
the sum of the input enough so how many
modules depends on some module right and
what other modules depend on that money
so we can do the same thing I like to
use this color degree ranking and size 3
so we clear get that look up everyone
depends on the look up here let's get
true but there is one of the basic
infrastructure right in the
infrastructure so you can always think
about Moses you know a kind of maybe a
to think about or tired or layered
architecture so you have Moses which are
related to infrastructure and then
implies the specific domain in every
module system you basically or the
framework in India module system needs
to give you a chance how to register
services and discover services and with
that's almost necessary feature of each
module system osgi has support for
services and that means as well okay and
actually in that means this is done by
the lookup API that's the reason is so
heavily used yeah anything out anything
else that is wrecked yeah that is
interesting here so you cannot bring in
better now so so you've got a spring in
bedroom yeah yeah okay
this layout algorithms there are a
variety of them is this one maybe Tony
can explain but it you know the biggest
models are in the center and you see the
smallest are around them and what we can
also do use this filtering the porgy
filtering right and use degree rank put
in there and let's say we don't want to
look so which wich one else which ones
are the most prominent ones here
utilities API look up and here it is see
we can filter doubt all modules will
have small number of dependencies and
just analyze so what do you have to stay
in your defense oh well this shows the
important api's basically yeah so and
actually all these modules are api's
that those are not implementation
modules so it's fine that they are used
a lot and of course if you want to deal
with files which is exactly what the
project support does it needs the
dependency on data systems and file
systems API if you want to work with
java sources then yeah it's okay it's
the dis using java source API as well
yeah the other thing you can do is take
a look more at the modules it's very few
number of dependencies you know so it
only will explain it over the position
so these are no no
Tony will explain the positive possible
scenarios can you comment on this so the
modules with very few usages are those
implementation modules usually yeah for
the statuses because national right so
there are a variety of things that so
actually if I don't know if you've got
one turning if you've got AP ice turning
up here then you've probably got a
problem that i referred to as ghost
towns or premature modular recession
that happens a lot actually so you have
a lot of a lot of guys who are eager to
create nicely modularized applications
and in the end they will only have one
implementation ever in their life and
that might be a problem and usually
modularization should be driven by some
purpose yeah if when we started for
example the NetBeans jdeveloper sharing
then we needed to make certain modules
like more lightweight remove that
dependency separate them into two parts
so we can just take the important part
and move it into different environment
and so so basically the module ization
should be driven by by needs it will
tell you the right granularity for
particle unique no so these are some
anti-patterns right it's Tony will
explain you that's my contribution for
this year making up good names for her
police thing and the first one is is
clandestine dealings and that is
basically when you have AP is there are
AP is that exists but they are
undocumented like for example there's
the there are magical strings that he
costs in somewhere some system
properties that you can set but it's
nowhere documented that this exists I
think yard I had last year
I had the had one nice example that even
made one guy in the audience yell at him
oh yeah because because I was recruited
to critical about osgi osgi
specification allows you to install a
module it has metal install bundle and
it takes string parameter which is
called URL so i was thinking okay i can
put that file URL i can put there HTTP
URL and yet that really works but in
eclipse and in felix both which are two
different implementation of of the osgi
api of GI container you can always you
can also perfect the URL with reference
a verte form a magical string and this
means the container will use the file
from a disk without copying it into some
own directory and this is of course not
documented anyway it's a it's a magical
API ok so the next one is prohibition
which is a phenomenon that that goes
with prohibition like when when we had
or week when you had the prover the
United States at the prohibition the
guys wanted to drink alcohol still found
ways to drink alcohol right so there are
lots of tricks that developer are doing
to still get to call into the api's you
into the implementations that you don't
want them to like for example they are
using reflection or I think you
mentioned that the che rebel guys in
their presentation said people they see
they commonly see people doing bytecode
catch patching to just a call in to
things that they shouldn't but on the
other hand it's clearly beyond the
boundary those people know that they can
shoot themselves into their own food
yeah it's well but as I guess any of you
we we tend to find interesting methods
in implementations and and casts cast
the implement cast as the implementation
if nothing prevents us from it and I
think I'm i did that and module systems
make it more complicated to do it but
they don't really prohibit you from
doing it and I recall a lot of times
when I I was dealing with XML parser and
stuff like that they've got very
interesting methods and the api's can
you know I'm losing power okay so what
so let's talk okay okay so the next one
I think it's not a very the next one is
H marriages and that is well it does
look like an interface while if when it
looks like an interface that can have
several implementation it isn't because
somebody introduced a dependency so the
whole system actually depends on the
implementation while it looks like the
system only their hands on the end
interface and that is something that you
see a lot of times in in module systems
and I've also seen it in in that means
once no no I'm impossible ya know is
when when we wanted to create a
different window system and you can
imagine the window system from that
often that means is very good so it's
it's very rarely with somebody like to
create a different implementation but
there was a customer and they wanted to
have like a window system implementation
where you have floating transparent
windows over one central radar screen
basically and so um I found out about
about this problem it was a known
problem chassis had already written a
book report about this but but it's
there so somebody has in a different
module has taken the the interface and
costs
posted it into the implementation and
with this we were done basically and to
evaluate this according to your 65
principles yeah this is increasing
coupling and that's bad of course and
that's a bad thing yeah we already
talked about ghost towns premature
modularization so when you do modularize
your application it can add complexity
and it's not always a good thing and
it's also something that I've seen a lot
since a lot of you are using spring that
is a very typical pattern in in spring
that there are a lot of developers who
are you simply create interfaces for
everything and I've seen I've seen
people creating whole whole object
relational mapping to just copy a
database or stuff like that your comment
on it oh yeah basically in netbeans when
we are developing some api's usually
it's a feature request driven deliver
creation of api's i'm often being
require at least two independent use
cases maybe even free before we try to
create an API because well maintaining
KP ice is slightly cost quickly exactly
it's so if you have just two copies of
the of the code somewhere then that's
not okay it's that's simpler but on the
other hand I also know that if you want
to expand if you want to stimulate
evolution basically then it's good to
create a new API for example in that
games i created the command line NPI so
people can really pass the parameters
that are passed into the netherlands
based running application and different
modules can participate on passing the
command line they can cooperate with
each other and at that time we had just
one module using the API so it it goes
against the principle to introduce the
API but I think it went really well
because there are many usages people
found the API useful so in case you want
to increase evolution you need to go and
risk the gusto right it's in it's an
interesting it's an interesting story or
so that that when i found out that it's
actually well it's actually obvious that
it's a lot of work to maintain an API so
when you open up an API you have to
maintain it and that's why developers
usually don't want to create API is
because they will be responsible for
that oh yeah so you have to fight you do
a lot of fighting like I remember that
with the XML multi view API there were a
lot of people using it outside of
NetBeans and they wanted to they wanted
to use it but it was very I think it's
still not an IPF right oh yeah well it's
a no more multi viewing those guys who
created the API just are really afraid
of stabilizing it but the good thing is
that they don't touch it that means it's
stable enough and the usages of that API
don't get broken over time that's at
this good sign it's don't touch it if it
works better right so the next one we've
got here is eager beavers and eager
beavers is is an anti-pattern in
that you can see for example in an osgi
or an Evans module system there is that
there is there are life cycle methods
like in osgi activators in netbeans
module system it's called module
installed it's basically the same huge
mistake yeah and those are classes that
are called when the module is loaded so
people use them to set up services or to
connect the databases do stuff register
things and that was that that's an old
pattern basically osgi has found better
ways of doing service registration and
they were not if the clarity of way and
that means module system it did that as
well but if you do that a lot the object
will be created very early and they will
maybe never be used there is a price to
that and actually I call it a syndrome
of most important functionality whoever
developerworks on some module like
support for PHP or support for uml
inside of NetBeans links all this is
something everyone has to use so let's
initialize it at the beginning but most
of the users don't use PHP so they start
my beans but they paid the price of the
initialization if it's done like it will
be yeah so the next one is bigger me and
promiscuity and I think at least that
that's what I'd shut it down as note I
don't know if it really fits the name
but it is incompatibilities between
different implementations so that is
something that we sometimes see you've
got an API but the API defines
interfaces it does not necessarily
define the behavior and different
implementations might behave differently
so for example we had that once in
in look up which is a very important API
and the thing was that you have to in
some implementations call a certain
method first before listeners would
would be registered correctly and
listeners would be fired the events
would be fired and but only for certain
implementations and so that is that is
clearly not in the in the API in terms
of of libraries you cannot define that
but the order of course but it was
causing trouble I know so the only way
how you can deal or fight against that
is to associate your API also with TCK
press compatible ticket so that's a
basic generic set of tests which
everyone who is providing implementation
can run against their implementation to
verify its compliant enough and actually
we have TCK for look up but this this
test was not there now it is that it's i
guess the issue is fixed we have also
TCK for file systems and I beans has
about a pluggable file system API and we
have power system for accessing remote
computers over ssh local disk zip files
and we need to ensure that it behaves
correctly so for that we have TC k as
well okay then we get one other one and
that's the small world phenomenon and
that is probably something that a lot of
you have seen and a lot of companies are
fighting against like for example in
Munich where I'm coming from BMW has
this blueprint where they limit the
libraries that can be used inside the
application the small word phenomenon
means everybody knows everybody over six
hops basically so developers especially
in their younger years tend to simply
reuse work done by others and maximizing
reuse is a good thing
but if for even for small functions you
you in you grab a new library that does
what you want and it's the only small
thing you might end up with a lot of
dependencies that you that you need to
maintain and they're basically you
manage to maximize reuse yeah so you are
using but you completely prevented reuse
of your module because nobody can use
you you have really have avoid
dependencies and they're using hear you
you really hard actually increasing the
weight right yes yeah viva recently
dealing with some application and it
really contained every possible library
so someone's each developer had their
own favorite json parser so Doug by free
of that and well I it has it effects the
final final application instead of the
server to start in one megabyte it needs
one gigabyte so and I can I remember
from my from my earlier days as a
developer that I was doing so much
pruning basically and finding oh
actually libraries in Italy I mean it
even happens that there are no actual
dependencies it's just like you you take
one library and it ships with all these
other dependencies with all this other
jar files so what you do is for
convenience you just include also all
these other Chavez if you need them or
not so that is basically what I what is
the small world or LinkedIn phenomena
and when gliding are continue with what
example about modularization that VA had
in netbeans so that means 90 the
NetBeans design started somewhere in
1997 and well it was not bad design what
we wanted to achieve is to have a one
module
it all the api's for for accessing the
IDE functionality then another module
with implementation of those api's and
then many modules using the API and
communicating Kruger API providing Java
support HTML support and stuff like that
so we had one huge module with all the
api's and we find it out that that's
probably not good because not all the
api's are needed as frequently not all
the APR and not everyone needs ability
well when there is an object that you
can copy or delete shoot is also have a
method can compile can debug that was
our original design and there was
completely completely wrong because the
fact that you can copy something doesn't
mean it should also even know and care
about compilation and debugging so what
we did very slowly realized that having
one module with api's is wrong that we
need to split it too many modules and
yeah in in the year two thousand five we
really did it and we started with
compile time separation so they still
produced the single jar file but we
tried to clean up the dependencies
between those 14 parts and it wasn't
easy at all the original vision was that
for example notes API should not depend
on windows that but the reality was
completely different and that happens
for many applications that you start
with a clean design separation and
dependencies between packages but unless
you are prevented by compare compiler
not to make dependency of calls between
those parts for sure
you will do it or one of your developers
will do it I guess this is something
that happened to end the original and
design was really nicely separated
package by package with dependent
division with directed the dependencies
between packages but it was just a
logical design and now when you look at
interdependencies between and classes
it's a mess so we had to compile time
dependency at and that allowed us to
prevent future aggressions in 2007 we
really separated the 14 modules into
into individual parts into individual
files but the problem was that
immediately we started to have a
performance regression because module
modularity is nice but there is some
price to pay for opening and reading
classes for 14 files instead of from a
from a 15 especially when it when all of
these were on a class part yes so we
need you needed to do something with
that and we created some caches that
returned the performance the startup
time back under control now we are
probably faster than at the time yeah
and actually having the fine granularity
and having modularity is a nice way how
you can eliminate certain modules I like
to say that API ap eyes are like stars
so basically you cannot get rid of them
as soon as you publish an API you should
it should be there you don't know who is
using it you should keep it but with
modulated that is ave how sent a star
into a black hole how you can basically
deprecated and slowly remove a certain
api so we did that we decided that the
options api is wrong and that we want to
get rid of it so is slightly arranged
the dependencies between these modules
separated the options API into own
module and River out all our other
modules not to depend on it but we
didn't know about free party
implementations so they could still use
this API on the so we included API
internet wins installation for those who
want to use Edmunds platform but it was
disabled still it all smooth migration
path basically in case somebody depended
on the options API they could they could
still use it and it got enabled but it
printed warming input into a log file
saying okay don't use it it don't use
this so basically modular systems should
help you even with deprecating API sand
moving forward cleaning your api's and
easing maintenance I should probably
mention that this story is also part of
boob that I just finished can you switch
to the browser on please yeah so this is
cover of my two years old book but i
just finished new one do you have a
browse okay okay yes so in case you
visit paradoxes dot API designed a
torque you will be able to see the 20
API paradoxes book okay that's probably
all from my son do we have
yeah no that's the end that's yes do you
have any questions yes
well I I prefer being credit for changes
of course having some design or one of
the paradoxes talks about api's saying
that most of the time when you design an
API you are not a developer you our
sustainer because as soon as you publish
first version of an API your creativity
is limited you need to keep backward
compatibility you cannot remove methods
you cannot refractor classes so doing
the first initial design right is
beneficial but on the other hand you can
never be completely right you need to be
ready that you will need additional
changes so the important thing is try as
hard to do the first version correctly
and then also do it in a way that you
will be able to improve the design over
the time anymore
so that's it folks thank you for coming
and we hope you not to find this device
is useful</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>