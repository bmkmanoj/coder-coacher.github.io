<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Data Storage for Embedded Middleware | Coder Coacher - Coaching Coders</title><meta content="Data Storage for Embedded Middleware - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Data Storage for Embedded Middleware</b></h2><h5 class="post__date">2013-01-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Rzw0ewx1kGE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so what we're going to do today is
to talk a little bit about Java embedded
suite which is a new product that I
recall has announced just recently but
we're going to focus on Java DB which is
one of the components of that sweet so
the Java embedded sweet trip over this
cable if I'm not careful is is a package
of a java runtime and a collection of
middleware for that is targeted at
embedded gateway type devices so you've
got a java SE embedded runtime a special
version of glassfish called glassfish
for embedded sweet java DB and Jersey
which is a framework for restful web
services and essentially what you can
think of that we're doing here is
bringing java ee technology to embedded
gateway devices we've taken so we've
taken these components done some
squeezing will be doing more squeezing
and crushing and cramming in the future
to continue to size reduce and optimize
the components of the embedded sweet and
obviously they're supported together as
a whole product so Rick why I'm you know
as as a java DB person you know why java
DB well i'm glad you asked that question
java DB is a full relational database
the codes but around for 15 plus years
it's the same bits as Apache Derby it's
being developed in the open largely by
Oracle shoulder to shoulder with IBM in
the patch Derby community it's as I said
it's a full-featured sequel database of
comes with all of the sequel object
types that you expect and all the the
sort of sequel security expect all of
the crash recovery you expect
transactional behavior but it fits in a
very compact 2.6
mega by Java thank you so I guess one of
the points here is that Java DB is
actually easy to use so all you're doing
is including that one jar file if you're
it actually has very very extensive SQL
support and so especially if you're a
you know an enterprise Java developer
then and you've done any sequel with a
bigger database then I think you'll find
that you got a very very familiar sequel
dialect to deal with yeah absolutely
it's a Java DB that the code grew up
after the sequel standards been approved
so we had the luxury of implementing the
most portable of the sequel dialects
which is an see I solo sequel standard
and suddenly when I used I found that I
actually got very good performance from
for the the things that I was writing
without really having to do anything
other than you know implement the jdbc
calls that that did what I wanted well
excellent that validate so the story
we've been telling so so there's there's
a lot of you know code in there that
actually looks at the environment and
works out appropriate defaults for page
sizes and things like that right that's
right it was originally designed 15
years ago to be an embedded database and
to be a database that could be dropped
into shrink-wrapped applications and not
need a database administrator so the
whole idea is that the database should
be able to tune itself configure itself
and come up with reasonable defaults for
your environment okay and we'll talk a
little bit more about that later on in
the presentation as well and then
flexibility is another important point
because one you no one-size-fits-all
solutions don't often fit or sometimes
they don't for any right absolute
and with java DB you can being a pure
java database means that all sorts of
features can be coded by you in java and
plugged into the database and there's a
different list of these features up here
yeah so you know the the encryption is a
good thing for a for an embedded
database and that's extremely flexible
because for the implementation of that
it relies on the underlying java
platform so and that is a pluggable
framework so if you're on a device that
say has some hardware encryption
capability then you can if there's a
plugin for the JRE for that then java DB
will benefit from that automatically
okay so we've actually a little bit of
code here so you can you um just tell us
about what's on screen absolutely so
what this shows you how you go about
creating how simple it is to go about
creating an encrypted Java DB database
and then reconnecting to it later on all
you have to do is add some extra little
attributes to the connection URL you can
see that there's a secret password there
in the connection URL clearly you
wouldn't hard code that string in your
application but anyone who is bringing
up in an encrypted data store its
familiar with what they have to do to
protect that password yep so actually
getting a code yeah an encrypted
database really is that easy it's that
easy you just have to add a couple extra
bits to the URL cool sure go ahead
cover later prophecies came to the same
we could will be talking about how how
Java DB fits into the system and we can
certainly cover multi-user during so if
you bear that in question in mind yet
we're playing a constraint yeah when we
get to the right slide so what we wanted
to do today was just to run through a
use case and talk about how we would use
Java DB to support that this use case at
least in outline so think of you know a
gateway system and embedded system which
is monitoring monitoring controlling
sensors and devices around a campus so
there's a lot of a lot of information
that you're accumulating you want to be
out of process process that information
intelligently use it to make decisions
and process it and forward it to to a
central location potentially you know be
able to generate alarms and warnings and
then end up with processed information
rather than just a big stream of sensor
data so this is kind of a you know this
is where you know this is kind of
showing showing the the overall
architecture that we're talking about
here so on the left hand side you can
see a bunch of different representations
of different kinds of sensor and control
device and in some cases then you don't
want these devices connecting directly
to the backend in other cases then those
devices may not physically be capable of
connecting directly to the backend so
you need in those in those circumstances
you need some sort of gateway or
aggregator system and Java embedded
suite is really targeted at that kind of
system and Java ME embedded is is the
the the Oracle Java product that would
be targeted more at the the edge devices
over on the left-hand side
there look excuse me I've been into too
much talking today I think so Rick can
you take us through talking about the
database schema and it's kind of the
first thing you need to think about when
you're thinking about using a database
to store information absolutely so since
this is a full mess qol database you
have at your disposal all the sorts of
sequel objects that you would expect in
a real database you have tables you have
views you have triggers who have
constraints you have functions you have
procedures you have user-defined types
you in a coming release we're going to
have user to find aggregates not in this
first release of Jess and you have the
familiar SQL fine-grained access
controls that you're from the you may be
familiar with the grant revoke and roll
management so that you can protect
certain operations or sign them to
particular users and limit the
privileges that you give to other users
ok so the kind of information you need
to store in this use case then is
obviously the data that you're receiving
if you want to you know secure access to
the system then you're going to need
some sort of you may want some sort of
credential store in your databases
obviously are not the only way to do it
and then you know device metadata and
configuration is you know something else
that your application will need and as
mentioned then you can use access
control to partition these things and
grant access preferentially to the
different kinds of information that
you're storing in the database so on to
some sequel Rick absolutely so one thing
to point out is that java DB comes with
a very rich set of built-in data types
there's basically a data type
corresponding to each of the java
primitive types with the exception of
the 8-bit byte
in addition there is there are a couple
byte array types there are large binary
and large character object types there
are date-time timestamp types and as I
said before there are user-defined types
so any Java type which extends which
implements java.io.serializable can be
used as the type of a Java DB column or
function parameter okay so so what we've
got here then is is based you know
simple table that you can use to store
the kind of information you'd be
receiving from sensors and you know this
is this is kind of an example use case
that we put together just to show some
of the capabilities of Java DB so you've
got you know a timestamp field in here
waited the day to come from and what
information did you gather about that
location when you sampled it
so often you want you want to persist
java objects into a database obviously
there are you know object relational
mapping technologies you know GPA and
hibernate we'll talk about those a
little bit later too but if you're just
wanting to if if you decide that that's
overkill for your embedded application
you just want to you know simple way of
storing your objects into the database
then you know seems like you've got a
couple of options Rick sure you can
certainly flatten the objects yourself
and into rows which is of course if if
you think that you're ever going to need
to search or a sift based on the fields
inside your object I recommend doing
that and I even recommend doing that if
you don't think you're ever going to do
that because you may not think you're
going to do that in rev one but you may
discover in rev three you really want to
do that but if you truly don't need to
ever search or sort or query on the the
fields that are embedded inside your
object then you can just as long as the
object implements serializable you can
store it in a column now suppose you
have a very large object graph that you
want to store in a column and there's
maybe one or two little bits of
information squirreled away somewhere
inside that object graph that you think
you want to index on well in that case
you can use something which we call
generated columns in a generated column
is an expression that is run at insert
or update time which can be used to
pluck those indexable fields out of your
your your object graph and put them into
their own columns in the row that you
can then build indexes on and this will
cause your queries to run very fast even
though what you've got is essentially an
opaque object there in the column so see
your kind of using using the you know a
column in the database is kind of a cash
it's stuff out of the objects exactly
another way to look at it is that your
pre compiling your query
results yeah yeah okay so basically two
options here key value storage or or
flattening the object into into
different columns so moving on to a sort
of a jdbc topic you've got a one class
called statement that you can use to
just run some sequel another class
called prepared statement what's the
difference between those rings well the
importance of the prepared statement is
that it allows you to to precompile your
query plans and it basically what
happens when you prepare a statement
java DB compiles the runtime form of the
statement and puts it in what we call
the statement cash and the key on the
statement cash is the statement text so
once you've compiled a statement and
it's been it's in letting in the cash
then the process of reusing that
statement is really fast because it's
just a key look up you don't have to to
recompile it and and we highly recommend
that you do this and that you use
prepared statements and if you have
variables that you that distinguish your
statements from one another use a
prepared statement with the ? parameters
and just before you execute the
statement plug the specific values that
you're interested into those ?
parameters well what's in example doing
that in a moment so essentially what
you're saying is that you'll get better
performance and better memory usage
absolutely if you if you use prepared
statements instead of instead of plain
statement yep and as it says up there
you'll also get protection from sequel
injection attacks please
the sterilizer than bucket for you
that's done I can see cases really have
an object crowd and that's may not be
sold field
uh-huh no we don't have an example of
that but if you come up afterwards we
can we can write it out for you yeah
okay so on to some some more code
examples so we talked about 11 piece of
using the database in this application
would be to just accumulate sensor data
so what we've said here is that you know
imagine that we have a class that will
just call center snapshot and that gives
you you know if stuff you just received
from somewhere somehow so as with most
you know most code that's going to do
anything with the database then this is
going to be able to throw a sequel
exception which you either have to
swallow and deal with insight here or we
have have your method throw that and let
someone else deal with so then here
we're using a java 7 feature here you
know try with resources so if you're not
familiar with that syntax then this you
know where we're actually allocating
this prepared statement here and if the
if there's an exception thrown inside
the try block then the the Java compiler
will automatically tidy up this resource
for us and it avoids us having to
actually explicitly code the you know
catch and the and do and closing down
this statement so it's a sure hand
that's kind of nice and you know
syntactic sugar that the compiler does
we
it can it could be remote if you have if
you introduce the right driver into yeah
yep I mean it's Java embedded sweet is
is is full it's full embedded se so
embedded se is essentially headless java
SE so you've got a full jdbc
implementation so any any jdbc driver
that works with SE will will work with
with java embedded sweet so brick can
you um can just take us through the
prepared statement sure there's actually
I'm very simple everything that you
could possibly use as a variable has
been replaced in this statement with a
question mark parameter and then I think
on the next slide you're going to see
how you actually poke the specific
values into the statement added just
before you run it hmm so so based on
going back to the prepared statement
versus statement thing then it's
actually this string here that the
starts with insert and finishes with
this bunch of question marks that would
be the the cache key to decorate for
this for this statement so any time that
you you know as long as it long as you
don't as long as still in the cash
anytime you prepare this statement you
then java DB will just go back to the
cash and fetch it again that's right
android yellow overhead exactly mmm sure
right but every time you execute this
you will get the current the the sequel
interpreter inside Java DB will look up
the current timestamp and plug it into
that particular column in the table
that's right right don't think that it
is the current timestamp at runtime not
the current timestamp at compile time ok
so yeah you refer to the next slide so
there you go ok so there you have it the
you're using the the JDBC setter methods
to to just poke to poke your sensor data
into the ? parameters and then you
execute the statement very simple so
anyone else feel please feel free to ask
questions as we go along if you if you
have any so you can see here how how
those question marks in the prepared
statement actually get you know actually
get to have real data values associated
with them so this none of the things
that you want to be able to do on the
gateway device is to do some kind of
processing of the data and that doesn't
necessarily have to be Java code that
you write because you've got you know
functions built into the Java DB sequel
implementation allow you to do a whole
bunch of things and this the sequel
statement in here is actually it's
relatively short but it's actually a
little bit subtle I'm going to ask Rick
to to explain that all right so what
we've got here is a kind of a gnarly a
query and the backstory behind this
query is this so you imagine in this
application that your sensors are waking
up once a minute or once a second or
something and they are sending their
snapshot snapshotting their state to the
gateway device so that goes into
the the Gateway Java DB database so the
idea here is that you don't want to send
that whole fire hose of data to the to
the server at the at the end of the day
what you want to do is you want to boil
it down you want to aggregate it you
want to summarize it and come up with a
single row a single summary row an
average row over an entire hour for each
room with all of its sensor data so
that's what this does it sittin just
uses the standard SQL average aggregate
to do that to do that work so it's this
is what you get for free for having a
full relational database on your gateway
yeah so it wouldn't be that hard to
write the Java code to look through all
this data and group things in two hours
based on the timestamp and whatever but
you know even so you can do it in one
line of SQL yes and it will be done
efficiently because all of that
aggregating is done in the in the
database where you can take advantage of
things like indexes yeah so you're not
having to read read every single row of
your of your table process it and then
then end up with the data you really
wanted in the first place yeah and so
the another way of looking at this is
it's going to run through internally you
know select all the rows whether the
timestamp is between you'll start
hearing you're in period and then it's
going to take those individual rows and
say well these five rows here will
belong in the same hour so we're going
to group you know Group oohs together
and run an averaging function as
described here across the across the
different columns and then you end up
with one row per hour of in the result
of this so and then there's a slight um
you know this is a little different in
terms if we go back to the previous code
where previous example where we were
doing the insert then we saw you know
heading to you know give that assign
values to the question marks in the
update we're doing something slightly
different here because we're actually
doing a query not an insert a graffiti
Rick right and and once again you've got
another try with resources block here so
that eliminates some some boilerplate
that you don't have to write when the
when you're done looping through the
result set the Jerry will make sure that
the result set is closed and your
resources are are freed up so
essentially what what happens here is
this what this while loop will simply
run through each of the rows in the come
back as the result of the query the
select that you thought you ran and then
you know this is this is entirely made
up code but you want to do something
with the result of the query
so device method eater and you know
preferences and you know configuration
of how you want me the application to
operate today that that kind of thing by
storing that in the database then then
you have the very easy ability to change
that and potentially even change it
remotely so we've got you know this
looks like an example of key value
storage array absolutely so I'm you
frequently find when you're writing a
data-rich application that you need a
table of odd bits odd little
configuration environmental facts about
your application about the device where
you're running and so just it's a it's
an excellent pattern to create this this
very general key value pair table and in
this case that the table has got a key
which is a string and the value is a
user-defined type which is bound to
java.io.serializable so you can store
anything in that payload column yeah
obviously a big idea to pay attention to
all the usual you know concerns about
making things serializable so that if
you end up having to change the classes
that you're serializing into the
database then you'll be able to unsee
realize you know old classes that are
that are pre-existing in the database
so then reading stuff back that looks
pretty simple to that that's pretty
simple you're just reading everything
out of your yorkie value a table and
well you're printing it out which is not
what you do in a real application but it
you can see how easy it is and they're
against your try with resources buck so
in this sort of contrived example then
we're actually just reading all the
metadata you know rather than looking
for a specific piece of information by
the key sure
right that's a good question so now you
certainly can you don't in defining a
user-defined type you could bind it to a
more refined type than just serializable
and if you did that then yes and the
advantage of doing that is you will get
runtime type checking in this case of
what we've defined is is the most
general kind of payload possible just to
serializable you probably define some
you know superclass in your your
application and that kind of type safety
is a good thing yep read object yet
wells theatre alright then that's where
you go yep
okay move on from that if you meant to
delete that slide before we got here but
nevermind so I know we talked about the
fact that Java DB is kind of self you
know pretty much self configuring but
there are always going to be cases where
you do want to you need to set something
some non-default thing for your
application so how did you do that right
so basically they're there are a number
if java d beads defaults turn out not to
be the right ones for you you can you
can customize those defaults by setting
system properties and you can use system
properties to customize things like
cache sizes and security settings as I
said those are you set those with system
properties you can store those system
properties in in a single tidy file or
you can you can store them in the
database itself and if you store them in
the database itself then you lock them
down which i think is a good design
pattern because that protects you from
people making mistakes if someone boots
your application with the wrong command
line and it also gives you some
considerable protection from security
experts so basically you you can figure
this through a properties file yeah and
and you're done yep so again pretty easy
now I'm sure your code is always correct
first time Rick but Tom yeah when I was
writing some code recently then you know
I had to do some debugging so the fact
that so in the Java DB that we ship is
part of the Java embedded suite is using
the embedded jdbc driver right what yes
trying to explain what that means the
embedded GD 0
right so javi to be comes with two jdbc
drivers one is a driver which you use if
you're running the database inside the
same vm as the application okay and in
that usage mode there is very little
context switching when you go between
your application code and the database
engine so there's no process switching
there's no thread switching it's really
fast jabra to be also comes with a
network jdbc driver although this is not
included in the Jazz bundle okay and if
you and then if you are running with the
jdbc client and the the java DB network
server then you can connect from
multiple different machines to a single
database and and you have multiple
connections note that even when you're
running embedded this is a full multi
user database so you can have multiple
multiple connections multiple
transactions all going on at the same
time and your concurrency is well it's
basically limited by your application
design you get a design yes now I don't
know what it means to put that on top of
gesso I don't know whether that voids
your warranty but uh I don't think so
okay good so one of the things that I
found I was writing some code recently
and you know I the whole thing wasn't
quite working and I wasn't quite sure
whether it was my glassfish
configuration that was wrong or whether
it was my database code that was wrong
so I wanted to I got to the point where
I just wanted to know are we actually
even touching the database and so you
know i found that found that it's really
easy to you know to set up the
properties file that you use for
configuring page sizes and things
and just by putting a line or two into
that properties file then you can ask
Java DB to tell you what queries it's
executing so you can actually tell that
it is executing queries you can it can
tell you about you know any exceptions
that are being thrown things like that
and then I'm sure that as you develop
more complex applications than I was
developing recently then performance can
can be become a concern absolutely
absolutely and one other point I want to
punch up on this slide is which I think
you touched on briefly is that if you
plug in your own code one of the cool
things about being an embedded job
database is that you will be using the
very same debugger on your application
code which is running outside the
database and on your functions your
procedures your types your aggregates
which are running inside the database so
it's a very powerful programming model
and it makes you very productive so you
but you can also when it comes to you
know looking at how the database itself
is performing then you can you can look
at how you know what how query plan is
being set up and the performance of
individual queries if you need to get to
that level of detail yeah okay so i
guess the performance took really ought
to come from you as the the java DB
expert right and i think that at the end
of the slide deck you give a pointer to
justice to some extra material on how to
how to fine-tune your java DB
performance so they'd big first and
foremost use prepared statements use ?
parameters bash your updates into
transactions don't commit after every
row it seems things may seem kind of
obvious but it's worth pointing out it
is it's it's worth pointing out also
that in there are applications which
don't need persistent data they just
need Tran
data for instance if you're if you're
processing a fire hose of sensor data it
may be that when you turn the devices
off you don't care that the do the the
data goes away it's only while the fire
hose is going by that you're interested
in plucking information out in making
decision in that case you can run java
DB purely in memory and this gives you
an extra performance boost but you can
also do this kind of Jew allowed things
where you run the database in memory and
then periodically or you essentially
copy that back out to persist in school
and that's another interesting design
pattern absolutely yeah
control
well that you would you or you're at so
you mean if you're running with an
in-memory database and then you want to
snap shot it to to to disk just before
your application exits yeah you you need
to adds a little scrap of code to make
that possible I think that at the end of
this slide deck there's a pointer to the
talk that dog gave earlier this week on
an introduction to Java DB and he shows
an example of how to do that of how to
snapshot your your in-memory database to
disk as your during application shutdown
and how to read it back in when your
application comes back up here that's
right that's right and you when you run
in this mode you just have to make sure
that in the event of a sudden cabin
depressurization you you you you know
what to do it you know if someone turns
off the device in the middle before
you've done an orderly shutdown you have
to have some way to be your your
application has to tolerate a disaster
like them we don't have any built-in
checks for that you'd have to code that
in your application itself it's an
interesting feature that might be worth
them built building out for more support
yeah yeah but as far as as far as
implementing that based on what's there
today then provided that you build that
you build the majority of code based
around a connection then it's really a
question of is that connection pointing
at an in-memory database or or a
persistent database right and then so
you could you could see
yeah exactly so even yeah so even
without even without any special
functionality in the database you can
actually build your application and you
could put some logic in there that could
switch switch connections out underneath
based on oh it's it's wednesday i want
to be persistent or what we have okay so
there's two whenever you talk about
logging with java DB there's there's two
logs to talk about there's a transaction
log which is not what we're talking
about here and then there's a diagnostic
log and the diagnostic log is something
that is well it was it was developed 15
years ago before these other packages
who are out there now it is you can plug
in your own your own print stream to to
control where where the diagnostic log
goes but it doesn't use any of these
packages that you just mentioned
although it's on our it's right it's
it's it's on our radar screen yeah
yep yep and-and-and by implementing your
own print stream for for the for the
logging you can you can do that
filtering yourself within that stream
but your I I hear what you're saying
about about the nice some filtering
features that are built into those
logging packages absolutely yep yep
okay so if you're ready to get started
using Java embedded sweet then you can
download an email copy from the Oracle
technical network it's been available
there since last week and there are a
bunch of places you know but Oracle and
apache where you can get more
information about both the embedded
sweet and specifically about Java DB and
there is as Rick mentioned you know
there's a presentation online now that
dark here gave earlier in the week which
is a more basic introduction to to Java
DB and there's also a lot of information
there about some you know where Java DB
is is is used that could give you some
ideas to please
10 incher son question for Europe we we
have been developing Java DB in the open
shoulder to shoulder with IBM since 90
what 2005 and so far they the two
databases have been bit for bit the same
we haven't needed to we resist the urge
to fork but we do have clearly we have
our own name java DB and we reserve the
right in the future two to four core to
add features to to an Oracle product
that would not be in the open source
version but right now same bitch okay
well that's the end of our presentation
if you've got any more questions then
we'll be happy to take those yeah the
back there
right so the question is do you have
access to the statement cash that's and
so that you could tweak the query plan I
believe that was the question there's
two answers to that question there's
always two answers to a question yes and
no so let's start with no you don't have
direct access to the statement cash but
by using certain procedures which set
the the database in a certain state you
are able to snapshot what the query
plans are and then when you understand
what the query plans are you can tweak
your queries not that not the plans
themselves well you live but you can
tweak the queries and you actually can
tweak the plans themselves using
something that we call optimizer over
arts did that answer your question okay
thank you other questions not quite sure
what you're asking
we used to have these balance packages
databases
well you can always pre prepare your
statements yeah and so and that that's
the design pattern that some people
follow so when your application comes up
it warms itself up before anybody
actually uses it and all of your
statements are prepared yeah but but we
don't provide you a way to pre prepare
the statements and store the compiled
forms in the database though the people
who worked in the in the the sequel
interpreter had a very bad experience
with that at a previous database and so
we've ordered doing that that is correct
you have to warm up the the database it
before you let your users in if you want
to get if you want the first preparation
of the query to not incur the the tax of
compiling it
but not for dramedy be in Java DB
triggers and procedures are written in
Java but once you but there's plenty of
there's plenty of SQL that you can
include in a trigger by itself but once
your trigger calls a database procedure
then you're stepping out into into Java
code that you've written yeah other
questions okay so please accept 14
minutes of your life back from the John
related sweetie</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>