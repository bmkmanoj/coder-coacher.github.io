<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Introduction to SQL Pattern Matching in Oracle Database 12c - Part 2 | Coder Coacher - Coaching Coders</title><meta content="Introduction to SQL Pattern Matching in Oracle Database 12c - Part 2 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Introduction to SQL Pattern Matching in Oracle Database 12c - Part 2</b></h2><h5 class="post__date">2013-07-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/hdp9kpw8Uf0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to
of this series of three podcasts on the
new and very exciting 12c sequel pattern
matching feature my name is keith Laker
I'm a senior principal product manager
for data warehousing and big data at
Oracle and if you have any questions
about sequel PAC matching please feel
free to contact me by my blog the aim of
this particular popper podcast is to
provide a little more information about
the keywords and features of the 12c and
matching clause and I'll be doing some
demonstrations during this podcast to
highlight some of these keywords and
features for a general overview and
matching please listen to part one of
this series of podcasts so let's start
part two of our podcast let's look at an
overview of our data set that we'll be
using during the demos our data set is a
table called ticker and it contains
three columns symbol date and price
there are three ticker symbols and we
have 20 rows of data for each symbol
just in case you missed the first
podcast in this series here's a quick
refresher of the syntax of the new match
recognized clause as you can see there
are a lot of keywords and features and
we'll explore some of these during the
demos don't forget the 12c database
documentation is a great place to learn
about this exciting new feature and of
course make sure you listen to part one
of our series of podcasts for a general
overview of panel matching now let's
quickly explore a demo environment okay
looking at a demo environment we have a
little script here don't we're running
and here's our table ticker as this said
we have three columns here symbol
timestamp and price and you can see here
we have 60 rows and all the data is in
date order with our three symbols
playbacks Oscorp and me
and as I said we have 60 rows and if we
look at some data relating to each
symbol and see each of the symbols has
trade data starting on the first of
April ending at the 20th of April and we
have 20 rows so that is our demo
environment there are four basic steps
to consider when we're writing our much
recognize clause the first thing we need
to do is define how to group and order
the data so that we can discover the
required patterns secondly we need to
define the pattern itself and the
variables that describe that pattern
thirdly we need to determine what
information we're going to return in
terms of data points and any related
aggregates and the last step is to
determine how the output will be
generated the following series of slides
take you through each of these four
steps and the parts of the match
recognized clause that relates to each
step step one bucketing and ordering the
data at this point we need to determine
the best way to bucket and sort the data
so that we can search for a pattern and
the two key phrases are partitioned by
and order by if you don't use the
correct partition by order by clauses or
you leave them out you may get
unexpected results so it's always best
to have at least these clauses as part
of your match recognized statement and
we'll go into what happens when you
don't put these in or you get the wrong
during the live demo so now let's start
building up our statement to create a
form that recognized Pat
search the partition by Clause lets us
bucket the data into specific groups and
in this case we're going to group by
symbol and the older by clause as you
would expect sorts the data into an x
pacific order and in this case we're
going to organize by timestamp so now
let's look why these two features are so
important and to do that we'll look at
how to organize your data using a live
demo environment so let's flip over to
our live demo environment and we've
still got our data set running so let's
keep our script going and now we want to
look at how to bucket our data so here's
our select statement at the bottom here
don't worry too much about the other
elements of this statement - that we're
interested in will be appearing here at
the moment we're just using the order by
element for timestamp and we've just
created a simple default always true
event called e which just says where
price equals price which is always going
to be true so here's the output first
thing to note is that we've got 60 rows
which is what we'd expect because we
have a simple almost true event and our
data set will reach right way back to
the 1st of April so what is wrong with
this data set what is wrong is or what
may be unexpected not necessarily wrong
but unexpected is the order in which the
information has been returned so you can
see here we have a globe X Oscorp and
Acme but if we go further down we go to
globe x2 oscorp's
who globe X and Acme so why
is this not correct why is our data in a
random order and it's because we have
multiple entries in our table for each
time stamp and we are only ordering by
timestamp so beyond that the order is in
effect going to be random what we really
need to do is to make sure our data is
in the correct order to highlight or
make visible our pattern and we're going
to search for is to add a partition by
clause which you can see here so we have
partition by symbol and order by
timestamp again just using a very simple
always true event of e where price
equals price so now let's look at our
data set and now if we were going to try
and search for a pattern with image
ticker it's much easier to try and find
that pattern within each tick in here
because our data set is logically
grouped by symbol and then by actual
trade date and again we have has 60 rows
of data returned because we have an
always true that so now let's go back to
our slides and move on to the next part
step 2 of building our closer
now we're back from our demo let's move
on to step two and this is where we
define the pattern we want to find
within our data set to do this we use a
regular expression length syntax that
will be familiar to users of languages
such as Perl the really innovative part
of much recognize this allows us to
search using sequel cross road
boundaries for patterns and we'll see
that in the next slide now because we
can search across road boundaries we
have to clearly define the data points
that we want to reference within the
match recognizer clause and this will
become clearer as we work through our
SunPower examples for those of you who
want to explore much recognized clausal
deeper you will notice that if you check
the execution plan for your match
recognized statements now you'll notice
there's a new row source but we won't be
covering that in this session now in
this example that you see on the slide
here we want to search for a v-shaped
pattern within our data stream and this
consists of a series of events where the
price decreases and then increases we
describe this pattern in two parts the
pattern statement uses a regular
expression like syntax to match against
the rows in our source table in this
case a down event must be followed by an
up event the defined
statement provides the details of what
the pattern means and it describes the
down event as the current price being
lower than the previous price as you can
see we have to be careful when referring
to data points to ensure we're looking
at the correct one in terms of either
the first data point the last data point
previous/next
min or max data points there are a lot
of ways to describe the pattern and you
should refer to the 12c
documentation for more information so
now let's move over to our demo
environment
and
and begin our next example of how to use
the match recognize a statement for this
example we will enhance that pattern and
slightly change power always driven this
time we're going to refer to the date
column and compare the current date with
the date in the previous row this takes
us back to the point we were just
discussing in the slides so e is now
defined as timestamp must be greater
than previous time step this should
result in an always true event because
we've included an order by timestamp
Clause and we're probing on the event
that the previous timestamp is lower
than the current timestamp however note
that we've removed the partition by
clause which might give you a clue as to
why the output is not what you'd expect
so why do we only get 19 rows back when
hopefully you were expecting to see 60
the answer is because like earlier we
have multiple stockticker entries per
timestamp and this time there's no
partition by clause so in many cases the
current date is the same as the previous
day given that we have prices for three
stock symbols each day so let's add our
partition by Clause back in and
hopefully you were expecting to see 60
rows in fact we only get 57 rows why is
that well this is because the very first
record in each data stream has no
previous timestamp to compare with so
the e event is not true for the first
record which means for each symbol we
lose the first record meaning only 57
raised or returned what we need is a way
to identify the initial first record and
we can do this using the identifier strt
or start
and we'll add this dummy event to the
patent clause and now when we run the
sequel all 60 rows are returned so now
let's return to the slides and continue
with our review okay we're back from our
demo environment and now let's move on
to step 3
this is where we define the measures
that will be returned by our much
recognized clause as before with the
defined statement we need to be very
careful about identifying specific data
points because as we'll see in our demo
the same result does not always mean the
same result and don't worry I'll explain
this during the live demo the measures
Clause allows us to define a list of
columns for our output table and these
columns can contain the navigation
operators like those we've used in
previous examples such as last along
with other navigation operators such as
previous/next and first we can also
include any column from the source input
table and because we're using sequel for
a pattern matching processing we can
actually include sequel aggregates such
as count sum average min Max and this
gives us a significant advantage over
the other non sequel based declarative
languages such as Perl which have no
concept of aggregates now to help
developers DBAs and even business users
we provided two specific building
measures to help you understand how your
data is being processed and those are
classifier and match number now
classifier returns the name of the
variable within the overall pattern that
applies to a specific row and this is
the pattern variable that the row is
mapped to by a row pattern match as with
the match number feature this can be
used during testing to help developers
determine if their pattern has been
correctly defined and is returning the
expected result ie is the same result
the same result as I said in the demo
we'll explore this a little further
match number returns the sequential
number starting with one for each match
of a pattern in the order that they are
found and this makes it easier to
analyze how your pattern criteria are
being applied so in our example here
we're going to retrieve three date
stamps relating to our v-shaped pattern
the start date of each v-shaped pattern
given by start time stamp the date when
the bottom of the v-shaped pattern is
reached which is last down duck time
stamp and the dates when the top of the
v-shape is reached
ie last up top time stamp there are two
other topics that you need to consider
relating to the measures in the output
table one is multi event matching so
with some patterns is possible for
events to overlap each other for example
searching for a w-shaped pattern in our
dataset could result in overlapping
patterns and we need to understand the
implications for this when returning
data points as we stated earlier using
sequel to perform pattern matching
allows us to introduce aggregates into
the output table and the match organized
feature takes this even further by
providing for both running aggregates as
well as final aggregates and for more
information about these two specific
topics please refer to the documentation
so now we want to go back over to a demo
environment and go through some of them
more examples of using the sequel and
match statement in this first example we
want to consider the idea that the same
result is not the same result if we
reset our simple always true event
pattern back to price equals price and
let's return the measures time stamp
symbol and price but we're only going to
view the ticker string for the Acme
symbol so let's also remove the
partition by clause because we only have
one symbol we don't really need the
partition by clause correct well let's
see we should get back 20 rows which we
do but now let's change the pen clause
to set E as a plus which means we're now
looking for one or more matches where
price equals price and here's our result
set but is it the same result set the
solution to that question lies in the
match of individual records to a pattern
so let's run the statements again but
let's use some of our built-in functions
on the slides we talked about two
specific built-in functions that can
help us analyze how our patent is being
applied classifier identifies the event
arose map to and match number identifies
which rows
belong to each match if we include these
in the measure statement we can see how
these two patterns E and E Plus are
actually applied in the case of E Plus
we only find a single match for the Acme
ticker data set and this is shown in the
last column by the number 1 if we now
check the pattern for P and here's how
the pattern is matched we can see the
difference in the matching process
compared to the patentee plus we can see
that there are multiple matches for the
patent e as shown in the last column you
should also note that there's a jump in
the match number and this is because the
predicate is evaluated after the pattern
matching process so the match is applied
to all rows in the table and then we
filter out the rows relating directly
so for this particular problem how do we
resolve the match number jumping issue
how can we get a sequential range of
numbers which is what we'd expect we're
matching this type of pattern there are
a number of ways that we can do this we
can add back in the partition by clause
and it's always a good practice to
include this in your match recognized
statement or we could use a sub select
or we can include a predicate as part of
the event in this case we've added the
partition by Clause back in because
that's good practice and we're also
using a predicate in the event and now
we can see we have a sequential set of
numbers in the final match column so
what this example shows is that while
the output from two similar match
recognized statements might look similar
they are in fact quite different
understanding these types of scenarios
is very important when you come to write
your match recognize clauses now let's
return to the slides and continue with
our review of the match bracket okay
we're back from our demo environment and
let's resume with step four the last
part and here we're looking at
controlling the processing within our
pattern matching operation so when
considering which data point to include
in our output table we also need to
consider the level of detail that we
want to return so did we want detail
data about our pattern or summary data
about that pattern and we'll look at
this in a minute
we also need to consider where to
restart searching for our pattern once
we found an occurrence of a pen so now
let's look at these two points in a lot
more detail the example shown here we're
going to output summary data that is to
say we're going to use the 1 rope
syntax so that our output table contains
one row for each match we get for our
pattern within our data set in the demo
examples that we've reviewed so far
we've used all rows per match and we'll
compare and contrast these two
statements in a minute in the slides so
the main difference between one row and
all rows is if we search for a v-shaped
pattern as we described in our first
podcast and as we've been explaining
here within a data set for a single
symbol such as acne then as you can see
in the graph we'll get three occurrences
of that V pattern which is shown here
match one much to match three so what
happens as we send data back to our
output table what happens when we use
all rows versus one rows so all rows per
match then our output table will contain
14 rows of data points corresponding to
the 14 data points that are highlighted
in red on the graph and all of these
correspond to the data points within
each of the V's then we identified match
one match too much three if we use one
row per match our output table contains
only three rows since there are only
three occurrences of our V shape you
know how can we dataset match one match
two and max three and this is shown the
output table on the right of the screen
here so we can see match one starts on
the 5th of April and hits its bottom on
the 6th of April and then finishes and
on the 10th of April match two starts on
the 10th of April reaches its lowest
point on the 12th of April and finishes
on the 13th of April and the final match
3 starts on the 14th of April which is
its bottom on the 16th and finally ends
on the 18th of April so there's our
three instances of our v-shape match and
one row per match gives us the summary
detail about that pattern now the next
thing we need to consider is once we've
made a match how we should continue
processing the data set and there are
five possible scenarios that are
available that determine where we should
start searching for the start of the
next pack and within this we can skip to
the next row skip past the last row skip
to the first instance of a pattern
variable or the last instance of a
pattern variable or to a specific
pattern variable and then the example
shown here we go to resume our search at
the next row after the last instance of
the pattern variable up in IE the top of
our V shape and you can see that here so
the graph we can see that the search for
the second V shape started at the last
up event of the first match and this
occurred on the 10th of April so after
match skip to last up means when we've
established the match of V show pattern
1 then we start searching for the next V
shape on either one that gives us much -
we start that on the 10th of April and
that is it that's our overview of the
new sequel 12c pattern matching feature
so now we've guided you through the four
steps in building a match recognised
clause and using live demos we've
highlighted some of the key features
that'll help you get started with your
own pattern matching process if you have
any questions about pattern matching in
12c and please feel free to contact me
by my blog
and in the next podcast we will look at
the common use cases for sequel</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>