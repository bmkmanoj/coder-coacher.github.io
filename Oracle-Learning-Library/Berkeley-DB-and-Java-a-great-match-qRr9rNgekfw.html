<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Berkeley DB and Java: a great match | Coder Coacher - Coaching Coders</title><meta content="Berkeley DB and Java: a great match - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Berkeley DB and Java: a great match</b></h2><h5 class="post__date">2015-04-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/qRr9rNgekfw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone in this session we're
going to talk about how to read Java
applications using Oracle Berkeley DB we
will start with theories talking about
what per
a DB is good for why Java and the
Berkeley DB works well together and what
Java API you can use in your application
to gather a concrete feeling about how
everything works in a real-world
application we will present you a sample
program let's get started and see why
Berkeley DB is interesting Oracle
Berkeley DB is a high-performance key
value database it is designed for high
throughput applications requiring in
process would improve management of
mission-critical data it scales
gracefully from managing a few bytes to
terabytes of data is supposed full asset
collections you can run concurrent
transaction operations with different
isolation levels Berkeley DB also
supports transactional recovery that is
committed transactions are durable even
after crashes and Eng committed
transactions are aborted after recovery
Berkeley DB supports both primary and
secondary indexes it also offers cursors
to help your interest through
potentially big collections of data
Berkeley DB supports many platforms it
runs on Windows Linux UNIX Android iOS
Windows Mobile and many other platforms
so why drama and the berkeley DB fit
together both Java and the Berkeley DB
has excellent cross-platform support so
you can continue enjoy the rough ones
driver Amato
most java application in drawing both
Java and the Berkeley DB covers a big
range of devices they both work on teeny
embedded devices and they both work on
clustered enterprise applications so you
can deploy both Java and Berkeley DB on
a wider range of devices so how to run
java applications using Berkeley DB
while Berkeley DB provides three api's
you can use
your job application you can use a base
key value API the direct persistent
layer API or a standard JDBC API the
basic value a P is a lower level API it
offers you a few control over how your
data is persisted in your database the
resemble closely to the C API it works
with Java for and plus but the downside
is it's more verbose the fundamental
objects will deal with key value API our
handles they're our environment handles
database handles and Curson handles an
environment handling capsulized multiple
databases it is where resources sharing
across databases are managed for example
you manage locks transactions shared
buffer pools in the environment so it's
comparable to the database instance
concept in Oracle database a database
managed is a collection of key value
pairs and you can choose per each
database the access method it uses so a
database in Berkeley DB is comparable to
a table in Oracle database cursors are
used to access key value pairs in a
database it provides an iterative
paradigm to access the data this is what
it looks like to use a key value API to
open the environment and the database
you first construct the environment
config and database config object
setting up various configurations and
create a new environment handle and open
the database handle using the
configuration objects to use
transactional database you need to call
set transactional true on both
environment config and David's config
objects to write and get values you use
database entries with double bindings
first creates database entries for the
key and the value and use double
bindings to convert their values to
database entries finally use put to read
well appear in the database to get the
value back you sketch with the
corresponding key database entry the
value database entry will be populated
with photos returned from the database
for the given key and you can use a
binding to convert the database entry
back to your original video to use
cursors first open the curse handle with
open cursor and then just get search key
to move the cursor to the key value pair
you want to retrieve if the search
returns operation station success
it means the cubital pair is found and
you can use a double binding to extract
the value from the database entry direct
persistent layer API is another API
provided by the Berkeley DB Java
interface compared to the q-value API
this API offers a harinama abstraction
it works with objects instead of key
value pairs it uses and rotations so you
can write less code because the
conversions between objects and their
persistent data is automated by the API
changing the class definition of
procedure objects may cause the API to
fail to load the existing values in the
database because the API may not be able
to match the saved data to the change
schema so generally speaking the DPO API
works better with relatively static
schema the core classes of the DPR API
are the entity store primary index
secondary legs and entity cursor only
the environment is same in DB area as in
key value API however instead of opening
a database handle you open the entity
store you create a new store config set
help configurations and create a new
entity store using environment and store
config
to save objects you need to edit a to
the class of objects with the entity
notation and for each entity class it
requires a primary key field you
annotate the field with the primary
annotation in addition every entity
class requires a dollar a constructor
you can make the dollar even stronger
private but you need to provide one so
that the DPR API can construct objects
with the DPL API you access objects with
primary index you get a primary index
from the Edit store and use put or get
to save and get objects from the
database using cursors is also easier
with the DPR API you use entities on the
index to get a cursor object and you can
just iterate through the cursor with a
for loop for those of you who prefer the
traditional sequel interface Berkeley we
also provide the JDBC API on Berkeley DB
uses sequel Lite dialect and is supposed
ABC for the URL for accessing a Berkeley
DB database is JDBC : C colon colon
slash and the database file name to help
you grasp of the concepts we have
created a sample program the sample
program simulates a parking lot with one
parameter it has both a OLTP and our AP
part the OLTP part follows typical data
transactions the ola P part models
business intelligence and data mining
scenarios in the sample program we
collected statistics from operational
logs the sample program runs on multiple
platforms we have tested on Linux UNIX
and windows we have also provided
project files for IntelliJ cliffs NJ
developer IDs
the sample program implements the same
application using all three api's and it
covers many Berkeley DB features like
transactions cursors primary and
secondary index this is a data model of
the sample program
we use two kinds of data tickets are
used in ticketed transactions each
ticket has a unique ID the ID of the
parking meter issuing the ticket and won
a ticket is created the chickens log
models operational logs generated by
parking meters each log contains the
time the log is grated the parking meter
ID the ticket ID the action performed
and additional business data as in the
TV application the ticket ID is
generated from a sequence also the
statistics worker who collected
application or per parking meter
statistics so we have created a symphony
index on the meter ID field of the Tiki
log the data access layer of the
subsequent program consists of three
interfaces DB manager which manages the
environment or a JDBC connection it also
manages transactions request Dao objects
will have two types of the error object
tiki deal providing crud operations on
tickets and tiki lock deal providing
methods for a pending ticket locks and
clarity clocks giving parking meter ID
and the time period we have provided
three implementations of the same data
access layer one for each shape here we
have discussed above the Dao layer we
have 12 education components the meter
class represents a parking meter it
equates tickets one car some ride as a
parking lot and a computes parking fees
when cars leave the parking lot the
reporting class represents a traditional
business intelligence reporting module
equal to reports using tiki locks
exercise these two application
components we have created a demo
trimmer program so you can run it and
see the results lively following other
general steps to run the sample program
first you need to build a following
Berkeley DB components on your platform
you need to build a core API the Seco a
PE the Java API and a JDBC API and then
you can use a project file we provided
to import the sample program into your
IDE after that you need to configure the
project's build path to include the Java
and JDBC jars build from Berkeley DB
finally you need to configure the Java
that library that passed VM options to
point to the native Berkeley DB
libraries in your run configuration we
have created separate tutorials on how
to build Berkeley DB components and
setting up the sample program in the
IntelliJ it cliffs or JDeveloper ideas
please visit our OPM website for more
details let's take a look at some real
code we are going to walk through the
sample program and see how we can
implement the same application using all
three api's the basic key value API the
DPR API and Seco API we will start this
tool with the data model the sample
program uses two kinds of data ticket
and Tiki log let's start with the ticket
class a ticket object represents a
parking ticket created by a parameter a
ticket contains three fields a unique
dignity generated by sequence the 90 of
the parking meter that creates this
ticket and once this ticket is created
it's generally a good engineering
practice to make your reloj class
read-only so we have only implemented
accesses for this class with a
constructor
that takes values of all three fields
and you can see that we do not prevent
your taters for this class maybe you
have already noticed that we have a
couple annotations on this class namely
the entity annotation and the primary
key annotation these annotations are for
the DPI implementation the key value and
the sequence fermentations just ignore
these annotations let's briefly explain
what this annotations do for each value
class whose objects you want to persist
with birthday DB you need to mark it
with the entity annotation for class are
notated with entity it requires a
primary key notation on some of its
fields here we have marked the ticket
Eid and the primary key of the ticket
entity class optionally you can specify
a sequence used to generate the primary
key and here we use a technology
sequence another data class is ticket
log a ticket log object represents a
large message created from actions
generated by parking meters for example
in this some publication we log two
kinds of actions the each action when a
parking meter creates a ticket or the
charged action when the parking ticket
is paid a ticket log object contains
five fields the time when action happens
the any of the parking meter performing
the action the ID of the ticket involved
in this section the actor action
performed and if the action type is
charged the charge the parking fee
the ticket we have only provided
accesses to this class so this class is
grid only similar to the ticket class we
have used and notations in this class
the ticket lock class is again annotated
with energy its long time annotated with
primary key and we have a new annotation
secondary key annotated on the meter ID
the secondary key a notation is used to
create secondary index so in addition to
have a primary key next unlock time we
also have an index on meter ID which can
be used to facilitate our queries based
on our meter ID another remark for the
DPR implementation DPR implementation
requires entity classes to have non
reconstructors the constructor can be
made private to avoid polluting the
public interface now we've seen the data
types used by the summer program let's
see how they are persisted in a summer
vacation using authoring api's to
encapsulate the different
implementations from the hair library
application we have created a set of the
interfaces the DB many
interface encapsulated ADB environment
handle or a JDBC connection it has a set
of a DB method which can be used to
create tables or databases used by the
simple program the main responsibilities
of a DB manager is to create Dao objects
Dao stands for data access objects which
is a common pattern used to encapsulate
persistence logic the cell phone program
uses two kinds of DEA objects the ticket
Dao used to access ticket objects and TE
locked Dao used to access T clock
objects another responsibilities of DB
managers is to manage transactions it
offers methods to start a transaction to
commit the current transaction and to
avoid the current transaction the ticket
Dao class encapsulate persistent logic
for ticket objects we can use it to save
a ticket to retrieve a ticket or deleted
to hit the T key lock de capsule is
persistent logic for te log objects we
can save a ticket log or clarity key
locks matches certain criteria here we
can clearly log messages created from a
given parameter during a given period
since the number of log messages making
the query is potentially big we are
returning the result as an iterable so
we can iterate through many locks
messages instead of pulling them all at
once
the clothes were iterables just a
interface combining both iterable and
auto closable now we have defined all
the functionalities we want to implement
using interfaces let's see how they are
implemented using all three api's
we will start with the sequence of
notation the sequel DB manager
increments the DB manager interface
using the sequel pi it manages a JDBC
connection and maintains transactions
the constructor of the sequel DB manager
loads a JDBC driver and opens a new
connection for the given database the
sequel interface manages transactions
using sequel statements to avoid passing
these statements multiple times we have
created a prepared statements for them
to start a connection execute sequel
statement begin exclusive to commit the
current collection execute commit also
about the current collection execute row
back when the DB manager is closed we
just close the connection and all the
previous statements
tbh method Chris tables the ticket ID
sequence sequence and the index
it correctiy
objects by constructing corresponding
Dao instances using the collection the
transactions are matched by executing
the prepared statements the sequel to
Dao is the sequence of meditation of the
ticket Dao in the constructor we create
all necessary prepared statements to
save a new ticket we first execute the
Eddy statement together next value of
the sequence and then we set parameters
for the safe statement and execute the
insert statement to retrieve the ticket
we set the parameter for the catch
statement and execute the query if a
result row is returned or construct a
new ticket objects using the returned
row to delete a ticket we set a
parameter for the delete statement and
execute
the secret ticking lock Dao is similar
we construct prepared statements in the
constructor and for each method we first
set all the parameters and execute the
statement for the current lock method we
have created a helper class to convert
the real offset into a iterable let's
continue with the DPI implementation
because both basic TB manager and DP l
TB manager manages a environment handle
we have created an environment DB
manager and the base class for both to
be managers the environments DB manager
manages a DB environment handle and
manages transactions to open a new
environment handle we first create an
environment config object setting up a
various configurations for example
enabling the collection and then open a
new environment handle using the
configuration object to start a
collection we call begin collection on
the environment handle and save the
return connection handle in current
collection to commit or above the
current collection we just commit or
abort on the card collection handle and
reset the carbon transaction handle to
null we also provided a accessor method
to gather car - an action handle given
the base environment DB manager the
implementation of dpr DB manager is
simpler the setup DB method creates two
entity stores one for tickets and the
world for T key locks recall that the
primary key of teaching objects are
generated from a sequence so we also
need to create a sequence in the ticket
store make sure the name use here
matches the name given in the primary
key annotation to create an entity store
we create a store config object sending
configuration options on it and
construct a new entity store instance
the
dbl TTL class implements Tiki do using
the DPI API in the constructor
it opens the ticket store and the
primary key index for the ticket class
saving a ticket is simple just put it to
the store using the primary key index
the order to make sure that the primary
key is generated by the sequence we
specifically copy the given ticket
object and overwriting its ID to no
getting or deleting a ticket is also
simple just called get or delete another
primary key index the DPI T key lock Dao
is similar in the constructor we open
the lock store the primary key index
lock time index and also the secretary
index meter index to save our lock
message again we use put on the primary
key index to clearly log messages we use
the secondary index first we retrieve a
sub index of the secondary index where
the parking meter Eddie is equal to the
given ID then we retrieved from the
sub-index all messages in the given
period
finally we convert the cursor object
into a closed for interval with the help
of a helper class
the basically TB manager implements to
be manager using the basic key value API
it's set up DB method creates two
databases for ticket and TT locks
creates a sequence for ticket ID and it
creates secondary index for the log
message database to create a database we
created a database config object setting
up configurations and call open database
on the environment handle to create a
sequence we create a sequence config
object configure it and call open
sequence on the database handle to
create a secondary index we created a
secondary config object configure it and
call open secondary database on the
environment handle basically TTL Clause
implements T key Dao uses the basic key
value API the constructor opens the
ticket database the sequence used to
generate primary keys and bindings for
keys and values the key of a ticket
object is its primary key so we can use
the primary body for long objects the
vinyl binding is a custom ticket body
implemented below to save a new ticket
will create the two database address one
for key in the world for value we call
get all the secrets to get the next
value of the sequence and then we
convert the new sequence value to the
key database entry using the key binding
similarly we can convert the ticket
object to the value database entry using
value body after that we can call put on
the ticket DB handle to save the ticket
gate and the
similar we first converts the ticket ID
to the key database entry and call get
or delete on the ticket DB handle here
is the implementation for ticket binding
for objects values we normally extends
top ID in the used methods on top of
input and topo output to convert between
objects values and database entries
basic TTC log Dao is similar in the
constructor we open the log database the
secondary index database initialize
bindings for keys and values and also
the index keys
we convert the locked message to key at
a value of de Paris and put them into
the lock database
the query is a bit more complex first we
need to open a secondary cursor on the
secretary index database that we use a
helper class to execute the query and
turn the result into a iterable the T
key lock it were per class is where we
implement the curie based on a secondary
cursor first receive all clear
requesters and then convert them into
database entries that we call get
searched both range to move the cursor
to the first locked message matching the
query and then we call such next value
to catch the first two result the
iterative method creates a iterator for
the resources because gas tax to the
cursor to move the cursor to the next
result it caches the next message and
checks if it is still in the range of
the given period and if the message is
out of the given period we know we have
exhausted the result set and we set the
cash next value to no to market now we
are set with other implementations we
can implement higher level components
full application the sample application
has two components the meter clause
representing parking meters in the
reporting class performing analysis
let's start with the meter class the
middle class has a parking meter ad and
it uses a DB manager and the 2d arrow
objects to marry stickers
as parking meter has two functions the
park method is called by the car arrives
and the issue is a parking ticket for
the car the department that is called
water current lives and calculates
attorney fee using the cars parking
ticket the park method performs two
actions in the collection it creates a
new ticket and a new message lock for
issuing the ticket the department that
performs three actions in the connection
first it retrieves the ticket and it
computes a parking fee
they'd adds a new charge block message
to the database and finally deletes the
ticket the protein fees computed by a
helper function the reporting class
shows how to perform analysis using the
database the analysis is purely
performed using log messages so we only
need a database manager and a tiki lock
Dao the reporting class shows how to
perform two analysis the first one
computes a total number of cars arriving
at a given parking meter during a given
period it clears all the log messages
mention the criteria and iterates
through them counting all issue messages
the second analysis computes a total
parking fees collected during a given
period of the given parking meter
it also iterates over all backlog
messages and accumulated parking fees in
the charge messages to demonstrate how
to use the two application components in
the real application we also created a
driver program
parking demo to make it easy to switch
over different implementations we also
created a helper class to be manager
factory to crazy be managers the driver
program first creates a DB manager to
set up the database and then start a
simulation to generate tickets and
teaching LOC messages
it creates a new DB manager and either
way through simulation events provided
by the demo data helper class after the
simulation finishes it creates another
DB manager to perform the two analysis
provided by the reporting class this
completes the sample program we hope
it's enough to get you started with your
own application using Berkeley DB for
more information on Berkeley DB Java API
please visit our out here website thank
you for your time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>