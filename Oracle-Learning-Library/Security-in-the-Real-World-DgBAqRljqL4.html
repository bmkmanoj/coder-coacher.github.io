<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Security in the Real World | Coder Coacher - Coaching Coders</title><meta content="Security in the Real World - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Security in the Real World</b></h2><h5 class="post__date">2013-01-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/DgBAqRljqL4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright thanks for coming I guess the
first rule of security club is you know
move the location at the last second so
nobody can find it this was originally
scheduled for Plaza a bi believe but
thank you for finding it hopefully
you're at the right talk this is a
security in the real world so just
quickly before we get started here the
company I work for requires me to do
this the the funniest part here is the
really the last line which is
effectively in the event my capture the
company that I work for will disavow all
knowledge of my existence so you know
please don't hold anything that I say
against them alright so now before we
get started you know where am i coming
from what's my background and you know
what kind of slant are you going to see
from the sort of talk my name is Ryan
shampoo Coney that may not be the right
way to say it but it's the way my family
said it for about four generations now
so and there won't be a quiz later but
I've been actually working on JVMs and
other interpreted languages for about 15
years now it's actually longer if you
count my school days but I'm really more
of kind of a systems guy you know
everything from just-in-time compilation
Biko verification garbage collection and
so on lately it's been more managed
runtime focus so not just specifically
to have about other languages and if you
need to get ahold of me after this you
know just just give me a tap on linkedin
or something if i mentioned some
reference that you want to know more
about or you have any other questions
you know feel free to either mail me
here or you know give me a connected all
right so you know what should you expect
from this talk and I've been sort of
joking about this this week that this is
really problem Safari is the style of
this talk I know that there's been a few
security talks this week I think I'm the
last one on the list I don't know if is
anymore maybe maybe maybe not but
hopefully this isn't a repeat of what
you seen the approach here that I want
to really take is to actually take a
look at a number of the problems that
have occurred in recently in the last 12
months or so and dive into them enough
so that you can really understand sort
of the complex nature of how you know
exploits occur you know simple changes
in your code or your development that
might actually affect things
and and how you really have to be aware
okay and there's a lot of subtle dangers
when you make changes to your code that
you know you just have to really watch
for so this is just going to be we're
going to look just that problem after
problem what happened and not
necessarily the high level washing to
say okay well what happened at the
runtime level why was this exploitable
what happened and what was the end
result and then maybe how you might want
to avoid that the future so before we do
that just a couple of charts on
introduction and you know this this top
code is really security at its finest
right it's almost complete overkill it's
funny there's so many points about this
quote that you can sort of take from a
security point of view and they're all
really true right it's there are so many
you know there's lots of different ways
to defend yourself right you get you dig
a hole put it a chest to bury it and so
on there's lots of different attack
vectors okay and you know you have to
try and guard against all them and then
no matter what you do in the end the
fact is is that your system is
accessible okay and that means that
there's going to be weighs in right it's
not something you can't access it's
actually something that that you need to
make accessible in some ways just
insecure ways and so right away because
there's a human factor and so on there's
a vulnerability so like there's a moral
to this quote right which is that no
matter what you really do the moment
make it accessible you're in trouble
right so you have to be really diligent
about things but so it isn't as simple
as a padlock on the door but you know at
the same time while you're putting all
these protections in place you want to
make sure that you're keeping the system
stable performance and secure okay it's
one thing to have security with an
unusable system because its performance
it's terrible but the same time you
don't want to compromise security in the
name of performance okay so it's one of
these really difficult balances that
that it isn't a balance it's really
security first but then how do you
provide performance as well this is not
a performance talk mind you this is a
security talk so and you know really
just quickly this is this is sort of an
overall summary and I want to be clear
that this is not a tutorial on you know
class loaders or verification
pation or so on or use of jce or what
not again I'm just going to talk about
specific problems but I wanted to really
mention this and say that you know
security is defense in depth with Java
there's a lot of different components
and parts some of them implicit some of
them explicit so implicit ones the
bytecode verifier right typically you
just run and you don't really ever
notice it but it's really helping you
out class holders somewhat a mix and
then you have things like JC EJ sse and
jas which you know you you go out you
use explicitly so but the one thing with
all of these though is you don't want to
sit around having to vet them right you
you have to be able to trust these
things you have to be able to trust the
JVM the JDK your runtime system to say
look if it's providing you a secure
environment for specific things and you
use it then you have to be able to trust
it right and when you can't trust it
that's when everything falls down you
start to get really kind of wary of the
whole thing so and you know lately
there's been you know a few questions
while job and we'll look at those
problems and you know moving forward our
expectation is actually to be able to
you know really solidify things and make
sure that that we aren't faced with
these types of questions right that you
really can't say look it is secure and
what you really don't want is having
people building their own security
layers because they have do they feel
they have to sew a last chart in this
whole introductory thing before start
diving in and go on home Safari like I
called it the Java security book from
O'Reilly presses well over 10 years old
at this point but quite frankly it still
completely relevant so if if you aren't
familiar with Java security it's an
excellent starting point okay it really
is and it's still completely relevant
today so you know take a look at it it
really this diagram sort of talks a
little bit about you know or talks to
the points I mentioned about implicit
versus explicit protections you can see
costs files coming in by co verify our
class coders and so on along with the
various aspects that you can use there's
even things like security manager for
example that you know in San boxing and
whatnot that you tend to get for free
especially if you're running for encode
that a lot of people really aren't aware
of that really if you're kind of worried
about these things you should be aware
of this is an excellent starting point
if you're looking for tutorials on that
which is not this talk
alright actually I go back here for a
second this this top this problem I want
to talk about the hashcode denial of
service attack how many people are aware
of this one only a few okay this is
excellent alright so this is actually
really practical example so I'll
actually get down to what happened and
why so for those of you who aren't aware
of it this will be a good education for
you so and don't worry this is sort of a
black-white slide I do have plenty of
pictures out to this to really describe
things I don't go through reams of code
that's just not my stuff so there's some
really simple job of 101 type of attack
vectors that actually exist i say java
101 because these things are actually
mechanisms and components that have
existed from the beginning of time if
you take things like strings okay and
hashing structures these things have
been around since day one all right now
through combination of specifications so
it being out in the open open source so
that you can actually see the
implementation and so on there's a
combination of being able to look at the
implementation or the algorithms and
understand what's a the performance
shortcomings are or really the worst
case scenario worst-case or worse order
a performance that you can possibly get
and you can actually take these things
and exploit them and say well if I know
what the worst-case behavior is maybe
there's some way that I can actually
exploit it to cause problems in a system
so if you're an attacker you just take
these very basic components that it
existed and go after it this is
typically known as an algorithmic
complexity attack where you basically
because you're creating the worst case
scenario on a system you effectively are
doing a denial of service attack so the
hashing vulnerability what I'm going to
talk about this is an example of that so
his number parts to it and we'll start
to build up from that the first one is
the string hashing algorithm this is
actually a well-known spect algorithm
and it's reversible okay so there's the
algorithm up that's actually taken from
the Javadoc you can look this up very
easily it's not a problem and as you can
see from the algorithm it's very very
straightforward you can take your string
and you can calculate your house go to
very very easily and the example that I
have here is actually pulled from stack
overflow so
it's actually very easy to look this one
up too if you want a deeper explanation
have only got one chart here for it but
the key here is that you can actually
construct very simple strings that have
the same hash code all right we see this
here right here right capital a small
way is it has the same hash code as
capital B capital B you can try this
right now on your laptops doesn't matter
Mac a thinkpad what have you this will
give you the same hash code right now
from that very simple building block
based on the algorithm you can actually
construct bigger and bigger strings that
actually have the same hash codes all
right now the other important point here
that to note especially with the small
the bottom group that have been built on
top of one another the beginnings of
some of those strings are identical this
will be a key point later all right so
important point here because the hashing
algorithm is well known and suspect it's
very easy to construct strings that have
the same hash code all right now let's
look at how a hashing structure
typically works all right so we'll take
hash map and I have my hash map and I
want to put a key and a value into it in
into it so underneath the covers a
hashmap is typically and I'm going to
kind of gloss over some of the details
here I know the people who understand
their deep implementation details yes
I'm omitting some facts here but I'm not
going to be lying to is the hash map is
actually implemented with an array
underneath ok and that array is intended
to hold the key in the value pair so
when you insert something it's really
being attached or put into an array so
in this case we take our quantity AAA
that I've constructed and we actually
use the hash code of the key quantity
AAA to find a location in the array so
that's a very simple thing of just
taking a hash code of the string you do
a mod find the position when thiet in
the Iranian you decide this is where it
ends up going and we stick a little
entry into the array to say great this
thing goes here right now in my hash map
you could look it up no problem now I
come along and I want to insert another
key value pair into here now you'll
notice that this is quantity BB if you
go back to my string construction stuff
these two strings quantity AAA and
quantity BB will actually have the same
hash code so guess what happens right
since the hashcode matches we find it in
the array and we say oh all right this
belongs actually in a location that
already has a value in it so it doesn't
go off and try to find some other
location what it ends up doing is
actually saying well look we're going to
actually stick this into the same bucket
okay we're going to actually you know
not other to look anything anywhere else
we're going to stick it in the exact
same location but what that means is it
says well you know hash maps only
contain one value for one key so the
first thing it has to do it has to say
well this bucket is already consumed I'm
going to look at every entry that's
already there to make sure I'm not
already in here IE is quantity BB
already in my hash map or not if it is
i've got to overwrite that value right
delete the old one new one in in this
case it doesn't find itself so after a
ton of lookups and and comparisons and
so on and says oh ok that's fine I can
insert myself in but this costs you I
end up having to take my key that I'm
inserting and comparing it against every
other key in the collision bucket okay
that can take some time in a second
you're going to see if I can take a lot
of time sometimes so you know this ends
up like i said this ends up requiring
you know identical crashes when you hash
identically for two strings you having
to compare all the way through the list
and this gets a little dangerous because
now there's the potential of instead of
it being you know potentially MN trees
across that you could take if you have n
total entries and you have em entries
within your array you would hope even
distribution but there's a very serious
potential that everything ends up in the
same bucket and you have an order of
complexity of n for either any look up
or insert all right let's make the
problem worse so let's take that string
construction story that I gave earlier
about how you can struck things with the
same algorithms and let's make a
gigantic string okay that is both the
same length as every other key in the
bucket and has identical characters at
the beginning of string where the
differentiator is at the end
so if I'm going to insert into this hash
map these two strings right one of the
problems is up having is I find the
bucket that I'm going to insert into and
then I go us already stuff here well I
got to make sure I'm not already here so
they're not going to replace it I have
to go through every string in that
bucket and compare if each of these
strings is a megabyte and length with
the differentiator at the end I can't
use hash code to differentiate them
they're identical I can't use the length
to differentiate them it's identical I
have to do a basically a character by
character comparison slow okay
especially if everything is colliding in
the same bucket all right so in practice
well you know websites when you're
actually passing parameters to them
right you know one of the ways to do
I've got in the URL here but you
actually stick this in the header as
well but you end up passing you a bunch
of parameters parameter 1 equals and you
give some value and so on your servlet
right in order for these to arrive it
basically uses a hashmap and it takes
these values and says out key value pair
great got it sit and stick it into the
hash map and it keeps inserting these
things a malicious attacker can
construct these incredibly long strings
that I talked about pass them to your
website and your servlet is just going
to say well okay I've got to insert all
these key value pairs into this hash map
before I hand it to the servlet say
here's your parameters and guess what if
they constructed these keys that
actually end up colliding with one
another you're in a lot of trouble
performance wise and the quote i have
here at the bottom is actually extremely
extremely interesting from a math point
of view right one attacker with a one
gig e connection can actually keep
100,000 core i7s busy on your website it
does not take much for a coordinated
attack of a bunch of identical strings
arriving for your parameters to cause
your website to basically died in a
denial-of-service situation right this
is all because all the time is spent
inserting into your hash map to
construct these parameters nothing
complicated I just passed a string to
your website that's the end of it pretty
easy right
as Java 101 we didn't use anything
special here right is the strings and
hash maps right it's like the breakfast
of champions for four Giada right okay
so what what did we do about it right
what's what's the current solution right
now well for things like hashing
structures and all the well-known ones
that exist and say java.util and whatnot
we actually use an alternate hashing
algorithm when we hit a certain level
our sorry a certain number of entries in
the hashmap the algorithm is one of the
you know it's it's it's one of the
secure algorithm secure hashing
algorithms so the problem with the
original one is that you can look at a
string i can go yes i know what the hash
codes going to be with some of the
secure algorithms you can actually have
it such that an attacker can't actually
reverse it okay there's a say constants
for example that can be derived at
runtime that influence the hash that no
attacker could actually be able to get
at so at a certain point in hashing
structures we have the capability of now
flipping to an alternate hash algorithm
so the moment we get say too many
collisions are too many potential
collisions we actually switch internally
to a different algorithm to avoid this
okay so Java can actually you know
helped protect you from this
automatically but why not just take
string and modify the hash code its back
right might say well it's a hash code
means back right nobody nobody codes to
what hash niall the hash code of a
string is they absolutely do you
wouldn't be surprised you sorry you
would absolutely be surprised I
guarantee there's at least one person in
this room that has code they may or may
not realize it that actually codes
specifically to the string hash code
values so these things actually happen
if we change this we potentially break a
lot of Java code unknowingly to write a
lot of people say all won't break mine
and then it does specifically this new
alternate hash code algorithm for
hashing structures is a potentially
problematic as well and we've actually
seen problems in the field with it so
I'm going to get to it it's actually not
on by default we'll get to that in the
next chart a second but but the problem
with hashing structures is that the
iteration order is not specified and if
you've ever been on a spec committee you
know that when you say not so
fied that means the implementation is
spec right you can if you take 10 items
and insert them into a hash table half
map guaranteed the order is going to be
the same when you hit rate over them
there is tons of code out there that
actually relies on this without actually
realizing it okay so switching the hash
codes switches the iteration order
because they get inserted in different
ways and this ends up causing problems
for existing software some fundamental
existing software too is that better pop
yes sir yeah yeah sorry about that
apologies that's me everybody's eardrums
will be better but that means i have to
talk more directly into the mic now all
right so because of this problem there's
actually a command line option to be
able to turn on this alt hashing problem
so you have to be aware of this right
first of all the alternate hashing
algorithm is nacked not actually on by
default all right it's it's off you can
turn it on and said to a particular
threshold for further documentation i do
encourage you to look this up it's
available java 7 in latest updates if
you look at IBM java it's available 5
and up for all existing latest updates
as well but there are you know there are
other things that can actually happen
sorry there are what now what am i doing
wrong now
okay all right at my chin is that better
yeah well can everyone hear me yeah good
all right so you know this fix was
actually turn around really quickly by
both Oracle an IBM right but it's an
option and you know actually somebody
like a group like Apache Tomcat actually
turned around a fixed even faster they
just said look there's a problem here
maybe we shouldn't be taking on
bazillions of element you know
parameters / for web grace so they just
put it in a max parameter count and said
look just set this we set it to 10,000
by default but you probably don't need
10,000 parameters per request so just
pick something smaller and go with it
right and just solve the problem
yourself so this is sort of a mix of the
JDK providing solutions that at the same
time because of the algorithmic
complexity aspects existing software has
to be aware of this as well right the
fun one let's look at a different
problem ever anybody ever fumble finger
the keyboard and then some app pops up
that you didn't know that the key
combination actually starts it up yes
kind of scary isn't it I I'm always I'm
always half and press whoa I could do
that wait was that me right so imagine
if you actually you know you type in a
URL hit return grab a cup of coffee or
sorry take a sip your coffee while you
do that your calculator app pops up I'd
be scared okay now imagine a lot worse
happening and that's exactly what could
happen with this latest attack your by
visiting a website your system could be
compromised and then attacker website
attacking you website attacking you
could actually run arbitrary programs on
your system outside of Java okay scary
how did this happen so you know we've
all been here right we've all been or
you know a lot of us have been at least
anyways up at three four o'clock in the
morning we've had so much coffee that we
can see sound and you're really trying
to get something done right and you're
really
pushing through I see laughter because
it's like yeah man yeah absolutely you
know sleeper days after that either
anyways you know you're working so hard
on something age trying to get something
on and you run into a roadblock and you
say oh no I just got to change this
piece of software outside of my purview
but that'll be okay it's not really that
bad and then you're really setting then
you know maybe days weeks months later
you realize you know what a mistake that
actually was and this is sort of a
potentially an example of one of those
things so you know there's an existing
API on a Sunday WG son toolkit that's up
that was private and it was basically
equivalent to really the reflect or on
the surface equivalent to reflect get
filled right but it was private now this
doesn't sound that bad right it's just
you know it's just it's equivalent to
reflect what's the big deal right you
know you know if it's available there
then what's what's the problem here so
the change actually from six to seven
was that this thing went from private to
public and again it just looks like
reflect what's the big deal right well
this is one of those cases where you
know the API and the illusion of what
it's actually trying to do versus what's
actually happening underneath can really
NAB you okay and if you're not paying
attention and you're not really thorough
about these things sorry more popping it
can really get you so I've got some
pseudocode here just to sort of
illustrate what was happening but in the
code it was really simple it actually
looked a lot like up just a pass-through
for reflect both was a lot more to it so
the first thing was is that we said okay
let's elevate any caller to this let's
elevate the permissions to be the same
permissions as me you know the class as
opposed to my callers permissions okay
that sounds a little scary but let's
keep going let's see what happens then
it said okay well let's just use
reflection to go out and get our field
type you know reflect field on you know
the class and the field name that's
provided by the user okay fairly
standard operation no big deal and last
but not least let's set
the set let's set accessible on that
field to true now what that means is
reflect will normally protect you and
say look if I have a reflect field on
something and it's private and I try to
use it you know and I'm some other class
not you know normally able to access it
it'll say no you can't do that and
that's the end of it it's fine security
checks happen at run at the point of use
okay this turns that off so now you've
got something that's potentially
referring to a private field that is
going to allow anybody to refer to that
private field both set and get eek
alright so that's really the key or what
the key change here that end up causing
this problem with being able to launch
apps but let's take a look at how now
it's not that easy right you know you
would think okay well this happened and
actually I want to go back to this for
saying there's there's some there's some
real hints here right about how this is
dangerous when you're making these types
of changes you have a method that
actually takes parameters from some
other arbitrary code source is going to
do something magical and then return you
a value okay when you have things like
this especially when it looks like you
know reflection or any other types of
you know potential you'll get a
filehandle or this or that you have to
be aware of these things and like I said
I gave that example three four o'clock
coffee buzz going on and everything it's
very easy to miss these things when you
do stuff like this so how did this fold
in because it wasn't exactly
straightforward now again I'm going to
generalize on the problem a little bit
but but kind of bear with me and of
glossing over the details we will
actually see that there's a number of
hops in order to be able to exploit this
so the first thing is that you need a
calm sunbeams find or class finder now
one of the problems with this class is
that this thing can actually find
anything in your system it's a bit of a
hole but but whatever what kind of you
know ignore that for the moment that's
kind of dangerous but ok and you can
actually use that to find your son awt
son toolkit class that I just finished
talking about with the access or change
all right while we do this we're
actually going to get a javabean
statement these things actually let you
execute code that actually lets you set
something up and say look go run this
and there's two kind of important things
about this one is that it actually lets
you set up a statement to say look I
want to run
when I actually tell you to run the
other thing is that says oh and here is
your access control context to basically
set up your security permissions okay so
this is important this is a very
important point we're going to get one
of these but we're potentially running
in a sandbox so our access control our
levels of Security's pretty much sand
box so you can't just set it to do
arbitrary things now we're going to use
the get field to go get a field on this
access control context field which is
private and we're going to get that
field back now remember we've now got a
reflect field for a field that's private
except that we've set the accessibility
such that we're going to ignore the
private aspect you can see where this is
headed all right so now we've got our
field great no problem let's set it and
let's elevate our permissions on that
statement danger all right now let's go
back to the javabean statement we're
going to run execute on this and we're
actually going to set the security
manager through that statement to
actually elevate the permissions on our
entire sandbox right so that's you know
seatbelts are off at this point and this
is an applet that you have visited on a
website doing this to your system
it is through class pointer yes that's
one that's sorry so the question was is
that hey that son toolkit is normally
not accessible absolutely true except
through class pointer which is yes so
there's a cheat like this just a whole
you know meandering line of things that
you need to do well guess what now that
we've got our sandbox permissions
elevated describe your javelin runtime
exact whatever you want I've never
understood why castle has keys but
anyways scary stuff right and when
you're hacking coving just out there you
doing things and you got you know peer
reviews and whatnot people you know you
need to be aware of these types of
things right and I'm look I'm a runtime
guy okay so so these are the kind of
things that we have to be more aware of
and even at even if you're not a runtime
person you need to be more aware of
these things right and be aware that
when you're making changes now do you
have the right level of security review
process in place it's important it's
hugely important sorry more popping all
right a few things about this stuff you
needed to be running untrusted code
right so if you're running your webs
you've got a web server running you got
your own servlets and so on you know you
trust all the code that you're running
you work and be affected by this okay
but if you're running java on your
browser you might have been this was
only java 7 so a lot of people were not
going to be affected by this thankfully
but those that are maybe a bit more
bleeding / cutting-edge running java 7
as their browser they would have been
I'm pretty sure macbooks for example
come with java 6 installed so you
weren't affected by this unless you
actually went out and downloaded the
latest now a fix for this did get turn
around in a hurry okay this was huge
right it was turn around incredibly
incredibly fast right but i think the
lesson here is that look you have to
really look at the API so you're
changing you know you know every line of
code hmm but you really have to be aware
look we're talking about reflect here
for example what are the issues and
really you know but the question I got
asked right when you have something like
classifying or they can really just
bypass all your checks and find whatever
class you want
we have to start to think about these
types of things
alright
the invoke special one is actually
really interesting because from a
security point of view what you're going
to see here is that it was more
theoretical in terms of an attack but
this is an example also of how spec
isn't what you write down is the
implementation and how by fixing your
implementation to match the spec you can
actually end up breaking existing code
so one slide interlude on the on the on
the verifier there's way too much text
on this chart so try not to read it a
bit of an eye chart but you know there's
a lot of language rules that get
enforced a job to run time right things
like sorry runtime compile-time
verification time and so on so when
you're loading stuff lots of different
things happen to make sure that you're
running trusted code and it isn't just a
matter of running you know untrusted
code and verifying that it's okay it's
actually about vetting your own code
really a lot of times when people notice
the verifier it's because it's actually
telling you hey you went messed up on
your application right now the verifiers
error messages are typically not very
helpful but you know it'll let you know
hey you went and compiled with this
version of a class and it's sort of you
know it's now incompatible or so on and
the verifier helps you know check things
like you know accessibility are the byte
codes in the right order are they doing
the right things are you messing with
your stack and so on so it does a lot to
really vet the the safety of your code
and when I say safety I mean both safety
through malice so people attacking you
potentially as well safety through
ignorance because you've gone and done
something wrong and you know it happens
to everybody right you have you know
incompatible classes bad things happen
so one thing to remember about the
verifier is that if you have native code
it doesn't do anything to help you
verify that there are different measures
for that type of thing including not
allowing you to call natives or load
your own native libraries rather but you
have to really be careful right about
what about what's a you know what type
of code that you run now the verifier
all right so the invoke special security
fix there was in the spec so this is a
voc special is actually a byte code and
I'll get on y'all have a more practical
example that you'll be able to you know
look at just Java code and kind of
understand but what the speck said is it
said look you cannot from a constructor
invoke anything any other constructor
other than some other constructor on
yourself right or your immediate
superclasses constructed you couldn't
skip any super class and go to some
other super class point and invoke that
constructor so it turns out that a lot
of dynamic dynamically generated code
dynamic proxies and so on that were
generating code actually went and
bypassed this for whatever reason not
malice at all but they've just you know
exploit and not exploited this but
really you know abused the fact that the
verifier did not conform to spec okay
and actually allowed you to invoke
things so I've got a simple you know an
example here with somebody codes I'm
going to skip to a more readable example
here but you see child extends throwable
and in the child constructor we were
actually calling directly through to
object in it as opposed to throw a limit
now you used to be able to do this until
it's got fixed recently and there was
never the potential for an attack which
I'll get to in a second was really more
theoretical but um this was counter spec
so what does this actually look like we
got two classes here an invoke special
example and then a my sub class that
extends that class and it's really
simple you've gotten the constructor for
the invoke special example my ID so
every time you instantiate something you
get a new ID this this is the best code
in the world I admit but it illustrates
the point you get a new ID and then you
have a do privileged action function
which checks and says hey look are you
the master you know id0 if you are do
some privileged action otherwise no
don't do some privilege to action all
right now in the my sub class I've got
like some sort of some comments here to
say look I'm going to invoke the
constructor for object and I'm going to
skip the invoke special example the
reason why I've got the some comments is
because you cannot write this in Java
you have to be generated by codes to be
able to achieve this behavior all right
but still I've skipped that constructor
so if you want we run through the
example really quickly again right we
have a per instance ID right and we use
this for privileged purposes every time
you instantiate one of these things or
at subtype you will get a unique ID
expected let's ignore multi-threading
for a moment and here's the control
point that I talked about we check on
the privilege to action are you id0 yes
you get to do something otherwise no but
then here with bypassing the constructor
it's very easy to actually end up in a
situation where you have two instances
that actually have id0 and you intended
to only have one instance have the
privilege action but now you've got at
least two if not more okay you can
actually just generate this code and the
JVM would eat it no problem all right
spec said you couldn't do it verifier
allowed you to do it and like I said you
can't actually express this in Java
syntax you actually actually generated
so you know the attack here's
theoretical again and in quo honesty we
ended up when this was fixed in the
verifier I can tell you more than one
piece of very popular software in the
public domain ended up breaking because
of this and they had to patch their
stuff and again it wasn't because they
were exploiting this for malicious
purposes it just happened to be what you
know how their code worked they just
generated this perfect example of how
when you have a spec and you have an
implementation the implementation will
win right way through very careful about
that right really making sure that we
match our spec do we have tests for each
and every speck
all right method ah who knows what a
method handle is sorry we're popping no
101 whew okay this should be interesting
then so uh in Java 7 you know anybody
here run JRuby um no ok so in Java 7 one
of the ASRs that end up being pushed
through was 292 which was support for
dynamically typed languages and this
introduced new to two important things I
would say two things right people want
to just say one thing but it's really
two one was a new bike code invoke
dynamic we're going to ignore that for
the moment and the other one that was
method handle which looked a lot like
reflection but in fact really looked a
lot more like a direct function pointer
and I'll explain the differences in a
second and which actually makes it
really attractive to use but you have to
be very careful much like reflection
what you end up doing with these
elements now a method handles really
really cool it's basically a direct
function pointer to method so you can
say look I want to know about this
method and I want to get a direct
function pointer and then by calling
this thing it's incredibly fast right
you call me through reflect most people
say yeah it's like really slow but call
me through method handles is really
really fast in fact the VMS are actually
designed to optimize through these
things and it's like literally a jump
right through it so blindingly
blindingly fast reflect if you will but
the problem is is that even though it
looks a lot like reflection the security
checks and access or checks and so on
are actually very very different and you
have to be very careful about what you
end up doing with these things so you
know here's a quick table just to sort
of a numerate the differences I the key
ones really are the second and third
rows where when the access checks end up
occurring all right at reflection we end
up checking at invocation time so if
you're trying to access a field through
reflection right we actually check at
the point that you use the thing and we
say hey are you allowed to do this right
here right now and if not then we just
say no all right so it's actually really
good right i mean if you end up losing
one of these things it's not like
something you know it's not a potential
problem if i say lose what i mean is
sort of you know you acquire one and
then you know
you end up giving it out to code that
maybe you don't quite trust this can
actually sort of be avoided as a real
problem because they'll still get access
checked and they'll still be denied
access if they don't actually have
access to it however method handles on
the other hand we check when you acquire
the field or rather the function we say
look you're trying to get this function
point we're going to check right now you
can get it from where you are perfect
here you go now you can use it anywhere
okay sounds like I don't want to you
know push anybody off from method
handles they're actually very powerful
and very important but it's an
incredibly important distinction so if I
want to you know if you want to sort of
look at this from a diagram point of
view the top the top chunk of code is
using reflection the bottom chunk of the
code is using method handles it actually
looks pretty similar you know driving
method handles looks it's a little bit
longer but and the bouncer character and
I know it doesn't look like it but I
like to hit the gym every once in a
while and actually know people with arms
this big so it can be kind of scary the
the balance here is meant to represent
when the security check actually happens
so you can see from reflection we know
when you get the declared method for
length on string right we don't bother
we don't really do a check okay but when
you actually invoke it we actually say
yeah okay hold on are you allowed to do
this or not right are you allowed to
actually go out and and get the length
of these strings method handles are
different right a complex piece of code
but at the lookup point when you say
find virtual we do the check right there
on the spot are you allowed to see this
method right here right now yes great
here you go and then that can actually
be used anywhere at that point so if
you're using it from a place that
normally wouldn't be able to access that
doesn't matter you got the method handle
away you go so this there's these subtle
types of differences that you end up
seeing that you have to be really aware
of and we have to make people or make
sure that people understand what these
differences are and how you can really
shoot yourself for method handles and
look up I mean there's a fundamental
difference on where the security check
occurs yet we documented I mean if you
look
the javadoc it's documented on this
little line on the lookup point on the
lookup method right to say oh you know
when you actually do a lookup oh by the
way don't lose these things they're
important ok guess so you know so just
be aware right I mean if you're not
somebody who uses these things now you
know be aware that they are cool they
work if you use reflection it's kind of
interesting potentially speed up your
code however there are dangers there are
different dangers than what exists with
reflection all right
oh so the question is why why why is why
do we have something different so it's
faster that's going to be really a
really deep explanation in 292 I'm happy
to go over it afterwards but it's kind
of out of scope of this talk like it's
like it's literally hours of explanation
and so on the the key point is to make
was to make dynamic languages faster so
when you had to do our job has its own
sense of dynamis ism for look up message
lookups but it doesn't necessarily match
everything that happens in all languages
so these along with the evoke dynamic by
code and so on were built so that we
could support different languages on the
vm runtime it just so happens that
method handles also available to you
from a development point of view to use
directly so you don't have to use the
invoke dynamic byte code to use method
handles you can just use method handles
themselves for other purposes lambda for
example 335 this coming up in Java 8 is
going to be using in both dynamic and
method handles as well so all right
40-minute mark time to let class out so
all right there's a lot of problems out
there right this is that's just a slice
there there are Jabba's not unique and
having security problems it is not just
a java problem ok but I do want to say
that that was a slice there are other
security issues that we constant it you
know we find and we address when you do
find an issue or you think there's an
issue you have questions about issues
you know please contact us at directly
there's the I both the IBM the Oracle
support URLs here don't be shy about
asking us questions on those things
right in terms of how we end up dealing
with these things it's really there are
there are two sides but one is that you
know security analysts and so on
sometimes get a little impatient and
reveal exploits earlier than they should
but generally we don't comment publicly
and neither does Oracle on when security
experts and analysts end up finding
problems because we don't want to first
of all give ammunition to the attackers
right we have to take the fit we have to
take the problem evaluate it and
determine what to do from an IBM
perspective we have a unified release
cycle so when we actually are applying
fixes and giving them out to the public
we actually provide fixes for all of our
Java lines at the same time so
if there's an X boy that happened all
the way back in Java 5 and you're still
using on five six or seven we will
release everything at once in lockstep
as soon as possible right with a fix so
Oracle has their own system that having
been said you know clearly from an
engineering point of view we are aware
that that no job is popularity is and
its ubiquity in a lot of ways is making
it a very serious target and it is
something from an engineering point of
view and as a security standards point
of view that we're certainly looking out
to make sure were not in this position
in the near future but that having been
said you know security is not unique to
Java right very clearly all right with
that what you should have gotten from
this is that look there are a lot of
security facilities within Java security
is actually complicated and that doesn't
make an excuse right you need to
actually be secure we are certainly
working on making sure things are
fundamentally sound and that you can
trust it because you need to be able to
trust it we say it's secure you need to
be able to trust that we understand that
but you know rolling your own or some of
the dangerous things that you can
potentially do you need to be aware too
because it isn't just a meeting
immediately obvious problem with your
code it can be something that you know
chain reaction a bunch of different hops
in order to get to a really vulnerable
point so just be aware of these things
too that having been said talks over so
thank you very much for your attention I
apologize for the mic and my popping if
you have any questions I'm happy to
answer them but you're free to go just I
ask if you can leave somewhat quietly so
I can hear the questions and answer them
but thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>