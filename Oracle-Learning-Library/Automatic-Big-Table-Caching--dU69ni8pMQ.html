<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Automatic Big Table Caching | Coder Coacher - Coaching Coders</title><meta content="Automatic Big Table Caching - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Automatic Big Table Caching</b></h2><h5 class="post__date">2014-11-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/-dU69ni8pMQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome my name is Dominic you know I
work for oracle server technologies this
is the second of two demonstrations
abound in Marrakech a new features
introduced in oracle database 12 on 02
this one illustrates the automatic big
table caching feature enhancing the in
memory parallel query capabilities of
the Oracle database in both single
instance and oracle RAC environments an
optional section of the buffer cache
called the big table catch is used to
store data for table scans if a large
table is approximately the size of the
combined size of the big table cache of
all instances the table is partitioned
and cached or mostly catched on all
instances within memory parallel query
this could eliminate most discretes for
queries on the table or the database
could intelligently read from disk l for
those portion of the table that does not
fit in the big table catch query scans
can use a different cache replacement
algorithm when a table does not fit in
memory the database decides which
buffers to cache based on access
patterns this provides efficient caching
for large tables even if they do not
fully fit in the buffer cache if the big
table cash cannot cash all the tables to
be scanned only the most frequently
accessed tables are cached and the rest
are read through direct read
automatically the big table cash is
integrated with the buffer cache and
uses a temperature based object level
replacement algorithm to manage the big
table cache contents different from the
access based block level and argue
algorithm used by the buffer cache to
use automatic table caching you must na
all the big table cash check the size of
the buffer cache it is currently set to
384 megabytes the SGA target is set to 2
gigabytes set the DP big table cash
percent target initialization parameter
to a nonzero value the value will
represent a percentage of the buffer
cache we will set it to eighty percent
of the buffer cache ensure that forceful
database caching is disabled because it
is incompatible with this automatic big
table feature we now run several queries
on various tables
application tables and then display the
statistics about the objects loaded into
the big table cash observe in the vid on
abilities can cash the allocated space
and the number of objects loaded into
the big table cash there are not observe
in vadala BTW scan object m's the
temperature of any loaded object now we
create a very large table there is now
one object loaded into the big table
cash the view displays the current ratio
of the victor berg cash section to the
buffer cache the target ratio of the big
table cash section to the buffer cache
the number of memory buffers are located
by the big table cash section two
objects and the minimum temperature of
the object currently cached by the big
table cash section you can get more
details for the object loaded into the
big table cash this is the size of the
object being scanned in this instance in
blocks you can also see the temperature
of this object mem only means that the
object is fully cashed in the big table
cash if it displayed disk it would mean
that this object is not cached in memory
nor flash and you can also see the
number of blocks that are attached in
memory for this object 3 select data
from the table the response time is
immediate because all data is in the big
table cash if we flush the buffer cache
the object is still in the big table
cash but if we restart the instance the
big table cash is flushed and the object
needs to be very clear it to be reloaded
into the big table cash let's create
another table another big table and
clearly the data from the new table the
second table is only partially cashed in
memory
and some portion remains on disk and
will not be cached for the moment let's
increase the big table cash % to 90 and
reselect data from the new table line
order to the number of memory buffers
are located by the big table clash
section 2 objects has increased and now
the new table line or two is fully
cashed in memory also observe that its
temperature has increased let's create
another big table I know the three and
query the data from the new table the
new object is loaded into the big table
cash the number of wavery buffers
allocated by the big table cash section
two objects as increased and the new
table is partially cashed in memory try
to increase the big table cash we
reached its maximum if we want to load
the three tables fully into memory we
have to increase the buffer cache weary
select data from the new table it is now
fully loaded into memory when space is
required in the big table cash according
to the temperature of the objects some
will free the space to hotter objects
that's why the line ordered to table is
partially replaced by the new line order
three object which has a higher
temperature the last test increase the
SGA target and the buffer cache the big
table cash is large enough now to fully
load the three objects which have a
temperature they have this is the end of
the demonstration and thanks for
watching</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>