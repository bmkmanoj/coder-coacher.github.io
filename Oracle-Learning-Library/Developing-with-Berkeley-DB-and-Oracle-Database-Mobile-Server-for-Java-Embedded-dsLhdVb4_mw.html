<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Developing with Berkeley DB and Oracle Database Mobile Server for Java Embedded | Coder Coacher - Coaching Coders</title><meta content="Developing with Berkeley DB and Oracle Database Mobile Server for Java Embedded - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Developing with Berkeley DB and Oracle Database Mobile Server for Java Embedded</b></h2><h5 class="post__date">2013-01-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/dsLhdVb4_mw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning everyone this session is
developing with Berkeley DB and oracle
database mobile server for Java embedded
and I'm hickman Wang I'm an engineer
from the Java embedded group i'm here
with my colleague eric jensen he's the
product manager for berkeley database
and database mobile server we have a
small group here so yeah if there's any
questions along the way let's just make
this informal and show show me your hand
and I'll call on you and you can
interrupt me as I'm going through my
slides that's no problem it's an
intimate crowd I should put it that way
so here's our safe harbor statement just
to make sure that all the information
that we're describing enough slides are
for informational purposes and I'm going
to go over the agenda will be covering
today an overview of Java and betta Java
embedded so how many here by a show of
hands have heard of Java embedded
technology okay so you guys know some of
it or most of it and I'll just touch
upon the overview so if there's anything
you want me to dive in deeper just let
me know along the way and then I'll go
over java embedded development since
that's the group i'm from is the
engineering development group of job
embedded i'll go over some of the issues
that we've come across and then this
session specifically is about tying that
the job embedded technology together
with Berkeley database so then I'll
switch it over to Eric and Eric will go
through the rest of the slides of the
presentation covering Berkeley database
with use cases so that part's very
interesting how Java embedded customers
today are using Berkeley database and
then he'll go over database mobile
server how many here have heard of
database mobile server okay so so he's
got to go mostly in depth on to that and
Berkeley database just because that
since this is the topic of the talk and
it seems like it's geared for this crap
and
and also give you CSIS for database
mobile server and then we'll wrap it up
with how you can get started programming
with the database mobile server and for
Berkeley DB using job-embedded so just
giving the value proposition or the
advantage that you get with Oracle's
Java across the board you see from the
left side you have the big servers the
app servers and now what's known as
mobile servers are also showing up on
the backend in the data centers this
this set of devices span all the way
down to the right side which are mobile
clients and this is happening in an
enterprise where you have your servers
on the backend serving up your clients
that people carry around with them in
their pockets such as the smartphones of
today tablets and also embedded devices
where you find in fixed assets that are
non movable and these are all smaller
pieces of equipment now where java still
runs by spanning from the left side to
the right side and what you get are the
gray lines connecting the old style way
of a server to client type of
information transfer and this has been
shown to be very effective also in the
consumer world not just the enterprise
world where you might have a back-end
server that serves up facebook data and
user information and that travels across
the internet the gray arrows there to
your mobile device so you get
applications like the facebook iphone
application for instance moving across
to your device which is going to access
data and in an enterprise world in a job
a world you can do that by having Java
Enterprise Edition Java EE running on
your app server and then having that
data interact with Java ME or Java
embedded clients running on your mobile
clients so you get this orange cloud
here of Java technology and that's the
unified the single unified platform and
language for Java that spans from your
servers on the back
and down to your mobile devices now
we're introducing the mobile server
where Eric is going to go into detail
more about that where you can take your
database mobile server and then
synchronize all the data and
applications from that mobile server
down to your mobile devices that's what
you're seeing in the darker gray arrows
synchronization and management from your
mobile server to your smartphone running
Java ME to your tablets running
job-embedded and your embedded systems
like network routers or printers
multifunction printers or any number of
devices that have these arm chips and
Linux running on them that's a very
common place to run Java and of course
since you know job-embedded seems like
this crowd already knows about Java
being and deployed on billions of
devices already from anything from these
toy robots down to smartphones and
feature phones and you all also see a
car there that's the Audi car that Eric
worked on that's running java real time
and there's multifunction printers the
Kindle from amazon blu-ray players
that's all running java embedded and
this includes not just the consumer side
of things but also there's a industrial
and enterprise there's medical equipment
industrial controllers smart grid smart
meters and so on so you know the
goodness of java embedded already it's a
proven and stable platform there's a
huge developer base because people that
understand java SE will be able to
program for job embedded unlike Java ME
where you have to think in different
terms of subsets of api's Java embedded
is a full set of the Java SC AP is also
you get to fold you get the goodness of
Java you get fully object-oriented runs
on virtual machines there's memory
management and now with all the ARM
chips becoming multi-core and
multiprocessing you want to be able to
take advantage of that also in Java does
that automatically under
covers for you so you get multi-threaded
support multiprocessing support and
multi-core support and then of course
very importantly the security and
networking of Java comes along with job
embedded now here's the the difference
that you see and I directly worked on
Java ME CDC which was a subset of the
full spec now with java SE embedded you
get the full implementation of the java
FC spec and so that's really important
because every time there's something new
that shows up in java SE so for example
a project coin or project lambda that
will show up in our job embedded and you
know you could you could look at other
job in quotes type platforms where they
don't do that they're not keeping up
with java 7 and java 8 you have to
scratch your your head and wonder well
if I'm trying to keep up with Java
technology what's the best way to do
that and java embed it is the best way
because we keep up with the language and
the spec as it moves forward and of
course we address that since you're
running on an embedded device we want to
make sure it's a smaller persistent
static footprint size and it uses less
dynamic memory than your desktop java SE
does so you'll see that our engineering
team goes in and make sure this version
java SE embedded runs appropriately for
linux arm and for embedded devices so we
go in and do optimization is especially
runtime optimizations while keeping the
full spec and so you get this spectrum
and and you've seen this slide before
many times we go from certain java goes
from servers down to java card what
we're talking about in art in our
presentation today is embedded right in
the middle there under the robot you
have java embedded java SE embedded and
that's the corner block of java SC in
the red under the platform there you get
the full java api is that you would need
to program your device if you were
talking about Java ME there's if you go
a little bit too right here in the slide
TV and mobile and they have special API
they need to change the channel of your
television or two to record and play on
your blu-ray blu-ray player or on TV
set-top box those api's are extra on top
of the Java platform so that's why
that's a little different that's more of
a vertical market that we address with
Java ME in Java SE again since we're
trying to match the java SE spec for
desktop where a horizontal platform more
general purpose for programming in java
and what are the best practices for job
embedded how is the best use well the
main concern you will have when you're
addressing these devices that i showed
in the previous slide is that you want
to manage your limited memory so on
these smartphones feature phones on
these multifunction printers you don't
have the 4 gigabytes of ram that you
have on your desktop or even your laptop
computer so there's ways of making sure
your static initializers are optimized
it's not grabbing megabytes of data in
arrays and byte arrays you want to make
sure you're doing lazy memory allocation
so on demand whenever you need that
megabyte of byte array don't do it don't
allocate it until the very moment that
you need it so put that off and we found
that is a big help especially in our
Java core libraries also you want a way
to limit your footprint size so there's
in the future ahead of time compilation
that will provide in Java embedded and
that allows you to convert your java
bytecodes down to an intermediate
language closer to machine language so
that the the JIT compiler the virtual
machine of your embedded device can turn
that into machine language very easily
without having to to process all the
byte codes and class files also you want
to limit your use of threads even though
you have these multi-core processors you
don't want to burn up cycles on these
arm processors that have
multiple cores even if it has dual core
or quad core on it and that's because
every cycle that you're wasting is
eating up your battery life so that's
very important on many mobile devices
such as tablets these days is you want
to extend your battery life and one way
to do that is watch how many threads
you're using in your your application
for embedded also you're dealing with
these lower power CPUs so the processing
that's available is not as fast as what
you get on desktop or laptop so remember
these there even though there's some
chips that are 1 gigahertz they're not
the 3.3 or 3.7 gigahertz I sevens that
are running on your desktop machines so
the the predominant CPUs nowadays is
armed and that's what you have to keep
in mind is what what kind of advances
are they making with ARM chips and how
fast and and how speedy will your
application run also because all these
different types of best practices are
great too to understand and to apply
where would you use that in the
marketplace right now and again they're
embedded devices such as even the
Raspberry Pi which is a target device
that you see a lot mentioned here at
javaone this year it's a target device
that's meant for test and development so
when you're doing your proof of concept
you're going to see that the use of that
CPU the arm CPU they're on on the Brazos
berry pie is going to be very different
than your desktop system so you have to
make sure to apply the best practices
there also on smaller memory and lower
CP at lower powered CPU devices such as
the smart phones they're they're really
trying to keep their bill of materials
very low costs on these devices since
their consumer devices so you'll see the
lower power chips there and most of the
time you're going to have a wireless
network sometimes you have a 3g network
such as the whispernet on Amazon's
Kindle that's actually sprint's 3g
network that they piggyback on to
you that is great because you get this
broadband connection to the data center
in your back-end sometimes it you might
have to count on it being intermittently
there if if the person is within reach
of a 3g cell tower and so you you might
want to adjust your app programming
because of that because you can contact
a back-end server at some point then
make your embedded applications with the
best practices optimized for memory be
able to do bursty types of
communications with a data server not
this continuous connection that you have
with desktop or laptop and then also on
a UI side you have to make sure to
account for things like headless use on
a network router there's no screen no
set of buttons that you're pressing so
you have to make sure your programming
your application to handle that and be
able to be configurable even if it's
headless or it might have just a small
screen small LED screen and then you
want to make sure to address the input
device such as a limited keypad or a
touchscreen how is the user going to
enter in data and how much data will
they be able to do on this limited
device then there's a the different
platforms that I talked about on the
diagram of the layer diagram there's se
embedded which has a small footprint and
it's fully java as fully java SE 1 dot 6
compatible there's Java ME which shrinks
it down even further by subsetting the
java SE spec and then there's Java card
which is the smallest and again just as
a recap is se embed is meant for large
commercial industrial use for fixed
location assets that's like a
multifunction printer it's sitting there
in the print room it's not going to move
around with somebody in their pocket as
they're walking around on the Emmy side
that's where you get the mobile devices
such as a tablet or a smartphone and
this is dominated mainly in Java by the
feature phone and then you get java card
which is used a lot on MDM networks for
security and authentication and also on
side
physical systems so that was a brief
overview of job-embedded just to get a
perspective in the scope of what's
coming next and I'm going to hand it
over to Eric and he's going to take you
into the Berkeley database part and how
that is used along with job embedded
Thank You England so these products are
what we're going to be talking about
today they have several use cases but
the one we're going to focus on today is
really networks of embedded devices or
machine-to-machine networks where you
have a large amount of data that you
need to manage and effectively transport
between the devices but also connecting
to it back end and at the same time
database mobile server actually allows
you to manage the device network as well
but first we're going to be looking at
berkeley DB which is the database you
would run on the devices themselves this
graphic will give you an idea of the
areas where berkeley DB is typically
found from left to right the range we
have here is the data center all the way
out to the edge and really past the edge
to mobile devices on the Left we have
oracle database and more times ten and
you're caching type functions and that's
after that is where you start to see
berkeley DB traditionally in things like
gateways authentication caching logging
servers and so on but increasingly we're
seeing demand for this database also on
mobile devices this slide focuses in a
little bit on the different areas where
berkeley DB is used what makes berkeley
DB interesting is that it's kind of
complementary to java in that it's a
ubiquitous data store that can be used
either on the backend to handle the data
as integrated into a server handle the
data that you would serve out to a
network of mobile devices
on some type of always-on appliance
let's say that was designed to manage
this network really without human
intervention just continuously handling
the request making sure that everything
is functioning the way it should the
other option of course would be on the
right side of running Berkeley DB
directly on the mobile devices and
there's a number of use cases we're
seeing where companies are looking for
really robust scalable data management
on mobile devices as they're collecting
more and more information pulling in
from sensor networks typically but other
sources as well for analysis and and so
forth berkeley DB is an embedded
database and the reason for that is that
embedded databases have a much lower
latency than a traditional RDBMS due to
the fact that there's simply much fewer
layers than an r DBMS on the left there
you have all the different layers you
would find in a conventional our DBMS so
you would have your JDBC you have a TCP
IP layer and then an actual network
connection normally although you can run
the our DBMS on the same box as your
application but you still have all those
other layers in there the sequel parser
the optimizer and so forth whereas with
Berkeley DB is just your application
code and the database Berkeley DB does
have a sequel API you can choose to use
so you would have some of the extra
layers in there added back in if you
chose to use that
we'll go through now the main
characteristics of Berkeley DB
describing what it is number one thing
to remember Berkeley DB is as I said a
library that links into your application
the idea here is to provide very fast
but highly reliable and scalable local
data storage that is also recoverable as
I mentioned its use extemp used
extensively in the middle tier edge and
mobile or embedded applications the
overall goal of this database is to
allow you to do more with less so
Berkeley DB has been designed to provide
you with the the fundamental features
that you need to manage your data but
it's sort of a no-frills database that
allows you to capture and manage huge
amounts of data but typically for a
single purpose and that's what makes it
very well suited to embedded or m2m
networks
going through the product feature review
the basic aspects of Berkeley DB number
one it scales two terabyte data sets so
for mobile or embedded applications that
actually scales well beyond what the
hardware could currently support it's
very good with concurrency multiple
readers and writers what this means is
in n2m type scenarios where you have a
gateway and you have hundreds or
thousands or more of smaller devices
that need to feed their information into
a gateway berkeley DB would be the ideal
database to run on that gateway a real
world example of that for instance would
be in a car the different electrical
control units in the car feeding data
into one central location they need to
be able to do that asynchronously
because they're very usually inexpensive
not very intelligent devices and the
database handling all that needs to be
able to accept connections as they come
in berkeley DB is very reliable we have
multiple customers deployed in proven
scenarios that are five nines or better
59 s is somewhere in the neighborhood of
a couple minutes of downtime per year
fully asset transactional small
footprint berkeley DB is also secure in
addition to the inherent security you
get of compiling your database into your
application you get the added security
of available encryption berkeley DB is
an open source product and we've worked
hard to integrate it with all major IDs
including xcode for apple jdeveloper
microsoft the canoe tool chain for linux
and so forth there are multiple api's
available you can actually choose to use
a key-value api if latency is your
primary concern or a sequel api and it
can actually be configured to operate
fully in memory if again if speed is
your is a main concern
some of the trends that we're seeing
that have really been driving the
adoption of Brickley DB recently number
one a preference for open source
technology this is really being seen
across the industry many of the new
startup companies are fully open source
now another one is that data is really
getting pushed out of the data center
it's on mobile devices on devices and
far-flung locations at your network it's
not the idea of all your data being in
one location and being served out from
that location is is definitely evolving
the services that run on this data are
expected to be available 24 x 7 by 365
and without someone quote unquote
operating them they need to just run so
these are appliances that you plug on to
your network they're configured to do a
single specific purpose and really do
that forever and i'll have a couple
examples of that later on for web
services and SAS the requirements really
tend to be speed with scalability
reliability and availability
availability meaning typically that you
would use a database that has some kind
of high availability mode where if a
portion of the network goes down or a
machine goes down the database can fail
over to the other remaining databases
that's actually a capability berkeley DB
has for the server side on the business
side we're seeing pushes to reduce
development time and at the same time
reduce cost and risk one of the best
ways to do that for embedded development
is to use proven technology wherever you
can the last one that we're seeing is a
focus on the core competency of the of
the company rather than trying to
engineer everything in-house again using
proven technology from outside that you
can rely on ideally open source so that
you know that you know the rug won't be
pulled out from under you at any point
is becoming more and more appealing to
people
we'll look at some use cases now for
Berkeley DB these first two are really
good examples of the server-side
applications I was talking about this
one is adaptive mobile they have a
content protection engine that runs in
this is soft real-time by the way not
hard real-time so this is for a network
of mobile users the content protection
engine needs to make a decision on
whether a certain piece of content will
be allowed or not in enough time that
the the experience is imperceptible to
the user so there will be a blacklist or
whitelist or both running on the server
in berkeley DB and every piece of
content that comes through will be
checked against those lists this is a
similar use case from cisco you've
probably heard the old adage about the
trade-off for any development project
you can have fast good or cheap pick any
two actually as it happens sometimes you
can have all three as it was with this
case Cisco replaced a object oriented
database with Berkeley DB we ended up
being faster than the original solution
more scalable and actually cheaper in
the long run as well here's a quote from
the cisco engineer to that effect
this one goes in a little bit of a
different direction this talks more to
where we see things headed and
definitely to what hink Minh was
mentioning with Java embedded in this
use case a Department of Transportation
of a certain country has chosen to embed
Berkeley DB enabled sensors in a large
Road based network for traffic
monitoring this is exactly the type of
solution that I'm talking about where
you you have to know that it's going to
basically run forever you can't have
technicians out on the roadside
reflashing firmware even if the firmware
could be deployed wirelessly it's still
not something that want they want to
mess around with these sensors once they
get smashed into the road they need to
they need to be confident that they're
going to run for as long as their scope
to run without any software issue
whatsoever we're seeing more and more
use cases like this in a variety of
different industries but I would say the
top ones would be healthcare smart meter
and industrial manufacturing so
industrial automation it will also
automotive telematics this one I put in
this is back more on the server side but
this happened recently so it's worth
pointing out you've probably heard of
Yammer they were in the news not too
long ago for being acquired by microsoft
for quite a large sum of money Yammer
was using one of the popular newish open
source projects that are out there I
forget which one but they ended up
switching to berkeley DB to power their
enterprise social networking platform
and the reasons they did that were what
I've already mentioned the scalability
and also the stability and it allowed
them to focus on their core value added
which was this enterprise social
networking platform which microsoft
found to be quite valuable to the tune
of over 1 billion dollars from here
we're going to look at database mobile
server this is the connecting piece for
your m2m network berkeley DB
enables the storage on the device itself
but you need something to get that data
off of the off of those devices and onto
your back end and at the same time you
need a way of managing all those devices
and understanding what's going on with
them database mobile server provides
both those things in one package tying
it all together here's a very high level
diagram of how database mobile server
works you have application subscriptions
and your devices out in your network can
subscribe to those applications and with
that subscription comes a data flow so
the data flow is tied to the application
once you get the application you have
access to the data flow as well and what
I mean by that is that your local
database is now linked to the back end
without you having to do any anything
else and changes that you make locally
will be replicated on the backend and
vice versa so these solutions are
designed for any type of deployment
where you need the best of both worlds
yeah I'm going to stay on the slide to
finish talking about this and by the
best of both worlds what I mean is you
need the data on the device so that
you're not relying on the network for
the devices operation but you also need
the data on the back end where it can be
we're number one it's secure and number
two you can perform any type of
analytics or whatever function you need
to do with that data and it'll all be
collected in one location without you
having to go out and constantly grab it
all the time the value proposition for
database mobile server or DMS for short
can be broken down into three pieces
number one is autonomy as i said the
device can perform its primary function
without dependency on the network the
database the web server the application
server all those pieces that normally
would need to function in a if you
develop the network in some other way
the device is no longer dependent on
that so this is very popular in any
scenario where you have a device moving
around constantly through a 3g network
that comes in and
or in a healthcare scenario where the
actually there's a demo you'll be able
to see I'll talk about this later on but
in a healthcare scenario where the data
needs to stay in the hospital bed in the
room with the patient in case the doctor
needs to come in there in case of an
emergency but it's also needed on the
back end where it can be stored and
analyzed for diagnosis and so forth
total integration the idea here is that
database mobile server provides not only
management for your data streams with
the devices as well the unified
management console allows you to check
on the status of all of your devices you
can check on the status of your
applications you can force a
synchronization if you want the latest
data snapshots and so forth the last one
is security which is very important in
embedded scenarios a lot of the data
that's being collected by our customers
is very sensitive and we take security
very seriously I'll talk more on that
towards the end of these of the DMS
portion getting into the technical
details a little bit database mobile
server can be broken down into three
groups of pieces for developers and I
assume that most of you in this room are
developers of devices you are going to
want to focus on the mobile development
kit or MDK this is a set of tools that
will allow you to develop your
applications it could be for java or
native applications as well that will
link into database mobile server just
quickly in case anyone is actually
interested in understanding the total
solution the other pieces are the sync
server and mobile manager console which
are the pieces running on the backend
the sync server is the piece that
handles the data synchronization the
management console as you might expect
is where you would manage your devices
on and it's fully integrated so you're
also managing users if you for mobile
deployments you would probably have a
single user for every device for
embedded you might have a single user
for
all the devices or maybe for specific
geographical regions or something like
that anyway however you choose to do it
you can manage everything from one
console the last piece is the mobile
client which as developers you would
develop with that mobile client and once
the application is packaged up and ready
to go the mobile client will be in there
in the form of either a library or a
standalone executable the choice is up
to you and once that application is
pushed out to the device it will handle
the synchronization and if you choose to
enable at the device management as well
this is a list of our platform support
actually I'll just pause here and see if
there's any questions on what we've gone
over so far or on this slide okay well
keep going
this is a review of the features that
I've been talking about so far so far of
database mobile server the important
thing to remember is disconnected mode
of operation anywhere where the device
operation is of tantamount concern that
it's able able to operate in a nun
interrupted fashion you want to use
database mobile server anywhere where
latency is a concern and you need the
data immediately available for not even
if it's not a requirement but just more
pleasant operation a lot of the
background of database mobile server is
in field personnel guys that are
so-called the saying goes that they're
either up a pole or down a hole they go
all kinds of crazy places where there is
no cellular signal still and what we saw
is kind of a dip in popularity a few
years back of these types of products as
people thought that 3g and 4g and so on
would really kind of save them from
having to do this and then a few years
ago they all started coming back
realizing that it wasn't working out and
their their mobile workers were having a
lot of issues in the field and
ultimately though i think that these
type of solutions have a place for the
foreseeable future until we reach maybe
decades out some type of ubiquitous
gigabit quality gigabit low latency
network you're going to want
synchronization in addition database
mobile server provides secure selective
access to the back-end data so you don't
need to synchronize data that's unneeded
as I mentioned we offer remote
management and diagnostics and the most
important piece of that is remote mobile
provisioning so the main reason people
choose to enable device management would
be once you've got that device
management agent on their future
versions of the application can be
pushed out from the mobile manager
console without you needing physical
access to the device any longer in
addition you can remotely wipe databases
you can remotely check on the database
you can perform other commands I'll get
into that more later but it's a pretty
powerful system
here's a peek into the it's a really a
high level diagram but the architecture
for how the client-side would work in
your Java embedded device you're running
your mobile application with a local
database berkeley DB in sequel light and
beauty of this solution is that's the
only database you ever need to worry
about these databases are very easy to
develop for and there's plenty of
examples online and it's generally just
not a problem once your data is stored
in the database the sink engine is going
to take care of everything else it's
going to based on the rules that you
define sink that data up with your
back-end and then what you end up having
in the back end is a huge set of data
from all of the devices you have out in
your network as I mentioned if you
choose to run the device management
agent you get a bunch of other really
cool remote features I'll go into a
little bit more detail about that in the
coming slides but first looking more at
what synchronization allows it uses a
publish-subscribe model as I mentioned
at the beginning you will publish
application and with that data flow and
then applications will authenticate and
subscribe to those those publications it
supports data subsetting so you don't
have to just synchronize tables you can
actually get a specific as synchronizing
specific rows or columns out to your
devices the conflict resolution is also
very advanced and that's important
especially in scenarios where the data
is being modified both on the backend
and out on the client simultaneously you
can define rules based on arbitrary data
in your database or from other sources
about who will win on a per on a very
specific basis on a per value basis for
conflict resolution and the system is
also fault tolerant meaning it's
designed to succeed over multiple failed
attempts iteratively over a shaky
network that can be very useful in 3G
type scenarios and places where network
coverage is still spotty in addition to
everything here synchronization can be
set up to be automatic and
bi-directional
application management this is one of
the cool remote features i was
mentioning once you bootstrap the client
you can then manage your applications
remotely you can check on the
configuration you can pause resume
uninstall applications push out new
versions to entire networks of devices
all at once from a single from a single
back-end console in addition to that we
have the device management so looking at
the device itself you can check on the
health of the device you can disable the
device if you needed to do that for some
reason you can or just choose to lock it
down temporarily all these kind of
things are possible a few more words
about security we offer encryption
support at every layer and what that
means is the data is encrypted at rest
on the device it's encrypted in transit
as well we have externalized Security
Administration if you choose to use it
we have our own as well but you can
integrate with Oracle's a variety of
Oracle security products the most
important of those is called Oracle
platform security services which is a
set of standardized Java API s that's
designed to enable the most the best
security practices for for java
applications and then lastly babe by
virtue of being able to control your app
and data subscriptions you really get an
extra measure of security on top of
other types of implementations ok so
I've got a couple use cases for you and
we've saved some time for Q&amp;amp;A at the end
I chose these two use cases because both
of them are available at this conference
for you to check out today I have a
bunch more if you're curious I could
just talk about I don't have slides but
once we get through these but these two
are important because you can see them
right after this if you choose to the
first one is from a company called M
frontières this is a relatively new
company but they're doing some really
cool things and what they've enabled is
a role based application management
system that sits on top of our database
mobile server product the idea there
would be
that you could define a role for a given
user and that user could also be a
device and then all the rest of the
management of the applications is taken
care of for you automatically so it will
push out whole groups of applications
based on the nature of the device this
becomes interesting as you start to
think about more advanced m2m networks
for instance in a hospital you would
have different types of sensors hooked
up to the bed in a car is the same thing
you have different types of sensors
sitting around in the car these types of
scenarios we're going to need more and
more management of these devices and m
fijn tears has taken our product and
really built a very nice management
layer on top of it for those types of
scenarios they're over in Moscone if you
want to check that out this one is right
over in the hilton and i think this one
is pretty exciting what we've actually
it's not on the slide let me just
mention this is I think booth 5605 in
the exhibition hall of the Hilton that's
5605 what we've done here is built a
Java powered m2m pulse oximeter which is
a device that measures the oxygen
content of your blood and the pulse as
well this is a real thing it's not a
simulation we have a live pulse oximeter
at the demo and what it will do is it
will take a reading using this m2m
device and then automatically publish
that data to the back end from the back
end and this is the really cool part the
the doctor would be able to subscribe to
the data that is linked to the patients
that he's assigned to and he would just
see that automatically on his mobile
device and so really you have the data
in every place that it needs to be
number one as I mentioned earlier the
data is is in the hospital by the bed
where it needs to be if something were
to happen with the patient and the
nurses have to come in and assess the
situation rapidly the data is there and
they can see it that's the most
important place number two though is on
the back end where we can do analysis on
it and in health care there's a lot of
talk right now about healthcare
analytics where you can picture these
huge decision matrixes where someone is
exhibiting
exhibit amande you say okay if the next
thing that happens is this symptom it's
one of these five things if it's this
symptom it could be any of these if it's
this symptom you know run these tests
and this is based on historical data
from other patients so you need the data
from everyone anonymously of course on
the back end to to build up these kind
of systems that will improve the health
of for all of us the last place the data
needs to be is with the doctor who is
under greater time demands and and
resource demands now more than ever on
the his or her mobile device where they
can do the diagnosis anytime at their
leisure enabling them to give the best
service but also keeping that data
secure because it is you know sensitive
patient data so i encourage you all to
go take a look at that demo this is a
live demo every piece of this is
actually functioning on the mobile
device the back end all is actually on
the form of a laptop for the demo and
then the m2m java device as well how to
get started so we've this is a very
brief introduction to a complex problem
and i want to be frank with you so the
the pieces that we're offering here this
is a little bit more complex than you
know writing just let's say a very basic
java application but it does enable you
to do something incredibly powerful and
we're not aware of anyone else who's
doing this stuff yet today so once you
have your java embedded device you're
going to want to install the mobile
development kit or MDK from there you
want to take a look at the documentation
I've actually got the QR code up there I
don't know if it will work but there's a
link in the presentation as well for you
to check out and that will start to give
you an idea of the steps needed to set
up all the different moving pieces and
the learning curve can be a little bit
steep at first but once you get over
that hump you'll find that you're able
to do some very powerful things with
this technology without having to write
any additional code and that's something
we're very excited about
there's our disclaimer again I don't
think I give away any secrets but anyway
there it is one more time so we're into
the Q&amp;amp;A section very good yeah I wanted
to remind you you were going to mention
the hands-on lab thank you so the first
thing before we get into the QA we have
a hands-on lab about Java embedded
platforms tonight it's at 7pm but you
should go anyway there's going to be for
every person there's going to be a Shiva
plug linux platform available for you to
program java on and the guy who wrote
that health care demo that i just told
you about is running the hands-on lab so
if you want to get some first-hand
knowledge of how to do that cut type of
thing you want to go to that lab tonight
his name's Jim Connor so you can tell
him I sent you but anyway the important
thing to highlight there as well I mean
Jim Connors is a very smart guy but he
built that solution by himself in a few
weeks working in his spare time he's
actually our set one of our sales
consultant so that's not as primary
function so again he's a very
intelligent guy but that gives you an
idea of what's possible with this
technology quickly some links this is
more of the blog and social type of
hangman runs a great job embedded blog
he's an excellent blogger and I
recommend you all read it it's funny
it's always topical I I read it for
entertainment value actually seriously
and he gets quite a few hits I try to
cover Java embedded java mobile
sometimes so it's a good one URL if you
want my blogs are okay you should read
them but I'm not making the same promise
as I am for hangman the Berkeley DB blog
and mobile and embedded are the ones
that I I maintained on there's good
stuff on there but humans humans better
at it we also maintain some LinkedIn
pages these will all be in the
presentation that's available for you to
download and then I run a couple Twitter
accounts as well my own and then the
Berkeley DB account here's a couple more
QR codes about the products and that
takes us into the QA are there any
questions I can answer for you yes sir
you have a friend support other data
rates general
mmm so there's a long answer this
question i'll try to get through all
aspects of it very quickly number one we
chose it's true that we only support
oracle database on the back end and we
chose to do that because we're able to
optimize for that database and make the
system very fast and very efficient
which we feel is important for the
customers now of course your point is a
very good one that people want to use
other databases so there are
alternatives available for them today
those would be number number one the
most recommended would be to use oracle
goldengate to replicate between the two
databases there are other replication
options available so you would still
need an Oracle database but if their
deployment is relatively small that
could be a cost-effective solution
there's a number of replication
heterogeneous replication options
available that you could use today the
other option we are considering again
this is remember the disclaimer and so
forth we are considering other options
to replicate directly from DMS out to
other databases we're looking at the
business case for that I would say so
it's definitely not something that is on
the road map but we should talk more
about that offline any other questions
okay so that we covered everything yeah
I think we did so thanks everybody for
attending this morning i hope you got
out of this what you were expecting and
just flashing these I don't know if I
can go back actually I was going to put
up yeah you can find us on LinkedIn you
can find us on Twitter you can find our
blogs find our products and thank you
for your time today thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>