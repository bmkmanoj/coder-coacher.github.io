<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Advanced Enterprise Architectures Using Open Source | Coder Coacher - Coaching Coders</title><meta content="Advanced Enterprise Architectures Using Open Source - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Advanced Enterprise Architectures Using Open Source</b></h2><h5 class="post__date">2013-01-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Ct6qXjvchFc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright we'll go ahead and get started
how many here have worked with something
like Apache some open source software
systems before frameworks okay just one
or two of you alright so let's get down
to more specifics who hears worked with
academic you okay few less how about
something like her a for osgi all right
camel okay I'm just going to keep doing
this and then we're going to get our
exercises in so see XF all right
excellent so a little bit of background
and these is going to be helpful today
basically I'm going to be hitting you
with a fire hose there's a lot of
information in these slides this is
basically two weeks worth of war
compressed into one hour so what you get
to see now is kind of the the general
guidelines of some of the stuff that I
have seen over the past couple of years
and working with these architectures
utilizing those frameworks that we just
talked about so that's what you're going
to get out of this there's also some
example code that you'll see near the
end you will have access to that via the
website from Oracle so anything that you
see today you will also be able to
download let's hope this works yeah so
Who am I I am an open-source evangelist
there's not a problem out there that I
don't think can't be solved that was a
double negative yeah that can't be
solved with open source almost
everything out there has some sort of
solution via open source and the nice
thing is is that the reason why I find
it so awesome is because if there's
something wrong with it I can go in and
debugging I can change it that's the
power and then what I get to do is
commit it back which is even better so
if you guys aren't in the process of
doing that right now I highly encourage
you to get involved the reason being is
then that way you're building a product
that you're happy with and you're
allowing the rest of the the people and
who are utilizing the framework to also
take advantage of your knowledge so
there's my evangelism now I'd like to
talk to you about Scientology
now I'm just kidding so Who am I I put
this picture up there because it serves
two purposes one it makes me look like a
badass too there's a slight alteration
to this photo and the reason why it's
there is because being an SOA architect
there's a lot of little hidden gems and
some of the software on the surface they
look badass you get to build these
systems they fit together really well
very easily and everybody gets to you
know you show it to your p.m. and show
it to the CTO or whatever and it works
great out of the box for your tests the
minute you put it into production ten
minutes later everything blows up goes
down and then you're on phone calls for
the next five weeks but that's part of
the idea of knowing what to do and what
not to do from an SOA architecture now
or recovering today are some of the
basics the general guidelines i would
say best practices but we try to avoid
saying best practice the reason being is
because best practices are going to be
more aimed at what is best for you and
that's an individual decision so what I
like to say the general guidelines this
is where we're going to start this is
where I would normally start with most
of the the enterprise systems that I
work with I'm not going to point out the
alteration of the photo but if you see
it don't mention it I also get called
into a lot of firefights people go out
they assemble these products I put them
together everything works hunky-dory a
test blows up in production hey active
and Q is garbage it won't work it runs
for three days and then just you know
basically goes down I have to go in and
firefight try to solve those problems
for them so that's where I come into the
picture i also do a lot of trainings
depending on on what you're trying to
achieve whether it's CX f camel we offer
a lot of trainings too so it's not only
as a firefighting but it's also trying
to mitigate to make sure that people do
the right things out of the gate
so what are we covering today there's
quite a few things here so we're going
to touch on all of them how to put them
together because a lot of the stuff that
you see out there on the web covers each
individual piece you can go out there
and you can learn everything you want
about camel okay but how do you get it
to work with activemq what's the general
guidelines when putting that together
how do we build build it into an ESB or
carafe or osgi however you want to stay
it enterprise architectures this is the
key this is where everybody goes okay we
need to get on the bus so it's a
buzzword but what does that actually
mean what is it there's a lot of
products that ending the SB is that what
it is we're going to talk a little bit
about what the ESP really is and how I
don't like using the word the term ESB
just because of what it stands for
because it's not it's not indicative of
what you're actually trying to achieve
so integration the whole purpose behind
the ESB is to get everybody to integrate
I want to I want to talk to system ax
system why System z and then I want to
pull all that information together but I
have to do it in a specific order and I
have to do in a specific way so I'm
going to route this information in a
specific way and that's where camel
comes in camels good for this you'll see
in very little amount of code you can
easily put together integration with
multiple systems but if you want
guaranteed message delivery if you want
to keep those messages in a way that it
allows you to scale and at the same time
gives you guaranteed message delivery
you have to use a messaging system and
also helps prevent you against bursts
message burst also gives you the ability
to throttle stuff like that
high-availability what happens if the
system goes down and more than likely if
you've used open source you've seen a
system go down so how do you handle that
how complicated is to set those things
up and of course everybody's favorite
osgi
how many people here work with osgi how
many people here want to work with osgi
okay there were fewer hands it's not
that bad I prefer it but that's because
i've been working in it forever but it's
it's a matter of getting over that that
home to to getting things to work in
that environment you'll see some of the
pros and i'm sure you've run into the
cons before to the difference between
spring and blueprint because a lot of
people when you hear the word the term
blueprint as an ioc what does that mean
it's a whole nother ioc and it's going
to be complicated i want to learn
something new Springs been around
forever blueprint isn't that different
and we'll take a look at some of the
different differences between them and a
lot of times people don't even realize
they're looking at a blueprint
configuration file and then of course
the big term ESB now i'll just keep on
so this is the architecture we're going
to look at today this is a general
architecture that I run into constantly
in the enterprise industry it's a
generalized architecture so but it fits
a lot of the use cases that we
constantly see in an integration system
so what we'll do is we'll just walk
through this really quick and then we'll
tear it apart so you can see each part
of this and how its set up because what
this provides is high availability on a
high on a high transaction type of
system so you can pass a lot of messages
through this and it can handle a lot of
clients as you can see where's my rent
thing at the top the basic entry point
for this system is going to be a web
service call now this could be other
things it doesn't really have to be that
but it's just basically in an
integration layer where you're telling
if I can get it over there you're
telling other people how to communicate
with you and in this case we're setting
up again the ESB ESP is basically a
proxy in this point all you're really
doing is giving your clients some
to communicate with now from that
standpoint what are you going to do with
this proxy the idea is here you're just
going to take information you're going
as quickly as possible pass it on you
don't want to hold on to that
information very long in the proxy layer
you want it to be fast you want it to be
thin because you want to be able to
either to release that client or persist
that information as quickly as possible
because you can set this up either as
asynchronous or synchronous depending on
your use case which one's better depends
on your use case where your requirements
preferably in my mind asynchronous is
going to work better and that's the way
it should be set up but it a lot of
times requirements dictate otherwise so
inside the proxy layer you can do things
like this with camel so the web service
proxy basically you're setting up a CX f
endpoint pulling that information in and
doing something with it whether it's
setting up of transformation you can
decrypt or encrypt depending on what
you're doing with the information coming
in and then you persistent to activemq
these systems have to be very
lightweight the proxy needs to be thin
and you'll see why later because when
you architect the system you want to be
able to scale your system at different
levels and you'll see why on some of the
later slides but so the idea here is
that the proxy layer is very thin you're
not going to do a whole lot here a
couple of things transformations
decoding whatever maybe security that
type of thing then you've got your
activemq layer this provides a
persistence layer so you're passing it
off to your activemq messaging layer
activemq has the ability to set up high
availability ability with active and
passive this is where you're guaranteed
messaging comes in now for some reason
activemq goes down or your message layer
it will fail over and you've lost
nothing your your proxy layers will
automatically switch over and
everything's hunky-dory and you go into
the annuals of your banner priory of
your company as the hero and it didn't
take anything on your part to fix it it
automatically does that for you there's
different ways of setting this up and
I'll show you some of those too
because this is very important when
trying to set up set up your system then
down here this is just kind of the fluff
this is where your business logic is you
know whatever you're trying to achieve
here this is just a simple use case
utilizing camel to say okay I'm going to
pull something from activemq got my
leash here I'm going to trip um you've
got activemq coming in in this case
we're just doing a multicast to two
different beans processes doesn't matter
those can be anything you want i just
called send mail and update database but
if you're familiar with camel anything
in there I mean these are just routes
and then I'm aggregating the information
this is kind of what we're going to be
going through today just as a simple use
case the information that's in here
really isn't that important it's how you
configure these systems to work together
that really is the meat of the
architecture so let's take a look at
some of the messaging system this is
where you set up your high availability
this is also what's going to prevent you
from overloading your system and give
you the ability to handle bursts of data
that kind of thing and also scale at
different levels so one of the the first
architecture I guess deployment options
for activemq is the ability to set up a
non-shared pure master slave what this
does for you is it gives you two
different persistence layers or two
different persistence stores but there's
a problem with this does anybody know
what the problem is with this raise hand
no
yes yes yes there's there's multiple
stores here so now you're paying the
price just up there you're paying the
price of data persistence on two
different stores also and you're paying
the price of storing that data in two
different places because the master
cannot acknowledge this mat the the
message until it's been persistent it
has to be persist places to maintained
agron data integrity is there a use case
for it of course there is that's why
it's there and there's been several
companies that said based on our
requirements we need to do this fair
enough this is not the general guideline
that i would suggest why because when
one when the master goes down the slave
is specifically configured to attach to
that master so how does that to happen
here's Anna can you guys see that code
it's not going to work well if you can't
see and I apologize but you're setting
up the the broker with the master
connector URI and then you're giving it
its own data data directory because
you're setting up the master you're
telling it here is my master so you're
defining master vs slave it's not the
best idea the reason being is because
once that master goes down you failed
over the slave now you're stuck you have
to shut down your systems and copy data
back over and then restart both systems
so you've got to have downtime available
to your system in order to get this back
online in a full HHA environment so is
there a use case of course there is this
is a very fast failover also it happens
very quickly it doesn't because it's not
based on locking mechanisms what you'll
see in a little bit here's the other
deployment option this is the one that's
kind of the general guideline this is
the best practice as they say so what
you're doing is you basically have two
configurations you've got a master in a
slave both
into the same shared persistence store
and this can be file system which is the
general recommendation is to say let's
use ass and now something or you can do
it via jdbc jdbc is going to be a lot
slower because now you're paying the
price of JDBC but for people that are
Oracle based my sequel based whatever
and they don't have availability to ass
and it's another option but it's not
going to be performant and I say that
was sure confidence it doesn't while it
was long it's not going to be as
performant so what does this look like
you're just pointing your database at
the same data store as your slave no
special configuration needs to needs to
happen you're mastering your slave point
to the same data store that's it so when
the master goes down your slave becomes
the master now you can just fire up
another instance of it and it becomes a
slave it's also a good process for
migration so now you can migrate your
systems so if you want to upgrade
activemq you can shut down 551 let it
fail over startup an instance of 56 shut
down your other your slave or your 551
and boom you're up your updated 256 no
downtime sure it sounds that simple
right really is one of the other things
that's important is checking for corrupt
journal files so that in case something
happens when it shuts down it'll correct
those journal files older versions of
activemq actually had an issue with that
so if we were looking at something that
was using a database it's very similar
you're just setting up the persistence
adapter in this case for the database
that's JDBC persistence adapter and then
you're giving it a data source that data
source then sets up a table lock so all
it's doing is setting up locks whether
it's JDBC it's a table lock if you're
using the file store it's a file lock
on that location now that also means
that there's a delay in that in that
switch over from masters slave because
what that means is there's a certain
amount of time between when one system
shutdown shuts down and releases that
lock from your file system and that can
be configured but there is a delay and
you'll see that too because we'll
demonstrate it but it could be anywhere
from 5-10 seconds that kind of thing and
plus activemq is actively pinging for
that lock so your slave instance is
sitting there trekking to see when that
lock is released so once you have your
high availability how do you scale
activemq well activemq has this notion
of network of brokers so now we can have
two active instances of activemq which
can provide a certain level of high
availability but with two active
instances you're not you don't have that
guaranteed message delivery the reason
being is because if you're just looking
at the top to the Masters the master one
and two and you're using two actives as
your failover they're not sharing data
or a data store they're not sharing the
data store so if one system goes down
and hit it had messages on it your
clients will fail over so they have an
in stay have the idea of high
availability but you're not taking up
and picking up those those messages that
were in the store of the other active so
it's not true guaranteed message
delivery and it also doesn't provide you
true high availability this scenario
does because now what you've got our two
actives two slaves they fail over to
each other these two share a persistence
store these to share persistence store
this guy goes down he picks up he
becomes active he reconnects to this guy
he starts sending his messages yes
no they should have the same arrows
thank you for pointing that out
appreciate it yeah I mean it's it
depends on which one goes down at any
time be but all the connections are
duplex yeah appreciate that no thank you
so here's how you set this up network of
connectors and as he had mentioned
setting up the duplex that allows you to
weigh communications across that
connection this that's also good for if
you're dealing with firewalls if you if
you're allowed a one-way connection from
a system that they don't want you
establishing the connection one
direction through their firewall you can
set up the duplex connection and that
allows you to wait connection over one
network connector and then in this case
we're setting up a perdu persistence
adapter kaha DB yes no no this has been
here since five are you talking about
just the URI are you talking about the
network connector itself network of
brokers that's been there just as long
this has changed a little bit since it
was like from 50 to 51 there was a
change in the syntax a little bit but
that's been around since 51 but what
this allows you to do is you're
basically giving it two different sets
of failover so what you can do is stick
a comma here and do another set of fail
over so you can string together
different failover groups that way
you're giving it more than one active
master to connect to one of the other
important pieces to this well let me go
back to the chi hai DB you've got
multiple options for persisting your
data even in a file system level you can
use kaha DB there's the am
q persistence or their different options
kaha DB is going to be the best practice
and then hates saying that it's the
general guideline and the reason because
what this allows you to do is dynamic
indexing on the file slows it down a
little bit but it's pays off huge
dividends when you fail over because we
used to get people complaining well it's
not failing over what's happening well
the Mars masters going down the slave
looks like it's trying to instantiate
but it just sits there okay how big is
your file store under which it's trying
to start up with well at that point they
had filled up their file store so when
they failed over what ends up happening
is that rehab had to reindex that file
that could take as much as 20 30 minutes
not marry many developers will sit there
for 20 30 minutes waiting for something
to come up so of course it looked like
it locked so this took away that problem
now you get dynamic indexing on the file
it fails over almost instantly once the
lock is released then you've got the
transport connectors this is how it's
activemq is telling people to connect to
their system so this is how it
instantiates those connections now the
nice thing about this are these mothers
more than these but these are two of the
more important parameters to know about
when you're doing clustering when you've
got multiple masters the reason being is
because before 55 you had no instance or
no way of telling it well I've got a
bank of clients that are connecting to a
network of brokers once they got that
connection that was it they were
connected to that master no other option
so if you wanted to scale and you said
well our system isn't handling it we
need to bring up another academic you
instance your stuff didn't didn't scale
truly because unless you who your client
went down and re-established connection
and knew about that other the new master
or the new broker it didn't do anything
so what this does is this now update
your clients to say regardless of what
my architecture underneath looks like
once i get a connection update my
clients with all of the URIs they're
currently in my network of brokers so
now your client automatically knows
about everybody else even though he's
not configured for them and the nice
thing is is rebalancing you can now tell
it drop the connections and let them
re-establish and let that balance is
them across all clients yes are you
talking about the rebalancing it happens
dynamically so the client doesn't have
to do anything you don't have to sit
there and tell the client to well you
know somewhere in your coach shut down
this does it automatically for you so
are there any more questions about
academic you I know I kind of hit you
with a lot of information we're trying
to put together the the whole
architecture really quickly so does
anybody else have any more questions
about activemq at this point yes yep yep
you can do as many I'm not going to say
that you can't infinitely do it but yes
you can do quite a few yeah yeah because
that's going to have a dependencies on
your hardware implementations what your
environments are things like that the
next piece is the CX FPS this is your
proxy this is what's going to allow
people to talk to you or you can talk to
other systems this way also so what is
that that's really tiny but basically
what this is is this gives you the
ability to look at or create an end
point within camel so all of these
slides are based on camel at this point
so see XF is utilizing the sea XF camel
component you can also utilize see XF
standalone framework you don't have to
use the CX f component and there are
cases under which I would say don't use
the sea XF camel component but for the
simplicity sake of this session we're
just going to embed it and use use the
camel component so all I'm doing here is
setting up the information setting up
the address the URL what I'm trying to
point out here is that within the
configuration file once I've defined
this see
XF camel component right there that ID I
can now utilize that in my camel route
so that gives me the ability to do the
from so now inside my camel code and i'm
using java dsl here but you can also use
spring to configure it i can now call CX
FB and report domain that's the
published end point i can now receive
messages oversee XF from that end point
now in this case I'm just doing a choice
on it and saying okay using some simple
logic to say okay well based on the
header information the operation name
I'm going to do this I'm going to
convert the body and then I'm going to
send it off to activemq so that
completes that first proxy layer in one
well there's two configurations and i'll
show you the other one in a minute but
in two configurations and this line of
code you've got that proxy layer very
little code very little work that's
what's awesome about it you know I
expect more excitement I'm jazzed yeah
so you know from the standpoint of a
developer I'm just like this is this is
the least amount of work at a you know I
could do that whole proxy level a layer
in a day and then take the rest of week
off so this is the part that excites me
so now on the back end where you saw
that that business logic layer this is
the code set up for that now again
you've got a little bit of configuration
from the activemq standpoint but that's
it of course great question everybody
hear that question what's running this
basically is a question what runs camel
pretty much anything you want except
camel you need some sort of container
whether it's jetty activemq carafe
which is osgi mmm straight Java and you
can fire it up in a je container it
doesn't matter camel will run in
anything I say anything it's not going
to run in c-sharp there's limitations to
my statements but so yeah this is this
is basically within a configure
statement of your camel API so now this
is that entire piece on the back end I
expected to hear cheers you know I mean
aren't you get jazzed about that a
little bit of code very little to do all
of that work so let's walk through this
real quick what is it doing it's pulling
from activemq I'm setting a header on my
message which is just basically here's
the the identifier and then I'm putting
a concert of one in there then I'm multi
casting to these three endpoints well
these three endpoints then I'm just I'm
throwing it at a beam and this is a beam
that I've created so there's no
limitations to it's just because it's a
route you don't have to use what camel
provides it gives you plug ins to say
I'm going to create my own process as my
own beans there's no limitations to it
you can pretty much do anything you want
to do because if there's not an endpoint
that supports what you want to do or a
component you can write it you just have
to stay within the confines of the
exchange exchange patterns and stuff
like that but it's very simple to do and
then basically I'm taking these three
external endpoints and I'm aggregating
them back together and in this case I'm
defining my own aggregation assembly
strategy so I'm telling it I'm going to
tell it how I want it to pull these
messages back together and you'll see
that right here but will actually move
the slide students here so this is just
an aggregation strategy from this
standpoint all I'm doing is I'm saying
I've got an old exchange i got a new
exchange coming in that new exchange
gets reassembled and then it processes
back and the one coming out of here is
the one that's going to be old
now based on that there's a general best
practices wrong way wrong button just
check for Nolan that old old exchange
there's no sense in processing if you
don't have anything in the old but other
than that you just you work with the the
exchanges assemble them the way you need
there there are in camp there it and
camel there are specifying aggregation
strategies for you so you don't have to
define your own but you got to make sure
that they do what you expect it to do
because a lot of times aggregation
strategies I would expect them to say
okay if I've got three messages coming
in and I say egg am I expected to join
them together a lot of cases the default
don't join them together they give you
the last one so just make sure that the
strategy that you're going to utilize
fits your use case so here's how you set
up the activemq components you see in
those in these routes activemq at the
beginning that's not a reserved word you
can use anything you want there you are
configuring that so here's an example of
setting up an activemq endpoint in this
case i'm using the activemq component
you can use other things to cannot talk
to other mq systems whether it's IBM mq
jboss mq whatever you can utilize the
JMS component to talk to other JMS
systems as well so it's not really it's
not something where you can only use
camel against a specific JMS
implementation yes
hmm yep now the one thing to keep in
mind though is that the the exchange
object that's being utilized in camel is
not the object that gets put on the
activemq it's the body of the exchange
that gets put on put on the activemq so
if you put something in the header of
the exchange that does not get
propagated to the back end so you lose
whatever is in the headers of the
exchange unless you put them into the
body of the message or as headers inside
the message or other properties inside
the message so in this example this is
just to show you that activemq is now
the component name so what I've named up
here as the bean ID is now what I use
here to make my call to active and cue I
could use my mq I could use Heath's
awesome activemq it doesn't matter it's
just an ID yes correct so that's I mean
that's that's the bonus here like he
mentioned there's you can get away with
doing all of this with no JMS code now
there are configuration strategies that
you have to think about whether you're
going to be you know how you're going to
be pooling your connections to activemq
are you going to use the activemq pooled
connection factory are you going to use
the cash connection factory from spring
each one has a different pay off those
are things you have to think through
when you're configuring some of these
things but unfortunately we've only got
an hour so I can't go through all of it
this is just to give you an idea of the
difference between blueprint and spring
yes no
well yeah I mean there's thirsty than I
don't want to sell it's a definite when
I say that yes you can but not in
general practice I haven't seen it used
outside osgi but there are
implementations like jeff had said that
will dip Oh Joe SR that you can utilize
yes I'm sorry I didn't hear that yes and
it could be anywhere inside your own and
you can also set it up to be
asynchronous communication with it or
you can set up to be synchronous I mean
there's no limitations to how you can
set that up there are things you have to
think about like if there's an exception
thrown how do I handle and that's that's
a big I'm just going to point that out
right now since i'm on the topic
exception handling is huge no you're
unhappy paths because all the time
through these through these routes
exceptions can be thrown how activemq
handles those may not be what you expect
so you want to be as specific as
possible to say i want it to do this or
I want it to do this because I want it
to go back and I want it to retry this
message you have the ability to do that
within camels so that you can specify
that I'm going to retry this this
message inside camel before I
acknowledge it there's a lot of
different possibilities in there and you
have to think through a lot of those
unhappy type of scenarios and just camel
testing isn't going to do that for you I
have a little snippet down here just to
remind you guys of that too is that you
can do a lot of testing but it doesn't
test everything unless you set up full
functional test Suites
so just as a quick snippet just and this
is a slide just to kind of show you guys
that there's really not a whole lot of
difference between blueprint and spring
a lot of people that I talk to are
always oh you're going to use blueprint
you know we don't have blueprint guys we
have spring guys and it's really not
that different as you can see I mean if
you look at this configuration it looks
a lot like spring really the main
difference is are you got a blueprint
tag down there oh it's going to throw
everybody off and your name spaces are
going to be different and there are
certain functionality that you get from
spring that you don't get in blueprint
but you can employ you can put them both
in the same environment that's also the
beauty of osgi so if we look at the
difference here really for a CX F end
point when defining a CX FN point the
only difference is that we've got a
wrong button we've got beans to find up
here with different namespaces CX F also
require some imports in blueprint you
don't need them so it actually makes a
little cleaner but if you look at how
they're implemented the same things
apply you're just defining the CX FN
point and then you're telling the camel
context where to start so here's my
favorite part is defining ESB what is an
ESB everybody hears that term and a lot
of higher ups like to throw that term
around but really what the ESB is it's
it's a layer under which you can
implement routing and integration and
that type of thing it's a buzz acronym
really but in open source the way we
actually work with that is servicemix if
you type in ESB that's what service
makes is defined as it's your it's your
ESP implementation what service makes
really is is carafe and what you're
going to find is that carafe is actually
the under driving engine of server
mix so a general guideline now is going
to be used carafe unless you have a
reason to use service mix and the reason
being is carafe is what provides you the
main implementation of the osgi layer
carafe provides you the console that's
what allows you to start and stop
bundles allows you to manage your
deployment environment logging you can
change your logging levels you can do
different administration functions like
setting up the configuration files you
can also do feature additions and adding
URLs basically everything can be done
through carafe what is servicemix
provide you more stuff on top and a lot
of times you're not going to use any of
this well it's not that you won't use it
it's just that most of its you want to
only provide what you actually need you
don't want a whole layer of a bunch of
garbage you're not going to use is
anybody here use jbi exactly that's my
point oh I'm sorry he raised his hand at
the end JB is slightly outdated not a
whole lot of people using it anymore but
that's one of the things that servicemix
still provides so if you're on JB I yes
yep yep from the standpoint of service
mix you do get a web service and a
restful service service makes specific
implementation but a lot of times are
not used anymore you're working with
camel now most the time everything's
going to be done through camel that's
your main implementation and aggregation
layer exactly carafe with camel does
everything you would need service mix to
do and it's a much lighter weight
container because you're not getting all
of this that's up you know up above
there the JMS the spring the JB I you
only implement what you need with carafe
so from the standpoint of starting up a
carafe instance what you're going to
want to do is you're going to want to
make sure that it's a clean in startup
so if you're in the process of utilizing
something like servicemix servicemix has
all of these boot features already in
there so when you fire it up you've got
this long instance or long list of
different features that it's going to
install for you this has been cleaned up
slightly in the latest release but i
just want to point this out that it was
installing a lot of garbage stuff you
didn't need some people are going to use
you also have the ability which is
powerful to specify your own
repositories what that allows you to do
then is specify your local maven
repository whatever and tell it hey I
want to load these features in you can
put those features into the features
boot area and every time carafe fires up
it will automatically load those for you
so it gives you power over the
implementation or the startup features
of your carafe implementation or service
mix so once you get to the point where
you're thinking about deploying all of
this the reason why I set up the
original architecture the way I did is
now it gives you the ability to scale at
different levels which is very powerful
you don't want to have to scale your
proxy layer just because your business
logic layer can't keep up so now you can
scale your business logic layer at a
different level than your your proxy
layer because more than likely your
proxy layers then it can go
very fast it can handle a lot of
connections that's not going to be a
problem your business logic layer is
almost always the problem and you have
to provide for that you also don't want
to have to scale out your messaging
layer just because you've embedded it
within servicemix which by the way you
have the ability to do that you can
embed activemq not only in service
medics but inside your code whatever you
can embed those pieces i'm going to
highly suggest against that because if
you embed it and your and your code
breaks it it brings down the activemq
instance also now you've lost the
ability to throttle or keep things
running until you get your service back
up and running so in most cases you want
to try and pull JMS out of your coat or
out of any embedded structure keep it as
its own entity that way one you can
scale it differently but also you can
handle failover better hardware
configuration well this has a lot of
lines on it there you go now I'm just
kidding so this just kind of gives you
an idea of how data is flowing through
the system so if you set up activemq
with network of brokers
high-availability two differents and
connections for for your progress
essence layers and then you've got your
logic layers on the back end it looks
it's a lot of arrows for a very simple
design really the important thing here
is that if at any time your activemq
instance one of your academic winces go
down one of your proxy layer is going on
one of your logic layers go down and I
mean one of your instances of the logic
layer not the whole thing your system
will still continue running it may get a
little slower but it will continue
running until you can restart that
service bring another machine online
whatever it is this gives you high
availability across your entire data
integration system
you also have the ability to cluster
this is utilizing seller what this gives
you the ability to do is you can now
deploy to a specific cluster and
automatically will deploy it to both
instances of service mix inside that
cluster it's a very powerful okies it
admins love that the less they have to
do to go to each box or run scripts or
write scripts to do this for you the
more happy they're going to be so in
this case we're just showing how we can
take both of the the proxy layer and the
logic layer and put them in their own
cluster so if you're deploying bundles
to either one or features to either one
you could you in this case you'd only
have to run one script against one
cluster yes no it's only a well it's yes
it's available for crap also it is crap
when I say servicemix I keep talking
about servicemix carafe is the
underlying pinning of service mix so in
basically they're synonymous in that
case so let's take a look at what how
you'd install it all you're doing is
adding a URL telling it to install
seller within the the carafe instance
this is actually what you see well the
next one you'll see it this is a how
simple it is to install on carafe now
once you've got it installed you'll
notice that here the the prompt is a
carafe prompt craft root that's actually
inside service mix so even the admin
console says I'm carafe in service mix
but here what we're doing is we're
setting up a cluster first one there it
just says group list I'm listing out the
different groups I've got in my cluster
then I'm going to create a group and in
this case I'm telling it it's a proxy
which is that second line there so I've
created a group called proxy I'm listing
the groups again you'll see now I've got
a group called proxy in there and then I
can add or join my nodes to this group
so it allows you to start building out
your your infrastructure
so this I just want to point that out
because it's a very powerful tool for
for people trying to set up these these
larger enterprise systems and make it
easier for you to manage so looking one
more time at the implementation this is
the this is the the code that I'm about
to demo for you which I hope works we're
going to set up two different bundles
within a craft service mix which is this
guy here and this guy here and then
we've got two instances of activemq
running we'll set up both of those so
that they hit the same persistence layer
and then you'll see it failover continue
running we'll just hit it with soap you
I so there any questions before I bring
up the demo yes there's a lots of tools
for Dana Center guys oh you have a
patchy well yeah I mean basically
there's no like pre-built tools other
than jmx so visual via or I'm sorry the
J visualvm and J console are basically
going to be your best friends logging
you can use anything against the jmx
api's camel provides you basically the
way of pulling information from jmx then
you can use basically any monitoring you
want and they can usually tie into that
using camel so camel is a very powerful
tool from that standpoint not only that
but activemq provides advisories things
like that where you can get information
from activemq when things start to fail
so if you start running out of memory or
something like that activemq will start
throwing advisories before it gets to
the point that it's going to fail and
that's all part of configuring activemq
and camel together to make sure that you
get as much coverage as possible for
problems with your enterprise
environment so there's a lot more to
this but we'll take a look at the demo
real quick so you guys can see all of
this working
are there any more questions on this
before i start into the demo outstanding
all right where's my mouse here we go
okay
so basically I'm using maven to I've got
it I'm connected so what I did at this
point is I just built my two projects
the logic layer and the proxy layer now
what we can do is let's start one
instance of activemq that's the slave go
so here's the master activemq this is
the first guy that I'm going to bring up
this guy starts up so this is my first
instant instance of activemq that's
going to be running now I'm going to go
ahead and bring up the second instance
you're going to see this guy stop and as
you can see well I don't know if you can
really see that but you could say that
lock could not be established that's
because these two instances are pointed
to the same file location so just so you
can see the difference between them now
once i stop this guy you'll see this guy
pick up boom failover nothing special
about this whatsoever other than the
file location that's it so that one
persistence adapter is aimed at the same
file location that's as simple as it is
is anybody in here ever worked with like
IBM mq we have managers and things like
that where you have to actually set up
and specifically configure everything
manually this is a much easier
implementation it really is as simple as
what you just saw yep so now my slave
has taken over I can switch back to my
master or my old master restart him and
he'll sit there now he's in slave mode
so now it's literally they've switched
roles you hadn't you now have a master
with a slave configuration again because
it doesn't matter which ones they actual
unless yours configuring it to have like
a more high performance box as your
master in your slave is just there as a
kind
back up with les cours whatever so if
that's the case then yeah now at this
point you once you get your master back
online you'd want to switch back so
that's the activemq portion of it oops
so now with servicemix i'll go ahead and
bring this up so this is the carafe
console within servicemix this is what
allows you to let me bring make that a
little bigger this is what allows you to
deploy your application so down here at
the bottom you'll see a POC blueprint
PLC scatter gather PLC blueprint is my
proxy layer that's the one that just
basically takes information and then
figures out from the header what the
operation was and then sending it to
activemq the other one is a scatter
gather I'm pulling from activemq
basically doing a multicast on it and
then reaggravated it all back together
so the way I just show that is going to
be soap you I let me go to the other
screen here
alright
so you can see this is configured to go
to the web service and there's one other
thing I should probably do which is
bring over the tail so you can see it
going through once it starts up bring
that to be here so here I'm just tailing
the service mix log file so you can see
the the information going through now if
there's you got you I guys out here this
is really not that impressive now it's
not like you know building a GWT app or
you know a lot of flex toughest but for
you back in guys this is the this is the
meet all right all right so you can see
the message hit in the end point down
here there's my message exchange going
through its aggregating basically what
I'm doing is I'm setting it up so that
it was just waiting on each one of the
beans the beans are just adding
information to it really not that cool
from a UI standpoint but it's really
need from a simplicity of code and
integration and routing standpoint one
of the other things I wanted to show you
here is just how simple this code
actually is you saw it from a
configuration standpoint on the slide
that's not going to be able to get big
anyway that's the amount of code it
takes looks really small to you but
there's not a whole lot to this from the
standpoint of once you've got to
configure it it's really really easy to
use the hard part is making sure you
design an architect this correctly
that's the point that really has to get
across all of this is really easy and
like I said at the beginning of this is
that when you first go into this it's
really simple to pull it all together
and it's really simple to get these
pieces to work together it's not until
you start pounding it with load that
things start going wrong and that's when
configuration and knowing what your
watch what you're up against really pay
off so from the standpoint of jumping
into this realm and that's why I was I
was looking for hands based on activemq
versus camel and and all that
is utilizing each individual component
in and of itself on its own isn't that
big of a deal it's when you start
integrating all of these pieces in an
enterprise system and the nice thing
about this is that you can do it for
free you know it costs you nothing from
an open-source standpoint it cost you
plenty sometimes if you have to go with
consultants but you know that's where
that's why I'm up here yes uh-huh right
exactly he basically was making a
commoner know if you all heard it but
I'm paraphrasing now he said it was
awesome I mean but he was able to do a
lot of a lot of architectural and
configuration work on a single VM and
then go ahead and distribute it in an
enterprise environment very easily does
that sound about right uh-huh yeah from
the standpoint of the embedded and
everything like that yes right
why camelus is a vm literally burn out
the entire application inside a single
VM and then take it out and then how all
these networks of brokers right right
right yeah exactly are there any other
questions yes
and do it installed
yes and well there is actually the
concept of web consoles in a lot of
these frameworks they're not quite
drag-and-drop type of consoles what it
does does give you a web console for a
lot of the at least monitoring and some
configuration of them so like carafe
comes with a web console oh I'm sorry
she was asking about she was saying that
a lot of the Ops guys need something
visual they don't want to just say well
you know the developers are all setting
this up and we don't really know what's
going on and we're okay with that you
know most the time Ops guys are like no
I need to know exactly what you're
setting up where you're sending it up at
how much is it going to cost what's
going on in and they want some nice
little gooey to do it yes you can use
products like puppet or whatever and
graphical tools in front of that to do
everything you could possibly need to
ssh in do deployments for you and there
are gooey front ends even to that so
kind of the world is n
if you need to get a pretty GUI for
administration you can certainly do it
you don't have to build it it's
assembling it you still have to assemble
a lot of these things and you guys have
to know how to write the scripts and pop
it and stuff like that so there is a
learning curve but it's not something
that's out of the box it's not like a
weblogic system where you can sit there
and say here's a nice little visual
thing and I'm going to sit here employee
you know drag things around and
configure it that way but you can make
it that easy with outside tools it's not
part of the Apache project allow you to
do that does that answer your question
or yeah okay yes
yeah I'm sorry I saw their hands yes yes
yep you can add as many different
context as you want using spring or you
know well xml-based scala based java
based think those are the three main
ones that are that are available from
camel at this point yes
uh-huh right mm-hmm error handling from
what standpoint though I mean are we
talking about your within the the
bundles or are you talking about when
something in carafe was okay well see
and that's the best the great thing
about it is that you can file a bug and
you can monitor the progress of it on
your own without having to go through
some corporation to support line or
something like that unless you're using
fuse or open logic or Tallinder well not
fuse anymore it's now Red Hat so you've
got other options from the standpoint of
support and things like that but that's
a great thing about open source is that
you can actually fix the bugs if you'd
like and then someone back to the to the
to the community yes within camel with
gamma yes yep not a problem the question
was asking you spring MVC with it don't
use spring integration though just
kidding risen another question yes first
time I got that question today the
presentation was done in Prezi Prezi
it's PR easy I yeah it's it's it's and
they've got a lot more I mean this is
actually you know I'm not that good with
it you can do a lot of stuff with it
this I'm just rudimentary and got out to
do what I needed to do but honestly
usually people ask that halfway through
my presentation what was this really I
got this whole architecture it's really
cool you want to know about my
presentation great shows I'm really you
know vagrant okay is there anything else
no alright thanks guys appreciate it
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>