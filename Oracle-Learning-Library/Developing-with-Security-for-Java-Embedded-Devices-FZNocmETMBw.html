<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Developing with Security for Java Embedded Devices | Coder Coacher - Coaching Coders</title><meta content="Developing with Security for Java Embedded Devices - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Developing with Security for Java Embedded Devices</b></h2><h5 class="post__date">2013-01-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/FZNocmETMBw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this session is titled developing with
security for Java embedded devices and
I'm Hickman Wong I'm one of the
engineers from the Java embedded group
at Oracle and we're gonna be talking
about how security applies to Java
embedded devices first there's our
typical safe harbor statement all the
slides that I'm going to present are for
informational purposes only and here's
an agenda I'm going to go over first an
introduction to Java SC embedded by a
show of hands how many people have heard
of or used Java SE embedded okay then
I'll go into a little bit more details
that doesn't seem like too many people
have been exposed to it how about Java
ME how many people have used developed
or heard of Java ME Technology Java
micro Edition okay
so I'll spend a little time on the
introduction seems like there's only a
few people that have background in Java
and me and Java SC embedded then I'll go
over the differences in the programming
styles that we have between Java SE
embedded which is a very very different
environment than you're used to on Java
desktop and Java server so we'll talk
about those differences and what you can
do as best practices then I'll go over
the security layers and different
components security components of Java
SE embedded and what's the difference
between that and what you find and hear
in the news about Java desktop and then
we'll dive deeper into the two parts
that are mainly what Java embedded
developers are concerned most about
that's encryption making sure your data
is stored locally in an encrypted format
that no prying eyes can get to and also
is transmitted using a secure connection
SSL or HTTPS to make sure that data
especially for enterprise data is not
being snooped upon or spied upon
then there's also other security
features that that I'll be covering an
overview that explain different areas
that we make sure are secure in Java SE
embedded there's future enhancements
being
new features in Java SC embedded 8 and
we'll talk about that then I have a demo
I have a small job embedded device that
I'll show later on and I'll give I'll
review the points that we covered during
the slides and then I'll open it up for
questions and answers this is a this is
a smaller group right now so if there's
any questions along the way just
interrupt me
Shoaib raise your hand and I'll answer
those since it's an informal setting
with with this small crowd right now
I should call it intimate crowd it's an
intimate crowd that we have today here's
the regular spectrum that of Java and on
the left hand side a lot of Oracle
OpenWorld developers are more used to
the server world where Java EE runs
that's not the focus here instead if you
go down a little bit there's then the
desktop stack which is Java SC you see
that in a red block in the middle bottom
on the left that spans from servers also
not just Java EE but you can run Java SC
on these big iron servers on your
desktop of course but then it goes into
the higher end of what's known as
embedded and those embedded devices it
could be consumer devices like the toy
that you see there's a robot but more
likely it's enterprise grade devices
that you see like network routers or
multifunction printers or in healthcare
there's the healthcare monitors medical
monitors in a net on a network in the
hospital or it could be industrial
automation where on a factory floor you
have all these computing devices that
are talking to each other and that's
what we're talking about is Java
embedded and I mentioned before Java ME
Java ME continues the spectrum even
lower than that the the thing about Java
seu is we keep one full API set but if
you wanted to subset down the API and
the spec then we have Java ME which
tries to have a trade-off between the
footprint that's required and the spec
that it adheres to so there's a smaller
set of features that are found in Java
ME and that's more for the consumer
market like blu-ray players and cell
phones especially feature phones on a
mobile side and there's extra api's for
changing a channel or fast forwarding or
rewinding a video for instance in
blu-ray so you you see those extra red
blocks that are on top of Java ME and
then MSA is the mobile services
architecture and that's for doing things
like dialing your phone or sending an
SMS text message those are extra Java
API is that do that we're not talking
about that because in Java SE embedded
as you can see we keep that full set of
api's or the full spec compliance that
you see in in the lower middle red block
under a Java SC and then that's the part
right in the middle there the embedded
that we'll be talking about in this
discussion and as the bullet items for
Java SC embedded we see that I'm
pointing out here the differences that
we have between Java SE embedded and
Java SE desktop you still get that well
this is something that's the same you
still get that proven and stable
platform that you get with Java SC so
it's the same implementation except
there's I'll talk about the differences
in in what we do to optimize for the
embedded world and embedded environments
but the api's are the same there's a
huge developer base so if you go online
and you you're scratching your head over
a problem in your application you can
find form groups and discussion groups
of talking about Java SC programming
there's also rapid application
development there's all the IDE s
Eclipse and JDeveloper and NetBeans that
are out there that help you program in
Java SC and of course you get the great
greatness of Java and that's why you're
here at the the conferences you get the
fully object-oriented programming
environment you get a virtual machine
that takes your byte codes and runs it
so if you have a jar file that's going
to run the same on any Java SC virtual
machine you don't have to recompile and
then there's memory management of course
with Java as you know being here at the
Java conference there's a no need to do
to figure out what you're doing with C
pointers
and your memory of making sure to free
the memory after you use it and that
that's big an embedded world because
many embedded developers are used to
programming in C and C++ so they're
already ingrained with trying to
remember to do all their memory
management coming over to Java is just a
breath of fresh air and then there's
portability we make sure to have our
virtual machines run on the typical
embedded CPUs and OS is not the desktop
OS on desktop you see Windows is
primarily the the OS and the x86 base
Intel chips are the environment that you
see there and then you see Mac OS we
have Java SSE the runtime for Mac OS and
Linux also but that's really the three
ports that you your concerned with in
Java SC in Java SE embedded we are
concerned with many many more devices
many more operating systems many more
CPUs its dominated right now by arm so
we we primarily focus on Linux arm not
windows because Linux and arm are are by
far the the two features of an embedded
device that far outnumber everything
else right now and there's
cross-platform issues that we make sure
to take care of in our Java SE embedded
libraries so that you don't have to
worry about that you just have to worry
about writing a Java program and that
that program will run on a multifunction
printer with Linux arm and also on a
healthcare device with Linux arm it just
will we we give the promise of the write
once run anywhere on embedded devices
which is much much harder to do when
you're talking about all the different
CPUs and operating systems even within
Linux there's different distros that are
slightly different flavors and different
settings from kernel to kernel so we do
all the heavy lifting for you and then
you just worry about Java code and the
Java program that you're programming to
and then there's also on the hardware
side these CPUs from arm as your as you
see in the news are now multi-core and
that makes it
very interesting because our Java layer
in our virtual machine in order to run
in a highly optimized fashion and as
fast as possible on these new embedded
devices need to be multi-core aware need
to be multi-threaded need to handle
those at multi processing device so that
type of support is built into Java SE
embedded also as a platform and then you
get the security which we'll talk about
in depth in this presentation and then
networking also so all the ideas that
you get from Java EE or Java SE that you
know about in Java apply directly to
Java SE embedded as a sidenote in Java
ME there there's all this a lot of pain
in terms of trying to remember which
subset is being used in which part of
Java ME or which api's are missing so
you have to use some other set of api's
or write your own that was a pain for a
lot of people in Java ME but in Java SE
embedded what we do is keep that full
specification from Java SE so you don't
have to make the mental switch going
back and forth of what sub subset you're
using also there's a different IO system
called generic connection framework in
Java ME so there was this whole mind
shift of how you were programming how
you're using your api's when going down
to Java ME so we heard our developers
and that pain of trying to remember to
switch gears when they go from Java SE
to Java me and now this is why we came
out with Java SE embedded which is
applying your knowledge of Java to these
smaller devices and this just goes over
what I've talked about before the full
spec is covered in Java SE embedded but
we make sure to go in and tweak the
libraries to end the virtual machine to
make sure that there's memory
optimizations it's not using up all 256
Meg of your embedded device of the RAM
that's an available on your embedded
device and that's because we very much
focus on the availability of your RAM as
opposed to desktop and even laptops
where there
there might be four gigabytes of vram
available and you don't think twice as a
Java programmer when you're in that
environment but when you have 256 or
even 128 Meg's of RAM on your embedded
device that's a big concern and we
address it right away in the libraries
so your platform itself is not churning
and using up all your memory before even
your application is running and so
that's a big deal with our runtime
implementation is making sure that even
the platform is performing correctly for
the the limited and restricted amount of
memory you have an embedded device and
then there's also smaller persistent ROM
and disks requirements so that you can
have a smaller footprint or when you
install your application and you install
the Java Runtime on your embedded device
it's not taking up all the flash memory
or all the ROM that you have available
and then of course that means your Ram
is going to have less impact also just
because when you load in our Java VM and
libraries that footprint that's taken up
by the storage space for our VM is not
going to be used when it all loads into
memory so we we care about the static
footprint because it impacts the dynamic
footprint later on when you're running
and then there's things to speed up
parts of our Java library that we've
done and many years over the past I come
from the Java ME CDC group where we
learned
hey there's Java libraries that do
things inefficiently let's go ahead and
go into each part of the library and
make sure it's running efficiently for
small devices and we've carried over
those type of optimizations into Java SE
embedded also where is it used so these
types of devices are embedded devices
there are fixed assets or things that
don't normally move around with you a
cell phone for instance will someone
will put it in their pocket and then
take it from place to place but a
multifunction printer or network router
it's just going to stay in one physical
location usually maybe in in healthcare
it moves
a little bit from patient room to
patient room but usually there's less of
that intermittent connections that you
have to the network and power issues
that you normally see in mobile devices
so in embedded devices that we're
talking about for for small embedded
devices that's one of the areas is
industrial automation you also have on a
factory floor fixed assets where these
embedded processors are running in
certain stations along the assembly line
one thing that's very common nowadays is
to still network these embedded devices
but using a wireless network for
instance Amazon has their Amazon Kindle
they piggyback on the Sprint 3G network
and then they call it whisperer net even
though it's still using the underlying
protocol and our underlying carrier from
Sprint just because Sprint has this
extra bandwidth and they said hey if
anyone wants to contract out and and hop
on to our bandwidth then you can set up
machines machine-to-machine
communication where these Amazon Kindles
are talking to the Amazon data center
getting the latest update of the OS and
being able to pull it over the Sprint
network so nowadays you could contract
out with these carriers and say hey I
want to use a little bit of your extra
bandwidth so can I have a private
network where my wireless network can be
set up across the country across the
world and so that's a big deal because
these small devices are now plugged into
the regular Internet and not just a
local area network and then there's
another distinguishing feature of
embedded devices and in this talk is
that they have small screens or they're
completely headless so you have these
small LCD panels that you find in
multifunction printers that's not going
to let you see the entire document that
you have it's going to let you push
buttons that show up on your screen or
touch for a status a small error message
window so that's very limited in terms
of UI that you have on in these
betta devices also for input you you're
limited to either a keypad and usually
that's a numeric keypad or just a
limited set of alpha alphabet letters
and numbers on a screen or you have a
touchscreen which is again that smaller
LCD panel that you're going to touch and
especially on buttons and and menus and
not really a full keyboard so that's
something to keep in mind when you're
programming to job-embedded now let's go
into the topic of today's talk which is
security
and security is an overloaded term it
could mean many things in terms of Java
mainly for this scope of the security
that we're talking about in this
presentation it's addressing the
security in these embedded devices that
we want to focus on for this talk in
other talks they talk about Java EE
security or Java SC security mainly
we're concerned about the memory use
that's happening on these embedded
devices and also you have these lower
power CPUs so you might have a CPU
that's running 270 megahertz not these
3.3 gigahertz quad-core eight-way multi
processors that you find on desktops
nowadays this is much more limited in
terms of what you can do in processing
and then less memory means that you have
less area to do your security algorithm
so if you're doing encryption a lot of
times if you do the brute force way of
just using AES on Java SC you're saying
hey I'm just going to use the latest
encryption technology latest encryption
algorithms and just be able to be safe
and and in knowing that it's going to be
fully encrypted but then there's a
second dimension here when you're when
you're talking about job-embedded is how
much memory is it going to use so you're
not just blindly using api's from
security anymore you're concerned about
the processing area or the amount of
limited memory you're going to take up
with that with that security algorithm
and then limited CPUs means there's less
processing
also for those algorithms that means it
takes more time so you're going to try
to encrypt a string that you normally
just do on Java SE and don't think about
twice it just returns right away after
you encrypt it it's going to be a
significant impact if you're going to go
on an arm CPU instead of one of these
quad-core 3.3 gigahertz Intel processors
on a desktop so you have to keep that in
mind is how fast is your embedded
application going to run and by taking
all that in your mind and keeping that
as in the back of your mind as something
to watch out for for memory and for
limited CPU power then you're going to
take a look at what Java SC security has
to offer and there's three components
that provide a comprehensive solution
for it secure embedded programming that
you want especially if you're using
networks like the Internet where you're
hopping on to Sprint's 3G network or
some other wider area network the first
component is runtime security so you
want to make sure the behavior is being
enforced by Java Runtime that you get
the Java platform is going to watch and
monitor can you do this action can you
open up a file on your local hard drive
can you go ahead and make a network
connection to some back-end server
across the internet that is being
monitored and managed by the security
layer in Java and then we want to make
sure that the application can run safely
in the restricted environment so in this
limited memory and this limited CPU can
we still ensure that nobody snooping
nobody's spying on the memory and
nobody's getting to the data that you're
embedded application is running so
that's very important when we're talking
about healthcare when we're talking
about industrial automation Enterprise
is making sure that all the data during
the runtime is secure then there's
security libraries we want to make sure
that everybody gets the typical API is
that they're used to using for
Photography and and for things like
encryption and key storage and
certificate signing and that's their
standard API is in our Java SE embedded
for things like the crypto package that
you find in in any computer language
there's also the public key and
infrastructure which is PKI
which allows you to have a pluggable set
of security encryption algorithms then
there's attenti keishon how does the
user who's on that embedded device
authenticate themselves and prove their
identity there's also policy and secure
communication in our libraries to make
sure that you as a Java programmer can
easily say hey make sure to protect my
my files on my hard drive so I'm going
to set this API to say don't allow the
user to touch any of these special files
or don't allow the user to override any
settings that I have and there's also
secure communication we're going back to
your data center especially for
enterprise data you want to encrypt it
so that there's nobody snooping on the
internet and nobody being able to pry
into your data as it as it's going
across the network across the internet
and then it's very important in our
libraries to make it pluggable so it's
very flexible where you can have a new
algorithm that comes along a better
encryption model that you hear about you
can buy that be able to plug it into our
framework our Java cryptography
extension framework or jce and this
allows you to extend it into the future
and then we have tools that make it more
convenient for you as a developer to do
things like certificate signing to do
things like taking your jar or files and
making sure those are protected there's
the key tool for certificate signing
charge signer and the policy tool that
we provide in the JDK so here's a
diagram of what's happening in runtime
security so when we're diving deeper
into this on an embedded device
especially you would have your
applications with Class A and Class
for instance on the very top those are
the blue boxes how can you ensure that
on that embed device which it might not
have a human monitoring all the time
like a server might have in a data
center how can you ensure that when it's
accessing things data and and files on
your device is it going to be protected
well what we have is the orange box that
you see on this diagram that's the Java
platform Java SE embedded has all these
class libraries that are following a
strict security policy management
paradigm and what we do as you can see
the Class A and Class B are your
application files or it might be a third
parties application they they talk to
our Java platform our orange blocks here
such as file input stream file input
stream and Java allows you to open up a
local file that intern doesn't go right
to the file and let you have it it goes
first through a security manager in the
middle there in the orange block and
that security manager is going to in
turn use an Access Controller and a
policy to make sure that it's going to
read off in this green block to the
right here the authorization data or
what you as the application programmer
or the device manufacturer what you're
saying
this is allowable for this application
this class from some third party is
going to be able to open up the
Preferences file for a user for instance
and nothing else but I give I grant that
developer using this class the
permission to go ahead and open up that
file and so going through all these
steps are a requirement for the Java
platform you go through a security
manager it checks to make sure that the
policy file says you're allowed to do
this as a certain application and then
open up that file and so this is runtime
security and and again let me know if
there's any questions along the way
next we have our security and security
manager and policy that we can talk
about more in depth it's something that
you as the device manufacturer device
developer can set so there might be
times where you want to open up things
like user preferences on a device
there's times when you want to keep it
completely closed like a network router
or a smart grid device like a
concentrator or a smart meter there's no
reason why you would put third-party
applications there it would be your own
in-house application developers that
create a smart grid or smart meter
application so you might want to shut it
all down and have no permissions at all
for any other classes than the system
classes then there's a so that's allows
you the flexibility of defining your
environment for embedded device there is
also Java cryptography extension and
that component again that's a framework
to allow you to do different encryption
algorithms so when you're scrambling up
your data jce is the part of Java SE
embedded security that allows you to
make sure that your data is is protected
against prying eyes then there's a PKI
which I discussed before the public key
infrastructure is a big component within
Java SC security and that enables you to
have encryption exchange between
unsecure on an unsecure public network
such as the internet and and be able to
use an asymmetric way of doing
cryptography which means there's a
digital certificate that's floating
around out in the public there on an
Internet and there's no secret key so
there's no way for someone to try to
open up your embedded device find that
secret key and be able to pry and be
able to look at and spy on all your
encrypted data on other devices instead
there's a digital certificate using PKI
way of doing encryption that allows you
to have that digital certificate be
authorized by
a authority or certificate authority or
a CA in your route set of certificates
and that's a much much cleaner way and a
safer way of doing encryption so that no
one's going to break your code and so
that's one big component within security
as PKI as an entire infrastructure to
allow you to do public key or asymmetric
way of doing encryption and then next is
Jas which is the Java authentication and
authorization service this allows you to
give a password and a username and say
hey I'm this person and then go off to a
back-end server and validate that you
are indeed the right person to use that
device then there's Java secure socket
extension which is jss EE and that again
is using the standard for HTTP which
when you go to a website and like Amazon
and you want to give your credit card
information and other personal
information you want to make sure that
it's scrambled along the way so HTTP is
the web services and web protocol way of
keeping a secure connection and also
there's SSL if you're doing instead of
telling it if you SSH your connection
into your device you want to be able to
type commands and look at results using
SSH rather than having and that's a
secure socket layer or SSL that's
protecting it having it inside that pipe
that's protected against prying eyes
rather than FTP or telnet which is open
for anyone snooping on internet and
knowing your IP address being able to
see what you're typing on that device so
jss C is very important for doing the
HTTP HTTPS and SSL way of protecting
your connections and there's also some
optional pieces that are not not as
popular and not as frequently used
there's Java GSS API that's that's a
generic secure services API that you can
use for authentication
there's Kerberos again
that's for logging in to a device some
people use a standard called Kerberos
where they can connect up their
corporate passwords and usernames so
that it's available to all the devices -
there's Java
Sasol which is a simple authentication
service layer and that's and that again
allows you to do
muggins XML signature so instead of
digitally signing a jar file which
represents your application and letting
that run on your device you can
digitally sign XML which is all
scrambled up and be able to to have the
client or the service that gets that XML
that's been signed and be able to
decrypt it by just the information
that's inside the XML so that's
important too if you're going to heavily
rely on XML going back and forth between
your device and your back-end data
center and then there's tools that again
that come along with development on the
development side for doing security on
Java SE and bedded devices then there's
must be twelve O'Clock there's there's a
there's the test of the sirens that they
do at twelve o'clock you're in San
Francisco I think it's for tsunami
warning so they actually do that before
they set that up but well anyway that's
just a side note there here's a diagram
of Java SE embedded security manager and
policy diving a little deeper in in this
diagram you have your local or remote
code up on top wants to go ahead and run
on your embedded device and that's the
security policy that determines you u.s.
developer you'll write out and say hey I
want this local code to be able to have
full access to all my files or I want
this remote code the opposite to be
limited to just the sandbox so in that
security policy it's going to be the
input into the Java platform judging
whether the local code or mo code
depending on where it's from gets to
play in the full access area or goes
over to the sandbox and gets protected
and once that code goes into one of the
two blue boxes that are on top there
it has different levels of security
because it in turn will go down into the
security manager and say hey I am part
of the code that has full access you can
also have more fine-grained control of
that and you see those little bubbles
there the blue bubble red bubble and
green bubble those are domains which
means there's even smaller sets of code
such as writing to a file instead of
reading to a file that are defined by
domain according to a class the the file
writer class for instance that domain is
going to have a specific policy that you
can find green define in your policy
file and say I want all local code local
applications to be able to write to
files that's the blue box but over in
the purple box on the right hand side
I'll say anything that's remotely
downloaded from the internet
I don't want it to write at all I'll
just let it read the file instead and so
you have this really fine-grained set of
dials and buttons to control in terms of
what the security protection is of your
device and then you have the security
managers watching all this and that's
the layer that protects your
applications from your resources or
allow certain actions to happen on your
resources and that's on at the very
bottom on an embedded device it's not
like your typical desktop system it's
got maybe a SD card it's got some flash
memory it's got some connections to the
Internet and that's really what you want
to protect because you don't want
somebody to come in and take over your
device and start spamming or sending
spam emails or sending using your device
to to spy on you so that's the bottom
very bottom box is your private data
that is kept secure any questions about
this
now we have oh there's also domains as I
was talking about in the in the last
diagram is an instance of the security
policy so you have up top the to box the
two bullets our Security Manager which I
talked about that's what's in control
the security policy that's how you
define the limits of the security
manager as a developer and then domains
as a little bit more detail it's the
instances of your policy so what you've
put in as lines of permission and it
also is the place where you define
specific access for different areas of
code so for your for instance there's
the file API is in your library that's
being protected by a domain and it can
be controlled depending on where the
application comes from is if it's a
digitally signed application is going to
have full access to do everything in
that domain but if the domain is
protecting against remote code then
it'll look to see up the stack where
application came from and it might be
from a URL that's outside the device and
that would be restricted from using the
file system so that's domains using the
the security manager defined with a
security policy now here's here's a data
flow diagram of everything all the
components that we just talked about
happening on a Java platform so you know
we don't have to go over everything but
it's just showing that in a java SE
embedded device there's a lot going on
in libraries on the platform to make
sure your data is protected there's the
the purple box up top is for
authentication is for logging in there's
things that will protect your code like
jce and being able to encrypt it and
then there's sub boxes that you get that
will do things in a specific standard
like Kerberos or there's pkcs 11 which
is the pluggable way of
different algorithms what's interesting
to note for embedded devices I'll point
out and this diagram is the bottom here
where it says pkcs 11 that is a set of
interfaces or a set of standards that
allow you to plug in how your
cryptography happens so again well on
these limited devices where you might
have a 270 megahertz ARM chip that's not
powerful enough to let you run in Java
an encryption algorithm like doing the
full scrambling of entire data set so
what you want is something faster and to
do that faster you can use the standard
called pkcs 11 and plug in something
specific to your embedded device so
maybe you've got a special ARM chip that
can do crypto acceleration on that chip
on the board on the target board that
pkcs 11 the structure lets you do that
lets you do for instance the AES
encryption if you say hey I'm gonna do
Java AES encryption it's going to
natively figure out hey there's a chip
here then I can accelerate on this
embedded device so chip manufacturers
and and target board manufacturers this
is great because you can have developers
write in Java still and under the covers
it can be really fast on your device
compared to all these other devices that
are just interpreting Java to do the
encryption and you can make that a
selling point you can say hey there's
value in my embedded board because you
can do encryption a lot faster and
encryption because you're at this talk
you know that it's it's very important
in terms of embedded devices nowadays on
that wide internet or you can have other
interfaces to pkcs 11 you can have smart
cards so you might have a smart card
reader where it would only decrypt the
data if you're the smart meter guy and
you plug in your smart card into the
device and and then you're able to
download the data but if you're just
somebody walking off the street up to
the smart meter and you want to read the
houses information you can't do it
because it's not going to be able to
decrypt other than using that smart card
technology so that's another way of
making sure ensuring that there's extra
level of encryption for your embedded
device and that's again it follows the
pkcs 11 plug-in architecture which makes
it very easy for Java developers to just
say hey encrypt us encrypt this data set
I don't know what you're doing under the
covers but I'm assuming that it's gonna
be fast and it's gonna be something
reliable and that's what we set up is to
make sure that it's flexible in a Java
platform to do that now let's dive
deeper into jce which I mentioned before
the Java cryptography extensions and
that is in itself a pluggable cryptic
cryptographic API and that's supporting
a wide variety of services not just
doing the pkcs style of encryption it's
doing things like message digests where
you can hash up and and make sure that
your your compressed files are haven't
been tampered with they can do things
like digital signatures so that only
signed applications on your device will
be able to run nothing else and that's
important because you've seen security
threat information on on regular Java SC
for desktop is open to all kinds of
applications so there's all kinds of
rogue applications out there that are
able to get on to our Java platform on
desktop because it's it's a plug-in and
a browser if you accidentally go to a
URL and there's a a pleasant been signed
it's still going to run and it's gonna
do something bad and that's where mainly
you see security holes nowadays is you
see it on desktop or laptops or the Mac
using that entryway of a rogue
application there's no signing no
checking of signatures and then it just
kind of it runs and finds one of the the
holes that it can get to to your data
here on an embedded device if you
digitally sign all your applications and
you know if a third
party or developer is going to want to
run their application on your device you
can say you are required to digitally
sign your application and only run
signed applications on your device
you've shut out all the security holes
that have been in the news recently just
because the any rogue application won't
be able to sign themselves to run on
your device
there's also bulk encryption so again if
you're doing data if you're shipping off
data back to your Oracle database on the
backend you want to be able to use jce
to do that and B if you're a Java
programmer you can do that very easily
there's a stream encryption so if you
open up a video stream or just a
continuous data stream that is also
secured and protected against people
spying on it what we talked about before
the public key infrastructure that's an
asymmetric encryption and then there's
also password-based encryption where
it's not using a certificate you're just
typing in a password to scramble up some
some data and there's keys that are
being generated and being stored so that
is during the exchange is being handled
by jce there's a message authentication
codes and there's also random number
generation and that's all under jce
which is a common set of api's from
device to device where your java
programmers can easily pick up and be
able to program to so that's why with
the benefits of Java is that you you
just have to remember jce to be able to
program to your embedded device
there's also cryptographic services
implemented to the standard so that if
you go to RSA or if you go to some
vendor like even the open source
provider like bouncy castle they're
going to create a standard that plugs
into jce so they're going to say hey use
my open source encryption because at
bouncy castle I've written to jce and so
you would download the jar file and it
would have all the interfaces
implemented to jce and that means that
you have implementation independent
you can use our providers for our
security encryption algorithms from sun
but from oracle formerly from sun and
then you can also use bouncy castle an
open-source version you can go to RSA
you can go to Verisign you can use
anybody's implementation because it's
appearing to jce and then there's
intrument a ssin interoperability which
means that you can mix and match you can
mix bouncy castle and Oracle's
encryption together in jce and algorithm
extensibility so if there's a brand new
elliptical algorithm that comes out and
your device was baked before that
happened you can still use jce to allow
that algorithm to get flashed and
updated to your devices and be able to
use that new style of encryption and
here's jce in action here's your
application again is on the top it's
going to figure out hey I want to use
md5 for message digests encryption and
then it goes through the provider
framework which is the key part of jce
to make it pluggable and then it goes
and figures out which one of the md5
implementations you want and that's
that's provider dependent so on a very
bottom you see three different providers
in those green boxes there there's
provider a provider B and provider C
that they they all have different types
of algorithms they might have shot one
and sha-256 provider B might have an md5
there and the sha-512
and there's a provider C also has an md5
encryption algorithm and then maybe shot
256 you can decide hey I want to use
provider bees way of doing md5 and then
it goes through and tries to check where
md5 is available and then you say hey I
wanted to use provider B then it the
provider framework does all the heavy
lifting and figures that all out for you
and then returns back to your app
application hey I gave you encryption
algorithms to use it's an implementation
that's using the
the ARM chips version of encryption so
go ahead and do that on your embedded
device so that's what jce does as a
provider framework that's pluggable then
we have the options for jce we have a
provider that we provide from Oracle and
that I guess that's why I'm saying
something because we call it Sun pkcs 11
jce provider and that's supported on
Solaris Linux and Windows so that those
are from Oracle what our implementations
are natively fast secure encryption
algorithms that you can use by default
with your JDK then there's Sun MSC which
is the Microsoft cryptography API jce
provider and that's only supported on
Windows so there's an optimized way of
doing it that's found in in the Windows
operating system that we allow you to
use then there's an Oracle you crypto
jce provider and that's natively written
on Solaris Park in Solaris x86 and that
allows you to do cryptography in an
optimized fashion on Solaris servers so
those are different providers just like
in the previous slide you can you can
request hey I want to use encryption
algorithm from this specific provider
depending on where you are what kind of
platform you're on and so now here's the
Sun pkcs 11 that we provide as an
implementation of encryption algorithms
this allows Java applications to access
the pkcs 11 implementations that we
talked about that it might be your
hardware layer doing this encryption
acceleration and using the encryption on
a chip to do your your calculations and
your algorithms it's using a
cryptographic token interface standard
that's across the board you can you can
find the standard in the C programming
language and in in Python and other
programming languages and we're
providing this the Java interfaces to do
the same thing and this is provided by
RSA security so
that anything that's done natively in
terms of doing fast encryption is an
interface using the standard using
tokens under the standard so that you
can have your hardware cryptography take
place for instance or you can have smart
cards do the encryption for you encrypt
and decrypt the the Sun pkcs 11 provider
is supported again for a Solaris spark
and x86 on Linux x86 and on 32-bit and
64-bit Java processes so it's also on
32-bit windows x86 there's going to be a
early access for 64-bit windows support
later on in JDK 8 and then for the
Microsoft part if you wanted to have
windows support on a Windows machine and
this might be interesting as Windows 8
gets ported to arm devices like tablets
so for an embedded world you might want
to take advantage of the Sun MSC API
provider where you can use Microsoft's
crypto instead and then there's all
kinds of other hardware vendors that can
provide crypto services that we talked
about and you could plug these as
hardware modules onto your device and
here's the Solaris one so if you're
you're working with embedded software on
a big Solaris server you can use the
Oracle u crypto provider and that'll
that's optimized for the SPARC t4 if
you're familiar with our SPARC
architecture that that's a hardware
assisted crypto cryptography
acceleration so that allows you to do
the encryption in a very very fast way
on servers and this is only available in
Solaris so you get this you get the
picture of all this optional ways of
doing security because it's a plug-in
framework that you get in jce and so in
the future for java SE embedded 8 we
have pkcs 11 for 64-bit windows not just
32-bit there's going to be crypto
operations with over the network so you
can use hardware that's of
on your network instead of on your
device itself there's going to be more
encryption algorithms more cipher suites
more message digests stronger better
faster all kinds of things good stuff
coming in in Java SC embedded 8 and now
here's the fun part there's a demo so
I'm going to switch over to my laptop
okay that's it that's all thank you very
much I'm gonna switch our windows over
here to show first NetBeans how many
people in the room have used NetBeans as
a IDE okay so I don't know how many
people have used JDeveloper no okay so
NetBeans is I like NetBeans I've
switched over completely as my editor I
use to use Emacs and X Emacs as my
editor which kind of dates me cousin you
know that goes back to to the 80s that
that was a big editor then but now in
NetBeans I find it so much easier to use
all the the context type of health's
that they have like if if you're typing
along and you decide that you need some
help with what the different methods are
you can go ahead and use there oops
there type-ahead feature and being able
to pop up a menu of different selections
that you have now it's not gonna work oh
that's dot yeah there you go thank you
and and you know just having this at the
touch of your fingers and having the
Java doc be available that's really cool
I never had this and when using it X
Emacs and then type ahead feature saves
me a lot of typing which is hard
sometimes when you're typing out long or
method names but what I'm gonna show you
here is a crypto sample demo and it's
using the typical Java SE crypto
packages that you find so any IDE that
can program in Java SE you can program
for a Java SE embedded and that's that's
the great part of Java SE embed it is
there's no special spec for Java me that
you have to look for and then here we're
just gonna take a string or take the
string hello this is a test and we're
going to encrypt it and decrypt it and
then we're going to use this current
time Millie's to time it before and
after and so I here's a couple key
parts of the code it's very easy to do
encryption you you get your key
generator and say I want to use one of
the security algorithms that are in my
provider in Sun pkcs that I talked about
before there's a EES and I want to knit
it to 128-bit encryption and that's it
you're gonna be able to generate your
key and then you're gonna take that key
and use it to do your encryption and
decryption so here's the key this this
step right here is important for
embedded developers because as I said as
an embedded developer versus a desktop
or server developer you are worried
about memory and about processing time
and this under the covers
is going to take up the bulk of the time
so you have to be aware of that that hey
this is a big deal to do generate key
it's gonna go off and churn a lot in an
ARM chip on the desktop you won't even
flinch you won't even notice that it's
doing that but in embedded again this is
the topic of the talk is you have to
worry about each line of your code what
what is it doing in terms of memory how
much time is it going to take to process
and that's that you you have to just be
aware from experience that that's going
to take a lot of time on the bedded
device and then you just go ahead and
say I'm gonna do encryption using AES
and then you'll take your source string
which is that hello world and be able to
do final do final I always thought that
with this name is should just say
encrypt or decrypt but that's what it's
really doing is taking the mode of your
your cipher and doing it performing it
on a set of bytes from your source
string which is the hello this is a test
and then I just print out what it looks
like after he gets encrypted and then I
do the opposite I'm gonna put it in to
decrypt mode over here and then I'm
going to say do final and decrypt it and
then show it afterward and then to wrap
it up I'll just show that how long it
takes on desktop and
my tastes on embedded any questions
about this demo about this program I
like I like the colors that it does
syntax highlighting as it does in the
IDE - it really pops it out when I you
know missed a semicolon or I mistyped
something it really does help a lot so
let's go ahead and go on to my Windows
machine alright this if you look at the
printout of the CPU info this is a
pretty hefty machine here it's got an i5
Intel 2.6 gigahertz and let's count one
two three four cores on it so it's
pretty hefty type of laptop machine and
I'll go ahead and run that program that
I just did and you can see it only took
198 milliseconds that's down here it's
taking that source string hello this is
a test it turns into an encrypted set of
data which is hex data that you see here
and so you send this over the Internet
and nobody's going to be able to break
it then you're gonna be able to decrypt
it because you know what the password is
to decrypt it on the other side and
that's gonna be 198 milliseconds so let
let's just make sure that's around what
we get that's 180 milliseconds under 80
milliseconds okay so let's call it 183
make milliseconds as the average there
because it seemed to be hovering around
there now let's switch over I'm gonna
hold this up this is a beagle board and
this is a Linux arm device so this I
call it a poor-man's Raspberry Pi even
though it costs more it's like $300 and
a Raspberry Pi is like $99 but you might
have heard in the show people talking
about embedded devices such as the
Raspberry Pi and makes computing on
embedded devices a lot a lot cheaper
nowadays the the low end is $49 and I
think there's a Raspberry Pi that's
comparable to this device that's $99 so
you could buy this and program for these
embedded devices nowadays and a very
very cost-effective way using these
testament test development boards and
it's connected with a serial cable to my
laptop and that's all I'm doing I've
loaded on here
Java SC for Linux arm and that's that's
a big deal now because we're providing
it from our group as a download you can
just go to the Oracle website say I want
the binary to run Java SE 7 on this real
tiny device and just get our binary run
it the same way you would run as you saw
on the on a Windows box so now let's go
on to the BeagleBoard and I'm gonna
switch over to this of course the demo
gods need me to reboot here so it's cuz
I moved it around that's why okay so and
it just takes a couple seconds to reboot
here so I could talk about it while it's
rebooting you can see it there's nothing
up my sleeves
there's no sleight of hand here this is
actual BeagleBoard running it's booting
up Linux it's only got 256 megabytes its
CPU is ARM chip as I talked about and
that means it only has I think a seven
700 megahertz chip on it it's it's more
hefty than I was talking about in the
presentation that it's got more than
just the the 270 megahertz that some
real tiny types of chips have on it but
now it's into the login here you can see
it's angstrom angstrom is a linux distro
that's very common on embedded devices
nowadays and it's a debian-based Linux
so it's very familiar to a lot of people
that have used Linux on desktops and so
I'm gonna go ahead and no just to to
show that this is a embedded device not
not trying to fool you with my other
devices here it is ARM chip 720
megahertz and
it's called the BeagleBoard here and
then I'm gonna go ahead and run that
same program and I ran before there it
is so it finished up in 2.8 seconds and
I'll run it again just to make sure that
it's I'm gonna get the average and not
just the first time it runs so you know
there was two point eight seconds two
point seven seconds two point six
seconds on an embedded device what took
183 milliseconds on my laptop so
something that you can't even tell is
happening on a laptop is all the sudden
something in terms of user usability and
you get rid of that in terms of
usability that's a big deal is whoops
sample sorry about that demo it's a big
deal that you have to wait 2.7 seconds
for it to come back so that again if you
go back to the code that bulk of the 2.7
seconds is coming from here and this is
going to be as embedded developer you're
going to just know that hey when I do a
key generation on an ARM chip it's a big
deal so I better be aware and be able to
program for it so that people know that
it might pause there for two seconds
three seconds before it comes back so
that's that's what I'm trying to point
out in a demo that it's not just that
you have the same api's on embedded and
desktop you have to be aware of what's
happening under the covers and in a
memory and in processing and that really
sums up the lesson that for embedded
device programming especially for
security there's all kinds of things
happening in the security algorithms
that you have to be aware of and
hopefully that helps I'm going to now go
back to the slides and just maybe
opening up for just a couple questions
if you have any questions anybody have
any questions about Java embedded or
security for devices No okay well I'm
available also if you want to come up
later after the talk
I know it's lunchtime so you might want
going off to get your lunch too but that
concludes my talk thank you very much
hope you enjoy the rest of the show</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>