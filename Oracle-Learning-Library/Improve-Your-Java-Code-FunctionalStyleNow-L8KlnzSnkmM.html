<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Improve Your Java Code, Functional-Style—Now! | Coder Coacher - Coaching Coders</title><meta content="Improve Your Java Code, Functional-Style—Now! - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Improve Your Java Code, Functional-Style—Now!</b></h2><h5 class="post__date">2013-02-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/L8KlnzSnkmM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this afternoon I would like to talk to
you a little bit about functional
programming in Java my name is John
smart I work in Sydney Australia where I
do mostly work on agile development
practices test-driven development
behavior driven development
continuous integration that sort of
stuff so functional programming from my
perspective is very much a practical
question it's very much what I can get
out of it and what's use what's in it
for me so I'll try and just share with
you my perspective on how I can benefit
from functional programming and how I
can make it work for me in Java before
we get to Java right so functional
programming I guess you may have heard
the word mentioned once or twice it's a
term that floats around a little bit it
is becoming very popular all the new
languages functional try to be
functional it seems it is there are very
good reasons that functional languages
provide a good model it's kind of
strange that it's only now that they've
really become popular because they've
actually been around since the 70s or
before maybe anyway at least as long as
I've been around so there but now there
are previously previous functional
languages that are come into vogue and
there are new ones that are becoming
popular as well so what's so great about
functional languages who uses a
functional language or has used a
functional language scholar or a school
yeah whose E is groovy it's groovy has
some functional aspects to it as well
you can program groovy in a very
functional style so one of the big
things in functional languages is this
idea of immutability for very simple
reason if you have an immutable object
and the mutual object is something you
can't change like an integer value or a
POJO with only getters and no see
so nice thing about immutable objects is
since they can't change their
thread-safe
you can have them shared between threads
and you don't run into problems that's
one of the biggest advantages there are
performance issues as well that make it
easier to optimize in Java it's actually
quite hard to do truly immutable objects
even final objects aren't really final
final variables and you can use
introspection and things like that if
you really keen to modify stuff so Java
has limited support for true or mutable
objects but you can try but it does have
a lot of benefits to to try and make
objects immutable where wherever you can
where it makes sense
your mutable objects one aspect of
functional programming another is side
effects so in functional programming one
of the big concepts is that there's
something that goes into a function and
something comes out your data side
effects so you don't have you don't have
a function a method that will change the
state of an object in a way that is
unrelated on the surface that seems
unrelated to what the method call should
be doing so you call a method get a
result and that's it so you should be
able to repeat a function call and
always get the same results so that's
very reassuring in that it avoids funny
bugs when you call a function you know
what it's going to do it's very
predictable it's also arguably easier to
understand because you can see what's
going on you don't get the sort of funny
side effects a another interesting thing
is that it's much easier to optimize
functional programming a programming
style which a program that's written in
a functional style is easier to optimize
for so that can be run in parallel
that's if you if you use a very
iterative classic nor traditional style
of programming
to loop through a loop you will loop
through that loop in that particular
order if you use a functional style you
say okay do something on this color on
each element of this collection I will
see later on it's much easier then to
decide to let the compiler decide or to
adapt your code slightly so the compiler
can optimize that and run it in parallel
batches as opposed to each rating over
each element so it gives you a lot more
freedom in that regard and you tend will
get do away with for loops for loops and
loops in general fairly old come
constructed language and can lead to
confusion if they get too complicated
they tend to hide the essence of what
you're trying to do which brings me to
my to my next point functional
programming is really trying to put the
move the emphasis away from how and go
towards what so rather than saying how
you're going to do something you move a
lit take the level of abstraction one
level higher and you describe what
you're going to do so rather than saying
I want to iterate through this loop and
add one and look at each element and if
the element has a price that's greater
than 100 then I'll add it to this result
collection and then I'll return that
collection that I've tossed everything
into you just say get me all the sales
that are greater than 100 dollars they
describing what you want rather than how
you go about getting it so that has two
advantages it's easier to understand
because easier to communicate what
you're actually trying to do and it's
less error-prone because you let the
language or libraries do all the
nitty-gritty details you just say what
you want so you get a lot of that in
most functional languages so
you may have heard some what - called
Jabbar ate something coming out - with
some sort of new newfangled lambda
thingy anyone heard of that he may have
heard that mention once or twice I'm not
sure with you listening following
closely in the keynotes and whatnot you
might have might have caught a glimpse
of this so in Java right there's this
thing called lambda expressions which
provides a lot of these dysfunctional
programming language support for Java so
in Java right you can do things like
this so we've got a list of strings and
what we want to achieve is to find all
the strings in that list that start with
the letter P so what do we do to
describe that we say okay filter the
name starting with P into an array list
no that's so it's not too bad I mean it
would be nicer in Scala be more concise
but it's still it's still not too bad
you can still kind of read what it's
trying to do you're nicer in groovy as
well but I mean where they've got you've
got a lot of baggage with Java so you
have to sort of do what you can with
what you've got really but I think what
the main thing here is that you're
saying you're looking at you're saying
okay filter the names into an array list
as you read it you can see what it's
trying to do
so why did I repeat that I think I was
just pointing out what it looks like so
you can do other things for instance
here we've got what we got we've got a
list of pets a pet has a name and the
species or going to do things we've got
some cats and dogs and guinea pigs and a
few staff a few static constructors and
things like that and so we've got we're
going to play around with these see what
we can do with it we've got we start off
with a list of pets so what do we got
we've got a cat called ginger a dog
called spot a guinea pig called fluffy
and another dog called Rover and so we
want to get all the dogs do is that what
we want get we want to get all the dog
so filter get the dogs and sort them by
name and what I want to point out here
is we're doing two operations two
sequential operations and when you read
the code even if you're not too familiar
the syntax you can more or less figure
out what's going on
so filter then I get species equals dog
things sort of take a guess that means
it's trying to filter all the elements
who species as dog and then sorted now
here it's another nice little construct
we're passing in effectively an abstract
method saying okay compare the names
kind of clunky but it's be nice if you
just say compare by name but that's Amal
shows a more general approach you're
passing in a function AK effectively
Lander constructing a closure to say how
exactly you want to sort it so it's a
lot nicer than creating an anonymous
class which you'd have to do in previous
versions of Java sorry
yeah so it's still kind of clunky but
it's certainly better than the nothing
but it's still kind of clunky it's not
definitely not a level of what you get
in Scala or groovy or more more recent
languages here we've got another example
so we're filtering then we're sorting
here we're filtering we're converting it
to a map and then we're sorting again so
here we're actually the difference is
here what we're doing is we're getting
the objects whereas here we're just
getting the name so there's something
you do a lot with functional programming
you actually probably do it a lot in
your normal code
I certainly do it but it's not
necessarily something you really think
about until you start programming with
functional languages you take
collections of objects and you do stuff
with them who works with collections or
lists of objects and does stuff with
them anyone now I didn't think so it's a
really pretty rare thing to do they take
collections and you're manipulate
collections so you extract data from the
collections you filter it to you
transform the data into a different sort
of data you a granade the dirty dual so
you do a lot of that and when you have
to do it with four loops it gets pretty
boring so here's an example of
extracting some data from a collection
and all we're interested in is the name
not the actual object itself and here
we're doing something else we're
creating a effective predicate saying
okay find me all the carnival the pets
that are carnivores then we say okay
filter carnivores into array list so
we're just finding cats and dogs because
they are the only ones that match that
predicate so this second line is what
you're interested in filter carnivores
so when you read that it's pretty
obvious what's going on much more so
than if you had to do a for loop and
there's a for loop the thing with a for
loop because you'd be doing that your
mind says okay I've got to follow so I'm
looking
but then you go in the for loop so you
might say okay what what am I actually
doing trying to filter so it's two
different steps here we're seeing okay
get me the carnivores so less CPU
operations for your brain so here's
another example where we've got all the
pet where I've got an object or vets day
and we want to transform our pets into
some of our pets presumably not all of
them into this vets day object which is
presumably when they have to go to the
vet to get fixed up so we've got a vet
stay with a start of stay and a
diagnosis so here we go to do a map
we've got a list a pet and we transform
the pet into a vets day object so to
give it a date and a diagnosis so this
is another example we're transforming an
object or telling basically telling Java
how to transform an object into another
sort of object and then you can take
that operation and then apply it to a
whole collection so that's something you
do quite a lot with functional
programming and here we've got another
example where where pets any much pet
we're finding where look what are we
doing here yeah we're finding pets in
that list where the pet is a dog and
we're may assert the assert means okay
there is a match there exists a pet in
that list who is a dog so doing a search
on the list and checking whether
checking for the presence of some sort
of element in the in the list so these
are examples of the sort of things
you're doing functional programming but
the question is who is going to be using
Java right anytime soon anyone
anyone on Java seven yet who's on Java
seven who is still stuck on Java six but
would like to be on Java 7 if up and I
do remember a client not so long ago
that they was still stuck on Java 41.4
I'm sure they had a good reason at least
they thought they did so sometimes these
things take I think probably because IBM
was supporting it or something but that
sometimes these upgrades can take a long
time to come through so it's a bit
frustrating to have to wait before you
can actually use this stuff so there are
a few tools libraries that you can use
today to do functional programming of a
sort in Java and sometimes it's really
really nice and elegant and sometimes
it's kind of ugly a bit of a fine line
to walk between the two whose use Google
guava yep got a fair few people at
Google guava is a library that well it's
a metal library really it's a collection
of utilities and cool stuff that Google
users use themselves it's got some very
interesting things it's got and what I'm
going to do here is focus on about 5% of
Google guava which is the support for
functional constructs or operations
first one probably the simplest to use
is the concept of immutable collections
how immutable collections are useful in
Java for the same reason that immutable
objects are useful you can't change them
if you return an immutable collection as
a result of a call you know that the
method that calls that that gets that
collection can't go and mess with your
internals if you just return the other
way
you have to copy it but if you just
immutable collections much safer than
just R if you just return the least
you've got a list of clients in a unit
class and you return that list of
clients obviously nothing's going to
stop your client class of doing a sort
on that your or some other class doing a
sort on that list and stuffing up your
your own class if you're not careful
immutable collections make a very
obviously you don't want people to do
that and make it actually impossible
people to do that so a couple of ways
this can work you can have this
immutable list of and then lists the
elements that's really good for any for
tests if you just want to set up that
immutable data and there's also the
immutable there are copy operations so
the mutable set immutable list copy of
and then the object you're you're
passing now an immutable just a one
caveat an immutable collection is a
collection that can't be changed non
said anything about the objects in the
collection so it's not truly immutable
unless the objects in the collection are
also immutable so what the immutable
collection does is basically it will
throw an exception if you try and sort
it or delete things or add things or
mess with the list do anything to the
collection it will throw an exception
but if your the objects in that
collection our model can be changed the
immutable collection is not going to
stop it so works best if you combine
that with and with a mutable objects if
you really want a mutability you want to
return an immutable collection of
immutable objects so objects with just
get us as your as the simplest way to do
it yes
collections are at the as in the Apache
Commons collections gbk collections
unmodifiable this predates it that's
been around for a while other than that
I don't remember be honest
we're immutability is a bit of a tough
one in Java because it's very hard to
actually make things truly immutable
just like finals but there's a the
readability of this is quite nice find
that quite readable as well so another
thing that guava borrows from functional
languages is the idea that returning
null is not such a hot idea after all
so probably nulls you get a null pointer
exceptions but that's not the
fundamental problem of now anyone got
any thoughts on what the real
fundamental issue with returning null is
hmm sorry examine say anything about why
you're returning null so there's a
semantic issue there why you're turning
null is it because no such object exists
is it because there was an error so
there's a there's an ambiguity and what
you're returning which can cause
problems and then when you get now how
do you know how do you expect that
you're going to get now your attend an
object say oh if we don't find it we
return now I hope everyone understands
that because otherwise it will explode
but it's not very obvious you might put
in the Java doc or something but it's
not really obvious that that's your
intent now in languages like Scala you
have this concept of not returning now
ever that's my example of an interface
we're going to into client service
interface fine by name if you return now
what does it mean so in functional
languages you have this concept of
optional so rather than our client
service which returns a client and if it
can't find a client returns now so like
hibernate does for some
of some of the calls here you return
optional of client now option or kind
that as much documentation as anything
else it's saying hey there might I'm
returning a client but maybe there isn't
one so it's about communication as much
as anything else so in your code it
means hey I'm not getting a climb back
I'm getting an optional climb back so
that forces me to think about things
like hey what am I going to do so if the
client is present and I'll do something
otherwise have to do whatever is
appropriate if the client is not present
so that it's safer than returning null
because it forces people to think about
process handling that case in functional
languages it's a bit simpler because
languages cater for that at the this
level as well so it makes it a bit more
elegant but still I think the the key
thing here it just shows the intent that
you makes it very obvious that may not
be a client and you better deal with it
so you can also get to use things like
this color so color to use get favorite
color so that will return will get
favorite color or blue it'll return
whatever color was or a default value so
you can there are a few methods like
that that help you define the semantics
of what you do in those cases and makes
it quite clear what what your intent is
so again it's a this is as much about
documenting what your intent is as I
mean you can check for null as well
that's semantically it's the same thing
but here you're making it very clear
you're forcing people think about it as
a rural optional you use optional to
return a value you don't use it as a
parameter passing passing a parameter to
our method passing an optional parameter
my method is kind of weird as a general
rule normally it's just when you return
a value that you have optional so that's
a brief overview of some of the stuff
that guava provides just as general
utility methods so now I want to have a
look at another library called lambda J
which provides more focused functional
tool guava also provides functional
support and pred exits and things like
that that said the functional support in
guava I found a little bit clunkier than
in lambda J so lambda J is really a
library from working with collections
that's quite focused it's quite quite
deliberately limited to manipulating
collections in a functional style but it
does that exceedingly well for you get a
whole host to all the functions that you
actually use a lot of the time things
like filter sort a great extract so you
might want to look like the examples we
saw early on fill pull out a subset of a
collection that had that obey certain or
respect certain criteria sorter
collection convert the object in a
collection to another type of collection
group them and a lot of pretty standard
operations that you do normally using
for loops and and building results as
they as you go so I'll take a few a few
examples just to give you an idea now
you see how compares to Java rate so
here we have a lots of same example as
we had earlier we've got a list of
philosophers and we want to find all the
philosophers that start with the letter
P I'm sure you do that sort of thing
every day
so the nice one of the nice things about
lambda J is it works with home Christa
sir - is use who is familiar with home
Chris deserts right that's your homework
for your other guys go look up home
Christopher because they are very very
cool
home crest asserts are a way of now
they're extensively used in unit testing
so rather than I haven't got a slide
here but rather than writing assert
equals 10 price you write assert that
price is 10 sounds really simple like
that but actually really really powerful
and here we've got an example so this
what we've got up here we've got a we're
making a e what are we doing I said that
assert that filter names contains Plato
Pythagoras that's an example what we're
doing here is we're importing a static
method from lambda J we're saying okay
filter and here we're going to start
with P that starts with P is a hunk rest
expression so we could have say assert
that filter all of starts with P here as
well that would be another it's they
work in both situations but here the
interesting thing is so we say starts
with P names so we're filtering
extracting all of the philosophers we
start with P in one line I find that
actually a lot more readable than the
job or eight version so they work quite
nicely together because the hungriest
asserts are really powerful and they're
you can do a lot with them you can also
write your own so you can write your own
domain specific custom matches home
crest matches which goes to making this
even more readable
so that's why that's the result of what
filter start with P names and you'll get
a filter so it's quite concise so just
comparing the three approaches so this
the first section obviously what you
traditionally do yep that been fairly
standard code the second one is the Java
rate and the third one is the lambda J
quite like the lambda J one actually
Java rate I think will have other
advantages and is it'll work everywhere
yes sorry yeah
starts with take the string yes yep but
matching hamcrest matches you go a
gazillion matches with four different
sorts of operations and you could write
your own so if you it's quite free quite
when you're using hum Chris matches it's
quite common to write your own custom
matches to work with your domain objects
so what else have we got
so here we've got some of the examples
of we're looking at earlier so we want
to find all the dogs so this arguably
we're starting to run into the limits of
the Java syntax but it does a reasonable
job anyway fine because you well should
I'll explain the advantages they say
filter having on pet speak get species
is dog so I'll break that down so
they're having on pet class you have to
do that to basically give lambda Jo a
hint as to what what functions you what
method you using and what class using
nothing is once you do that once you do
the having on pet class you do a dot and
you get all the methods of the class the
pet class so you get species and then is
dog that's
your home Chris Matra then pets is
Alesha sorting and then once you do that
you'll get your result so I find that
actually pretty nasty compared to your
that's getting pretty not particularly
readable so you want to be a bit careful
about how you use that yes
I've got performance benchmarks I'll
show you later on about lump about
lambda J and standard looping I haven't
got any for for Java rate I I've done
these operations but I didn't do any
benchmarks on them I imagine being built
into the compiler and the bike code
would be reasonably fast now lambda j as
a rule it's it's obviously slower but
not that much slower so yeah that's I
would say that's a pretty nasty one
that's not particularly readable but you
can do it if you have to so and the
lesson of that is that like you can do
everything with lambda J that you want
but sometimes it starts to get really
clunky you've got to be a little bit
careful about the maintenance of not
it's the old thing just because you can
do it doesn't mean you should do it here
we're going to smaller more obvious
example
so sort sort of dogs on class get named
so here we're just sorting by name and
and here's another typical sort of
operation you might do you do often
you'll do operations in several steps
just to make it obvious what you're
doing you might be able to do an
operation with a one-liner but it's not
necessarily a good idea because it will
be hard to maintain afterwards so here
what are we doing we're finding all the
dogs and then sorting the dogs by name
and to notice I'm using variable names
to make it we're relatively clear what
my intention is what I'm trying to do
and so we'll see is an example of
extracting with lambda J this is an
example where I'd say lambda J is
probable that's Java right this is where
Java rate is a bit clearer than lambda J
so I suppose so we're finding all what
are we doing so filter we find all the
dogs and we map so we get all the names
of the dogs then we sort the names so we
get a sorted array of the names of all
the dogs so if we did that in lambda J
what's actually can we have a Paul which
one's better
first the Java rate Jo he says Java
rates better on this example who prefers
lambda J who who has no opinion so
that's how you do it in lambda J so
you'd want to break it up into steps so
it's more obvious what's going on I
guess these first lie they're having on
I always find a bit clunky I mean when
you get used to it's okay but still bit
clunky so but it certainly beats the old
approach of doing it with just
traditional Java we have to actually
implement a an abstract method yes
in lambda J or in in job rate obviously
there are ways to do that in lambda J no
not not at the moment I think I don't
think there you don't yet but I suspect
that's something they're probably going
to implement is it's a really good point
I mean it's you know I don't think they
do it as I've yet I think at the moment
it's just transformed into other looked
at the source code so I'm not sure what
goes on behind the scenes but I'm not
aware of any particular support for
parallel explicit parallel operations as
of yet but it'd be an obvious thing that
they'd be likely to do but that's a
that's a very good point normally the I
mean with Java rate you may seen you can
either basically add an operand scalar
you add a signal operation in the chain
to make a power make it be able to run
in parallel so I'm not aware of that for
lambda J or further or any of the other
ones either for that matter so for that
you have to go to scholar so it may like
I said it's something obvious that you'd
want to include so I suspect there might
be something on the roadmap what else
have we got
so here we've got our example of
converting names again so here got
another example of converting hit the
vets day example so how do you do it
with Java 8 so we convert the pets into
web days so putting this putting the
pets into sending the pets to the vet
now this is this takes a bit of getting
used to but I actually quite like it
within I think it does a good job of
getting around the limits of Java of
Java pre Java right so what you do you
do come
but convert pets to vet stay so so far
so good that's really clean and obvious
and then here's the nasty bit this is
because you haven't got closures you
have to return an anonymous class to say
exactly how do you convert a pet to a
vet stay the anonymous class is simply a
converter class that takes a pet and it
converts it to a vet stay and then you
have one operation convert which
converts the pet to a web state yep the
web state
yeah
Java's good at that but that's what you
do typically when you're converting
that's a in this case the aim is to
convert a list of pets to a list of that
stays
for therefore this particular oh yeah
yeah I see what you mean guess very true
you would typically have a proto static
static final class I did some short cuts
or the feet on the slides but yeah very
true for the actual for the class itself
your item although you're talking about
the red-state class yep absolutely right
this and typically be a static final
class but the thing you want to take
into account is you go to one-liner and
the only thing you're really interested
in is this line here so the rest is
boilerplate so I actually use that
pattern quite a lot because it's quite
common to have to take a collection and
convert them to objects if you take for
instance web testing do a lot of work
with web tests you'll look at you might
look at a page get a list of web
elements from a table and then convert
those web elements to a poacher's for
higher up so the POJO that at the test
level itself you're talking about pojos
and not web elements and in that case
it's exactly the same pattern you're
converting your web elements to pojos
you can also do grouping so here we're
grouping by species so we so we convert
we get a list of a group all for each
species and then we want to find the dog
so we do pets by species find of dog and
it returns a list of dogs this is one I
found often and found useful so you've
got a list of Lists and you want to just
flatten that into a single list take out
the flattened method very simple
effective works well so you might have a
tree structure and you might want to get
all the leaf nodes of that tree
structure or the leaf nodes of a
particular type you can recognize them
you flatten the list you flatten the
element in the because your tree is
effectively a list of lists you flatten
the tree and then you extract the leaves
so what else we got
checking for existence so exists check
whether an element exists in ER in a
list using predicate so again the
predicate is similar to the anonymous
function we saw earlier we've got in
we're in Java 8 you'd create this
predicate object so pets filter
carnivals and whatnot and lambda J you
have to use anonymous anonymous our
classes so you've got a predicate of
type pet and then that predicate has a
boolean function called apply and then
you just check do whatever you want so
we've got the match up it will return
true if it's a dog or a cat and then the
filter is very similar to what we saw
earlier just filter Carnivale pets I
find or extract all the objects that
match that predicate you get this
pattern a lot yeah yeah there's support
for maps yep I my are mainly doing
collections in the examples but there
are there is plenty of stuff on maps as
well
you can aggregate so bundle now bundle
your objects together and do so here
what am i doing finding the maximum pets
get age mean from pets good age so what
I'm doing there is Max and min so the
pets can be sorted however you want to
naturally sort them and if you had for
instance if or pets I'm sorting by age
for an arbitrary reason but in this case
all I'm doing is grabbing the oldest pet
and the youngest pet and finding the sum
of all the ages so they're built in
operations so in real world class you'd
probably have but you'd be using the
natural sorting by price or whatever and
so here's actually a real-world example
so we've got a in this real world
example it's a processing test results
I've a set of some tests pass some tests
fail some tests are pending and so I
need an operation that extracts all the
passing tests so that would look
something like this to filter having our
test outcome class get result is success
you get used to it they're having on or
you could do this I mean the thing here
is you're used to it without having on
test outcome class get results in
success
I've got successful got failure I've got
pending I've got ignored I've got lots
of different types of tests that get to
be boring to repeat that so what I
really would like to do is just have a
method filter with result success and
the with result that returns a match up
that's a hungriest match up and the
matcher is basically a parameterised
version of that expression we saw
earlier so having on test outcome class
get result is expected result so you do
tricks like that to reuse predicates to
reuse matches make the all
the aim is when you start to see
something in a bit clunky hide the
clunkiness away because the important
thing that you're trying to convey here
is what this line does
so I filter with results success that's
fairly obvious this goes into the realm
of how you do it so you can hide that
away but this is the most the first line
is the important bit to meet you want to
convey where your business logic is
going to be so since at UM crest um
crest allows you to do things like this
you can put matches together and combine
them so here we don't filter any of with
result success which was op pending so
we're finding both successful was a test
success and pending so its hamcrest are
a lot of ways to add to join and combine
and mix and match matches so that you
can actually combine and nest matches
together
so what do we got here so we're
extracting tags so I got this just
remembering what my example is yeah so
here I've got a set of tag provider
objects each tag provider knows how to
return a set of tags and all I'm
interested in is the total list of tags
so here I do an extract tag providers
get tags so I extract all I'm going to
get two collections and then I flatten
that list so I just get one list so
again combining and aggregating that's
very typical of functional programming
that's just and the advantage advantages
in readability you when you get used to
it especially it becomes obvious what
the intent of your code is as opposed to
trying to figure out how you do it now
someone asked about performance so these
are benchmarks comparing just normal for
loops to lambda J so it reaches out
about two and a half times slower using
lambda J then using for loops I mean I
depend on your code but for me two and a
half times slower is not going to be a
deal-breaker
if it makes the code more readable
so here's a just something that the
guava team says about the functional
programming yes
I haven't noticed and in particular I
think though these are pretty big
benchmarks or sorry yeah the question
was how does it impact garbage
collection because it creates lots of
small objects I presume what I'm
thinking is the garbage collection is
going to be reflected in these figures
because these are pretty long running
benchmarks so that would be part of a
part of that and the reflection using
reflection and whatnot so this is just a
quote from the guava team who basically
say the jar is not meant for functional
programming so don't push it so when
you're using any sort of functional
programming techniques in Java it's true
of a lot of styles you don't want to go
overboard and make your code so full of
this stuff that's that you can't
actually understand it so the intent of
all this is to make the code more
readable you've got to keep that in mind
the intent is to convey the logic of
what you are doing to whoever is going
to read the code later on so the intent
is not to show how clever you are with
your functional programming skills the
intent is to convey the business logic
in a way that's clearer than if you had
to deal with a for loop so if we add
something like this it takes a fair bit
of sea brain CPU cycles to actually I
guess we'll figure out what's going on
whereas if you take something a little
bit simpler less optimal from a I mean
it's not a one-liner but we're
explaining the steps that we're going
through to obtain our results but if
making very clear what we're doing and
why we're doing it so that arguably this
second approach is going to be easier to
maintain than the first yeah now maybe
it's a question of a lot of this is a
question of taste and style or whatnot
but Jen the point is you want the you
want your Co to convey the meat the
intent and the business logic of what
you're doing rather than how it's doing
it so here we've got another example you
can you could do this converting pets to
vet stays with an inline anonymous
function but I'd much rather do it just
with a convert pets to that stay because
it reads clearly and says what it's
doing they'll worry about the details
later on so I personally prefer that
style even if it makes lots of one law
effectively one line anonymous class
functions the next last thing I want to
point out is this idea of the matches so
I'll be talking about hamcrest matches
and the way you will often write your
own custom home quest matches so here's
a very simple example the one we saw
earlier where we've got the width result
where which we can reuse in different
contexts now in in the actual
application code that's used all over
the place I had a very simple example
you can do much more sophisticated
matches than that it's hiding away the
details of how you go about deciding
whether manipulating your objects really
doing predicate operations on your
objects so matches are not hard to write
you can either use them directly with
these having methods or you can actually
write a custom hunk rest matter which is
a bit more involved but not rocket
science either so that goes to it all
goes to making the code more more
readable so I think the bottom line is
these techniques are useful if they're
going to make your code easier to
understand and maintain so I find them
useful because I do a lot of work
manipulating lists and collections and
sets of data and so I find it makes the
code more readable and maintainable
and gets away from conky for loops
that's but the bottom line is you do
want to use it with the intent of making
a code cleaner and more understand
easier to understand okay questions
yep these slides will be available on
the owl's they'll be on the Java one
side they'll be on Wacha Leo calm which
is the left side there they'll be on
SlideShare they'll be available yeah get
all these all the tools I've been
talking about are open-source thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>