<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>High-Performance Scripting with Kawa | Coder Coacher - Coaching Coders</title><meta content="High-Performance Scripting with Kawa - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>High-Performance Scripting with Kawa</b></h2><h5 class="post__date">2013-01-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/GouDYhrOc2g" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to those of you are here my name
is Pierre bottner and I'm going to talk
about the open-source scripting language
Kawa which is a project I've managed and
been involved with for many years no
wrong direction so I am I'm an Oracle
employee but I want to be clear that
this is not an Oracle project and it's
not sponsored or supported by Oracle so
this is my disclaimer so the take away
which we're supposed to put on the slide
is basically these points and it's going
to be a somewhat rambling talk so if you
have questions or or things are unclear
you know feel free to interrupt the
things is convoy is the mature its
standard based scripting language next
sent me a very high-level non pure
functional language that means it's a
language where functions and expressions
and pure values are easy and important
but it's not a pure language there are
there are side-effects and assignments
and as far as I know it's the fastest
scripting language on the JVM depending
on how you define scripting language and
it provides a good balance between the
static and dynamic properties of a
program which I'll talk a little bit
about more and so first okay we know
scripting languages have a lot of bells
the last few years very visible and
popular but what is a scripting language
compared to a contrast to a programming
language and there is a really a
difference it's it's a matter of degree
but common properties of what we think
of might be a scripting language is that
it has immediate evaluation you don't
have to have a separate compilation step
if there's a compiler it's automatic
when needed there's typically you can
evaluate expressions immediately there's
an eval function and there's maybe a
read eval print loop that is you know a
command shell it has less boilerplates
you don't have to say you know class
something function main and all of that
stuff that you have to with Java
there's hopefully there's not usually
less syntactic verbosity and and
programs tend to be on the whole more
dynamic less sort of fixed when you
write it program and more things on the
fly so one issue with scripting
languages is they tend to be very slow
relatively speaking which may or may not
matter depending on your application
here's some benchmark numbers these are
these the so called shoot out benchmarks
and with all these numbers are relative
to the Java Runtime so higher numbers
are slower and and Scala is usually
considered a not a scripting language
it's it's sort of heavy-duty it's a
little hard to learn and it's not as
agile as other languages cloture and
JRuby and calves are are perhaps more
scripting language side you'll notice
cloture and JRuby are significantly
slower than Java or Scala and
significantly slower than Kawa which is
the language we're going to be talking
about now you know there's a little bit
of cheating because cava has optional
type declarations and a smart compiler
but of course those are things that are
very useful if you care about
performance so so and cut down on the
arms the it's not just speed that's an
important when you're comparing programs
and programming languages you also care
about how productive it makes you and
being too dynamic makes it hard for your
compiler and IDE to detect errors at
compile time or and and we all know the
early
you can detect errors the faster the
cheaper it is to fix them and your
typical scripting language has just as
runtime type checking which means the
way you detect an error is you get an
abort runtime error and then you have to
figure out what caused the runtime error
and so if you have for example type you
know static types aren't just you know
you know they they let you annotate your
program with things that let you the
compiler catch errors you know since you
know we all program in Java as well as
other things so you know that that's
good
and and also not just catching errors
but also analyzing the program you know
you want to find given a an identifier
in a program where is the declaration
the definition of the identifier and if
your language is very dynamic it depends
on what the execution passive you know
what what gets loaded what in which
order and you can't really judge where
the definition of the variable is so so
so there's there's a trade-off there and
that's a big trade-off in programming
language design what aspects of a
program are static and what are dynamic
and you know static aspects the things
that are fixed in the program fixed at
compile time are things that make it
easier for the compiler the type checker
the ID and the human to figure out
what's going on and and analyze the
program understand it on the other hand
whatever is dynamic what the things that
change at runtime you know they make the
program more flexible more agile you can
do things on the fly
so so is the key issue is what is the
right balance and and I think cava has a
fairly good balance there and it lets
you get good performance it lets a good
error checking but it lets you do all
the dynamic things that are are you know
most useful in my opinion okay that
button didn't work try
I think I went to farther it's like
missing I think
you know there's a sign missing oops
happen or having Savannah just use this
hmm okay there was supposed to be a
slide about dynamic versus lexical
scoping of local variables I guess I'll
have to wing that it's about this fair
the classic rookie mistake of people
designing their own programming language
is you make dynamic scoping of local
variables and a similar related mistake
is oh the variable comes the appears
automatically if you signed to it and
this seems appealing to people who don't
have a lot of experience with
programming languages it's simple it's
easy it's convenient but once you get
more experience because all kinds of
problems and and experienced teacher
says that lexical scoping closures
lambda expressions are much more useful
in general and so that's where you know
the the kawah which is a dialect of
scheme has schemas had most perhaps the
first important language which actually
had lexical scoping in terms of what we
now might think of as a scripting
language or a very dynamic language okay
so now let's see if I leave the slide
that was following the slide that I just
improvised as an aside dynamic scoping
does have its uses it's not it's not you
know completely useless feature for
example for you know context parameters
like the current open file or the
current paint or you know or state of
your program it is Sun as convenient to
basically have that be inherited
dynamically in in the States but it
shouldn't be the default for your local
variables and Makabe has functionality
for dynamic bindings it has a fluid let
the dynamic binding so it's called fluid
bindings and so so it has that
functionality but the default is lexical
scope in which this is the right thing
and a slightly harder to read slide
another example where the trade-off
between static versus dynamic comes into
effect and programming language design
is how our class is defined and in the
classical trance any intended is that
classes you write them in the program
they have a name they're fixed you know
you can tell what the name from and from
a name of a class you can tell the
definition of the class it's right there
but some languages instead have
prototypes basically a any object can be
sort of act as its as a class for any
other object by providing the defaults
for it the most common but best known
example is JavaScript some languages for
example Juby sorry oops some languages
for example Ruby allow you to add
methods to a class dynamically basically
that's how classes are created by adding
methods to them and you know these these
properties first they make
implementation a lot more difficult
needlessly more difficult especially on
the JVM but even if you have a custom VM
it's difficult but more importantly it
breaks modularity it pollutes the global
namespace with things that changed in
weird ways you know given a class name
if your class chain can change
underneath you you know you don't know
what what it is what it can do and it
makes it very hard to keep track of
understand what's going on and it's also
again you know right now we all know
parallel programming is the big
challenge and part of the solution
appears to be immutable state and if you
have mutable classes then immutable
States becomes so much more difficult so
conclusion is you know keep your classes
static you know you can always create
classes
the fly and if you have a vowel or
something like that but but but but
their basic define a class mechanism
needs to be static or should be yeah
last slide on classes decided on
multiple inheritance
yeah cava has you know conventional
classes defined in the program text with
all of stuff all of the fields and
methods in the same place but it does
have more full multiple inheritance that
is a class can extend multiple classes
and it's it's Java 8 is finally getting
multiple inheritance for interfaces in
that he can with with default bindings
cava also has multiple interface
I'm sorry multiple inheritance of fields
and state which isn't as useful but it's
occasionally as well and it just makes
things simpler and more consistent and
cob also has properties in the sense
that the compiler kind of hides
difference between fields and methods or
getter setter pairs so if you you can
use something that looks like a field
reference and if there isn't the feel
but there's together set of pair it'll
use that and vice versa so let's try the
next one
okay now back up if you know a few
hundred feet so the Carver language
which I've basically written since 1995
is a language in the lisp scheme family
of languages and scheme goes back to
1975 and was the researcher of guy
Steele is also well known for the Java
language specification it's game has
been standardized a number of times in
formal standards there's a new standard
the the seven times the seventh revision
are seven RS is expected late
this year or maybe early next year and
there's because of this there's a
related to this it's a there's an active
community of many implementations and a
number of them is still active there's
also a number of historical
implementations it's been used a lot in
academia for programming language
research and teaching is basically the
prime language for experimenting with
dynamic languages scripting languages
and Calva Impa is is more or less
compatible with the skin specifications
it implements basically all of the
current specification which we could
argue whether that's our five or our six
and that's a contentious issue with a
lots of popular extensions and the main
thing missing before before people ask
is that it does not support full
continuations at this point and
implementing those is possible but it's
difficult and and it's not clear it it's
never been important enough to get to
come to the top of the priority queue so
the thing that makes is most obviously
noticeable about the families in the
lisp scheme family in languages in the
loop and that family is the way function
calls look the lots of Lisbeth's have
said to stamp are lots of irritating
silly parentheses so the the function
call notation is our assistant work
my clips nope
and okay so sorry about about that okay
let's just see it go there
but it's a yes okay so we will point my
hand so this is your prototypical
function call expression it's basically
these are all expressions that evaluate
it and then the first sub expression it
has to evaluate to a function object and
then the others become the operands of
arguments to that function which then
gets called so here's an example if if
steward is bound to a string this gets
the substring from I to J of that string
and so substring here is is is is a it's
sort of a variable but it's a constant
but it's a variable that's bound to
function so so it's in general this
could be an expression but usually it's
just a variable name and for consistency
of this notation is also used for
arithmetic so this adds these three
numbers to get 6 now we use the same
prefix syntax for control structures for
example this conditional hair it's this
sort of if expression if this this is
the condition if I is less than 0 notice
the less than is also in prefix for
position then negate I again in prefix
otherwise return I so it's basically the
absolute function yes
and right now I'm speaking of speaking
scheme in general yeah this slide in the
previous slide is a scheme in general
and similarly assignment has this
built-in operator which looks like a
function but it's yes it's a special
built-in operator which assigns the
value of this expression to the variable
named ABS I and this is not a
subtraction it's a very you know - can
be in variable names the the in general
you know these are all
identifiers this is an identifier the
less than sign the minus sign is our
identifier there's there's a fairly rich
syntax for names and in the scheme list
family which means you have to put
spaces which is what do you want for
readability anyway
and you don't have to have commas so
there's you know there's positive - is
what the syntax a finally variable
definition defines this variable to have
that value still general scheme rather
than cover except for the sentence so as
I said scheme is a functional language
it's always had anonymous lambda
expressions or lambda functions which is
a little like Java 8 if you familiar
with that and that's dcara this is a
this is a keyboard that's you know it's
predefined lambda a parameter list and
then an expression so this this create
defines creates a function value which
with these parameters and then when the
function allocates called this
expression is evaluated in the context
with the parameters bound to the actual
arguments and and then this can you know
this can be assigned and passed around
this is this is a general thing that you
know it's just it's an object but it's
an immutable object though it may depend
on the lexical States because that's
that's what lexical scoping means so
there's an example here this is the the
same absolute value expression now as a
function with a with the parameter I
return the absolute value of I as a
color extension if you use a lambda
expression in a context that requires a
special class an interface that has a
single abstract method then the lambda
expression and gets turned into a method
of of an anonymous class very similar to
Java 5 sorry Java 8 but the difference
with from Java 8 is that you can use
these lambda expressions even in an
untyped context you can sort of if you
have the equivalent of object x equals
lambda expression is meaningful which is
but it's not meaningful in Java 8
because lambda expression each of eight
are only meaningful in a context with a
target type in cava if there is a target
type it will do this automatic
conversion but if it isn't it'll be a
generic function value and of course you
can name functions this this this
special syntax here defines Apps as a
function with the parameter I and the
body hair and this is basically just
syntactic sugar for defining abs as a
variable that you initialize to this
lambda expression so yes this syntax is
a little weird
maybe it's consistent and it's simple
it's not what we're used to but it has
some advantages the main one is that
given that the the core syntax of these
in prefix expressions its prefix forms
is very simple in general it makes it
easy to extend the language and define
your own forms basically Mak a macro is
fairly easy to write people do it all
the time you don't have to be an expert
to do it and it's basically mapping from
a you know source expression some a form
that's in the source program that the
programmer writes and then it maps that
into a something implement in terms of
primitives or other kind of macros so
it's a it's a it's it's a rewriting to a
simpler expression and then so so you
can basically define domain-specific
languages or whatever kind of syntax as
you like that
and the key thing so the in the macro
call or a macro invocation you know you
call it the same way you have a macro
name and arguments and then these gets
passed to the macro transformer and then
get compiled evaluator just like it was
a built in and so having this in fixed
syntax sorry this perfect syntax
consistent makes this a little easier
and you can define macro systems
expensable syntax in other languages but
they tend to become they haven't been
very successful it's difficult to do but
it's mainstream in the lisp scheme
family and the if and defined firms are
in cava are actually implemented as
macros in terms of lower level
primitives so just change and move on a
little bit this is now not scheme
general though there are other schema
implementations that support the same
syntax this comes from a language called
DSL this actual syntax no DSL dsssl for
it was it was a precursor to XSLT using
which was basically a scheme dialect so
this but if I ins a function Z which
takes this this is a magic little word
which means that the following
parameters are keyword parameters
so there's Ari and M are the names of
the parameters and they have default
value zero and the function calls make
rectangular which creates a complex
number with those values and so here we
define the imaginary constant as Z with
M set the in parameter set to minus 1
and the real parameter defaulting to 0
so
think time for the water as an example
where keywords and keyword parameters
are useful as for example if you want to
deal with XML HTML type nodes where the
convention that this function make
element creates a node a element node
and the convention is that keyword
parameters become attributes so this has
8l returned Evalia step node through
element node whose tag is P with an ID
attribute value of p0 and the body as
the concatenation of the string some :
and whatever the value of the variable
sum is which you know visible clumsy so
cava actually has XML literal syntax
which looks like this which is basically
regular XML syntax but prefix this this
hash sign is a sort of a standard syntax
extension it's sort of it's used for a
number of little things to indicate what
depending on depending on what the
character is after the hash sign it can
mean all kinds of different things so
this is a carving extension that hash
less than is is an XML Metro and Harry
it's sort of okay value at this
expression and substituted and you can
have sort of evaluate the the tag name
could also be an expression that gets
evaluated in which case it could leave
out the final tag
so again a more important or or this is
perhaps a variation of general object
construction using name parameters
keyword parameters are useful for
basically object builders which I'm
gonna talk for a few slides here start
out with the case where you have a type
name usually a class name but it could
be something else basically a class name
a keyword a value expression kiva a
value expression so basically this
evaluates the value expressions and then
sets the name properties so these
keywords are seen to be property names
and this is general it doesn't need any
special magic it doesn't need any
special build or property or anything
this just works with the built in stuff
so for example it assumes it works as
long as the class has a default
constructor and and then for each key
word there is either a set method or an
ADD method that matches so so here for
example you have create a swing jbutton
with and then it calls set text using
this parameter and set tooltip text
using this parameter scheme and Lisp
traditionally hughes instead of
camelcase they use hyphens so so so cava
magically translates back and forth
between camel case and the - thing but
you can use whichever you prefer a
another variation of object construction
is sequences list arrays things that
have children which includes a
xml elements have children so in this
case you have the type name followed by
the list of children and this is
actually conventionally this a standard
scheme this is this particular form
vector is is a built-in function in
scheme it creates a new vector which is
basically the same as sort of like
aerialist with these parameters so kavik
kind of changes the meaning of this a
little bit in scheme vector is a
predefined function in carve a vector is
a type name which means you can also use
it as a type specifier in declarations
but you can also use it as a constructor
function basically if you have a type
name types of my little aside here type
names are can be evaluated at runtime
they're basically an expression that
returns either a class or something else
but basically let's just call it a class
so in this case this is an expression
that evaluates to Java util dub
ArrayList off class and then if you call
a class there's a there's a magic in
karma that says oh well you don't want
you can't call a class but let's call
the constructor instead or in this case
if it's a but there's also a little
extra magic if it's a list or sequence
or an array construct the sequence and
so so here we create another list and
add the elements it were it assumes
there is a default constructor and an
ADD method and then it just works
doesn't need any special magic this also
works magically it also works for native
Java arrays so here's the java.lang
integer array with three elements and
this is a little more magic ter say
array of array of ends so here's a
little context-dependent type this is a
special car by extension syntax it's
sort of like a it's sort of like the
vector constructor of four five it
creates a it creates an immutable vector
but it's context dependent so if the
compiler and oh I need an int array here
stead of creating a vector or an
ArrayList of whatever else it creates an
inter a and so this this becomes an int
array this becomes an inter right and
then the two together becomes a double
nested array sorry when does it how do
how does it know that the time name is a
container I I have to look back at the
code I think it is basically there's a
there's this complicated code there but
partly it is if it has a default method
and an ADD method that's all it needs
yes as long as you have an ADD method it
works for I'll show you an example later
where you have things like Java effects
scenes where you have nested sub sub
elements there's a little bit of custom
attic there but basically the general
thing as long as you have an ADD method
it will say oh okay if there's an ADD
method it knows these are children and
so just add them to the constructive
thing now there's a special you know
obviously arrays don't have add methods
but it but it's sort of special cases
those and the final part of the
constructor syntax is a regular
constructor so if you have a type name
these are treated as constructor
arguments so there's a little bit of ad
hoc URI it has to say you know it's this
are these constructor arguments or are
these children that get added just after
things get constructed and and you know
usually you know usually there's no
ambiguity oh but there's also ice
especially if there's no because if
there's no constructor then the compiler
or the runtime will look for a value off
method which allows you to basically use
the same syntax for factory methods and
I think it's actually kind of a good
principle of language design to try to
hide the difference between factory
methods and constructors because you
know they may change
sometimes you may want to cash something
and reuse a previously constructed
object and if you have if you have to
have a different syntax for new T rather
than T of you know using a factoring
method I think that makes your program
less flexible your language less
flexible so Cova tries to make that more
automatic yes let's get to the next
slide if there are ambiguities how do we
do it well first look at the here's the
general case the general case is you
have a class or type name you have
constructor arguments you have keyword
arguments and then you have child
arguments so the constructor arguments
are passed to the constructor function
the keyword arguments are used for
setters or add methods with with named
add methods and the child arguments are
used for children and so then it needs
to be an anonymous add method now what
happens if these if there are no keyword
arguments how can you tell whether their
constructor arguments or child arguments
in general it's complex dependent there
is a hack you can put in you can use a
null keyword which is documenting the
cover manual if you need to actually add
this and bigoted but it's it's pretty
rare that that's needed so water
breaking so this is like object builders
in groovy and other languages but the
key thing is it's fairly general there's
no special builder class needed in most
cases and just the compiler figures out
by heuristics and method names and says
okay this works and most of the time it
can do it at compile time it doesn't you
know so so it generates basically the
same code as if you'd program it by hand
a Java IDE generates very efficient
bytecode now there are class you know
there are cases where this general
heuristics don't aren't really what you
want there and they don't find the right
method
the right properties so there's a
there's their there is a hook for
overriding it and here's an example
where this hook is used I haven't talked
you know how to write the hook is is a
little black arch but it's relatively
simple code is just not documented so
here's how JavaFX has this has has has
these properties that various nodes have
that you can modify and you can set the
properties and add things and but you
have to go through an extra indirection
and there's extra builder tool stuff
like that and and which means this kind
of code isn't gonna work out of the box
for what cover won't be able to find the
right methods and figure out that these
are property names so there's there so
there's a little helper class you have
to include a macro which is which is
pre-written you know there's that in the
carver library has a has a special
module if you include that module it
enables the stuff to work and basically
that basically adds some extra special
compilation rules to say oh if I'm
trying to compile a Java fix button or
whatever then you know I need to go to
this extra step to get this to work and
as a in addition to the object
constructor here there's a few other
interesting things here first Java fix
scene is a macro that we've written in
that library module I mentioned which
creates a scene and a stage and puts
them all there so so basically this is a
complete program you you you you you you
put this in a file you load it and a
scene with a button and
and you can set the title of the window
so it comes up with a window and you can
set these properties and and you know
you don't need to do anything more you
can also set the this is the you can
also set event handlers by using lambda
methods and this uses the same
conversion that I mentioned earlier
ie there's a anonymous function but this
context requires an event handler so
we'll treat it as an event handler and
it'll compile to an event handler rather
than 2r to a function and a lot of these
things kind of a lot of these
constructive things will work within
interpreted or compiled text but there
are some subtle differences because
unfortunately you know the Java type
system you know method overloading and
stuff like that it's a little bit magic
it doesn't work quite the same if you
don't have the static types and so so so
that's an aside which is I think it's
kind of but if curious argument it
switch to a slightly different topic um
one of the key things about cava
modularity was is it's very simple and
that a source file is a module the unit
of privacy per private versus public is
a source file and that's very simple and
a module or sub-module it's a collection
of top-level definitions variables
functions classes macros can also be
top-level actions which are executed
when the module is loaded some subset of
the module top-level definitions make
the exported others are private and you
can import another module which
basically means the model gets loaded
and the mark did the exporter names from
that module get then imported into the
namespace of the current module but not
automatically they export it but you can
be exported if you explicitly great
sport yes okay so
so the other thing is such a module
basically compiles into a module class
so it'sit's this is obviously simplified
but basically you have an optional
module name declaration if you don't
specify it it it's inferred from the
name of the source file which then
generates a component similarly named
class file or class northern oh yeah
you can specify which top-level
definitions are exported in this case
only G is exported so you have a
function f at a function G and a
variable Val - which is not exported and
these compile into methods and function
and variables and there's a little bit
of magic and stuff like that but that's
the sort of very high level what what
goes on so by default such a module gets
compiled into a static module that is
everything is static but you can have
non static modules where whatever things
are instant modules instant variables
and that can be useful if you have like
for constant properties mod where
modules can be you know depending on
your context depending on your HTTP
session or whatever some things like
that
but basically they turn into statics is
the normal case of course yes of course
huh yeah this is this is this as a
simplified equivalent Java of the
generated by code but yes so one key
property of the module system which
which is sort of inherits from our six
scheme is that all of the exported
variables and definitions are read-only
and you you you know you can't export a
variable and then assign to it from some
other module I mean read only there only
there exported read only they can only
be assigned to within the module
this key property so to speak enables
it's very helpful for the compiler and
error checking and in general because
you know it and modularity safety you
know it's it's it seems a very good idea
which I got from you know our six game
it approves the dataflow analysis they
that town type and friends are checking
just having that now so of course you
can call a function which changes a
variable but you can't change it
directly a few more words looking close
to the end here but this gets into some
more heavy duty stuff unfortunately I
didn't really write any good examples
are variables in cows game and this is
an extension standard scheme is
completely dynamically typed or no type
specifiers cava has type specifiers you
can sort of you can say you know define
x colon colon integer whatever and that
says that X has to be an integer and do
that parameters and and and and local
variables and but key things that those
are optional you don't have to specify
the type specifies if you do it will you
know allow the compiler to generate
better code it allow the compiler to
catch errors at compile time or earlier
at runtime it's also you know if you
have a tie specifier it gets enforced at
runtime with some kind of cast sophia
even if it's even if the error is called
at run time it gets caught earlier which
means it's it's easier to debug so the
type the optional tie specifier is
compiled with combined with dataflow
analysis allows the compiler to generate
pretty efficient code as I showed in the
earlier slide and as I said they also by
the compiler catch a lot of errors early
which includes your productivity and
karma has a lot of warning said you can
switch on off and you can switch them on
and off local or you can sort us you can
bracket an expression which says turn
off this warning and this in this sub
expression or in this file so you can
then enforce and there's also switch to
say make all warnings to be errors so
you combine those two you can sort of
have your compiler catch a lot of errors
earlier you know I think that's it
that's it's it's always a good good mode
to compile with what warnings be forced
as errors but not everybody wants to do
that you back to your question about
what what happens a little bit a very
quick summary of the logic of the
compiler the first step is this the text
of the program is read into what are
called the s expression D D that the the
the the a list representation of the
parenthesis note notation basically so
the everything in the parenthesis
becomes a list and then it gets it to
this tree format which is the
traditional way scheme endless languages
into and then the next step which you
know and that happens for you know that
that means that's part of the data did I
have a slide for that but I also got
missing and to step back there's the
duality between every yes I don't have
it down a toilet sorry for that at some
point D you know what I rendered the
these these parenthesis expressions they
can also be data and and you can quote
an expression and then it becomes just a
list or you can evaluate a list and it
becomes an expression of which n gets
evaluated so there's this duality
between code and data is a signature
property of lisps family languages which
means you know basically a program is
sort of an interchange format so yeah
you get this so the first step is you
read the data the thing the program as
data and you get basically a data
representation
it and that's that's raw then you need
to actually start analyzing it and the
first step is you you do the lexical
name resolution you do the macro
expansion and a few things like that you
get that an internal cover format which
is an expression tree which is your
classical you know abstract class
expression and sub expression for if
expressions and lambda expressions and
stuff like that then there's a little
preliminary analysis which I'll go into
then the big phase is the data flow
analysis which also does a fair bit of
rewriting so it'll do constant folding
it will do simplification it'll it'll
keep track of say a little more button
on the next slide about that but that's
the big heavy one then we do get into
the low-level stuff we now have we now I
analyze the program now we need to say
okay we have these anonymous functions
these lambda expressions and they may
refer to variables that come from
elsewhere how we're going to translate
that into objects in classes and methods
so we do some analysis figuring out what
what local variables have to be
allocated in an object of a field in the
class similar to the way anonymous
classes in Java have the same issue how
do we do that
then finally we generate bytecode and
then the bytecode
either is written out to a file for
future use into a class file or we just
immediately evaluated if you have a read
eval print loop it just gets compiled to
an array and byte array and then the
class gets class loaded define class and
then you do this you know you call it an
appropriate method and evaluated the as
mentioned the most important and most
complicated pass in the compiler is the
data flow analysis pass and it was
complicated because there all these
dependencies everything depends on
everything else it also has to be done
at the same time and so so any you get
an approximation you know you can't you
know because you know is
if this is a constant that influences
something else if this function calls
that function and I belittle so it's but
it's basically it's a tree walker it
visits the expression and and and and
calculates properties the types of the
expression it also keeps track at every
points as it's visiting the tree what
were each local variable what
assignments or initializations may have
set that variable so it's it's it's a so
it knows that okay and so you can do
like constant folding for example you
can also say okay I know the type of
that because it was said in this
assignment and you can check for
uninitialized variables and a smarter
way than Java does there's also some
special hooks for certain known
functions like arithmetic the map
function which does sort of maps over a
lambda expression sort of kind of like a
funny kind of a loop it didn't they that
actually gets translated into a loop and
so there there can be hooks those
special functions which and rewrite the
tree into a different format or
simplified in various ways including
constant folding so so yeah this should
be basically some of this data flow
analysis is similar to the classic
single static analysis single static
assignments SSA analysis which is
traditional has become traditional in
compilers for languages like you know C
C++ it gets a little harder with when
you have functions first-class functions
where expressions can evaluate the
functions and and it gets even worse in
scheme because basically there's not a
no such thing as a loop per se basically
all loops are defined as tail calls or
tail recursion and there's also a fair
bit of analysis for figuring out when
tail calls can be implemented as loops
and when tail calls can be when
fractions get in line if you have
mutually recursive functions that call
each other with tail calls
the stacks gonna explode unless you have
tail call elimination and so covered us
this analysis to say oh these can all be
compiled into a single method and all of
the tail calls get compiled in to go to
go to statements basically and in it the
bytecode has go to the Java language
does not and so you know the analysis is
going to be approximate because you know
I try to do things linear time I only
try to analyze each piece of code once
and and so and so you know you're not
going to get perfect results but it does
pretty good most of it is actually
written in Java there the libraries and
built-in functions are written in kava
kava is actually I am Drella gone into
it but it's actually kind of a framework
there's actually multiple languages but
it supports their stay it also there is
an X query implementation xquery is this
language that the w3c did to process xml
basically do to search and analyze and
query xml and it's a very different
style of language and there's also and
it uses the same engine the same
compiler you know parses it builds the
same expression trees generates bytecode
so so for that reason plus that it
simplifies bootstrapping most of the
compiler is written in java but as I
said the easy and I'm sort of gradually
moving at least you know built-in
functions more I try to do as much of
the built-in functions as in in in in
Kaba but they did the court language the
compiler itself is pure Java
yes but you can't do it in every case
there's a there's a natural in our
analysis well the simple case the common
case when you have you know a function
calls itself in a tail call it's it's
easy to just okay I'm just gonna
implement that as a loop but it might
tell call some other function that it
doesn't know people come in you know if
I like delegation and and if this is why
some people say you know telco
eliminationism isn't necessary for
object-oriented programming if you're
going to be safe I have this method in
an object and I want to delegate it to
some other outreach which may delegate
it to some other object which
etc you know that's kind of potentially
blow up your stack or at least unless
these delegations can be implemented as
tail calls but you can't really do that
if you don't know what you're delegating
to so so what what Coward there is a
good job of tell color malaysian - you
know functions that call themselves in
in in a sort of group all in the same
module says ok virgin f cost function G
which calls F and H and they're all kind
of have these properties so I can all
compile them into one method and do go
choose but if you don't know what
function your tail calling you can't you
can't do that they're very other Oh
bonus Carbon has an option there's a
something called trampoline where you
can it has a compiler switch which says
I'll generate support full tail call
elimination and there's a trick where
you instead of you know if F calls G in
a telco position instead of calling G
directly what it does it's it remembers
G in a special context variable and then
returns immediately and then there's a
what's called a trampoline there's a
sort of an outer loop that says oh okay
I'm not done somebody asked me to call G
after I called F so I'm going to call G
next and so you can get the you can get
the tail calls executed without
expanding your stack
and the problem is it's a you know it's
ads overhead and it's you know the it's
not really compatible with the javis
stack so so your ID and your the bucket
well your debugger doesn't understand
what's going on so it would be really
nice if this was sort of built in into
the JVM but it has to be kind of built
into the JVM and it has to be built in
it's it's it's not an up it's not an
optimization it's something that's part
of the semantics if it's going to be
supported right
well it's desert said that's part of its
it's part of the semantics the tail call
elimination isn't enough to if you think
of as an optimization it's going to
change the properties of the program
because you know your stack is gonna be
different which which is going to change
the bargain it's going to change the
security model and stuff like that if
you say the tail call is defined as a
tail call to to sort of it get rid of
the stack then it's part of the
semantics and then so yeah and it's
basically a loop and it's it's it's it's
what it is I think I have one or two
more slides so let me finish that I
mentioned that part of the way cover
generates good code is that various
predefined functions they have various
custom hooks to optimize them for
example addition and there's two hooks
one there's a hook that's called at the
data flow rewrite time which was used
partly to simplifying partly to infer
type so you say okay if I plus J and I
know that I and J are integers then the
result is an integer there's also a
possible set of hooks for my code
generation time it was if say okay I'm
generating byte code for I plus J or you
know plus IJ and scheme's effects then
you know if I know these are integers
and specifically if I know if these are
32-bit integers that I can just generate
the job JVM I add instruction instead of
making a method call and our object
allocation etc so so a lot of these
built-in functions have custom hooks to
generate custom byte code and and you
could do do too and custom type
inference today and that's probably what
- I can generate good code and that's
the last that's the info slide so any
more questions and I think yeah we're
pretty good time wise
how do I print out what objects well
these are version was XML literals if
you print them out how did they get read
back in again or nor well they will
print out using the same syntax so they
are gonna be readable but there's a
there's it's a little bit of a issue
there in that what is the difference
between a a the things the literals that
are literal at read time as in red end
by the low-level scanner as opposed to
things that add value to whatever they
value to add evaluation time so yes not
ever not everything will be readable in
the same sense as but XML literal should
general work that they they will print
out as using the XML literal format and
so they can be read back in again
um that's the general problem with you
you can't the gel you know you make just
call a two string method if it has one
or there's a special interfacing they
call sometimes you will get objects you
know if it's a random java object you
know if you print out a java big swing J
button well it's gonna just call the two
string method up to taper them you can't
read it back in again you know in
general you know it's not going to be a
perfect serialization format
the the well it's it's there there's a
defiant there's comments actually two
two two two methods two forms there's
defined simple class which generates a
single class
there's also defined class which
supports multiple inheritance and that
it works by basically compiling a kava
class into both an interface and a class
and so the the class contains the you
know the each of the methods that are
you know not abstract get compiled into
a static method in the in the in the
class class and then you know if
subclasses will they will have to sort
of generate stub functions that then
call these static methods as necessary
same with the fields and properties they
are basically compiled in the interface
gets getter and setter methods and then
a class it has each each subclass has to
sort of automatically generate the
setter and getter methods that that is
to set the properties to confusing yeah
in the back
uh-huh okay the there's a bunch of
research projects that people have done
to implement continuations to intend to
implement full tail calls another
interesting one is structures or tuples
none of these are in any imminent danger
of being shipped or being integrated in
any thing the there is no there is no
what did whatever continuation support
there is in the da vinci machine or
whatever or the kitchen sink language as
some people call you know our highly
experimental and there are no plans to
turn them into a standard part of jdk
unfortunately and that's because of you
know and some of these things are
clearly you know everybody agrees that
you know john burroughs
everybody agrees it'd be really nice if
we have proper telco support it'd be
nice if we had really support for
efficient tuples or structures and so
somebody makes a prototype
implementation but that's only a small
fraction of the work needed to actually
get in shift you know because you have
to standardize it there's all the
politics that's obsessive occation the
test cases the TCK it's it's a and and
and you know you know we you know a
couple of years ago we got invoke
dynamic and they're and they're working
on improving that and maybe in a couple
of years we'll get tail calls that you
know don't hold your breath you know
because the people who can do the work
in terms of actually you know employees
you can actually you know make it more
than just a masters you know it's a
master's research project is one thing
but something that can be part of of a
specified product is
harder yes yes yes I vote yes they're
there so there's there's something in
the men held about how to do that
there's a couple of different ways of
doing it you know there's the usual
problem with with the the but yes you
have to specify specify the interpreter
explicitly or you have to do some other
magic but there's the the basically the
kaabah command line you say carve on
it'll by default it comes up with the
read about print but you can also say
cover food out scheme and it'll load it
no it's part-time and I'm trying to try
to cut down my and so it's sort of
depending on what my day job is
depending on whether I you know you know
I taken you know there was a few years
where I was working as a contractor
working on cava and I actually did
manage to get enough money to support
myself right now it's been difficult so
for that and other personal reasons I'm
trying to cut down to maybe working
halftime midoriko they've helped
hopefully hopefully then I'll have more
time on camera because I have the I have
this queue of things I want to finish
and well are features that I want to add
and think documentation I want to prove
the website is not sexy you know for
example you know it's trying to you know
trying to get people to use it this
really leads more PR which I don't have
time for you
oh that's the whole slaw is the whole
talk unfortunately but I can show you
the the this is the this is the numbers
unfortunately I didn't these are like
the I prefer these numbers for Java one
two years ago so so so I think they may
be a little bit of a lie I I kind of I
tried to update them but like that kind
of got over one with personal things but
basically these times are relative to
Java Runtime and you know this comma is
a lot faster than they really are
closure it's comparable to Scala
basically and and that the talk is that
partly explain how and why okay now what
sorry
well it's I've done a little bit of work
there I have lazy evaluation and futures
and promises and and and sort of and
something I want to work more on but it
it doesn't you know it doesn't hinder
the threading model but it doesn't have
a lot built in except for it does have
some you know syntax for futures and and
promises which give you sort of
automatic synchronization so there's a
little bit there but not as much as I'd
like if there any more questions just
talk to me personally I think we're kind
of over our time too and technically so
or talk to me while I unpack</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>