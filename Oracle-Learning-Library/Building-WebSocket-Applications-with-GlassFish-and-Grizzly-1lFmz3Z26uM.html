<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Building WebSocket Applications with GlassFish and Grizzly | Coder Coacher - Coaching Coders</title><meta content="Building WebSocket Applications with GlassFish and Grizzly - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Building WebSocket Applications with GlassFish and Grizzly</b></h2><h5 class="post__date">2013-01-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1lFmz3Z26uM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this is building WebSocket applications
with grizzly and GlassFish everybody
hear me on the back okay good
it's only a small room okay thanks I say
thanks for coming after their party for
two hours of class efficient grizzly I
wonder how many of you will bail before
the end of the two hours so I'll
basically go through who am i first
okay so I'm a fake basically a field
consultant so we're a company that does
middleware Aranea round large-scale
systems and we do it across the board on
many different vendors so the reason I'm
putting this up is basically I'm I'm not
WebSockets specialist
I'm not grassfish specialist for what
what I'm aware of at the moment is what
our customers are looking at with
WebSockets and this sort of talk is
around some a very very cut-down version
of some POCs that we've done around
WebSockets mainly for gaming and finance
companies mainly just experimenting with
the technologies and seeing if they work
for their use cases so that that's me so
I'm not here to sell anything I'm not
here to say this is awesome and so if
anyone wants to ask you know while we go
through this just ask questions that's
fine as we go along it's got two hours
of me talking so the agenda we're gonna
do is I'm gonna do a very short
introduction to WebSockets and push a
little look at the API is the web
sockets in GlassFish and this is
GlassFish three dot one dot two dot X
whatever we up to now so it's one that
you can download now and use in
production so it's not j5 throat's je7
WebSockets API as I only came out in
September
a bit late for me we're gonna look
through a code walkthrough on a basic
eco server so sending a message on a
WebSocket getting it back put it in
JavaScript and when we're doing the code
are the chances of you getting this
right are probably nil so I really do
need someone to people to watch and
shout out if I type something wrong
because it's it's gonna happen you know
what it's like in pair programming well
this is like 10 times more so there will
be mistakes there will be stacked races
I'm sure about it so we'll look at basic
echo server now echo is not very
interesting because HTTP Ajax can can do
that so well then look at expanding that
actually a slight slightly wrong look at
extent expanding that to then push some
messages down there it's going to be a
contrived use case we'll use we'll just
spawn a thread and start pushing data
down to the standard WebSocket to the
browser and render that but it
demonstrates how how that works and then
this is boil getting into the use cases
we've been discussing with customers so
we're going to look at how you could
maybe use a datagrid product in this
case would be using oracle coherence but
no no other reason that i know it and
look up how we could cook hook up
WebSockets to a data grid through
GlassFish and then push updates that are
occurring on the grid down to a browser
and hopefully we'll get to the point
where we have a html5 canvas graph
updating based on some stock prices if
we get to the end and my voice holds out
and then then we have a summary ok so
like say ask questions as we go along
and help me out with the code ok
I have no idea what this will take two
hours or 1 hours or 3 hours even so you
practice but who knows ok so let's look
at HTTP this is standard HTTP model as
you all we'll know it's a request
response protocol browser sends a get
request to a to your I for a resource
typically that request will have about a
kilobyte of overhead on HTTP headers and
then web server goes away it finds the
URI reads it and sends it down as a
server responds again there's a bit of
overhead on that in that you have
response headers as well except cookie
and then the browser displays the page
so the problems with that is is
essentially it's a request response
protocol as we've all known for a long
time and it's half duplex and what that
means is you can only send traffic in
one direction at any point in time so
you're either getting or you're
receiving data and because it's
originally designed about it whether it
is a stateless protocol there's a lot of
redundant data on that so I said it
tends to be around a kilobyte of headers
depending on what you've got so you'll
have all the headers were for cookies
headers for what content types you
accept headers for just general you know
content length not and whether you
encode zip encoding and all that those
sort of things and they all build up and
that data is redundant in a in a push
model because it's sent every request
and it's received and every request and
it's often the case that you need a new
connection keepalive helps a little bit
but essentially that connection can be
torn down
so it look a little about push no pushes
to give me reason people do positive
push technology is to have a more
responsive user interface so you don't
have to render the whole page for for
each request so you don't do a get get
the whole page and render it for the
user interface you want small pieces of
data to give an interactive experience
and does anyone here use push different
types of push once they push
technologies cuts company but push
techniques so so which ones you use long
polling ok so we look at how people do
push now and this is linking with Ajax
so you you want to get updates from a
server in essentially is in real time
without having to request them ideally
so these are techniques that people use
now so you have regular polling so this
is you send a request set in to pull an
HTTP request from a from the browser for
JavaScript that works so you send a
request the server hasn't got any
response for you say any any event that
you're interested in then you come back
with a error or whatever depend on what
you protocol you've designed is but then
two events may occur between your
polling interval and you send another
request response and you rather get both
of those or you get in one of those
depending on how you've written your
application and this is quite expensive
obviously from both a service
perspective and the client perspective
and that you have to manage why is this
polling so the alternative is to do long
polling this is essentially where Eraser
do HTTP request and the server hangs on
to that request until there is an event
and then it sends the data back down for
the response
and so essentially of sending so you're
requesting thread in the browsers held
up while waiting and worst case in early
days the server often had a thread open
waiting until there was an event that it
could send down to the browser so it's
quite expensive on the server and
they're obviously ways to mitigate that
with asynchronous servlets and those
sort of techniques but they're all
they're all a bit of a hack at the end
of the day so so this can be very
resource heavy on the server and and the
sort of customers we're talking about a
customers that have essentially doing
online gaming so they have hundreds of
thousands of users potentially connected
so these sort of techniques are very
expensive for them and bandwidth is
expensive the other option is to go into
HTTP streaming so this is where we
basically open a HTTP connection or
ex-maid XML HTTP request and you hold
that open and get multiple responses
sent down from the server so again the
server is holding the response open and
can send multiple data never actually
closes a response
again this is expensive both on the
server side and client side and it's not
very friendly to proxies and it has a
tendency for the proxy to tear these
things down and which case you have to
reconnect and go back to long polling
okay and then obviously we get comment
which is essentially just relieving some
of the pressure on the server side to
allow asynchronous servers it is quite
complicated to develop and it's not is
it I mean this is what they do use now
but it is very expensive for them the
way a lot of these in sort of gaming
companies work is they tend to do a lot
of syndication as well so you get all
these aggregation websites what when we
talk about gaming is probably not as
familiar in the u.s. it's in Europe is
it's things like in Play betting on
sport so what their use case is updating
odds on who's about to score or get the
next point in them in a game and those
need to be updated in real time or as
real time as possible because when the
client comes back to place a bet on
order then those odds may have changed
and they may not do it so they lose that
that that order a stake and also it's a
very complicated market and there are
many many aggregators that are
aggregating odds and prices from many
many gaming companies and they all using
reverse Ajax onto their servers to pull
pull so it is there their server farms
are very very loaded from these sort
techniques if you think of an HTTP
header is about K in size if you then
scale that up into hundreds or thousands
of concurrent connections then that's
that's a lot of wasted bandwidth these
places tend to be in strange offshore
locations for tax reasons which tend to
have expensive bandwidth and tempted in
the market tend to be fairly sewn up
so so the future really going forward is
WebSockets is anyone using WebSockets
okay why are you in this talk
territorial sorry yeah
so WebSockets is new to html5 and but
it's it's a combination of both a
protocol through our C process and w3c
spec for the JavaScript well what
WebSockets does is it gives you an it
gives you a full duplex connection
between sck browser in a server so
you're basically opening a socket and
that's socket again browser can send and
server can send simultaneously over the
socket so in that case it's better than
a long polling in the sense that the
it's just one single dedicated socket
between the back-end WebSocket server
and the browser so this is this area
it's a the reason that clients are
looking at this and proof of concept is
it this stuff is in flux really I'm no
way am I telling you this is mature
technology this is not mature technology
and most of the application servers have
only just started started supporting
WebSockets prior to that you would have
had to get a proprietary well not
proprietary but a specialist company to
give you a WebSocket server but the
protocol is defined by RFC six four five
five so it is now a standard that is
ratified or whatever the word is and the
JavaScript API is defined by w3c web
sockets spec so now is probably the time
to experiment but not necessarily the
time to roll out into production
okay sse sneaked onto the slider and so
i'm not talking about it anywhere else
for SSC is over HTTP so it's still an
HTTP protocol and it's server sent
events so it's events sent down from the
server to the browser over HTTP yeah i
don't know the details of it i must
admit
I don't know what the future will be as
I'm not on the Sanders bodies so sorry I
don't know have no one unique insight
into that so the question was whether
speedy will take over WebSockets
and I don't know WebSockets is here now
okay so WebSocket browser support is now
in most of the major browsers so we have
Chrome Internet Explorer Firefox Opera
and Safari and its benefits over a long
pole and etc as we've discussed really
so you get reduced latency and that
there's no gap the server can send data
as soon as it receives it there's a
there's a large reduced network traffic
because you've no there's none of the
HTTP negotiation overhead it's just a
sort of nominal framing in the protocol
so there's some some bytes overhead for
each message but it's quite small so
this can must have reduce the CPU and
memory on the server side and actually
as we hopefully will see it's quite
simple to develop for okay so this so
WebSocket builds on top of HTTP in the
sense the initial connection is over an
88 DP connection so the client will
basically send a get request to a URL it
will also provide a host so there's
location-based security can be used they
also provide a connection header which
has upgrade and it will then send three
or more specific WebSocket headers these
are centrist first one is the key which
is a hash of a certain u gooood plus a
nonce and that gets sent over to the
server and then can say what's protocol
that the client wants to support or not
and these protocols are fairly opaque
strings although they can be registered
and it says what version of WebSockets
is using
an in response the server must response
sent back hair 101 switching header say
let's upgrade into WebSockets then also
sends actually as it should be a
carriage return there a WebSocket except
which is a hash of the nonce and a
gooood and says that which protocol is
going to support out the two that was
requested here so that requested chat
and super chat and this service says
it's going to use chat over the over the
WebSocket and these securities security
headers in quotes are really a light
wave form of security as these headers
aren't available to JavaScript clients
so you can't set one of these headers in
a JavaScript silent client as an eight
as an XML HTTP request so you try it
it's to stop some sort of levels of
spoofing it's actually there for a
complicated reason to stop proxy
poisoning so but it doesn't prevent
obviously a row client written not
written in on JavaScript on a browser to
send whatever it likes okay so this is
quoting from the RFC so essentially
WebSockets just a layer on top of TCP
it's web-based origin security so we
send a location and then the server can
then that location will be sent by the
browser obviously rather than they the
JavaScript which which is the location
where the JavaScript was loaded from and
then the server can decide whether or
not to accept adds the dressing protocol
which is obviously your eyes and the
level of which protocols are supportive
and then it has a lightweight framing on
top of TCP which is essentially
splitting messages up into certain
chunks and having a certain frames of
certain types which you won't go into a
detail with it and do ping and pong to
look for so lightweight keep alive
and it can have additional closing
handshake so the client can request a
close and it is designed to work in the
presence of proxies but it's not at the
moment
guarantee that it will it may or may not
the safest way to get it to works with
proxy is to do it over TLS because you
can do WebSockets over TLS and then
proxy will obviously the TLS is fairly
opaque to the proxy so the security
channel tends to work much better than
plain WebSockets okay so the JavaScript
API in oh sorry
support people
in the same ways that HTTP does because
the initial opening is an HTTP GET so it
could have a host for that so you can
use virtual hosting on top of it okay so
the web socket API is pretty simple in
JavaScript it's setting w3c standard oh
not quite yet because it is tl5 not out
but essentially there are there are a
constructor for a WebSocket which takes
a location which is obviously a URL and
a protocol which is a string they want
to send to the server to say which
protocol you'd like to use on the web
sockets socket there are then for
callback functions that you attach on to
the WebSocket object so you have on
message which gets called when a message
is received from the server on open
which is a callback when the stock is
opened and negotiation has been
completed closed obviously if you want
you skew or the service decides to close
the socket and negotiation of close is
complete then you get a non closed
message and then on error if so there's
a disconnect or something so if it goes
away and then you can two methods you
can call from JavaScript which is close
it is to shut down the WebSocket and
send which is some data and there's
actually another there's a couple of
sends ones for plain text ones for byte
byte arrays so this is actually the w3c
definition straight out of the spec so
there's a couple more attributes as well
which is ready state and buffered amount
and ready state just allows you to query
what state the sockets in whether it's
connecting open or closed it's not a
huge amount of life cycle stages
so we'll quickly look into web sockets
and GlassFish any questions on that we
all get into the code on it just puts up
context okay so this is what we're gonna
do is use GlassFish three point one
point two so it is production quality
class fish it's using grizzly one nine
so it's quite old grizzly but the API
even grizzly hasn't changed drastically
than two diets but we're not looking to
use the GAE six seven 677 API as
progressive always a little late for
this but this does work now in
production so so the first thing you
come across when you get GlassFish three
is that you actually have to enable web
sockets support so that will confuse the
hell out of you if you go away and do
these tutorials and without doing that
first because none of it's gonna work
and there's a long long dot list of
things for that but that's where you
need to set WebSocket enabled equals
true you can go navigate down the admin
console to serve a concrete network
config love la okay there's only three
key classes now we'll see in grizzly for
web sockets as a web socket engine which
is a singleton a web socket application
which will see what we were right and
then there's the web socket class itself
which is derived from essentially which
will again we'll see which implements
your own protocol over the socket
okay and so one of the key things about
WebSockets is that it is your protocol
it is raw it's not HTTP over this socket
you can send and receive whatever you
and the server I want to negotiate and
send so you could write JMS clients you
could write SMTP clients whatever you
like you can send and receive any type
of data okay so I'll quickly walk
through what I'm gonna do so like you
can keep track so we're gonna basically
write a simple application that sends
them exit message back but it received
from a browser so we're gonna this is
the grizzly class we're going to write
an echo servlet and an echo application
and the echo servlet is essentially
going to create a new WebSocket
application which will be echo
application which will extend WebSocket
application and in our in it and destroy
methods we're essentially going to
register our application of the grizzlys
WebSocket engine and then in grizzly the
way it works is your your application
has to decide whether it the request
that's Rizla's received is one your
application is interested in okay so in
this case what we're gonna do is check
that the request URI ends with slash
echo and then we return true to say that
this is for us so grizzly essentially
will iterate through every registered
WebSocket application when it gets a
WebSocket request and asks them whether
they want to handle it but essentially
and then we will override on message in
our echo application so basic to send
back the string that we received okay
and then we will put together a JSP we
should have three buttons on it connects
and disconnect connect will create a
WebSocket send will send some data and
on message which is the callback from
the API that will write the data that
you got back to the screen okay see if
we can get it to work
so I'll basically create a new project
so be a web application and call it echo
project or j6 GlassFish server don't
need any of those things
okay so I've got a new project I'm gonna
keep track on a bit paper otherwise I'll
get lost
we'll add grizzly libraries this is only
really for the IDE because they come
with a class efficient anyway
okay so we don't create a new servlet
let's call it a servlet
the package is gonna complain
okay and what were they a cursor that's
going to do is we want it to register
our Co application which will create in
a second when it when it starts
so we basically set this servlet to load
on startup so that wait so with that
initial get called get rid of all this
junk and I'll go back and create an echo
application it's just a basic Java class
we're in the right project that
okay and this is going to extend
WebSocket application
and first thing we're gonna do is is
we're gonna override that is application
request which tells us which basically
Grizzly's going to call when it gets a
WebSocket connection and will ask us
whether we want to handle that
connection so
where is it
I can't see it
go to my snippet snacks I give up
I got to go back the one that works
because I car in the wizened okay so
that's what you want to overwrite why it
didn't let me do it I don't know
okay so this this is gonna get cold by
grizzly so basically checking the
request of your eye to see if it ends
with a cow it's a bit bit of a hack
really but that allows us to tell
grizzly that's a request we're
interested in and then we're going to
basically override on message seeing see
there's actually two on message methods
because from JavaScript you can either
send a string or you can send bytes so
we're gonna override the string or
message and in that we're basically
going to send the text back
so
what we're doing back up back servlet
what we want to do is override and eat
and destroy so that we can register that
application with grizzly
and as I car remember it
okay so in the set initializer because
we've added a load on startup the
servlet will get started as soon as the
server soon as it's deployed and when it
deploys it will register the application
with the WebSocket engine of grizzly and
then similarly when we're destroyed we
want to unregister ourselves otherwise
bad things happen as WebSocket engines
are single to not keep a handle on that
application we just created and it'll
confuse you when you do redeploys
because the code won't change because
it's got the old application registered
okay so will now create a JSP
old echo and this is going to do our
WebSockets calls so first thing I'm
gonna do is I'm actually create a div
just this is going to be a div where we
all dump the output in the that we
received from the server using
javascript we're going to add three
buttons but I'm gonna cut and paste
these because it's quicker so we'll
create three buttons in our JSP on
clique which is going to call a function
connect which we haven't written yet do
send which is going to send a test
message and disconnect which is going to
disconnect so
we'll start writing those
because it's not very good at job first
thing I'm gonna do is put some just it
Traci the websockets going to want a URI
the your eye is gonna be built up in
JavaScript from the location host that
the received and paid requests and bitch
the reason this is a JSP so we can get
the page context that it's deployed to
under in the in GlassFish that make
sense so if you write the connect
function here which I will pinch again
so obviously connect will take that URI
the uri starts with WS which tells the
GlassFish that this is a WebSockets
connection we this is a JavaScript API
you create a new WebSocket give it a
connection we don't have to give it a
protocol if you don't want to and then
the WebSocket these are the four
callback functions and we're going to
associate these with some functions we
haven't written yet which will be on
open on closed on message and on error
if we then write these next one so if we
take do send
okay will you disconnect first
so disconnect button will will hook up
to disconnect JavaScript function and
that's just going to call WebSocket
clothes and we'll try to write the do
send function or I'll cut and paste the
do send function I can't write
JavaScript to save my life so this is
why I'm doing this
that was server-side guy so do send will
take a message which will be test
message right to screen which we have
written and it'll send it down the
WebSocket okay when we press the send
button
okay and the right screen function is
obviously just a basic bit of JavaScript
it's going to use the div that we wrote
the beginning and just append to the in
HTML the message that we get from the
server or any any message so when we
created the WebSocket we gave it for
callback functions so these are on open
on clothes on message and on error okay
the first three they all these are going
to do is write to the screen so that we
can see when we get callbacks
okay and finally if we look at our on
message function this is the message
that the old message is the function
that will get called when the WebSocket
is receives a message from the server
okay and we need to close our script
any questions on that yeah
sorry
yes
so the question is is WS standardized
yes it's part of the RFC the IETF RFC
okay any any questions yep
okay there's a what you send your
receivers up to you and center that
level of protocol there's a lower level
framing which tells so breaks whatever
you send as JavaScript into a bunch of
chunks and the server then can
reconstruct those into a single message
yeah there's there's op codes and it
says if it's very lightweight so okay
again so this is a servlet
it's got load on startup equals one the
way it's interacting is it's only really
a hook into GlassFish essentially so
when it when it boots the servlet then
at that point it registers our WebSocket
application with a web grizzly WebSocket
engine it's only there to give the
effect of your startup class now you
don't need any of the other servlet your
you know serve up functions you don't
need to override the process or do get
or anything like that - thank you
lovely doesn't match your WebSocket one
because that would be bad but no didn't
really matter okay let's know it's not
actually so I'll go back to that the JSP
is not hitting the echo servlet at all
the echo server so only there to hook in
the WebSocket application into the
grizzly engine so if you look at your
eyes gonna call it the hostname slash
the web app context but not the servlet
slash echo and then echo application so
as it's a WS grizzly we'll pick the WS
and go through all the applications and
ask them if they want to take this
connection and echo application here
checks there's got slash echo on the end
and then says yes I'll take that no
question yep
yeah you can do WSS as a URL but you
it's not it's not quite the same
connection because it'll you can do it
over HTTP can do the get over HTTP but
if when the browser comes back is
obviously the JavaScript that's
initiating the connection back and you
can use WSS and connect over TLS so to
do is ssl connection essentially okay so
let's see if this actually works
which is the challenge okay
no instead I've written anything wrong
yet so
mine's already done yeah well might be a
bit boring to navigate through but yeah
yeah you do have to do that otherwise it
won't work okay so if we run this moment
of truth so glass official boot
maybe
so you can see it's three one two and
it's grizzly one nine four six so it's
not patched or anything
it's grizzly that comes with grasps we
want to
I don't want admin console
Oh No where the hell I didn't take the
helloworld out okay they must know
something okay so we have our three
buttons if a connect about nothing
happened
okay we get connected which has come
back from the server on the on connect
if you use go back to the JSP our on
open sorry callback it was put connected
and then if I send we get a response
test message all right we PD and that
came from the on message there okay so
that it's and if you disconnect we get
disconnected sent on our on clothes and
at that point I can't send any more
messages or I could connect again and
then send messages get a response okay
sorry say that again
who don't know never done it it's wanted
to try go off piste okay
network
to resent it get got one-on-one
switching back all this right off piece
now so
so if since end it's odd because they
have the ill be opaque to it isn't it
because it's a web socket socket
oh right okay sorry does that do
anything
sorry do get
I can't see anything in the WebSockets
thing that's a click where
yeah
right
let me get there
but okay right oh you learned something
that's why you come to Java one okay so
if we do that was the original one I
suppose if you disconnect it's not
updating maybe it's that one don't know
in them
you know I was not telling me anything
salt works
maybe maybe
oh if I keep hitting it will it keep
connecting back to server don't know
yeah Grizzlies Network layer inside
cross fish so it's a network a network
library
I think so
maybe not
it's broken it Hey it's all gonna be
wrong okay
why do 1d was refreshed
she's broken glass fish is broken
that's what happens if you hit send
connect
let's say don't use the in production
well I mean you probably wouldn't have a
button on there that said connect with
you
yes
I wasn't why what's gonna show is if I
take out GlassFish that we should get
disconnected sentence
okay so that's so that's it essentially
we've written our first WebSocket
application it is pretty trivial to be
fair but don't let people hit connect
all the time so what I'm going to do is
extend the application I mean in a very
very trivial way as it's a two hour
tutorial to actually push data to the
browser as opposed to us because sending
echo is not very interesting because you
can do that in HTTP and with XML HTTP so
what we gonna do is we're gonna take
this echo servlet an echo application
adding an app actually create a
WebSocket and if you know to the
previous one we didn't bother creating a
derived WebSocket we just let
application handle but the Royal
WebSocket the protocol I'm not sure why
grizzly allows you to do that but what
we're gonna do is create a derived
WebSocket class called push socket let's
write take you through this again go
we've seen that that's what echoes it so
we take the same echo server that we
have before the same application but
instead of having our message on it what
we're gonna do is create a WebSocket
when we get connected we'll have
override create web socket and we're
gonna return one of our own derived
classes for a WebSocket thanks oops
Pasha socket and what that class is
going to do is it's gonna override on
clothes so it gets the same callback
methods essentially as on the client
would get on clothes on connect and
during our connect essentially was going
to create a thread which is obviously a
bad thing to do don't do this read for
real and in our thread we're going to
run and just send an integer down to the
browser okay
and I JSP will be exactly the same as it
was before except I'll remove the send
button
okay so let's eat that works
first I will clothes or documents
I will start my GlassFish server and I
want to clean it before I do anything so
I'm going to undo ploy the current app
otherwise bad things happen
okay
so in the same project but I will do is
I will create a new class which will be
push socket
and this will extend what we extend
why is that i working
yeah that's why about another class name
sorry people display
so the class space in the grizzly
package called default web socket so
that will override a bunch of the
standard callbacks to do nothing just an
adapter
should also make this in a you know
really bad way implement runnable
I will override firstly all over I on
connect to these of essentially all the
callbacks that you get from the
WebSocket spec and that code is actually
going to create a thread so
once again it's not recommended it works
for demo
you're gonna add a variable called run
which really work but and then I'm gonna
write the run method but it's long so
okay and so this is basically just gonna
be a really naphtha of doing push okay
so this thread when we create this
socket in the read method of run method
so when we connect we will create a new
thread and that thread is just going to
go in an infinite loop and check whether
if run bear variable down here is true
and it's still connected and then sleep
4,000 milliseconds and then send that
send is the WebSockets end call so we'll
send to string of an integer down to the
browser we got some logging
okay I shall so override on clothes or
clothes
for clues
I said run false ah didn't do that
so that hopefully would stop the thread
Yeah right I do
that what it got me I thought I just did
that was wrong right and I need a
constructor
which I shall steal from one that works
okay so have I got any arrows there okay
so this is basically a class extends
from WebSocket and this is where you can
write your own protocol essentially
between the browser and the and this
class so it has all very go back to this
although I'm going to do this
you can see that the methods WebSocket
has all the standard sort of methods
that map to the website ik socket JSP
sorry
javascript calls so you got caused on
message calls ping these are the date
frames that get sent
and send so you can basically in this
classes where you would generate your
own protocol that you wanted to talk to
the JavaScript client through in this
case it's not going to handle any
messages from the JavaScript is just
going to push periodically integers down
the socket okay so when I switch back to
my echo application what I'm going to do
is as our sockets going to handle that
I'm going to override that
and then I'm going to basically override
the default implementation of create
WebSocket
and in this I'm going to return our
derived class of WebSocket
okay sorry
okay
okay so that's the best so while I've
done now that's all I need to do on that
application so what I've done is
essentially created a new protocol
hooked it into the original echo
application class we had so that when a
WebSocket request comes in for this
application it creates a new handler
essentially for the protocol called push
socket and returns that back to grizzly
and then that's all we need to do to
hook it all up essentially so if we go
back to our original JSP the only thing
I really need to do don't really need to
do anything but know we'll just run it
okay so that's back to our original day
SP if I hate Connect hopefully you'll
see that now that's getting the numbers
pushed down to it so these are
essentially pushing integers down to the
browser okay so there's no messing
around in comic libraries or anything
like that that's just straight simple
JavaScript simple server-side
programming and actually the overhead of
this is just a little bit of framing and
an integer string going down that socket
connection I think my thread handling
really poor actually so disconnect
doesn't actually work trick cap call me
out
yeah
yeah
maybe I was out there this morning
trying to think why doesn't it work that
bit but never mind
I didn't have time you see that way you
know glass which is spitting out that
we're sending data and this is
incrementing the Refresh it will start
from beginning oh no one actually I
think I'd will there we go that's just
GlassFish me complaining I'm trying to
write to WebSocket as closed
okay so that's you know very trivial but
that's hopefully trivial and showing you
that you can actually write these things
pretty pretty easily there's some
obviously like any any distributed
computing there's a lot of messing
around on connect and reconnect and
handling those side of things so what
we're gonna do for the final bit and we
probably finish early I apologize is
we're going to look at hooking this up
to a data grid Desalle gonna be a little
bit about data grids themselves and this
is where sorry question yeah browser i
refresh the page so we got a legal state
exception when I scratch send data down
socket okay so we're gonna look at
hooking this up then we'll go to the
buff Tuesday by update grids and things
okay so we're basically what kind of
code for that and how that works
essentially so so most data grids
essentially implement J cache so we're
talking about in-memory caching
essentially distributed cache so the
implement is our 107 which is coming je7
and essentially we're gonna be using
here n't and that provides a set of map
semantics for putting and getting data
out of a distributed cache jason and the
way these work is sent boy we have is
you have for JVMs they have a cache
within them keep or data in the cache
and the object is put somewhere else as
a backup in another node and these sort
of technologies are of interest with the
customers that we've been messing around
with pocs for because our these are very
fast this is fast later if you like
and fast in memory data across many many
gigabytes but if at any 4-node crashes
is resilient because it will just creep
another backup somewhere else and this
is just a lot of context so typical data
grid right we'd be looking at some of
our customers is of this sort of size so
you're talking 21 node grid with around
4 gigabytes of heap in each one if you
had 4 duplicates then you talked about
42 gigs of data and memory is what they
tend to tend to look at and this is can
be finance can be stocks can be gaming
information about who's on what gaming
tables essentially is a memory book the
bit where we're interested in is most of
these products have an event subsystem
and the event subsystem is where you
apply a cache listener on to the grid
where that listener will be look will be
essentially interested in a subset of
the data and whether it changes are not
okay so that when data enters the grid
the grid itself the grid product will
tell the cache listener that something's
happened and that catalyst newark can
then do whatever it wants to do which in
our case will be to send data down a
WebSocket okay so we're building this on
coherence but you know because I know it
and then must what a lot the finance and
gaming companies use but here it has a
couple of classes called has a map
listener which receives map L events and
essentially each time data changes here
as hereit's raises the map event and
calls your listener and you will
override a couple of methods so entry
updated will see this in the code entry
inserted and you do whatever you want to
do when you receive those events but the
key thing is is that these listeners can
have filters associated with them so if
you're interested in a very small subset
of the data that's in the grid you can
set filter and you only get events on
that filter so for example if a user you
know connect
interested in a certain number of stock
symbols than you can accept filter just
for those symbols and you'll only
receive events on those symbols the jsr
107 has a subset this API to register
cash cash entry listeners and they're
fired again onyx when it's expired from
the cash when it's removed when it's
updated or when it's read so what we
gonna build
we've got rogue arrow there so we're
gonna have a glassfish and it's gonna
have an embedded coherence simply
because that's simplest thing to do in a
demo and then we're gonna run a command
line application and that's also gonna
be a full clearance grid member just to
call it's the simplest thing to do in a
demo but in let's see in the next slide
that's not what you do in reality and
basically this this application is this
stock ticker apps going to place gonna
place objects into the cache actually
just going to update one stock in the
cache the random number and when that
occurs we'll have a castle cache cache
listener on GlassFish so an event will
happen now go to GlassFish and then what
we'll do
in that cache in our event listeners
will push basically stock price down
down through WebSockets to the browser
okay so in reality the sort of
architectures we're looking at in PLC's
is we have obviously something much
bigger than that we have a cluster of je
nodes WebLogic GlassFish whatever and
then we typically would have a remote
grid and these remote grid would hold
data that's of interest to the users on
here and obviously when these users
browse the website we set up as we'll
see in the code cache listeners for the
data that is of interest to them on that
specific page okay then as data gets put
in from any other node then events get
fired to that cache listener that's been
set up specific for that browser and for
that user and then those events will go
down through WebSockets and push and
update the browser's user interface
what
in this demo is going to be Oracle
coherent is that without think what you
mean there's hazel cast or in finish
span that or Bella tube main open source
ones I was gem fire Giga spaces supreme
scale it's quite a lot they're all very
very similar though in this all tend to
just you know copy each other's features
five camels
thank you
set a filter where
it depends on the product incoherence
you can build up like a criteria API as
a filter and push that so it can be very
fine-grained some of them is just at the
key level so I'm interested in this key
or the set of keys but it dad that is a
product specific thing
okay so these are the this is the code
we're gonna write actually all this
gonna be pre-built if I hook here it's
into it because you'll have seen the
other bits but essentially will have a
WebSocket engine as you that's the clock
grizzly class will create a stock
servlet to initiate the stock
application and that in its initializer
the stock application is going to create
a stock socket when it gets a WebSocket
connection and that socket is going to
establish a listener with a named cash
which is a coherent class okay and then
we're going to have a separate piece of
code it's a command line Java wrap
called stock ticker which is going to
update these stock objects in the named
cash and a stock servlet will receive
those as in its events and will push the
data down this WebSocket
so our stock was just gonna be a POJO
implement serializable so that we can
serialize it around the grid our stock
ticker so this will be our coherent
client ID by our standard JBM
stand-alone Java command line process
this is all the code that would be in it
so it will ensure it joins a Kieran's
cluster it will get a cash out of that
clearance cluster and then in the loop
it will just take a stock object and put
it into the grid with a key of C - B -
which is my company and push the object
in okay so these three parameters are
name description and price sorry so give
it a random number for the price so it's
very volatile stock small cap and then
it is gonna sleep for a random amount of
time so that it doesn't look like we
just pulls in doing long polling
basically yeah no no no the key is that
is the that is no sharding is just one
objective with one key
okay now stock servlet in its
initializer is going to draw in
coherence get the same cache create a
stock application and register it into
the Grizzly WebSocket engine and our
stock application is going to over I
create WebSocket create a new stock
socket and all the way through this will
push the cache basically object that's
the only change we're really going to do
is push the cache as a parameter and in
our stock socket we're going to
implement it's not on that we're going
to implement map listener interface for
coherence and in our on connect so this
is our standard WebSocket call on
connect we're going to add on to the
coherence cache a map listener which is
itself and then entry updated is a
coherence call which is a call back from
coherence when your entry that you're
interested in is updated in the grid and
when we get one of these we will call
send update and that send update will
our codes missing on here because it
doesn't fit on the slide but what it'll
do is it'll take JSON use Jackson it
comes with grizzly and changing into a
JSON object and then send it down the
WebSocket is a string JSON string and
then we're gonna have a fancy JSP we're
just going to use something called high
charts which is just a html5 graphing
library so it's all html5 so it's an
html5 canvas don't it's open I don't
think it's open source I think it's free
for non-commercial use and in our JSP on
our message function what we're gonna do
is take the data we got from the server
on a WebSocket pause that back to an
object from JSON create an X
on x-axis of a coordinate which is this
committee current time and price and
that will let us as we will see graph
price against time and then on this high
charts we're going to basically add a
point on to the Chart series okay if all
that works you have some lunch okay so
I shall clean up my GlassFish
yes let's start it again
okay I've got I have one but I started
already cuz there's too much code but we
lad something so it's really the code
you've seen before but I won't write
again so we have a stock class this is
this is the one this is the PC the data
object that we're going to pass around
it's very simple pojo serializable three
parameters name description price
constructor with once you get us on it
and a two string okay it's pretty simple
if we go to our stock servlet which we
have before again it's going to be setup
to load on startup and in this case we
haven't hooked here ensign yet so what
it's going to do is in this initializer
like before create a stock application
which is a see a second WebSocket
derived application register it into
grizzly and then destroy it all on
register it from grizzly same as before
same pattern so in here what we're going
to do is add in coherent so well in the
initialize and we're going to hook into
the grid and remember the code
so that gets us into coherence that cash
factory and show a cluster I mean I know
this is coherence but it doesn't really
matter that much because the same
products do the same thing so we'll add
a variable to hold our cash which is a
coherence named cash it's just a Kira's
class and then can't remember the code
yesterday's
so from coherence we'll get a name cache
which is called sporting odd sum log
legacy reasons from a different demo
okay and we'll store that on a variable
and in here we will do
so time just to make sure we clean
ourselves up when we under ployed
the other thing we will do is when we
create an application we basically pass
through the cash as a constructor
parameter okay so if I go back to our
application sighs yeah there is because
I added a parameter on to the stock
application and I haven't added it into
the code here so I'll do that
so basically to store all the cash for
essentially just for lazy reasons
okay we're also as before and I create
WebSocket i we created a stock socket
I'm also going to past past of that the
cash object just push it all through I'm
sure they'll be a better way but and but
the rest of its the same as was before
so we've got the same is application
request where it checks for your irons
in stocks and decides that it will
accept this your I as a application
request for itself okay and if we go
back to know this why is that complain
and again in here we will add the cash
as a parameter and an attribute
okay
so this was out is a standard WebSocket
you're right I do okay
and we're also basically what we're
gonna do is implement map listener
and
implement those three so the basically
these are the updates that you'll get
called from coherence when things happen
on the grid so there's three methods in
map listener which are entry deleted
entry inserted entry updated very simple
so we add those in otherwise it's the
same code we had before for in our other
example
so in on connect what we're going to do
in connect is add a map listener to
coherence so this is where we've got a
new WebSocket connection coming in so we
need to say that we're interested in
things happening on the grid so you had
a map listener you can see that there's
various versions you've got on takes
filter but we'll just basically listen
to all events that map listener will be
ourselves versus socket class itself and
then on close we all say we're no longer
interested too so we'll remove the map
listener which is us from coherence so
that when the browser goes away that we
don't leave listeners elite hanging
around and then
let's pinch a bit code here
so you have a bit code to the stock
stock socket which is essentially to
send the update that it will receive
down to the browser so this code takes a
stock object it uses Jackson to
basically take the object write it into
a string okay then get a JSON string
from there and send it down the
WebSocket so basic and take that stock
pojo return it into JSON using the
Jackson libraries which come the
griz-lee
and then send it through the WebSocket
and all we need to do now is on these
callbacks we get from coherent such as
entry deleted which we will do don't
really care about for this printer entry
inserted entry updated we will
get from the event the check but it is a
stock right some bad code and we will
send then email send that down to the
our method we just written here that
does a JSON
and same for if we get in trip date so
these are they cut these in the
coherence callback methods that get
called when something goes into the grid
okay you won't following not losing too
many lose another one and then finally
this is our command line app that we're
gonna write okay the moment it doesn't
do anything the coherent so this is just
gonna it's got a main it's just gonna go
in the loop update at stock object with
a random price so we will hook in
coherence into this forgotten the code
yeah before that
that's what I need
okay
so we get the same clash essentially
okay
and then when we create this new stock
with a new price we will do cash dot put
give it a key done okay
then finally we look at the JSP
so this has got the high charts in it so
there's a lot of JSP JavaScript already
in this project but we look at high
chart just for an example
essentially you create a chart object
I'm not here to look at high chart
specifically but and it has a whole lot
of jason properties you set how it's
gonna render what its title is x-axis is
a date/time and it's how often it it's
ticks on the access our y-axis title
tooltips and then a data series okay in
the first plane is going to do is
actually generate a bunch of zeros just
so you have a graph to start with the
interesting WebSocket stuff so that's
basically just setting up the highcharts
object within the page so here this is
where we do our standard WebSockets we
did before so we have a URL your I as it
was before we create a WebSocket that
your I we set on and on open on clothes
on error events and in this case they do
nothing so we'll add on message event
which I can't
sorry
you probably can you haven't tried it
yeah
so if you busy huh copy on message the
on message function is going to take the
string it's going to pass it the event
data it gets into an object it's going
to create a coordinate X which is
current time Y which is the price from
the JSON object then it's going to add
them onto this doc this chart as a point
and then magic happens okay this might
work
so if I run this JSP I don't want to
kill GlassFish first maybe it's running
just to make everything clean because
otherwise demo God will kill me
okay
so that's GlassFish up if I run this
file I would just written if I run this
oops
okay so it deployed in it should at some
point what we see is in the initialize
is called coherence is booting up and
I'm waiting for chrome to appear
okay so there we have let's that's the
high charts graph for the initial chart
which had a load of zeros in it okay so
on so that's connected to the WebSocket
you can see here we've got WebSockets
accepted by stock and a WebSocket was
called but nothing happening yet that's
what I'm going to do is run this dr.
Kraft location and this is the bit
that's gonna push data into the grid so
just draw the command line app so we'll
see that kick off it boots into coherent
as I'm not connected to the network its
waiting on some network payment
and is not working
okay
so what I'm gonna do is I'm going to
stop that
boom
and I'm going to run one that does work
right so I will start grass species not
most GlassFish team mm-hmm okay is this
time
so this one should work I did before
so we began is booting coherence
and we run the command line up
surely connected to the network
Hey
I'm sure there is all right there we go
so you see that this is the so that that
one is the command-line application
GlassFish is receiving the updates from
coherence as a event and then this
GlassFish is pushing the WebSocket the
up the price down through JSON down the
WebSocket and that gives you this is
this here is all html5 so as canvas it's
not flash or anything
it's got animation on it but it's a nice
wave records a nice demo so hey
there you go we could probably do it in
Firefox too
yeah
there you go
- all right this
in the HTTP session and know it can be
benign this code is associated with the
page though yeah yeah it's just yeah
each one's pushing it's added a cache
listener for each page so it each one's
pushing the same data but yeah there's
three sockets there
that would just be a matter of setting
up the in this case setting up the
filter differently when we when we
create the WebSocket object you just set
a different filter and they would only
receive those events when we go in here
this object to go back to the
application
when this create WebSocket call gets
called by grizzly when there's a new
client so you create a new instance of
the stock socket class and that instance
this was one of these per WebSocket
connections so one per browser which
means that if you need to set up
different data for that specific view
then you'd set it up in that class
sorry I can't I can't hear
how did I boot it either I boot
coherence okay it's in this and the
servlet initializer here yes that's the
bit there ensure cluster basically says
and set goes with all the networking it
only comes back once coherence has been
booted and that you're in the cluster
that's when all it starts spitting out
all all that stuff
sorry
no no this is raw hearin so it's not
hearin sweat or anything like that so
this is just raw okay any other question
yeah yes can be I'll polish lies in
SlideShare and I'll put the code
somewhere I'll put it on our website
some ok it's ok it's www.ctvn.org
yeah there is yeah he came for the
slides for me so he's got slides we want
the code we probably put a blog about
two input code on there we actually have
a blog doing the similar sort of thing
with infini span but it's it hasn't got
a graph but it has a whole bunch of odds
of dating and you through WebSockets and
that's on Tomcat and all the codes on
our blog as well for that because
grassfish Tomcat jetty they all support
WebSockets at the moment
dot coat UK we are a UK company
yes
yeah yeah I haven't got to here to test
okay what I mean
a lot of the commercial libraries that
do this sort of thing like causing and
push technologies they provide
JavaScript libraries that do fall back
and they'll all fall back either to long
pole in comet flash which is another way
that luck I mean a lot gaming companies
now use flash they don't use long
polling because flash gives them a raw
socket but I want to get away from that
because it's not very secure so yeah and
some of the commercial libraries will
fall back between those different
techniques so they'll use WebSockets
first if you can't do WebSockets maybe
flash or Silverlight or something like
that yeah that's what yeah that's why
the lot of commercial libraries will do
that for you so they'll do all that
fault back transparently to you as a
developer yeah but I think they were all
around before a lot of this stuff came
out sir
okay so and that's essentially it so in
summary so web stock is effectively
reducing latency because it is full
duplex so you can be sending data over
that socket while the old Java scripts
getting called back from what's coming
back from the server so there's no delay
as there is in it in long polian or a
polling type model the only data flowing
is a bit of framing which is a few bytes
and the actual raw data you send there's
no HTTP overheads on this there's only
one socket as opposed to say a comment
where you have to have two sockets one
to receive one to send and you have to
do a whole load of code to work out you
know which message you received
corresponds to which message you sent
because it's half duplex on HTTP so it's
much more scalable in that sense you get
one socket per browser know per
connection and you know software working
out at the minute with customers is
linking into data grids to see if we can
do enterprise scale push without having
to go and buy a push technology or
causing or something
and there look at this is pocs at the
moment the only barrier for them at the
moment is browser support so there's too
many other browsers out there for them
to do this in total for everybody but
they're looking at doing this because
this works quite well on the modern
mobile as well so having got internet
here but wouldn't have done this in the
past we've put it up on Amazon and got
everybody to look from from their mobile
devices and see which ones actually work
which is getting better so yeah is that
which ones which ones can do read render
that picture that graph and which ones
can't
the only thing about html5 of the minute
we've seen is the actual CPU set usage
on these things is very very high so
when we push prices much quicker to say
at Apple at something it just burns and
Firefox can burn like dual quad just
rendering a little graph like this
JavaScript on the client can be a bit
CPU intensive but that's the same for
any of these techniques in html5 okay
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>