<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Effective HATEOAS with JAX-RS | Coder Coacher - Coaching Coders</title><meta content="Effective HATEOAS with JAX-RS - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Effective HATEOAS with JAX-RS</b></h2><h5 class="post__date">2013-02-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/CcQE9481lMs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so my name is dawn and this is my
colleague Matt's and we're going to talk
about effective hypermedia api's with
the jax-rs so if you ever wondered how
to pronounce this word it's pronounced
hypermedia api's okay so the first thing
whenever you hear a rest presentation or
talk about rest there is this discussion
about the theory and practice
you have the professors on one end
discussing you know the very detailed
theory and the practitioners that want
to get things done so if you google for
every discussion about rest ever you can
find this hilarious video and we're
taking some excerpts from this to just
highlight some some of the problems so
the developer is really happy
he says check out my API is totally
restful and the developers love it the
professor says cool what media types
does it use and the developer says well
I'd use JSON because that pretty easy
for the clients to parse oh but how
you're handling the hypermedia
constraint then what now
and the professor says your fool using
hypertext as the engine of application
state you'll never achieve internet
scale decoupling without it
and from then on the discussion spirals
out of control with Professor arguing
for writing RFC's and creating the
internet standards and the developer
just want to get things done
start starts his startup and makes a lot
of money and the professor is really
unhappy okay it's this one
yes so let's start about talking all
saying what we won't talk about in this
discussion and since this isn't is an
advanced talk we won't we won't be
introducing rest and we won't be
discussing nitty-gritty details and the
protocol such as differences between
these verbs we won't go into discussing
however interesting this media type is
or even be discussing it this should be
its name and unfortunately we won't
provide a simple recipe for doing these
hypermedia api's but discussing how how
you should do them and what we've done
so yeah we'll talk about practical
hypermedia ap is a definition and how
it's used and will outline with our
experimental framework we've been
developing and using and lastly
discussing the possibility used using
jax-rs 2.0 a little bit about our
background we come from a company called
gateway which is scandinavian based
software consultancy company located in
sweden and denmark and we've both been
working well know a little bit about j
with first we it's it's a consultancy
company for we do software and
pretty much do anything from embedded
software to back into front-end let it
be a web clients or even clients
installed on on devices such as Android
and iOS a really a full range of
software and in terms of rest we really
have both ends both the construction of
rest api and consumption of rest APIs
we've both been working as consultants
for modern for more than 10 years so
with and mostly working on unpacking so
we've done a lot of rest of course and
then a couple of years ago I started
working on a project called ScreenFlow
which is an open source in case
management tool and it's implemented in
a framework called
chief oj they're both Java based in and
both streamflow and chief oj is
implemented by uh or driven by a guy
called Luca repair a Java champion you
might have heard of him and part of the
streamflow application exposes a restful
back-end and Rick had had some really
great ideas on how to how to provide
framework support for rest making it
really easy to to implement wrist and
then that was really very inspiring to
work with but as a consultant I had to
move on to new projects and I started a
new project and that was also
implementing a rest back end but now in
a more plain Java context not enough in
a chief of Jay context the framework g4j
is really even though it's it's Java
based and an application framework it's
it's very advanced and um since actively
it doesn't really look like Java it has
constructs like to make scenes and stuff
like that so it's it's it's it's very
good but it's it's very advanced they're
not really something just pulling on
your project and I was working on this
new rest back-end and wanted to do these
principal but I couldn't really
take the whole cheapo jframe organ so I
talk to young a little bit and then we
decided to let's try to implement these
ideas for the rest framework in a
standalone Java environment so we did a
framework called forest and then
implementing these these ideas that it
was really quite effective and
successful yeah okay
so during this presentation we will use
and have an example domain and that is a
web shop for e-books and I think with
ebooks is that you don't have to wait
for them to be delivered to your door
you can actually download them directly
there is no need to have a shopping
basket or things like that so it's
really sort of simplified domain so
that's why we use it here because it
sort of avoid all the complexities that
arise you know in a normal purchasing
flow another thing you can do on this
site is you can of course view the book
you can view information about the books
you can query for the books you can
browse for the books you can so that's
that's so we will use this domain
throughout the presentation and whenever
you talk about rest you hear about
something called the Richardson maturity
model and this describes sort of how
restful you are and at that level zero
the bottom level sort of where soap is
located at that level you only have a
single verb and a single URI so you see
all communication is done typically
through a post into some URI at level
one you start using different resources
for different things you might have a
book resource or a purchasing resource
or downloading resource things like that
but you still use you still don't use
the different verbs for what they are
supposed to be
at level two you use the different to
our eyes and you also use the different
verbs for they their meaning so you use
gift when you want to access the
information without modifying anything
you use put when you want to replace the
contents of the resource use delete we
want to remove things and so on and you
also use the different status codes for
what they are designed to do and within
the context of our presentation we will
only consider HTTP as well as we won't
consider our other protocols although
that would be possible as well so if we
take a look at the current version of
the jax-rs and the 1.1 version we find
things like at path which you can use to
have different your eyes for our
resources we have all the different
verbs and we can put them on our
resources to expose you know how to
access the resources and we can also
very easily use the status code so I
think jax-rs is it's a really good
standard and we like it a lot and it it
fulfills all the needs you have up to
level 2 in the Wichita maturity model
but of course there is the level 3 at
level 3 you have something called hyper
media controls and what this means is
that you have ins in your response
typically you have any representation
you embed links and this is something
you all know about when you browse the
web because when you when you browse the
web use you get an HTML representation
and you have links inside of that and
you can navigate the links it's sort of
that simple really and also you can
there are many ways to represent links
you can have them in XML JSON and you
can have them also in the HTTP header so
there are many ways to represent that
so if we take a look at what is a link
what are the parts of a link obviously
you need to have some kind of target
where the links point to so what happens
when you click the link what resource is
this accessed if you look at the HTML
you know you often have a description
also for the humans so we can read a
link and we can understand what happens
when I click the link but for for a
program to know what's going on you need
to have some kind of semantic
information the program needs to
understand what happens when the program
does something let's say you have an
iPhone client and the developer
developing the app in the client needs
to know what happens when when I follow
this link so you need to have some kind
of information usually that's done using
something called larell and that that
describes the relationship between the
current resource and the target resource
also you can have things like what kind
of media types you support let's say you
can put something to this resource maybe
you want to describe what you can post
kind of things you can put you can also
describe what kind of methods you expect
we support
so when you look at this red thing which
is really really important when we do
what we want to do hypermedia
guys we want to know the clients needs
to know what is the meaning of the link
there is a standard for this of course
you can find the standard at this Ayane
has it has the registry of all this
standardized links in there they include
things like items you can have items in
a collection you can point things to a
collection because let's say we have the
book example again you might have a
specific book and that is part of a
collection of books the collection of
book points to the books things like
that so there are many many rails that
are standardized but most typically they
are standardized for things like blogs
and document repositories wiki's things
like that so there aren't really many
standard rules that you can use when you
want to do implement a specific service
like a webshop so that so the professor
says well it's not no problem just write
an RFC and you can create your own
standardized rels it's really really
simple but of course in reality we want
to get things we can't wait for things
like our to other people to approve our
ideas we need to get them out facing our
customers as soon as possible and that's
possible but using it we don't need to
have we don't need to have the standard
Wells we can start using non-standard
rels for example you can use if you are
you are I as a rel or you can just make
up your own things and hopefully
standardize them later often that's
that's more pragmatic to get to do that
okay so how does a an application that's
built using a level three how does that
look like well it looks like something
like this we have a number of resources
and you have a number of links between
the resources and when the client access
is let's say the root resource because
that's the sort of documented resource
that the clients normally access the
first time what happens is that the
client get gets the representation of
the root resource and the number of
Link's we get the links to the books you
own and the books that are available in
the webshop so let's say the client
falls and this is of course the rail the
rails that are specified here so let's
say the client follows the available
link the client gets a representation of
all the books that are available and
maybe one link to the book one two three
and obviously many other links as well
but also maybe a link to another
collection of the most recently added
books or something like that the client
decides to follow the specific link to
book one two three and we get of course
the description of the book and the
author the title the price thanks my god
and depending on if we have bought this
book or not we get the link to to the
payment resource or we can get the link
to the download resource but we won't I
mean we want to we won't have the client
wants to have the information what links
are available what link things can I
follow so if the client hasn't bought
the book there is no meaning to have the
link to the download because we can't
download the book until we have bought
it so let's say we haven't bought the
book
we need to buy it first there is a link
to only link to the payment we follow
that and we'll go into more details
later on and after fulfilling the
payment process we can download the book
ok ok so one interesting thing here is
that I never said anything about what
you are eyes were available here and for
the client the you are eyes doesn't
really matter the client doesn't care
what the URIs are the clients does
doesn't care if the if they are just you
know randomly generated characters or
nouns verbs whatever the client doesn't
care it just follows the links so this
could be a scheme we could use and we
could use any other scheme as well it's
a for the from the client perspective it
doesn't really matter we should use a
scheme that is appropriate for our
purposes on the backend and we should be
free to choose the scheme we want
okay so this thing that I said was
pronounced hypermedia api's it's a
acronym for heiping medias the N general
application state what what does it mean
really so the way I look at it is that
that is the application state that is
from the point of view of the client so
let's say I have accessed the book one
two three resource I have retrieved the
information about the book and get the
link to the payment resource because I
didn't PI have bought the book yet and I
decide I want to buy this book I follow
the payment link and end up in the
payment ok resource now the state has
changed now I have both the book and now
I can download the book so that is the
engine here is the link you follow the
links and the state changes what
resources you are currently located at
changes
so if we compare the level to which is I
can see the level many there are many
useful level to services so I I don't
consider level three the only option uuu
it's fine to do level 3 never to
services as well for example Amazon s3
it's a very good level to service but
doesn't contain any links but it's still
very very useful but let's compare it
from the point of view of the client so
what about navigation at the level 2
application the client needs to be know
how to build the your eyes so the URIs
are really really important for the
client it needs me to construct them
somehow using maybe some parameters or
or some other rules or something I don't
know but in level 3 you just follow the
links the links are available there and
you just follow them so if we look at
the behavior I mean what behavior is
available let's say we take a book
example again if the if the client
should should be able to display the
download button if you want to download
the book the client need to know is the
can i download the book or not at level
2 you need to have some business rules
in the client so the client knows how to
what what to display or not but in level
3 if the download link is available you
can download the book so let's say you
have a some maybe you want to give away
the book for a certain day if you have a
level 2 application you the clients must
be available know that you have this
campaign going on because it needs to
know about those business rules that in
level 3 you can just add the links and
the client will show the download link
if if it is there
and of course the professor pops up
again and reminds of about this ideas so
let's let's have a look at the how this
can look like yes so we'll take this
example and see what it looks like
implemented in the framework I mentioned
we call forests but let's instead of
starting looking at the code let's look
at the at the result so we take a browse
yeah and yes so now as Yun said we
document the root URL of course and we
answer that in a browser here and forest
supports two different media types built
in either HTML or JSON and when you load
or yeah reference a URL in a browser it
will ask or it tells actually in the
request that it prefers to read text
HTML so our framework will then say ok
I'll give you HTML so that's a HTML
representation of the root resource we
have if we would sake curl in a browser
yeah I've actually already done it here
just for you I'd do it again so I curl
the same URL and then I I put it into a
pretty fire for the case and just to
make it more easy on the eye but we see
how they result it actually returns us
some JSON with the same link as we had
here so here to understand that this is
actually when if you know of our curl
when you just curl it like that it
doesn't have a accept header set but in
our framework dances are the default
media type is is JSON so it will give
you JSON but of course you could also
add and say I want to accept JSON and it
will will work like that so two
different representation of the same
resource but let's let's browse it using
HTML in in a browser that's a little bit
more easy so looking at the root
resource here it just writes and I mean
this is a it's not considered a real
client this this is only for browsing or
discovering your API so it looks like an
ugly website and it's not really
anything but to browse your API so what
it does is it looks at the resource then
generates this first of all the fully
qualified class name and then it lists
the links in in different groups we only
have one group here called soft
resources
so yeah we have the books we talked
about before so I've followed that by
clicking it and now of course the your
little changed change - yeah appending
this books slash under on the URL and we
see a different risk or a different
resource now called books resource and
it has a a query called discover and a
list of soft resources and this book's
resource is is a collection of books and
then the framework now oh this is a
collection I will I will start listing
the elements in this collection here we
only have two elements where do seals is
it really has built-in support for
paging all these links so it so it
doesn't write the whole collection at
once it pages it nicely and and also you
can sort them by name for instance you
can sort them differently and okay so
let's follow a link again let's take the
first book and we go to an other
resource analysis and with the idea this
is very common way of doing this that
you have the collection name and then
the collection or the item ID yeah and
this is called book resource without the
s and we have a query called read and we
have a command called PI then it also
writes the description that's because in
our framework we we said that this is a
readable resource meaning that it
implements this read operation and
meaning that the framework will just
include the result of calling read here
just for convenience but really if we
press this read we could actually see
that it does like that it writes the
JSON and now the browser has a plug-in
that verifies the jason but it's just
the same string actually
okay but we have a command here called
by so let's try following that and then
we get to a page where it says okay
before you can buy the book you have to
enter your PIN code so this is a sort of
a mock-up of a pair of purchase flow and
I will enter my secret pin code and
press submit this is operation completed
successfully fine so if I now go back to
the same resource again and this is
unrefreshed because just press back so
if I press refresh you'll see that it
actually changes now it has different
links of course still it can it's it's
readable that's not changed but the by
query or the by command is not available
anymore because I've already bought it
now but now instead I can download the
book so if I press that I yeah
supposedly see the content of the book
okay so I mean that's a hyper media API
so that how did we implement this so we
go back to the slides here to see the
code so yes so you see here in the top
corner you see a little snippet of the
graph to show you where we are and then
at the bottom a description of the links
it shows so this is the root resource in
our framework you must if your resource
you have to implement the interface
resource which is just a marker
interface but in but I need an interface
as part of the framework in and then of
course you have to tell the framework
when you initialize it that this is a
root resource is not because it's called
the root resource that will act as a
good resource we tell the framework this
is the specific root resource and
and yeah we have a method called books
returning a resource and then the
framework knows okay this this is
supposed to be a soft resource of this
resource just returns a new instance of
the books resource so moving on to that
one yes I mentioned that's a collection
so we implement the framework interface
collections resource and then you can
specify what it is it what is it a
collection of and in our case it's just
a collection of links and yeah then you
need to implement these two methods
called item and discover so item is the
specific item in the collection and
that's fairly simple it works as a
sovereign source remember we saw that
the books and then the ID of the
specific books so that works as a sub
resource to that one and the method call
item it takes the ID and then gives us
the resource that ID we'll get to that
in a in a minute but then you need to
implement a method called discover every
turns a list of links and I mean we've
commented out the code here but
presumably it does look up in the
repository and returns a list of of
these links using this links build build
up okay so the book resource the final
one is just an resource and it has a
constructor now because it needs to know
the ID of the specific book and again
we've commented out the actual code
because it's not relevant here but you
do some kind of again look up from the
repository based on the ID and if the
book is not found you throw a 404
meaning not found something like that
and otherwise you you you assign it to
your local variable book and then you
have these two methods down here
buy and download okay so first of all
and under the hood how does this
actually work because what we did in the
framework we chose to have a concept of
a command query separation to
distinguish commands from queries we
remember you saw it listed it in
different groups either the method was
enough in the queries group on the
commands group and the command query
separation is really a a big topic so I
won't cover it here but basically it
says that um your method is divided in
in two different categories and either
it's in the queries category or in the
command category and if it's in the
queries category you're allowed to
return something but you're not allowed
to change the state of the application
and if you're in the commands category
you're allowed to change the application
state but you're not allowed to return
anything and if you think about these
two kind of things it's really similar
to what get and what post means in HTTP
sense and if you think about it with the
return a return or not return anything
it's really easy to write a framework
that recognizes if a method is a query
or if it's a command so basically we
just look at our methyl and say if it
returns a void well then it must be a
command and then it must operate on post
and if it will actually return something
like the download which it sends an
input stream it must be a query so it
must be get so in that way we sort of
avoid with just this simple convention
being we avoid polluting our code with
these annotations these verb annotations
but ok so the by if you look at the by
and Method you see that it actually has
a pin DTO so an argument and now they're
one step back here because now I just
said that
the by method will be moved but if you
think about following a link in a
browser as always HTTP GET so how does
this actually work so let's go back to
the yes the browser and we just turn on
yeah we just go back to the list here
and we turn on
which is turn on the console here to see
what's actually happening Resource
Network yes okay because what I just
told you means that if I follow this
link
no not yeah sorry here so now we're on
the other book with which I haven't
bought yet so I have to buy command
ready but as I said following this link
will be HTTP GET and hmm how does that
work then so if you notice down here you
see the response code it actually says
405 meaning method not allowed and what
method not allowed means is that it says
to you that the URL you're using is
correct but the verb is using is
incorrect and that's what we see we used
get so hen we should have used post
because it was a command so it says 4 or
5 that's that makes sense but instead of
just breaking or saying yeah wrong it
actually helps you so it generates the
response here based on the method you
when working so it looks at the method
and say oh we're actually expecting a
pin DTO so using reflection it looks at
that in class and generates a form based
on that and the form or if if you look
at the pin DTO class it contains one
field called pin which is which is a
string but the framework is is general
so it could really be arbitrary
complicated and nested objects and all
that it would just generate a an
appropriate form and the form can then
be submitted so it resubmit to itself or
it submits to itself the and that that
is using post of course so now the verb
will be correct and also the input
parameter will be correct so that's how
is you sort of discover your API don't
need to document this it's just given to
you so when I do this and then press
post
the URL is correct the verb is correct
and we get a success okay but what about
so the next thing is that the links are
not enabled at the same time and that's
the whole point of this hypermedia
Vyatta to change your state and then you
change what what you can do what links
you see and so we need some kind of
constraint here and how how do you
typically do constraints well it's
probably something like this that when
you call a method you start the very
first thing you do is that you validate
you do some validation input validation
or whatever you do and if that is not
valid you'll throw an exception and then
yeah below this should of course be the
implementation of the method but if you
think about that approach here that's
not really good enough because we need
to know
I mean before the method is invoked we
need to know is the constraint valid or
not so the the quick fix here the easy
solution to a constraint is not really
good enough so we choose we chose to do
it like annotations so you could imagine
now that you have and then you say a
constraint called hey sport book and you
can say it's either has has bought it or
has not bought it with this boolean and
then yeah basically so the framework has
a a constraint annotation built in at
that that it knows when it sees that
annotation on something so this has for
book annotation will extend from that
framework a constrained annotation and
that will evaluate to either true or
false
and based on that the link will be
visible and we've actually implemented
this much like in the bean validation
it's also happening
so doing this on the code will actually
do exactly what what I just showed you
is really easy to read here and and and
and figure out I mean when is when it's
the one link enable and when is the
other link enabled so that's really good
okay so that was fairly easy to do let's
try to evaluate I mean the quite some
advantages of this of course you saw
that the discovery and the documentation
is basically for free you just implement
your resource tree and then yeah then
you just say to the develop or whatever
yeah yes the root URL and just browse
the API you can see how you invoke
methods and what what the input
parameters are needed at all that you
don't need to write a lot of
documentation on how that works also the
conventions was really gave us very
clean code you don't have all kinds of
annotations in the code it's it's
basically Java Java code and very
readable and the declarative constraints
really are a huge benefit because that's
what hypermedia api's are really all
about being able to enable and disable
links all the time depending on the
state and so let's ask what does the
developer think about it and he's really
happy because it's real easy to use and
that's no extra work for him to do this
hypermedia stuff that was the issue in
the beginning that hmm but what about
the professor then is he happy yeah he
he asks about other media types i mean i
said that we only have HTML and Jason
and hmm of course he wants the whole
general package that you can you can I
mean define your own media type for
instance we couldn't do that and mmm
rels yeah we don't
we don't support that in general at
least
so however cool it is it's the its we
have some disadvantages also a very
basic HTTP support immediate side wise
and here are wise and all that it's it's
you have to restrict yourself to only
using JSON and simple things and you
also had very limited control as a
developer for instance the serialization
mechanism was baked into the framework
you couldn't change civilization
provider for instance if you wanted to
do that for whatever reason and also the
linking mechanism we saw that lis these
child links as long as you append to the
URL meaning that its child links you're
doing it's very easy to do that's
building the framework but but general
linking in the in the resource
structures not not very easy to do and
as we saw in the in the diagram that Yun
showed it was really you could have
links anywhere so concluding forest
didn't it was a really great experiment
and it served us well we've used it on
several projects and we've showed it to
some of our colleague developers and
they love it and have actually used it
on other projects also it gave us a lot
of ideas on how to do that and and it
turns out that the problem is it's not
really general-purpose you you you need
to have these this media type
flexibility also you want a general
hyper media API
so we we started to think about how can
we how can we do this in a more
general-purpose way and since we said in
the beginning we like jax-rs
quite a lot so we started looking at how
can we do this using jax-rs is it
possible possible well using the current
version it's not really possible because
it's you have to limit you have a bit
limited access but there are some
interesting opportunities coming in
jax-rs 2.0 so we want to take a look at
those so the first thing that happens in
in jax-rs 2.0 and we saw that in the
keynote yesterday as well and there is
hyper media support and that is the
class link you can add links to your
resources and you can add links to
representation and this is well this is
sort of mandatory to have a hyper media
API so this is very good so let's ask a
developer if he's happy with this maybe
now we can add links everywhere he wants
let's ask him let's see mmm he's not
thinking any no this is not enough
because he will have to add these links
everywhere in his application and that
would be too much work for him so he
won't bother doing that that's our
theory at least so how can we make it
easier friend we think you need to have
these four things to get a good hyper
media framework you need to have this
idea of a single root resource that's
very important if you look at rest from
the from the theory perspective and also
from from a practical perspective you
need to have support for this rel
attribute at the links you need to have
some kind of links by default and our
idea is that every resource every URI in
your application should have at least
one link pointing to it somehow
there should be one link somewhere
pointing to every resource so we need to
come up with a strategy how to how to
build that we think this idea with
having declarative constraints it's also
a really
we need to have this so let's let's go
through this and see
but first the professor pops in and of
course he thinks we should all program
HTTP directly but you know that's won't
be very productive so we won't do that
what about the single root resource
using jax-rs this is actually supported
already and when you annotate your class
with the at pants annotation that would
that resource becomes a root resource
the sort of problem I see is that you
can have multiple root resources using
jax-rs but but this is already supported
we can we can use this and we can add
sub resources by simply by adding that
path annotation without the verb so we
can have sub resources in the same way
we have in forest so what about what
about well support well adding an
annotation where you can specify the
relationship isn't the sort of a hard
idea to come up with the question is of
course what is the relationship to what
and the way we see this is that you have
this the root resource here and the path
is just slash for this one and the
relationship is for that URI
so you specify the relationship to that
URI and then what you do is your group
your methods in different resources and
the things that are in the same
resources they have the same link the
same relationship so let's look at the
more complete example
if we have this we have this buy down
here and that has a relationship of
payment to the book resource no so I'll
go through later on what be so the
question was it was if it if it girl was
a standard and it's not and we will go
through what is standard or what we're
showing here and what is not the seller
so let's say you want to add links
automatically the links method here
that's part of the jax-rs standards you
can add links to your response but the
make links is not part of that but you
can imagine implementing a framework
method that takes an object using
reflection looks at the different paths
of the rails and generate links isn't
that complicated so we can actually do
that and if we do that we will get
something like this we will get the link
to with a payment well to that your I
however we need to be able to construct
absolute links since jax-rs and doesn't
really support relative linking very
well since the slash in the end is
optional so we need to add this this as
well
and suddenly you can imagine if you have
to add this to all your methods it gets
a bit messy so we probably don't want to
do that but in jax-rs 2.0 one of the new
things that comes there is a way to to
control how things using some some kind
of interception mechanism so there is
something called the container response
filter that is code you can make that we
called after the representation has been
generated and you can imagine
implementing this and all this would do
is call the make links method and add
the links to the to the response
so what about the declarative
constraints has much show you before and
the idea is very similar to two yellow
bean validation so we could just sort of
use the concept of your bean validation
but instead of validating the return
value or validating the parameters we
would evaluate if the method is can be
called or not and we need to evaluate
this before the method is executed and
in 2.0 we get this container request
filter that is called before the request
is made so we can we can filter things
before before they are actually called
so okay the things that exists in
injector is 2.0 it's the link class it's
the container response filter and the
request filter the things that with am
needed either you know as the future
part of the standard or as a separate
framework is the real limitation the
constraints and the possibility to
generate links using reflection so we
get this these sensible defaults that I
was talking about
it's so in conclusion and yeah we saw
that
using these hypermedia ideas as yarn
outlined in the beginning really
simplifies the client development you
don't need to duplicate all the business
logic on your on your client as a huge
advantage and really that jax-rs 2.0
really provides the framework for or the
foundation for doing this but they're
still a little needed so we believe the
minimum thing you really need for a
framework like this like this hyper
media framework is to have sensible
default links added that's that's that's
the basis of it but we know that many of
you are our developers and you want to
have a look at this now so you're asking
you know why can I get hold of this
thing and if you do we need to keep in
mind that this is an experimental
framework and it has a number of
drawbacks but sure it can still be very
useful you can find it at github you can
download it you can try it out there are
some samples there the documentation
could perhaps be improved now it could
be okay
it becomes with the plugin for sports no
this is only a back-end framework we
should implement and that if you're
building a front-end you need to
implement that separately so the way we
typically build is having clients using
backbone or jQuery things like that at
the at the website calling the rest
resources so any more precious
yeah what happens what happens okay what
happens if we don't have HTML at the
response format and you do the method
not allowed well it actually provides a
JSON representation of all the form it's
I mean it's no standardized but it's
it's at least something you can work
with so there is support for that as
well
the engine or is it just excessive okay
so if it would persist anything or if
it's just a certain if they know there's
a it's just a session state or I mean if
you want to have things like security or
you know authentication I think I
thought that you have to be able
separately
no no notice I'm like the has ball you
wouldn't know
no no you need you need to have some
some kind of authentication mechanism
you know connected to this the issue you
can implement a sport book somehow yeah
but that's not support that nothing with
a framework for that what we typically
do is have things like spring security
on top of this no it's it's an it's
built using we built it ourselves
know that the framework is completely
stateless no the current version of a
forest is completely not related to yaks
RS we will be originally using jax-rs
but we have no dependencies to exercise
right now but who knows you know what
once the jax-rs 2.0 comes out maybe
there will be a new release of forest
yes exactly
so how do you how does the client figure
out what calls to make
yeah okay so the way the way you would
do that this I mean you would hopefully
be able to use you know build your
client using the rel rels and use those
to drive the new client but of course
you can of course and we have seen
developers you browsing the HTML client
that we showed and then sort of
hard-coding all the your eyes in the
client which we we don't think that's a
great idea but but it can be done of
course that way as well
and I didn't get the last part
yes exactly so so the all the actions
that are available are exposed as links
and the client only need to follow those
links so how do you know what kind of
links you can perform on okay well as we
showed you there is you know you can add
and some people do this you can add what
methods to support it on the on the link
but also I mean the rels you need you
need to document the rels what the rels
mean so let's say you have some kind of
payment well you need to document what
that means and while you're documenting
that you can of course document what
methods are available as well and what
media types are supported so the way
yeah you could you could of course do
something like that we have been
thinking about adding things like you
know options
so the question was developer feedback
on using CQRS style and query separation
well I think initially most developers
find it hard to use that because it's
completely different because what
because what they used to and so I
definitely fantasy takes some time to
accept accept that style yes
was
I mean what HTTP or something
no no no the way we see this is that
this is a convention and the convention
has been like if it's a command that
should be opposed but using jax-rs
when we sort of where we go move ahead
to jax-rs you know that you can of
course override the defaults so that the
convention might be there or may not be
there but you can override the
combinations using annotations I think I
think that this a good idea to have you
know good good conventions a tour
through most of time but then you can
you should be able to override them when
you need to no no the framework as I
said is is experimental I'm very much
multiple ignore that and it enforces
these constraints you have to avoid
methods have to be post and the other
ones have to be get but we also support
put and delete don't think about using
slightly different approach
now we have an interface that we
implement
sorry yeah we if you don't really return
anything you know well the electric
command implemented by the application
doesn't return anything but but of
course the the application the framework
returns something else sure what we will
post and we have support for it yeah
yeah I don't think we have an opinion no
we're starting to reach the professor
side I think yeah ok thanks thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>