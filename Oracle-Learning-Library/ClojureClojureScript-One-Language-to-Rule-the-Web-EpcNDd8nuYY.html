<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Clojure/ClojureScript: One Language to Rule the Web | Coder Coacher - Coaching Coders</title><meta content="Clojure/ClojureScript: One Language to Rule the Web - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Clojure/ClojureScript: One Language to Rule the Web</b></h2><h5 class="post__date">2013-02-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/EpcNDd8nuYY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon everyone and thank you
for coming my name is Stuart Sierra I
work for a company called relevance and
I'm here to talk about closure and more
importantly closure script so first of
all just a quick introduction what is
this mysterious thing called closure
well closure is a fairly new dynamically
typed Lisp like language for the Java
Virtual Machine it compiles to Java and
it's organized around the ideas of
functional programming immutable data
structures and built-in support for
shared memory concurrency so this year
is a whirlwind introduction to closure
syntax every expression is wrapped in
parenthesis like any Lisp this little
example here starts with a namespace
declaration ns that's saying we're in
the namespace Java one examples and then
it has one function definition defin
defines a function average is the name
of the function and nums is the argument
to this function and the ampersand means
that this function takes any number of
arguments so it has variable arity and
then you just read expressions from the
inside out they're nested so the
innermost expression in this example is
reduce plus nums that's calling a
function called reduce and plus is
actually the name of another function
that's being passed as an argument so
we're passing the plus function into the
reduce function and that's going to use
the plus function to reduce over this
collection of numbers that we've passed
in so it's going to call plus on the
first two numbers and then take the
result of that call plus on that and the
next number and so on until it gets the
final result which will be the sum of
all the numbers that we passed in here
and then it's going to divide that by
the count so again this is a list we
have prefix notation the slash is the
division function so we're dividing the
sum by the count to compute the average
of a group of numbers now you'll notice
of course this is a dynamically typed
language we don't have any type
declarations so if I call the function
average with exact integer arguments
down there I get an exact answer in this
case a ratio if I call it with
floating-point numbers I get a
floating-point result and I could also
do that with arbitrary precision
integers or big decimals or anything
else so just as a very quick comparison
you can see this is what this piece of
code would look like if we were writing
it in a more typical language I use Java
as the example now in Java of course
everything has to be in a class so this
function would have to be wrapped in a
class it has to be statically typed so
the Java version only works on an array
of doubles and it's got some explicit
for each looping and then it returns a
result the point of this example is that
if you hear a lot of complaints about
Lisp like languages that they have lots
of parentheses the parentheses all over
the place it's not really that there are
so many parentheses it's just that
they're in a slightly different place
than you're used to so if you actually
count up the braces and the brackets and
everything else you'll see there are
just as many in the Java example we just
use different kinds and we use them in
slightly different places so that's all
I'm going to tell you about closure
you're experts in closure now so close
your script is a compiler which is
written in closure so it also runs on
the JVM and it compiles closure script
which it turns out is very similar to
closure into JavaScript it takes closure
script source code as input and returns
JavaScript source code as output and
that's everything you need to know about
closure script so the rest of this talk
is going to be about
I you would want to do this why do we
want to compile into JavaScript why do
we want to use closure and why is this
interesting first of all why JavaScript
why write a language that targets
JavaScript as a compiler besides the
fact that all the cool kids are doing it
these days and the answer is because
it's there I mean you can't get away
from it it's in your web browser it's in
every kind of phone whether you've got
an Android phone or an iOS phone they
both do JavaScript it's in servers and
databases it even shows up in set-top
boxes and other kinds of embedded
devices JavaScript just keeps popping up
it's very frequently the only executable
code technology that's available in some
given environment so if you want to go
someplace javascript is going to take
you there some people even go so far as
to call javascript the assembly language
of the web and I didn't come up with
this some very very bright people doing
a lot of work with JavaScript have
agreed to this this picture here is what
you get if you do view source in Gmail
now obviously that was not written by
hand and it was not intended to be read
by a human being so this has been going
on for a while people are compiling
things into JavaScript and treating it
as a an execution target as a platform
in fact someone I think it was a Brendan
Eich did an experiment and he discovered
that if you take this compressed
JavaScript source and then you compress
it as text using gzip or something you
actually end up with something not much
larger than x86 machine code that gives
you the same effect so this is actually
a fairly efficient way to distribute
applications last week I was at the
strange loop conference where Brendan
Eich the father of JavaScript gave a
talk about this language that he wrote
in ten days and has been trying to
Fix ever since and this is his slide he
said you can always bet on JavaScript
every time someone says javascript can't
do something people will figure out a
way to do it because as I said it's
there the only thing wrong with
JavaScript really I mean the only
problem it has is it's JavaScript you
know it's it's a weird language and it
sort of shows that it was developed very
quickly and then didn't have any
standard or careful design process and
Brendan Eich admits this you know there
are all sorts of weird edge cases
especially in the syntax and how things
get converted to different types there's
a presentation by Gary Bernhardt called
watt where he just goes through all the
weird things that JavaScript does and
there are actually reasonable
explanations for most of them but still
there are a lot of these little details
that you have to keep in your head if
you want to write JavaScript directly
and over time you know in a small app
they're not going to bother you very
much but as your applications get bigger
and more complex they're going to become
more and more of a burden to remember so
why closure why would we want to write
JavaScript programs in closure
well closure is a very small language
designed around a few very essential
ideas and the biggest one is this
immutable persistent data structures
there are four basic data structures in
closure this is what they look like list
vector map and set and all of these data
structures are immutable that means that
when we modify something we don't
actually modify it we create a new
version of it that has some changes in
it so just as a very quick example if I
define a map a map goes from keys to
values like a dictionary or a hash table
I can then call a function in closure
it's called Assos for associate to add
another key and value on to that map and
I get a new map back
I haven't actually changed the original
map and this immutability is very
important for concurrency which is one
of the things closure was designed for
now that doesn't show up so much in
JavaScript but it's still surprisingly
helpful think about callbacks or event
handlers anything where you don't know
when your code is going to run it's so
much easier when you don't have to worry
about data just changing out from
underneath you
another thing closure is built around is
this idea of manipulating data
structures as the core operations of
your program
so there are is that there's a very rich
library of functions in closure for
manipulating these data structures
keeping their immutable properties and
here are just a couple of very small
examples I could take the function range
which returns an infinite sequence of
integers it's only infinite if I try to
read all of it as long as I don't use it
all it's fine then I can filter that to
get just the even numbers then I can
take just the first hundred of that
infinite sequence of even numbers and
then call that reduce function again to
compute the sum of all those numbers so
you think about that problem that's
something that might take several lines
and a couple of different loops in a
conventional programming language it
boils down to just a single line in a
data oriented language like closure a
little more complicated I've written a
little one-line program to count the
occurrences of vowels in a piece of text
I slurp in the piece of text from a file
and then run a regular expression that
hash quote is syntax for a regular
expression to find all the vowels and
return them in a big infinite sequence
and then call another library function
to compute how often each of those
vowels occurs so you can see there are
about 11,000 OS 15,000 e's and so on
so closure is a very expressive very
powerful language and this is a thing
that people will say after they've
learned closure they say I got into it
for the concurrency but I stayed around
for the data structures this is really a
liberating kind of way to program but
there are lots of other maybe less
significant features in closure that are
things that are lacking in JavaScript a
simple example are functions with
different era T's the same function that
we can call with different numbers of
arguments now in JavaScript you can kind
of fudge this you can use the arguments
array that's not really an array but you
know you can make it work but in closure
script we can actually define a function
and give it different era T's so this
function greet can be called with no
arguments and then it prints hello world
it can be called with one argument a
name and it says hello name or it can be
called with two arguments and it mashes
those two arguments together into a
single string and we can also reuse the
same function with different era T's of
itself this is a quick way to get
default arguments in closure there are
rumors that Atma script six might have
multiple arity functions but you know
why wait this works right now another
feature closure has that turns out to be
very helpful in JavaScript oriented
programming is namespaces we all know
JavaScript doesn't have namespaces or
modules and they're all these little
tricks that you do to actually get
privately scoped functions and sort of
isolate your code from other pieces of
code in closure script we don't have to
worry about that we create a namespace
we declare it at the top of a file and
then every function in that name in
defined in that file will belong to that
namespace and it will not clash with any
other functions this is safe and it
works another really interesting feature
and this is something that exists in
both closure and closure script it's
called
protocols a protocol is a little bit
like an interface we define it we say
def protocol give it a name this is one
of the core language protocols it's
called I counted and it has a single
function count now that defines a
function count in this namespace C ljs
core and it defines a function but
doesn't give it any implementation so
then we can do a couple of different
things with that we can create a new
type in this example a type called array
chunk that has a few fields array offset
and end and we can provide an
implementation of that protocol for that
type now this is pretty much
conventional object-oriented style
programming here we've created an
interface and we've created a concrete
type that implements that interface but
the other thing protocols can do is that
they can be extended to types that you
don't control so the language itself
actually does this we want the count
function to work on Java scripts
built-in array type and we can do that
by extending that type to the protocol
that we've defined so this is a slightly
more flexible way of dealing with
interfaces and inheritance than the more
conventional ways this is actually
extending the definition of the array
type but it's doing it in a namespace so
it's not creating new functions on the
array prototype that are going to clash
with other libraries and other code that
you might net load finally closure was
designed for concurrency in particular
it was designed around a particular way
of doing concurrency where you have
controlled access to mutable state
remember we said all the data structures
in closure are immutable everything
doesn't change but we can define things
that we allow to change
by replacing their state so the simplest
version of this and the one that closure
script includes is called an atom we can
create an atom give it some immutable
data structure as its initial state we
can dereference that atom that's what
the @ sign means there and get the state
back out then we can call a function
swap and tell it to change the state of
this atom we're actually creating some
new state by giving it a function to
call on the previous state
so basically state in closure is always
a transition from one immutable data
structure to another immutable data
structure and it does that by calling a
function so this function update in is
going to look at a map find a particular
value at a particular key and then call
another function on it so this data
structure this map has two scores in
Italy and Terry both have scores in some
game they're playing and we're going to
add seven to Lee's score and then the
new state of the atom scores is the
updated map now the name atom comes from
atomic because in a multi-threaded world
there's a promise that that change will
be atomically visible to all the threads
that might be looking at that atom now
in closure script we're compiling to
JavaScript where there are no threads so
this isn't as much of an issue but it's
still a surprisingly useful way to think
about State in a typical JavaScript
program you might have lots of mutable
state all over the place variables and
objects that can be changed and it can
be very hard to track down where all the
state changes happen in closure script
state changes are always very explicit
you know exactly where they're happening
and they're usually isolated to a few
small areas of your code can make
programming much much simpler
so again closure script is a compiler it
compiles closure script into JavaScript
now why would we want to do that well it
turns out it does a pretty good job of
it in part because of this extra little
piece called the Google closure compiler
now the naming here is a little
unfortunate there's closure which is a
language on the JVM closure script which
is a version of closure that compiles to
JavaScript then there's closure with an
S which has absolutely nothing to do
with it but closure script uses closure
with an S the two projects didn't know
anything about each other for the record
our closure came first so the Google
closure compiler is an optimizing
JavaScript compiler it takes JavaScript
as input and returns optimized
JavaScript as output and along the way
it can do very sophisticated whole
program optimizations of a JavaScript
program to optimize it for both
execution time and space in download
size so just to give you an idea of just
how good this optimizer is here's a
simple example I wrote a JavaScript
function there and the Google closure
compiler can run in three different
modes whitespace mode is similar to you
know a typical very naive JavaScript
minify or it just strips out the
comments and the whitespace and stuff
then there's a mode called simple which
will do some very basic optimizations
probably most JavaScript minifiers can
do things like this it renames the
function arguments it removes some of
the intermediate variables but it
doesn't fundamentally alter the
structure of the code but where it
really takes off is Advanced Mode
Advanced Mode the Google closure
compiler can basically rewrite your
entire program to something
significantly shorter that's going to
have the same effect
and I am constantly amazed when I see
this this is probably one of the most
sophisticated open-source compilers out
there right now it basically saw that I
was calling this function only once with
constant arguments so it says okay I'll
just inline the whole thing evaluated at
compile time and return the code that
you meant that does what you meant so
the Google closure compiler is very
effective at optimizing JavaScript
output from the closure script compiler
and making it very small and very
efficient the other thing it does is
something called dead code elimination
so similar to hear how it eliminated the
do stuff function if I hadn't called the
do stuff function at all it just would
have removed it entirely so any code in
your program that's dead that's not
getting used in the main flow of the
program if it can determine that it'll
just strip it out entirely and this has
some very interesting advantages when
you're delivering an application over
the web and you have limited bandwidth
because you could take in a whole huge
library of code for example the Google
closure compiler comes with its own
libraries that are many many megabytes
in size but you only pay for what you
use if you're not using some
functionality or some function it's not
going to be there so this is a very
different approach from what a lot of
current JavaScript development is doing
where people are trying to make hand
optimized libraries that are very small
and they do a very good job of that but
they're still limited because if you
want to use say jQuery you're getting
all of jQuery whether or not you're
using all of the features that it
provides closure script is also fairly
efficient it can get very close to hand
optimized JavaScript here's an example
this is a spectral normalization
benchmark it's from the alley off
computer benchmark game I won't pretend
to understand what this code does but
you can see it's got lots of tightly
nested
loop's it's using the typed arrays that
are a new feature in ECMO script six and
it's just doing a lot of mathematical
computation now the same code in closure
script doesn't really look that
different David Nolan mote wrote most of
this and I adapted it you can see we've
got loops arithmetic some arrays we can
create the same primitive array types
that we can use in native JavaScript
when those features become available the
j/s slash is a special namespace that
tells the compiler that this thing
exists in JavaScript it wasn't created
in closure script so the code is not
that different and it performs similarly
now I will be honest here David Nolan
who wrote this example claims that he's
got it running at the same speed as the
original JavaScript code in the latest
version of the v8 JavaScript engine I
personally have not been able to
reproduce that but I've gotten it quite
close and this is a very actively
studied area this is continually being
improved we keep finding new ways to
make the compiler a little bit better to
emit code that modern JavaScript
runtimes can execute very efficiently
and the other nice thing about closure
script is that it's still basically
JavaScript you have access to everything
you have in JavaScript if you want it so
you can use JavaScript libraries you can
use jQuery Raphael whatever there's a
little bit of extra configuration at
Build time and those libraries will not
necessarily get the benefits of the
optimizing Google closure compiler
because they weren't designed for it but
you can still use them you can call
methods you can create objects directly
and it'll all just work there's no funny
syntax you have to use in fact I have an
example this is the Raphael JavaScript
library this is a demo that they have on
their site Raphael is a vector graphics
library for doing things like charts and
graphs and so
worth and this is some very simple
JavaScript code that draws a canvas and
makes a little animated circle in the
middle of it I ported this to closure
script in about 15 minutes it was not
difficult and you can see the code
doesn't look all that different I can
create an instance of the Raphael object
and I can call some methods on it to
draw the canvas draw the circle and
animate it and just to prove that that
works there's a little animated circle
unfortunately I'm not much of a graphics
guy or I would have come up with
something much flashy er than that so
where is this difficult it's not always
perfect where are we going to run into
challenges working with closure script
now the first one that people always
bring up the question everyone always
has is how do you do debugging what is
it like to debug this generated code
you're an extra level of indirection
away from what the browser's actually
executing and yeah it's a little bit
harder than debugging JavaScript that
you wrote yourself but it's not really
that much harder my coworker Jason
Rudolph wrote a blog post demonstrating
some examples of how he did debug a
closure script application that he was
working on so here's what it looks like
this is the WebKit debugger this is
chrome and he found an error message
said type error cannot call method call
of undefined so it tried to call a
function that wasn't defined well where
did that happen it happened in a
namespace that namespace is clearly
indicated in the output JavaScript
source code then we can find the
function that it was happening in we can
see what got called on that line so we
know it's one of those calls in there
that was the problem we can trace that
back fairly easily there's more or less
a one-to-one correspondence between the
JavaScript source code in the closure
script source code so we can find
what line in the original source have
the problem and then figure out what the
problem was oh we call it a function
that doesn't exist we miss type the name
so you know it's not really that hard
it's basically the same process you'd go
through debugging any JavaScript
application another example is profiling
and again it's not really that different
from profiling and optimizing a
JavaScript application you can run any
JavaScript profiler or debugger this
example is using the WebKit profiler and
you can just turn it on in code run the
profiler in WebKit look at the call
stack find out oh this function is
occupying 30% or so of my runtime and
then find instances in the closure
script code where I'm calling that
function and realize oh yeah that's
printing a 30 kilobyte string to the log
every few seconds that's probably going
to slow the app down so this is not
really all that esoteric you know the
generated code looks like something you
can read you can find the associations
back to your source code and figure out
what's going on
finally tooling closure script is a very
young language it was first released
publicly in summer of last year so it's
a little over a year old and admittedly
the tooling and sort of build
development workflow support is still
very much a work in progress it's still
evolving but there are some things out
there already that make it much easier
to get started line again is a build
tool designed originally for closure and
there's a plugin for it called line C
ljs build there's also a tool called the
browser attached ripple or as I like to
call it the bat rebel which is an
interactive console connected to your
application
running in a browser and if we have time
I'll show you an example of that so
here's what line again looks like this
is a build or project file for a sample
closure script project using line again
in line C ljs build you define a project
give it a name I call this Java one
examples my project add in the C ljs
build plugin and then tell the clj s p--
little build plug-in how you want to
build your javascript application in
this case i'm telling it to compile to a
single javascript file using the
advanced mode optimizations and not
including any white space or pretty
printing in the javascript output so
those are both fun closure and closure
script or great languages but where they
really start to shine where you really
get to have fun with this is when you
combine them when you put a closure web
server communicating with a client
application written in closure script
running in the browser all of a sudden
you can share data back and forth
between a server and a client in the
native format of the language every data
structure in closure and closure script
can be printed to a string it has a
string representation then you can read
that string back and get the actual data
structure representing that string so
this is now called extensible data
notation it's sort of an answer to json
but it's much richer than json you saw
we had in addition to the standard lists
and maps we had maps that could take
arbitrary keys
we have arbitrary precision numbers and
this has also been implemented in a few
other languages so now you can exchange
this data with any language for which
there's an edn reader and there are
several of them now another really neat
thing about edn and about the literal
syntax of closure and closure script is
this thing called tag literals now this
is a way of specifying
type 4 a value independent of its
in-memory representation so an example
that's built-in to closure and closure
script now is inst for instant is a tag
it's written that way hash sign I NS t
and then a string the format of the
string is rigidly specified it has to be
in that ISO format but any particular
implementation is free to choose how it
wants to represent that instant so on
the JVM I can represent that as a Java
util date or a Java util calendar or a
Jodha date or whatever type I'm using in
my application and in JavaScript or in
closure script it'll be read as a
JavaScript date so what this means is we
can have well-defined typed information
that has different class names or
different concrete implementations in a
client and a server so think of all the
times you might have had to put
something in a string because that was
the only format that both ends
understood this happens a lot in JSON
everything gets turned into a string and
you have to remember when you get it at
the other end to turn it back into
whatever the correct type is with tag
literals it just happens automatically
another really neat thing you can do is
share code between the client and the
server this is I think one of the very
few languages that can actually do this
right now we can write the same piece of
code say data validation a model some
you know templating logic even and we
can compile it once for closure run it
on a web server with you know multiple
threads and all the performance of the
JVM then compile it again as closure
script and it'll just work everything
will work any code that's just
manipulating those data structures which
as I said is the bulk of what your code
will do anything that's not calling the
host platform so things as things that
are not calling methods on native types
or calling constructors of native types
you can just work
so it's very easy to port code between
closure and closure script frequently
it's automatic fairly soon I expect
we'll have something called feature
expressions which is basically some
extra syntax that will make it possible
to write the same source file and
include different variations for closure
and closure script so then you actually
can have the same source file that will
be compiled in a compatible way for the
two different platforms so that's pretty
much all I have here I've got some slide
notes there I don't generally distribute
slides themselves but a copy of all of
the source code and all the links that I
included in this presentation is
available there there are some other
conferences where I'll be speaking and
this slideshow itself is actually a
closure script application it's tied in
with emacs org-mode so it's kind of a
special case but it's very useful for me
and finally I have a book coming out
with Luke van der Hart from O'Reilly
called closure script up and running
this is available in beta early release
now online and it'll be in print soon so
I have about 10 minutes for questions
and thank you for coming
question can you target nodejs yes you
can there's an extra option of the
compiler that emits a few extra things
for node J s not heavily used at the
moment but people have done it yes yeah
so the question is how important is it
for closure script to maintain
compatibility with the features of
closure that were sort of forced by the
JVM in particular the fact that closure
does not have automatic tail call
optimization as some lisps do because
turns out you can't actually do that
efficiently on the JVM closure does have
something called recur which lets you
get most of the effects of tail call
optimization so the answer is a closure
script is designed to be the same
language as closure so it will probably
retain some of those features one I know
right now is try catch in closure script
uses types for exceptions because that's
how try-catch is defined in closure on
the JVM there may be some loosening of
those restrictions especially once we
get feature expressions so that we can
distinguish the types recur will
probably stick around I think there's
some argument that that's valuable as a
safety check but in general both
languages try to embrace the host
platform as much as possible and they
try to not prevent you from getting at
any of the features of that platform so
that's the best answer I can give you
yes
real-world examples of closure script
well this slideshow so I work at
relevance it's a consulting company we
have done client projects enclosure
script I don't have anything publicly
demo able that I can show you but we
have been using it on projects it's been
a lot of fun to work with and I know
certainly other people are either
seriously investigating it or starting
to use it but again still a very young
language people are just starting to try
it out any more questions yes
is very similar to it at least in our
environment our struggles
so the question is how long does it take
to compile with all of these different
stages including the Google closure
compiler the Google closure compiler
takes a while even a fairly small
application will take 20 or 30 seconds
to go through the optimizer but that's
an advanced mode and you don't need to
run an advanced mode when you're
developing so line seal J is build I'll
see if I can show this actually has an
auto mode so if you can see that this is
compiling some sample code and if I
change one of my source files and save
it you'll see it recompiles it in less
than a second so the closure script
compiler is fairly quick if once you
want to go to production you're invoking
the closure the Google closure compiler
it takes a bit longer
now
any more questions yes you're asking
what what's the maintainability right
right so the maintainability I think in
closure is actually much easier than in
JavaScript partly because you have these
features like namespaces you have things
that were actually designed for working
with larger applications are there
plugins for IDs I don't know if there
are any plugins explicitly for closure
script all of the Java IDs have closure
plugins however and since the syntax is
the same the highlighting and stuff will
still work yes
so why not Jason when communicating
between closure and closure script you
can use JSON it's there there are JSON
readers and parsers written for both
closure and Google the Google closure
library has one that you can use from
closure script the basic reason is that
what you're going to end up translating
it into is the native data types of
closure script and closure anyway so
there's sort of a an impedance mismatch
with JSON because JSON is sort of
limited to the lowest common denominator
of what every programming language in
the world can do which is just arrays
strings numbers and maps with string
keys edn can do a much richer set of
data types that might be easier to
represent the data in your application
questions anyway all right thank you all
for coming I'll be around</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>