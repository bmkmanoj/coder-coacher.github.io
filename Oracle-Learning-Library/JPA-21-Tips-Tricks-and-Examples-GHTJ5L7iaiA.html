<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JPA 2.1 Tips, Tricks, and Examples | Coder Coacher - Coaching Coders</title><meta content="JPA 2.1 Tips, Tricks, and Examples - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JPA 2.1 Tips, Tricks, and Examples</b></h2><h5 class="post__date">2013-01-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/GHTJ5L7iaiA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well we have apparently we have 45
minutes apparently but if I won't look
at my watch then you'll forgive me if
you promise not to look at your watches
this is a birds of a feather session I'm
Mike Keith now birds of a feather are
supposed to be more informal more casual
more conversational
so I'll ask questions you guys answer
you guys ask questions I'll be tend or
do my best to answer but hopefully you
won't feel uncomfortable making comments
or questions along the way as I say the
casual part of this is what makes I
think beneficial to all of us
unfortunately a 45 minute time limit is
a little bit hard so what I've done is
I've tried to separate into different
sections and based on your feedback and
what you'd like to spend the time on
will kind of zero in on the parts that
are most interesting to you and then go
from there so remember casual informal
say stuff I thought about dislike how
could I make people feel comfortable
that's how I could just come in my
underwear but I didn't think that would
work very well I thought well maybe I
could get them to go in their underwear
I didn't want to do that either so I
just have to really leave it up to you
guys to feel kind of as comfortable as
you can and open it up the questions
that you feel Lord you know nothing's
too stupid to ask I might answer
stupidly but that'll be my problem so
the first thing also how many people
here were at Linda session this morning
or this afternoon or whatever Linda did
Mikkel
she gave a JPA session she talked a
little bit hands up high if you were at
that one okay about a third of you so
Linda covered a few things a lot I
unfortunately didn't talk to her
beforehand to kind of work out usually
we do that and kind of work out how
things are going to go we just never had
a chance so she talked about schema
generation I have a little bit about
schema
duration here I could talk about some
other things about schema Jen if you
like we can we can hone in on that she
talked a little bit about converters but
I think there's a lot more they can be
discussed about converters and I think a
lot more people here would be interested
in the converting part this is um for
people who use the clip link there's a
converter feature that's been kind of
translated into the spec hybrid a has a
similar kind of feature called a user
types for those of you who have used
those and like those to be standardized
least that's the one that I've had the
most feedback on over the years so I
thought we would start with that yeah no
no I don't see very many shakes of the
head so we'll go ahead with that and
then I'll carry on from there okay so
the provider looks for these classes
that are implementing a attribute
converter and this is what it uses to
convert the the type the state sorry of
the attribute of the entity type the the
attributes themselves are essentially
basic attributes now basic is kind of a
general term it really just means
anything that doesn't fall in some other
category it reverts to being a basic and
although we don't actually say so in the
spec what generally will happen is you
go through this list of things that you
try to do to the attribute and at the
end of it all if you can't do anything
else with if it's some other object that
you don't know what to do it and not a
known type then you can just serialize
it out if the database type is
appropriate so this allows you to take a
method and do that kind of civilization
if you like or transformation or
conversion on your own and map it now I
say that any basic type strictly
speaking this means that it has to be an
attribute of one of the standard JPA
types an entity an embeddable or a map
superclass right if it's an attribute of
one of those and it should qualify for
conversion there's two ways you convert
you can opt in say I want this attribute
to be converted or not to apply meaning
that all the activity
this given type are going to be
converted using this converter so it's
kind of a catch-all and you should be
careful which one you use depending on
the circumstances obviously finally a
note we district we disallowed various
types of basic attributes to be
converted and just the ones on the
bottom IDs I think it should be fairly
obvious that IDs are kind of a very
special type of attribute that used all
over the place within the provider
they're keyed on it probably wouldn't be
a good idea to be converting a primary
key secondly a version that is a
container managed attribute not
generally used by the application
developer it serves their that the
developer declares but it really the
container is managing it so you don't
have too much business in the way of
playing with that although it is
possible and sometimes people have
thought well maybe this would be a way
to implement some kind of optimistic
locking policy for example and so that
you know it's not portable to do that it
might be allowed by certain providers
but we disallowed that in the spectra
enumerated people when they first read
that to say oh wait a second that's a
really you know that's a common thing I
want to be able to convert enumerated
type that's not what this is saying
there's not saying that you can't
convert enumerated types this is saying
that you can't convert attributes that
are annotated with enumerated because if
you're doing at enumerated then you're
performing something on that enumerated
type already you're specifying the
strategy for example whether it's going
to be an ordinal or string or whatever
and so you're kind of doing something
already if you're going to do conversion
then you don't need add enumerated you
can just convert the enumerated type
yourself and and don't use a numerated
annotation it'll be okay same with
temporal you can convert a date but
don't edit a tit with that temple and
then relationship so obviously you're
not going to convert related entities
again these are just attributes so what
do you do to convert well you implement
and you annotate implement this simple
interface which is called an attribute
converter under the jelly's persistence
package name and those two methods
convert to database column
convert to entity attribute to convert
to database column takes the attribute
itself which is of some type and then
converts it into returning the type that
goes to the database and the other
method does the opposite so these two
methods are the two types rather are the
types of the X and the y being the
entity attribute type and the database
conversion type so the bottom here has
this converter and this is what you do
to the converter class you annotate it
and you may or may not have this Auto
apply on it again the auto apply says
it's going to apply to every attribute
of that type in an entity a map super
class or an embeddable class so it's
pretty heavyweight and you would only
want to do that in certain cases so
here's an opt-in I have the auto apply
in gray so just ignore that for now
assuming you didn't put Auto apply on
there we have a boolean to integer
converter we're going to define the two
types the boolean is the type of my
entity attribute and the integer is the
type that's going to database as so I
convert to the database column I'm doing
a boolean true equals just because this
boolean here may be null right depending
on what's in the entity attribute maybe
it never got set so I have to consider
that case on the other hand the other
one going from the database column to
the entity attribute is likely not going
to be null because something in the JDBC
will probably create some value for it
now the bullet or the bubble up above
has a statement saying that this will
apply to wrapper types as well and so
defining a wrapper type here sorry
primitive types as well so defining a
wrapper type here means that it'll also
apply to primitive types if I have a
lowercase boolean in my entity and I
have an auto apply here at the converter
then it will be a candidate for B
converted and will automatically be
converted by the provider okay any
questions so far yes
this is all there is to it you can
access the attribute itself through this
method that you don't you know you
define this class so you could you could
do anything you want within this class
but you only get access to the attribute
itself you don't get access to the
instance right yeah yeah yeah
any other questions yes question is can
they be chained to go through multiple
converters it's not currently defined
that you could apply multiple converters
you would have to define a sort of
single converter which call those other
converters currently in fact right now
if you had multiple converters on an
auto apply then they would be undefined
which one actually gets invoked because
if they if multiple converters up have
the same target type how does it know
which one it won't just do all a little
it'll try to pick one and then be
undefined
any other questions
so on the application side use the
convert annotation so this is a kind of
annotation that's meant to be used
well it's multi-purpose really but the
primary use of it is that it's an opt-in
mechanism to say I want to convert this
specific attribute and the converter
class will be used to say what converter
class should convert this attribute the
attribute name is specifically used for
when you have a map or when it's
embeddable and you have to use a dot
notation to get in to which attribute
within the embeddable you want to
convert and we'll show you an example of
this in just a minute and the disabled
conversion is when you have an auto
apply and you want a specifically sub
case where this one isn't converted so
everything else is converted but this
one is turning off conversion all right
so here's opting in and using the
convert as specifying the converter
class and this is the typical case where
all you do is you specify the class and
here I have a column on there as well
and I've obviously forgotten the bracket
but the preferred status is going to be
then converted using this boolean to
integer converter class funny story I
actually had these slides and I didn't
back them up a week ago and I lost my
hard drive so you're seeing a second
copy of these slides which are only
probably slightly resembling the first
copy there's stuff that's here that
wasn't there and the stuff that's there
that clearly wasn't isn't here so you
get what you get here are some examples
of nested conversion I've got an element
collection so I can convert a collection
of things a collection the basic so I
could have a collection of strings just
a list of strings and then I would apply
the convert annotation it would convert
each of them in this case I've got a map
keyed by string with elements that are
strings and if I don't say what I'm
converting the default is just going to
be the value okay just like anything
else when you use annotations the
standard practice is that you're
applying that to the value unless you
say that you're doing to the key so here
I'm saying
using a phone number converter class and
converting the values in this map the
second example here or attribute is an
embedded attribute called a count detail
and here I'm using the attribute name
I'm converting a URL and it's the
transaction history URL within a count
detail now if I have nested of edibles
then again I would use a dot notation
okay I would say you know if I had say
some other embeddable within a count
detail like address of the account
holder I would say address dot city and
then have some string converter applied
to the city for example alright lastly
we have a relationship where we've got
transactions stored and they're keyed in
this map by a basic object a date
so I'm converting the date and to
indicate that I'm using the attribute
name of key okay so this is dedicated
name key we've used this in other
examples or in other cases in the JPA
spec where you say key and that
indicates that you're talking about the
key to be converted again if I had an
embeddable object that was the key of
user dot notation to indicate some
specific attribute of that embeddable
object any questions about these no okay
okay so that seems to all we're fine
however some things you should be aware
of when using a converter here we have a
simple query that's looking for all the
preferred customers well we're
converting preferred stats so the
provider knowing that it's being
converted has to then go ahead and
convert the operand the other right-hand
side of that expression okay so I'm
executing this query what if I have this
table I've got some accounts
and I've got some stat I that write or
statuses I don't know that are sitting
in this table and let's say that one of
them has you know legacy wise has the
status of two because I don't know there
used to be a gold preferred status but
nowadays we just have preferred or not
referred and an greater than zero was
our test right I went back we had our
test our conversion it was greater than
zero in the database then it must have
been true
so he's preferred well what happens now
we have a fail our quality fail is not
going to work why well because we have a
bunch of mappings of integers to bully
ins and we said okay all these integers
are going to map to the anything above 0
is going to map to true but going the
other way my converter says oh if it's
true I'm going to map it to 1 so when I
map true what's the sequel did it come
out like select all the accounts where
the preferred status is equal to 1 and
I'm not going to get this poor gold
prefers that the guy who's the most
preferred doesn't get selected isn't
that bad so we have to be careful when
we that's that's the only lesson of this
I'm not giving you this to to show you
how stupid I am I'm just showing you
that you can make mistakes and if you're
not aware of all that's happening here
in particular you're not aware that the
provider is going to be converting these
values in your sequel or sorry in your
JP QL to end up in sequel then you could
end up shooting yourself in the foot
alright so that is converge
anything about converters that you want
ask before we leave convert last chance
that's not your last chance you can ask
me later oh you want to feel he doesn't
trust me how would it work around the
situation well that is a good question
the way I would work around it in this
particular situation is I would know
that there would be two values
potentially in the database that mapped
to true
so when my convertor function that said
greater than zero is is true I would
know that a 1 maps to true or 2 maps to
true
likewise in my preferred status I could
do one of two things I could say map
another value I could do a different
conversion and say where preferred
status is equal to this or that and then
can provide that in my conversion in
other words if I had some value of 2
let's say I put 2 in here so it's going
to take this value automatically and put
it through my conversion routine my
conversion routine can do whatever I
want it to do because it's my routine
I'm defining it so if I have to then I
can put 2 in there and it's going to do
a check for 2 as well or I can put a
second Clause on there and say where
it's equal to this and Orser or it's
going to be equal to that so I could say
true extra preferred or true preferred
if you don't mean so because my
conversion can handle it both ways I
could actually manage that but I would
have to still jigger with my J pql I
have to add an extra clause to make that
work right and I'd have to rely on the
fact that the provider is not going to
look to see oh you know what this is
really boolean so make sure that it's
still the boolean type and that it's not
going to it's not going to fail going
through the conversion process before it
even gets to square one any other
questions
Oh
you speak up a little bit I'm not deaf
right so so if I can just rephrase that
question
okay rephrase the comment the comment is
what tell me if I've got it wrong what
I'd like to have is a more abstracted
type of converter that could say I want
to apply this converter to any type and
I can apply this type at runtime is that
correct
so I can apply a conversion of I can say
a an X converter to Y converter and I
would know somehow in my X converter to
Y converter based on whatever type is x
and y that I can I can do this
conversion so for example if you're a
numerator type I'm having a numerator
type two integer and you can accept any
numerator type and you convert that to
an integer that's an abstraction over
and above this right you're sort of
generalizing it and so I mean to some
extent you can do that you can have a
superclass if there are subclasses if
there's a hierarchy there you could do
that well that's no different from what
you're doing because you're gonna have
to have a case statement yeah
no I don't think there's any difference
there because you would still have to
you would have to entertain each
attribute anyway or you're going to do
Auto apply yeah but that's the same
whether you do it abstractly or not it's
you have to add a convert to add convert
or you don't auto apply there's the two
choices whether or not it's an abstract
converter or not I don't think that
changes but so I argument is that I I'm
not so sure that that's too useful but I
could just be me maybe it's really
useful I just haven't I haven't seen it
yet but if more of you feel that way
then let us know and we can look at it
my feeling would be it would actually
complexify add more than be worth doing
I think but oh yeah
Hey well so I'm assuming you can't
change legacy code you're not going to
change database code that's dbe's don't
like that much I don't know how many of
you guys had to work with DBAs they have
long white beards and they're really
stubborn but but the J pql code
generally isn't going to be legacy it's
something you have more control over
because you're writing it that's why I
say you can add a clause on to that one
and have different values mapping the
same one that was the only reason they
gave that yeah that depends on the
provider again I mean even my fix
depends on the provider so maybe your
fix is as good as or better than mine I
mean I we haven't defined exactly
whether the provider has to type-check
that value against the original NT
attribute okay so if it doesn't you know
maybe that would work out better I don't
know but there going to be other
problems that you could hit bump into in
this the same area I just only gave this
kind of funky example because just so
you knew now you'll never make this
mistake
hopefully all right so well I was
probably 25 minutes of converters but
worth it right what do we want to do
next
there's query enhancements there is
let's go back doggone it he's stupid
bubbles oh there we are Stewart
procedures some of these query
enhancements and stored procedures well
they've been in the JPA 2.1 spec for the
last year or so I mean they've been
introduced in JP 2.1 and we haven't
released until ask Java one at least so
they're still there but for those of you
who haven't seen them we can talk about
that the new thing unsynchronized
persistence contexts is is we've added
since then that's mildly interesting
schema generation Linda talked an awful
lot about this morning but again that's
kind of mildly interesting I don't know
from my definition of interesting it
might be completely different from yours
who's interested who wants to call it a
day and go get coffee I don't know okay
how many people vote for query
enhancements my goodness we have a
winner I'm not even going to ask I'm
going to save the X of 30 seconds and go
on to query enhancements darn these
bubbles okay
there's five main query enhancements
that I picked out there is actually more
that we've added but these are the kind
of ones that I see is having some value
or the ones that I get asked for the
most down casting now we already jpq el
queries are polymorphic already they are
you'll get all the subclasses when you
ask for a class you'll get it subclasses
as well we introduced a type you know is
something of a particular type to kind
of allow you to filter based on a
subclass but now with down casting this
allows us to access the state of the
subclass all right and you can do that
both in the from or the where clause so
in the first example I'm selecting the
name and the ID from the customer and
I'm joining the customer account
treating it as a savings account what
that does is allow me then to access the
balance of the savings account
assuming that balance wasn't also on
account I'm not sure why it wouldn't be
but let's just assume that this was a
savings account specific state and then
I could access it within the where
clause and do a filter on five hundred
thousand awesome
the second example says well now I'm
going to select all the employees but I
want to select them based on different
criteria all the full-time employees
they have a salary if their salaries
greater than 50,000 I want them returned
but if they're a part-time employee Dan
to get a rate of pay a pay rate and
they're getting $100 an hour so all the
employees that are either full-time or
salary full-time or part-time and
getting salary of 50,000 or a rate of
100 will get selected you see that see
how that works it's kind of useful
sometimes any questions about that all
right
this is move on Oh
all right let's go back what happens if
there's a if there's more than one type
of account well it'll only pick the
savings accounts yeah yeah yeah that's
that's the idea of this one is that
you're only using joining across the
savings accounts well because this is a
crappy example that's why I wanted to
save space but if you were me you would
have done that yeah you would have done
the smart thing I didn't okay any other
questions before I after I've gone all
right let's go on to other joints with
on this doesn't do a whole lot other
than just add a condition to the outer
join we already have outer joins
obviously and what we can do is we can
say on some other condition and that
will include that in the outer join
in other words allowing it to the null
in those cases so that's different from
the bottom one where I including the
amount is equal to 100 or balance is
greater than 10,000 where it's part of
the filter they will get included so
there's the difference between the top
one at the bottom one including the
condition in the on is including it in
the outer joint itself in the bottom
case I'm actually filtering against it
so the regular filter rules apply this
doesn't happen very often
I'm not sure why I put this in here
I regret it Oh question that's why I put
it in can you the question is can you do
an or on the on condition well no not in
no would ya it wouldn't make sense any
other questions
okay you know how in jpq l you can you
can do select to new and then maybe you
don't know that you know that by the way
in jpq l you can select new some type
which is not an entity type and then put
a bunch of put a bracket some fields and
end bracket it'll use the constructor of
that class and create a new instance of
that class based on the results from
your query for those of you didn't know
that you probably already all knew that
and some of you may have also wished you
could do that with native queries how
many people here wish they could have
done that with native queries I'm sure
there's many more that aren't putting
your hands up that's why we added the
feature because we knew inside
yourselves you always want them to do
this we've given you what you wanted
exactly even though you didn't know you
wanted it you can now have a native
query that does a select and in this
case we have a result set mapping that
is how many people here use native
queries at all wow that's a lot I think
that's on the it's on the it on the rise
it used to be you know three or four
years ago what I've asked people one or
two people who put their hands up and
they did it embarrassingly you know like
now you guys like with pride right no no
it's gets on there it's on their eyes
for sure well here I'm specifying a
result set mapping of customer details
result and so this makes it clear here
this result set mapping is using a new
annotation called constructor result and
that just says well here's my target
class which is a fairly nonentity class
but it can be an entity class as well
and by specifying an entity class it
will create an entity which is detached
and then it'll use these columns which
are the columns sorry I destroy beeping
did anybody else hear that beeping it
kind of makes me nervous I'm Canadian we
don't have beeping going on around here
in conference centers but here I'm
nervous and I cross like security or the
border and I get nervous what about your
so here we have these calm results that
are specified in the order that
constructor expects them and that class
the customer details class will have a
constructor that accepts those four
things and it will be instantiated just
as you expected them and always wanted
them to be yeah the question is when the
application is deployed will it fail
fast is that your question and the
answer is not typically because at
deployment time there's not a lot of
validation that will happen in these
kinds of things there's no we don't
define in the spec whether you have to
or not if it's a it wouldn't be too hard
to do so it's possible that a provider
might but I wouldn't expect it to any
other questions does it support nested
constructors no it does not
no how would that be what you wanted to
support necessary constructors anyway
what would you what would you expect it
to do you would you allow it would you
want to be able to put a constructor
result inside this constructor result is
that how you want it to do okay I'll
wait and see if someone else asked me
for it see me in five years
oh I don't know maybe maybe we'll get a
flood and that that's I never heard of
that what a nasty constructor oh this
that I can answer the other one he'll
have to answer this is when you have a
native query so sometimes people want to
return results that are not managed
they're just sort of a bunch of data but
they don't want a bunch of fields all as
a result set rows you know the way you
get from G to BC they want to have
structure to it so they put them in non
entities that they're not saving or
never being persistent that's usually
the case why you use the new in J pql so
now we've just you know given parity to
the native queries as well where they
also can have these constructor results
of non entity classes being created that
contain a bunch of data that's that's
pretty much the case
oh good question yeah no you can't I
wish you could though questions can you
have variable argument constructors
variable argument constructors so we
know dot dot dot and no I don't think
we've ever supported that in GP QL but
if we add it in GP q ll probably add it
here too that's all I can say okay let's
move on I'm answering too many knows I
gotta move on okay
this was actually more common than you
might think people want to have named
queries because name queries are cool
and like it's really a lot nicer when
you have a named query stashed away
right it's been precompiled it's ready
to go you just execute it but the
problem is people didn't want to have to
predefined these name queries they don't
wanna have to have an annotation with
the query in it they wanted to be able
to create the name query say
initialization time or something and
then have it ready to go and I want to
do the same thing myself so I certainly
have sympathy for this and so that's why
we put it in the idea here is that you
create a query dynamically and then you
add it to your set of named queries that
exist in your entity manager Factory and
so the second or the first thing is just
creating regular query the second one is
env manager factory add named query and
then you're adding it and that gets put
in your set of name queries that the nd
manager factory keeps track of and then
I can use it anywhere else in code
attain cranium query and I get my
pre-compiled query and it's I do bind my
parameters and go so it is really quite
handy I promise
should be no questions about this
because it's pretty straightforward I'm
not answering them anyway because this
is cooler in line database functions now
this is cool because it allows you to
access the power of your database
functions that we don't have to define
all the functions that exist in every
database okay we started down that road
we have a bunch of numeira
functions we have a bunch of string
functions that we started adding to j PQ
l but you get to a point where you don't
want to do that anymore right
specifically when this functions
available that aren't even there on most
databases they're only there for one or
two databases or one specific database
and so by allowing you to plug into that
function J pql directly then this allows
you to call it the function but still
use j PQ l now this is cool but it's
also bad why do I have an uneasy feeling
about this anybody want to tell me the
whole point of j PQ l is you don't have
to bind yourself to a database right and
here what we've done we've allowed you
to bind yourself to database so yeah
it's kind of greasy but I know people
ask for it
and they keep askin till they get it so
we finally give it I know just like dad
just giving out allowance but that's
that's kind of it's important for some
people and at least it's limited right
you have functions that are there and
you could write you could actually know
have some predefined function for a
database and you couldn't move to
another database and the function
doesn't it doesn't exist there you could
use your define it and create it there
right so you sorta if you look this the
right way and squint short procedure
queries well we have seven minutes so
what do we have laughing at unser grants
persistence contexts stored procedure
queries and schema generation how many
people here voted for procedure queries
okay how many people here vote for
unorganized persistence contexts only in
four schema generation okay schema
generations out how many people vote for
either of four procedure queries or
unfreeze entrance persistence context
straw procedure queries unsink pc's ah
and they're killing me
okay I really can't do both I'll try to
do both okay I'll try to do both
here's store procedure queries I'll show
you example I create a stored procedure
here like this admin store procedure
query this is a static stored procedure
query so I have an annotation just like
a named query right but it's named
storage for name stored procedure query
I named it and I have the procedure name
this is the database procedure name and
then I put the parameters and they're
specifically stored procedure parameters
I have to specify the name of the
parameter the mode this is whether it's
in out or in out or in some databases a
wrap cursor from one return result set
and then I specify result class if it's
returning the result class it may not be
it might just be returning a value or
nothing right just an update count
depends on the start besito how would I
execute it well I bind the parameters
and then I call one of these execute
methods just use actually heute it works
all the time and I say get result list
to get a result list or get some result
to get a single result I have to once
all the results are obtained I get
output parameter values for the out or
in out values and it looks something
like this create name store procedure I
create it this is the name of my throw
procedure I set the parameters of the
inputs if I have defaults then I don't
have to set the parameter if I don't
want to if the default value is good
enough for me I'll use it and I actually
cute it I get the result list and now
after I get result list I've drained the
results that I can go get the output
parameters and get those any questions
no moving on unsynchronized persistence
context unsynchronized persistence
context are good for one main thing that
is if you have a some people would like
to call a conversation some people call
an application transaction really it's
essentially a bunch of operations that
each involve a single transaction but
you want them all to be atomic in one
logical transact it's not a real
transaction I call our logical
transaction because you want them to
either to be atomic tag to occur
together or not occur so if I want to do
this right now it's a little difficult I
can do it but it's difficult it involves
having non-transactional calls and then
creating other transactions and then
creating different types of beans and so
on so this was the case that we were
trying to solve what you can do with
this unsynchronized persistence context
that does not amount to join the
transaction is you can call all the
regular things that you can do in a
transaction like persist or merge remove
these sorts of things these are regular
transactional operations but you're not
a transaction in progress you just got a
persistence context so you're running
around changing things in your
persistence context but it's never
writing anything on to the database it's
just keeping them all stored up
meanwhile transactions are starting
they're being committed they're starting
being committed and meanwhile you're
doing nothing your persistence context
is just staying as it is that's the idea
of an unsynchronized persistence context
the key to the unsynched PC is that you
can cause it to be synchronized and
being listed in the transaction anytime
you want all you have to do is call
joint transaction and that will cause it
to be synchronized with the current
transaction there must be transaction in
progress once you join it it will get
synchronized when that transaction
commits but only for the life of that
transaction okay
now this can add unsink PC can happen on
different kinds of scopes it can happen
on transaction scopes although would
make a lot less sense on a transactions
go PC right that would be if you wanted
to control when it joined three minutes
I also want a time for feedback I guess
I'm not doing well there either
so if there's a new transaction then you
will not be joined to that transaction
unless you explicitly against a join
transaction so it's a one-shot deal each
time you want to be part of the
transactions a joint transaction
normally you'll only say it once that's
when you're done you have all the
changes stored up on your PC and then
you want them to be saved and here's
here's the example I've got a shopping
cart this is a traditional stateful
example I've got a cart I specify it and
again extended is the type of
persistence context that is going to
make the most sense for this alright
this transaction scope doesn't make a
whole lot of sense I mean you can there
are a couple of cases but generally this
is what you'll want to use it for in a
stateful session mean so you'll have
your entity manager and then you know in
some initialization here you'll create a
cart you'll add some item to the cart
and you're persisting the item you're
adding it to the cart it's just getting
stored away at some point user says yeah
I'm done on my shopping I want to buy by
now and so complete purchase gets called
and I say ok joint transaction and all
my changes in their persistence context
get foisted into the transaction
synchronized and a commit time they all
get written out so that's the use case
that under grants persistence contexts
meet there could be a couple of other
cases but it's essentially explicit
control over the enlistment of your
changes now there are some problems one
is a cache if you're doing this and this
transactions going on you know
meanwhile the longer this happens the
more your cache could be out of date
because your persistence context is
acting as a cache so optimistic lockstep
shion's could happen you can't use
pessimistic locks because you can't know
right there's not transactional you
missed that boat the second one is the
data source what happens if you have a
JT data source but you're not listening
in the transaction you're reading things
from the database potentially that are
transactional and not committed for the
existing JTA transaction things are
being changed and written out and
committed you're not committing anything
but other things might be people other
people who are using the JT transaction
might be writing stuff out other
resources if you're reading from that
same transactional connection but not
writing out you could see some
uncommitted changes one of those changes
what
the transaction rolls back and you
didn't know about it you don't care
because you're not synchronized you
could be using uncommitted data in your
PC so that's why we say specify a non JT
data source as well if you using this
feature and lastly well other things are
committing you can't roll them back if
you have multiple commits happening then
you say oh you know what I don't really
want to do this anyway I'm not going to
throw in my cart well other things I may
have committed those JT transactions got
committed right you can't uncommit them
so depending what happened let's say it
was a message message queue he started a
transaction and sent a message to some
other back-end system that's at all
guess what you know Google wants to know
that you're buying this right and that
message got committed said to have
Google thinks he bought it hahahaha
right it doesn't know because it got
committed so those are some issues to
think about and be aware of and that's
all I promise because kheema generation
oops I did want to ask what your current
pain points are and I also being that
I'm working on the next version of an
approach APA book I want to know what
pieces got missed there so if you have
any suggestions please let me know about
that
and feature requests for to point to
anything else that you might have we
don't have time now but I'll be outside
if you want to talk to me and give me
your input thanks a lot for coming guys</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>