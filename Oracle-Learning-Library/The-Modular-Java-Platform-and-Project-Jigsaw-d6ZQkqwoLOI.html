<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Modular Java Platform and Project Jigsaw | Coder Coacher - Coaching Coders</title><meta content="The Modular Java Platform and Project Jigsaw - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Modular Java Platform and Project Jigsaw</b></h2><h5 class="post__date">2013-01-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/d6ZQkqwoLOI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Mark Reinhold i work at
oracle on java have been for many years
and this talk is about the modular drop
a platform and project jigsaw so this is
an update relative to last year some of
the material will be kind of the same
because i don't want to make sure i can
introduce concepts to people who haven't
seen this before so if you have seen it
before you know bear with me but they're
there there's definitely new stuff in
this in this talk so what i'm going to
talk about first high-level any of the
goals of this project the status where
we are where we aren't going to be i'll
describe modularity concepts in
particular the module declaration
language that we that we've been
designing and prototyping and working
with i'll talk about packaging concepts
relates the modularity concepts to
actually actual packaging artifacts both
a java specific module file format as
well as native OS formats and finally
i'll talk about monetizing the jdk which
is one of the ultimate goals of all this
and given the size and scope end and age
of this model that the code base is
quite a challenge so goals and status so
what are the problems that we're trying
to solve one of the big ones is is
application construction packaging and
and installation in a publication and
installation you have the famous jar
hell problem it's it's kind of kind of
sad that the large java applications are
so brittle in that they're typically
constructed with a class path of tens or
dozens or even hundreds of jar files
I've seen I've seen applications inside
to Oracle with class pad with the
classpath over a thousand jar files
which is kind of frightening looking
back at the history of Java if you know
if there's one thing I could I could
have changed if I had had the power to
change in nineteen ninety six or seven
and of course I was very junior guy at
the time it would have been
let's introduce a module system because
this thing is going to grow like weeds
and it's quickly going to be out of be
out of control and well that happens so
now we're having to go back and do it
all the hard way so solving jar hell is
is a big goal another big goal is to be
able to scale the platform scale the SE
platform down to small devices and
actually converge java SE with a higher
end and me that is the the cdc platform
you know moore's law is now giving us
enough transistors on really small
devices that we can run a stripped-down
hotspot vm and and we can we can run
actually all of SE if there's not enough
static memory to hold it there isn't
always so being able to have a
well-defined subset of the platforms
that you can configure just the parts of
the platform that you need delivered
them with with your application will be
a compelling way to get the SE platform
to scale down and then finally you know
while we're doing all this we have a
great opportunity to address some
long-term performance problems one is
download time you know it is still
interesting you know that the old
problem of downloading Jerry's on to
come to consumer desktop laptops and
other devices you know when the minimum
windows JRE even though it's highly
compressed is I think it's still a
wrapper around 15 megabytes you know
especially if you don't have the luxury
of a fast line that can take quite a
while let's figure out how to do just
just the part of that that you need and
also startup time you and the more stuff
you have on the classpath the more start
out the more time you have to spend
scanning it just to get the JRE started
up and that's painful so the solution to
this there is a magic bullet well no
there isn't but it kind of looks like
one at a high level is to modularize the
platform introduced a module system use
it to modularize the platform and also
use to modularize applications so it
enables us to escape from Jar hell we
eliminate the classpath we record
dependences amongst modules directly in
source code it's you know it's just more
facts about about your code it shouldn't
really be anywhere else we can package
modules you
very easily for automatic download and
install them will actually demo that in
a little while we can also easily
generate sensible operating system
specific packages so we can provide a
very natural installation experience on
platforms that already have good native
packaging systems we can scale the
platform well well specified subsets of
s ii can fit into small devices and we
can improve performance we can download
things incremental ii on-demand just
install the stuff you need we can also
optimize module content during
installation when I one of the long term
things that I expect jigsaw to enable of
the model system to enable and I'm quite
excited about this is we can finally
finally have a sense of a way of doing
ahead of time compilation when you
install a module we could do basic
compilation of methods in the native
code and it won't be highly optimized
but it could well be enough to make
startup time significantly faster it's
possible to do this with a hairy class
path today but to actually make it work
is very very difficult there are people
who have done this and if you ask them
they they will explain to you how
difficult it is okay so what is project
jigsaw it's partridge excited I level
has two phases in the first phase we're
exploring a particular part of the
modularity solution space you know there
there's one part of that space has
already been explored very thoroughly by
osgi and similar systems we're taking
the opportunity to explore a different
part of it taking on some some different
design principles we're trying to build
something that is simple yet scalable
we're trying to build something that is
approachable by all developers but
powerful enough to modularize the JDK
and and also importantly we are
exploring ways that we can leverage the
ability to change the virtual machine of
a language and the libraries to come up
with a really good module system which
is something that osgi was never able to
do because it always had to build on top
now it's still you know it's still
impressive what osgi was able to do
given that limitation anyway
so partner you phase one we're exploring
this other part of the design space
because introducing a module system to
the Java platform is something that we
can only do once you know it this isn't
going to be like like like a
java.util.date we did java.util.date in
in java 10 and we realized that sucked
and then we did java.util calendar and
java 11 and that hasn't worked out so
well and now we're trying to really nail
at this time with jsr through 10 on the
daytime api to really hope it does but
we can't play that kind of game with
something as fundamental as a model
system we have to get it right so it's
important to explore as much of the
design spaces we can before we get into
phase 2 with page to project jigsaw will
shift gears and become the reference
implementation for a specification to be
created by the expert group of a
forthcoming module system jsr because
you know since all important
specifications are governed by the JCP
this is how we have to do it and it's
the best way to ensure that everybody in
the wider in the wide java ecosystem has
an opportunity to give their feedback
and comments into that process so that's
what that's the that's the two phases of
a project jigsaw and at the end will
commit the transaction and we'll have a
model system hopefully one that everyone
can use okay we've made a lot of
progress since last year I'm not going
to go through every every little little
detail here but we've we've struggled
with some really tough problems trying
to understand the best way HR trying to
come up with a a clean conceptual model
for a module system yet still have the
expressive power we need to modularize
this enormous legacy code base that is
the JDK so among other things we've
extended the module declaration language
with three with three additional
concepts exports views and services and
I'll show all helps you show two of
those laters late later on we've done a
lot of internal plumbing work that isn't
very glamorous but
in some cases was pretty tough for
example we have the hot dog spot vm now
bootstraps k can can bootstrap itself
reading reading the primordial classes
through a native interface that is part
of the module system this is work that
Mandy did and Karen Kinnear did and this
required me a deep surgery under the
covers to make it happen our earlier
prototype has just had a hack basically
where the hotspot vm knew where a
certain way we're inside a module
library to find something and assumed it
was in a certain format but whenever we
changed that in the module system build
hotspot would break and that was no good
so to sum now we're doing that the right
way we've converted certain security
providers in into true services we
implemented the removal of installed
modules answer duh we have the ability
to compress installed modules this is
important for for some embedded devices
where they have there's enough
processing power to do decompression of
class files on the fly so you can
actually save save time because memory
bandwidth is so limited you can save
time by compressing all the class files
in the module library and then
decompressing them as you load them into
the vm right of other other things here
we now have a very tiny subset of
Berkeley DB integrated in their jigsaw
code not quite using it yet but we're
going to use that for stored module
configurations that will make make
modules start up very very fast and
finally we also have matkins lara 64-bit
builds and finally finally that we have
early access builds so we've been
shipping early access build since i
think around june maybe a little earlier
they're not weekly be weekly they're
kind of irregular depending on when we
make some make big changes but you can
get early access builds at at that URL
when we update them we send an email out
to the jigsaw death list so you can
subscribe to that if you want to get
updates ok status so as many people
probably know by now we took a hard
decision a little earlier that they're
well late late this past summer
to defer jigsaw be of the entire
modularity effort from Java 8 to drop a
9 this was painful this wasn't fun but I
think it was the right thing to do it's
you know if you can see if you can see a
year out that something is unlikely to
make it it's better to better to defer
them to defer it three months before
you're about to ship why did we do this
some significant technical challenges
remain the there's this entire sub
problem of dynamic modular ization which
all of which I'll go into a little bit
later wherein in module in module mode
with jigsaw the the mode of operation is
quite different from the regular
classpath mode in some you know small
but but important ways and chasing down
all the different places that are
affected by this is if you take some
time another thing we haven't done yet
is is support for containers by that I
mean things like ed application servers
or applet runners or IDs that want to
have you know dynamic plugins and things
like that to support containers well we
need the we need a reflective API on the
module system itself so that an app
server for example can load can and tell
the module system okay now i went to
load you know this web app over here
that's in a set of modules that were
delivered to me in a modularized you
know war or whatever it needs to be able
to change the module graph at runtime
create a sub graph of the regular module
graph hook everything up and then when
that web app if that web app is under
played has to be able to dissolve that
module graph and unload everything you
know it's something the weed that we
know how to do but it's going to take
some care to get it right so technical
challenges were one reason for the
deferral the other reason and i think
the more significant reason is we were
just running out of time for the broad
review and testing and feedback that a
change of this nature requires this is a
profound
change to the platform it's not
something that we should rush in it's
going to affect the entire ecosystem the
long run so given that the the the
essentially the eight the specification
freeze date is you know at this point
about seven months away it would not be
it would be the wrong thing to try to
rush it in you know even even though it
is disappointing that have to defer it
anyway so I made this argument he and in
my blog a couple of months ago there was
a lot of discussion in the community we
discussed this in the java SE eight jsr
337 expert group and the end in the end
decided to defer it and i know some some
folks are disappointed with that i
myself am disappointed with that but as
i said i do think it's the best decision
okay that's it four goals in status
let's let's move on to some concepts so
this is a a little bit of a deep diving
into the module declaration language
that we've prototyped in jigsaw the
fundamental concepts are grouping
dependents versioning permits optional
modules module aliases exports and views
so this list is a little longer than it
was a year ago okay so let's start at
the beginning grouping here we have a
class calm calm dog who made that main
it imports some stuff it's fairly simple
presumably there's there's a main method
in there we compile that we get we get a
main class we have we have we have some
other stuff there's there's a calm few
other class nearby we compile that we
get comfort whether there's maybe a sub
package called kombu you I we compile
that we get one more thing you know
we've got now got three related classes
we want it we want to describe these as
being in one module and the way the way
we do that is we have a new kind a new
part of the job
programming language called a module
declaration module module declarations
go you by convention go into files
called module dash info Java this is
expanding on an existing convention of
package info Java which is a source file
where you can put package annotations so
this is this is this is where you put
module declarations and this is really
really simple you just say module combat
foo and well there's a opening brace and
a closing brace because I'm not saying
anything interesting about it yet but
don't worry I will so you say this and
then let us at least conceptually you
now have a module and in terms of the
file system layout this this this is all
works in the natural in a pretty natural
way module dash infotech job is just at
the root of that part of the source tree
as you'll see you later a module can
have an entry point so conga food on
main presumably has the main method of
this application so in the module
declaration if I just say class combat
boot main that declares the entry point
and then once I've installed this module
and all the modules upon which it
depends I can tell they'll drop a
launcher rather than give it the name of
a class and a big long hairy classpath I
can just say go run the module comm got
food it'll go find the entry point and
poke it and make everything up okay
external libraries suppose suppose this
app depends on some stuff in or Bart
libs something or other and Ed Vaizey
util something or other the traditional
way to solve this of course is to
descend into jar hell and have a bunch
of dryer files in a class path you know
that that's that's the world we're
trying to escape from so in the modular
world we declare dependences in my MA in
my declaration for the konbu module I
say requires or bar dot lib which is not
only the principal package name but by
convention the name of that module and
requires a judo and in graphical terms
that introduces arcs we now have a
non-trivial module graph here for the
combat foo module
partner with module and edgy Baz you the
module and the dependences between
versioning yes for your burgeoning is
its own rich topic I could give an
entire talk about it i'm not going to
you can put vertical s let's just say
for now say you can put version numbers
on modules when you declare a module you
give a specific version number when you
require another module you can give a
specific version number where you can
give things like ranges you can say
you'll give me a give me version you
know five dot 200 score 11 or later or
earlier or something like that so there
are a variety of things you can do in in
jigsaw so far we've taken the view that
that the module system shouldn't impose
specific detailed semantics on version
numbers you know that's not a position
everyone agrees with but it's the most
sort of neutral position and it's it's
actually the position taken by the
successful operating system packaging
systems out there okay permits so
modularity a big part of modularity is
encapsulation it's it's hiding things so
that you can change them at will later
and empty because you know that no one
else could have depended upon them so
this graph shows a somewhat Richard
structure we have a compu app module of
the top it depends on campu lib which in
turn depends on conf you secret and or
bar liban if your bath youtube as util
now all this stuff defined in these
bottom modules is is implicitly and it
reacts ported up into compu app
including compucom poo secret but
suppose we don't want that to be Rick's
re-exported because well gosh it's
secret isn't it and we don't want any
other module that might can you come in
later that's not even related to this
application come in and depend upon
concrete secret because we want to be
able to change it whenever we want
and maybe it actually has other secrets
in it so if there's a another construct
in the module declaration syntax called
permits so in the Declaration of the
contras secret module i can say permits
comp who lived that means calm few lib
can depend upon it but no one else can
directly depend upon it and it's types
won't be react sport it cannot be
re-exported out of completely added to
any of the modules that use confu lib
okay there's also a notion of optional
modules sometimes you want to be able to
structure an application so that if some
other module is already installed it can
take advantage of it but if that module
isn't installed but the application will
still and itself install and run this is
this is a typical example of where this
is useful is it is for look locale
specific resources you might want to put
all of your locale data for Asia in one
module all your your locale data for
Europe and another module and so when
you deploy your app you install just too
low cal modules that you want your
application has optional dependence upon
them so if they're there your app will
find them and if they're not your app
will still work it just won't have the
data for those okay okay splitting
whenever you have a way of constructing
you know graphs like this a language of
dependences it's critical that you have
the ability to refactor the shape of the
graph over time so the basic operations
there are splitting and aggregation we
want to split a module in this case
we've got comecou lib suppose it's
growing over time we decide we want to
want to split it into several modules we
can do that but suppose we don't we
don't want to change compu app or we
don't have the power to change compo app
maybe it's the third party module or
it's from another team that has a
different release schedule we can do
that by introducing what we call an
aggregator module so there's still a
comp who live now it does
actually have any content of its own all
it does is require these other three
guys so the dependent the dependence
from compo app upon compu live still
works as expected now the inverse of
splitting is aggregation if we're in
this situation where we've got calm
throughout depending explicitly on these
three and then we decide oh well we
actually want those three to be in there
in their own in just one module and
unify it but again we don't have the
power to modify compu app we can
aggregate them into compu lib now we
have these dangling reference references
because compo app it still is still
referring to complement DB and
comfortably hbu I and compute lip util
the way we get around that is is with
aliases or the provides clause so in
conf you live we put in some
declarations which say not only is this
thing named comp you live but it also be
if someone asks for comp you live DB
then tell them that this module will
work and that causes those references to
be resolved directly to comp you live
when the modules are installed okay
exports this is new so we've got compu
lib this this other module compu live DB
now imagine there's there's there are
some classes income to live DB that we
want to export to comp you live and
whoever else uses this and there are
some internal classes that we don't now
what's going on here basically is with
within comp you live DB all of these
classes are public but we don't want all
of the public classes to be exported
outward these two classes need to be
public because they're going to be
accessed by classes in the Ekka de in
the exported packages but we don't
actually want these to be sort of
globally public as it were so there
there's a kind of subtle thing going on
here we're actually change you with the
introduction of the model
system we're changing the meaning of
public the public used to mean visible
to everybody what it means now is
visible to everybody in this module and
visible outside this module if the
package is exported so in order to
control this we use an export Clause
because we only want comp you live to
see this stuff we say exports package
comp you live DB and that causes these
things these two classes and whatever
else is in these packages to be hidden
they can I dairy rd know at a deep
fundamental level in the virtual machine
they cannot be accessed from outside
this module now a related thing that
thing to exports is views one thing we
did we just we discovered well
modularizing the jdk we originally
started out with lots and lots of
modules as we trim that down we
discovered that we hope we were often
needing pairs of modules because there
needed to be a module of some some code
in the jdk that exported a bunch of
stuff outside and then a very tightly
related module that had had code had
mafia classes that were only used within
the jdk and we didn't want those
exported outside so we always have these
module pairs and it made things hard to
reason about it almost doubled the size
of the model graph in some ways and that
one that wasn't very satisfactory so we
introduced the concept of views the idea
of a view is that a think of a think of
a module as as exporting a set of
bindings by default it exports the set
of bindings in the packages in its
exports clause of course you can have
more than one of these I should have
said and have as many export causes that
you want a view defines another set of
exported bindings with a different name
so if I have some calm fuel another
module and I actually want to give it
access to these so all of this stuff I
can define a view in this module
say call it compu live DB internal I can
say that it permits only this module
compu with other to link to it and by
the way in addition to contact on Fulop
DB package it also exports calm pool in
DB internal so this module sees these
two internal classes whereas that that
module still doesn't so user views a
proven to be very powerful and really
let us clean up the overall jdk module
graph okay so that's the that's the
quick quick deep dive into into
modularity concepts like a to talk about
packaging for a bit so concepts here are
our module files libraries repositories
and native packages so let's look at
some some command-line stuff here just
to make it really concrete and this is
stuff you can you can type in and it
works we've we've modified the Java
compiler Java C it understands a new
convention which we've called module
path which is a way of structuring
source code and and compiled code
directories in a way that reflects the
market structure so you can run Java Sea
on on some code you this is telling it
module path mods that video that's
instead of instead of dash D classes you
say module path mods and your compiled
modules what will wind up in here if we
look recursively into mods so so in mods
there's one directory for each module
that you compiled and then if we look
into one of those directories will see
that will see the compiled module info
at the root of that one and then
underneath it the usual a quips the
usual package structured hierarchy of
directories and class files
once we've done done the compile we can
package those class files up into a
variety of formats one format is called
J mod which is a java specific format it
uses pack 200 on the class file so it's
extremely compressed it can also handle
native code resources and other things
you do that then in this case we get 3 j
ma j mod files out the back as you can
see just by convention the file names
reflect the version numbers once we have
the J Mont files we can create a module
library a module library is its you can
think of it as a little database into
which you install modules it has has
some internal information to make things
fast this is where the where Berkeley DB
comes in create a mantra library we can
install those other modules that we
needed from wherever we got them word
bar lib and that your Baz noodle then we
can install the three modules we just
compiled including com few app now when
we do that the module system will
resolve all the dependences make sure
everything gets linked up and it will
precompute information which ultimately
will store in a really fast be tree so
that looking up class files at runtime
is very efficient we're no longer
dealing with with with zip directories
at the ends of files and seeking around
and stuff like that we're pulling
information out of a b-tree and being
very efficient once we've in once we've
install them out installed modules we
can we can use the LS subcommand to ask
well what's in this module library of
course LS dash irby will tell you a lot
more and finally as i mentioned earlier
we can use the Java launcher we tell it
look in this module library and instead
of naming a class and giving a class
path we say go find the module named
compo app dash cam for module and run it
and it does ok library one library can
delegate to another and in fact the
Driggs a prototype JRE has its own
built-in module library surprise
surprise which has you know whatever
modules of the JDK that you've installed
and our little example module library
mmm lib delegates to the system module
library by default every module library
you create delegates to the system
module library you could delegate in a
chain if you wanted to anyway so
delegation does kind of kind of the
obvious thing if I one library delegates
to another than we've stall things into
the into the child library dependences
will be resolved up through the
delegation chain okay we also have a
concept of repositories as in a web
hosted repository of modules they bring
you from which you can you can download
modules that you need so I could have a
full repository of all the JDK modules
on some host somewhere have a module
library refer to it and now if I I can
go and use the use another sub command
of this dream I'd utility and say you
add this repo sfa whatever it's called
go install the JDK tools module you say
it okay I need Java Java Sea now but
Java Sea isn't in isn't among these
modules if I did ask it to install JDK
tools it goes and does it and then I can
run the compiler okay native packages so
we have enough information in these
module declaration files to create
sensible native packages at least for
operating systems that have sensible
made of packaging systems we have this
language that allows you to express that
a version to dependence of one module
for another not that's exactly what we
need to for example create debian or RPM
files and that there's there's there's a
another way to invoke the j package tool
that will get you get you Debian
packages we haven't implemented via the
RPM one yet but it's very
straightforward since there are
isomorphic
so from kombu app in module form we can
create compu app dev and I know the
syntax isn't actually perfect according
to the Debian policy guidelines but
we'll fix it when we do this that
dependence in green from one Java model
to another is reflected in the
dependence that winds up in the Debian
package control file so that when you go
to install these these these packages on
on your debian machine all the other
right all the other Java modules that
you need will also be installed ok
modularizing the JDK this is the fun
part so the JDK up till now has been
developed as a huge monolithic software
system and it has all the usual problems
of huge monolithic software systems when
we first were when we did the first cut
at modularizing it back in two thousand
nine or so this is what we got mandy
remembers this it was really painful so
this there there are fifty nodes in this
module graph and 171 edges the module up
here in in bold red I'm you probably
can't sleep in back of the room is
called base that's that's the most
fundamental module that's the module
that you have to have it has
java.lang.object in it right so one of
it one of the goals here is you should
be able to install a JRE and the only
module is in it is based you can't do it
with you can't have a Jerry without
place that's useless how do you have to
F base because you need java.lang.object
and java.lang.string and and a few other
things just to get the vm off the ground
so the first question i asked about this
graph once we had it was ok if i install
base does it drag in any other stuff and
the answer is yes it drags in quite a
lot of other stuff for for those of you
can't see them back the room let's see
it drags in logging that drags in
Kerberos it drags in pack 200
we don't need packed 100 to start the vm
it drags in as my favorite it drags in
korba definitely done need corpus start
the vm you know so the if we left it
here we obviously would entertain our
goal of being able to scale this down to
small devices because we're talking
about installing you know two-thirds of
the existing modules just to get base to
run so mandy and now on and others did a
lot of surgery we spent a lot of time
digging into the code finding internal
dependences from 11 and turned one
internal api to another or an
implementation of a public api to some
internal api and found that well a lot
of them were true to it asst it could be
removed or some code refactoring would
allow such dependences to be removed or
in some cases modest api changes some of
which we actually made in java 7 would
allow them to be removed and eventually
came up with a much simplified graph so
this is where we are today there are 32
nodes nodes and a hundred and five edges
there's actually a little bit this isn't
quite reality but it's it's a
comprehensible version of reality to
make it even more readable there's this
form of it this is the transitive
reduction of the previous graph so this
is this is the graph that we would
expect people to you know here you print
this out so what I what I would do
anyways then you print this out put on
my bulletin board so I know what the
model graph looks like so that's that's
the after picture how does this work in
practice well I know you might have seen
the demo i did in the technical keynote
on sunday we've we've had the scheduler
app running you've probably seen the
kiosks in the hallway this this amazing
scheduler app that Jasper pots and rich
bear wrote in javafx and and Jasper
built these physical kiosks that are
spread around the hotels that that's the
JavaFX app my colleague Allen Bateman
took that app modularized it he also
modularized the JavaFX runs
so we can install the scheduler app in a
modular form all that the scheduler app
needs from the JDK is three modules TLS
which is SSL logging and of course base
because you out they always have to have
base the scheduler app needs some other
stuff there's a it needs the JavaFX
embedded runtime or there or the whole
one it depends on the device you're
running on it needs another module a
module that has some some modeling
classes in it the scheduler itself uses
the logging API it also uses the apache
HTTP client and HTTP HTTP core libraries
which we converted it into modular form
we actually have a tool that will take a
jar file and convert it into a a modular
jar file or a Jay mod file and deduce
the the versioning information that's
needed and then HD to be climbin HTTP
core dragon there unda pendants ha's and
you know apparently no java program is
complete without at least one copy of
comments logging there it is and it
works so let's show that it actually
works Mandy has it warmed up and ready
here let's switch to run for
okay so which java okay dream on LS or
governor Berg dash version jigsaw
nightly hmm we don't actually need that
one but there it is how big is it that's
that's an implementation detail it will
it will disappear in in due course 23
megabytes so this is a bigger number
then then with the embedded build which
is what I demoed on Sunday because this
is not the embedded bill that's just a
regular jdk you know server desktop bill
j repo is that kind of bathtub that's
not a command I think you need to say J
mod Reba Oh does that work okay I i miss
i missed that change said apparently
right so so these are the modules that
are available they're not installed in
this very but they're available in the
repository that it's connected to okay
sorry it's not connected to yet but it
will be in a moment yeah it's fine mmm
what you just establish the link between
the library and the repository so that
shows you everything you can install now
can you do a J mod installed a Shen this
will tell you oh here you we're asking
it you tell me what you what you would
need to install and how many bytes it
would take so it comes back and says
well I need all these modules it will
take that many bytes to download and
that many bytes to store ok now let's do
it for real without the dash n but we do
that again ok now it's doing some work
and it crashes I've just haven't had
good luck this week MSC msvc are 100 dll
art exists thank you let's do it the
other way
okay so she's creating a another module
library adding adding the repo link to
it there's everything we could installed
I will actually do the install tada and
now we can run it tada and it comes up
much faster than raspberry pi all right
it works Thank You Mandy okay so that's
that that's the modular platform in in
actual use it actually does work and you
can download it in play with it if you
want so I'd like to take a little
digression here and talk about profiles
jigsaw won't be in in Java aid but there
is there's still a lot of demand for the
in some way to scale java SE at least in
a crude way you know in cruder ways in
the java a time frame so we're going to
propose the the introduction of a set of
profiles to java SC this is in the
context of the JCP this is using the
profile concept that already exists and
has been used in Java ME and also drop
it II we're not going to use that in SE
to define some smaller subsets not not
as granular as modules not as rich as
the whole module graph but something
that will love okay I'm not have orders
already something will allow small
devices that you to be used in in the
near term rather than the medium term so
here's the graph we were we started with
the shaded part you
is is the JRE with an embedded java bill
this is 52 megabytes what we're
proposing is to start is to define
profiles that correspond as much as we
can make them to the jigsaw modules and
you know of course we expect those to
shift a bit but we'll do our best to
align them all so that there will be a
10 megabyte base profile that contains
the base module TLS vindication and
logging and then above that this is any
sort of like the layers of an onion
there will be a 17 megabyte or so module
that contains a few other things jdbc
rmi and Jack's pxp of course is the
biggest part of the biggest part of that
addition and then a third one that will
probably be around twenty four megabytes
that contains more day TBC stuff and
kerberos and jndi and management in the
compiler API and and other things so
this this will give enough flexibility
for for a while that we can make some
some good headway to scaling java SE
down to embedded systems even though we
won't have the whole module system to
work with ok lean back up a bit and talk
about compatibility ok compatibility in
in the modular world so our expectation
our goal is that once we have a model
system in a modularized platform if you
have an application that that's composed
of jar files in the usual way and runs
on Java 7 or Java hate or six even today
it will run on Java with with the module
system as long as it doesn't do two
things one is it doesn't depend upon the
internal structure of the JDK or the
Jerry if it goes in digs in and and
tries to do something directly with RTR
for example that will fail because it
won't exist it also has to be the case
that it doesn't hit only uses supported
api's and other interfaces you know
digging into Sun reflect
is a bad idea because that's not going
to be exposed so modularized
applications will see some changes for
example if an optional module isn't
present there there are two modes of
operation at least in our prototype
today there's there's legacy mode which
is you know the usual classpath
everything as long as I every module is
installed an existing application should
just work as long as it doesn't depend
on internals and then there's module
note for for the case where you have an
application composed of a set of modules
in module mode some things will be
different the optional modules might not
be present there will be be some other
differences tools or applications that
depend on files in the Java home
directory will require some change Artie
dr. are one exists tools Darwin exists
the boot classpath flag won't exist so
what I've talked about so far is
primarily the the process of static
modularization that is taking taking
this giant body of code dividing it up
into modules changing things so that we
have a sensible comprehensible module
graph at the end there's also a dynamic
aspect of this and this has turned out
to be one of the more difficult
technical challenges I don't think we we
realized at the beginning quite how how
hard this would be because in module
mode certain things have to change model
notice is different from class path mode
one of the fundamental differences is in
in class path mode if you if you get you
get a class object and you ask it what
its class loader is that that class if
that class came out of RTR that is it's
part of the JRE you get back to special
value know which your shorthand for the
bootstrap class loader a concept that's
actually defined in the specification
well in module node there there isn't
really an analogous concept in module
mode we needed a way to associate every
class with a distinct class loader so
now if you go ask
you're java.lang.object if you invoke
its get class method you get back an
actual live module loader you and if you
have the right privileges you can go do
reflection on that and find out things
about where it came from and so forth
but there are there are assumptions
throughout the platform sometimes in
surprising ways where people have
inserted tests and and just and assume
for example that it's ok to do a
privileged operation if the calling
classes class loader is not now that may
be true before it's not sure now so
we're having to do a fairly detailed
audit of the entire code base to find
all of these assumptions you know
there's also the issue that some
previously visible classes are just no
longer visible if some stuff in some
desk for example you know it's it's
finally hidden behind a wall which is
where it should have been placed in 1995
ok there are lots and lots of
complexities here in some of our very
favorite areas of the platform certain
serialization are my and korba which you
all do some amount of reflective magic
and and all I'll require some amount of
privilege when you're running in us in
sandbox mode so it's it's quite quite
delicate work to work through all this
stuff ok I talked about profiles and
I've talked about modular eyes in the
JDK hasn't been just me working on this
or it hasn't been just me in and Mandy
but a bunch of other people working on
this for several years now and at least
a couple years more so what you wanted
to give them credit for that the
obligatory legal notice and finally
there's a day off if you well if you
have questions we can we can probably do
a few questions now but we also have
this room for the next session at four
thirty and Mandy and I'll be hanging out
in between four for QA places where you
can go for more information our project
page our main
Bajan openjdk is the first URL we have
our development list jigsaw devin
openjdk and JDK a Java net / jigsaw is
where you can get the early access
builds of course we will shortly be
changing that to jdk nine java.net /
jigsaw but we'll try to leave a redirect
I'd also like to like to mention there's
a related project in OpenJDK called
Penrose where some folks are exploring
the important topic of osgi and jigsaw
interoperation jigsaw is is not trying
to replace osgi there's lots of cool
stuff osgi can do the jigsaw is not
trying to do so to keep osgi based
applications working well this int'l
evidence interoperation project is
really important so if you will learn
more about that you can visit there
we've got about eight minutes left in
this clip in the session for questions
so you have any please ask thank you
yeah the question is what about cyclic
dependencies they would they work just
fine they might not be best practice but
they work just fine it's the the resolve
our result / handles them it's just a
graph can you speak up please it's kinda
our dear right so the question is I
showed explicit export causes and then I
mentioned implicit re-exports one thing
I didn't show because I wasn't sure I
would have time is is you can control
re-exports in fact we flip this around
in the prototype a couple of times based
on experience if you want to re-export
you have to say that explicit you have
to say that explicitly so if module a
requires module B and wants to re-export
what it gets from module B instead of
saying requires be it says requires
public be and that will re export
everything although if B has a permits
clause that won't be allowed okay yeah
how do you handle java.util do you split
it into many modules it's it's a bit
late for that so we did what we have now
is is we have the power to split that up
using a an even deeper more subtle
feature called requires local which
allows multiple modules to be loaded in
the same runtime class loader but it's
the working out the semantics of that
has proved to be proved to be pretty
tricky so we might we might just drop it
when when the whole jigsaw effort
originally started back in two thousand
eight we were one of our goals was to
include but it was to converge not just
with Java ME CDC but also cldc which
would require splitting up many existing
packages you know as time has gone on
the CL DC goal has become less important
yes it's true java.util really from the
beginning should have been probably
three or four different packages that
would not make you know three or four
different nice modules right now but
it's not so they'll probably it probably
but most likely all of Java util not not
it necessarily at sub packages but I'll
java.util itself will wind up in the
base module and stay there somebody who
hasn't it
so so Java EE how do i see this
affecting Java EE I expected will affect
java java ee is is one of the most
important you know customers of all this
and you know we've spent lots of quality
time speaking with with technical
leaders in that community the the
long-term goal is for java ee to be able
to adopt whatever module system why
winds up in java nine so that they're
there can be a clean basis for for truly
modular java ee applications and i would
expect the related java ee standards for
you know war fire files in here files
and all that to be expanded so that you
can for example have in one in one file
somehow packaged up a bunch of modules
of the constitute your your EE
application for deployment yeah how
about sun miss gun safe so the this is
what I sorry I finally referred to as
the W problem because every time I talk
to Doug Lee he he politely reminds me
that I better not take away sun this gun
safe because then people won't be able
to test out new versions of his
java.util concurrent library that that's
a really tough one I mean that there's a
lot of you know frankly garbage in the
Sun disc package and as and some of the
other old crafty packages that that just
needs to go away send this gun safe
you're right it's important I don't know
what the right answer is there if there
were some way to you know if I if I
could give if I could give Doug a
cryptographic signing key and then and
then only allow code written by Doug to
the linked is on this gun safe that'd be
one way to do it but i think is really
practical what one idea that was
suggested recently and maybe this is
actually the way to go is maybe we make
unsafe part of the standard
you know maybe we have java.lang done
safe you know we if we do that we have
to make damn sure that the security
around it is airtight obviously but
given the importance not only to
libraries that Doug rides but libraries
that some other folks right that that
may be the best way out of that
particular puzzle oh sorry can to can to
modules to can one well taken two
modules depend on different versions of
the same other module with will that be
supported the answer is no in in
practical experience that does not seem
to be a common case I know it's
something that OSU I can handle and
sometimes in really rich systems you
need to be able to do that but if you
look at you know in in the classpath
world if you have two different versions
of the same drawer file on your
classpath that's a bug it might be a
really difficult to diagnose bug but
it's a bug yes so so yes kk is observing
that you know our old friend calm is
logging there will be 16 different
versions of it in a running app server
and that's true and that's why that
that's that that's one of the problems
we haven't yet tackled in container
support in in the jigsaw prototype so we
understand that in some controlled cases
you need to have multiple versions of
the same thing but are the view we've
taken is that we want to do that in a
controlled way right rather than solving
the general problem of oh here's this
big huge sea of modules with arbitrary
version constraints and everything we're
going to do it in a more controlled
manner so that we actually can
understand what's going on and reason
about for example the correctness in the
performance of the system okay
good question what will it look like
when we're what will it look like when
we're converting our own our own
projects into modules but we still
depend on third-party libraries
delivered as jars well I you know I'd
like to think there'd be a magic Eclipse
plug-in a magic NetBeans plugin that we
just do it all for you the the in in you
know in a more realistic answer is so we
we've thought some about that problem 11
answer we have for that is we've
extended the jar tool to be able to add
module metadata to a jar file so if you
if you've got a jar file and you know
what its version was for example
actually had a prototype of this we
demoed last year where you could go to
you go to maven central download an
artifact and convert it into a J mod
file that deduced all its version and
dependence information from the pump
because the palm well you look at a palm
and you know from 30 feet away it looks
a lot like a like a module declaration
so that's that's one that's one answer
to that we also expect to have every
week we already we built many Andy built
this nice dependence analyzer tool which
is how we constructed the construct of
the module graph and simplified it we'd
like to get that into developers hands
and ideally into IDE plugins so that
when you're starting with your own code
and trying to figure out what its
inherent module structure is you can run
that class analyzer and it will offer
you suggestions about how to clump
things up into modules is there anybody
who hasn't asked a question yet be
honest okay class p the classpath will
study that they're there two modes you
can be you can be in class path mode or
you can be a module mode you cannot mix
them cannot mix them it we've thought
about that it is just it's so hard to
make sense of you cannot mix them okay
yeah
sorry I mentioned that the boot class
loader will no longer be represented by
null is the class loader precedence
changing do you mean is the the
delegation model changing yes the
delegation model is changing it is going
away there sorry a.m. every every module
has its own class letter you know that a
mod a module class loader knows about
other module class loaders in a way
that's precisely described by the module
declarations and that's all there's no
more delegation chain and inherent look
up that way exactly that that is where a
lot of the container support it is based
on I mentioned HTTP repositories for
java modules what is the format it's
really simple it's static files on a web
server there there's a little tool
whether that's the the JRE repo tool
Mandy showed there's a little tool for
maintaining a catalog file in the root
of sector repository but otherwise it's
just it's just jam on files simple
static web server you don't need to
install a servlet or any server side
code you know under heightened right how
does it how will this relate to maven
that's that's a good question another
existing system that that we aim to
interoperate with is maven the details
of that you know we we prototype some
stuff we showed it here last year but we
we need to work more on that and and we
hope that there are folks in the maven
community you were interested in helping
at wait but we already know a couple
so how do i how do I expect this to be
adopted slowly yeah maybe let's be
realistic about it it's it's a huge
change I expect you no no no it's it's
it's it's it's not a fork in the road
right once we have a module system in
Java 9 there will be there will be a
module system there you know you can use
it or not just as you know just as in in
in Java 5 we introduced generics you
could use them or not over over time
most people figure you know learns that
they're the benefits outweigh the
disadvantages and convert it to using
them but it we understand it will take
time we understand that education is a
is going to be an important part of this
you know serve way so we're we're
actively looking for example for size
for a really good tech writer to write
the canonical jigsaw book in in due
course we expect training will be a big
part of it so yeah it is a big change
and it'll it'll take time but we're not
taking we have no plans to take away
classpath mode right you know maybe in
20 years but that you know that has to
stick around for a good long time all
right yes sir well yeah what is there
still room for osgi so no she has not
out of the picture it's it's
it's meant to run on top for those who
need it and this is what's going on in
project pan roses they're there they're
working through the details of how do
you make an osgi resolver hook into the
lower layers of jigsaw so that an osgi
bundle could say you know requires jdk
da base version whatever and an app that
I'll work so you're supporting a osgi is
a unarguable requirement basically it's
just that osgi itself even though there
are problems we need to solve to
modularize the platform that osgi can't
solve I think they're going to kick us
out of the room so that everybody can be
rescanned but we don't come back</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>