<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>HTML5 WebSocket and Java | Coder Coacher - Coaching Coders</title><meta content="HTML5 WebSocket and Java - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Oracle-Learning-Library/">Oracle Learning Library</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>HTML5 WebSocket and Java</b></h2><h5 class="post__date">2013-01-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/8QBdUcFqRkU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">today I'm going to talk about WebSocket
and Java and if you were expecting a
kaleidoscopic talk about html5 that this
isn't it it's mostly focused on
WebSocket so I'm Dani coward
I've been at Oracle since they bought
Sun and then I was at Sun before that
for a while and here's the this is
because I might talk about some future
plans so don't sue me if I get the date
wrong by a few days
so what I'll cover I wasn't sure how
familiar people would be about
WebSockets so I thought I'd just kind of
get us all on the same page about
WebSocket the protocol and then I'll
talk about the jsr fairly briefly and
then mostly I'll focus on showing you
the API with some sample code and I
think I have a demo that's going to work
so the roots of WebSocket came from you
know in the I suppose in the early 2000s
when websites became more and more
interactive there was more and more need
for the web pages to be you know
animated in some way in terms of
information which required the server to
push out notifications things like stock
quotes or people writing the first
chapter is and things were becoming
popular so HTTP being the primary
protocol doesn't really support this
very well at all it's a request response
interaction model so if the server
wanted to push it dependent on the
client doing some extra smart things
things like you know polling at some
regular interval or keeping the HTTP
connection alive and waiting for
snippets of updates to come down whether
or not there was any need for that
connection to be open and then some
programming models like comet and Ajax
and a sort of family of little program
models were built on these ideas to try
and bring this interactivity to web
sites which is great but it meant that
are there a lot of open kin
Shinzon the internet that weren't needed
all the time the server didn't always
have something interesting to say to
these websites so it was inefficient so
that was the roots of WebSockets and you
know the idea is to have a new TCP based
protocol that is conversational it
symmetrical from the client to the
server once it the connection is
established it's full duplex meaning
that messages can be sent simultaneously
from one end to the other you don't have
to wait for the other person to speak
before you speak so you can all the
messages can interrupt each other it
took several revisions and it's been a
winding path but it's now a standard the
IETF for the the protocol and there's a
JavaScript API that's defined in the w3c
that's tracked this draft this this this
network standard so things are looking
in pretty good shape after it not being
quite clear how widely adopted
WebSockets would be and you know you can
google this kind of thing yourself but I
did take a look at which what the
current state of browser support for
WebSockets is because still a primary
model is a browser client talking to a
web application so I don't know how
clear it is here but I'll give you the
highlights if I know I don't have a
laser pointer if you see three from the
end as a current line and anything green
or greenish means that WebSockets is
supported so I'll read off the most
popular ones IE is experimenting with
support doesn't support it yet but plans
to in IE 10 so that's going to be the
next version Firefox does chrome does
Safari does opera does partially it
doesn't put their support all that all
the features iOS Safari on iOS does so
even just scrolling through those
browsers we've sort of covered hundreds
of millions if not billions of web pages
on different devices
okay does anyone have a cat that they
brought wait ago I think I might be the
cat there it is okay current this is the
line so it's nearly all green is
basically it OEE is the big popular
holdout it's supported on blackberry
it's going to be on it's on Chrome for
Android so you know tablets smartphones
desktop laptops it's it's either here
today or it's going to be here very soon
and when I say support that generally
means they support the JavaScript API
and the web protocol underneath so you
know don't be scared to start really
looking at it seriously if you're not
already so the basic idea just there's a
primer on WebSockets if you not familiar
with the protocol there are three stages
first there's a handshake process to
establish a connection and I'll talk
about that then there's this stage of
once the connections established
messages of various shapes and sizes
flowing backwards and forwards between
the two peers in the conversation and
then finally there's a part of the
protocol is about ending how to end
gracefully or otherwise the connection
so to establish a connection you the
client creates a handshake request this
is a specially formatted HTTP request so
one of the ideas of the protocol was
that it layered well on top of existing
technologies and then the server thinks
about it for a moment and formulates an
HTTP response in a special format to say
I accept your connection request and
then what's dance that's done well we'll
get there this is what the HTTP
handshake request looks like it's a get
to a URL it uses the HTTP upgrade
mechanism it's the first use outside of
SSL to do that it sends a little dongle
so the client can when the response
comes it can the server knows to allow
the client to check that the
response came from where it thought it
came from and then there's a few other
details like the in establishing the
connection the client can request that
certain sub protocols and extensions of
the WebSocket network protocol be
supported on that connection so if you
have a sub protocol of WebSockets that's
about chat and it's just dedicated to
doing really good chat applications in
the handshake requests the client will
indicate that then the server examines
this information and it looks at things
like you know the URL does it match an
endpoint that it has to serve for that
URL it will check for this well-formed
and so on it will check whether it
supports any of the requested sub
protocols or extensions and then it
makes this response if all if all goes
well and then once the response is made
the client knows that everything's good
the TCP connection is established
between the two physical machines and
then you're kind of up and running and
once you're connected the the protocol
defines a number of events that defines
the life cycle of the connection at the
sort of the application layer so the
first thing is that both parties get
notified that the connection is now open
then any number of messages can be sent
maybe in this case from the client to
the server the client can send one to
the server will get to all this in much
more detail there's a WebSocket event
that indicates there's been an error on
the connection either the physical
connection may have gone down or there's
a problem with the format of the message
for example more messages can flow and
then finally one of the parties can
initiate the closing of the connection
and the other party is notified that the
connection has gone down and then when
all that's happened at the end of the
conversation you you disconnect the two
machines the TCP connection is brought
down so that's a quick flyby of
WebSockets how it works
alongside the volunter of the standard
there were lots of Java API s that
started to being developed
to allow Java developers to use this
protocol largely it has to be said on
the server side because like I said the
primary deployment scenario is still a
browser to a web server and here are
just a few of the examples I suppose the
notable thing is that the the leading
Java web containers like Tomcat like Kao
Chiao like jetty and the JBoss and so on
sorry JBoss is Tomcat but they have been
you know bringing these api's into their
web servers
I suppose due to developers wanting to
use them and then an Oracle we've we've
supported it in grizzly for some time
kind of a lower level API approach and
then more recently where this project
grew out of we experimented with some
annotations in a WebSocket SDK project
that ultimately sort of led to this jsr
in a way from our perspective so we
started the expert group in March I
think it was to start working on this
that's the number of obviously you can
Google all of this the specification is
being run in a java.net project with
public mailing lists you can go and read
the archives anybody can go and read the
archives and you can follow the expert
group traffic if you would like to by
joining the users list we're currently
an early draft route review which means
this is the force first formal
exposition of the API that we're looking
for feedback on after you know several
months of work now we'll be in Java EE 7
next year so we've got to get things
straight before then and we also have a
reference implementation that Oracle is
is doing that will implement the
specification and that's being done at
another separate java.net project called
tyrus and the tyrus builds are now
tracking the the early draft version of
this specification so everything I
talked about today is in the early draft
and then if you go after this and
download the the Tyrus code that will
implement not all of the features but
many of the features in the early draft
and also Tyrus is being bundled as of
last week I think in the GlassFish for
builds the expert group it's you know
it's not always the case but I think in
this case we got all the people who are
nearly all the people who are
implementing WebSockets as a java api
which i think is really good that's
really important so that's great and
here they all are and anyway so now
let's go to the API so this is where the
bulk of the talk is just to show you the
API here's a you know high-level view
we've got API for the WebSocket events
for various different ways of sending
messages backwards and forwards between
a client and a server we've got a notion
of a session which is really a sort of
high-level view on the connection which
encapsulates the idea of conversation we
haven't quite separated it well yet but
there we will have a separation of
client and server api's the idea here is
to bundle the server api's with EE but
also have a separable client API that we
hope will be incorporated into the jdk
at some future time we have a bunch of
annotations to try and make this easier
for people in the EE style of turning
pojos into more interesting objects we
have an SPI for WebSocket extensions and
data framing and then we also have
integration with the EE web container
we're trying to view this as just part
of a bigger web application so here's
the tour of the api's so just a
disclaimer here this is early draft we
have several more drafts to go
things like method naming class naming
maybe even one or two of the smaller
features might change as we go along but
this is our first outing of this API and
so that's what I'm going to show you
things may change before we go
so just some basic examples to start
with this is the server component that
is extending hello server is my
application class endpoint is one of the
key classes in this API this embodies
the notion of one end of a WebSocket
conversation and in the API that we have
the idea is that your application
subclasses endpoint and overrides one or
many of the lifecycle methods that
intercept events on the endpoint and in
this example what we're doing in the the
overridden on open method we are in this
method we're going to get a callback
from the container when a new connection
is established the session object that
the container passes into your code your
application code represents the
connection with that client who's trying
to who's just connected into you and
then the first thing we do with the
session is add a message handler this is
like you know adding a listener that's
going to listen to any messages that are
going to come in as part of this session
or on this connection from the client
and here we add a variety of message
handler we've got lots of different
types of message handler here we're
adding a simple text handler which has
one method on message which simply takes
a string parameter and we're just
printing out what the message was and so
in this case what we're doing we're
adding the message handler so that
anytime a text message comes in on this
connection
we'll get the text message passed into
our on message method and then we can go
and do whatever we want with it so very
simple we're just listening to text
messages from client here so already in
this even in a simple example like that
we've covered some of the main classes
here endpoint this is the application
class that you or the API that you
subclassed is the entry point for an
applique
and this intercepts events like on open
the open event arrow events
close events then we have a separate
notion of developer components that
listen for messages dedicated just to
listening to WebSocket messages and
there are all different flavors of
message handler then I didn't show but I
will in a moment we have a notion of a
remote endpoint which from if I'm a
server my perspective of a remote
endpoint is it's the other end of the
conversation and that's the that's the
thing the object reference that I get
when I want to send a message back to my
peer in this conversation and then as
I'd mentioned we have a notion of
session perhaps a little too broadly
named but a session which represents the
active conversation between the two
parties
so just to double click into that a
little bit more what this looks like is
an object model my server let's say my
endpoint there is just that simple hello
world application my endpoint has a
number of message handlers associated
with it you know what 0 to n you could
listen to nothing or if you listen to
things in in multiple form then for each
client that's connecting into my server
there's one session and each session
holds on to one remote endpoint
representing that client so a relatively
simple object model here the object
model is showing two clients connecting
to the same endpoint and having some
kind of WebSocket conversation so what
does it look like we just showed that so
here we are this is the you know there's
that same code again now what does it
look like on the client side well
WebSockets is a is a protocol that's
mostly symmetrical once the connection
has been established the handshake as
you saw is not a symmetrical operation
so but typically clients there tends to
be a
one client tends to make you know one or
a small number of connections to a
server and a server is managing to
accommodate you know one up to millions
of connections from millions of clients
maybe like on Facebook for example at 3
o'clock in the afternoon so you can see
that we're using the same API objects to
represent the clients perspective of
this connection whether client who is
connecting is also an endpoint because
it's one of the ends of the conversation
it has message handlers too for when the
server sends a message back to the
client saying you know there's a stock
update or there's a new chat message it
sees a session object just the same way
and it's remote endpoint represents now
the server that it's connected to sort
of the other way around so here's the
client side code again our application
hello client subclasses endpoint and
we're intercepting just the the honor
open event which indicates that there's
a new connection has started with the
server and this time instead of adding
message handlers to listen for messages
the first thing we're going to do in
this this application is to send a
message to the server we just connected
to so we get from the session object
that's passed in as part of this event
the remote endpoint and then the remote
endpoint contains you know whole host of
methods for sending WebSocket messages
and and that's that so sort of if you
combine the two things together you
could produce an echo server and you may
know this already but there's a website
that you could test your browser which
has a little echo server on it not this
one but
as a different one we'll just echo any
WebSocket messages that you send to it
so here just to go through it again
we're intercepting the open event as
soon as the connection is opened we ask
to add a message handler to handle any
incoming messages and here we're just
handling the text messages and at the
same time as soon as we configured our
message handler
we're going to send a message back to
the client the coldest and just echo
back the message that they sent so
configuration we have a you know a
concept of configuration objects we
include a number of default
configuration objects we're trying to
make the easy things easy let me go
through the example first in this case
the top half of the slide is showing the
client configuration the configuration
process for a client endpoint we get we
make the URI now I'm sorry the top half
shows the server side of it where we
create the URI where we're going to
deploy the endpoint where it's going to
be registered we get the server
container oh I'm sorry we get the server
endpoint configuration and we use just
the api's default server configuration
and pass it that URI and we call to the
server container to publish that URI now
the default matching algorithm if you
just use the API default is just an
exact match all these algorithms are
over idol in your applications if you
want to have some star matching or
regular expression matching or something
even cleverer than that you can override
methods on the endpoint configuration or
provide your own to have you know
different algorithms then on the lower
half of the slide where we're on the
client side we get hold of the client
container and we instantiate our
application object
and we connect to the server using the
default client configuration object I'll
go into a little bit more detail about
that but configs relatively easy
so client configuration again these are
abstract classes that can be subclassed
if you want to provide different ways of
doing this but what you can do by
default is easily add in any sub
protocols or extensions your client
application needs any message encoders
which I'll talk about Linda little why
while that your client is going to use
and then the request UI it's going to
connect to on the server side the
configuration allows you to specify
algorithms for the negotiation of sub
protocols and extensions the message
encoders and decoders on the server side
and some of the other aspects of the
handshake like whether you check the
origin on art the URI matching algorithm
that you would like to use and also to
be able to examine the the details of
the handshake request and response if
you want for example to add custom
headers into that as I know some people
so what some people do so we've kind of
set up the basic you know hello world
echoing simple messages text messages
one of the more interesting parts of the
protocol is that allows you know a
variety of different modes of sending
and receiving messages and we've tried
to reflect a number of different styles
based on you know message style message
size program style so if you're
listening for message we have I'd
mentioned that you use a message handler
you configure those we have a number of
different kinds of message handler so
that you can listen to incoming messages
in a variety of different ways so we
already saw the simple text message
handler which is just an on-message call
callback you can the WebSocket protocol
divides messages into either text-based
or binary messages
so for incoming binary messages there's
an analogous binary message handler so
this is good for smaller messages where
it's okay to process you know a small
message all at once and wait for the
whole thing to arrive before you get the
callback for larger WebSocket messages
you may want to process things in more
of a stream based manner so we have four
asynchronously processing incoming
messages a piece at a time we have the
async text message handler which is a
relatively common pattern in the
different implementations of WebSockets
that we sort of we leveraged or I
suppose copied where you each fragment
that comes in you get a callback for
each fragment and then the final
fragment the boolean that you can see
here on the right-hand side on the on
message call is set to true and then you
know that the complete message has
arrived and then the Z analogous binary
form of that you get a partial byte
buffer coming in and then when you get
the last part of the message you get the
last byte buffer the boolean is set to
true then you know I suppose people a
little bit divided whether they still
like to use IO or whether they you know
need the scalability of two a
synchronous asynchronous processing but
there are lots of libraries that support
traditional blocking i/o so we've also
provided as you can see here the
iostream versions of processing messages
as a reader in the one two three four
fifth line and as an input stream so if
that's the way you like to process
messages by using a blocking stream then
you can add that kind of message handler
and then finally I mentioned encoding
and decoding one of the interesting
aspects of WebSockets is being able to
take developer level level objects like
a chat message or a drawing message as
I'll show a little bit later and provide
decoders and encoders that can translate
those developer level objects to and
from strings and binary message
so when you provide encoders and
decoders which I will show how to you
can also opt to receive messages in the
form of a custom developer object
provided you provide the correct encoder
for it
all these api's are you know single
abstract method entities so that the
lambda ready so that when we can switch
to JDK 7 then you will be able to sorry
when we can switch to JDK 8 you can
write these message handlers as lambdas
if you want to so let's look at the you
know just some of those different modes
of processing an incoming WebSocket
message we already really covered this
one it's just there for completeness
this is handling on message just as a
simple string so if you want to this as
one is handling text in fragments at
each piece of text as it arrives you can
get a callback for each piece of text so
here when we add the message handler we
add the different variety of message
handle the async text Handler and its
method signature single method is on
message part and this receives the
callback with partial strings
sequentially in order until the last one
arrives when the boolean flag I'm going
to do questions at the end just in case
I happen to stumble on the answer in a
later slide and then you can construct
the message in the order that you
received it then here's a streaming
version so it's a member class of
message handler member interface of
message handler the character stream
with its own message that takes the
reader and then you can use the
traditional reader api's to read things
as quick as you notice as small chunks
or as big chunks as you like and you
will just have to wait till other chunks
arrive
and then I'd mentioned that you can up
to receive messages in the form of
developer objects of your choice here my
custom message receive application wants
to receive custom message objects which
is some you know developer object that I
created and here we use the decoded
object flavor of message handler and you
see the signature is the custom message
that I want to receive but this is
dependent to get the callback here on me
having provided a custom message decoder
which you see on the lower half of the
slide which implements the Dakota Tex
decoder interface and it's contractors
simply to be able to decode a string
into that developer level object so this
is a very straightforward simple
approach to being able to elevate
WebSocket messaging from strings and
binary arrays up to something a bit more
friendly to developers now on the other
hand sending messages we have really
analogous modes for sending messages as
well
the top two show on the remote endpoint
interface that I mentioned earlier this
is the representation of the other end
of the conversation we have this variety
of methods for sending messages the top
two of the simplest if you have a
smaller message you know small chat
messages you know things that are
relatively quick to transmit we have a
send string and I apologize the the
binary version should say send data I
believe then again you can send things
in fragments here in the third and
fourth lines by sending things in in
chunks you can also send things using
blocking i/o using writers and output
streams and then analogous to processing
messages you can send things in the form
of a custom developer object provided
you provide a an encoder so the
container knows how to turn that custom
developer object
into either a string WebSocket message
or binary data and then the ones that
I've starred here the modes that I've
starred also have additional flavors
where you can send them by completion or
by future and so if you send by
completion what this means is that the
send call returns immediately you
additionally pass in a send handler
which gets a call back when the
container has fully sent the message
weird isn't doesn't provide a guarantee
that the message was received and
processed by your client but if you're
sending you know is to hundreds of
clients you can hand off that work to
the Container while your program thread
can carry on and do it's do something
else in the meantime so here we are some
examples of these different modes of
sending now basic send we saw this one
before we get the remote endpoint a week
just called send send string and send
the whole thing all at once and this
method blocks until the container has
fully sent that message on the
connection here's the blocking streaming
send version of it again we just get the
remote endpoint and this time we are
going to send a text message through the
writer interface so we just you know
call writer dot write and send things
that way and again this is a blocking
process but at least we're streaming
things now and then you can send things
now either by completion or by future so
here is an example of sending a message
by completion where the relevant method
is send string by completion as well as
the message hello in this case you send
in a send handler which receives a
callback either when the message has
been properly sent or if there's some
error it receives an error so as you can
see here in our send handler we can
when we get the call back we can check
whether the message actually was sent by
the container or whether some error
occurred on the transmission and then
this is the other version - sending that
message by future so now again the send
message here send string by future
returns immediately probably before the
message is actually sent and you are
given a handle to a future object which
you can wait around for you can
interrogate for completion and so on on
your own thread and you again you get
the send result which gives you any
exceptions that are raised during the
send if any otherwise it tells you it's
okay so that's some you know bright
different varieties of messaging which
hopefully will accommodate a wide range
of messaging style applications from
smaller messages to big scalable chunks
of data being sent backwards and
forwards now we're going to talk about
pojos as WebSockets so this is very much
in the EE six e5 and e6 style of things
trying to take what for some people is a
complicated API and using annotations to
help making easy cases super-easy to to
write so back to our hello world server
example we saw this earlier all we're
doing is listening in for a text message
the annotation version is this one it's
the hello bean and now instead of
implementing subclassing at implementing
endpoint and using api classes to you
know decide when what form to receive
messages we use annotations instead so
hello bean is a is a POJO it doesn't
implement anything in particular it
could be some pre-existing class that
you already have it's decorated with
this at WebSocket endpoint annotation
which in this case has Hello as a path
so this tells the container that
developer would like this pocho to be
deployed as a WebSocket endpoint under
the URL hello on the server and then
it's handled message method note the
different method method name from on
message was the API version is decorated
with the app WebSocket message
annotation and this tells the container
that this is the method on this Pocho
that the developer would like to be
called back every time a message comes
into this endpoint and again we've opted
for the simple string form of handling
that message so you can see for you know
especially for new developers for
developers who like annotations a lot
for you know development tools that like
to set up templates for things this
makes it a little bit easier see oh yes
then this example back to our echo world
server which not only processes the
incoming message but bounces it back to
the client that send it sent it I wanted
to show you that version in the the
annotation so this time again we're just
using the WebSocket endpoint class level
annotation to say this POJO is a
WebSocket end point and we're decorating
the echo method with the WebSocket
message annotation and the WebSocket
message annotation allows for a return
type from the method and if there is one
and in the correct format it will treat
this as a message to immediately send
back to the client so this is a somewhat
useful case for for developers to make
easy so looking a little bit more deeply
we have a number of other annotations
for doing this style of POJO programming
turning pojos into WebSocket endpoints I
talked about the WebSocket endpoint
class level annotation that's the main
the first one that people would learn
then you can intercept some of the life
cycle events a web socket open and the
close event web socket close and you can
also decorate one of your methods or
several of your method
with error handling code using the app
WebSocket error method very recently in
the specification we've added the
ability with annotations not just to
provide a URL to deployed the endpoint
to but a URL template this has become
quite widely used in a style of web
programming and in order to be able to
intercept those parameters of the URL
template we have a method parameter
level annotation called WebSocket path
parameter that allows you to receive a
matched segment of a your URI template
and then of course WebSocket message is
kind of the workhorse which tells the
container these are the methods or this
is the method that I want to process
incoming messages so all of these
annotation most of them come with
various different attributes that allow
you to twiddle the dials and knobs of
the annotations the WebSocket endpoint
annotation allows you to provide the
path where the endpoint is deployed to
and here we've got an example hello or a
very simple URI template allows you to
list out the method the object decode
message decoders and encoders that you
want to use for your hojo and also the
sub protocols that you're POJO supports
for WebSockets and then a WebSocket
message the annotation allows a
relatively flexible class of method
signatures to be decorated with that
WebSocket message annotation any method
that has a parameter of string byte or
any Java type for which as a configured
decoder an optional session parameter if
you because you usually typically want
to know where who the message has come
from zero to end string parameters for
if you're using the URI template style
of deployment matching
and then a return type of string byte
array and any type of which there's an
encoder so I think I haven't really
talked about this with the expert group
I think we should probably add you know
Java primitive types collections of
those things to that list obviously I
will talk about that in the expert group
before adding it but I think that would
be a good idea to add to this list
before we go final oh now I have a
little demo no presentation is complete
without a demo so I wanted to just show
an example of something running this is
running on tyrus and it's one of those
group drawing applications where you
know two people are drawing a picture
and they've got a kind of joint
whiteboard so just give me a second to
get it set up
so here's my little drawing canvas and
this is in Firefox on Mac obviously so
these are two separate browser clients
so as far as the server is concerned
these are two different clients so
what's happening is every time I draw on
either client canvas the client canvas
is sending through the JavaScript API a
little WebSocket message telling the
server endpoint what it just drew so
it's just drawn some red circles let's
do I don't know
Square and then when the server gets the
message it's bouncing out to all the
other connected clients that it has
connections with from this drawing
application just exactly what got drawn
on one of the other canvases so the idea
is that when everyone's connected at the
same time if anyone draws on the tool
through mediation through the server
everybody gets the message about what
just got drawn and everyone ends up with
the same picture except when you clear
it but so that's just a very simple
application of this kind of technology
so then that really the idea of showing
you that was so that I could jump to the
slide which I think ties a lot of these
concepts together and I'm showing you
here the server side endpoint of that
demo application so this is the POJO the
group draw server that is you know being
run in that that application every time
one of the clients draws a message this
group draw server pojo receives an
object called a drawing message and this
is a simple object in this demos case
which has you know whether it's a square
or a circle or something else the color
and the size of it so you can see it's
not just a string or a binary data it's
actually a Java object with methods to
indicate the shape and the size and the
color and so on
and in order that the POJO catches those
messages what I do is I declare this as
a WebSocket app WebSocket endpoint at
the top I give it a URL the draw URL
which is where the endpoint gets
deployed to I need an encoder and a
decoder to translate the incoming
WebSocket message which is a string up
into a drawing message object and then
when I send the message back I need to
be able to translate the outgoing
message from a drawing message object
back down into a string so that's what
the WebSocket endpoint annotation is
doing at top and then my shape created
method is annotated with at WebSocket
message so I'm telling the container
this is the method that wants to handle
any drawing message messages coming from
my client then in my implementation of
that message I get the message as well
as the session I get hold of the the
server container that I'm in this is a
WebSocket API that I can list out the
active sessions the current connections
to that server and then I can iterate
through them I throw away the the client
that sent me the message because he
doesn't need to get the same update of
the thing he just drew and I send all
the others that exact same drawing
message back out again so that they get
you know whether I drew a red square or
a blue circle so you can see this I
think exercises many of the aspects of
the API and the annotations that I was
talking about the different stars of
messaging here in fact we are sending
those objects asynchronously
you can see we're calling send object
and passing in a completion handler so
this means if I have a hundred clients
all using simultaneously this drawing
tool these send object calls in this
iterator they'll return immediately so I
can get on with something else in my
application meanwhile mice and handlers
get the callback when the message is
by the container so we showed the
different modes of operation we showed
encoding and decoding we didn't show
your eye templating but I think we
showed pretty much everything else so
let me just do a time check Oh had time
for questions packaging this is an area
that may develop a little but you know
the basic idea here is on the client
side for the client API that we hope
will be incorporated at some future time
in the jdk applications will just simply
package their application classes and
any resources that they use into a jar
file and then they use the class path to
indicate where the WebSocket API
implementation is or or not if it's
already included in the underlying
platform and then in the web container
for Java EE the idea is simply to
package these classes in the war file
either in the webbing classes or in the
webbing Lib directory packaged as a jar
file and any resources so we're just
piggybacking on existing packaging
models here some features I didn't talk
about you know like I say this is the
first time we've really talked about
this so I didn't want to jump ahead to
you know some of the things we added
later but just so that you know I'm not
going to talk about these in details but
just so you know that these are features
that are part of this this API in the
specification there's a you know
WebSocket the protocol is by design
extensible and that has a formal way in
which people can create extensions of
the protocol multiplexing is one that's
been worked on already compression is
another one where WebSocket messages
compressed this obviously takes both
ends of the conversation to agree on
that
that's how they're going to play that
the websocket game so we're going to
allow Java developers also to be able to
implement these extensions by providing
a data frame WebSocket extension spi
it's kind of an advanced features most
developers won't need to do this
they may even borrow someone's extension
that someone else has created maybe
we'll even provide one or two in our
reference implementation I touched on it
and we're really sort of trialing more
complicated schemes for URI matching
exact match of your eyes on endpoints
gets you so far but it can be very
useful to essentially parameterize the
URL that you publish an endpoint on and
allow your clients to connect with you
know a multitude of URLs to their
endpoint
each with a different state indicated in
the URI template so we've included that
in early draft review for those of you
know about your eye templates its UI
templates level 1 which is the simplest
form especially interested in feedback
on that and we also include you know
definition of how WebSockets integrates
with the wider web container and other
EE services so being able to inject
things like the HTTP session of the web
application you're in into a WebSocket
application you know if you imagine even
something like the newsfeed on on
Facebook where you know you have
scrolling you know Mary had a cup of
coffee or whatever people seem to say on
Facebook these days scrolling away but
this is all part of which is probably
something like a WebSocket application
or if it's not it should be bundled
together with a larger web application
that is the newsfeed there's clearly a
state that you would like to share
between individual web sockets on a web
Paige and the web the web page itself
and also integration with the web
security model how we apply the web.xml
and security constraints in the web
layer to WebSocket endpoints so that you
can say I'd like this WebSocket to only
be accessed by people who are
authenticated and people who are
authenticated and belong to certain
roles within the deployment environment
so these I build them as advanced
features they're probably not it's just
that you know I wanted to cover the
basics as this is the first time we've
we've talked about this JSON so I'll
leave you I think with about 10 minutes
for for questions and just just to say
yeah there's you know a bunch of people
already starting to implement this is
Greg Greg here jetty I know is looking
at implementing this
we've got Tyrus is quickly catching up
with the expert draft go download it if
you want to you know try this stuff out
that drawer sample is entire us for
example okay so with that questions oh
you had people first yeah so on the
client side just by specifying the W SSL
URI and then on the server side the
mapping is how to apply the security
constraints in the web.xml to protect
resources you are using the same URI
scheme so the idea is just just as if
you're protecting a servlet map to foo
we would like it you to be able to
protect a WebSocket endpoint map to foo
using the same mechanism essentially and
the protection level is at the opening
handshake which makes it particularly
easy because that's an HTTP interaction
already so it sounds kind of a natural
fit okay yes
well it depends on the implementation
I'm not sure how much will specify a
separate port for that many people some
people are just using 880 for this and
some people using a dedicated one so we
haven't really talked about that in the
expert group so I'm not sure how much
we're going to need to define that but
so it's like a bad way of saying I don't
know we don't specify anything yet I
think some people do and some people
don't
today you had a question in the corner
well in the current draft there isn't
you can just you just get the whole
thing so string or binary data or or
developer object but you know I think it
would be a good idea to be able to get
things in chunks we'll just have to you
know which would mean adding some
attributes to the WebSocket message
annotation and then specifying how the
container interprets the signature I'm
not saying it you know it would do we
definitely to think about it and design
it carefully I think on the face of it
it's a good idea but it's not in the
current current draft
yeah we looked at it we look to jax-rs
for sort of inspiration but the model
doesn't quite carry over in jax-rs you
can essentially allow a method to be an
endpoint using sub resources it doesn't
quite fit this model because there's
more life cycle so we've opted as you
can see for something a bit coarser
where the the end point is a class it
makes it a bit weak sketched out a few
things doing kind of sub resources and
sub paths but then where the you know on
open and on error and on closed methods
the life cycle methods it starts getting
a bit tangled up to be honest because
you're doing kind of four different
things with jax-rs you're really just
doing one it's just like give me this
give me this give me this
WebSockets is more complicated protocol
so we might talk about it more but it
didn't didn't map so well that part of
jax-rs the analogous didn't map so let's
do here yes
oh the JavaScript code yeah of the draw
application yeah it's part of Tyrus the
reference implementation there's a chat
there's a chat one here it is yes
JavaScript this is this is showing just
the JavaScript client the server was
written in Java
showing the API in this case you know
primarily to do you know for a while
it's going to be most the clients are
going to be mostly JavaScript snippets
in webpages we're providing a you know a
Java client side thing for rich clients
doing WebSockets but most people doing
WebSockets are doing JavaScript clients
at the moment so so here it is you know
let's see WebSocket this is a API class
from JavaScript from that a w3c standard
create a new web socket and then it has
its own way of intercepting events and
so on is pretty pretty straightforward
you had a question
yeah we did when we were experimenting
before the jsr we had sort of simple
property stuff something that I'd like
to do is to look at dependency injection
for allowing people to store things in
some sensible place probably on the
session there's kind of when you're in
the web containers off there's a lot of
different places to put this information
already so we have to be careful about
providing sort of more storage on our
API when you could put it in a HTTP
session and an EJB somewhere I mean
there's lots of places but one of the
things we'll look at you had a question
here at the end you like having a
gateway in front of the web server yes
I don't know I don't know to be honest
so we'll keep that one quick my boss has
a question
okay there we are the green shoots are
growing you had a question yes yeah well
the applicate let me try and find a
slide that maybe hold on that frames a
little bit yeah I mean I think as much
as we'll specify is what the threading
what what we need to specify we've done
to some extent is if you're an endpoint
developer on the server what
expectations you have of container
threads calling your code and so you
know one of them is that in asynchronous
messaging their calls should be
sequential and no two threads you know
calling with you know here's one bit
here's one bit here's one bit either in
the wrong order or simultaneously we'd
like I think to have calls from multiple
calls from the same client arrived
sequentially at the endpoint so the
endpoint if it just focuses on one
client it's only getting sequential
calls from that client even when it has
a hundred client it might have a hundred
threads coming in it wouldn't be a
hundred and one oh each client would
have a dedicated but not more than one
thread at any time calling into code
there are a number of those concurrency
situations that we've made a start on
clarifying for the developer because I
think our goal is to provide a
relatively friendly development
environment while sort of delegating the
issues of scalability into
the implementation so I would look at
the causing WebSocket gateway because
I'm sure they've solved these problems
they've got a WebSocket gateway and
deployment so you know I could say more
nice things but if I wanted to know the
real answer that you're asking I'd look
there I think you had a question
our natty as well yeah of course yeah
natty
no now if you want to send a you know a
binary message string message an
asynchronous message and then an apple
you just have one endpoint connecting to
one remote object just one connection
the the session and the remote endpoint
or one-on-one with the underlying
connection basically unless unless the
underlying implementation is using
something like multiplexing where it may
choose to piggyback the work of several
connections into one physical connection
oh I'll talk to you in a minute if I can
thank you everyone enjoy the rest of the
show</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>