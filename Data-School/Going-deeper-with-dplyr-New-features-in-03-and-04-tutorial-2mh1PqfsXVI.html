<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Going deeper with dplyr: New features in 0.3 and 0.4 (tutorial) | Coder Coacher - Coaching Coders</title><meta content="Going deeper with dplyr: New features in 0.3 and 0.4 (tutorial) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Data-School/">Data School</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Going deeper with dplyr: New features in 0.3 and 0.4 (tutorial)</b></h2><h5 class="post__date">2015-03-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/2mh1PqfsXVI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello and welcome to data school this
video tutorial is going to cover many of
the new features in deep wire version
0.3 and 0.4 as well as some other
functionality that I didn't cover in my
previous deep wire tutorial if you
haven't already watched my previous
tutorial I strongly recommend you watch
that first that video covered the basic
functionality of the package using
version 0.2 and I won't be repeating
that material here I'm going to be
walking through an our markdown document
that I created here in our studio if you
want to follow along this code is
available on github and there's also a
rendered version of this document on our
pubs that you could use as a quick
reference guide you can find links to
both of these below the video
alternatively you can just type the
commands as you go one other note before
we get started if you have any questions
about anything in this video please let
me know in the comments below and I'd be
happy to answer them and with that let's
get started ah so the first thing you
should know is um that even though my
last tutorial use data from the H
flights package had Lee Wickham the
chief author of the deep liar package
has rewritten all the deeper vignettes
to use the NYC flights 13 package
instead and so for the sake of
consistency I'm going to use NYC flights
13 also so if you just finished my
previous tutorial you'll want to run
this line of code remove flights to make
sure that you get rid of the flights
object from your environment alright so
let's go ahead and load up the deep liar
package and then we're also going to
load the NYC flights 13 dataset if you
don't have it you'll just want to
install that now and I'll print the
flights data set from NYC
x13 you can see that there is one row of
data one observation for each flight and
there were three hundred and thirty six
thousand flights these are just flights
from the New York City area airports so
let's jump right in to our first couple
commands we've of course seen the Select
command before and this is used to pick
columns so in this case I am just
picking the columns carrier and flight
throughout this tutorial I'm going to be
using this pipe operator which I'm going
to call then so in any case of besides
using select just to pick columns you
can also use select to hide columns so
let's say that you want to select all
columns except for the month and day
columns well I can just do that like
this and as you can see I'm now showing
14 columns instead of 16 all right so
you might remember that you can use
select to select a range of columns
using this colon operator and in this
case I'm going to actually use the minus
sign to hide a range of columns so in
other words this hides all columns
between and including departure time
through arrival delay we can also use
the minus sign to hide columns matching
a name so let's pretend that all of the
columns whose names have time in it are
not of interest to me well I can say
select - contains time and it will hide
those columns so for example the air
time column is no longer shown now
here's a piece of new functionality
let's say that I have a character vector
which I'll call
Falls and it contains the names of some
columns that I want to show well there's
now a command called one of and I can
pass it to select so I say select one of
calls and it will only select those
columns now you might not know that
select can also be used to rename
columns and let's do that here and we
see that I have selected the tail num
and I've renamed it as tail note that
when I do this all columns that I don't
mention they're dropped now this
probably isn't that useful to you but
there's a new function called rename
that does the exact same thing except
all columns not mentioned are kept which
is more likely what you want to do so
you can see that we now have the tail
num and it's it's been renamed to tail
but all the other columns that I didn't
mention are still here alright let's
move along to some functions for
filtering so you might remember that the
filter command which filters rows or
observations supports the use of
multiple conditions so in this case I'm
filtering to only show rows where the
departure time is greater than or equal
to 6 0 0 and the departure time is less
than or equal to 6 0 5 in other words
this is flights that departed between 6
o'clock and 6:05 in the morning
inclusive note that I use the comma to
separate these conditions but I can also
use the ampersand if you're doing this
particular operation where you're
selecting these endpoints you can
actually use a new command
between so this is a more concise
alternative for determining if numeric
values fall in a range and so if I say
between depth I'm six zero zero six zero
five it's the same as this command and
once again I'm filtering and again you
can see that all of these departure
times are between six o'clock and 6:05
a.m. as a side note on filtering I found
that the is n/a can actually be quite
useful within filtering so in this case
I'm filtering flights to only show
observations in which depth time is not
in any value so you can see that now we
only have about three hundred and twenty
eight thousand observations out of those
three hundred and thirty six thousand
observations moving on to another new
verb called slice slice is used to
filter rows by position so for example
here I'm going to show only rows in
positions one thousand through one
thousand and five now you might wonder
how that might be useful you've already
got the head command to look at rows at
the top and the tail command to look at
rows at the bottom well it's possible
you might want to just slice some rows
out of the middle and take a look at
those and this is an easy way to do that
but this probably isn't the most
compelling use case for slice what I
found is that slice is actually most
useful for filtering rows within groups
so in this case I'm going to group by
month and day and then I'm going to
slice out the first three rows within
each group so as you can see I've got
three rows for January first three rows
for January second three rows for
January third
and so on and these are just the first
three rows that deep lie are encountered
within those groups ah now perhaps I
don't want to look at just the first
three rows instead I want to sample
three random rows from each group well
there's a handy command called sample n
and I'm going to just pass it a three
and that just means within each group I
want to see three random rows so maybe I
don't want to look at the first three
rows or a random selection of three rows
maybe within each group I want to look
at the three rows that have the top
departure delay or some other variable
well I can do that with this top end
function and what I do is I pass it the
number of n so the number of rows I want
and then I pass it the variable on which
those rows should be chosen so let's run
this and what we see is that again I
have one row or sorry I have three rows
for each day of the year and then within
those the particular three rows that
were chosen were the ones with really
high departure delays so as you can see
earlier I was just getting arbitrary
rows and here I'm actually getting one
specifically with high departure delays
now you might note that they're not
actually sorted within each group um
which to me is probably what you'd want
to do if you were doing this particular
operation so just note that you can
throw on in a range function at the end
and if I say a range in descending order
by departure delay then I get what I
actually want
which is I'm getting three rows from
each group with the top departure delay
and then I'm sorting in descending order
by that departure delay
moving along um let's say you wanted to
identify unique rows so for example I
want to select origin and destination
and I want to see all unique origin
destination pairs there's a unique
function from base R so let's run that
and we'll see that there were two
hundred and twenty four unique pairs of
origins and destinations in this data
set now D prior actually has an
alternative command called distinct and
you'll see that the results are the same
but it's a more efficient command so
this is what des plier recommends you
use instead of unique and as a side note
um and this is something I just learned
is that when chaining you actually don't
even have to include the parentheses if
there are no arguments so for example
with distinct there are no arguments I'm
including and thus I can actually just
run it without the parentheses um it
looks kind of funny to me having you
know being used to seeing a lot of
parentheses in our um and I don't know
if this is officially endorsed and
whether this behavior will stick around
forever but at least for now it works
and it certainly makes your code a
little bit shorter saves you some typing
so let's move on to adding new variables
so we've got mutate which has been
around from the beginning of deep liar
so mutate is how you create a new
variable and let's say I want to create
a new variable called speed and have it
be a function of distance and air time
so this is speed in miles per hour
I run mutate and although we can't see
it here we've got a new variable speed
and you'll notice that mutate kept to
all the existing variables
now there might be times when you only
want to keep the variables you just
created and that's the purpose of the
new verb transmute so the syntax is the
same and when you run it you see that
the only variable that was kept is that
new variable now let's move just briefly
to a different data set built into our
called MT cars very famous our data set
and we're just taking a look at the head
the first six rows and you can see that
empty cars uses row names to store the
the model of the car now in kind of Tidy
data principles this is not recommended
it's recommended that you instead of
using row names you make this an
explicit variable in your data frame and
as such there's this new verb called a
drone aims so what it does is it takes
any row names in a data frame and it
turns them into an explicit variable
with the specified name so let's do that
and you'll see that I've now created a
new variable called model that just took
the row names from empty cars now as a
side note um anytime you are creating a
local data frame and you create a local
data frame using this TBL underscore DF
command also known as table diff if you
like local data frames they used to
print row names under some circumstances
and not in other circumstances well d
ply are no longer prints row names ever
so you should not you should not plan to
see them on any time you're using local
data frames
moving on to some grouping and counting
operations um and the first is just a
review of some
rise so let's say I want to group by
month and then summarize count equals n
so what is this exactly it means for
each month I want if I want to calculate
the number of rows and one row
represents a flight and store that in a
variable called CN T or count so let's
run this and this is telling us that in
month one there were 27 thousand and
four rows which represents the number of
flights in February there is this number
and so on so this is nothing new I
wanted to compare that syntax with tally
and count so tally is a way that you can
do this slightly more concisely so tally
just replaces this summarized command
and when I say tally does the same exact
thing except it automatically assigns n
as the column name so I couldn't define
it as CNT it's just automatically n but
it saves me some typing and it's a bit
cleaner to read now a new a new way to
do this is to use this count function
and this makes it even more concise
because it automatically does the
grouping for you so this line of code
count month does exactly the same thing
as above which does the same things here
now I'm going to show a couple more
examples of comparing summarized versus
tally versus count so here's a let's say
that I wanted to sort this data in
descending order
I of course use an arrange command so
arranged descending count let's run this
and now we can see that July is the
month with the most flights and February
is the month with the least flights I
can also do the same thing using tally
using this optional parameter called
sort and I'll say sort equals true and
you see the tally
does the same thing and then count also
has that same parameter sort equals true
and again it does the same thing so
that's another comparison of summarize
tally and count ah now note that when
you're summarizing you can do a lot more
than just counting the rows in each
group you can for instance sum over a
specific variable so in this case for
each month I'm going to summarize and
I'll say dist
equals sum of distance which means that
I want to sum up the distance values for
each row and store it in a variable
called disk let's run this and we'll see
that for example in January this was the
number of miles that was flown and this
was the number flown in February and so
on ah now again with tallien count you
can do the same thing so with tally you
have this optional parameter called WT
which I just call weight so this weight
parameter specifies the same thing here
and it will do the sum of that
particular column instead of just
counting and you can see I get the same
results and then count again has the
same weight parameter now coming back to
counting ah so remember this command
here so for each month I want to tally
all right now let's say that I want to
quickly get these numbers into a vector
for some reason well that's the function
of this group size function so let's run
this and you can see that I get the same
exact results as here except it's now
just been turned into a integer vector
okay now for something even simpler
maybe all you care about calculating
the number of groups we know in this
case that the number of groups will be
twelve because there are 12 months but
in your case you might have data in
which all you want to calculate is the
number of groups and that's what n
groups does so it just tells me I have
12 groups ah next I want to just show a
little bit of behavior that that is a
bit confusing to me and in case it's
confusing to you I want to show you kind
of a workaround so let's pretend I'm
grouping by two variables in this case
month and day and then I'm doing a
summarize doing account and then I doing
in a range okay and one thing I'm going
to throw on at the end here is this
print function and say N equals 4t that
allows me to print 40 rows so let's go
ahead and run this and let's take a look
at what we've got
so I grouped by month and day so there
of course 365 groups now there's
something that's a little funny to me so
I see that it does look like it's in
descending order but notice that all of
these are from January so there were uh
you know 943 flights in in January 2nd
and that was the greatest for January
but if I want to see February it has to
go all the way down here so in other
words um it's sorting only within month
whereas what I had really wanted is
sorting across all groups so I wanted to
know for instance the top 10 days
throughout the year in terms of number
of flights not just the top ones from
within each month now why exactly is
this occurring well I did some research
and it turns out that every time
summarize is called that removes a
grouping level so even though I group by
month and day here as soon as I called
summarize it actually drops a grouping
level so now it's only grouping by month
so when I arrange
change its arranging with that in mind
now there is a workaround and it turns
out that there's this command called
ungroup so it essentially removes any
groups that have been defined and I just
throw that in after the summary but
before the arrange and if I do that and
this time I'm just showing ten rows you
can see that it's sorting across all
months across all months and days so I
can see that the day of the year
in 2013 in the New York airports that
have the most flights was November 27th
followed by July 11th etc so ungrouped
can come in handy if you're experiencing
behavior like this and it's not what you
want moving along let's talk about
creating data frames using data
underscore frame now this is not data
dot frame this is data underscore frame
which is a new thing in deep liar so
data underscore frame is a better way
than data dot frame for creating data
frames so what are some benefits of data
underscore frame well you can use
previously defined columns to compute
new columns and we'll see an example
below it never coerces column types
it never munches column names never adds
row names
it only recycles length one input which
is probably what you want and it only
returns a local data frame which is what
a deep liar encourages so let's do a
quick example of data underscore frame
and what I'm doing is I'm creating a
data frame with four columns and I'm
sending it to blimps which is kind of
deep liars version of sturer STR
so what do we see we see that a has been
created one to six B has been created as
a times two which does work when I
created C as string you'll see it it
stays a care
instead of being automatically converted
to a factor and when I created D plus E
as my fourth column name it it leaves
that as is it doesn't it doesn't change
it and you can't tell from this glimpse
ah but this is actually a local data
frame so let's compare this to data dot
frame your standard way for creating
data frames and our I didn't bother to
find trying to define B equals a times
two here because that would fail with
data frame since um since a doesn't yet
exist at this point so you'll notice
that when I do C equals string it gets
turned into a factor when I say D plus E
as the column name it gets turned into
de and for what it's worth this is not a
local data frame all right let's move on
to joins or merges as they're sometimes
called and there's a number of different
joints um we've got for what are called
mutating joins and then to filtering
joins um if you already know joins this
might be pretty elementary for you but
I'm going to presume that you're not
familiar with joins so let's create two
simple data frames which I'll call a and
B and take a look at them and in case
you're wondering uh anytime you wrap an
assignment statement in parenthesis it
automatically prints it out with without
you having to explicitly tell it to
print so what what do we have um well we
have data frame a which has color green
yellow red and numb one two three and
then data frame B which has color green
yellow pink and size SML for a small
medium and large okay so let's start
with what's probably the simplest to
understand join the inner join so
that type of join only includes
observations found in both a and B and D
flyer will automatically join on
variables that appear in both tables so
the only common variable is color so it
joins on color so what this inner join
results in is we see green and yellow
because those appeared in both a and B
and then I get the nunc anima those
observations from a and the size column
for those observations from B okay
ah next we'll do a full join sometimes
known as an out a full outer join and
what a full join does is include
observations found in either A or B so
this time we'll see green yellow and
then red which came from a and pink
which came from B we'll see both num and
size but because uh because red did not
have a size there is no red in in B size
gets an any value and because pink was
not in a it has no known value so that
gets marked as na okay so that's our
full join our left join is for including
observations found in a so anything
found at a will be shown and so of
course we see green yellow and red
we sent num one two and three so so far
this is just what we already had an a
but in addition we also have this size
column so size small medium and then na
so it's basically these three rows but
only those three rows because ah Left
joins only include the observations
found in a oK we've also got a right
join so when I do write join
a bee it only includes the observations
found in B so we've got green yellow and
pink and then the num and then the size
so this is just like rows 1 2 &amp;amp; 4 from
our full joint okay now a lot of a lot
of people aren't used to write joins
they just use left joins and of course
you could just do a left join of ba
instead of a right join a B and they are
indeed identical except for the column
ordering so let's do a left join of B
and a and you'll see that it just swaps
the column ordering so it just all
depends upon what you want in terms of
your resulting column ordering finally
let's do our kind of filtering joins so
the first is called a semi join so when
I do semi join a B that filters a to
only show observations that match B so I
don't gain any new columns all I did was
I lost the red observation from a
because red was not found in V now the
opposite that of that is an anti join so
this filters a to only show observations
that don't match B so you can see that
between a the semi join and the anti
join we have all of a okay now of course
our matching variables don't always have
identical names in different tables so
I'm just going to rename the the color
column in B to B call instead so how do
i do my join in that case well I
actually just need to add on this
argument by equals and I pass it a
character vector that says armed color
equals
all and then if there were multiple I
could just say comma and then indicate
others but by telling the inner join
that color in a equals call and B it
successfully completes the join even
though they had different column names
and finally let's wrap up with some tips
for viewing more output so let's say you
want to print more than just the default
of 10 rows let's say you want to print
15 well you can use this handy little
print function and say print n equals 15
on note that you do have to say N equals
you can't just put the 15 there and of
course I see 15 rows now let's say your
data frame has a couple hundred rows and
you want to see all of them you don't
want to be constrained to see only 10 um
but you don't know exactly how many well
you can just say print n equals I and F
which means infinity or an infinite now
I'm not going to run this in this case
because we've got three hundred thousand
rows but you may find this to be handy
for smaller data sets um for seeing all
columns this is the the trick I use most
often if I say print width equals INF I
get to see all the columns so I'm still
limited to the ten rows but deep wire is
indeed showing me all of the columns
um now a different way to accomplish
kind of the same objective is to use
this view function which does not does
not come from deep wire I don't believe
it's a cat capital V in view if you
couldn't tell so let's run this and it
opens up this data viewer that you might
already be familiar with and as you can
see we can see 1,000 rows so all the way
down to row 1000 and we can see all the
column
I'm sure there's a limit as to how many
columns it will display but I don't know
what that limit is so I'm going to go
ahead and close that so that's another
way to view more data without printing
it out in your console here um let's say
I want to set some options so it turns
out maybe I like deep liar to print six
rows by default rather than ten well I
can change deep liar dot print min to
six and maybe I always want to see all
columns I can put the flyer dot width
equals infinite so let's run that and
now if we look at flights
we'll see six rows and all of the
columns without having to use this this
print command now if I want to reset
this I can set deep liar width back to
null and deep liar dot print min back to
ten and that will reset my options to
the usual options alternatively if you
just close our it will reset your
options and I'm sure there's a way to
set these options to be permanent upon
startup if you like so that's it for the
code I'm just going to go through a few
resources now the release announcements
on the arc studio blog for a version 0.3
in October and version 0.4 in January of
2015 I linked to those here there is a
nice quick read the deep liar reference
manual in vignette Songkran those are
certainly worthwhile
there's a lot of vignettes they're
always being updated and they're quite
thorough in covering certain aspects of
deep liar one particular vignette that
might be of interest to you if you want
to learn more about joins is this two
table vignette specifically it also
includes set operation
which I did not cover during this
tutorial um highly recommended is our
studios data wrangling cheat sheet which
is a two page very well designed visual
for both deep liar and tidy are for
tidying data on and finally we've got
the deep liar github repo if you want to
keep up with development or the list of
releases and you can read the very
detailed release announcements which is
a lot of how I prepare for these video
tutorials is reading those in depth so
thank you so much for watching if you
have any comments or questions please
let me know in the comments section
below and if you enjoyed this video I'd
love to have you as a Youtube subscriber
so that I can let you know when future
videos come out
so please do click the subscribe button
as well I have a blog and an email
newsletter in which I cover a much wider
range of topics including our Python get
machine learning and data science in
general so please check those out and
again thank you so much for watching</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>