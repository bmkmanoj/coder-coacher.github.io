<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Houdini: Demystifying the Future of CSS - Google I/O 2016 | Coder Coacher - Coaching Coders</title><meta content="Houdini: Demystifying the Future of CSS - Google I/O 2016 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Houdini: Demystifying the Future of CSS - Google I/O 2016</b></h2><h5 class="post__date">2016-05-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/sE3ttkP15f8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright hey everybody I'm gonna use the
remainder of my voice to tell you about
Houdini so if I go full adolescent
crappy voice on you I apologize in
advance but I've done a lot of talking
in the last few days but I'm very
excited that a lot of people came here
to listen to me talking about Houdini
which I want to talk to you about so
this is about Houdini and the subtitle
that you can read here is the title of
an article The Smashing Magazine
published which says it may be the most
exciting development CSS and actually
this article was written by a colleague
of mine in devrel and the article goes
at the subtitle goes even longer saying
may be the most exciting development CSS
that you've never heard about because so
far the entire Houdini effort has been
kind of flying another radar so for the
poor alton who wrote this article joined
forces with Shane Stevens and Ian
Kilpatrick who are chrome engineers who
are leading the effort in chrome to work
on Houdini so this article is not only
really good it is also really in-depth
so if you want to have more reading
after this talk I encourage you to go
there and read that it's just a good
article so before I start getting into
the whole gory techy details of how
Houdini works I just want to make sure
that all of you know what Houdini is and
where is trying to we are just try to go
Houdini is the effort of exposing the
internals of the CSS engine to you as a
developer and that sounds a little bit
ominous I'm gonna explain that a little
more and afterwards I'm gonna talk a
little bit more about the individual
parts of Houdini where they are at right
now where we're going and all these kind
of things so actually I wrote a blog
post too even before Smashing Magazine
so I wrote about Houdini before it was
cool and I did that because when I
started on the Bedini project which was
back in January of 2016 there really was
no publicly available and easily
consumable information about Houdini
there was a website which was a
glorified wiki really and it just linked
to the specs and the specs were empty or
they were like you know specs just very
hard to read and consume and to
understand what the motivation was and
so I had the privilege to just go to my
Google colleagues the actual engineers
working on this and have them explain to
me why this exists and so I wrote the
blog post and I did the whole thing I
put it up on the Twitter's and the
Internet's and I had a lot of feedback
and was really interesting because loads
of people were just mind blown by what
Houdini was trying to do and one person
was Dan tahini who is the inventor of
GSS the great stylesheets a constraint
based layout system for the web and it's
now the CEO of the grid
so he said Houdini sounds like the best
thing since sliced bread and of course
you would say that because both of his
projects are really deeply invested into
CSS and the more powerful CSS gets the
better his projects become but he was
not the only one so in fact if he he was
mind blown and I was asking myself why
is it is it really that mind-blowing why
does it feel that way because to me
certainly did I was blown away when I
heard first about it and what it comes
down to I think is that you are getting
access to browser internals you now have
things at your disposal once Houdini
lands that weren't at your disposal
before it feels very very raw and
fragile and actually kind of secret
because usually it's reserved for
browser engineers and not the web
developers so you now have kind of have
the tools of the gods at your disposal
and that make things really really
interesting and the thing is this has
actually happened before there are two
technologies that were pretty much the
same level of mind-blowing but and
polymer made have use of it and it made
polymers so good but people were
crediting polymer instead of a web
platform and things I'm actually talking
about our shadow DOM and custom elements
these are web platform standards that
supposedly are supposed to end up being
implemented by every browser and polymer
sits on
of that and they're emulating oh they're
giving you access to a browser and
Charles for example shadow Dom look at
the markup right here the video element
if you think about it where do these
elements come from nobody in the mark-up
do I ever specify the play button or the
progress bar they just appear and and a
subsequent question is how do i style
these magically appearing elements if I
never put them in the markup and since
shadow Dom we actually have an answer to
this question because now we can
actually in the inspector we can open up
video elements and see that the play
button is just an input type button and
we can base maybe even style it and this
has always been this way browsers have
always used their own elements
internally if you want to have this kind
of hidden control elements but you were
never able to do that yourself because
Shalom wasn't the thing and now you can
but again people thought this is just
polymer emulating something that looks
like a browser internal but that's not
the case as a platform feature this is
actually how the browser's work so again
both shadow DOM and custom elements are
specs that's supposed to expose
something to you that the browser
already had internally and now it is at
your disposal
and it enables you to recreate behavior
was already there before but you
wouldn't have been able to do this like
these magically appearing elements you
wouldn't be able to do this before and
this kind of mind-blowing this has a
name it's the extensible web manifesto
and the key code for me from that
manifesto is the web platform should
expose low-level capabilities that
explain existing features and allow
authors so you to understand and
replicate them and again think about how
fitting this is for custom elements and
shadow Dom exposing things that were
there before but religious puzzle and of
course it goes further it not only
allows you to understand things or to
replicate things but you can combine all
these low-level capabilities into
something potentially new and
mind-blowing and when you said this as
you go that you want to expose all these
low-level
capabilities that look like black boxes
before and you look at the current state
of the web you find a lot of things
where they say this could be exposed and
this could be exposed and one of these
glaring shortcomings is CSS and that's
why Houdini exists custom elements are
Dom tackles the Dom turned the black box
Dom into something more open Houdini is
trying to do the same thing with CSS and
people keep asking why it is called
Houdini and nobody knows I actually
asked him last week the task force and
they had two stories and none of them
knew which one is true so I'm gonna tell
both of you the first story is that CSS
is magic it's just another word for a
black box it's really magic you just
where does does it say what display flex
even does you just change from display
block to display flex and suddenly
everything rearranges how does it happen
where is it sad how border-style dashed
is supposed to be drawn exactly Houdini
is trying to demystify that the other
story is that CSS a straitjacket and we
want to escape that straitjacket and the
goal is whatever the origin of the name
is the goal it's the same we want to
expose all this to you so you can
actually use this low-level features to
build more and greater experiences on
the web so we need to expose all these
low-level api of the CSS engine and let
me read this off this is not a chrome
brainchild this is actually and I'm
going to read this because I don't want
to forget anyone Microsoft edge Mozilla
Firefox Apple's weapon Safari Opera HP
IBM Intel Adobe and LG are all
participating together in this workforce
to make this thing happen so it's not
like one browser supports you nobody
else does but this is a web platform
feature in the form of the future
everybody else is working on this
together to be on the same page and work
towards the same goal so let's talk tech
the first off Houdini is not a single
API it is a collection of api's and I
made this graphic and this is not even
complete I skipped over a few of these
smaller specs or the more basic specs
that the other specs work on top of
because they were kind of boring to
explain by themselves but these are the
ones I'm gonna focus on and the grouping
of these specs is my personal emphasis I
grouped them kind of by synergy because
these specs that are close together work
very well together but there's no
limitation on how we can real on how you
should use them and what what you should
keep in mind though is that a lot of
these specs are still empty or just mere
placeholders for an idea and need to be
fleshed out and SPECT out and
implemented and try ashed so for this
talk I'm gonna focus mostly on the least
immature ones which are arguably these
for some of the other ones are not even
drafted or just an idea I'm gonna
explain all of these on the slides at
least roughly but the four highlighted
ones are the ones I want to take a
closer look at so let's take a look at
the very first cluster these two api's
have the goal of introducing typing into
the JavaScript API for CSS currently
typing is in a really weird spot for CSS
which I think I can explain best by an
example because currently when you want
to manipulate styles from JavaScript
things start to hurt a little bit so you
probably you've all written something
like this before you just have your
variables and you want to turn them into
a style so you do a lot of string
concatenation and you append units and
only thing you want to do is just move
something by changing its transform and
this is not only unreadable it's
actually kind of ridiculous when you
think about it because we have numbers
and we turn them into strings to pass
them to the CSS engine so that CSS
engine in turn can distract that string
again turn it into numbers and do its
thing under the hood so we are really
wasteful here with computational Styles
es2015 made things a little bit better
in terms of readability because we have
template strings
now but it's still strings so the
wastefulness is still there and it's
just it's just not a good idea
things get actually even more ridiculous
when you think about it when you try to
read back styles from the CSS engine and
use them so you have to strip off the
pixel suffix yourself or if you want to
work with transform func that I make
functions or CSS matrices good luck and
this is where the type object model
comes into play it exposes a typed API
for CSS I say typed it's still
JavaScript but at least now we have
units and values separated and what I
mean by that is something like this the
new API the new API is mostly contained
in a style map on Dom nodes and with
that object you can set styles and you
can query starts when you set Styles you
said you'd give it the property you want
to set and you use one of the new types
that they have introduced for number
values keyword values or length values
which can be pixels or EMS or the ages
all these things that you have in CSS
obviously you can also query something
where so when you set something you get
something back and the mind-blowing part
here is now you have a dictionary which
has a value and a type so you don't have
to do the string parsing yourself great
accomplishment this thing goes also
further because it also handles calc
values so if I said a calc value I will
get a dictionary back that has a entry
in a dictionary for each of the units
that are in that calculation so I don't
have to do a rithmetic parser myself
which is really good and then they
realized hey wait if we have a
dictionary right don't we also allow
setting the value with a dictionary so
it's actually much easier to assemble
styles programmatically and with that
arithmetic becomes a lot more
comfortable to do when you write
JavaScript and then they thought about
well it is easy to be to do arithmetic
but I don't why don't we support
arithmetic as a first-class citizen so I
added basic arithmetic method as well
and they would turn simple legs into
calculus automatically
from the engine if the units don't match
up so this is really nice if you have
something like Paul Lewis's flip where
you have to take calculations and mix
and match certain types together it
makes JavaScript much easier to write
the CSS the spec actually has a table
that maps from property name to the
types that that property can take but as
you can see some of the types are not
actually linked that means they don't
exist in the spec just yet they just
haven't been suspect out and for these
the API will currently fall back to the
string representation so right now you
still can't really handle transition
timing function values but that will get
around with it and one of the future
iterations of the Houdini typed om spec
and I think one of the most interesting
parts of this is that we have a we had a
hacked implementation or a premature
implementation of the type 2 m in a
custom build for Chrome and did some
performance testing on very high
animation websites and it had an impact
of up to 90% faster code which i think
is amazing or just shows you how much
time is being lost and converting back
and forth between strings and numbers
when you do animations there is a
polyfill that is being worked on it is
not complete yet and it's not very easy
to use at this point apart from the fact
that you should never use this polyfill
in production because you add another
layer of converting strings to numbers
because the API doesn't exist so we do
it in the library for you it's just a
huge performance hole but I still
encourage you to use it and play around
with it because it is very nice to just
play to see how this API fields and we
need your feedback for that because as
of now we have the chance that she'll
still change all of these API they're
just in the drafting phase so nothing is
really stable so you have the chance to
get involved and I'm telling you once
you actually start using that polyfill
and just play around with just
manipulating CSS from JavaScript you
will say that is so refreshing that is
so good
and as I if you want to involve do it
you have the chance you would never want
to go wet go back but for now sadly you
have to so that's type 2n the next thing
I want to look at is properties in value
which ties in very very closely to the
type to M spec and if you think about
properties in virgin think custom
properties
you'd be right because it's very much
related to that at the current stage
custom properties has been a thing for a
while now
however they work on the basis of
strings and why wouldn't they because
before Houdini CSS was purely string
based at least the part that is exposed
to you as a developer and therefore the
usage of custom properties worked with
single string replacement which doesn't
seem too bad but let me give you an
example let's say you wanted to
implement a side menu a side nav that is
you know almost hidden away when you
click it it expands very common thing
and you realize that the width the
extent of expansion of that side nav is
used in multiple places not only on the
transform of the side nav element as
well but maybe on the transform of the
body or maybe as a padding somewhere
you're using that value in multiple
places so it seems kind of like a good
idea to put it in a custom property
because you're using that value all over
the place and then you don't want to
just snap out the side now if you want
to animate it so the idea would be to
just animate the custom property instead
of all the properties that use this
custom property so you write that and as
it turns out custom properties are
strings and strings are not really
animatable because you can't transition
between two values of a string what is
30% between string a and string B the
engine doesn't know that so what will
happen instead is it will just flip over
from the start value to the end value at
50% of the time and that's not smooth
that's just flipping out and doesn't
look like a real animation so that
really doesn't work and actually things
get even realer with the current state
of custom properties because when you do
a weird miss assignment by accident for
example
a color - with it we'll just silently
fail and you will know we will have no
idea why it is not working so the
bugging becomes really hard
enter properties and values properties
in values respect the API the new is
actually really small it's just one one
call really and allows you to define
more details about your custom
properties so what you can now do is you
can say what kind of syntax the custom
property has which basically means what
type that custom properties has you can
have control over if it inherits down
the CSS tree or not and what it's really
big in terms of custom elements is that
you can give it an initial value custom
elements use custom properties a lot to
define their looks on the things they
have in the shadow Dom or something they
want to give special access to and at
the current stage you have to define
every custom value a custom property
they define and now you can have an
initial value which will be used if the
value hasn't been overwritten so it's
really handy so now we are able to write
JavaScript that interacts really really
well with styles and now we come to the
spec that personally I think is the most
exciting because we have our basis of
having being able to write JavaScript it
looks really good works really well with
CSS and composited scrolling animation
makes heavy use of that just to be clear
the spec is called composited scrolling
and animation while its main feature is
called compositor worklet and people
tend to use these two terms
interchangeably but the question really
is what problem does it solve let's say
you wanted to mimic an effect of a
popular social networking app you can
see we are scrolling down and the avatar
changes position according to school
position and it scales and also the head
of our fates in and this would be kinda
possible on the web right now actually
you would hook up to the scroll event
you would start a requestanimationframe
and in that requestanimationframe you
would Paul in the scroll top and do your
math and change the transform and if
you've ever listened to Paul Lewis you
would know you would have to change will
change to have it on its own layer
because otherwise you would have read
Jayne's so it's really hard to get this
right without ripping a huge gaping
performance hole into your current app
so before I start talking about the
composer worklet what are layers I'm
assuming maybe not everyone knows this
layers are more of a logical concept
that manifests as a separate buffer on
the graphics card whenever a Dom element
has their own layer it means that on the
graphics card they will have their own
buffer on to which they can paint
themselves and that means that changing
the transform like opacity or Tran
translation scaling or rotation will be
a pure GPU operation instead of forcing
repaints all over the place so the only
thing that needs to change when you
actually change the transform is the
compositor re merging the images to the
thing that you actually see on your
screen and this is really important
because GPUs are really really good at
that and we want to be as close as
possible to 60 frames per second to make
the app actually feel good so as I said
this is kind of possible with the
current approach when you really know
what you're doing and even then we are
still at risk of having an animation
that lags behind so this is a normal dom
anna normal diff box on a website ram
scrolling just up and down looks normal
as we all know but if I add another box
that is statically positioned and try to
use JavaScript to do the same thing
basically your re-implementing scrolling
myself it will most likely look like
this to be fair this video is slowed
down to make the effect more obvious but
even in real-time it is very very
noticeable and make scrolling effects
usually seem very laggy on the web and
this exactly is the problem that the
compositor worklet is supposed to
address it allows you to write a piece
of JavaScript that runs in sync with the
rendering pipeline instead of being
async because the problem we had
previous is that we're doing consuming
async data and our getting get it as
mostly out-of-date more often than not
so now we have a piece of code runs in
sync with the framerate and you get
access to all the layers and you can
manipulate the transform
of these layers and do the kind of magic
in there to implement what we just saw
and this is easy now because we have
typed two M's with writing JavaScript to
change transforms should be a piece of
cake eventually but what exactly is a
worklet that kind of jumped over that so
worklets are actually one of the
additional specs that i left out in the
original image a worklet is kind of like
a JavaScript worker but much more
lightweight they have been stripped down
of certain axes and have been have
certain restrictions and I'm not going
to get into too much but they still run
in a different thread and that's the
important bit because whatever you run
in a worklet will not interfere with
your main thread so they do run in a
different thread but that also means
they don't have access to the Dom so we
do have to find another way of doing
that inside the composer workers we can
now define multiple animator objects
each animation to separate the code for
different animations that you might have
on your website and as I said we have no
access to the Dom so we need to find
another way of doing that and that where
the composer worklet spec defines
proxies these proxies give the animator
access to certain properties of certain
Dom elements so that you have although a
very restrained or restricted but a very
precise access to the Dom in the
composer worklet without us having the
risk of you modifying everything there
so this very well defined what you're
gonna change but let's look at some
actual code so let's say we want to
implement the thing that I showed you a
video of the twitter-like header bar the
first thing that we're going to do is
we're going to import a javascript file
into our composite worklet with this
statement the the script will be
evaluated inside the composite record
and it's just a normal javascript file
with its own scope but as i've had no
access to the dom and inside this world
we can define a class and can register
that class as a animator class with a
name we need that name to head get a
reference to it in the main thread later
on and inside the class we mostly have
two important functions the first is on
message which allows us to have post
message style communication with the
main thread
and the second is the tick function that
will run every single frame in sync so
it is blocking so that means also it's
not necessarily true it does not
necessarily run every single frame but
it's a good assumption to work with
because it very well can happen but it
means that the code in the tick function
needs to be efficient like like really
efficient so the tick function would
basically contain what we had in our
requestanimationframe before we would
get the scroll table we would do the
math around the transform and set it on
the Avatar back to the main thread after
we have called import we get back a
promise that resolves once the composer
worklet has evaluated the entire
JavaScript file and now we can create an
object is a reference to this animator
class that we just registered on the
Alpha thread on that animator object we
can call post message to basically
create compositor proxies that are
proxies for the elements that I'm
calling there so for the window because
we want to have access to the scroll top
and to the avatar and the bar because
those are the elements that we want to
change the transform or opacity on this
is kind of important because this allows
the engine to optimize when our code
actually really needs to run the scroll
top didn't change we don't need to do
anything but if we are scrolling we are
actually changing scroll top every
single frame so our code will run every
single frame so the performance
assumptions about this code still need
to hold up and that's actually kinda it
I mean I skipped over the math and the
skipped function but this is now
something that would run in sync with
this with a composer engine and should
look really nice so I recorded this
video which is recorded with a custom
build of chromium where we have kind of
a hacked inflammation of the compositor
worklet and you will just have to
believe me when I tell you that the the
difference is really notable in terms of
how reactive the scrolling is chrome
engineer Robert flag actually wrote a
polyfill for this as well so again this
is without any performance benefits
because these kind of things are by
definition or poly fillable but
again it gives you a feel for the actual
API itself so the polyfill uses the
approach I mentioned earlier on
requestanimationframe and hooking up to
the scroll event and these kind of
things and in the repo that's actually
also the code for the demo I just showed
and two more demos and each of the demos
follows have a link to a video where
record these demos in a Houdini enabled
browser so you can actually see the
difference to how your browser behaves
and how Houdini browser would behave the
future will tell how this works out
lastly I want to talk about the paint
API also called
paint worklet the API allows you to
define your own paint routine for
elements basically enabling you to
define your own background patterns or
border styles or even your own shadows
they're still working on where to draw
the line but effectively it is somewhat
like a canvas you might be asking why
not a canvas well mostly because a
canvas is really really heavy weight
it's a very memory heavy and processor
heavy element and also it has a separate
resolution that doesn't scale with the
element itself so you get this weird
stretching effects if a canvas gets
rescaled and you don't have good control
over when a canvas needs to repaint
itself but how do you use the paintwork
late' basically it works as a background
image where instead of an actual image
you now use a function to your own paint
implementation so I've this back is
pretty fresh so I'm not gonna do too
much of all things but I'm going to take
this example which is straight from the
spec and the goal of this example is to
show a temporary image as long as the
actual image that we are linking to has
not been loaded yet so we're going to
register a custom property that gives
the text the actual image and we're
going to use our paint function to draw
the temporary image as long as the
actual inner image has not been loaded
then exactly what we're gonna do we're
gonna register a custom property with a
syntax image so that means that the
browser can tell us when we actually
assigning a length to this value
and we actually need this to have deeper
access on the JavaScript side and then
we're gonna work again with the paint
broken up attribute and just import a
JavaScript file into that worklet inside
that worklet we will now register a
class and the first important thing is
again that we tell the engine which
actual properties we actually penned on
again this allows the browser to kind of
optimize when we get to repaint
ourselves we are saying we own depend on
the image because when the image changes
we need to repaint the new image but we
don't care for example about margin left
of margin left changes we don't need to
repaint everything is the same and then
we're gonna look at the actual paint
function the paint function gets a
context which is very much a canvas
context just stripped down of any kind
of read back because for security
reasons you should not be able to just
inspect what the element looks like just
because you're a paint worklet we get
the geometry of the elements so this is
one of the advantages over standard
canvas that we know the the size of our
element are for layout because painting
happens after layout and we get a
dictionary with all the properties that
we defined we need access to so what
we're doing then is that we are
requesting access to our image property
custom property and switching over the
state of that image because we have type
2 n we know it is an image and that
image has a state attribute that tells
us if the image has been loaded or not
so if it is pending
meaning it's still being loaded we draw
mountains in this example if it is
invalid meaning the loading has failed
for whatever reason we draw a sad face
and if the image has been successfully
loaded we draw the image itself that's
with the least immature specs of the
hood of Houdini right now and now I just
want to quickly cover the ones I I left
out so far from the image and as I said
most of these are kind of empty or just
symbolize a future idea that needs to be
fleshed out but they're still really
exciting and one of the things that's
really exciting is the layout work on it
the spec is pretty empty is what I would
have said last week but we had a meeting
of the Houdini work for slacks we can
actually Ian Kilpatrick proposed a
complete I had a proposal for the API
and it's pretty hard to grok but still
it would allow you to write your own
layout for CSS so something that would
be possible in the very near future for
example would be to have an actual
implementation of masonry layouts
something that the web doesn't have
right now and it would be implemented
with the very same tools in native
browser engineer a browser engineer
would have a terrace puzzle because this
is a very same API so once this lands
this would allow great polyfill ability
for the future of the web because any
layout idea that come up can just be
implemented in the very same way a
browser engineer what can be tested and
if they actually prove to be useful
browser engineers can port the jobs and
implementation to C++ or whatever the
browser uses and become an actual native
implementation another great use case
would be grid style sheets which is as I
mentioned earlier a constraint based
layout system which is really
interesting but right now runs on the
main thread and makes your site really
behave really weird at times especially
when layout is being triggered so I
guess they would benefit a lot from
having a native or almost native
implementation using the same api's the
font metrics api is is exactly what it
sounds like it will allow you to finally
know the answer to the question how big
is text x and font y with font size z
going to be because right now this is
surprisingly hard keep in mind that this
calculation actually gets really really
complex because most of the time text
wraps and you might need to have access
to not only the entire bounding box but
the individual lines of the wrap text
and text op often changes the font
without you noticing think about emojis
emojis are different fonts than the font
you're actually using so you have
different metrics and that it's just
it's very complicated
it can't be polyfill to be neat browser
level support for this so one example
would be auto sizing texts some attacks
it adapts to the width of the window how
do you do that right now this is an
implementation by Paul Lewis where he
does a canvas and an iterative loop and
he uses black magic and it's just
bizarrely difficult to achieve this at
the current state and this is something
that should
become easy eventually with this back
the power suspect is arguably the most
ominous of the mouth because there's
nothing in there I just talked to some
engineer who had the idea and he was
like yo this somehow works with a string
and then you can modify it so III tried
to ask a little more and he gave me a
rough explanation so you give him some
string you get back a abstract syntax
tree like object you can easily modify
and turn into actual CSS directives feed
that to the CSS engine and turned into
styles you will have hooks for at
directives and for properties and
functions but that's all I know really
the future will tell they're still
working on it so this is something to
keep an eye out but now for the
interesting part due to let's let's call
it unfortunate timing you can't use any
of this however however a subset of
these api's these three IP eyes are
actually in trunk of chromium and that
means that we're pretty soon is gonna
have them behind the flag in canary and
once this lands I will tweet it out
every day and make people use it because
we need your feedback we want you to use
these and see if it solves problems for
you if you are able to understand and
use them so you should be able to play
around with them soon I wrote a blog
post on web updates which I basically
reiterates this talk and my goal is to
keep this blog post up to date with the
most recent progress and development and
the current state of the API is of
Houdini so go there keep an eye out for
any updates on when it actually lands
and once it has landed I would encourage
you to play around with it and give us
feedback so go there and leave something
in the comments section or use Twitter
same goes if you have a problem with the
API or if you think you have a
suggestion that it's worth considering
if something turns out to be good we
still have the chance to actually
incorporate it into the specs that are
still all evolving in are all drafts so
Ian Kilpatrick who I mentioned earlier
is the chrome engineer on Houdini leads
on the entire project from
Google site and he said that he really
is really eager to hear all of your
opinions and wants to hear your feedback
so go annoy him and traitor or go annoy
me on Twitter we really want to hear
what you're doing with this entire thing
and that we have still a chance to
change how things shape up in the future
so I hope that this kinda makes you
understand what the extensible web
manifesto is all about when they say
they want to expose low-level features
to you this really gives you the power
to over the future of the web because we
are exposing the building blocks so you
can build everything on the web it makes
also it makes it much easier in general
to keep up the pace at which the web has
been developing in the past because you
all know that there's all these plans
for great new features on the web and
then it takes two years for everyone to
adapt if we expose these low-level API s
we can do polyfills that actually work
and you can do work as if the browser
already had implemented themselves this
will basically fuge is one more step in
future proofing the web against all the
ideas designers will come up with
eventually so III agree sorry I get it
we're kinda in this painful spot right
now between we have a solution for all
the polyfill ability but it's not
implemented yet but I think the prospect
is exciting enough to just power through
the section and just try to get to the
end as fast as possible if you have any
questions about this I'll I'll be around
I'll be happy to talk to y'all thank you
for your attention</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>