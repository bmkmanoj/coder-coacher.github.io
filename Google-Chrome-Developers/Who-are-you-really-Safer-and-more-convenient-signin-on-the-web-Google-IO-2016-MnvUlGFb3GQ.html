<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Who are you, really: Safer and more convenient sign-in on the web - Google I/O 2016 | Coder Coacher - Coaching Coders</title><meta content="Who are you, really: Safer and more convenient sign-in on the web - Google I/O 2016 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Who are you, really: Safer and more convenient sign-in on the web - Google I/O 2016</b></h2><h5 class="post__date">2016-05-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/MnvUlGFb3GQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Sabine bar say I'm the
product manager on the chrome password
manager team Michael XE and I are here
today to talk about making the sign in
experience easier and more secure for
your users now let's see how many of you
have ever had to use the forgot password
link on any website before show offense
okay that's really a lot of people now
let's turn it around for a moment how
many of you have never had to use the
forgot password link okay no one I
totally understand I think we've all
been there we've all needed to reset our
passwords at some point and this is what
most silent screens look like and when
users land on these sign-in screens they
often don't remember which email address
they used which pathway they used or if
there is one of those buttons and that's
a lot of cognitive load for a task that
could actually be quite simple like
signing into a website and a Bloomberg
study shows that thirty percent of help
desk calls our password related hmmm and
this is how it looks like when most
people type in their credentials on
their mobile phones what do you think
this number is yep it's the most popular
password in 2015 and what do you think
this is correct this is the second most
popular password in 2015 but the
complexity to remember passwords does
not only lead users to use weak password
such as password or 123456 it also leads
users to reuse the same password across
lots of different sites and that's of
course a significant security risk in
fact a study conducted by Verizon shows
that seventy-six percent of account
vulnerabilities were due to weak or
stolen credentials that means current
ways to sign in our nighttime user
friendly normally secure but out of
complexity comes opportunity and that's
what we want to focus on this talk today
we are going to talk about three
solutions to help assist your users
getting authenticated to your site first
we start off with password autofill and
how you can annotate your forms it's
just a few lines of code to really
guarantee that your password forms are
treated properly by password managers
and then Mike is going to show you how
you can layer the credential management
API on top of your existing silent
system to allow your users to sign in
with just one tab and then alex is going
to show you how you can use security
keys as a second factor an additional
layer of security for your art system
okay we have seen that current I flows
are broken for users and password
managers can actually be of great help
here they can remember are your
passwords for you and they also take out
the need for you to type them like we
saw earlier so that's great and this is
how it looks when a user signs in to a
website chrome uses a bunch of
heuristics to automatically detect a
successful signing event and then as you
could see here prompts the user to save
the password and I'm going to use our
returns to the side there's no need to
remember or type anything anymore the
credentials are just auto filled and the
user can go straight to content and this
also works across your devices as long
as you are signed in with the same
Google account and the bestest does not
only work in crawl across your devices
but also with your Android native apps
that means passwords that you have saved
for a website and chrome can be used to
help you sign in to the respective
android- app and vice versa and in order
to enable this cross-platform experience
for your users you can use the smart
lock for passwords ap is for your
Android native app and then you can also
do the mapping between your app and your
website ok so chrome is already doing a
fantastic job today by helping users
sign in more easily by assisting eight
billion success with silence a month and
it's really great and to a large extent
it should work without any extra work
required from your side but the system
cannot be perfect and every single time
the system fails is a time that someone
has to type their credentials but you
can fix that by giving password managers
hints to really ensure that your forms
work properly and these sins should also
work across all modern browsers and
password managers now the system that's
built into chrome and most password
managers is your wrist exposed and one
thing that password managers care about
is understanding what are and what are
not the username and password fields on
your forms you basically look at the
form poor sit and try to extract meaning
from it and sometimes this is very
straightforward but sometimes this is
rather difficult and this form here is
an example of a rather difficult case we
just don't know which of these text
fields represents to user name that
means we simply guess and there is a
decent chance that we are guessing
correctly but again here you can solve
the problem by explicitly declaring your
intent in the forms markup you can do
that by adding autocomplete attributes
to your forms to explaining the purpose
of each field to password managers and
in this case since we are talking about
sign up forms here you should also mark
up your password field with autocomplete
equals new password to prevent password
managers from auto filling previously
saved credentials into your sign-up form
now after your users signed up they also
will sign in at some point hopefully and
then um you should again mark up your
username field with autocomplete
recruits username very straightforward
and then for the password field you
should use autocomplete liquids current
password now from time to time your
users might want to change their
password and change password forms can
contain both the old and the new
password so here you should use
autocomplete equates current password
and new password here it's also
important to include the users username
you can delete for example in the hidden
text field just to make sure that the
correct username is being captured for
the update and when you mark up your
forms like this chrome is also
significantly more likely to auto Jenner
read a new password for your users
during account creation which then
hopefully keeps them at some point from
using 123456 in fact we've been
experimenting with this feature for a
while in our canary def and beta
channels okay we have ground rules are
pretty fast but if you want to come back
to it later just check out these links
there are a lot of example forms using
these autocomplete attributes and then
also check out the smart lock for
passwords api's for your Android native
app okay to wrap this up as you've seen
autofill is really great but just a few
lines of simple code you can fix so many
of these issues for your users across
the board and that's really the
foundation but what about eliminating
the sign in screen are together that's
where the credential management API
comes in and with that i'm handing over
to Mike who's now going to tell you more
about that Thank Sabine my name is mike
west I am a software engineer on chrome
security team and I'm responsible in
large part for the implementation of the
API that we're going to talk about just
a moment so if you have questions
afterwards I'm a good guy to catch as
you just heard password managers today
our Rube Goldberg ian piles of
heuristics they certainly get to the
right result but they do it in a way
that isn't quite as explicit as it could
be so in this image that you see to
decide if any of those strings break or
if that bird decides it doesn't actually
want a cracker today then you're not
going to get your mouth white with this
amount automatic napkin and that you
know would be quite sad password
managers are quite similar they piece
together a picture of what's happening
on a particular page by parsing through
the markov trying to assign meaning to
all of the things on the page based on
attributes that you've just heard about
but also based on their position whether
they're inside of a for mother that
inside of a form they then try to model
user behavior by hooking into things
like form submissions and xhr or fetch
in order to determine what the user is
actually doing on the page and how the
browser or the
a spur manager can assist the user now
we do pretty well all things considered
but let's be clear we are guessing and
sometimes we're guessing correctly now
of course we guess more correctly more
often when we have more information so
you should absolutely use the
autocomplete attributes that subpoena
was just talking about but wouldn't it
be nice if we could avoid guessing
entirely if we could avoid all of the
complexity around here and focus very
simply on the thing that actually
matters that is the users intention the
credential management API gives you as a
developer the ability to integrate more
deeply with the users credential manager
you as the developer of a website
understand how a user is actually using
your site you understand their intention
because you have a deep understanding of
the meaning of everything on your page
you know whether they're signing in with
a username and password you know whether
that signing was successful more to the
point you know whether they're doing
some sort of federated sign it using
Google or Twitter or Facebook or any
other identity provider password
managers today simply have no
understanding of these mechanisms the
browser season navigation but has
absolutely no understanding that that
navigation is actually a silent event in
short you can avoid the kind of fragile
machinery that we've just talked about
you can pick up the napkin and you can
wipe your own mouth creating a seamless
experience for your users getting them
signed into your websites now this quote
from kayak shows I think a good
understanding of what users want and
what developers want giving users a
simple sign-on experience but a secure
and seamless is incredibly important no
one likes typing passwords no one likes
sign in forms if we can get rid of them
or at least show them to users left less
often I think pretty much everyone is
going to be happy now on the screen
beside me you'll see a list of companies
who have already taken the napkin into
their own hands by deploying bits and
pieces of the credential management API
into production I'll show you some
examples of the UX improvements that
they've achieved as we walk through the
nuts and bolts of the API over the next
few minutes but don't take my word for
it you can actually experiment with this
API today on your own
websites it's enabled by default in
Chrome Canary dev and beta and we plan
to ship it to stable along with chrome
51 which should be coming out later this
year it's our apps right later this
month it's a really good time for you to
start experimenting with this because
it's still early days in the API and
since not many people are using it it's
a really good time for you to give
feedback to us so that we understand
your needs and we can ensure that the
API is actually meeting those needs so
let's talk about the flows that folks
generally have on their websites and how
the credential management API can layer
on top of those flows in order to give
your users a better experience now most
developers that I've talked to have
started with very simple and
straightforward sign inflows the user
types in a username and password or the
password manager fills it for them they
click Submit and the form is posted as a
top-level navigation to some landing
page the response sets a session cookie
and booth the user is signed in just the
way that you're doing it today now this
is indeed quite simple and it does work
but it has some drawbacks the biggest of
course is that navigating via form
submission means throwing away the
current page entirely redownloading the
payor the new page the response
potentially redownloading new resources
for that page parsing through all of
them rendering building a layout tree
and then painting now it updates the
entire page it's slow it can be janky
and jarring for your users you can
create a significantly better sided
experience if you start moving towards a
more asynchronous mechanism that has the
potential to improve the users
experience so the notion of a
progressive web app for instance is
something you've probably heard a lot
about at this conference what I would
suggest is that it's a good idea to
build an application shell that renders
some sort of loading graphic while
checking locally to determine whether or
not the user can be signed in whether
credentials are available if those
credentials are available and they can
be posted to the back end using fetch in
order to sign the user in asynchronously
without actually navigating them for one
page to the other now the response might
contain a JSON blob filled with some
useful information in order to render
the rest of the page to give the user
that's
and experience give them access to their
data and give them exactly what they
want when going to your website and they
can do that without jarring the user
through a janky full page navigation now
the credential management API is tuned
towards this kind of sign-in flow but it
can be layered fairly easily on top of a
navigation base flow as well and we'll
talk about that in just a moment
aliexpress is a great example of the
kinds of flows than this API enables
it's a shopping application so of course
it's important for users to actually be
signed in because when they're signed in
they have access to their shopping carts
they can look at things they've tried
the purchase in the past and most
importantly the purchase flow will
actually work because all of the users
information is already there they can
buy the things that they want to buy and
get on with their lives without actually
going through the frustration of trying
to sign into an application on their
phone now here the user has added the
application to their home screen when
it's tapped it loads up an application
shell populates that with information
from the server and during this flow
aliexpress we'll ask the browser for the
users credentials the browser is able to
provide them in this case because the
user has chosen to be in that state and
Aliexpress can seamlessly sign the user
in using the mechanisms that we've just
talked about you'll see at the bottom
that it pops up a little toast to the
user informing them that they've been
signed in of course we're not going to
hand over credentials without actually
telling the user what's going on we want
to make sure that they're involved so
the greatest possible the code for the
flow that we've just seen is quite
straightforward there's a credentials
object hanging off of the Navigator
object in the Dom this has a get method
that method takes a dictionary of our
dictionary of options as its only
argument and it returns a promise which
either resolves with a credential object
if it's able to provide a credential
object or with undefined if either no
credential object is available or the
user chooses not to provide that
credential here we're looking for a
username password pair so we set
password to true because that's the kind
of credential that we're looking for
further we'd like to ensure that the
user isn't prompt
that we only sign the user in if they're
in a state where we can automatically
sign them it so we said unmediated to
truth that is the user will not be
involved in this conversation if they're
in a state where they can automatically
sign in great we get a credential if not
the user isn't bothered with any sort of
choices or any sort of decisions we can
ask them later and I'll show you that in
just a moment so this code is safe to
put on pretty much every page of your
site if you need users to be logged in
in order to have a reasonable experience
on your site you can put this code into
place if the user can automatically sign
in to your website they will this will
give you that credential and you can use
it to sign the men if they can't
automatically sign in to your site they
won't be bothered and you can choose to
sign them in or to help them sign it a
little bit later on signing in of course
is a little bit more application
specific so we'll walk through it kind
of broad strokes but it's going to be
specific to your application so once you
have a credential object you'll do
something useful with it and in this
case the something useful is going to be
using the fetch API in order to send it
to your back-end in order to actually
sign the user n you'll send it to a sign
an endpoint he'll use post as your
method and you'll pass that credential
object in as the credentials attribute
in this options and the request and its
options for fetch then when it resolves
you'll get a response object back and
you need to examine that response to
determine whether or not the silent was
actually successful some applications
will return to status code of 200 others
will return information in the JSON blob
you'll need to do this for your own
application to determine what makes
sense for you but once you figure out
what makes sense you can either render
an amazing signed in experience for the
user if you're in this kind of
asynchronous flow where you're able to
update your site asynchronously if
you're not in that kind of flow yet if
you still need to navigate them to a
landing page then you can do so quite
trivially by setting window dot location
we've seen a number of the websites that
i showed earlier on are doing exactly
this right now layering it directly on
top of their existing sign-in system and
then thinking about this kind of
asynchronous model as a future step now
I talked it a little bit about
automatics inet and this of course is
new for the web
and we're just starting out with this
concept so the initial implementation
that we're shipping is going to be
relatively conservative there are some
privacy and security considerations here
so we want to make sure that we're doing
the right thing now the browser will
hand over credentials automatically only
if the automatic sign in feature is
actually enabled that is the user is
chosen to be in an automatic sign in
state and if the user is saved only one
credential for your website if there's
any ambiguity if they have multiple
credentials for your site we punt and
let the user decide later on we won't
automatically sign them in when
automatic sign-in isn't possible the
credential manager API can still offer a
one tap sign at via a chooser dialog now
freeletics is a fitness and exercise a
bloke a shin which is a good example of
the kind of general flow that we're
looking at here the user expresses an
intent to sign in by tapping on that
button login based on that intent chrome
presents an account chooser dialogue and
in this dialog the user is presented
with the credentials they've saved for
this origin if they save multiple
credentials they're able to choose from
those credentials pick the one that they
want to use to sign in and then continue
the flow now if you're experiencing a
Keanu moment of deja vu here it's okay
this is almost exactly the same code
that you saw before the only difference
is that we've removed the unmediated
attribute from the option so we passin
to get that is in this case we accept
user mediation will get an automatic
credential if we can but if we can't
then the browser knows that it's allowed
to pop something up to the user to ask
them to involve themselves in this flow
now you'll want to execute something
like this snippet when you recognize
your users express intent to sign in now
if the user clicks on a button named
login that seems like a really good time
to pop something like this up so getting
credentials is great but they have to be
stored in the credential manager first
and this is where our heuristics often
go awry it's simply the case that we
sometimes miss parse the signup form
don't get the right information and at
that point the users in a bad state so
as you see here the credential
management API offers developers the
ability to choose
win the save your password prompt is
actually triggered and to ensure that
the correct information is passed in so
the chrome doesn't miss a thing now
since the user has just entered their
credentials into a form the best way to
store them into the credential manager
is actually to use that form to create a
credential a password credential object
so as you see here you'll use the
password credential constructor you'll
grab a reference to the forum you'll
pass that form in chrome will parse
through the form find all of the bits
and pieces that you've marked up using
there's autocomplete attributes that we
talked about a moment ago and populate
the password credential with that
information will have a username it'll
have a password and if there's any extra
well talk about that the moment you'll
then call navigated our credentials that
store you'll pass it in and it's really
quite straightforward now getting
credentials is great but the sorry so
with kayak we just talked about
usernames and passwords and figuring out
how to make sure that we get the right
information but I mentioned earlier that
Federation is something that we have no
understanding of today the credential
manager API of course gives you the
ability to inform the browser about this
Federation so if your kayak for instance
and you want to let users sign in with
either Facebook or with Google the
credential manager API allows you to
save that information so that when the
user comes back next time they don't
have to choose which thing they use last
time I know that for things like
stackoverflow I personally created at
least three accounts because I happen to
have multiple things that I could use as
a Twitter as a facebook as a Google who
knows here will create a federated
credential object and because there's no
form that's actually used we need to
pass in all of this information
ourselves so we create a critter ada
credential object we pass in an ID and
we pass enter the provider and the
provider is a serialized origin of the
Federation that we use in order there
that the Federation that the user used
we then store that in the exact same way
that we just saw navigator duck
credentials that store and we pass in
that that credential that will pop
something up to the user the user can
choose to store it and you can move on
with whatever part of the flow you find
yourself in
the last step of course is to ensure
that when a user chooses to sign out of
your application that they're able to do
so we don't want to automatically sign
them into their application if they've
just click the logout button this is a
relatively straightforward API you
simply say that user mediation is
required in order to sign the user n so
you call navigator duck credentials that
require user mediation that will go
through all the credentials that are
stored for your origin and they'll
ensure that those credentials cannot be
used for automatic sign in until the
user explicitly chooses to sign in via
the account user that we saw earlier now
there are some interesting
considerations here we've talked a
little bit about the UX improvements
that you can create and there are good
good reasons for you to use this API
just in terms of making the actual
experience better but there are also
really good security reasons to use this
API first of all navigator dock
credentials is locked down to secure
context this is basically in line with a
chrome teams general notion that
powerful features should only be
delivered over TLS we simply do not
trust plain text websites and we're
ratcheting down on those websites over
time in this case we don't want to give
those kinds of websites the ability to
interact deeply with a password manager
especially something like automatic
sign-in would be pretty bad if we
exposed it over plain text where anyone
between you and the server you're
talking to can both read those
credentials but also manipulate the
JavaScript that's on the page secondly
the passwords are not directly exposed
to JavaScript I talked about using fetch
here and fetch is actually the only
mechanism that allows exposure of those
passwords so if your website has some
sort of cross-site scripting bug where
someone is able to inject code they
won't be able to access passwords even
if the user is in an automatic sign in
state because the password is only sent
to the backend server that is you
authenticate to your backends by using
the fetch API at the point that we touch
the network we see realize that
credential information and send it up to
the network or it send it out to the
network but not to JavaScript on the
page and finally we further limit that
by saying that fetch can only send
credential information to same site
origins
is example calm can send something to
add mint example calm but it can't send
it to evil calm so even if there's a
cross-site scripting bug in your site
even if they're able to grab credential
objects they can't actually actually
exfiltrate them to third-party origins
so we've gone through that pretty fast
as well there's a whole lot of detail
that I skipped over and I think it'd be
really good for you to skim through the
spec there are a ton of examples of the
top that show you how you might start
using this API and a number of different
situations that are fairly common for
websites like the ones you probably run
today those examples I think are really
interesting to read but those are kind
of spec examples and they don't really
reflect the real world in the same way
that actual code does happily enough the
Guardians implementation is open source
which means you can actually go out to
the github commit that they use in order
to implement this API on their website
and see the exact code that they use on
their website and start using similar
code on your own websites finally my
colleague eg who's sitting over there
has put together an amazing code lab
that will walk you through step-by-step
usage of the API layering it on top of
an existing login system and turning it
into a much more functional system that
is easier for users to use and doesn't
actually show them sign in screen so
they don't need to see them so that's
the credential management API it has
some real advantages over the status quo
and then some flows that allows you to
sign a user in without ever showing them
a sign-in screen which i think is great
for you as developers but also great for
users that said it's still based on
passwords passwords of course or at the
core of it and passwords themselves are
a little bit of a risk they're probably
the most common form of authentication
we see and we need to support them but
it would be excellent if we could layer
something on top of passwords in order
to give us better guarantees about the
authentication so I'd like to invite my
colleague Alexi up now to talk about
mitigation strategies that we a google
thing are really important
thank you Mike hi everybody my name is
Alexei and I'm a secure in Iran the
identity team and I'm going to tell you
about security keys so Sabine told us at
the beginning that passwords can
passwords are often reused by users
across websites because of the cognitive
load that it takes to have lots of
different passwords and of course this
is a security threat because that means
no matter how much you lock down your
website it's only as secure as the
weakest website with which the user has
reused the same password we know that
once attackers break into one website
they take the passwords from that
website and reuse them on other websites
and that's really frustrating but we
also know that passwords can be stolen
by adversaries in other ways for example
they can be plucked out of network
traffic if that traffic is not encrypted
and some other series are so powerful
that they can look at network traffic
and sometimes find the cryptographic
fault and maybe are able even to decrypt
it later on but it turns out that the
attackers job is even easier than that
they can often just ask users for their
passwords and the users will just
happily give them up this of course is
called fishing so this is where the
security key fits in it's an additional
layer of protection that you can give
your users in addition to their password
to guard access to their account data
okay you might be asking yourself is
fishing effective is it something that I
actually need to care about well in a
recent study conducted by Google we
found that fishing was effective almost
half a percent or half of the time
against users so that means half of the
users will get tricked by good fishing
pages and even if the attackers don't
don't take a lot of effort in making the
fishing page if they just simply say
give me your username give me your
password it'll still capture three
percent of users with a lot of users
that is quite a bad figure okay so what
does a security key do well it's a based
on a public standard called the Fido
universal second factor standard you to
f it's safe so it protects users against
phishing it also protects them against
man-in-the-middle attacks some network
adversaries it's easy to use so you take
it you stick it into your USB Drive if
it's a USB form factor
and you just press a button and that's
it in this compact it's one small device
that you can use with many different
services on the web so I've been talking
a little bit but let me show you how it
actually works in real life all right
there we go so I'm going to demonstrate
signing into my personal google account
which is protected by a security key so
here my browser happily remembered my
username through a password manager then
it happily also remembered my password
but now it's going to ask me to insert
and use my security key so if you are up
here with me and you know it's good
thing that not all of you are up here
with me but later I can show you that
there's a security key already stuck
into the USB Drive here and it's
blinking furiously at me I really want
to touch it I'm going to go ahead and do
that there we go I touched it and voila
I'm signed in that was fast that was
easy and it was resistant against
phishing and then the middle attacks so
what just happened well my browser sent
a pass word along to the server just as
I had before and this was vulnerable in
all those different ways that that we
have mentioned but it also sent
something else it sent a proof that a
user was there and this proof had a
couple things in it first it said that
it was issued as a result of a direct
user action that means that I actually
touched the security key it wasn't
issued by malware it says something
about the freshness of this proof it
can't be something that's captured and
then reused so as a server challenge it
mentions an origin for which this proof
was issued so you can see that it was
issued for Google and had I accidentally
pressed the security key and given this
to Fisher calm or or bad calm it
mentioned right there and that website
could not take this proof and then reuse
it against google or your website in
order to confuse that website and let
the attacker in and finally it mentioned
something about the TLS connection so it
mentions properties of the TLS
connection that a man-in-the-middle
could not fake and then for therefore
this also ford's interception and of
course this is signed and sealed with a
private key that resides on the
security key who's publicly the server
knows alright so maybe that sounds
interesting to you and you want to try
using it so let me show you how you can
do this through a browser API there are
two API calls one has to do with
registration this is the operation that
you undertake the first time that you
want to associate a security key with
the user's account and then for all
subsequent times you use authentication
so this is what you do every single time
that the user wants to actually sign in
each of them have three steps so first
your web page is loaded from the server
just as it is today then you decide that
you want to authenticate the user so you
call the api this causes the browser to
then take take your request and send it
on to the security key which processes
the request blinks an LED for example
gets the user touch and then replies and
then the browser takes this gives it to
you through a call back to you it's your
code and you can send it on to your
server for verification this was shipped
in chrome 41 and if you're curious
you're all probably using chrome 50 so
you've had it for a while and it'll soon
ship in Firefox as well it's shipped as
a component extension which means that
it's there you just don't see it and in
fact if you launch Chrome with a special
flag the dash show component extensions
flag you'll see it it's called the
crypto Tekken extension and you can walk
right through it if you actually want to
debug the code so you can talk to this
extension directly through the message
port API or use a little wrapper that we
wrote to sort of have a more handy API
experience okay so remember registration
that's the first thing that you want to
do this is when you want to associate a
security key with the user so this is
what the API looks like it's pretty
simple you stick in a version it's a set
string right now we're at you two fv2 so
that's what you put in then there's a
challenge so here you go you can put in
whatever you want to as the server maybe
you want to encode the user session
whatever you want it to be a fresh knots
and then you provide an app ID I'm not
gonna go into details about what this is
but it's basically a little file that
you host that maps various properties of
your online presence so talks about
maybe what origins you own but also for
example if you have an Android
you can do that Association in that file
you can go to the specs and read more
about it there and finally you provide a
call back remember this is what will be
called by the browser once it gets a
reply from the security key in the
callback you get two things you get
client data and registration data client
data is what the browser actually
package together and sent on to the
security key and this is what actually
got signed so it mentions that it's a
register request it has the challenge
that you told it to have it has a couple
more things that the browser puts in for
the users protection for example it has
the origin that the browser saw and then
it also has properties of the TLS
connection that's the CID public key if
you're curious about what that is you
can come find me later and I can tell
you how you can how you can verify one
of those things all right the other
thing that you get back from these from
the callback is you get a registration
data this is what the security key
produced there's a couple things you
don't need to understand all of them but
it's basically a structured byte array
that has the public key that the token
generated it has an attestation
certificate that lets you reason about
what kind of token that says who made it
do you want to trust it do you not want
to trust it we know that some
enterprises really care about
procurement so how the user actually got
this token in which exact token it is so
it so this attestation certificate
allows you to reason about those kind of
things it has a key handle and then it
has a signature over all those things
that the the token produces so you take
that and you send it on to your server
for verification the sign API remember
this is what you call every single time
that the user wants to log in it has a
lot of the same things but now has a key
handle and for the crypto nerds in the
audience what this allows you to do is
it actually allows you to build really
really neat tokens really small ones
that don't have any storage on them
because this key handle is a mechanism
that allows the server to remind the
token of which key it can use again if
you're curious come find me later I can
tell you all the gory cool details look
at about we can talk about elliptic
curve it's going to be awesome all right
and finally the callback now your
callback has the same client data
remember that's always sent down it
looks the same except now it says
authenticate because the browser knows
that this is an authentic eight call has
the challenge that you put in
properties of the TLS connection so you
can throw those men the middle attackers
and the origin which protects you
against phishing and then has a
signature now it's a lot smaller there's
a counter that again lets you capture
very strong attackers that may have
cloned tokens so for example if you if
there's an attacker that is able to get
their hands on one of these melted down
examine it with an electron microscope
and make a copy you can catch it right
there through a counter and then of
course a signature you also get a key
handle so that if the user has multiple
security keys as a lot of users actually
do then you'll know which which security
key was actually used to create the
signature alright so we know that this
is more secure we know that it's less
error-prone because you just touch it
there's really no error you can make
their we know it's more user-friendly
you users really love this but we also
found that it's very fast so in fact
this is a this is at least twice as fast
as any other second factor mechanism
that we know about so hopefully that
sounds interesting to you and if it does
then you can go read the full specs at
the Fido Alliance make sure you click on
the you to F specs that's what they're
called you can get the code we've open
sourced a bunch of the code for example
the extension that lives in the browser
the sample server which is live at that
appspot site but whose source is also
there in the github repo you can get a
device on amazon there are multiple
vendors who make it if you do make sure
you smile that amazon com because then a
little bit of your money gets donated to
charity that's pretty awesome and then
if you do get one don't forget to
actually protect yourself and your
google account you can go to accounts
that google com to security two-step
verification and click on security keys
and it's important if you think about it
because you guys all our developers and
if an attacker gets into your account
they could then use that to perhaps make
your users vulnerable so it's really
important that you protect yourselves
alright so today say beans started out
and told us about password autofill
which it which allows you to use just a
couple lines of code to enable something
really powerful on your website to allow
password managers to help users remember
their usernames and passwords and then
automatically stick it in the forums
then I came up and told us how for some
flows you're able to get rid of logging
forms all together and then I told you
about security keys an extra level of
protection that you can add to your
Simon flows to protect your users from
fishing and Manimal attacks I think
that's it thank you very much and have a
great rest of Io</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>