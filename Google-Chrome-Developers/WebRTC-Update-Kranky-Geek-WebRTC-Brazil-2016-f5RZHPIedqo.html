<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>WebRTC Update (Kranky Geek WebRTC Brazil 2016) | Coder Coacher - Coaching Coders</title><meta content="WebRTC Update (Kranky Geek WebRTC Brazil 2016) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>WebRTC Update (Kranky Geek WebRTC Brazil 2016)</b></h2><h5 class="post__date">2017-01-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/f5RZHPIedqo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">but thank you thanks for the kind
introduction so it's my real pleasure
being here not only do I like traveling
to brazil a lot i think it's a great
country but i think Brazil has also come
a long way from a technology perspective
i just looked into some numbers
yesterday on web browser stands and i
found that about 300,000 startups that
are being created every year in brazil
know and from an internet perspective
sixty-four percent of all internet users
connect from mobile and from those sixty
four eighty-six percent ex GF x is 2 3g
networks 2g and 3g networks so i think
this is a really great time to get
started with real-time communication and
thinking about how to enable those users
on a real-time basis with WebRTC and
that's why i'm here to talk with you and
to you about WebRTC and give you instead
update where we are and how we got there
so I'm starting over the status update
just giving you some numbers what we see
of WebRTC usage and chrome from those
users who opt-in into providing this
data to us and chrome but also how the
ecosystem has developed I'm gonna do a
quick 101 on on the web RTC overall
pictures and I think we've seen already
and heard really great presentations
today I also learned quite a bit about
WebRTC actually and I will look into
give you an overview of features that we
have developed and enlarged this year
and what's our roadmap basically towards
the end of the year and beginning of q1
so about five years ago on june first
2011 my colleague harold who works with
varun on on the get stats specification
posted to a w3c mailing list that we are
open sourcing WebRTC and working on
standardizing platform of a pepe p is
for for real-time communication platform
so five years fast forward
on june first 2016 we celebrated the
50th anniversary by updating the logo on
to end of this year and what what did
this five-year basically bring into
launching a a toolkit basically for
real-time communication and enabling
users to make use of RTC and the browser
so just two weeks ago on the chrome dev
summit it was published that there are
two billion Chrome browsers across the
desktop platform and also mobile which
are active every month these are monthly
active users and all those are web RTC
enabled all those are web RTC built in
and you can basically directly unable or
chrome users by making use of the of the
web aprs that we have but it's not only
chrome right since we launched WebRTC
WebRTC has been adopted across various
browsers so this is an overview
basically of which api's are enabled by
which browsers and you see there are
quite a few now and not every user
obviously is a chrome user people make
use of different browsers but many of
them are WebRTC enabled microsoft on the
edge web summit provided this update on
on WebRTC development stages and i'm
super happy basically to see really
microsoft joining basically the
bandwagon of WebRTC and i think that's
actually one update to this slide that
vp8 for real-time communication is now
also in development in edge so you will
have basically various options from a
codec perspective to connect users
across different platforms there wasn't
question about that qatari ago so there
are some folks who have brought open web
RTC an alternative implementation of
approach ec into web kit just some weeks
ago and here you see a a party see video
call between a WebKit enabled web GTA
gtk+ browser and chrome so WebRTC is
actually already somehow there in in
WebKit but if you look on the WebKit
side you see although the official
status of under development so bench
all the WebKit and other browsers they
built on top of WebKit hopefully will
also be web RTC enabled and these web
RTC browsers are being used it's not
only they all enabled you know in
sitting there around on some desktops
and mobiles so what we see in chrome
that we have an aggregated usage of
audio and video minutes per month of 1
billion well that is 2,000 years of all
your own video communication per week
what is being used only in chrome by
various service providers but it's not
only audio and video communication that
we think of WebRTC right it's although
the data channel that has been mentioned
today and what we see on the in chrome
again for the data channels per week is
one petabyte of data transferred over
the data channel and that is for various
use cases right there are services that
provide content delivery network CDN and
WebRTC but this is also any kind of
content sharing basically for
peer-to-peer so this is massive and the
end it's only 0.1 percent of our chrome
traffic but this number has been rapidly
growing so just beginning of this year
this was at 0.05 percent and now
basically doubled this or users you all
and all the party see users have doubled
this with the service is provided over
the data channel and it spread across
different projects and companies that
make use of WebRTC so by launching this
toolkit as open source and providing the
codex which are the which we have talked
to about already today and which other
dig into a little bit later on we've
really unlocked basically the previously
closed ecosystem of real-time
communications so 1200 WebRTC based
companies and projects that are tracked
by Sahib a on us on his block and this
is great because it's not just a few
players that basically own all the
servers on users it's it's tons of
projects and services that that make use
of it now it's not only a phenomenon of
the bet so some estimations that we have
done just by knowing what kind of
services billed over GC so
there are probably around more or more
than 5 billion apps that have been
download which include WebRTC on iOS and
Android so what other services on mobile
we have just launched our own reference
service or communication service on top
of a party see which is due this August
it's been used a lot extra here in
Brazil but there are quite a lot of
other mobile apps that make use of
WebRTC it's viable for example that
makes use of part of it hang out
obviously builds on top of the WebRTC
stack facebook Messenger builds on top
of WebRTC so if you want to make a voice
call or video call inside of messenger
it's very serious being shipped with it
snapchat as being managed by so here
earlier today the video calling service
in snapchat is based on WebRTC and slack
has just some month ago launched
basically all you're calling in slag and
azure to based on WebRTC these are
numbers that we don't see but if you
think about the the 1 billion minutes
per week only in chrome and now you
basically multiply this across all those
apps it's probably much much more usage
as being made on top of web RTC and the
phenomenon is global so Brazil makes it
another top 20 but these are the google
trends for WebRTC search queries in
google and you see this has been growing
continuously over the last five years
and it's been spread around the world so
it's china who is maxing basically most
of the queries which is very interesting
but then also south korea and taiwan so
this is first of all like an asian form
a phenomenon but it's also Sweden India
and us I think doesn't even make it
under the top set well it's nice to see
that it's it's not really like the the
Western tech countries who adopt this
but you can see it all over the world
that users and so averages are
investigating how to bring real-time
communications to all internet users
let's take a little bit into into bed
proteaceae for those of you who might be
newer to it so this is the overall
architecture picture that we are living
a couple years and WebRTC and I just
want to quickly walk you through
basically a top to bottom so we have
seen the the web IP is already in the
those were covered extensively basically
today already but they are also mobile
AP ice which are provided by the by the
mobile native libraries for iOS and an
Android that we are providing those
these are either an objective C or Java
bindings that you have there and below
those application level API so you have
the C++ peer connection which is like
the main interface basically to the
WebRTC library and be those those you
have you have three big components one
is the voice engine as we call it which
con includes all the the audio codecs
and this is opus on a second ng 7 11
that is enabled in web RTC and which is
a a jitter buffer which we call nettie q
is annette equalizer those data buffer
basically takes care of all the the
incoming packets and trying to pay
packet concealment if their packets lost
or trying to manage basically the
variability that we see in in the livery
of the packages and then we try to
address certain very hard to solve
signal processing problems and software
well this is echo cancellation noise
suppression and gain control and this in
the end basically what what helps to
make audio great and tries to fix many
problems with different hardware that we
see that's a video engine basically
which enables WebRTC with video
communication though the codecs that are
being provided are vp8 vp9 and h.264 and
similar to net eq on the voice site
there's basically a video jitter buffer
that manages the incoming packets and
outgoing the incoming packets for for
video communication and the the
underlying algorithms that enable a best
quality video communications and
beverage ec is bandwidth estimation so
WebRTC is mainly use
by in the internet right it's not
provide not usually or the telcos out
they are not the usual use of WebRTC so
we are not have we are not operating on
a medium with a dedicated quality of
service we don't actually know what kind
of pit road and quality we have for each
individual sessions you can do tests in
advance but actually the next time your
network quality might be completely
different because the internet and
especially Wi-Fi is a shared medium so
bandwidth estimation is a key component
to understand and to deliver video and
then obviously error correction if you
lose packets how do you deal with those
can you apply even forward error
correction in providing more bits and
fixing those areas that might occur and
then there's a transport component so
each communication and WebRTC is always
encrypted there's never unencrypted
communication so sr GP and i think
starting to a nice has been extensively
covered already today here but this is
basically mechanism that we have built
into WebRTC that helps you to across the
network translation that is applied in
many IP version 4 networks in our days
and then we have those platform-specific
connectors so every operating system
every hardware is having its own audio
capturing and rendering video capturing
rendering and network io system
basically to which we need to adopt or
connect to form from a web RTC software
perspective low bandwidth estimation
beginning of this year we had about two
seconds medium ramp up time to one
megabit video that means bandwidth
estimation the algorithm is algorithm
used two seconds to understand what is
the capacity of the network and to be
able to ramp up to one megabit which
provides an almost HD screen so then we
have made great changes to bandwidth
estimation we switch the algorithm from
ace and receive side split algorithm
moved all the logic of bandwidth
estimation to the sand side and worked
on
feedback format which is provided from
the receiver site back to the sand side
and this allows us to basically decrease
the time of that we need for ramping up
to 1 megabits to 650 milliseconds so
this below one second and this is for
example if I do work so great and why we
can do something like knock-knock with a
good video quality from the very
beginning because we get instantly very
good video quality the Codex as i
mentioned in WebRTC are our own codex
from the from the web and project vp8
and vp9 they're both provided with loop
VPX inside of chrome they're open source
and royalty-free so everybody can use
them and the work that has been started
there is now being continued in the
Alliance for open media which not only
all big internet players more or less
have joined but all done is very
important the chipset manufacturers have
joined a many tryptophane have joined
the Alliance for open media and this
really provides basically assurance that
the next generation codec will also be
hardware enabled and the other codec
that you committed to support h.264 the
legacy video codec basically so we make
use of open h.264 here for encoding
video and WebRTC and chrome always head
lip ffmpeg for decoding h.264 which is
also used for web or DC but event
basically beyond this and thought okay
if you want to make it efficient if you
want to address the capabilities of the
devices we also implemented the hardware
encoders on desktop browsers available
so that is one on Mac OS Chrome OS and
on Windows selective machines and if you
have basically h.264 hot by encoding and
they chrome automatically makes use of
it and this saves you battery this which
uses the heat of the Machine and and the
time basically on turn the fan turns on
I want to give you hear an idea what
what is the advantage actually of vp8
versus vp9 and why we call vp9 the
successor of VP
eight on the create the great thing is
that it requires thirty percent less
bits or the jump out of this
presentation go in here and this is an
example video that I'm starting now and
the left's all right shows vp8 at eight
hundred kilobytes per second but as the
right side of this red line makes you so
vp9 at 650 kilobits per second and both
on HD resolution so usually if you see
here I'm sliding on the white background
there's like hardly any difference looks
boring is actually exciting because this
is these white backgrounds is usually
where you can very good better see when
when they're sort of compression
happening in the Codex and then those
look very different but also if you look
basically on our code shirt like hardly
any any difference or other the skin
color well show you here basically to
two sides of this video and there's no
difference and this is actually the
great thing that I want to outline here
going back into some numbers that we
have from YouTube which has enabled vp9
already in large scale so in 2015 there
were 25 billion hours of YouTube video
shown making use of vp9 so think about
thirty percent less bits on such a scale
that is huge for for network providers
on traffic that needs to be delivered
that is huge for YouTube on capacity for
play out but this is also huge for
content creators and connecting their
users with them excuse me oh these are
not another graph provide by YouTube and
you see here Brazil is here on on number
four basically and this is the amount of
users it will be that vp9 unable to
upgrade to an SD resolution and as these
objects actually something on mobile
where we say like this an acceptable
video quality
so over ten percent of users in Brazil
we're due to vp9 upgraded to an SD
resolution where they react before very
low resolution so now think about the
potential of real-time communication
right you provide better video quality
to your video communication service even
if the network capacity is not that
great that might be on your on your 3g
network for example on your bed Wi-Fi
the vp9 is a more complex collect and
vp8 some of you may say it's difficult
to run this basically and software on
the devices but our tests have shown
that at these rather small resolutions
it's feasible so you can actually make
use of vp9 also on mobile if you run at
those small resolutions the audio codec
as been tension before it's opus which
is our codec of choice it's also an open
source project we continue to invest
into opus massively mainly for reasons
of improving quality improving quality
at the ultra low bitrate range so
somewhere between 12 kilo bits and below
this is if you have a if they have a
rather good edge connections or a pretty
bad 3g connection you should still be
able to have without if you don't have
huge packet loss or delays bugs you
should still be able to run a voice call
at those literates but we also try to
increase the complexities or complete
increasing and complexity provides in
general higher quality of the opus
encoding and for be able to doing this
we basically a lot on performance so
let's look into some of those features
that we have launched this year and I'll
continue to launch towards end of this
year one of the most start features in
inverrary d this year was mediarecorder
that were actually over 2500 stars it
was a higher stars start packing in the
chromium bug tracker and what it does it
support the recording of local and
remote media streams so this is not a Z
an API that you want to make use of a
neighbor real-time communications but
you can basically capture your screen or
capture
incoming stream with this API you can
capture it in vp9 vp8 or h.264 and the
default code I get set to opus audio so
we see that this API is being picked up
we don't really know about what's
happening and and why people are using
it and we would really love to hear
basically back what are your use cases
what are the kind of services that you
from a developer's perspectives are
working on to record media on a host we
worked a lot on bringing more
performance to to iOS so mobilis is a
focus for us obviously and performance
on mobile is always critical so an iOS
we worked a lot on the texture pipeline
and that helped us to decrease the power
consumption by eighteen percent by being
able to capture directly to Texas by
reducing or removing copies of frames
that we have done before and especially
if you think of the of the iphone 4 4 s
or 5 5 s devices this is where it
becomes critical that you that these
performance improvements really make
your your service smooth but Android
obviously has been also in the focus so
a party see mobile app RTC has been
mentioned before it's a free service
that you can that we offer just for
trying our WebRTC there's also a mobile
app which is called a party see mobile
and by making use of capture texture for
example and which using frame and
removing frame copies in the capture
process we choose the power consumption
so don't be fooled by these graphs they
look kind of equal but if you look on on
the y-axis here you see that the scale
is different now this is just a battery
power that has been removed this is
basically CPU improvements that we have
done and we have also enabled offloading
to the GPU
and this is how how the GPU load looks
after all these improvements so these
are massive improvement that we have
done in this deck inside of WebRTC to
help you from a developer's perspective
to create better services on mobile from
an enterprise perspective or not only
that from what mainly from enterprise
perspective screen sharing is an
important topic so what we have done is
to enable screen sharing on Android so
it captures everything that is on the
mainstream screen it's just being
launched now in m55 which is coming out
soon but it's already used it's used in
the pixel phone that we have launched if
you have issues with your pixel phone
and don't know how to use it you can
call a half hotline and the help hotline
asks you if you want to share the screen
with the backend over the hotline agent
and the helpline agent is then able to
annotate the screen and be when provide
drawings to the user on what buttons to
touch on on where to go on the screen
for doing things and this is WebRTC
enabled inside of every pixel phone if
also enhanced and improved screen
sharing on the browser so in chrome 54
we enabled tap sharing before that it
was always share your entire screen or
share an application window sewn on
chrome you can also just share a
specific tab with with with other users
being connected in a call and you can
see that we have organized the screens
picker you I definitely it makes use of
material design now as I as a UX and we
have organized it differently and
hopefully more intuitive so you can show
you entire screen the application window
or the chrome tab and additionally you
can share your system audio so we
received many requests actually that
users want to share also audio in in
screen sharing sessions and four tap
sharing this can be done across order or
different platform
this can be done a mac OS than both and
and Linux whereas a system all your
sharing is not always available so we
will share the slides later on with you
but that's although you are on here
where you can where you can try this out
by also installing a extension for this
WebRTC is also used a lot in in
corporate networks and enterprise
scenarios and often these corporate
networks are managed and blocked or
protected by firewalls and that means
that UDP is limited too often to a
specific port range and not across all
the or the range above 1024 usually quad
1024 so what we have done we have
enabled a chrome user policy that the
administrators can specify the port
range for which it allows WebRTC traffic
and then WebRTC is forestall UDP traffic
and WebRTC is forced to go to the
specific port range this has been a much
vaunted feature from all big service
providers that make use of WebRTC so
what's the upcoming work that we are
focusing on end of this year and
beginning of next year it's making
WebRTC better even when when the proxies
that require authentication there are
still a few bigger bucks i would say
that prevent WebRTC for being like
having really the five nines of roubaix
reliability high FPS frames per second
screen sharing and what we call slim de
Partie see so I want to briefly walk you
through these features so yeah web RTC
works best with direct UDP it can fall
back to TCP but in many corporate
networks there's a proxy which requires
all traffic that goes in an hour to be
authenticated so there are two different
decks basically in chrome one for the
HTTP signaling side
and then one for the media side from a
network perspective and whereas proxy
authentication works well it's a long
time for the HTTP signaling it does not
yet for any for any media traffic so
what we will be working on until the end
of this year together with the chrome
team is to enable basically the media
site also with proxy authentication and
that will enable the media traffic to
pass through these proxies in such a
managed environment and you see that
this this feature request is having over
100 stars so in just in general if you
want basically features to be
prioritized in our work starring a buck
is always a good idea because then this
is a feedback mechanism to us where we
understand what is really wanted by the
community improving media reliabilities
or there are still three main issues
that we see where chrome and WebRTC
fades from time to time one feature is
there is no audio from microphone coming
and we actually see the microphone but
we all get zeros all the time so and you
need to restart chrome to make this
happen or two to fix this a similar
issue is there is no webcam detected you
need to restart chrome to get the webcam
back and abled and then there from time
to time glitches on the audio and video
render and capture side so these are
fundamental problems that we have with
the party see inside of the chrome
architecture it's due to how processes
are being managed inside of chrome and
how different process are competing on
threats and what this means to ask this
we need to switch basic user process man
handling for for media in WebRTC and
there's a new process framework and
chrome which is called mojo it's a
simplified process model and it
addresses basically data ownership and
process sharing so we will adopt module
for audio and video capture they will
get their own processes they will not
compete against
other process anymore inside of chrome
so if you have very heavy and expensive
javascript in your application this will
not block the audio or video capturing
rendering anymore and video overcome
first until end of this year and aw it
was a little bit of a bigger project and
this will land basically next year then
and this will be a big milestone for us
because then we believe that really
WebRTC will become very stable inside of
Chrome another feature that we are
working on is high frame per second
screen sharing and chrome so the idea is
to enable users with sharing video or
multimedia content sharing gaming we are
chrome this is the feedback that we have
received so we are adopting a new direct
x feature for desktop capture it allows
us to go up to 30 frames per second
depending on the power of the mobile of
the desktop hardware and this will bring
almost real-time screen sharing into
chrome last but not least slim WebRTC is
a project with which we address the
request from from many users who want to
customize WebRTC not always do you want
to ship all codecs with WebRTC or you
want to deploy WebRTC to constraint
devices because you are building a
camera or a speaker or microphone which
is all a network connected from an
intent of things perspective though
WebRTC might be too too big basically
the footprint might be too large of the
binaries so we are coming up with a way
of allowing you to configure the WebRTC
libraries on a modular basis removing
specific features and customizing it to
your needs so the sum up what we are
doing with WebRTC the WebRTC platform on
the map is moving towards a very stable
state we see tons of services being
built on top of it there's a lot of
users as massive usage we ourself f
at the moment and increased focus on
mobile to bring up the mobile platform
on an equal state from a performance
perspective and we invest tons of time
and effort to make WebRTC better when
the when the networks are not so good
and I think this is especially something
in markets like Brazil on mobile
networks where we hope to make WebRTC to
work much better I thank you for your
for your time and being here for
listening to me and yeah are there any
questions that you would like to ask me
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>