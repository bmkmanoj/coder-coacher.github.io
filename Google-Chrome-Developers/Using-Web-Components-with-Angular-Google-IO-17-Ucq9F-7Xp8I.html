<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Using Web Components with Angular (Google I/O '17) | Coder Coacher - Coaching Coders</title><meta content="Using Web Components with Angular (Google I/O '17) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Using Web Components with Angular (Google I/O '17)</b></h2><h5 class="post__date">2017-05-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Ucq9F-7Xp8I" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon hello so my name is
Steven fluid and I'm a developer
advocate on the angular team hi there my
name is Rob Dodson I'm a developer
advocate on the chrome team and today
we're going to be talking about using
web components with angular so this is a
topic that Steven and I get asked about
a lot so we thought it would be cool
this IO to sit down do a session
highlight how you can combine these two
technologies and you know cover some of
the best practices for doing so and also
where we see some of the best
opportunities for doing that but before
we get started we just want to do a
quick overview just to throw out some
terminology familiarize everyone make
sure we're all on the same page and
explain again you know where we think
these two things fit well together so so
angular is a platform that makes it easy
to build applications with the web and I
talked about this a lot with developers
and I use these two terms very
particularly I use the term platform to
refer to angular because what we're
really trying to do is we're trying to
move from being a framework into a
platform that owns the entire end-to-end
developer experience and I use the term
with the web but very intentionally
because while you can build angular
applications that target installed
mobile or desktop use cases we're really
built from the core with the web and for
the web and when we talk about web
components we're talking about a new set
of api's they're landing in the browser
that allow you to define your own custom
HTML tags and these are tags components
if you want to call them that that will
work really in any context with any
library or framework that's really our
primary goal they're the two big
standards that make up web components
our custom elements that's what lets you
define your own custom HTML tag and
shadow Dom that's what lets you scope
your CSS and encapsulate your markup
inside of those controls many of you are
also probably familiar with libraries
like polymer which we use to build web
components today we're actually not
going to be talking about polymer
specifically the reason is because I
wanted to sort of remove variables from
the talk and make sure that I could just
get down to just the web standard level
with vanilla JavaScript and make sure
those worked well with angular once we
have that stuff squared away then adding
in libraries and abstractions becomes a
lot easier so let's talk a little bit
about why we would want to combine these
things and because there's two
technologies that are playing a little
bit of different roles so we talked to a
lot of companies and a lot of
enterprises that are using many many
different technologies and these
companies are often building lots and
lots of apps across different sub teams
and different divisions this is kind of
a very common problem along among
enterprises large and small and what
ends up happening is a lot of these
companies end up wanting to have a
single UI library whether they're
building a date picker or some sort of
calendar or even just a normal data
table they want to be taking UI
standards and brand guidelines that are
coming from the company and apply them
to the technology that they're using
across the board regardless of what
framework or pieces of technology that
they're using so when we think about
these two things we think that angular
is great for structuring and organizing
an application whether you're looking at
something like the CLI which is going to
help you scaffold and get started with a
project as well as build and ship a
project or whether it's other tools
within the angular framework that are
really all about architecting and
thinking higher-level
about the application and the flows
within your application angular is great
at those pieces but web components is
really great at compatibility and
building reusable UI elements that can
be used across many many different
contexts so then you might be asking
yourself alright well that sounds good
but like doesn't Google have like
multiple implementations of its UI
library and how come you all aren't
really like walking this talk so it's
true yeah we actually have more than two
versions of our UI library we have one
in polymer and web components we have
one in angular we have things like
material design light and material
components there's even a few internal
implementations sprinkled around there
and the reason is because when we
started material design
I guess maybe three plus years ago at
this point we cited material design the
web component standards were very much
still in flux today we have web
components v1 we have it shipping across
Chrome Opera and Safari things are
starting to settle down now and I think
we're actually at a place where we can
start to take a serious look at how we
can share work across all these
different teams
I also want to point out physical assets
a lot bass you know is angular on
polymer are these going to merge
together they go in away at some point
how is that going to work so there's no
plan for any of these projects to go
away at any point they all have their
own priorities they're trying to solve
but we absolutely want these things to
be able to interoperate well so it's a
primary goal of web components they
should be able to work anywhere and I
know that a lot of effort went into the
angular rewrite to make sure that web
components were well supported and so to
demonstrate this what we've done today
is to put together a very simple
application which we hope highlights
some ways you can integrate these two
together and that's really what we're
going to be walking through with you
today so what we've built for you is a
simple check out form on the web side
you see two standard HTML imports or
inputs where you've got a name and an
address for the user and then we've got
two web components below that a list box
over on the left side that's going to be
accepting information about how they
user wants to be shipping their products
and then it's a check box that allows
the user to decide how whether or not
they want gift wrapping for their
product and on the right we've got all
these angular declarative templates that
show hey here the prices that we're
going to be using here's the subtotals
and then giving that user the ability to
submit all that information so they're
in the bottom you can see the shipping
selection and then below that you can
see the is a gift wrapping web component
that we're adding there so our agenda
for today as we're going to go through
this session is really going to have
four parts we're going to talk about how
to set up an angular project and make it
compatible with web components then
we're going to talk about the guidelines
and the best practices for authoring
your web components in a way that can be
compatible with frameworks then we're
going to talk about how do you use these
web components within angular and we'll
finish it up with some general best
practices so let's get started here with
a project setup so within this context
I'm really talking about using a angular
CLI project so using the app angular CLI
project within NPM so let's dig in
via NPM I'm going to npm install angular
CLI and then I'm going to use the ng new
command in order to scaffold out that
project within my system then I'm going
to CD into that folder and I'm going to
see all the things that it created for
me a CLI project looks a little bit
complex at first but it actually has all
of the
things that you need to get up and
running as a developer using angular so
everything from editor configurations
get configurations typescript
environmental configurations as well as
tests that make it easier to maintain
your application as it continues to grow
and then in the source flash app folder
we're going to really see the core of my
angular app and the code that I'm going
to be writing where you can see all of
my modules my components they're
typescript HTML and tests so then now
that I have a standard angular project
that's going to work for me I'm going to
go ahead and add the polyfills that I
need it to work with web components so
we've released these tools on NPM and so
I can use NPM or yarn so you yarn add at
web components slash web components j/s
and then we're going to guide for our
project and we're going to add two
specific components called - checkbox
and - list box then within my angular
project I'm going to go and find the
polyfills es file this is a file that
has a built-in tutorial that says based
on what browsers you want to support
based on what targets you're going to
target here are the polyfills and the
other pieces of JavaScript that you're
going to need to include in your project
to make everything work so within there
you're going to see the import for zones
is which angular's dependent on for a
change of section and right below that
I'm going to go ahead and add the web
components polyfills it's going to make
my application compatible with what with
web components so one possible foot gun
and you might run into is you're at this
phase in your project is that if your
transpiling your elements down to es 5
or your custom elements down to es 5 in
browsers which natively support custom
elements already like chrome opera and
Safari by sort of spec definition those
browsers expect a custom element to be
an es 2015 class if you try and give it
an es 5 object that you've created and
say hey let me call a custom element
define with that it'll actually break
and so if your transpiling your entire
application and you're loading it into a
browser that already has native support
you need to include a little es5 shim
it's kind of weird to think about it
you're taking your sort of es5 code and
like backing it into the future you want
to think of it that way but here's how
we did it in our project me included
this little snippet here so if the
browser has native support for custom
elements it's going to load
adapter otherwise the adapters going to
like self remove itself this is probably
something that you can just sneak into a
web pack plug-in or something like that
so you don't have to look at it but I
did want to make the snippet available
and yeah if you want to write a website
plug-in out of this that's a free
open-source project ideas that I would
love to see so now let's go ahead and
add web components directly into our
angular project so I'm going to do two
things within my app module the first is
I'm going to go and import those web
components in there es5 or es6 teen
version then I'm going to go ahead and
let angular know about web components
that I'm using them within my
application so I'm going to import
custom elements schema and I'm going to
supply that as a schema on my route app
module and what this is actually going
to do is normally angular goes through
all my templates and validates and
verifies as part of compilation that
every HTML tag I use is part of the HTML
spec or coming from a component that we
think within the context that I know
about and what adding this custom
element schema does is it turns off that
validation so that we're able to add any
generic web component to our application
without throwing additional errors then
for our project here we're going to take
a very simple angular form so you're
going to see that at the very top we've
got a submit event that we're using the
parentheses binding for event binding
we're using ng forms here so we're going
to sign that out to a variable and then
we're adding this HTML input tags with
ng model directives on it and those
directives wire up the form for us and
then we've got the shipping web
component we're going to be adding a
little bit later and then we've got the
gift-wrapping web component we're going
to be adding and so what do we really
want from forms as a user so as a user I
really want to turn forms from a one-way
data dump into a conversation where the
application can be interactively telling
me about what's going on with the form
in a more helpful and intuitive way one
of the problems with building web
components by default today is that you
have to wire up forms yourself by
default they won't be included in the
value of a form element but because
angular automatically and is already
doing all that rewiring to make all the
submit buttons work and all the keyboard
shortcuts work we can include web
components in that model very easily
all right so now that we've got some
placeholder spots in our app we're going
to include some components it's time to
actually go through and do a bit of our
authoring now I've split this into two
sections I want to talk a little bit
about custom element philosophy
basically like what I think makes a good
component and then we're going to walk
through how do we define an interface
that works well not just with angular
but really a custom element that works
well with any library or framework yeah
component philosophy what makes a good
component I'm going to say first and
foremost if you're building web
components to be used instead of an
angular app I feel like these components
work especially well as leaf nodes so
you can think of leaf nodes as stuff
that you really can't break down any
further right stuff it's pretty concrete
UI if you were to graph the structure of
your application these would be sort of
like the terminating nodes at the end of
that graph you're already familiar with
using leaf nodes in HTML all the time
mostly interactive controls that you use
are already leaf nodes so things like
button and select and input things like
that right you don't think about
breaking those down into any smaller
pieces they're kind of as small as they
get another way that I like to think
about this is like these are not
abstractions right there they're really
concrete pieces of UI
so using angular you might create a more
abstract view like you know user
dashboard or login view or something
like that
and that view will be made up of these
smaller more concrete UI components and
that's a good place for web components
to slot in I also try to take any
component that I'm building and if it's
too monolithic I want to figure out how
I can break it down into smaller pieces
and factor it into these little bits
that I can compose together so I want to
show you what I would sort of recommend
not doing and then what I prefer when I
am structuring my elements so let's say
I'm building a list box and I've totally
done this before I started building this
element and I was like all right um I
guess the API for this thing will be you
got to like select it in JavaScript and
maybe they'll be like an array of
elements and I'll call a method on that
element
I'll give it this array and then it'll
it'll render all that stuff in the
shadow Dom and like yeah that's how I
assign my list box is going to work
right now totally go controls that work
this way there's some downsides doing
this though for starters we've got to
you know have some imperative JavaScript
set up to it there we've actually got a
query for this element call a method
pass some data to it that way which
little funky
also we're hiding all of our content in
the shadow DOM and we don't need to be
so instead of doing that approach again
we want to take that monolith and we
want to factor it into smaller
components so this - list blocks can
have little - option children inside of
it that way we can put the content right
there in the white Dom that's good for
crawlers and BOTS that want to you know
read the page it also means that you can
just hand author this in regular HTML
right I don't have to do any imperative
JavaScript setup code to get it into
this state so yeah it's good for server
rendering the thing if you want to think
bit that way your content is in the
visible Dom so it should be able to be
crawled and there's no one period of
setup work happening another thing that
I like to do is I like to think of web
components as each one as like its own
little field black box kind of the same
way that you think of native HTML as
like a sealed black box right you don't
try and poke around in the internals of
the select element or anything like that
and so when you're working with web
components you don't want to try and
like pierce the shadow root or violate
the encapsulation or anything you know
when we work with native HTML there's a
very well defined interface that we use
for talking to those controls and we
should implement that same interface in
our web components so that means we use
attributes and properties to configure
the control and we listen for events to
you know signal changes in the control
if we make sure that our custom element
dovetails into this pattern then we'll
have a nicer time working with other
libraries and frameworks which are
already sort of built to understand this
so finally I would say whenever you're
building a component I try to recommend
preferring a properties driven interface
versus one that's like heavy on on
methods and things like that let me give
you kind of a more concrete example of
what I mean there so let's say you're
building a dialog element it's very
tempting to say okay I've got this
dialog control and I guess the only way
for it to render in its open state is
going to be for someone to query for it
in JavaScript and call this like open
method and like that's how that's how
you'll open the thing right and I would
recommend instead of doing this give it
an open property and have setting that
property define a setter on your class
and setting that property that's what
will render your open state there's a
few reasons why this is beneficial the
first is it means that state can be very
easily reflected onto this component so
if you're using like a unidirectional
data flow
sort of like what angular does or what
something like Redux likes to do where
you want to take a state object and just
kind of like pass all those props down
the tree this model works very well for
that it also means that someone who is
just writing vanilla HTML can very
easily configure your control they don't
have to write any JavaScript to open it
they can just put an open attribute on
the thing and send its open state right
and as you start to do this and you look
at native HTML you'll see there's a lot
of similarities there things like the
the checked element or the input type
equals check element it has a check
property and I checked attribute it
doesn't have like a toggle method or
anything like that
so as we're mirroring what native HTML
does it tends to make our life a little
bit easier so it's all that in mind
let's essentially create an element and
define an interface that matches these
patterns so it works well with angular
so I'm just going to build this little
checkbox here and for the sake of time
I'm not going to cover every detail of
how we built this element but I do when
I highlight the important areas of
integration between angular and custom
elements so I've got two goals the first
is I want to make sure that angular can
tell my element what state to be in and
the other is I want angular to be able
to listen to changes from my element
like satisfy both of these I should be
happy so let's start with that first
item there making sure any other can
tell my control what state to be in so
I'm going to start by creating a custom
element class and under the hood custom
elements are a really really simple API
you basically are just associating an
es2015 class with a tag you're telling
the browser hey whenever the parser hits
one of these tags create an instance of
this class so I'm going to - checkbox
class that extends from HTML element I
call custom elements define I tell it
the tag name I give it the class that I
want to associate it with and with just
that I've created my own HTML tag I've
literally extended the language which is
pretty cool but right now it doesn't
really do anything so I'm going to add a
little bit behavior to this and again
the interface that I want is one that
kind of maps back to what native HTML
does here so I've got a checked property
that could be set or a check attribute I
want to keep these two in sync so
setting one sets the other vice-versa
right to do this with a custom element
very straightforward I can just use
regular old property getters and setters
on my class and I'll leverage them to
synchronize with my attributes
so inside of my check box I'll create a
set checked setter and a getter for
checked and I'm checking my setter to
see if the value passed in is truthy
this is very similar to what native HTML
does you can pass in like strings and
stuff to the to the input type we'll
check element it'll be it'll say it's
true and then I reflect that to my
attribute and since it's a boolean
attribute I'm either going to set the
attribute or I will remove the attribute
entirely the interesting thing I think
is the getter so the getter is checking
to see if the attribute exists and that
is how we're defining the state of the
property the interesting thing with this
approach is that means that someone goes
in and they just remove the attribute
then the property immediately becomes
false I don't really have to write any
additional code to keep these two in
sync which is pretty handy
so now angular can go in it can set
either an attribute or property
whichever you know approach we want to
use there you can query the check
property and figure out the current
state of the control the next thing is
we want to tell angular anytime
something in the control changes and I
have a little rule that I try and follow
with all of my custom elements when it
comes to doing this so I want to
dispatch Dom events when things change
but I like to do this only when there's
some external force acting on the
control so a user clicked on it or
something loaded or you know a timer
fired within it or something like that I
tend not to do this I tend not to
dispatch event
just because someone set a property on
me I my assumption there is if the
developers set the property they know
they did that and they don't need to an
event telling them that they've done
that right it also avoids potential
issues with any sort of binding system
that is property and event-driven
you don't end up creating like infinite
loops where it's setting the property
and hearing the event setting the
property and so on and so on so I only
do this just event dispatching in
response to user action so the other
cool thing that custom ailments are
going to give me is lifecycle callbacks
so inside of my connected callback this
fires anytime my element gets inserted
in the page this is sort of its like
initialization phase I can add event
listeners for you know user clicks or
keydown anything like that in this case
I've got a toggle checked Handler inside
of there I'm just going to flip my check
state which triggers my setter which
sets the attribute and I also dispatch
an event telling the outside world hey
something changed
the event name that I chose there of
change was very specific because that's
what the native input checkbox also
fires again I want to map closely to
that interface because there's some
upsides for doing that when you're
working with angular
so now angular can tell them I can point
what state to be n it can listen for
changes from my component again I've got
sort of this interface similar to what I
showed before where I've got properties
and attributes going in I got events
coming out we also have another element
inside of here this list box control and
for that I did basically the exact same
thing I defined a little properties
interface for a value property and I
fire an input event so it's sort of more
like a generic input control there and
we'll also talk about why that's
beneficial in angular in just a second
but with these two items satisfied our
custom elements should work well pretty
much anywhere and so the last thing to
do is just to bring the two together
with our angular app alright let's go
ahead and look at how we can now add
these custom elements that we've
developed within the app that we set up
earlier so we're going to do three
things first we're going to bind to
those elements they're going to go ahead
and add ng model support using forms and
then we'll talk a little bit about
validation and how that works so
starting with binding to elements I'll
take that same form that I set up a
little bit earlier and I'll go ahead and
add in my - check box and you'll notice
that this looks very much like angular
where I've got the square brackets for
property binding right on my web
component and we're setting the checked
and by setting the checked property
that's equivalent to running - check box
checked is equals is gift and so we're
looking at the component that we've got
and we're pulling out the property is
gifting we're assigning it out to that
check box now let's actually add the
listener so now we're going to listen
for that change event so we're manually
wiring up the event listener and now
we're going to set the is gift property
on our component to the events targets
checked property so now these things
basically we have a checkbox that when
we click on it it's going to set the all
the properties declaratively and then
our entire angular application is going
to run change detection and render the
new state of the app so this is how we
manually wire things up right I use the
property attribute binding to set the
properties and I use the event listeners
to bind to the all the events that the
property is going to emit
but that's not actually the easiest way
to do it we want to be using angular
forms so angular forms are really based
on this idea of an NG model where we can
look at a component or a control and set
the attributes and properties and we're
going to be listening for events so
let's look how we do this with standard
HTML with standard HTML which for
example an input tag we're going to be
setting the value property and we're
going to be listening for input events
and we hold it's the default value
access err most of the time you don't
see this because it's under the hood but
there's some ways that we can tap into
it now that we're using web components
and then if we look at a checkbox which
is an HTML element that has a different
API we're going to be setting the check
property and we're going to be listening
for change events so it's been angular
we call that the checkbox control value
access sir and so while these things
work perfect for standard HTML elements
we can actually do the same thing with
custom value accessors so if I have a
web component that has the same API as a
standard input tag where I could be
setting the value property and listening
for input events then I can just reuse
that default value of access or on those
components or controls now if I want to
do something that has the same
properties and same API as a checkbox I
can still use that checkbox property and
the change events from it using the
checkbox control value access err so
let's take a look at each of these so in
my - list box which matches the API of
an input box all I have to do is add the
directive ng default control along with
ng model and with this does is it tells
angular and angular forms the API that
it needs to use to listen for changes
and this set and make updates then we
can even do things like stamp out
additional dash options using standard
angular syntax such as ng 4 so here
we're iterating through a list of
shipping options and we're printing out
that option with the value being set to
that option 1 for each of those within
our web component now if we turn our
glance a little bit over towards the -
check box that we built maybe we want to
build a completely custom value accessor
and we can do that too this will allow
us it engage and interact with any
arbitrary API that we need maybe from a
web component that we didn't offer that
we don't control so I'm going to wire it
up within angular using a directive so
I've got the selector here
for - checkbox I'm going to add a host
event listener on change where we're
going to be looking at the check
property of that changed object and then
I'm going to let angular forms know that
we have a value accessor for this by
using a provider that points to this
Jett - check box directive and now we
define that - check box directive
there's a few methods here we have a
property called unchanged which is the
function that we're going to be calling
then we have a constructor that gets us
access to both the elements and the
renderer that angular needs to do these
sorts of interactions then we have a
method it's going to tell us how to
write out that property and then we're
going to register ourselves to listen
for those change events and then we'll
also register for touch events another
thing that we really care about is form
validation and web components plus
angular and annular forms is really a
magical experience in my perspective
because the moment you've wired up these
control value accessors everything that
you expect from a form validation
standpoint is just going to start
working so if I take that same - list
box that we built and I add a required
attribute to it it's now going to be
required as part of the standard form
controls and within angular forms we
actually give you a set of CSS classes
that let you know what's going on within
your form if the control has been
visited you'll see ng touched or ng
untouched
if the forms value has changed we're
going to see ng dirty and you can tell
whether or not the form itself where the
form controls are valid and all of these
things are wired up automatically using
the validators that you use these are
the same validator to use with standard
HTML LS and then combining that with the
requirements that you've set within your
component so now as I hit submit here
for example if I hadn't filled out any
of these fields that we'd marked as
required I'm going to see the same CSS
classes apply to all of these things so
let's now talk a little bit about best
practices for combining these things
first of all staying up-to-date second
using es2015 imports
third mutating data and forcin theming
now let's dive into each of these so the
first thing is very important is staying
up-to-date the web components spec
itself recently hit version 1 but it's
continuing to be in revised and updated
as they move and look towards a version
2 possibly in the future
as well angular is continuing to be
updated between versions 2 and 4 we
actually made a bunch of different
improvements that improve compatibility
across the board between angular and web
components and we're continuing to look
at ways to do that there are other
things that are happening across the web
as the ecosystem evolves as well such as
the fact that we on the angular CLI give
you a certain set of polyfills and we
can help you manage those polyfills as
things continue to evolve because I
think we all hope for a world where we
don't need polyfills because the web
standards have evolved sufficiently
additionally we're really talking very
specifically about a couple versions
when you go all the way back to
angularjs we didn't have the same sort
of approach that we have now in the same
sort of knowledge that we have about web
components and the specs that exist and
so angularjs is much more Dom bound and
there's a little bit more magic under
the hood in terms of how we interact
with elements and so working with web
components is not as great experience
and you can run into edge cases whereas
if you're using angular any of the
latest versions you're going to have a
much better time especially when
combined with the latest polymer 2 or
anything from the web components one
auto spec yes the next thing I want to
talk about is how you use es2015 imports
with these controls so using ES 2015
imports with angular is pretty nice
because angular CLI gives you a nice
build pipeline to go ahead bundle and
package these things up
you've got great tools out there things
like roll-up which will do tree shaking
and things like that so it's really
really exciting to be at a place now
where can start using this technology
but I know if you're you know some of
you are already familiar with web
components you might be wondering ok
cool yes 2015 imports what about that as
HTML import things right those are part
of the web components spec as well so
while HTML imports have shipped in
chrome and they're still totally safe to
use in you know polyfill and other
browsers and things like that I think
it's probably unlikely that other
browsers are going to ship HTML imports
in their current form I think instead
the direction that the specs are taking
is one in which HTML imports will
probably be reimagined on top of the es
module loader system and that's a good
thing because it means we don't have two
systems for how things get loaded into
the browser so you know today if you're
building a vanilla web components I
think it's totally ok to just go ahead
and use es2015 modules for the
and that brings up two more interesting
points which is how do you transpile
those modules and then you publish them
to something like NPM so this is the
approach that we use in our project I'm
not going to say whether this is right
or wrong but this is what we did it
seemed to work for us what I'm doing
here in my package JSON from my element
is I'm creating a number of different
build artifacts I'm exposing those to
the user so they can kind of choose
which one they want to leverage this is
similar to the approach of the angular
team uses when they publish their own
libraries so what we're doing here is in
our package JSON main point at a fully
transpiled bundled together es5 version
of our component using UMD so this
should be able to be dropped into the
page using a script tag or loaded with
like you know common j/s libraries like
browserify and things like that this one
should work pretty much anywhere for
folks you want a little bit more control
there's also a module feel that we've
dropped in there so this is still
transpiled to es5 but we're using module
syntax for import/export we left that in
there that's so a tool like roll-up can
do tree shaking if it wants and so you
know again if someone wants to have a
bit of a fancier build they could rely
on that and we've also got an es2015
field this is basically just
well-supported es2015 with import/export
syntax left in there so this is for
someone who wants like full control over
their dependencies they want to build
what's inside of node modules maybe and
they want to have like you know
differential serving for different
clients depending on what they support
things like that right so this is
approach that we use you can do this in
your package JSON or maybe put it in
your Bower JSON if you want to learn
more about this the angular team has put
together a pretty good right up over at
the angular package format doc there so
you can learn more about that personally
I would love it if I could publish my
components as es2015 and that would sort
of be it I know the polymer team is
excited to do something like that as
well in the near future but for a tool
like angular CLI today you kind of need
to publish a cs5 I don't even think it
allows you to transpile with inside of
node modules and so we're definitely at
a point now and this is this goes way
bigger than this talk but we're at a
point in our community we're going to
start figuring out like you know
how are we going to eventually
transition off of publishing everything
on NPM as es5 so we can start adopting
es1 2015 more especially because many of
our client browsers probably already
support mostly es2015 features we want
to shift to them so yeah you can check
out the stock for a little bit more
backstory there also some of your ears
may have perked up a second ago when I
said bower.json and you may even like
wait what did you just say so I know it
for the web components people you're
like oh yeah Beus of that so the angular
people you might be like hmm so there is
still a lot of utility and using a tool
like Bauer for package management
particularly for web components the
reason is because when you're working
with custom elements the tag names are
global so you can only have one version
of a tag registered at a time it means
if you can't have a fancy button v1 and
fancy button B to living on the page at
the same time you got to pick one okay
so a tool like Bower is helpful here
because at install time if there a
version conflicts it will ask you you
know which of these versions do you want
to use it'll be duplicate and therefore
your client dependencies you're only
going to be shipping one version of that
library and ultimately this is a good
thing right like we don't want to ship
twelve versions of lodash to the client
so I have seen people do that before so
deduplicating is good it saves bytes
over the wire but I realized that
everybody wants to use Bower so if you
want to use it to like NPM for
publishing your your web components you
can do that as well my recommendation
there would be to rely on the peer
dependencies field in package.json to
express your dependencies and avoid
version conflicts that way so the way
that that would work is let's take our
list box here which had that - option
child that it depended on so if it says
hey that's a pure dependency of mine
then when someone runs npm install it
will install this element and then it'll
log a little warning in the console and
say hey you've got an unmet peer
dependency you need to install - option
at version you know 1.0 so this will
give you a nice flat structure in your
npm folder the downside to this is it's
not going to install that dependency for
you you've got to manually do that which
means you've just become kind of a
one-person package manager so it's
workable in the near term but I think we
can do a little bit better there the
thing that I'm kind of most excited
about right now is
yarn package manager in particular the
flat option that yarn has so this lets
you do a flat install it's basically
giving you that same bauer behavior
where you kind of duplicate your
dependencies but you can still use
things like the NPM registry which is
pretty nice a word of warning it's
pretty experimental I wouldn't recommend
actually like doing what I'm going to
show you in your project but it's
interesting and exciting and I want
people to explore this space okay so
here's how it works in yarn to flat
install your client code if you're
finding a custom element or something
like that you can put a flat field in
its package.json this says hey when
you're installing this thing it must be
deduplicated and then inside of your
project when you run yarn install you
pass it's a flat flag and that says
alright anybody with flatten a
package.json make sure to deduplicate
them resolve any version conflicts that
i have when you think about it a little
bit your dependencies the stuff you want
to sing to the client yes you duplicate
that stuff is good your dev dependencies
your build tools and things like that
that stuff you can probably leave with
the whole like nested newid module
structure it's probably fine so if you
want to take this a step further what
you might consider doing is actually
separating your client-side modules and
your build tool modules so you could
pass additional flag to yarn where you
say alright the production flag these
are my dependencies I want them
installed in actually a separate
directory called client modules and then
I'll let all my build tools and all that
other stuff that can keep going in to
add modules again very experimental I
wouldn't do this in production just yet
but I'd be really interested for people
to try it out on some side projects and
see if it works if it doesn't work and
let me know kind of where you find
issues there because I'm pretty excited
about this approach yeah sorry TLDR
bower if you can stand it it is sort of
helpful with web components if you want
to use NPM peer dependencies got your
back and then finally experiment with
the yarn install stuff I'm not quite
sure about flat installing today but in
the near future I hope we can make that
a workable solution for folks so another
common problem that we end up seeing
when we're combining these things is
about mutating data so we've done a ton
of work with an angular in order to
handle change detection of content and
data and so if we take an example
scatter plot data set like this
if we make a change to one of the names
in the first items of the array by just
a simple inspection of the root you
don't actually know if anything that's
changed right we can't easily check data
without comparing the entire tree
against it another this happens with
both arrays and with objects in an
angular we solve this with change
detection it's all based on users and
very fast one-way data flow or excuse me
change detection paths across all of
your components in your tree but when we
add in polymer elements or confusing web
components this can actually be a little
bit more difficult and so if we take for
example an X scatterplot element here
what we actually want to be doing is we
want to be making a copy of that object
using something like object assign and
by making a hole copy of that object
we'll get out a new array and then the
web component can do a very simple is it
this exactly equals to the other thing
and if it's not then it knows it needs
to re-render itself and so this is a
relatively straightforward way that
solves change detection that mirrors a
lot of the things that we're doing
within angular last thing I want to
touch on is seaming this comes up quite
a lot when people are talking about web
components so there's really two
approaches that you can use here if
you're not ready to dive headfirst into
shadow Dom you can just write a custom
element and along with your javascript
file you can bend a CSS file and you can
say hey if you're going to use this
component here's the CSS for it as well
kind of like the way we used to include
bootstrap in a lot of our projects
there's a totally workable solution and
in fact it's how we included the
checkbox in our example so angular CLI
does a really good job when you're
importing styles of just you know
putting those together into a style
element for you and injecting that in
the page which is really nice so yeah we
have a - checkbox CSS we have a -
checkbox jf we just import both in the
project and we're good to go if you do
want to use something like shadow Dom
though the upside there is your element
will be a little bit more modular right
you can maybe use it in more places you
don't have to run the risk of
overwriting its styles or anything like
that
so the approach that I use when I'm just
doing vanilla web components and I'm
working with shadow Dom looks like this
so I'll create a template element up at
the top there inside I'll put using just
inner HTML like a template string from
my entire element and then inside of my
actual check box element what I can do
then is clone that node during connected
callback and insert it into my shadow
root the outside of using this approach
versus just calling like inner HTML on
your
a root is that this will save a lot on
HTML parse cough because we're parsing
it one time up there in the template and
then we're just cloning that Dom over
and over into our elements this is a
little perf win if you want to use this
pattern to look at that a template a
little bit more and look at the actual
style inside of there if we want someone
to be able to see our component then we
need to expose styling hooks for them we
can do that via custom properties aka
CSS variables so in this case for my
checkbox for the border that goes around
the checkbox I can expose that as a
checkbox border color CSS property now
anyone can set that higher up in the
page if they don't set the property then
I'm providing a fallback value there so
my checkbox for it will be black by
default so this is a bad as good as it
gets when it comes to styling vanilla
web components today there's a lot more
work we want to do in the standard space
to make theming easier but today custom
properties are probably your best bet oh
I also want to point out I'm not showing
how to work with the shady Dom polyfill
directly in any of this code and if you
know there's a couple places inside your
custom element where you need to shim
styles for legacy browsers my
recommendation is if you're at that
point you find it sort of onerous to
work directly with the polyfill that's a
good time to consider using a library
like polymer because that's exactly the
kind of thing that it does sort of
cleans up that boilerplate code for you
so you don't have to do that repetitive
stuff so let's go ahead and wrap up here
so we've walked a little bit through how
to combine both angular and web
components but we can see how these
things come together in some very
natural ways that are very beneficial to
each other really one of the things to
consider is consider your audience what
tools are your developers using if
you're developers are have multiple
teams on multiple stacks that can be one
of the drivers that can make you say hey
maybe we should consider web components
within our project so we're going to be
pushing the demo that we showed here
live very shortly after this talk so we
wanted to thank everyone for coming and
if you have any thoughts if you like the
way that we talked about and recommended
integrating these two things let us know
or if you don't like it we're both
available on Twitter and once again
thank you guys so much for coming hope
you enjoyed IO 17</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>