<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>High performance web user interfaces  - Google I/O 2016 | Coder Coacher - Coaching Coders</title><meta content="High performance web user interfaces  - Google I/O 2016 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>High performance web user interfaces  - Google I/O 2016</b></h2><h5 class="post__date">2016-05-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/thNyy5eYfbc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello hey how y'all doing good afternoon
so so the slides have disappeared the
slide should come back I would like a
low so uh well this is the first of the
web content this year's i/o and I I
couldn't get a straight answer from
anyone whether it was like a flying
start for the web or if it was like
ripping a band-aid off to get off you
know like get him over and done with so
the fun can start I don't know but all
the same here we are
I'm Paul I work on the web developer
relations team and I typically talk
about performance and today I thought
I'd take a break and talk about
performance which is to say actually
there is a slight difference what I'd
normally do is I'd normally explain how
pixels get to the screen pixel pipelines
how you know Styles work and layout and
stuff but today I want to talk about
building stuff because that's what we do
we build stuff but before I get into
talking about building stuff I wanted to
explain how it is that I think this talk
fits the overall story this scheme into
which it fits if you've heard us talk
about progressive web apps you'll know
that we've mentioned a bunch of things
along the way and if you haven't heard
you will do over the coming few days and
you'll hear about progressive web apps
and you'll hear things about how you
need HTTP for a bunch of features it's
good for users it's good for you it's
just generally a good thing and HTTPS
unlocks a bunch of stuff not least of
which is push messaging which is super
exciting great to get your users engaged
back into your app and all that kind of
stuff my push comes through a
serviceworker
which itself requires HTTPS and a
serviceworker is going to help you with
the offline story which is cool but I
actually there's a bit about the offline
story that I'm you know I don't mind the
offline bit but the bit that really gets
to me at the Battle of is actually the
poor connectivity bit I on my way to
work
passed through Europe's busiest train
station according to Wikipedia anyway
it's called Clapham Junction in the
United Kingdom and you would have
thought that Clapham Junction being so
busy would have amazing connectivity
you'd be wrong
because every time I pass through it my
phone says Paul I've got 3G and I say no
you don't you're putting up a spinner
this is not good service workers help
here they're gonna help us smooth over
some of these cracks in poor
connectivity so progressive Web Apps a
bunch of stuff very exciting and if all
goes well you're gonna arrive here the
thing that you built is going to be on
somebody's home screen now that's cool
that's a position of privilege that's a
fun place for us to be it's exciting
we've never been here before
but a closer look at that home screen I
think reveals an interesting challenge
for us when I look at that and I say
which of these is the progressive web
app or which of these are the native
apps well okay the Google Maps one is
probably pretty obvious but the other
ones I don't know it could be one of the
other now I use it's never going to say
this to you but there's an implied
message here that app looks like native
I hope it behaves like it
and when I say behaves I think that
falls into two parts I think it's about
the performance and I think is about the
interaction models the way this actually
feels the things that it allows you to
do they're kind of is it intuitive I
suppose so let's just quickly deal with
the performance bit if you've heard me
Paul Irish ilya grigorik
anybody from my team talk about
performance in the last year we've
talked in terms of a model called rail
which is kind of a way to put the user
back in the middle of the performance
story and it boils down to these things
a way to kind of think about how the
user is going to interact with your app
and what they expect so for example if
they tap on the screen we want to
respond to them in under a tenth of a
second for it to feel instant if we have
an animation whether that's scrolling or
a transition from one state to another
we won that at 60 frames a second and
that's 60 milliseconds idle is an
interesting one it's about doing
nonessential computation work at a time
that is convenient for the user as in
when they're not interacting and they
won't notice it and you do it in 50
millisecond chunks so that you can get
back to handling interactions if they
occur and load is sort of you know
getting stuff on-screen I think it's
what we all expect from the network or
from a cache or what-have-you um for the
gold standard there we want to get
something that up on screen and
interactive in under one second now when
we mentioned rail often people feel like
we're saying everything's important
everything is like top priority you must
do all of these things but I think
reality tells us something different I
think when we look at the advice that we
get in the sort of they're the way that
things pan out in reality it looks more
like this I think for most of us we you
know if we use the taps on the screen
course we want we want to respond well
and then we've heard that scrolling
performance you know that's the thing
and idle yeah okay but load load yes
I've got that yes when somebody talks
performance they talk load and that's
great now what I'm gonna say is that if
we expect to be on a home screen and if
we're going to build a progressive web
app I think the priorities start to look
more like this which is a different way
of thinking about what's important the
reason I say that is kind of a bit
back-to-front so let me work backwards
from there let's assume the app has been
added to somebody's home screen if it
was added to the home screen the user
was probably prompted chrome probably
said hey you're using this a lot would
you like to add it to your home screen
if that happened it's because you've met
certain criteria one of which will be
that you've got a serviceworker and
other bits like a manifest well if
you've got a serviceworker I think
you're probably going to be handling
things like the offline case or the poor
connectivity case so I'm going to be
passing through Clapham Junction and
quite happy so I'm saying if you're here
or wanting to be here it looks more like
this because while load remains
important you do have to load quickly
you do have to get the app on screen
quickly if you're hoping to run 10 20 30
and you've got a serviceworker you're
loading from a cache and if you're
loading from a cache you're not network
bound anymore correspondingly think
about the apps that you use every day
from your home screen if they scroll
well and they're responsive and they
have the features you want well that's
the way you differentiate those apps and
the things that you get so if you
thinking home screen well now we've got
a whole new competition on our hands
things that we actually have to care
about well maybe you're sitting there
going I'm more of a slight person less
of about the apps but I still think this
is gonna be useful to you I hope it is
because we still all make user
interfaces all the same and ultimately I
think we're heading to a fairly web Appy
world so with all that said what I
wanted to do is I wanted to step through
the building of three components and
they are they range from the kind of
fully deterministic we know where we
start and where we end with the the
animations in the transition all the way
through something that's a little bit
more dynamic all the way to the far end
where we have no idea upfront exactly
what the animation is going to behave
like those three components are a side
nav a dismissable card system and an
expanding and collapsing view so let's
talk about the side nav so now then is
this one we're all used to them I think
now what we're gonna do is we're going
to talk about a little bit of theory for
each of these just to kind of set up how
it is I would actually consider
approaching them from a at least a
performance point of view so we've got
our page here and let's check on a
containing element and this is going to
be the home for our side nav into which
we're going to place two other elements
a semi-transparent black background to
obscure the page content and of course
we'll have the side nav contents
themselves which we're going to want to
slide into place and in and out as we go
when it comes to that container what I'd
normally do is make it position fixed
and left top zero width on 2% homes and
some people might write 0 bottom zero
that's fine I know I don't feel strongly
about it
overflow:hidden because when we got
something translated on the side we
don't want a scrollbar but there's an
interesting design decision that I'm
taking here with my side navs which is
I've got pointer events nan the reasons
this a sign now is the kind of element
that you want primed and ready to go if
a user taps on the button we need it to
come in quickly we don't want to have it
out of the render tree because then when
we bring it into the render tree we have
to trigger layout and styles and we have
to paint the thing and then we can
animate it in so we want it there we
always wanted in the render tree not
hidden but then it's going to sit on top
of everything else and block clicks
that's not cool so we can add pointer
events nan and clicks will pass through
to the underlying content when we bring
the side nav out we can switch that to a
pointer events Auto you don't always
want like this primed ready element but
if you have one like a side nav consider
that you might want to just have it
ready and set something like poet or
events to non other things this side nav
content a bit we want to promote this to
its own compositor layer composited
layers are our way of separating a part
of the page from other parts of the base
bit like you would in an art package
where you create a layer and then you
can mess around with it and it's not
going to affect the other layers that
you've got it's not just one flat bitmap
it's sort of separated out browsers will
let you do that and the way the easiest
way is to use will change transform it's
relatively new only last couple of years
before that you would have used
something like translate Z zero which I
think many folks have done so what it
kind of does if you imagine there's this
page here simple as possible page I
could think of with a photo of a bald
guy and a nice guy and we put will
change transform on that then it gets
separated out this is yes 3d love it
and when it's separated from the page we
can use a transform and move it around
and it's separate we don't have to
repaint the page content behind it it's
an extremely you
full thing that we can do now maybe
you're sitting there going that sounds
cool I feel like I should promote to
every element star will change transform
burn that from your mind if I'm not
clear enough don't do it don't do it the
reason you don't want to do it is
twofold firstly we want to keep memory
usage down when you create a layer the
layer itself has a memory associated
with it but you also have to load up
load the textures to the GPU and so
that's memory you're gonna use and on a
mobile device you don't want to do that
the other thing you want to do is bear
in mind that your time putting those
layers back together is compositing and
you'll want to keep that time down so
the more layers you have the more time
you'll spend in compositing so it's a
balancing act but all the same this is a
primed and ready element and we're going
to promote it to its own layer so we've
got we'll change transform and we're
gonna transform this side nav off to the
side just out of view with a curiously
specific - 102 percent you might be
thinking why not have minus 100 and that
is because I've got a shadow and the
easiest things just move it a little bit
further sometimes like I need to turn
the opacity down it's do that but why
not just do 100 and tips it was 2%
between friends nothing just do it now
at some point the users going to tap on
the button and we're going to show the
side nav which in this case is just
going to be adding a class to the side
nav which is going to remove that - 102
percent and just transform none and that
will basically cause it to slide in from
the side with the semi-transparent black
background it's a similar kind of story
we just have will change opacity this
time which will create another
compositor layer and it will also create
a stacking context and then we can
transition from opacity of zero through
to opacity of one dismissing the side
nav is a fairly similar process but it's
the same but in Reverse really but the
way I choose to do it is I'll say if you
click anywhere
now if you click anywhere in the side
nav I'd like you to hide the side map
which is great because if you tap or
click or whatever in semi-transparent
black the black background that's going
to go but the problem with that is if
you actually click on the contents of
the side nav you're gonna dismiss the
side nav which might not be what you
want it's the easiest way to solve that
is just to cancel it if you click inside
the side nav it is canceling so you've
got to be careful with this but I think
it's a good use of this and that just
involves stopping the propagation of the
event I think it's reasonable the other
thing is this is behavioral thing that I
think users expect from Cerner they
expect to be able to gesture and sort of
swipe it and move it around with their
finger get rid of it so in this case my
personal preference is to delegate that
out to the documents with a touchstart
touchmove and touchend since I've
delegated that out to the document I
need an early exit case if you touch
start you know on the document and it's
not the side now that's not so clever so
we just have this it just says if the
side nav is not out because it's a kind
of modal element you basically can just
rely on this simple check if the side
nav isn't out don't worry about it if it
is cool let's start figuring out what we
need to do and in this case we're going
to start visually updating every frame
with requestanimationframe
oh where did this and where did the
slides go let's bring them back hello
it's twice terrific so we start this
update loop with requestanimationframe
and the request animation frame what
we're doing here actually is decoupling
a little bit now I'll talk about this
more in a moment but I've got the
requestanimationframe which is going to
update every frame of the animation
irrespective of whether I get touch
input as I say we'll talk about that
more in a moment it's a useful thing in
the touchmove all we want to do is just
find out where the finger has moved to
because we're going to need that in a
moment to actually slide the side nav
into position a slight note here is that
we would want to use prevent default
because by default by default chrome is
going to throttle back the number of
touch movies
we get and we want them every frame if
we want something that we can have stick
to finger so the way to get that every
frame is to call prevent default so with
that said our update is fairly
straightforward we can just figure out
where we've moved from and to make sure
we never go past 0 because we won't
always go to negative and then apply a
translation to the container works out
just fine and then when we're done we
need to remove that transform that we
are dynamically because it takes
precedent
it's got greater specificity than the
class-based animation that we had that's
right I said specificity twice and I
didn't get it wrong and that's where
jet-like and then if you were translated
off slide to the left will hide the sign
of works out just great this is what it
looks like in reality this is a side nav
the code for this is on github and I'll
send you I'll give you a link to this in
a little bit and you hear si point out
from the side it's going in we can drag
it around who works out really well in
fact from a performance point of view
this is the dev tools timeline and you
can see here I've taken recording with
the side nav sliding in and the side nav
going out and if we zoom in a little bit
on the side nav coming in the top bit
the green bit is the frames per second
which is a steady 60 frames a second on
a nexus 5x and you can see that below it
there's the work per frame and it's
basically very cheap we're doing really
well here so this approach works well if
you want to recap on that because we're
about to move on there's a show that I
do called supercharged and there's a
live stream of me building the side nav
which is about an hour long and then
there's the TL DW which is this which is
about five or six minutes long where I
basically recap what I just told you bit
least look slash sign now so let's move
on to the swipeable cards because the
sign that was fun and it was pretty much
a deterministic - hundred and two
percent to nothing and back again
swipeable cards well they're not primed
we don't know which card you're going to
interact with so we don't necessarily
want to be like we'll change transform
on all these cards because there might
be lots of them so let's see what's
involved here so it's this you know it's
not with this wipe and the move and
they're cool so our theory is that we
definitely do want to promote
to a layer but we want to do it at the
last minute we don't want to do it up
front
so we'll have to do that with JavaScript
when you move it to the side we're going
to use a transform because we did we
know in the same ways we did with that
photo we can I moved it back and forth
we want to do that and we can use
opacity as well transform and opacity
are our two best friends when it comes
to animating performant ly so we'll use
that as well now I mentioned before
about this decoupling and of the touch
input from the visual update and this is
pretty much what game developers do as
well because whether or not you move
your character or whatever on screen
they want to make an update they want to
draw the screen and it's pretty much the
same here we will always want to be
updating the screen we want to draw the
stuff irrespective of whether you've
actually interacted so the way we do
that is if you imagine every frame that
we want to draw of the the interaction
or animation we just call
requestanimationframe with the update
function for every frame and if we get a
touch move event great we'll incorporate
it into that frame if we get one
slightly after that's okay we'll deal
with it in the next one
and if by some weird co-inky-dink we got
two of them while it doesn't matter we
were all we were going to do is store
the touch value the the position and
we'll deal with it in the next
requestanimationframe it's a relatively
cheap way now it shouldn't be the case
that you get more than one but it could
happen and so we want to decouple we
want to separate out what might happen
here and as it happens it means that
you've got an update function that you
can call independently if you ever need
to for some other reason kind of works
out well now when I show my code often
people go what gives with the bind thing
it's just this is a total aside I just
wanted to talk about it so that no might
be useful it's a bit of an acquired
taste like Earl Grey tea and it would
like kill Grey tea no no a few ogres
okay basically what I'm doing here is
I'm copying from the prototype into the
instance
and binding it in the process the reason
I do this is it's got two benefits on
one cast the two benefits are because
I'm binding to this it means that when
I'm in these functions if I say this
thought whatever it refers to the
instance and not the event target the
other thing is they're named on star
I'll move on it and that means that it
can do add event listener and name call
them by name and I can remove event
listeners for tidiness sake if you just
use an arrow function it can be a lot
more difficult to do that impossible but
it just makes life a bit more difficult
so our cards they start here and that's
fine we can do that we can get the page
X or the first touch events page X I
think when the pointer event stuff lands
that will be a lot easier it's not too
bad it's a line of code and here this is
what I'm talking about we were going to
use JavaScript to manually promote the
car that we're interacting with to its
own layer as and when we need it
not before we don't know basically
promote everything just in case we
caused ourselves memory issues so this
is where we started and now we're going
to move off to the side here well our
own movies fairly straight for it's
pretty much the same kind of deal we can
just track that's all we're going to do
we're going to track in the our move own
the update will to take care of actually
moving the card like so because we know
where we started we know where we are
and that's just a translation at this
point so that's cool if you're dragging
the card the translate is the current X
minus the start X and then we can use a
transform to just move it on very
similar to the side nav right but
there's a bit where you dismiss the card
right so if this is like zero and off to
the side is position one like normalized
position one out to the side or in the
other direction this is one what I do is
I throw up these thresholds at like I
thought I put it in 0.35 but you could
put wherever you like if you go past
this not 0.35 threshold and release then
we want to dismiss the card so that will
be in here in the on end the threshold
is the card width there you go and if
you've gone past the threshold then you
set this target X which we haven't seen
to this point but
and it's either gonna be the card width
or - the card with depending on where
you were going and that's it in use here
now it takes this form translate X plus
equals target X minus translate X all
over for now if you've been in doing
this kind of stuff for a while as I have
you'll recognize this pattern if you've
not seen this pattern before it's
incredibly useful there are variants of
it it's kind of like looping and it's
very very useful it's kind of like the
easiest easing that I know how to do
till you get this nice smooth motion and
it takes this generalized form value
whatever it is and in this case it's the
translation in X plus equals target
minus value all over strength let's see
what it means in a kind of for reals way
let's say we're taking this box from 0
to 100 well there'll be 100 minus 0
which is 100 all over strength that says
4 will we move it 25 pixels in that
first go so it's now here I mean the
next frame it's going to be 100 minus 25
which is 75 all over 4 which is 18.75
pixels and on and on and it basically
slows down because we get closer and
closer and closer to our target every
time which gives us this kind of nice
slowdown which is cool because that's
the feeling we want we only want the car
to kind of slide gently back to the
middle or we want to dismiss it off so
they're young so see it's a one-liner
but it's a really useful one-liner I use
it quite a lot so now we got to take the
doneness like how do we know when this
cards are doing I don't know
well there's one version which is where
you can slide out to the middle a little
bit you don't go over the threshold and
then you let go and we go back to the
middle well that one we can just ask if
the translation is small and if the
translation is small enough then we'll
just reset it it'll be fine
that would work but the other one is
basically well we've got a gonna dismiss
it off to the side and it's going to
disappear because that's the something
else that the user would expect they'd
expect this to disappear they expect it
to go to an opacity of 0 as part of that
behavioral thing in that case there's a
nice and easy cheap way of checking that
it's big
Stickley gone which is that it's
invisible and in that case we can
basically remove it from the Dom but
that will cause the other cards to just
jump up immediately and what we'd like
to do is we'd like to slide them into
position that we like that okay
so we've removed a card and that's going
to cause the other cards to jump up so
what we can do again with the
translations you can start at the car
that we've removed we can immediately
transform them all down by a cards worth
of height plus in my case a little bit
of a margin and then we'll wait a frame
for that translation to take hold
we're using requestanimationframe to do
that and now what we'll do is we'll
switch on a transition on transform and
we'll just remove that transform that we
added that again is another transform
transition on transforms nice and easy
and it will cause that to slide up when
the animation is finished we can
basically say okay we're done this
card's gone pick another card so that's
a slightly more dynamic version of the
first one really and this is what it
looks like in reality you can oh go back
Paul you're gonna do it you can do it
you can do it yes so you know move out
let go fine just miss that one just miss
that one great dev tools this is what it
looks like again very green that's all
good news now this bit of the the
timeline is the card being dismissed
which you can see is a fairly steady 60
frames a second and then this is where
the other cards slide up into position
and you'll notice at the start because
this is reality there's a little dip in
the frames per second and that's because
we're doing that setup of all the other
cards to get them ready to animate them
up so there is a little dip just as that
works going on but it tends to not be
too much of a problem because there's a
break in the animation the first one
disappeared there's a break and then the
other one slide up and you don't tend to
notice it again if you want to see this
one being made there's a another live
stream and a TL DW that could help
so let's move on to the final one the
expand and collapse now the expanding
collapse is probably its the most
challenging of the three and the reason
is we don't know really where we're
starting and where we're finishing ahead
of time and it could change with
responsive breakpoints so in this case
we're going to expand this one card out
like that but we could be doing any
number of things we could be sliding
something down bringing something in
from the side this is probably the the
one you'd most likely to do in an app
context because this is the kind of
thing that people expect from an app
right the theory here would be well
certainly what I do when I get something
like this from a designer where I do it
myself
is I'll eyeball the animation over and
over and over again and okay there's the
pink thing that's fading in the header
bar at the top but mostly this thing is
just changing size right it's getting
bigger and it's moving on-screen its
width is changing its height is changing
its left to changing and it stops
changing at those will be the ones that
I would want to animate unfortunately
that wouldn't be the performant path
forward if you go to CSS triggers calm
and you look up any of the four of left
width height or top you'll see that for
blink gecko WebKit and edge triggering
changing any of those mutating any of
those will cause you to trigger layout
which is changing the geometry of the
page so that's the positioning or the
dimensions of an element and layout is
normally proportional to the Dom size
the more elements you've got in the page
the more time you're going to spend in
layout that's typically the case so
you're going to do that if you change
left with height it up and you'll do
that every single frame of the animation
you'll also trigger paint if you trigger
layout you're guaranteed to trigger
paint painting is going to be expensive
cause you're filling in pixels and then
you're gonna have to composite any
layers that you've got together on the
page not a good story if you do that
every frame of an animation certainly
not on a mobile device now from the
previous two examples you may have
noticed that I'm a big fan of transforms
and the reason is this with a transform
if is if you got something that's got
its own layer which I showed before with
there will change then you don't trigger
layout you don't trigger paint you entre
compositing if you transform it around
it's our new best friend I think for
this kind of work so the question
becomes can we do an effect like that
with transforms the answer is yeah we do
is just slow down that looks to me like
a transform or it could be if we use the
scale transform and we use the translate
cool but we can't just hard code it
because we don't know what we've got
we've done our vice the approach I take
I call it flip and it stands for first
last invert and play and I'll step you
through what it actually means first is
where the thing starts on screen so in
this case it's starting here this is the
card that we're going to tap on to
trigger our animation and what we can do
is we can call get bounding client rect
way to go naming of functions but it's
been around forever is been around since
like ie four and it's amazing it tells
you like the width the height the left
that top the bottom the right for an
element relative to the viewport so you
know where this thing is on-screen and
how big it is
then what we can do is we can actually
immediately snap our animation right to
the final frame it sounds a bit odd
bear with me in this case I'm going to
use an expanded class but you could
manipulate the styles any way that makes
sense to you so we've gone from our
first we've gone to our last position
that's cool and then what we do is we
call get bounding client rect again now
we know where we started and we know
where we finished interesting now
admittedly in this process going from
the first position to the last position
forces styles and layout which I'm sure
you've seen they're going
sure you said that was a bad idea are
you doing hold on there's two reasons
why it's not as bad firstly because I've
said it here yeah there's two reasons
why it's not so bad firstly we are only
going to do it once we're going to do it
as part of the setup of the animation
we're not going to do it on every frame
we're doing it once and I mentioned rail
back at the start
rail is going to help us out here bear
in mind the user tapped on the card to
get to that finalized in a version and
they're tapping and so in rail terms we
actually have a tenth of a second to
respond to the user so we've got a tenth
of a second and that normally gives us
enough time to do some work and in this
case you can typically afford to do a
single styles and layout pass just the
one but you can afford to do it but
you'll still need to complete in less
than 100 milliseconds if we're going to
stick to the rail stuff but actually in
my experience 100 milliseconds is
actually plenty of time to get one of
these styles and layout passes done okay
so we know we started and we know where
we finished now finally we are ready to
introduce the transform to this
situation because what we want to do is
we want to return our card or our view
back down to where it started just using
a transform well we can do that because
we know where we started where we
finished and we can figure out the
scaling that we need and then we can
apply a transform to take care of it so
and that effect is this here we are
before or about to tap Ready Steady Go
that's it
at this point we're actually done with
the first last an invert but actually
what happened was this we went first
last and then we didn't animate this bit
we inverted which is cool because what
we can now do is we can switch on a
transform transition because we've knows
to just basically apply a transform to
this element and it will call and then
we remove the transform that we buy that
invert transform and it will cause the
card to do that
we just managed to remap that animation
from width height left and top through
to using a transform and that makes it
much more likely that we'll get 60
frames a second flip does come with a
couple of caveats though and it would be
remiss of me to miss those out so I
shall tell you what they are firstly if
you scale something you're gonna scale
the children elements with it you might
need to use sibling elements for content
because if you've got something that's
scaling and skewing and not quite you
know linearly doing so then the children
will also get skewed and squashed and
stretched which might not look really
nice so what you want to do is you want
to probably move that content out to a
sibling element which isn't being
squashed and stretched so it does
require a little bit of gymnastics but
it works out typically just fine it's a
bit of sleight of hand smoke and mirrors
to make that work like I said that first
to last change involves forcing styles
and layout so you need to be careful
with it you need to check your dev tools
and just make sure that when that
happens you're not spending a long long
time but when you do this is the kind of
the thing you get this is on the Nexus
5x as well and you can see it's the kind
of you know it's a fun little animation
you can have lots of them on the screen
tap one and it expands to take up the
full screen but like I say flip is it's
responsive design friendly because of
the fact that we don't know ahead of
time we just ask what are you what are
the positions on screen before we begin
this animation in this case if it's like
this but it could have been like this
which is the desktop version different
size different location on screen but it
works just as well works out really well
for us from a dev tools point of view
this is what you'll see this is the card
expanding again we're going to see a
fairly green run across the board now
there are a few dips was it one two
three four dips and that is just reality
in this case Chrome has decided part way
through this animation to do some
painting and that just happens sometimes
but mostly it doesn't happen and in fact
when you look at the collapsing
animation you actually get a much
cleaner picture of what it's normally
like
she's like this mostly green except for
that bit at the start which is the first
last and invert part it's the setup of
the animation that's why it's running at
a low frames a second because we take up
to 100 milliseconds to do the setup in
this case it's like 14 10 to like 14 40
30 40 milliseconds something like that
on a 5 X so we're nearly done we've gone
from a fully deterministic side nav
which we know ahead of time all the way
through to something and where we don't
know ahead of time we have to basically
bake it into our code they're consistent
things across those three which tends to
apply to all the kinds of animations
that you should do if you want something
that's performant is that you'll want to
use a promote elements that that you
intend to animate use things like will
change or translate Z if it makes sense
it normally does but you'll want to use
it sparingly as I said you don't want to
overdo it and overuse memory transform
and opacity changes are your friend
because of the fact that they don't
trigger layout or paint and they can
typically involve GPU layers and that
makes it pretty fast GPU less composited
layers which have the GPU helping there
you go flip I mean I'd love to find
another way but this is the only way I
can think of at the moment to remap
expensive properties to transforms it's
more work than just going transition
width height left top there's a lot more
code but it works and it works really
well and we have used it in production
in the stuff that we've built at Google
so that's cool if you're new to
rendering performance and you're sort of
thinking why transform and opacity
what's layout what styles what's paint
I've never really spent much time we
have a section on Google web
fundamentals that could help you it's
the rendering performance section
there's also a course that you can do
with Udacity as well which runs you
through exactly what's involved in every
stage of the pipeline and that could be
extremely useful
kind of figure out when you're looking
at a dev tools timeline what why why did
that trigger layout and it should
hopefully help you there if you want to
see the source code and play around with
the elements the three elements that I
showed you can do that with the
supercharged UI that'll take you to the
github repo where you can clone and play
with the code and if you want to watch
the supercharged episodes where well I
tend to do the coding and Surma
interrupts me but that's fine it's just
like real life in the office so that's
helpful you can do that ultimately
though when I think about this I think
it's a tremendously exciting position
for us to be in as web developers this
is it's just so exciting like somebody
could add you to the home screen and
you're incredibly useful to them and
that's awesome but with that comes some
expectations I think I users deserve
user interfaces that they they love
using I think the web is ready to give
it to them we have sometimes have to do
a little bit of evidence to make it
happen like you saw with flip but it can
be done and it's completely worth doing
well I'm gonna be out over in the mobile
web area for the next few days just
kicking around so come and say hi can we
show me what you've been building and
have a wonderful i/o and thank you very
much for coming to see me dude</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>