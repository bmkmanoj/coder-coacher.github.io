<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Polymer &amp; the Closure Compiler (Polymer Summit 2016) | Coder Coacher - Coaching Coders</title><meta content="Polymer &amp; the Closure Compiler (Polymer Summit 2016) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Polymer &amp; the Closure Compiler (Polymer Summit 2016)</b></h2><h5 class="post__date">2016-10-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/CplQdSo7lkE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello my name is Sam Thorogood and I'm
looking for the bit BA here it is
so I'm from Sydney as Matthew mentioned
I'm on the developer relations team
there so today I'm going to talk to you
guys about the closure compiler it's
actually quite old for Google right it's
been around for 10 or 11 years but it's
something that can make you more
productive so with that let's dive in
but I want to start with a happy cat
first so I've been at Google for a long
time I've worked on you know C++
projects Java projects objective-c
projects and I love a compile step right
it makes me feel like warm and fuzzy
like this I think this is the same cat
as Eric used actually but this is what I
feel like one of you statically compiled
languages it's like this confidence that
your code is doing the right thing
you're getting you know build kind of
time checks to make sure that things
aren't going to break spontaneously for
your users so with that in mind
I want to reintroduce the closure
compiler it's a JavaScript optimizer
transpiler
and type checker and what some people
don't really know is that it's also at
rent like a s60 s5 translate a
transpiler you know it supports all kind
of normal stuff you'd expect from a tool
like that and being on the cut again
cutting edge of AES is pretty much the
highest thing on the teams priority you
know they're keen to support things like
a sink and a weight and that's coming
soon in some future release of closure
compiler it's a it's a Java jar it was
released you know many years ago as a
pure Java thing you have to install Java
to run it but just recently Google has
released a version of closure compiler
that runs in pure JavaScript so turns
out when you tell developers you have
one fewer dependency and that dependency
is Java people are really happy and so
obviously closure compiler loves polymer
this talk is really about how to make
these two wonderful strange sometimes
the Hema things work together to make
you more productive so I want to talk
about your first compile you know how
are we gonna how are we gonna compile
your polymer code with closure compiler
so I won't go into the exact build steps
there's some resources online and
putting some later in the end of the
talk but basically you'll have to set
this polymer pass flag so it understands
a few polymer quirks
you know the polymer function and its
properties object and this will change
over time as 2.0 comes out
I've been reliably told that there's
fewer hacks and 2.0 so closure compiler
will be much happier but you'll probably
still need this flag for whatever quirks
we have happen to have in that release
to start with I'm also going to talk
about closures simple mode so that has a
couple of modes I'm gonna focus on
simple today but I will talk about
advanced because I really love advanced
but simple is really where it's at
let's show a quick example so this is a
polymer element it's pretty simple and
it has a single closure annotation it's
a bit out of place so you might be able
to spot it but there's also a bug so
let's look at the compiled version so
this is pretty familiar anyone who's
done any kind of javascript minification
you know is used to this thing on the
top it's a minified blob of JavaScript
it's short it's made some you know
concessions it's turned variables into a
YZ versus real names and things like
that it's pretty similar to most tools
but what closure is also giving you is
this morning it's done an error this is
configurable it can be a warning or an
error in this case it's just a warning
it's telling us that there's no method
called to lowercase on number which is
right turns out I can't lowercase a
number the annotation you saw before and
I'll just go back to show you which
annex your back will work there it goes
so that annotation before the number
tells us that this method expects a
number so therefore closure is giving us
a warning it's not a number what's going
on so let's talk about what simple gets
you as well as this kind of basic type
checking so it minifiers
give you local variables I'm sorry it
minifides local variables it turns them
into short names it gives you notices
about side effect misuse this is a bit
of a weird thing to explain but let's
have an example if you have this line on
its own without anything a jacent to it
closure can basically tell you why do
you have this it doesn't do anything
and so it will actually warn you about
that it'll also catch common j/s
pitfalls it's a bit out of scope what
that means but if you look up close your
compiler it'll tell you a little bit
more about the things that'll look for
and the problems that we'll find in your
code it'll also do type checking and
while you saw an annotation before one
thing I want to point out is that
closure with no extra work will still
give you some benefit because turns out
we know what the platform is we know
what it returns so the same pausing
function we know it returns a number so
whenever we see X and we see X move
around your code we know there's going
to be a number and we know if you're
going to use it incorrectly or we know
that you pass it to some method that
doesn't expect a number so you get a lot
of benefit even while doing nothing so
this is great right you know this is a
simple example and you can imagine as
your code gets more complicated that
these kind of annotations and checks
will help you write your code gets
bigger it'll find more nuanced problems
it'll kind of give you warnings and
errors all over the place you know I can
show you some of my projects which have
you know hundreds of lines of errors but
it wouldn't be making a very good talk
and so this cats pretty happy about that
so we're done right well it's hard I
mean what makes this hard and why
wouldn't you use this closure stuff you
saw one example already it was kind of
subtle but you'll need annotations
occasionally to help hint to the
compiler of certain types what else
closure expects JavaScript not HTML it's
pretty basic we can probably fix that
duck typing we've got that lovely
picture there is fragile this is kind of
a pro and a con turns out you know I've
written closure I've I've written
polymer elements in a vacuum before you
know I've written something that has
some properties and some functions and
I've given it to a colleague or
co-worker and said call this method
it'll totally work the way I've told you
and you know there's no guarantee there
there's no contract yeah of course you
can solve this with testing other
approaches you know using static
analysis is not the only solution to
this problem but as a pro if you can
provide the right closure information or
the right information to closure you can
actually tell your colleagues or your
neighbors or even yourself about what
this method expects or what this class
looks like and you can be more
productive
because of that I guess what I'm trying
to say is closure is not a silver bullet
remember that you do need to provide
some level of information and that is a
con and one thing I want to talk about
again is advanced mode so this
interesting point will come up a few
times so as I said I love advanced mode
it's awesome
it makes closure really really powerful
but it does this strange thing for
closure and the problem we have is if
you have stringed named observers or
computed values closure doesn't know how
to look at these it goes it's a strain
I'm not going to touch it but in
advanced mode closure will minify your
property names including your method
names which means that that update foo
is now a one letter mapping that is much
shorter or much neater you know saving
your space so this is a common problem
with closure and Advanced Mode but I'll
focus on simple mode for now so what's
the first problem well you need
JavaScript pretty basic stuff we'll do
something like CRISPR to pull out your
JavaScript from your HTML next as I
mentioned before closure is about types
so we need to provide some level of type
information to closure to get the most
benefit out of it you know we've got
some built in ones we've got number and
string and function we've got you know
built in HTML types like that maps to an
input tag and every polymer gets a
default type enclosures mind unless you
override that so it's the camel cased
version of your element so an element
called my dash element will be called my
element element and it inherits from
something called polymer element which
has a bunch of definitions about you
know this dot fire or attached or are
the callback methods and so closure will
actually help you if you use those
incorrectly what else is polymer
specific polymer has this dollar sign so
everything on the dollar sign here is of
a completely unknown type closure
closure doesn't know anything about what
that element is because it doesn't see
your HTML only sees your JavaScript so
it literally thinks this is a typed
question mark which is the most generic
type you can have in closure what we can
do is add an annotation here so this is
if this is of type my element element
then I can pull this out into a local
variable and we can tell closure that
it's actually of a known type so you'll
see this kind of a formatting pretty
commonly throughout close your annotated
code another interesting part of polymer
is behaviour
you know I've deferred to the UK
spelling here you know in honor of our
hosts and there's some minor caveats
here
they're pretty not they're not very
exciting but I'll go through them anyway
they need to be fully qualified closure
needs to be able to get at them so that
means they need to be on window as
opposed to hidden inside a closure and
by that I mean function closure not
closure compiler just in case the some
confusion about those tones they need to
be annotated but in researching this
talk I actually found out that the
compiler tells you to annotate it which
I find a bit strange right surely if it
knows then it doesn't need to tell you
but in a kind of suggestion to go in
network I actually talked to a polymer
engineer this morning and he explained
to me why this is the case so if
anything come find me later if you are
curious about why we have this double
level of our annotation it's not overly
exciting but I find as a nerd it's very
interesting to know how these things
work so I've mentioned simple and I've
gone through some of the requirements or
things you might need to do to make
simple work so I'm gonna talk about
advanced very briefly what is advanced
to that simple doesn't so as I mentioned
it minifides property names that'll make
a code even smaller it also does dead
code removal and tree shaking and this
these things together actually make
closure one of the sort of best
JavaScript complier compilers in terms
of size and it'll regularly you know do
very at least very well on kind of
shootouts of of what is the best
compiler for reducing your code size and
what this will actually do is any code
that's not run in a kind of a statically
analyzed way will be completely dropped
from your output it'll even do things
like inlining where you know functions
they're actually shorter within your
code but maybe better presented you know
as an engineer as you're building it
outside your code when we brought inside
it in line directly in that position and
of course it'll do all of simple but I
will continue about advanced a little
bit the big takeaway here is that most
polymer elements won't compile with
advanced if you want to use it for your
own
that's great and this property renaming
stuff which I keep coming back to there
are a few approaches to solve it you
know you could in happen you could in
fact put your methods in strings
themselves you know the key word of your
object defining your polymer class could
have on food in a string but that
rapidly becomes a bit unwieldy there's
also something called google reflect on
object which now I'm getting very very
detailed which actually lets you
introspect to closure compilers internal
renaming table so that you can actually
see what the compiler is doing while it
works kind of like a macro or a
preprocessor yet again a bit nuanced and
a bit detailed but if you can do it it's
really cool you'll get a huge benefit
but only try it in isolation
don't try to compile your whole codebase
with this because you'll get errors
aplenty so if I want to leave you with
anything it's basically to keep it
simple you know closure gives you a huge
amount of benefit for like very little
work actually you know if you're writing
closure if you're writing polymer
elements with var and you know old-style
functions because you're worried about
browser support turn on simple mode get
closure compiler add it to your projects
could you get some of this really cool
stuff you get transpiration you get
static type checking
you get minification and probably the
most important part of all this is it's
what we do at Google and it's worked for
us for you know 10 or 11 years it's
migrated into the polymer era and in
fact nearly all of our polymer projects
actually use it to be more productive so
this talk was largely drawn from a blog
post called using polymer with closure
compiler all these resources will be in
the YouTube video but you can google for
them later as well so it was written by
one of our keenest external contributors
it's in three parts the first part talks
about largely what I've mentioned today
and the next two parts go into a bit
more detail about advanced and a few
other topics there's also a tool called
polymer rename which helps with this
process and finally just this morning I
actually quickly put out a post called
polymer and closure compiler which you
can read which is really a how-to guide
of how to add closure compiler to an
existing polymer project and there's
even a repo you can check out to
no just literally type you know get
clone npm install and you'll have
something that's been compiled and
minified right in front of you as a bit
of an ad judge adjunct I'm gonna talk a
bit about the use of polymer within
Google because turns out we use closure
compiler within Google so it's a perfect
kind of segue so inside Google we use
these things called build files I'm not
going to cover them here but they're
basically part of our open-source build
tool called basil we have a couple of
simple rules that we use that actually
the help us build hermetic which means
kind of self-contained
HTML and JavaScript files you know this
contains all of the elements that are
used inside a particular project this
number here this 350 projects is the ID
to such a few days ago for the binary
target so each one of those targets is
something that gets built that gets you
viewed in a browser and that is a real
Google product some other and some of
them are internal facing some of them
are external facing most are probably
things like internal dashboards or tools
that are used by a small number of
people so finally this binary target we
have will also run closure which is
known internally as Jas compiler and it
has a sort of special process for
handling this property renaming stuff
which i've been mentioning how do we
store this code we use something called
piper which is a global version control
system one of its interesting properties
that it has
determines turn it deterministic build
numbers I'm sorry I can do a build at
any particular version and know whether
that's going to be green or red and now
all the dependencies will be consistent
at that version so this is a nice
property to have right I can basically
check out any point in history and say
whether my target was success was built
successfully or it failed but it has
some side effects so we have it Google
what's called a one version policy so
within our code base we only really have
one version of any open source or
third-party library checked in at once
this includes polymer so while we might
have rapid development in the public on
github what will actually happen is
we'll only occasionally do imports of
that code into into our mainline code
base and this turns out is like most
companies right
don't want to you know move or change
your dependencies too rapidly but of
course occasionally we want to do
emergency releases we want to bring in a
security fix or some urgent patch we
need to make what we have is something
called a global pre cement and this is
the lovely part of that working at
Google and I can literally run every
single target and every single test at
least the ones that depend on Palomar
rarely relatively quickly and find out
whether that change will be successful
and of course if you're feeling lucky
you can always just ignore the pre
cement and submit anyway so finally I'm
going to leave you on a few public
projects which use polymer I mean you've
seen some of these already today but for
big projects we've got things like
chrome itself YouTube the Google
developers code lab site which is eric
mention and you'll actually see if you
go into the back room and do some code
labs today and actually for me i'm
actually the lead of santa tracker so
turns out Santa is Australian after all
and he's pretty happy about our choice
of framework as you can see the secret
is that actually I'm gonna go home and
watch all these talks and go what can we
make Santa Tracker do this year it's
even better at using polymer but just
like all the you know good boys and
girls around the world you'll to have to
wait until December to see what new
features we've come out with this year
so that's it thanks everyone and I'll be
around for Q&amp;amp;A later
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>