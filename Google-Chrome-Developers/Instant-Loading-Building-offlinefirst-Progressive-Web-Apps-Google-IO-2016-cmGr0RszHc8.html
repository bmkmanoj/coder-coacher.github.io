<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Instant Loading: Building offline-first Progressive Web Apps - Google I/O 2016 | Coder Coacher - Coaching Coders</title><meta content="Instant Loading: Building offline-first Progressive Web Apps - Google I/O 2016 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Instant Loading: Building offline-first Progressive Web Apps - Google I/O 2016</b></h2><h5 class="post__date">2016-05-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/cmGr0RszHc8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone welcome to building
instant loading offline first
progressive web apps it turns out if you
put all the buzzwords in your title they
let you have the big stage which is
great I'm Jake Archibald I'm one of the
designers of serviceworkers and one of
the editors of the spec as well what I
actually want to talk to you about is
spam phone calls which I get a lot of
you know the sort it's kind of like you
know have you been in an accident in the
last 200 years
would you like car insurance for all of
your pets etcetera etc I actually get
enough of these phone calls that I
started inventing games to play and my
favorite game is um and in this game I
become the most indecisive person that
has ever existed it goes like this
hello mr. Archibald are you interested
in saving money on your mobile phone
bill and I reply
um well layaway iOS suppose if and at
this point the caller usually tries to
hurry things along but it's very
important that you do not let them well
we've got a great deal on wait wait wait
wait wait do you um is it one of the and
you get a point for every second that
they aren't talking and it's a really
difficult game because you know the
caller gets frustrated pretty quickly
because you're directly blocking a
conversation which is a very synchronous
transaction where each person wants an
instant response and and you're breaking
that model we expect a similar model
when it comes to getting data from a
computer but that wasn't always the case
like 25 years ago our expectations were
pretty low like if you wanted to know
the directions somewhere first you would
have to go to the room with the computer
in the room I turn it on and the fans
would start worrying you get that static
crackle as the CRT monitor whirs into
action Windows 3.1 would start booting
up and then eventually you would get
your desktop and then it did this
because this was an era where booting up
successfully was a fanfare worthy moment
but even after that you had to find and
insert the map CD and print out
directions then off you went these days
we don't need to to boot up the one
computer we own because we have a
computer in our pocket that's already
booted up we can ask it for directions
but that later often comes from the
internet if you have zero connectivity
and you ask the internet for something
the web's answer is often no I remember
when I first realized how problematic
this is a few years ago I was working an
agency a web agency and I found myself
needing to go to the toilet following a
lunch that my stomach was unhappy about
there were five cubicles to choose from
but in this instance the first four were
occupied that's usually okay even in
this situation I felt that one cubicle
would be enough for me but from previous
experience I knew that mobile
connectivity and the office Wi-Fi only
extended to the first four cubicles I
fought for a moment and decided no this
is not acceptable and I returned to my
desk and I waited until later despite
being in some discomfort that's the day
that I discovered that as a human being
I required an internet connection in
order to take a dump so this is a
problem worth solving and until recently
there was nothing you could do about it
especially during the initial page load
but at all changes with the
serviceworker I was told that this slide
wasn't impactful enough I don't know
it's one of those management buzzwords I
don't really understand but I did give
it another go came up with this
apparently this has branding issues and
Scott loads of brands I don't understand
Bruce Lawson the deputy CTO of opera he
gave it a go as well he came up with
this but it's kind of free and if you
stare at it it almost looks like that
that the colors are changing and the
colors are changing it's got a filter on
it
but then Jeff who at the time worked at
Udacity he had to go and came up with
this for too long
users have been left staring at a white
screen
for too long they've been let down by
the cruel seas of network connectivity
and for too long we've been powerless to
help
we've been left waiting but no longer a
new browser feature has arrived
a total game changer
featured LRT you control the network
than letting the network control you
who is this new feature
what promises does it green
introducing
the serviceworker
it's a bit much isn't it really I prefer
mine it's got a Thai fighter with a
cat's head in it but what does this all
mean
what can serviceworker actually do we're
going to take a look at a mojo which is
a little progressive web app you can
find it at this URL but it's basically
like a simple version of hangouts so I
guess it's already out of date it should
be a lo that anyway it's like hangouts
but it only lets you enter emoji it's
died life as a mere website but over
time it was built up to become a fully
progressive web app and it didn't
require a full rewrite to do this it was
something that happened incrementally
bit by bit this here is this is v1 runs
at 60 frames a second it's really simple
so it's only it wasn't like 25k all in
so really fast to load unless of course
you're offline what I mean it's it's
fast but you know user experiences is
lacking somewhat at least this is what
it was like when I first launched it
here's how I fixed it to begin with I
registered for a serviceworker now this
isn't some magic manifest or a config
file it's just JavaScript because why
should we reinvent some new thing when
we have a world full of JavaScript
developers and loads of tooling already
out there oh but of course we should
wrap our register call in a basic
feature detect because I don't know
there are older browsers out there that
don't support serviceworker and a simple
feature detects them from hurting
themselves and others around you but
anyway in that script I'm just gonna put
a simple log for now so now if I load
the page and open Chrome's dev tools
console there it is cool also we have a
look in this new application tab there's
the serviceworker section and there's a
serviceworker in there as you can see it
was last modified in 1970 meaning this
serviceworker predates the internet
which is pretty cool that's a bug we're
going to fix that in a couple of days so
how has this actually changed things so
to find out we're going to pick the
original online-only site against our
shiny new serviceworker version to do
that let's go to the compare inator
right first up the online experience so
okay pretty much the same
both flowed reasonably quick I recorded
these with a throttled internet
connection or as most people in the
world call it their internet connection
also I did close the browser before
clicking the shortcut so that the low
time you're seeing that includes the
browser opening what about the offline
experience okay so - both of faylene now
you've probably noticed not much has
changed well nothing's changed okay one
thing happens it logged hello because
that's all we told it to do and that's
how serviceworker works it only does
what you tell it and that's great
because I'm sick of these magic api's
compare it to app cache if we gave them
oh joy an app cache manifest and that
manifest just contained the words cache
manifest which is required to make it
valid even online that would that would
turn the render of a mojo from this to
this and I can't help feeling that's not
what I told it to do app cache is a bit
of a disaster is that a very simple
format but a massive complicated
rulebook and if you didn't like any of
those rules tough you're restricted to
the way that the designers of app cache
wanted you to work and those designers
had not created many offline web
experiences so this whole thing kind of
gave rise to the extensible web
manifesto which most browser vendors are
now fully behind here we acknowledge
that browser developers and standards
developers are not better at building
websites than web developers and we
should stop tossing out scraps from our
ivory towers like app cache like CSS to
do reflection in one particular way and
instead we should give developers full
control give you as much information as
we can as many hooks as we can by
providing you with this kind of
low-level access you can create things
we didn't consider you can use patterns
we didn't invent and those become
evidence for us as well for higher-level
features so you can we can make the
common stuff easier or faster so Service
Worker was built to this model and so
the things I show you today are just the
kind of patterns that I have
but you'll find your own patterns
there'll be loads better than mine the
serviceworker is driven by events and
one of these is fetch so we've got a
listener for that there just with a
debugger statement so before I run that
I'm going to check this checkbox update
on reload I'll cover why in a little bit
but now if i refresh the page I'm going
to hit that breakpoint
so on the event object there it's got a
request property and that's this is
representing the request for the page
itself you can get the URL the headers
the type of request but I also get one
of these for every request that the page
makes so the CSS the JavaScript fonts
images I get the event for these avatar
images even though they're on another
origin so you get all of the requests so
by default requests go from the page to
the network and there's not a lot you
can do about it really but once you
introduce a serviceworker
it controls pages and requests go
through it but like other events you can
prevent the default and do your own
thing so instead of a triggering the
debugger I'm going to call this event
dot respond with and this is me telling
the serviceworker hey I'm actually going
to take control of this fetch and I'm
going to respond with a response
it says hello so let's give that a spin
I'm going to refresh the page and there
it is so instead of going to the network
the serviceworker just took care of it
so this example works offline
I mean it's rubbish but it does work
offline you don't have to respond to
every URL the same either you could pass
the URL so you can pick out the
component parts if the path name ends in
jpg you could respond with a network
fetch for a cat JPEG the vendo responder
if takes a response objects or a promise
that resolves with a response
fetch returns as a promise that for a
response from the network
so these compose together really really
well so now if we refresh the page it's
back but all the avatars are cats
instead of doing something special based
on requests we can do something based on
the response as well so here I'm going
to respond with a fetch for event
request this is telling the browser to
just do the thing it would have done
anyway but because it's a it's a
JavaScript API we can actually get all
of the response before we send it on to
the browser and we can take a look at it
so
or if the status is like four or four we
could respond with something else like
some SVG or whatever otherwise we'll
return the response we got from the
network so now if we refresh the page
the avatars are back but if I navigate
to some sort of nonsense URL we get the
404 message so serviceworker lets you
intercept requests and provide a
different response and you can do that
based on the request the response or the
response of a completely different
request you you could get you can do
what you want but this stuff is just
playing around really you probably
wouldn't use a serviceworker for a 404
page you let your server do that so
let's do something a bit more practical
a good way to dip your foot into the
serviceworker pool is to make an offline
fallback page something to show the user
if the page fails to load because the
current state of things is pretty bad
you know the user comes to us comes to
our site wanting content and this is our
moment to shine but without a connection
you know we crap ourselves to the extent
that ma'am our browser has to step in
and defend us and it does this by
blaming the user Chrome can't display
this page because your computer is not
connected to the Internet if we're going
to be competing with native this is like
an operating system error we can do
better than this so I created a custom
error page I mean it's still an error
but at least we're owning it this time
and it's something we can build on later
I want to show this when there's no
connection so you know it has to work
offline and I need somewhere to save it
and I need to do that up front when the
user does have a connection the
serviceworker has an event for this
install and I pass a promise to event
dot wait until to let it know how long
the installs taking and whether it works
or not the install event is fired when
the browser runs the serviceworker for
the first time it's your opportunity to
get everything you need from the network
you know CSS JavaScript HTML and stuff
for storing these requests and responses
there's a new storage API the cache API
this specializes and requests a response
storage but unlike the regular browser
cache stuff isn't removed at the
browser's whim so we put all of our
stuff in there
and once that's done the serviceworker
can start controlling pages so let's do
that
I'm going to open a cache and you can
call it whatever you want I'm going to
call it static v1 then we add the
offline page and the CSS it needs
so if the cash fails to open it runs out
of space all of these fetches fails or
returns a 404 the promise rejects and
that signals for the browser that the
install failed until that happens this
service work will be discarded it will
never control pages not that the both
the offline page in the CSS have a
version number in the URL this means we
can give them good HTTP caching headers
and we just changed the URL when we
change content you can actually work
around bad caching headers with
serviceworker but it's much better to
work with good caching so that's why I'm
doing here but now we need to use this
cache so over in the fetch event I'm
going to respond with a match in the
cache one that matches this request
matching has done similar to HTTP so it
matches on URL very headers method but
it ignores the freshness headers match
returns a promise for a response so if
we request the offline page directly or
its CSS is going to come straight from
the cache and that's great but if
there's no match found it results is
undefined so we need to deal with that
so if response is false see which
undefined is we're going to fetch the
responder request from the network if
fetch fails which it's going to do
offline the promise rejects so we'll
catch that and if the request was a
navigation will return the offline page
we only want to return this offline page
for navigations because it doesn't make
sense to return this HTML page in
response to a request for some
JavaScript or an image or something like
that but that's it we can now give the
page a refresh doesn't look like
anything's changed great but over in the
application tab there's this cache
storage section and we can see static v1
there it is
so if we simulate offline which we can
do in the serviceworker panel is a
little offline toggle layer you can also
do it in the network panel but now if i
refresh the page there we go there's the
offline page we can ship this this is
shippable and that's what the Guardian
did on that developer blog if you don't
have any connectivity it serves you this
custom sorry page but as a rather nice
touch it gives you this crossword that
you can do in the meantime which i think
is a really nice easter egg I'm not good
at crosswords actually I didn't even
look when I recorded this screencast
clue one across a Californian City three
letters nine letters
probably should've managed to get that
one of course we may want to make
changes to this in future add some
things like a refresh button or some
JavaScript which keeps checking for a
connection and to do that we need to
work with service workers update system
which we've been avoiding so far thanks
to this checkbox so let's take those
training wheels off say we want to
change this text here to be no
connectivity rather than no connection
just a simple change
well we change the HTML of course but we
need to update the service worker to the
URLs are generated from the files
content so we'll need to update that
we'll make the same change in our fetch
event so we're returning the correct
page from the cache I'm also going to
change the the version number of this
cache here from v1 to v2 and I'll show
you why in a moment but let's give that
a spin I'm going to reload the page to
pick up those changes and once again
we're going to change the network state
to offline and reload the page again but
you can see here that the text hasn't
changed it still says connection not
connectivity here's what happened we
reloaded the page which triggered the
browser to go and check the
serviceworker for updates it fetch the
serviceworker and went huh this one is
different to the one I have is quite
different and it spins that up as
version 2 running alongside the old
version the old one remains because that
you want isn't ready yet is it because
the new one has to go through its
install event so it gets everything it
needs from the network including this
the new offline page that we've changed
then puts them in the cache and this is
why we gave the cache a different name
so it wouldn't overwrite the stuff that
the version 1 was still using now by
default the new version waits it doesn't
take over while the old version is still
in use and that's because having
multiple tabs open to the same site
running different versions as a source
of some really nasty bugs that a lot of
a lot of us as web developers very
rarely cater for we could actually see
this happening in dev tools so here
we've got the the activated
serviceworker but below it there's a 1
there waiting to activate with a
different version number we can also see
in the cache storage static v2 will be
there as well
this new serviceworker will stay there
until the old one is no longer in use so
when this page like navigate
it's away or closes or whatever there's
nothing left to control now the old
version isn't needed anymore
it becomes well redundant and it goes
away
but that means the new version can move
in and start controlling pages we can
make that happen by navigating away I'm
still in offline mode just navigate to
about blank now I'm going to click back
and there we go that text has changed we
still have that all cache hanging around
though but we can deal with that once
the old service worker is gone the
service worker gets an activator vent
and we can use that to perform cleanup
because we know the old version is gone
now you can migrate databases delete
caches so I tend to have an array of all
the caches I expect to be there and then
I use the activate event to go through
all of the caches and delete the ones
that you know I don't expect to be there
is a slightly ugly piece of code it's
kind of a bit of boilerplate right now I
think it's one of those things that will
develop a higher-level API for pretty
soon this behavior of one service worker
waiting behind another that's the
default but it doesn't have to be that
way your new service worker called skip
waiting which means it doesn't want to
wait behind the older version when you
do this that just kicks the old version
out and it takes off a straightaway but
when you do this you need to be aware
that you're now controlling a page that
was loaded with some older version of
your service worker not necessarily the
last one some older version you can
track this from your page as well so
when you detect this happening you can
show a message to the user like refresh
for the new version or maybe you could
just trigger the page to refresh
automatically if if that's going to be
an OK user experience but for most of
development I really recommend this
update on reload thing this checkbox in
the Service Worker panel this changes
the update flow to speed things up with
update on reloads you hit refresh the
browser fetches the serviceworker from
the network it treats it as a new
version even if it hasn't actually
changed so it goes through an install
picks all the latest stuff up from your
server and then it puts them in a cache
and once that's done it kicks out the
old version moves in and then the page
refreshes and that's kind of a lot but
the product of this is you just hit
refresh and you get the latest
serviceworker in your latest assets on
every load ok that was a lot to take in
but how are we doing well to find out we
must return to the compare inator
right first up online okay so we haven't
really changed anything content is still
arriving in a reasonable amount of time
how about the offline experience we're
now taking responsibility for network
failures we're catching that error this
is something we can ship but we're not
quite a progressive web app yet because
we need to tell the browser that we're
ready to offer a native like experience
so in the head of your page you can
declare a theme color which chrome uses
to style the the location bar so that's
a quick win it kind of integrates with
the operating system a lot better we
want users to be able to add this to
their home screen there's a lot of ways
you could do this to cover all the
browsers you know you'll need to specify
an icon and icon probably another icon
did I mention the icon but most of this
meta crap isn't needed until the user
opts into adding the site to your home
screen and meanwhile it's being sent
down with every page increasing the time
to first render so we got rid of all
this and we replaced it with a single
reference to a manifest and that's only
downloaded when it's needed
it no longer clogs up the the load of
every page furthermore it was a great
time to standardize all that meta crap
the manifest looks like this and once
you have one and the serviceworker
chrome will start asking the user if
they want to add the site to their home
screen if the browser thinks they're
engaged enough with this site this icon
here comes from the icon field you can
specify many icons of different sizes
and chrome will pick the nearest one
that it wants to use here I'm just
serving one 512 by 512 icon and letting
chrome do the scaling you should serve
smaller icons if your large icon is a
big download but in this case the big
icon is 5k so I wasn't too fast the name
comes from the name property yet you see
how this works
if these are taps on add to homescreen
they get an icon on the home screen
we've already seen where the icon comes
from but this name here that comes from
the short name if your short name and
your name are the same you can omit the
short name it doesn't need to be there
later when the user launches your app
they get a splash screen and that's
displayed while the browser's are
spinning up and while the page hasn't
rendered this icon comes from the icon
set it will go for a bigger icon for the
splash screen the name comes from the
name
the background color comes from
background color and the color of the
statusbar here that's from the theme
color then once the page is ready the
splash screen goes away and the page
lights loaded is this one listed in
start URL so it doesn't have to be the
same page that the user was on when they
added to homescreen
but you'll also notice that the URL bar
isn't there and that's because the web
app has its display standalone and all
this adds together to make the whole
experience feel like a native app and
that's why it becomes so important that
we at the very least own our connection
errors because we don't want the default
browser error breaking this this native
feel once again this is something we can
ship it's an incremental improvement
when developing offline capable sites
it's a common error to start iterating
on this for example make it show cached
messages make it a full of offline
experience but that's an online first
approach that works fine when the user
is truly offline but zero connectivity
is not the worst thing we face this is I
call it life I this is when your phone
says it has connectivity but it doesn't
if you have Wi-Fi and you ask for
content the web says well and that's it
this is worse than offline with offline
you get a quick answer it's no but it's
an answer but here you're just left
waiting and I'm sure you've had this
before yourselves like you don't want to
give up you keep thinking well maybe if
I just wait a few seconds a few more
seconds the page will arrive but does it
know
you're forcing the user to stare at this
or give up and with every passing second
they hate the experience a little bit
more our current offline first pattern
online first pattern works great when
the user has a good connection they get
the latest messages pretty fast it's
great when users offline because they
get some you know cash data or a failure
page but with life I that's it
chrome removes the splash screen when
the page gets the first render and with
life ID that never happens so we've
improved things for offline users but
life I users are in the same hell as
they were before this is the problem
with online first we're giving users
with some connectivity a worse
experience than those with no
connectivity and this isn't always just
down to the poor connectivity on the
user's device I don't know if you've had
this before but I get it all the time
my phone's reporting full signal but I
cannot get a bite down at all a lot
happens to get data from the web you
know the phone sends a request off to
the Wi-Fi router or the cell tower then
on to the ISP through intermediate
proxies you know potentially across to
the other sides of the world and
eventually the request reaches the
destination server but that's only half
the journey because the server responds
and the response has to go all the way
back across the world through proxies
through ISPs over the air and land safe
and sound hopefully on your phone but if
something along the way goes wrong or
run slowly the whole thing runs slow and
therein lies life I and you don't know
how good the network connection is until
you give it a go until you try it
and that takes time there are a couple
of api's on the web that attempt to
predict the network such as that's
interesting there's supposed to be a
slide there
this isn't part of the Act by the way
this is just some fun oh yeah
life I know this entire presentation
works offline
maybe I'll unplug it and plug it back in
again do we have a dodgy connection here
don't present for that I do want to
present for my own laptop how are we for
the oh my god it's starting to work this
is amazing
so my colleagues always tell me I'm
stupid for doing my own slide framework
there we go let's see if this continues
to work oh my god it's working again yes
okay here we go where was I okay so
there are a couple of api's on the web
that attempt to predict the network and
these are things like navigated online
another get a dock connection type but
these are weak signals those API is they
only know about that bit they don't know
about any of the rest
for instance when navigated online is is
false you have no connection that much
is certain
when Navigator online is true you have
not no connection
navigator online is true when you're
connected to a cell tower or a Rooter
though that router may only be plugged
into some soil navigator online will
still be true anything after that first
hop cannot be predicted you have to make
a connection and see and that takes time
if the user wanted to come to our chap
and look at pass messages why should
they need a connection for that why
should you use I have to wait for a
connection to fail just to see stuff
that's already on their phone the great
thing about local data is you don't need
to make an internet connection for it
this is why the gold standard is offline
first offline first solves these
problems with offline first we get stuff
from the cache first and then we try and
get content from the network and the
more you get surrender without a
connection the better you should think
of the network as a piece of progressive
enhancement an enhancement that might
not be there so we to rethink our
approach a bit here I'm going to create
an application shell and that's just the
site without messages we'll leave it to
the JavaScript to populate it so I'm
going to change the install event so it
caches the the app shell
the CSS and the JavaScript meanwhile
over in our fetch event we're going to
start by parsing the URL so we can read
its component parts and then if the
request is to the same origin as the
serviceworker and the path name is just
slash so it's the root page we're going
to respond with the app shell from the
cache done otherwise we'll try and
respond with cached content and fallback
to the network so all together we're
going to fetch the HTML CSS and
JavaScript from the cache and that gets
us a first render and then the page is
JavaScript that's going to go off to the
network and get the messages for us
which gets our content render going if
that fails the JavaScript can show some
kind of connection error message as well
so by doing all that what do we win it
is time to return to the compare inator
what I enjoyed that jingle the first
time but it's feeling like diminishing
returns now anyway how are we doing the
online experience look at that we've
massively improved the render time by
going getting the first render without
the network and the messages are still
coming from the same throttled network
connection but they get on screen faster
because the download starts much earlier
what about offline great the app shell
loaded and the pages JavaScript showed
the no connection error but what about
life.i so you know we've defeated the
blank screen at least I mean our
JavaScript could do better here could
show a spinner or something but things
are looking loads better you can see the
benefits of offline first versus online
first rather than improving things for
one connection type we've improved
things across the board we're back in
control of the user experience it's
taking this very little code to get
there we can ship this what about
caching chat messages so we can display
those before connectivity - aside from
the initial page load messages arrive
one by one this continual feed of data
doesn't really map well to the cache API
which is request in response based
instead we want a store that we can add
and remove messages from the web
platform has such a thing it is called
index DB index DB has a bit of a bad
reputation among developers thinks fair
to say but that's only because it's the
worst API ever designed in the history
of computer science
other than that's pretty good but
seriously 60% of the oil comes from this
weird event system it uses because it it
predates promises if it was invented
today it would use promises and there is
an effort underway to patch it up as
best we can without breaking
compatibility
I much prefer teaching the web platform
rather than libraries of frameworks but
I am going to make an exception here IDB
is a little library that I flew together
that mirrors the indexdb API but it uses
promises where IDB should have used
promises other than that you're still
using IDB all the same method names and
everything just with 60% of the awful
eliminated it's 1.2 K so it's really
small there are bigger higher level
api's out there which you maybe want to
consider things like Dex e pouch DB this
library only eliminates the very worst
of ID V but let's use it let's create a
database for our messages the messages
look like this they're in JSON format so
here's how we build a database for it
I'm going to start by opening the
database giving it a name
ammo joint version number one and then
we get a callback to define the schemer
of the database so we need someone to
actually store the messages relational
databases call these tables idv calls
them object stores created one called
messages and I'm going to tell it the
primary key is ID
we're often going to look at messages in
day order so I'm going to create an
index for that called by date and that's
it not too painful now I can take this
DB promise and add messages to it as
they arrive so say we had a function
like this that gets called every time a
new message arrives and it's added to
the page we get our database from the
promised create a read write transaction
on the messages store and then add it I
don't expect you to remember all this
code I'm just trying to I guess trying
to convince you that index TV can be a
little bit less scary when you involve
promises getting messages not too bad
either transaction go to the object
store get the index where everythings
date ordered get them all done of course
we can't just keep adding messages to
the database we need to perform some
cleanup at one point say we wanted to
delete everything but the newest 30
messages I'm going to create a
transaction get the date index I'm going
to open a cursor so I can go through
them one by one the previa means we're
going to go through the index backwards
starting with the newest message I'm
going to advance past the first fuzzy we
want to keep those
I'm going to loop through the rest
calling delete on each one okay so this
code example isn't quite as pretty as
the others like I say the library only
adds promises in you're still exposed to
the rest of ID B's ugliness but this is
loads cleaner than it is with just
straightforward ID be I think a database
full of messages means we can fetch the
the app shell the JavaScript the CSS
from the cache that gets us a first
render but then we can render with
messages from the database as well we
get content on the screen without going
to the network and then we go to the
network for newer messages and avatars
we can update the page so if this
network request fails that's not a big
deal you know we're still displaying
content that's pretty good it's a great
offline experience if the network
request is slow yes that's ok as well if
the users just coming back to check past
messages that's fine to see the benefits
of this we must once again gaze upon the
compare inator right okay
the off online experience check out that
performance difference you know that's
huge what about the offline experience
we get content and we get it quickly ok
the avatars have failed we'll deal with
that in a moment but this is loads
better this is way better than the sorry
message we had before how about the life
I experience we've gone from the most
frustrating experience in the world the
white screen of eternal misery to
instant content we can ship this the
only thing missing in terms of a full
off lining first experience is the
avatars but yeah we can fix that here's
our current fetch code just like we
wrote before we want to do something
special for the avatars so let's rewind
a bit if the request is to Gravatar
which is where I'm getting the avatars
from I'm going to call out into another
function create a handle avatar request
otherwise we'll just carry on doing what
we were doing before so what does handle
avatar requests do well we could fetch
the avatar from the network and if that
fails we could serve some kind of
default from the cache and we catch that
as part of the install event that's cool
we can ship that it's good enough but
later we could do something even better
when we get the request for the avatar
we can try and get it from the cache and
if we get a response
send it back to the page that gives us
the Avatar without going to the network
but we should go to the network to not
only in the case that we didn't have
something in the cache but also to
update the one that is in the cache if
there is one because you know users
change their avatars a lot showing an
old avatar is great that's fine but we
should update it for next time so off to
the network we go and if we get a
response back we put it in the cache and
that's how it's done unless we were
unable to give an avatar to the page
from the cache in which case we'll send
them the one from the network and that's
done this is what HTTP calls stale while
revalidate is one of the cache control
options it's an experimental feature in
chrome right now we're busy implementing
it's behind a flag but we don't need to
wait for it to ship we can emulate it
inside the serviceworker people can have
it today thankfully the code for this is
actually I think is a lot simpler than
trying to describe it with a diagram
we're going to start by making a network
request because we always want to do
that sometimes just to update the cache
sometimes just send back to the page as
well we just wait until to say hey we're
going to do some additional work as well
as providing a response edit here we're
going to take the the response that we
get from the network we're going to
clone it and the reason we clone it is
because a response can only be read once
the body of the response can only be
read once and this is how the browser
works this is how you can receive like a
free gigabyte video and watch it but
that free gigabytes never needs to be on
disk all at once it's need to be memory
all at once we're going to clone it
because we might use it twice we're
going to send it back to the page and
we're going to put it in the cache I'm
going to open the cache called avatars
unlike our static cache we're going to
preserve this one between versions we're
not going to change the version number
and then put the Avatar in the cache
meanwhile going to return the response
from the cache and if the cache doesn't
have one we're going to fall back to the
the network one and that's it I mean
sooner or later you're going to have to
write some code to go into the cache and
look for avatars you don't need anymore
and delete them but but this helps a lot
so to see how this affects things for
the final time I promise we approach the
compare inator
right first up the online experience
quick full content the offline
experience quick full content what about
life I once again quick full content in
fact the experience is the same thank
you the experience is the same with
every connection type the network only
matters when it comes to fetching new
content we can ship this so we've
achieved Network resilience right well
we're doing great when it comes to
sending data to the user but not as
great when it comes to the user sending
data to us I really hate this because
for me that the users transaction is
complete they have said here are some
smiley faces please send them to people
done that's all they have to say about
it but no we're requiring them to watch
it through to completion we can do
better than this background sync landed
in chrome a couple of months ago it's a
serviceworker event that you request
you're asking to do some work when the
user has a connection which is straight
away if they already have a connection
or some time later when they do so say
we had a function that was called
whenever the user typed a message and
hit Send so we'll add a message to the
outbox using ID B or whatever this is a
function we drive ourselves but then
we'd get the serviceworker registration
and register for a sync event giving it
whatever name we want that can fail of
course if the browser doesn't support it
or the users disabled it or whatever so
in which case we'll catch it and just
send the message normally where the user
has to stare at their phone otherwise
over in the serviceworker we get this
sync event and we can check the tag name
so we know what we're supposed to be
doing here we'll use our old friend wait
until to let the browser know how long
we're going to be doing work for so then
we get messages from the outbox from idv
or whatever and send them to the server
and remove them from the outbox
the effect of this is the user can be on
life I or totally offline but they can
use the app as if it were entirely
online when they sent the message so I
rip do here I'm just going straight to
airplane mode so it's a completely
offline and now I can type some sort of
message
I know some pictures of some cats and as
soon as I hit Send we can add it to the
flow even though they have no connection
it does say sending they're in tiny
letters but it doesn't have a lot of
emphasis because the user is free to
lock their phone and go about their day
they can even close the browser if they
want it doesn't matter then at some
point later when they regain
connectivity the message will be sent in
the background there it goes and user
didn't know that this happened you know
didn't know that I was sent in the
background because from their point of
view their transaction was complete you
know they'd already said please send
this the time they get to know about it
is when they receive a push notification
with a reply from another user by using
background sync and push messaging we
get out of the users way they don't have
to stare at the screen while stuff sends
they don't have to check for new
messages we tell them about that all of
this massively improves the user
experience and if you do this sort of
stuff I think it's totally cool to you
know brag about it this is something the
the i/o web app does so caching complete
this now works offline I think this is
great but I do hope that it goes out of
fashion
I remember those little site badges that
we all used to use it said Lake this
site was built using CSS 2 and now when
you see them you're like what and CSS
well done you and I hope one day this
will seem as ridiculous
but before that we do need to build up
user trust I don't know if anyone's seen
something like this before
this is what I'm greeted with in the
bathroom on board the trains I commute
to work in first you have to press D to
close the door and then you press L when
it's flashing to lock the door
not this Braille layer as well so even
blind people know they have to wait for
the flashing light but the buttons
aren't proper buttons either the kind of
flat touch sensitive things there s
horrible I don't trust this I don't
trust this because once it failed on me
and I was slowly revealed to the
carriage like a bad game show prize
similarly users don't trust the web to
work offline because it's failed them
before so messages like this do help and
yes all epiphanies I've had about user
experience happened
bathrooms but this is why chrome
requires it to be a serviceworker there
went before it will show the add to
homescreen banner and in future we're
going to tighten the rules there to try
and detect some kind of offline capable
experience we want everything that ends
up on the home screen to be competitive
with native apps we want to make the web
a first-class part of the operating
system in the users mind so on that note
I want to compare the launching of a
native app Google Photos quite a well
built and well optimized one to ammo joy
and launch them at the same time oh it's
really close like ammo joy is like noir
point two seconds slower to show content
at 200 milliseconds it's almost nothing
and that's a well-built native app and
but that's also starting from cold the
browser not in memory at all if the user
had looked at the browser at some point
recently and let's face it the browser
fairly popular app so that's quite
likely this happens this is a
progressive web app
that's beating a native app to content
render by almost half a second that is
the power of serviceworker and the power
of offline first and achieving that
wasn't a matter of rebuilding the entire
app it was incremental improving the
experience at every step for everyone
things get faster for users with decent
connections things stop being
frustrating for users with life I and
things become possible for users that
are offline a few people today asked me
about Android instant apps and what that
means for the web well progressive apps
are possible today one app across
thousands of devices operating systems
and browsers already beating a
pre-installed native app to render
service worker is in the stable versions
of Chrome Firefox and opera right now
and it's a high priority implementation
for Microsoft edge it's under
consideration by Apple but progressive
enhancement means you can use it today
as we've seen people talking about on
the stage earlier and if you use
serviceworker and sites will only become
way faster in Chrome and Firefox than
Safari that will give Apple more reason
to implement serviceworker as web
developers you're in the position of
power here you get to guide the future
of the extensible web service worker
letters create great user experiences
but becoming faster network resilient to
polyfill a new network features and I
know I've gone through a lot of stuff
for lightning speed but there is a free
Udacity course which is fully
interactive where you take a website
from online-only to fully offline first
covering everything I've spoken about in
more detail and more don't worry about
remembering the URL just Google for
Udacity offline it shows up but with
that it's been another pleasure thank
you very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>