<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Write-once, run WebRTC anywhere with React Native (Kranky Geek WebRTC 2016) | Coder Coacher - Coaching Coders</title><meta content="Write-once, run WebRTC anywhere with React Native (Kranky Geek WebRTC 2016) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Write-once, run WebRTC anywhere with React Native (Kranky Geek WebRTC 2016)</b></h2><h5 class="post__date">2016-11-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/OT6kwzsQeVc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone so indeed if you've seen as
in previous RTC talks on the RTC
conference chat then you've likely heard
us praise the merits of video routing
against media mixing or how the benefits
of Si fuse are so great compared to MC
use one thing strangely enough that we
don't talk don't talk enough about is
the other side of all this it's another
component of our ecosystem that is just
as important and that's our video coin
GT meat so jitsi meat is a mature
conferencing video client that connects
and uses the GT video bridge and people
use it for a bunch of things meetings
one once global hands and all staffs
it's again a very rich application it
misses one thing though or it did it
until recently as Chad pointed out at
the beginning of the session Rio starts
counter you've probably all seen this
had this stat about in October for the
first time ever more people connecting
to the internet through mobile devices
than they did through their desktops and
that kind of puts things in perspective
makes you want to do I have the high
priorities well we certainly did have
mobile as a priority and we were
thinking about it in a way that many of
you are let's let's get a little bit
into that so of jitsu mean if you look a
little bit too deeply a little bit
deeply into it is two main components
one is the user interface that you use
and see and the other is everything that
happens under the hood hood XMPP session
management handling peer connections
merging SDP so you have simulcast
participant joining and leaving all of
that is what we call Lipschitz elite so
in our community these two projects have
stabilized at around 20,000 lines of
code obviously your mileage may vary but
just keep those numbers in mind as a
reference so when it comes to mobile
again we were thinking of just doing
everything the way that everyone else is
doing it so we thought you know what
well we'll just take the WebRTC stack
and wrap it in some Java and we'll have
an Android application and then we'll
just do the same with objective-c and
we'll have an iOS application and
everything will be just beachy or so we
thought
and then we started and we started with
a Java prototype application for GT me
we were at about 10% of feature parity
we hadn't even gotten into all of the
battery savings and native encoders none
of that and we were already at 19,000
lines of code which is half the code
that we already had for that stuff and
then Comcast tried and did a similar
thing a similar exercise for iOS they
were a little bit more mature like
there's about 15 percent parity and
still almost had 20 thousand lines of
code at that early stage so that was
disheartening because basically it meant
that either we have to split our team in
three and completely destroy our
development pace and basically don't do
almost anything new for a number of
years or we had to go to a lasting
management and beg for triplicate in our
team and hope that we don't get laughed
out of the room so we started looking at
other alternatives and one thing that
really very quickly started looking
promising was the whole ecosystem of
react and that's really great so how
many people here are familiar with react
about half so for those of you who know
react you you probably already know that
one of the most characteristic ways of
things about it is the fact that you're
manipulating this virtual Dom you're not
actually touching the HTML that goes
into the browser you manipulate a tree
that's only used by react itself and
then you have react that's responsible
for translating that tree into something
that the browser can render now when you
look at that diagram and obviously
everyone's thinking well if I have such
a separation I could probably just you
know replace this thing with something
else like like a mobile interface and
it's not such an original idea and
actually the react community went along
and did exactly that so this is how
react native was born the concept of
react native is that you write your user
interface in JavaScript in a virtual DOM
and
that is rendered into native components
native views on Android and on iOS now
we get to the interesting point this
whole thing about writing the user
interface in JavaScript is obviously
great but the really great thing about
react is that you actually get to use a
full-blown JavaScript engine with great
native integration this is really where
react stands out and keep in mind that
this is not a Cordova webview style
browser this is just a JavaScript engine
so you have JavaScript and that's about
it by default you don't have things like
WebRTC so we're thinking well what good
is that well this is where web I'm sorry
react native components react react
native modules come in a react native
modules are a way that react gives you
to use native functionality on different
devices things like I would like to make
my phone vibrate or I'd like to do an
alert or I'd like to get some
geolocation information this happens to
react native modules most importantly
while most of them are provided by
Facebook themselves there's a bunch out
there that are provided by the community
and specifically react native web RTC a
project of high road yang is something
that gives you all the favorite objects
and functions that you need in order to
build react native applications peer
connections media streams media stream
tracks all of this is available with
this react native web RTC module so this
is pretty big
we took react native WebRTC we plugged
it into react native it took a little
bit of pushing and shoving and a lot of
PR ring back to react native web RTC but
eventually we got it to work with jitsi
meet Lib we added a thin UI layer on top
of all this and we had it we had an
application that was using exactly the
same code to run on desktop Android and
iOS and that was pretty big for us so we
were quickly feeling very very
optimistic
yeah and this gray stuff was wasn't
surprising at all like because we were
harnessing the power of multiple potent
technologies but truth be told those are
young technologies so you kind of expect
to bump and deepen to the road that's
what we did when we actually ran our
application on mobile there were
problems so let's just give you fair
warning zhan different topics now what
you can expect one thing on our desktop
that we do is we take great advantage of
peer connections Weber's statistics we
use them in multiple ways probably do as
well you get the classic one where you
just submit them to coast at sea or you
process them like locally and do things
like we do without do levels so in our
UI we examine the statistics that
whoever to see gives us this is
information that receives over the
network and whoever to see collects it
and then from time to time we can go and
ask about it that's what we do allow do
levels and we Paul peer connection stats
now we've introduced you to this world
of react native and a very big piece of
it is the part that connects the
JavaScript world with a native world and
it's called native to JavaScript bridge
so when from our JavaScript source code
we Cohen code or the method that we know
get starts we wanted to ended up in the
native whoever to see implementation
that's gonna go for this bridge and we
saw that this audio levels were pretty
slow that's wasn't for profiling and the
profiling
reviewed it well it's the native to
JavaScript bridge there is inherent to
react native that was the bottleneck few
details so where were these stats are
big object especially for us because we
have like multiple participants we are
supporting conferences so we can have
like 10 20 people really unlimited
number so this object gets pretty big
and we have to walk it because it's like
a tree of objects and convert it into
structures that react native knows then
it's going to drive this known structure
to the JavaScript side and give us a
JavaScript object and we discovered it
it in the case of such big native
objects it's actually better to just go
and walk them and build a very long
string a JSON string have this single
object passed through the bridge then
even go and do in here JavaScript
json.parse and still get better results
like five times better so if you decide
to go this way give this idea in mind
while looking at a peer connection we
discovered though we were looking at
react natives problem we identified or
kind of surprised to find it in whoever
to see itself there is a inconsistency
it's slightly mentioned in the source
code as a legacy thing so in the web
specification for whoever to see some of
the statistics are numbers which is
natural like bytes sent or received you
you wouldn't think about them in strings
but in the Java and objective-c API will
get is a key value of thing with strings
on both sides we're kind of safe because
javascript is readily gonna step in and
do good conversion when we consume these
data from strings to numbers but people
list some of the JavaScript community
frown upon it because it's an implicit
coercion of types so qubit in mind in
case there's some unexplained problems a
big disadvantage I would save react
native is that displeasure I described
it's
serializing but most importantly a
synchronous so your communication
between JavaScript and nativism
synchronous and naturally you can't just
return a simple return value from your
native code to the JavaScript so it's a
it seems that the way it was implemented
is kind of a step back because the
JavaScript community made a lot of
strides who solve their callback hell
they introduced promises such but react
native is gonna light those fires a bit
back it's going to contain them in the
native modules so your JavaScript source
code you can still go and do a model
thing with promises so this one was
mentioned but I would like to like
stress it a bit so in react knee it
react the react all that like half of
the people here expressed and they know
it you describe a tree like a HTML tree
it's not really HTML but let's say that
and in the react native when you
transfer this idea it's gonna be a tree
of views so you're kind of free to do a
broad or deep tree of views and you can
have your videos that you're rendering
with other people in your video call if
you have like us multiples you can place
them on different and notes in this tree
so for example the one who speaking
could be kind tree and the ones who
our remote participants could be lower
in the tree so day they appear in front
of the guy who's talking has multum
nails and when we're trying to support
this thing in a third party modules such
as react native ever to see where we're
contributing we kind of try to be
generic there but you we have to
remember that even though we are free to
put our reviews however we want
generally on Android they're just three
layers in which you can place video like
one is behind the application which cuts
a hole in the application you just have
an open GL surface and under knows about
oh I know about a second layer when you
Ching can put above this and then you
get a top layer on which you can put
stuff but they're gonna either be behind
your UI or in front of it so if you want
to provide some decorations it's gonna
be difficult and again because we use
react native and we want to bridge
between JavaScript and native we have to
do some interesting and advanced stuff
with collections that's where it is
covered another weak point of WebRTC and
that some WebRTC goes and creates
multiple objective-c instances for one
and the same underlying media streamer
media stream tract instance and because
they don't have value equality like
there's no recourse or hash you kind of
can't go and simply use them in
collections and expect the right
behavior because it's nowhere in the
public documentation and biggest problem
for us was of course that we just lost
apples popular associated objects port
we feel that this is a
that's more easily solved in WebRTC
itself because in the case of
third-party developers like us we have
to add much more complicated logic in
order to deal with this problem and we'd
like to alert you that when you go and
use the simples plus API at the Java API
or the objective-c API you're kind of
choosing three different things there
are inconsistencies with between them
which may force you to as cross-platform
developers you would have one problem
but you wanna have an go and solve it in
two ways that's what we did because
datachannel
was missing an idea and the java api but
it was it's we all know it's available
in C++ ABI and it's in objective-c
thankfully at the beginning of this
month it was added with Jarvis kind of
everything school again
but there may be other inconsistence
before you like go and choose it okay
I'm gonna do this thing on the Platinum
no two platforms in one single way maybe
go and check whether it's supporting the
two different ideas and as I mentioned
we wanna be cross-platform not only on
mobile with cell phone two platforms
owned by but we want to have the same
code on JavaScript it's a little bit of
detail that needs to be mentioned so
these objects in react native that we
have on the native side you know whoever
two-seam they're gonna be managed
automatically by reverence counting
garbage collection whatever but since
we're representing them as JavaScript
objects kind of have to force our
developers to actually go and explicitly
release some of them like the media
streams in the media stream tax
especially those that come from
getusermedia
I'm just the last pieces inconsistencies
between the native and the Web API so in
the on the web side were kind of used by
having a set of constraints where you
just tell strings to the web to the web
or to co-pilot we want oh this whole set
of constraints and one of them is gonna
be the optional video concentrate facing
mode but strangely enough like on the
native you get supports for some of the
elements of this set but others like
facing what you just have to go and find
specific classes that are dedicated to
the purpose and specifically we have to
go and call specific methods so it's
sort of one of the same thing everywhere
right so all of this may sound like a
lot but you really shouldn't worry about
it for two main reasons the first one is
that we've already solved it in
Lipschitz you meet so if you wanted to
use the same thing you could get C's
open source I didn't mention that but I
expect people know it and then the
second one is that we have to put in
perspective what we're trying to achieve
here what we got out of this is an
application very quickly that for the
most part runs the same code on all the
target operating systems that we're that
we want to run on and let's go back to
where we wanted to talk to where we
started from the lower layers of jitsi
meet legitimate we've been able to
achieve 100% reusability across all
platforms there's still a little bit of
work to do on the UI layer we're
currently running with more about
specific user interface but still it's
one it's 90% shared code between iOS and
Android which is already quite an
achievement and we have an objective to
make it to make the same ratio apply for
desktop as well we hold that we achieve
it we're not there yet but we're
certainly at a place where we can
already highly recommend react native if
you have a web RTC project that
currently all
on the web or you're planning to start a
new one then you should definitely
consider react native is one of the
first options for mobile development
thanks very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>