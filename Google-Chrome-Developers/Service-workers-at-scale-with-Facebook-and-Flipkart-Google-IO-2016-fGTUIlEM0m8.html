<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Service workers at scale with Facebook and Flipkart - Google I/O 2016 | Coder Coacher - Coaching Coders</title><meta content="Service workers at scale with Facebook and Flipkart - Google I/O 2016 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Service workers at scale with Facebook and Flipkart - Google I/O 2016</b></h2><h5 class="post__date">2016-05-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fGTUIlEM0m8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi welcome back my name is Owen and I'm
a product manager on the chrome team I
focus on making sure that all the
browser's provide you all of the
capabilities that you need to be
successful on the web so I'm thrilled to
be here today
joined by addy chip and Johnny from
Flipkart who worked on the amazing
Flipkart light progressive web app and
by Nature loss from Facebook who worked
on their service worker based pushing
avocation implementation and is now
working on rolling out more Service
Worker features across the site so our
goal here today is to make sure that you
leave with all the knowledge that you
need in order to bring service workers
into production at scale and to start
I'm going to quickly recap on how
service workers can be used to solve a
number of key use cases on the web so
the first is caching with service
workers so service workers give you full
programmatic control of the network and
if you're caching there are kind of
event-based web worker and the way it
works is when a user first goes to your
site what happens is a service worker
can be downloaded by the browser and
stored on the device and then whenever
any network request is made by your app
like an ajax request or you include some
kind of image the first thing is that an
event is fired into this service worker
that essentially allows it to intercept
that request and handle it
programmatically it can do this by
forwarding it onto a web server or by
reading from a cash or by generating a
response entirely and so these allow you
to build an experience that's responsive
and reliable regardless of the network
conditions
so next synchronizing with a service
worker so service worker has this great
capability called background sync which
means that if a user takes an action in
your app whether they're on a flaky
network or completely offline you can be
sure that that action will make it up to
the server and so the way this works is
when a user for example writes a post or
takes an action that generates an
analytics event which here is
represented as the blue dot even when
the web server is not available you can
make that network request the service
worker receives the request intercepts
it and sees that there's no web server
available it can now register for an
unsinkable which will be fired the next
time the device connects to the internet
so now the user can navigate away from
the page they can close it they can be
doing something else on their phone and
the service worker can go to sleep so
now nothing is running but then at the
point where the internet connection
comes back the operating system will
notice it let the web browser know the
web browser can wake up the service
worker and fire the on sync event this
allows the service worker to run and you
to synchronize your data up to the
server reliably and in the background
and finally push notifications with
service workers and so this starts by
you tell your service worker to
subscribe to a push server the push
server will generate an endpoint and
some encryption keys the endpoint is
kind of like a magic URL that if your
back-end sends a request to it it will
trigger a event to be fired on the
user's client in the Service Worker and
so the push server generates this
endpoint and the encryption keys and
passes it to your service worker then
you send those up to your web server at
this point the user can navigate away
chrome can be closed they can be doing
something else on their phone and then
when you have a notification on your
server that you want to send to the user
you simply encrypt it with the user with
the keys that were given to you and you
make a request to that endpoint that
will pass the data the encrypted data
over to the push server which will in
turn wake up the device and send an
event into your serviceworker running in
the background the serviceworker
then receives this decrypted payload
down from the web server and can use the
notifications API in order to show that
notification to the user and so together
serviceworker allows you to build
advanced caching that makes your website
fast and reliable regardless of the
network condition allows you to build
offline and background synchronization
and it allows you to send your users
push notifications and so together with
these capabilities you can build a
really great experience and so we added
one more thing to it which is add to
homescreen so by providing just a small
Jason manifest with some metadata about
your app icons and its name
you're able to show a banner to your
users asking them if they want to add
the progressive web app to their home
screen and if they click it then they
get an icon on the home screen just like
any native app and together sites that
use these rich serviceworker
capabilities and Add to Home screen we
call progressive Web Apps and so the
world today looks something like this
you have this array of ingredients that
you know can be combined together to
build something to create something
amazing and you might have even cooked
up a little something at home and got a
taste of it and you think it's great but
it turns out that as Rahul mentioned in
the in the keynote yesterday about the
mobile web service workers are now
handling over 13 billion page loads a
day and the responsible for delivering
over 10 billion push notifications every
day and so suddenly you're not just
cooking for yourself you're cooking for
a pretty large group of houseguests and
so that's why I'm thrilled that we have
here today two of the world's master
chefs in serviceworker cooking and so
i'd like to invite up to the stage a
teacher from Flipkart to tell you more
it's great to be here my name is Aditya
and I work for Flipkart which is one of
the largest e-commerce retailers in
India now in India if I can get my slide
to change all right
Mobile is profoundly important and it's
at the crux of everything we do at
Flipkart we continuously strive to build
really compelling and delightful mobile
user experiences and in that regard
early last year we actually shut down a
mobile website and directed our users to
download the native app which we believe
give a far more superior experience than
the mobile web that back then at the
same time we actually asked ourselves
what is it that gives native apps an
edge over the mobile web especially
given the unique properties of mobile
web such as an always updated
distribution and an frictionless you
know instant load
we are into five three core areas and
that is high performance an immersive
experience and the ability to re-engage
our users let's look at high performance
there was a common feedback among users
the by native apps somehow fell faster
than the mobile web back then what they
really meant was that the native apps
had a reliable and consistent
performance independent of the network
conditions or the type of device profile
they had Network mobile networks have a
lot of variations to it you know you
have things like the time of the day
your location or the number of
concurrent users all of these factors
can affect the quality of a network take
for example when you have a low signal
you have to chose that I do have an
internet connection in minute reality I
don't or what happens if your internet
stops working and it's just decided to
reconnect at some point or if you
totally lose your signal at all in all
these cases the native apps seem to end
or the network conditions and open up
reliably even so on the web we have
actually lacked the model to build web
apps that can end your flaky networks
native apps however do this at a very
high cost on a 2g connection it can take
several minutes for a user to install
node and install the native app compare
that to the different ways of building
web app at Flipkart even with
server-side rendering or a client-side
single page app it takes several seconds
before anything meaningful is painted
for the first user on repeat visits
native apps have a significant advantage
on the first visit they have managed to
package and download the entire set of
critical resources required for instant
load the next time we wanted to bring
this instant load model to the web and
the way we do that is with the actual
architecture the actual architecture is
in many ways an evolution of the
traditional u server-side rendering or
the isomorphic or Universal as we call
it but it has key differences to it
which I'll get to in a minute for us the
option architecture meant breaking down
an entire application into two States a
loading state and
instead the loading state is essentially
what the app shell is it's a HTML
structure which has placeholders and
acts as a host for the dynamic content
to come fill in a well-designed
action would give visual cues to the
user of what to expect as the data loads
in progressively this will enhance his
perception of speed now with app shells
you throw service workers to the mix and
you can cache this options on the first
visit and on the second load you have
instant load performance now a lot of
you may argue that you could do this
with other technologies such as app
cache what's so special about service
workers well for us serviceworker is a
highly programmable low-level primitive
what that means is there is no magic
everything is left up to us as
developers to design the solutions and
with that we could actually device very
sophisticated cache policies that could
never be done before the last important
bit is that the serviceworker acts as a
networked proxy layer in your browser
what that means is that our application
can be completely indifferent if whether
a serviceworker
exists or not and just function with or
without it the impact of this was
immense even on a 2g connection we
brought down the load times to a few m/s
times for serviceworker cache so now on
a repeat visit with serviceworker and
the actual architecture we have a
comparable load time to the native apps
and it's not just blazing fast it's even
reliable on flaky networks this is what
we believe is the offline first pattern
which is you respond to all the critical
resources from the offline cache first
and go only to the network for dynamic
content that cannot be otherwise cache
this allows us to build really reliable
and network resilient web apps all right
so let's compare the option architecture
to the traditional way of doing
server-side rendering now server-side
rendering is a recommended approach to
improve first paint but we get the same
benefits for the actual architecture
because in both cases we are executing
JavaScript on the server
and generating HTML for a quick first
print the interesting thing about the
optional architecture is that the app
shells are just static HTML pages that
means they have no dynamic elements to
it which means they could be generated
during your build time so you can
offload all the heavy lifting to your
build process rather than on the
server-side rendering where you have to
process and generated per request again
being static they can be easily cache on
the client-side which may be tricky to
do with the server-side generate HTML
pages because they have dynamic elements
to it so you might end up with stale
content which in e-commerce is
unacceptable the best part about app
shell is a single app shell can be
reused across millions of URLs at the
same time at Flipkart we have a catalog
of over 30 million products that means
30 million unique product page URLs but
we can share the same product page
option across all these product page
URLs the last part is SEO a lot of users
do server-side rendering to solve for
SEO but with experiments at Flipkart we
have managed to achieve the same
benefits of SEO with the actual
architecture there were many challenges
that we faced throughout this whole
journey but one of the biggest challenge
was maintaining and scaling the
handcrafted serviceworker code we wrote
as more team members collaborated on the
same file and I use cases glucose guru
complex we found the need to sort of
abstract the common patterns and move to
a library we chose to use sw-toolbox
for those who are not familiar
sw-toolbox is a wrapper library on top
of serviceworker it allows you to write
it allows you to explicitly define
routes and map different caching
strategies to this routes here's an
example of what the code looks like on
the top you see a product page URL map
to the SW dot fastest strategy which is
essentially a race between the cache and
the network most of the time one by the
cache of course but it also means that
in the background if the network request
succeeds it is going to update the cache
with the latest version of the product
shell serviceworker toolbox also adds a
bunch of capabilities on top of service
workers for example the max end
that allows us to have an LRU based
cache implementation so we don't do it
the cache with too many resources max
eight seconds allows us to easily purge
cast off at a given time the network
timeout second option enables us to
build Network resilient web apps by
falling back to cache if a request on
the network is taking too long
one of the patterns that we followed
before deploying service professional
production it should devise a
serviceworker kill switch the kill
switch is essentially a combination of
four different things first is the
two-level versioned cache names
second the no cache HTTP headers and the
third skip waiting along with clients
dot claim in the serviceworker the way
we name our caches is that we have a
global version and then a local version
appended to the canonical cache name and
the install event of serviceworker we
clear out all the caches that are not
part of this cache object so that means
if we had in case of an emergency to
purge all the caches we would just
increment the global version and if for
some use case we had to just bust one
particular cache we would just increment
the local version now you want to make
sure that as soon as we update a
serviceworker file it reaches the user
so we said the no cache and max age
cache control header and a negative
expires that makes sure that makes sure
the browser always downloads the latest
serviceworker file on every navigation
now like us if you're worried about the
amount of download that adds for users
on mobile no mobile bandwidth well you
can add the last modified or the e-tag
header and respond with the 3:04 not
modified so that it's only downloaded
when the serviceworker file changes all
right so now once the browser has the
new serviceworker file it will install
it on the install event you want to make
sure that this serviceworker
immediately moves from the install state
to the activate state so we call self
dot skip waiting this will make sure
that the serviceworker goes to activate
state without requiring the navigation
from the user on activate we want to
take control of any and open clients
under the same scope of the
serviceworker
so we call self dot client
all these patterns put together allows
us to confidently and reliably deploy
serviceworker to millions of users and
manage them at scale native apps have
this first-class experience where they
live on your home screen I can home
screen page or the app menu and on top
of an icon you can open them up in a
full-screen immersive experience on the
web we have been stuck in a browser tab
for a very long time the good thing is
that's changing with the serviceworker
and web manifest as the one mentioned
now we have the add to homescreen
function on Flipkart Lite we make the
act home screen completely opt-in for
the user so as a user once you engage
and explore the web app you can decide
to press the install this web app icon
and open up the native pop-up which will
then add the icon to the home screen
from there begins the immersive
experience as you can see as soon as I
type the icon it opens up with a splash
screen there's a full screen experience
gone is the URL bar the interactions are
smooth and fluid we give touch feedback
when I search something there are loads
and really quickly and overall the
entire UI stays responsive but that's
not it
this web app is resilient to all kinds
of flaky networks so if I Emily at the
offline mode here the web app still
works seamlessly and allows me to browse
my last the cache product and this works
even if
the best part is this works even if the
user tries to boot up Flipkart light on
a flaky Network here's example Mitra at
open Flipkart light on the airplane mode
it still opens up reliably and that
consistent performance that we promise
and while we wait for the internet
connectivity to restore the user can
still interact with the web app and
browse previously cached content this
keeps the user engaged and as soon as
the connectivity comes back the full
functionality is restored this is what
we mean by reliable performance and
network resilient web apps alright so I
did say we solved for SEO but how
exactly did we do that
well we just followed a couple of best
practices the first one was we treat
serviceworker as an opaque black box the
means that application code is not all
aware that a serviceworker exists or not
the second is that we embed SEO content
within the app shells now this might
seem counterintuitive what if my app
shell of product page a gets cached and
then when I visit product page B the
serviceworker picks up the shell of
product page a and serves me the content
well that might be true but the good
thing is web crawlers don't really have
service workers so web crawlers are
going to make a network request and
every time and that with that we can
give them the relevant content third
point goes without this without saying
that you want to have cross browser
support for efficient and reliable
crawling and indexing a main content
however is still rendered by a
JavaScript and generated dynamically
with experiments at Flipkart we have
seen that the Googlebot does execute
JavaScript and indexes the dynamic
content we've launched this just a
couple of weeks back and we are already
seeing a huge upside in organic search
traffic and a big surge in the number of
mobile-friendly search results when we
launched Flipkart lite it started as a
chrome only experiment but from day one
we have always been committed to
building a ubiquitous or a map
today Flipkart light works on a wide
spectrum of browsers with just a couple
of more left to go and this is
essentially the theme of progressive web
apps you have a web app that works
almost everywhere and it starts in a
browser tab the more you interact with
it the more you engage with it on more
capable browsers it transforms into a
native next Irian s-- fast forward today
we see over 45 percent users that shop
45 percent users the shop on the mobile
web our brand new customers for flip
card not just that we have over 40
percent monthly repeat users moreover we
have seen a jump of 70% in conversions
from the user that brass Flipkart from
the full-screen immersive experience
launched right from the home screen icon
the best part is we have barely
scratched the surface there's so much
more we can do with the mobile web and
we have an amazing team back at home in
Bangalore and they are working very hard
at this
now native apps have an incredible tool
to reach out to their users known as
push notifications transfer
serviceworker we can even send push
notification on the mobile web today
we're working really hard to bring this
to Flipkart light soon but to talk more
about web push and serviceworkers I like
to invite nature on Facebook thank you
thanks so much Aditya it's really
exciting to be here
my name is nature lost and I'm a
software engineer at Facebook I built
out a browser push implementation and
I'm also working on her future use of
serviceworker and rolling out
serviceworker across our apps at
Facebook we love the web the web is
cross-compatible users understands how
to use the web and there's low barriers
to entry the love is also fast
navigating to a website can happen in a
matter of seconds versus minutes to
download a full program as a mobile
first company you might be wondering why
does Facebook care so much about the web
when will the first does not mean native
only to have a successful fully liked
encompassing mobile first strategy you
also need to include the mobile web as
well as native one might worry all right
we're going to invest all of this time
in a mobile web app but what about the
native experience
well the mobile web is growing right
along native when we see growth in the
mobile web we don't see any downsides
going on in native when we see growth in
native we see the mobile web go right
along with it the platform's are
complimentary they're not competing
against each other the mobile web play
is an even more important role in
emerging markets like India in places
where the barriers to download an app or
high maybe there's flaky networks maybe
people have a hard time understanding
how to install Google Play get online on
Google Play maybe you don't have a lot
of data so it takes time to they don't
they can't download a full app the
mobile web is a lot easier you can just
click on a link get to a site and load
it instead of having to download a full
app every single time the desktop web is
also an area that's very important the
desktop web is an area of continued
strategic importance to Facebook
lots of people use Facebook on desktop
and it's an area that we need to make
really awesome we need to have the a
polished experience and continues to
make it a really great way to use
Facebook so speaking of desktop
you might remember your first desktop
computer maybe it was 1995 and you
wanted to track like your encyclopedia
so instead of like browsing to a website
you would open your Encyclopedia program
you would go search what you want an
encyclopedia program everything to be
local and you would get what you want
let's say you wanted to play like a
pinball game
you would open your pinball app on your
computer back then and you would play
your pinball game but then we started
seeing a shift to the web around like
2000's people started stopped using
native apps for everything and started
shifting to the web for a lot of the
reasons that I outlined before the
barrier to the entry on the web is lower
the web is fast you don't put download a
full program it's a lot greater
but then when mobile came around we saw
a shift back in the other direction
people stopped using the web so much and
they started using native apps on mobile
no why was this so originally on mobile
the web was more of the desktop web just
brought to a smaller screen it was
missing many of the things that made
mobile great the mobile experience and
the desktop experience are pretty
different on mobile you expect a
real-time communication device you don't
expect the full desktop experience and
there's a lot of features on mobile that
haven't traditionally been on desktop
for example things working really well
offline on flaky networks and especially
that real-time communication experience
with push notifications pushes necessary
to be successful on mobile you wouldn't
use a messaging app that didn't tell you
when you had new messages you wouldn't
use a calendar app it didn't tell you
when you had a new appointment and for
example you wouldn't use a social
networking app that didn't tell you when
somebody comments in on your status now
the web for the longest time the best
way to reengage people was email now
email is not terrible it can look pretty
good and users understand email it's not
like so bad
hover the barriers to entry for email
are pretty high you have to type in your
email address then you have to go to
your email program click on a link go
back to the site it's very if there's a
lot of steps additionally you can't get
some of the real-time engagement that
you can with push notifications with
email if you're active like commenting
on a thread or in a messenger
conversation you have to keep going back
to your email program to check what's
going on you don't get notified about
anything in real time with us I met so
we can also use SMS here but SMS has a
lot of the same barriers to entry that
email has in addition to being flaky and
sometimes so we knew that push
notifications were a good way to solve
this and we also knew that they were
very very successful on our native apps
and we all we cared about the mobile web
as well and for the longest time we
wanted to
push notifications to the mobile web we
wanted to do it so badly that we built
private push notification
implementations with UC browser and
Opera Mini and just like we saw on our
native apps this was very impactful
visitation grows up engagement goes up
this was really really great for the
mobile web we want it so after
successfully doing this in a private way
we wanted to start doing it in a
standards-compliant way in a way that
work would work everywhere and just
really well for everybody outside of the
box so when we heard that Chrome and
Mozilla and others were working on doing
a web push API with service workers we
were really really excited to build a
notification implementation there as
well so what does this look like
well when a user browses to Facebook
they can opt in to get push
notifications once they do that and
let's say somebody post on their wall so
somebody tagged them in a post they can
click on a notification and they get to
the content right away this is really
similar to the native experience in many
ways it looks identical to the native
experience and it's the experiences that
users know and expect and like this is
the way to do notifications on mobile so
from a technical side as Owen was saying
before setting it up isn't too bad when
your user opts in for push notifications
you get an endpoint you send data to
this endpoint in this case it's going to
be Google Cloud messaging now GCM is
going to have a persistent connection
with browsers so it has this persistent
connection and it sends a push event
with the data that you sent to it before
to the browser the browser knows which
serviceworker to wake up for this push
event it gives the push event to the
serviceworker the serviceworker takes
the data and makes a notification it
gives a notification to the browser and
the browser can then go ahead and
display notification to the user now if
you're doing this on the most modern
browsers you get push notifications with
data however Transat the long tail of
the web
not everything supports push
notifications with data so you also want
to set up push notifications that can
work in situations without payloads
doing this is just one additional step
it's not too bad so just like before you
have your push endpoint and you send a
request to it however this time you
don't have an encryption key and you
don't send data
just like before you've your push
provider which is there and it has the
persistent connection with the browser
and sends your push event to the browser
just like before the browser knows which
service worker to wake up for this push
events and it wakes up the service
worker and gives it the push event
however this time your service worker
doesn't have any push data so it has to
go back to your server fetch the data
and then it has the data so that it can
use to display notification it
constructs the notification just like
before gives it to the browser and the
browser can display the notification to
the user however I should note in this
scenario there's one other thing you
want to think about that fetch request
back to your server could potentially
fail but the service purse still has the
push event as part of the contract and
getting pushed events in a serviceworker
you're promising the browser that you're
going to go ahead and actually display
notification if you don't many browsers
will apply a penalty and some browsers
will actually show an error message
notification this aramesh this
notification is not a good user
experience it looks really bad so you
want to always have a backup
notification ready in your serviceworker
for if that fetch to you fails so as we
rolled out push at scale there are many
lessons that we learned along the way
one of these is when it comes to
clicking a notifications the problem of
clicking on applications might seem
pretty straightforward you click on a
notification and it opens a new browser
window so let's say you're an active
messaging conversation I click on
artificial it opens a new browser window
now the next message comes in I click on
our notification and it opens a new
browser window now another message comes
in I click on notifications it opens a
new browser window as you can tell
pretty soon you're gonna end up with a
lot of browser windows open it becomes
really really hard to use Chrome because
you just can't find the tab you want
maybe things are it could be a little
slow it's it's not a good user
experience alright so how do you solve
this well maybe you click on
notifications now the serviceworker
checks if there are any windows open and
then if there are asked that window to
navigate to the new the place that
clicked or if there's no windows open it
opens a new window this brings some
other challenges though let's say that
you have a site that users can engage
with maybe they're in the middle of
typing a comment or a new post and they
click the notification and then the
window navigates and it blows away their
post they're in the middle of right
that's also not a good user experience
because now you've just deleted what the
user was in the middle of doing so to
solve this we came up with a solution
that's also that's not too bad so
somebody can click on your notification
then the service worker is going to get
a notification click event now what the
service worker will do is it'll check if
there's any windows of your site open if
they're orange what it can just like the
first scenario outlines it can go and
tell the browser hey browser please open
a new window to my site and the browser
can open it pretty straightforward
now this case gets a little interesting
let's say you have a window open and
somebody clicks on your edification
again just like before the service here
gets a notification click event however
this time these service worker is going
to check and see if there's any windows
of your site open if there are instead
of posting a message to the browser
it'll send a message to the window
saying hey window can you please
navigate to this URL the window can then
either say yes I'm gonna go navigate if
the user is not in the middle of writing
content in which case the service worker
can say hey browser please focus on this
window or this window can say hey the
users in the middle of writing a post
I can't navigate right now in that case
just like before the service Square can
go ahead and open a new window we found
that this was the best compromise
between not overwhelming the user with
too many tabs of the same site being
open but also not blowing away what the
user was in the middle of doing so in a
similar vein when I was first we were
first building this I had notifications
on for every single platform at the
beginning this wasn't too bad it was
just Facebook the the native Facebook
app so I would get an application from
Facebook my phone would shake I would
see the notification not too bad but
then once we hit every single platform
there's got to be a little overwhelming
so I got my notification from Facebook
my phone just shook I'm pulling out my
phone now my phone shakes again I get an
ovation from Chrome I'm maybe looking at
the note kitchen problem trying to pick
between Chrome and Facebook then I get
another notification from opera then
maybe a little bit time later I get
another notification you see some iPhone
and I'm looking at this then my computer
makes it sound and I got a notification
Chrome on my computer there's a lot of
things going on I'm just like what is
happening so solving this
it's kinda straightforward only send
notifications to your users on the
interfaces that they frequently use just
because you can send notifications on
every interface does not mean you should
pay attentions to where users are
engaging with your site and using your
app and notify them they're a very very
similar vein you want to make sure you
don't send too many no to kick this play
too many notifications at once let's say
you're in a messenger conversation and I
get one application for another message
then another notification comes in for
the next message then another
notification comes in for the third
message and they get another
notification for the fourth message and
if I show a different notification on
the screen each time
pretty soon the screen is just full of
messages and it's very very hard to use
my computer or really even engage with
any of the messages because just kind of
a list that's just constantly pulling up
to solve this you can use tags on
service record notifications to replace
previous notifications think of tags as
a slot you can say I have tagged a slot
a and then if there's no notification in
the slot the browser will just display a
new notification there if there is
already notification there at the
browser will place the existing
notification with the newest one this
way you can make sure to not overwhelm
the user by displaying too many
notifications on the screen at the same
time another interesting case we ran
into was accidentally downgrading
clients when we push out new code on
Facebook we don't roll all of our
servers to the newest version 100% all
at once we test the newest version of
our server code for a little bit before
we were to out the entire site for this
example let's say we have version 1
rolled out at 80% and version 2 rolled
out at 20% and we have our serviceworker
and the entry points to Facebook
so the browser wants to go ahead and
update the serviceworker it hits
Facebook and says hey Facebook can I
have the newest version of the site
really yeah here you go
we hit version qu this time and we give
the browser at the newest version of the
serviceworker this is great the users
fully up to date they have the latest
experience this is really awesome
however let's say sometime later the
browser goes ahead and updates the
serviceworker again just like before it
hits Facebook but this time we serve the
serviceworker from version 1 so this is
not the best experience let's say we
save data in a new format in version 2
we'd have to make it backwards
with anything that was going on in
version 1 also it means that the service
workers are gonna do an update that it
shouldn't do it the service worker is
going to be in the update state way more
often than it should which is not lead
to the best user experience to solve
this what we did is we started looking
at the current version during the
install event in the install event we
would check to see if the currently
installed version of the service worker
was greater than the newer version if
the currently installed version is
greater than the newer version we throw
an error in the install event and we
just don't let the install event
complete this means that the user is
always going to be on the newest version
of the service worker which makes
developing for the service worker a lot
easier and it leads to a greater user
experience overall software polishing
and perfecting the user experience with
service worker and push we ruled out put
web push and started looking at impact
so it's been about a year and a year
later we're happy to say that web push
continues to drive significant impact
for Facebook mobile was right in line
with what we were expecting it web push
on mobile is great we knew that it was
great it fit our native it fit our
native experience really well we kind of
knew that web push on mobile was awesome
and we saw the engagement we were
expecting daily month of active users
increased commenting increased
engagement increased it was really
awesome on desktop we were a little bit
worried it was many users first time
getting push notifications on desktop
the desktop experience is different than
mobile people don't always expect to
have real-time communication on their
desktop just like they do on mobile we
were very very happy that this had great
impact on desktop as well daily months
of active users increased commenting all
the things that we wouldn't increase
increased what we saw was that users
kept it on and they really enjoyed the
experience it turns out that people like
getting notifications where they're
already using Facebook if you meet your
user where they are it's just a greater
experience for everybody so now that we
rolled out web push we're starting to
look into investigating where we can use
service workers elsewhere at Facebook
today loading on loading facebook is
often blocked on a network what we try
to do when we load facebook is we do a
little bit of work on the server and
then as soon as we can we push it out on
the network and let the client do work
as soon as we can then in parallel we do
a little bit more work on the server and
try to push that out to the network
as soon as we can what this does is
we're taking full advantage of
everything of everything that we can
across the stack to try to get the user
face book as quickly as possible
however if the network is flaky or slow
or something's going wrong this can just
block the client from being able to do
anything the client doesn't get Facebook
at all maybe it takes a long time a lot
of us the optimizations that we can get
by doing things in parallel just don't
imply anymore the serviceworker can do
much better like Andy said with
serviceworker we can make sure that we
already have the shell of the app loaded
we can start doing work on the client
before we even hit the network and
before we even hit the server the client
can start doing work to display the site
then all it has to do is fetch the
content that it needs to display this
piece of content instead of fetching an
entire app every single time here at the
site so we can start doing work in
parallel even earlier and paralyze
across more of the stack another
experience that we can get is being able
to run an app totally offline now
offline dinosaur is great he's super
cute but really it's time for him to go
extinct native apps can work offline
when you open native app you don't see
like and you don't have internet
connection you're not gonna see offline
dinosaur you're still gonna see an app
experience and this is what we should be
able to get on the web and now we
finally can our Facebook we're already
really starting to invest heavily in
service workers and we're very excited
about their future starting this week we
began testing offline mode on messenger
comm using service workers Riesling
service workers on whatsapp web to make
the site load much much quicker and as I
talked about before we're using service
workers to power push notifications on
Facebook supercruise week service
workers make native experiences possible
on the web at Facebook we're very
excited about the future of service
workers and we can't wait to explore
their potential in the months and years
to come now to wrap things up
Owens going to come back on stage
great job thanks mate so I'm really
excited about all of the momentum we're
seeing in the community around service
workers and progressive web apps I was
really happy to steal this slide from
Rahul's mobile web state-of-the-union
yesterday which shows all of the
different companies that have either
already ship progressive web apps were
investing in progressive web apps and
it's not just Chrome this is a journey
that all of the number of the browser
vendors are taking together and here you
can see some of the tweets and posts
from a number of the other browser
vendors about service workers and
progressive web apps we've been really
excited to see the momentum in this
community and I encourage all of you to
get involved ask and answer questions on
Stack Overflow post your libraries and
your pour requests on github and tweet
at us on Twitter with service workers we
need to rethink web development it's now
possible to build high-performance
engaging experience on the web and all
of these features are available in
production today and they work
progressively and so I encourage all of
you to go back home and join Facebook
and Flipkart in using service workers at
scale thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>