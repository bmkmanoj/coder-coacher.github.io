<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>ES6 Modules in the Real World (Polymer Summit 2017) | Coder Coacher - Coaching Coders</title><meta content="ES6 Modules in the Real World (Polymer Summit 2017) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>ES6 Modules in the Real World (Polymer Summit 2017)</b></h2><h5 class="post__date">2017-08-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fIP4pjAqCtQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello
let's look quite loud so confusingly I'm
the second Australian Sam you're seeing
today so we do look a bit different so
you'll be able to tell us apart later on
today I'm here to talk to you about es6
modules you know how they work what are
the ups and down sides and how they exit
integrate with existing code you know
and this talk is to have taken
definitely a technical deep dive which
is basically code for there'll be a lot
of stuff on the slides so pay attention
it's a bit of a preamble I want to give
some non men some naming stuff so I just
want to say that es6 modules are also
known as JavaScript modules or Akuma
script modules if you've heard of them
before they're not common jeaious
modules which are you know the probably
the most common non-standard approach to
modules we have today and it's what we
get if you download nearly any module
from NPM or yawn you know there is an
interrupt story here es6 modules don't
have to exist in a vacuum and i will get
to that later on so this talk is pretty
big it's comprised of three parts the
first part is I'm gonna give a brief
intro to es6 modules what they do and
how they work you know and at the end of
part one you could walk out please don't
but you'd have an understanding of the
how and why including the story for
older browsers and part two you know
modules are really great I think they're
quite cool it's given me a whole new
lease on writing JavaScript but they
also change a lot of subtle things about
the way we write it which is why I've
split this part out and finally I'll
talk a little bit about integration with
existing packages and code splitting so
maybe most importantly I mean why do we
care well obviously we care because poem
is moving to es6 modules and that's
super important for us using palomar but
the other reasons are you know any
language really needs modules right
anything more than a trivial trivial
program in any language needs some sort
of include system and of course you know
in languages like Python or C++ we've
obviously had that since the inception
but for JavaScript we've not had this
right you know you include a script tag
in your page and just hope it works and
we all know this but including loosely
scripted find script tags like this you
know is such an anti-pattern right yet
we see it really commonly and secondly
we want to use the platform we obviously
have great community driven
approaches you know I mentioned commonjs
which we'll come back to but they never
pulled picked up as a standard and never
really adopted by browsers and this is
for a couple of reasons but what I think
is really interesting is that the
ecumene script standard for modules has
a really intentionally small
specification it's actually really
simple when you get down to it but it
has obviously a few nuances which I'll
be talking about in a little bit so this
is technically an example this is how
using es6 module you can either include
a script file to run as a module which
is the code snippet at the top or I can
write up write a module script in line
which is what you see at the bottom you
know okay this is great I've specified
type equals module but what does this
actually get me well I get you a couple
of things firstly it gives you
superpowers don't worry that's the worst
slide transition we'll have the whole
time but it gives you superpowers
JavaScript superpowers to import an
export code
sadly modules don't let you fly I hear
that's reserved for Python on this some
joke there I can know Python programmers
here so now you can port import other
code and here you know I'm declaring my
first script tag as a module so I can
request that this symbol answer which
comes from the bottom appears from the
it's in the question source file and I
can request that that will show up in my
index.html and now I can use it in any
other way any way that I'm used to you
know this is really the basic core of
modules and I'll point out that in
regular j/s these symbols are there is
right you can't use them so you can't
just include these files as regular j/s
and mix and match that code bout that
code so here's a slightly more detailed
example unlike the last slide we're now
including the J's file by the source
attribute you know the point is here
that doesn't really matter whether the
script is in line to your HTML page or
you're including it they still work the
same way and because we started with
type equals module both these files are
kind of running what we call module mode
you know even though the bottom one
purely has side effects I'd purely
exports something sorry it has the
superpower to include additional modules
if it wanted to so what we've basically
built is sort of like a path of imports
you know this is our little example
we've got a HTML page it pulls in code
and it pulls in question
but you could add you know another
dependency here or I could add something
else that's dependent on my multiple
files I can also have other HTML pages
which maybe enter into this graph of
dependencies that I have here which is
super interesting and I'll refer to this
a little bit later on this slide details
some of the options so we saw the really
simple mode of exporting and importing
before I find there's actually a lot of
resources about the format of this kind
of important export syntax online and
it's interesting but it's really well
covered if you google for things like
es6 modules most of the articles you'll
find will talk about the format's of
these things so you know it's really
well covered I'm gonna mention a few
things you can see on the left here that
we have sorry on the right we have
exports for cat and dog and on the right
yes we import those things as sort of
named things from the other in in this
other file there's a few nuances you can
also have a default export functionally
while it looks different than the other
types of exports it actually is just an
export with a name default we can't use
it because it's a keyword so we can't
export something named default it has to
be special then you can see this on the
right if you actually use this format on
the very bottom right which talks about
importing the whole module as an object
that looks like a dictionary you'll
actually see that default just ends up
being a key of that dictionary so that's
kind of interesting the most important
part of these statements is that they
have to appear at the top level of a
file and I'll visit that in a second so
let's talk about what I'm allowed to
export so I can export something that's
generated you know since apples are in
season but forces bananas I'm gonna
return a different function and so this
file will export you know an unknown
method that's not known it's sort of
static sort of built time or whatever as
the fruit property but I can't
optionally export something this doesn't
appear at the top level so this is
basically a syntax error and on the
import side there's kind of similar
problems the rules around this are
basically saying that I can't import
from an unqualified path it has to be a
relative path with a dot at the start or
a full URL
you can't import not at the top level so
even though this try-catch block isn't
actually a control fire control
structure it doesn't actually optionally
run this is an error because it's not
appearing at the very top level of a
file and at the very bottom you see that
you can't import I don't I did not a
dynamically generated script either so
think of these restrictions as like what
kind of a very dumb static passive pass
without running any code and this
matches you know traditional languages
like Java or Python or C or c plus C or
C++ and it comes from that small
specification that I kind of mentioned
before so this is the very basic intro
to s modules but of course what supports
the browser support and so what I've
shown you so far isn't theoretical right
you can use this in all major browsers
but I'll admit as I give this talk I
think five for an edge are still behind
these behind flags we saw that in the
keynote but if you're watching this you
know sometime in the future well you
know as an Australian would say she'll
be right I'll also note when I say
chrome of course I really mean chromium
and browsers derived from that and
modules are implemented at the
underlying v8 level so it's possible for
support to flow from there so okay we're
through a sort of part one you're
convinced right modules are great syntax
looks good and you're gonna migrate all
your code to this format well we're web
developers so we know that nothing comes
for free so let's talk about the support
story and I'll start with a favorite
thing old browsers browsers will
basically ignore script tags with the
type that don't understand so you can
safely tell them hey here's this module
script and actually you know your ie
Elevens or whatever will actually just
ignore this completely you know it's how
people have sent CoffeeScript or dart
down to the browser for years now but of
course if we write stuff in the module
format we need to still need to
transpile or compile for browsers that
don't support the module the don't
support es modules you know you might
already be doing this right
paalam is build and serve commands with
the CLI stuff already run a transpile
step for you for these browsers and so
yes this does mean we need to ship two
sets of code down to pretty much all our
users and when we do the transpile we
obviously need to include both those
sets of output so the way we do this is
we basically do what's called a No
Tagg so we add this script tag that
browsers that support es6 modules will
actually ignore with a small caveat so
putting it together you'll basically you
know on your eventual HTML page you'll
have two scripture script tags one for
module browsers and one without and this
is great right because it doesn't have
to you have to run script to generate
the right imports you know new browsers
get new and all browsers will get old
but that star from before actually
safari 10.1 actually shipped without no
module so there's a small bug into
workaround
we've actually got a solution there's a
small jason effort you can include that
will stop a safari from loading this no
module code this issue was fixed in
future versions and everyone else is
shipping with this feature um it will
eventually go away right you know all
browser versions will eventually
disappear like tears in the rain and the
biggest cost maybe in the very long term
is that users on this very specific
version might end up downloading both
your bundles of code so I've mentioned a
bunch of stuff I said well you need to
transpile you need to ship two code
paths and you need to deal with a fun
bug so why should I even bother with it
air six modules at all and there's
basically two really huge compelling
reasons the first is this immediate dev
cycle when you're building modular code
and you have a native browser that
supports it you can you know if you
don't have native browser support you
know you've got to build or run or
whatever to actually see your output and
even if that happens automatically you
know I mean you save it's still a cost
it's still going to run something
instead with es6 modules you can
literally save a file go to your browser
refresh it and your code is just done
right it reads all the stuff modern in a
modern way the vastly more important
thing in my mind actually is it's a high
watermark what this basically means is
that echo script modules are a 20-17
feature literally any browser to support
second script modules supports a ton of
features that you may have been afraid
to use or afraid you have to polyfill or
afraid you had to work around so if you
have a separate serving path you can
quite literally only serve code to these
browsers that you know that you can be
confident about that's gonna work you
know we get to restart JavaScript
development from
point and you know here's a table I sort
of worked on earlier you know this is a
kind of list of a laundry list of
features and you might have been afraid
of shipping this or using these and of
course for if you have an es5 client you
still got a transpire you've still got a
ship that old code to support those old
browsers but if you're shipping es6 code
in parallel you can basically drop the
polyfills for all these features you
know your award users on up-to-date
browsers and you know to pick on a
certain feature asa can await you know
to transfer all this adds a bunch of
bloat they've got to rewrite the code to
be a weird generator thing
and for es6 modules you can actually
safely ship this down you know for those
modern browsers while still supporting
that very long tail of browsers that you
know obviously will never get support
for this feature and let me stress one
point right we don't penalize old
browsers for doing this you're probably
already transpiling these features away
and including the right runtimes it's
just the idea that for modern browsers
you can ship a entirely new fast code
path that doesn't have to deal with any
of that legacy croft and okay so what's
the last part of the process
you know I've mentioned transpiling but
I want to revisit this a little bit you
know you want to convert es6 code to es5
code and you might already have built
build tools and infrastructure that does
this for you right they'll bill adapt
nicely to es6 modules if you just
include them these include pleasure
compiler which is by google of course
and roll-up is a good example of a start
up starting point for something that
will get rid of es6 modules and ship it
down to something it's a bit like es5
for those older clients and roll-up is
basically what I recommend it's an open
source tool that's built entirely for
merging es6 modules together to give you
one output es5 file you know and to
compile and actually to finish that
whole process and compile and transpile
you would use roll-up to merge your code
and then at least for me I would include
something like the babel plugin to
transpile to the version you're
targeting that's how you can build your
es6 modules down to es5 and the couple
looks looks a bit like this we've all
seen something like this probably but I
want to focus on two main things you
know we include the babel plugin to
actually do the transformation for us
and we tell be able to we tell roll-up
to give us an Fe out and I'll come back
to this later but I have an opinion for
simple apps and for production
actually suggest using roll-up with this
flag and no plugins to ship a single
file even to browsers that support es6
modules so this is interesting right
like I'm telling you to use modules that
I'm telling you to roll them up when you
actually finally ship this code so
firstly you know it's smaller you know
you don't hit me to include polyfills
but I covered that before but there's a
few benefits right so when you rot use
roll-up or tools like it even to ship
here six modules as a single file you
get a bunch of benefits and one of the
big things is called tree shaking you
know when you merge modules together you
basically get rid of code that you don't
need or isn't being used and this isn't
a talk about compilation there's plenty
of other resources out there on that but
the key is you know these will really
save you a lot of space and if you're
importing a lot of dependencies which
es6 modules let you do you know you can
have hundreds of tiny dependencies using
different you know maybe it's written by
you or written by someone else you can
pretty very confident in saying that the
stuff you're not going to use will get
thrown away and having a lot of module
files is also going to call it's also
going to cause what known as request
chains so if your browser fetches an
index page it's gonna then see it needs
this file main dodge is and then it's
gonna see that it needs depth ojs and so
on and so forth and before you know it
you might have done a whole four or five
round trips to the server so of course
you might have heard of HTTP to push and
this can solve this for you you know
tell your clients here all the j/s that
here's all the J's files they need you
know before they even ask right I can
tell the client you need all these five
files you know have have fun with that
but a lot of servers won't do this for
you right and in my experience well
that's a great feature it's not widely
adopted right so you can improve improve
your users experiences by having just a
single file and there's also the header
overhead right if you have a lot of 100
byte files maybe the head is a 200 bite
each so rolling up your app it could be
really important to save space okay so
that's a lot but I want to go into some
of the new answers that were the way
JavaScript changes when you write module
code so module code is always executed
in strict mode basically this turns more
mistakes into errors and prevents some
JavaScript anti patterns that have been
about
all for a long time so Mozilla has the
best documentation on this so go look up
look up on mdn but basically you can
pretend that every file has this use
strict pragma at the start of it and
module code is always effectively
invoked in what we call an iffy and
immediately invoked function expression
so what that means is that symbols you
define in your module won't
automatically appear in global scope on
window and this is what it would look
like in code right your module stuff
would basically appear in the middle
this is informational all right your
browser doesn't actually do this but
it's something to keep in mind if you
write any tooling around here six
modules and this is what it would look
like right when we add code into here
you can imagine the sort of errors you
would get you know the with statement
for instance is sort of considered
harmful and it's disallowed and using
this variable Q without defining it is
also an error you know we haven't got a
vast daemon or a letter or anything like
that on the other side you get some
benefits right this variable X won't
define what pollute the global scope it
won't implicitly create a property on
window which is kind of not usually what
you want but we can still access things
like let's say we've had the H at this
HTML element obviously we can still
access things in global scope as we have
you know normally used to so there's
something else I want to talk about you
know in early examples we saw that a
module is usually either an entry point
which runs code like your application or
it's a dependency you know that was the
example of a file that just exported
something but we can kind of have a mix
of both I can import a file just for its
side effects just to run it and what's
interesting is that this fits the model
of many single file J's libraries this
is talking about integrating with this
existing code it's a really simplistic
way to pull in dependencies that maybe
aren't written as es6 modules which
turns out is most code right now and so
here's a real world example I was
working on recently you know I wanted to
use a base64 library which isn't
available as an s6 module but it was
available as a you know single minify
javascript file which you know again
it's pretty common for small libraries
or feature polyfills so I could target
it directly for import you know even
though it has no X for export symbols
and its side effects will still take
place you know and again this isn't the
be-all and end-all of existing of
existing code
it's interesting it's an interesting
step modules are also deferred they
actually aren't allowed to run
synchronously the reason for this is
because if you have a lot of
dependencies your browser could be
sitting there for a long time going to
fetch all those files before your page
can continue running you can however
specify async and what this basically
means is that fast loading or cached
modules will run in any order as soon as
they're downloaded and this is the same
as normal script tags and the way that
they what they would work modules are
imported only once this is good to solve
although it's not a huge deal it kind of
avoids this problem which no one really
does anyway no one accidentally includes
multiple versions of the same code but
what's more important is because modules
are kind of a graph or a tree structure
they're kind of like Singleton's right
two files that include the same
dependency will actually get the same
module back and it will only run once so
let's take a look at what that means so
let's say we bring in this default
import from food ojs even using you know
different paths these all point to the
same file and no longer and no matter
how the browser imports that file
because it resolves a URL the module
object will always be equal in this last
case this is where it would differ this
is a bit of a red herring but it might
be something to watch out for you know
we know these files are the same right
we know the query string doesn't matter
but to the browser it's a different file
right there's a different URL so this is
going to be a different file and this is
kind of almost a hack to make a module
run twice if you want to module imports
are like functions in that they hoisted
so this code here which is here on the
right will actually run fine right
exciting module exciting method is
brought to the top of the file just like
this and so we have another example
which has an interesting you know
trade-off with that right so let's say
we have a new emoji polyfill you know we
need this for our emoji library to run
properly what we've want what we've
learned though is since the import is
hoisted this actually won't work right
the polyfill won't be available for the
emoji library we can basically solve
this if you have code like this by
moving our inline j/s into an import
because now the these import statements
will still run in order they'll just run
at the top of the file so we can use the
the side effect benefit to make sure
that that is that this window thing is
going to be available for our next file
that runs and lastly which is kind of
cool
circular dependencies are actually
allowed in J's modules this is kind of
interesting because it's something that
you know we haven't had in other module
systems they work mostly because of some
of the properties I've talked about on
the last few slides the basic rule of
thumb for modules that have circular
dependencies is to not do any work at
the top level you know don't cause
side-effects just important export
things so let's see an example so I'm
gonna give you a classical Cs exercise
you know I have a superclass let's say
it's a vehicle we want to subclass this
and we want to give each vehicle an ID
make sense so far right I have a new
file which has a class car you know it
has an engine a driver whatever it
doesn't really matter but because it
inherits from vehicle it's also going to
get an ID so let's say we want to have a
static method on a vehicle that returns
a car this is kind of a Java ism or a
kind of a poly morsel you know a basic
polymorphism kind of exercise but you
have a builder on a superclass that
returns a subclass and you know maybe as
a user I treat that as a vehicle I don't
care that it's a car so we now have a
circular dependency right car descends
from vehicle and vehicle itself can can
return us a new instance of car you know
and this is actually more or less fine
if I import either of these files this
will work as intended so this is kind of
a good example of where circular
references will really help you but
there's one case that would break it so
you might have noticed a static kind of
ID property this is kind of a property
of the vehicle singleton if you can
think of it that way so if we know if we
end up using that property inside the
car code just maybe say tried a test or
a default car well this is actually
gonna fail and you might be able to see
why but let's look at it why let's look
at it anyway because the vehicle is
effectively hoisted while we're in this
kind of crazy scope and because it's
exported inline ID is not really
available yet so what ends up happening
is that this constructor will fail with
a reference
I do you know effectively is not
available to this class yet there are a
few crazy hacks around this right and
what may actually work out to be
possible is maybe there's some
interesting patterns that the people
will work out or realize that will kind
of leverage circular dependencies in a
very interesting way to do some cool
stuff but for now doing this sort of
thing actually using the code you know
in line in this file is the sort of
thing that will bite you
okay so I've talked about a lot of
nuances let's talk a little bit about
integration and as I mentioned before
your six modules don't have to live in a
vacuum so let's talk about the elephant
in the room this is a bit forced but you
know using the existing ecosystem of
nerd code firstly there is a simple
solution you know we've talked about
building modules using roll up and how
modules obviously are very different and
while modules can help you get rid of
the massive script tags there's some
cases when you can just include them
anyway right and a really good example
here is when we just want to include
some dependencies for tests now here I
include mocha and chai just the things
to run my tests and these are just these
just have side effects and remember
remember that modules are always
deferred right so I can also defer my
script tags because I know that they
don't need to run until my module is
ready either but I want to talk about a
more concrete solution you know what you
can actually take away and use in your
own projects
what is the story for code you've
installed you know this code that's
inside node modules this is stuff yet
again that's likely in common J's format
it uses require it uses model boat
exports so firstly I want to focus on
you know this sort of stuff what's the
solution right it's actually really
simple
we want to build a special es6 module
that actually uses the require keyword
and then re exports those symbols again
in es6 you know this is obviously magic
right because we know the require isn't
supported by browsers so how do we
actually do this and just to go through
it a little bit more I want to connect
this very clear we have our app on the
right here this is our you know es6
module thing all our modules are in pink
and on the Left we have our node modules
that we're really keen on using in our
projects so firstly we create what's
called this support JS file this file
will use require to pull in the node
modules just like they used to so we add
these links here right we then use
roll-up to generate a rolled up jazz
file in es6 module format
we'll see how in just a second this far
bridges our common dress code to be a
module to be module code and because
we've now kind of transformed this old
stuff into a module code we can now
depending on wherever right you know in
this case I'm pulling in left pad which
I'm sure is very important and I'm not
judging right I really want you to
remember this left-right split it's
really the best way to split up our
dependencies you know especially with
this wealth of code we've had it you
know over the years you know yes we're
introducing a compile step but it's
really just for the stuff on the left
right it's not really a huge burden it
only happens when we change other
pendants ease which we presume is not
going to be that often so I've talked
about the support file but what does it
actually look like you know we can just
require code in this file as normal of
course a reminder we can't really ship
this it doesn't really work but I
immediately then react support them as
es6 modules so this indicates to roll-up
that these are the things we're
interested in and you know as you see in
the example we might only care about one
sub symbol as well and that's fine so
this is a sample gulp file but there's
really two important parts here what we
want to do is we want to tell roll-up
about the common J's plug-in and this
basically allows roll-up to go and read
those old-style formats and in its build
process it will output you a file that
understands them we also want to re
export as an es6 module so this is the
example I was kind of talking about
before right we want to use roll-up with
its config and say well I don't want
anything I don't want the final output I
want something in the middle so what it
generates is something that looks like
this right it looks like a normal ear 6
module that we can depend on with all
the require statements you know even up
and taken away so this is now just
another dependency in our you know graph
of modules that I can depend on either
in prod or dev there's one other case I
want to cover which is kind of like an
anti-pattern es6 modules don't allow
dynamic dynamic imports and exports and
so unsurprisingly most of the tooling
around that doesn't allow it either so
even though we're using the common J's
plug-in for a while roll-up
right now we're all up and cap will
complain horribly this right it's a
conditional it has to evaluate to decide
what to include in this output so it
basically returns a file that just has
this error in it and so I'll discourage
you from doing anything that's you know
if you're going to integrate with old
code
avoid those patterns that we want to
maintain that es6 modules prescribes
another option of course if you are
lucky enough to see a or six modules
actually a node code and obviously we're
going to see that at some point with
Palomar you can actually use yarns flat
option to install them and this is for a
pretty simple reason right flat was
covered in some earlier talks but unlike
nodes require statement which sort of
has a few fasts
sort of has a few paths that looks at
import requires very sort of fixed
relative paths so that means that the
code you download which will be es6
modules kind of chooses the approach to
finding files that it likes right and in
polymers and others cases you're gonna
see quite a little it looks like this
right it's always going to assume that
it's dependencies are going to be
essentially up and one you know one
sibling across so we've covered that
option and i only go on a bit of a
detour so one thing i was thinking about
a lot with es6 modules is this kind of
code splitting story you know you got a
lot of code we want to make it one file
but that's not always what you want so
you of course with the air six modules
isn't that code already split right
we've already got lots of dependencies
let's say i've got an application with
two entry points right these are
basically analogous to our two HTML
pages that exists on our site they
import you know they import this graphic
dependencies to achieve their goals this
is a bit contrived i just drew some
lines in two boxes just to see make a
cute example but you get the idea right
these are all things you might depend on
and other libraries that they follow
will depend on if we were to do my
approach from before and basically say
let's roll up everything into a single
file we get two giant bundles right this
is kind of a common problem I think with
bundling any kind of code you know I
don't know what my files really need so
I end up just shoving all the J s in the
output file and letting the client deal
with larger download size you know this
ton of code the participation here but
what we can do is we can basically
identify what's needed at each entry
point and we can basically walk the tree
to do that so the reason I'm telling you
about this is because the module spec is
so simple that actually really trivial
if trivial for you to do this yourself
in your own build steps you know we
marked these with colors and now we can
see almost implicitly what are the
different kind of bundles we need right
initially we basically want to include
the code for entry one
entry to those parts are really obvious
right we know that those files are only
needed by those two entry points so we
can roll them up together but what do we
do with the rest right I mean this if
they H team if they were HTML imports we
could actually just group them all
together and send them down as one big
you know chunk and that's great right
it's a block of shared stuff that both
sides can import but with es6 modules
and i am a minute admittedly simplifying
a little bit we can't really do that do
that because of this because the two
modules might export the same property
name we can't at least naively roll them
up together right to one module can't
export the same symbol name twice and so
our entry points might use these methods
in different ways and you know you can
rewrite them I'm alluding to the art the
art this is a simple option and web
something like web pack collection do
this but to think about a simple process
what we want to do is if we actually
want to create different entry points
into these two bundles right the left is
D and the left is effectively e right
the F is a byproduct of e so this is the
minimum amount of code splitting you
need to do to basically serve these two
entry points and you can imagine as you
get more and more code and more and more
dependencies this graph got me might get
more complicated and like I said the
reason I've mentioned this is so I've
actually you know in building this talk
I went and built this tool right it
actually goes and finds the minimum
spanning requirement to basically split
up your code into models that don't
duplicate code but in doing it actually
wasn't overly hard right the module spec
is incredibly simple and it's really
just a simple parser that goes over and
looks at this code and run some really
basic graph theory on it and this is one
of the huge benefits of switching to
this approach
you know require a common to yes and
require statements can support a lot of
things they can support you know
variable imports they can be not at the
top level and actually that really opens
back makes static analysis really hard
so check this out if you are curious so
this is basically the last technical
slide it's also worth mentioning dynamic
import and I know this was mentioned you
know for web pack as well because they
use it as their their boundary for
splitting code but I want to talk about
the function it's not really available
yet you know browsers are still building
it now but it is coming soon you know it
looks a bit like this you pass it a path
and it returns a promise no real
surprises there right
which is unlike our regular import
statements which which happens
synchronously secondly it's sort of poly
fillable you can actually use this today
if you want to there is one catch though
so we can actually do this but the
browser has no way of knowing what my
current file is so I can actually import
food all day yes but I'd have to tell
this polyfill function what is my
current path because essentially there's
no way for the browser to say what is
the currently executing es6 module file
this is actually subtly different than
the way we do regular JavaScript regular
JavaScript non modules you can actually
use the document current script property
to find out who I am button sadly in es6
modules that's not allowed we're not
allowed to know who we are so you have
to include some information about where
is the file relative to me so thanks for
listening we've covered lots of stuff
and admittedly this is a bit of a grab
bag of technical stuff so I appreciate a
Varenne paying attention so what are
some takeaways right browsers love
modules they get along fine you know
there's even the no module keyword for
all browsers the way we have to write
jess will change a little bit it's
pretty subtle and it's mostly to do with
the way we interact with files but the
things that might bite you as you go
along and secondly modules play nice
with you know NPM modules via roll-up
but we obviously recommend yarn for the
flat up fat flat package approach and
I'll leave you with some for the reading
my colleague Jake who managed to avoid
giving a talk he's hiding somewhere and
you can grab him on myself after the
talk and find out more about modules and
that's it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>