<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Polymer 2.0 in 2.0 seconds: Upgrading Projects Large and Small (Polymer Summit 2016) | Coder Coacher - Coaching Coders</title><meta content="Polymer 2.0 in 2.0 seconds: Upgrading Projects Large and Small (Polymer Summit 2016) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Polymer 2.0 in 2.0 seconds: Upgrading Projects Large and Small (Polymer Summit 2016)</b></h2><h5 class="post__date">2016-10-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/iI3G-tzbC_Q" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm Peter burns I'm an engineer on the
polymer team I'm gonna talking about
upgrading so polymer 2 it's really
exciting for the very first time you
you'll have native shadow Dom a native
CSS custom properties in every single
shipping mobile browser that's enormous
Rob also just showed you all of the new
ways to declare an element and all of
our new and improved api's hauser this
is a lot of changes how's everyone
feeling good amy was feeling nervous
anyone feeling dread if you are it's
okay trust me I know exactly how you
feel because at Google I was the upgrade
guy
I was the guy responsible for getting
everyone at Google migrated off of
polymer 0.5 and on to one point out
hundreds of projects and hundreds of
thousands of lines of code
coordinating tons of engineers and
interacting with them a lot taking their
support tickets that sort of thing and
honestly speaking on behalf of myself
and especially on behalf of them it was
painful but the polymer team we learned
a lot I can honestly say it was
transformative as to the way that we
think about breaking changes and
backwards compatibility so why are
updates painful I think a lot of it is
around uncertainty the way we think
about risk
you start thinking questions like how
long is this going to take
what what do I need to change to get
migrated and those are sort of the top
of mine things but I think the back of
your mind is thinking especially if you
have a very large code base and a lot of
a large ecosystem I think the back of
your mind is thinking about something
that I've been calling the cleansing
wave of fire you're in a cleansing wave
of fire situation when from the moment
that you begin your upgrade your entire
app is broken and nothing is going to
work until you've migrated all of it as
Tammy was saying earlier this is a
really painful situation to be in
you've got one codebase that's new and
shiny and all the engineers are excited
about working on it and they're learning
new api's and they're being very
productive and then you've got the one
that's actually in production that all
of your users are using that are filing
bugs against you come up with cool new
product ideas you want to launch them
it's a bad situation to be in
fortunately with polymer two we've taken
a better route we're calling it hybrid
mode hybrid code is code that works
either with polymer 1.0 or 2.0 at
runtime basically that just means that
uses none of the deprecated features
from 1.0 and doesn't depend on any of
the brand-new features that are only in
2.0
the other thing to emphasize is that
unlike the 0.5 to 1.0 migration polymer
2 is minimally breaking we did not
redesign everything just because we
could we didn't see this as a blank
check to rename everything we could
we really would try to do a very
targeted and deliberate upgrade and
furthermore we're here to help we're
gonna help in a variety of ways starting
with compatibility shims a compatibility
shim is a bit of code that either makes
an old API behave like a new one or
makes a new API behave like an old one
let's actually jump into some code so
this is a very minimal polymer 1.0
element should be very straightforward
it declares a tag and when that tag is
attached to a document it logs how would
you write this if you started from
scratch with a polymer 2.0 element it
looks a little bit more like this Rob
just walked you through a lot of these
changes so it should be fairly
straightforward we have a class
expression we declare the tag name using
a static getter and because not even
spec authors can resist a little bit of
bike shedding attached has been renamed
to connect it so back to one point now
what does this code look like if we
instead use the polymer 2.0 backwards
compatibility shims did you catch that
not a single line of code changed not a
single byte out of place this works out
of the box in both environments let's
take a look at another example
so in the shadow Dom v-0 specs if you
wanted to allow a user of your element
to inject content inside of your local
Dom you would use the content tag in
shadow Dom v1 that was changed to the
slot tag the slot tag is is nice it is
designed to be faster than the content
tag but it also has a simpler API and
that means that we can't really explain
how slow how content works in terms of
slot but we can't explain how slot works
terms of content so the hybrid mode is
actually the new syntax so starting with
polymer 1.7 you can start using slot in
your code today in polymer 1 and every
element that you migrate to using slot
is save time for your eventual polymer
2.0 migration so we're gonna do more
than just compatibility shims we're also
going to ship an upgrade er this is a
will be a node.js binary that is if you
were familiar with the 0.5 poly up tool
very similar what it will do is it will
take your code and rewrite it in place
too
to express the old concepts in terms of
the new so here I've got some code that
uses three different deprecated syntaxes
the first is a style tag outside of a
template tag in my Dom module the second
is this add apply with the parentheses
syntax which is not standard and colon
root which is standard but it doesn't
have broad enough browser agreement so
we're recommending that people move off
of it now keeping track of all these
different changes it's kind of a pain
and all of the changes are very
mechanical so you can just run polymer
upgrader
against your code and it will
automatically fix all three of these
issues there are a lot of issues that
are very like this that are very
mechanical very rote and that you really
won't need even need to think about very
much you'll just run the polymer
upgrader and it will take you to hybrid
or depending on how you configure it
directly to to point out we're also
going to be shipping an updated linter
you'll hear a lot more about that
tomorrow morning at the tools talk but
just to give you a bit of a preview take
for example this code in polymer 1.0 we
would encourage you to extend native
elements using the is syntax the is
syntax basically lets you extend this
attribute but you still extend this
element but you still get the parsing
and a lot of the native behaviors of
this anchor tag built-in because we
didn't get very broad
browser agreement one is well okay there
was one holdout we're recommending that
that you instead use composition like so
but to upgrade to using composition
requires some human time some human
attention it's not something that you
can do mechanically in a rote way so
instead we will give you a linter
warning to let you know that this code
is not compatible with hybrid you'll be
able to configure that winter with the
versions of polymer that your target
targeting to give you appropriate Lent
warnings underpinning all of this of
course is documentation we will provide
extensive documentation just as before
with all the changes that will be needed
along with some broader context as to
why and of course none of this would be
complete without testing today and web
component tester in a branch and soon on
master you'll be able to test your your
element or your app against both polymer
1 and polymer 2 with a single command so
what now what should you be doing or
what should you be planning to do as
part of your upgrade I think that varies
depending on your situation if your work
if you have a small project you really
probably aren't empathizing with very
much of this it's not a very nervous
scary situation because once it's at the
appropriate time you can just migrate
all of your code at once it's not that
big of a deal the cleansing wave of fire
isn't that bad if you don't have much
fuel if you have a library such as we
ship with the paper elements and the
iron elements we recommend that you ship
hybrid versions of your elements for a
while to support other users that are in
polymer one hybrid mode or polymer two
but it's really for the huge projects
and the very large organizations that
hybrid mode is really going to pay off
because you can start migrating any part
of your app at any time and we would
recommend the you migrate directly to
hybrid mode and then let that roll
across your your organization and then
when an app by app basis migrate those
individual apps from hybrid to 2.0 as a
makes sense for your organization
so I hope that that reduces some of your
nervousness some of your dread from up
the upgrading process
I've been Peter burns you can catch me
on slack and on github as richtek I'm
and I'll be around the conference thanks
very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>