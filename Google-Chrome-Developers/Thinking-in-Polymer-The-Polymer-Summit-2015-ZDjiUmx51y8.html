<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Thinking in Polymer (The Polymer Summit 2015) | Coder Coacher - Coaching Coders</title><meta content="Thinking in Polymer (The Polymer Summit 2015) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Thinking in Polymer (The Polymer Summit 2015)</b></h2><h5 class="post__date">2015-09-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ZDjiUmx51y8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right good morning everyone you guys
ready for the first tech talk of the day
awesome all right so my name is Kevin
Schaaf like Matt said I'm a software
engineer I work on the core of the
polymer library so I implement a lot of
the core polymer features and today my
talk is titled thinking in polymer and
really what we want to do is kind of
introduce the mindset that we the the
polymer team want all of you are using
polymer to be in when you're using
polymer to kind of help solve problems
in building your applications and I'm
gonna try and introduce some some
concrete concepts and patterns that you
can you can use to kind of you know make
the whole process of using using these
tools a little more concrete in your
head so first if you've heard us give
any talks in the past and in Taylor just
kind of drove the point home
you've probably caught on to this notion
that polymer is really all about
leveraging the Dom the document object
model as its framework and when you
first hear that it might sound kind of
kind of strange right and maybe we don't
mean it like 100 percent literally but
what we're really trying to say is that
the Dom actually has a lot of framework
type concepts just built into it just
sitting right there and so really what
we mean is that rather than inventing a
whole set of new concepts that kind of
ride on top of the platform what we're
gonna do is look to the Dom and use all
the good parts of the Dom the kind of
framework you type parts of the Dom that
are just sitting there before we invent
anything new and ask you to learn those
so what are those good points what are
the good parts of the Dom that that that
we like so first of all Dom comes with
it with its own component model this is
something we typically think you know we
need to go to a framework to get and the
component in the Dom is the element
right so a lot of times we use the video
tag as a good example of a really
powerful element that's hiding a lot of
complexity behind a really simple and
easy to use interface and that's what we
mean by a component model and the Dom
has elements you
this concept of an element with the with
a standard interface just sitting there
and by you know by dropping just you
know a simple tag on the page we can get
a lot of functionality I mean it's like
a whole application just sitting sitting
there hiding behind one tag Dom also has
a concept of data flow and I think we
kind of take this for granted but you
know if we go back to our video example
the way that we can think about data
flow in terms of elements is is we have
attributes and properties that that's
how we get data into our elements and
elephants can tell us when they have
data to send back to them through their
through their events so the the video
tag is gonna fire like a load event and
a time update event to tell us when
things change so Dom can has concepts of
how to flow data in in and out of
elements that that we can think about
leveraging and then finally elements you
know the the component model the Dom
elements come with their own declarative
syntax you guys know what it is it's
HTML right and it sounds like really
silly to point out like hTML is some
awesome thing because we take it for
granted we use it every day but think
about what hTML is actually doing it
allows us to encode a whole tree of
pre-configured elements in a human
readable format send it over the wire
and then a high-performance parser
that's sitting there in the browser is
going to you know slurp that up turn
that you know inflate that into a bunch
of live elements our component you know
live working elements without us having
to write like a line of script so hTML
is just sitting there and and we can you
know if we're using elements as our
component model we can leverage all of
these things together but until recently
the Dom has been kind of this this
walled fortress it wasn't extensible and
so you know while the you know the
people who invented the Dom you know 20
years ago you know in you know had all
of these concepts sitting there we just
couldn't really take advantage of them
until custom elements so custom elements
is is kind of the linchpin to to us
being able to kind of return to the Dom
as the framework because it really you
know by allowing us to extend the
vocabulary of HTML we can really kind of
opt in to using all of those those those
concepts that are just sitting
and this has real like tangible benefits
to you to all of us web developers it
means we have fewer concepts to learn
right I mean everyone sitting here in
the crowd knows how to write HTML you
know how to set attributes you know how
to you know set events and listen sorry
set properties to listen to events so
you know how to use elements already so
when we're using elements as our
component model you know we don't have
to carry around a whole nother set of
knowledge that we have to learn and then
custom elements become this Interop
interoperability layer because like any
web library out there today knows how to
work with HTML knows how to set
attributes knows how to listen for
events and inset properties the custom
elements that that we create are
naturally going to be interoperable and
reusable across a lot of different
projects and technologies and ultimately
this lowers sorry that this lowers the
the the lock-in for you by using an
interoperable standard as our component
model we're not locked into one
technology silo okay so if if DOM is the
framework and elements are our component
model what is polymer exactly right so
polymers primary mission is to help you
build custom elements . so like that's
our mission in life we want building new
custom elements to be as elegant and
productive and endeavor as possible
and when you're building in working with
with polymer elements they're really
just just dom elements and so you're
going to be using all of the same you
know dom techniques and idioms that
you're familiar with things like
attributes and query selector and event
listeners and that sort of thing but we
find and this is where we start as well
on the polymer team but we find you know
when you start building a lot of these
that that these primitives that you're
using in the dom can be a little tedious
and it ends up being a lot of
boilerplate code to do kind of simple
things and really what we're trying to
do is encode that into you know some
shorthand that you can opt into using to
really make building your own custom
elements a lot more fun and you you end
up writing a lot less boilerplate so
that's really a lot of what what
polymers is trying to provide
so you know hopefully you can see that
we're like super psyched about custom
elements right we actually think that
this is going to become the de facto
component model for you on on the web
because it's an interoperable standard
and you know I think it's pretty easy
for the casual observer to look at
custom elements and go yeah so this is
this is you know a nice new standard for
building new dropdowns and new date
pickers the new you know combo boxes and
that sort of thing but we actually see
custom elements is a far more powerful
tool so the polymer team we I mean we
actually started building element sets
you've probably seen them in the nice
material design said we actually have a
whole team of engineers who work on just
building elements you know because Dom
you know HTML needs a you know a lot
more you know a higher level of UI
components for developers to start from
but we don't just stop there we kind of
had a radical idea what if what if
custom elements were the only tool that
we needed to build applications right so
that's kind of what the rest of this
talk is going to focus on is is to look
at how we can take custom elements as
this really you know primary tool that
we can use in our tool kit to build not
just widgets and new date pickers and
that sort of thing but entire
applications all right you with me all
right so as we go through you know kind
of what we're gonna do today is is build
an app and we're there's basically like
three main concepts that we're going to
kind of leverage as we're going through
the app building process that would
really kind of help coalesce how we put
together custom elements into an
applications so the first one is
thinking locally and there was a little
confusion in the rehearsal yesterday so
if anyone looks at this picture and sees
like a guy with a giant mouth like
eating eating like a face size lollipop
that's not what this is you're gonna
have to like suppress that image from
your mind this is a guy holding a
magnifying glass up to his face okay so
so just try and you know you're gonna
see it a lot just try and push it down
okay so
so thinking locally why is this guy
holding a magnifying glass up to his
face well it's because when you're
thinking about you know using elements
to build an application you're not gonna
try and hold the whole complexity of the
application in your head instead you're
gonna break the application down into a
lot of little bite-sized pieces that
each do one job really well and you're
gonna give it a really well-defined
interface and this is how we keep from
getting overwhelmed when we're when
we're facing a really complex
application so next when we're when
we're thinking locally we're only gonna
kind of draw a box and look at one one
specific piece of the application at a
time and let all the other details the
application fade away then inside of
that element we can actually leverage
other elements to get to get the job of
that that element done and this is where
composition comes in so as we're
thinking locally about one element we're
thinking about what could I go to the
catalog what could I go to the shelf to
pull in you know even native HTML
elements to get the job done those
elements are going to go into the
private implementation of our custom
element into the shadow Dom kind of into
this this separate tree that that's
hidden from that from the user of the
element and we can compose them together
so we're thinking locally we're using
composition and finally the way that
we're gonna reason about all of the all
of the elements that are sitting in our
private our little private world of our
custom element is through the mediator
pattern so if you're not familiar with
the mediator pattern this is kind of one
of those classic Gang of Four software
design patterns the Wikipedia definition
goes like this so the essence of the
mediator pattern is to define an object
that encapsulates how a set of objects
interact objects no longer communicate
with directly with each other but
instead communicate through the mediator
all right so this is going to be a
really central central concept as we go
through so let's see what this actually
means in progress in process so kind of
abstractly we're gonna we're gonna kind
of break off one piece of the
application and we're just going to be
thinking about that
so we're that's gonna be our custom
element our kind of lens of focus next
we're going to use composition so we're
gonna go grab some some children we're
gonna put those in the private
implementation of our element and then
we're going to use the mediator pattern
two kind of media to control the
interaction of those elements and in our
in our private implementation and and
what does the mediator pattern kind of
mean in this context so it means that
the custom element it's acting as the
host of those of those elements we often
say these are the local Dom elements so
the host in the local Dom kind of have
this relationship and so all
communication between any of the
siblings in the local Dom will be
mediated through the host so you know
concretely this means that the host is
going to be configuring its children
with properties it means it's going to
be say using out a bit listener to
listen for events coming up for the
children and then deciding what to do
maybe it flows data back down to some of
the other children so this is going to
be kind of our primary one two three
step as where as we're going through
building an application and then finally
you know the last piece of the mediator
pattern is that while it while he's he's
the custom element is both kind of
mediating the control of the children
he's also presenting a common simplified
interface to the outside world for
end-users to use I mean it's very
classic you know object-oriented
programming you're hiding implementation
details and then providing an API floor
okay so these three pieces kind of work
together and and by hiding the the
implementation
you know once we're done implementing
that the functionality of that custom
element all the details fade away and we
can just think about using that element
as as another element just like the
video tag it's got a tag it's got an API
it's got events that it sends and we can
just think about it as an element from
there and then we can use that compose
it into another custom element and then
that cycle is just going to keep
repeating as we build the application
okay all right so let's go ahead and do
that let's build an app we're gonna go
through this kind of quickly it's not
going to be like a full syntax tutorial
what we're really going to want to do is
kind of try and focus on these three key
concepts so thinking locally as we're
building an element we're not thinking
about anything else around it we're
gonna be using composition and then
using the mediator pattern to to stitch
those together
okay so that we're gonna build is going
to look something like this
so it's going to be a little chat app
it's gonna have some threads on the Left
that we can select we can post some new
messages we have the message list and
it's got some non-trivial details like
this we can edit the the title of the of
the thread as we go alright so first
we're gonna think locally let's break
off one small piece of this application
so I'm just gonna think about this one
piece up here this toolbar that that has
the little pop-up that we can edit the
title right so I'm just gonna focus on
that and that's gonna become our custom
element I'm gonna call this an input
header element right so thinking locally
next I'm gonna use composition so what
are the things inside of that that guys
implementation that I need so first
we're you know we're gonna make it
fancier later but we're just going to
start with the key pieces so there's a
there's a div that shows the the label
the title of the of the toolbar and then
there's an input that allows the user to
to edit it alright so again here we're
using composition alright alright so
let's start writing some code to to kind
of codify this so hopefully through the
code labs and stuff you guys kind of
have a basic handle on what some you
know normal polymer syntax looks like
basically looks like this and the
template I have the the area where I'm
putting my private elements those are
going to go into the local Dom the
shadow DOM and then I've got a script
this is going to become the prototype of
the element and I can add add some
things there and then going forward I'm
just gonna show this shorthand here so
we can just focus on the key bits
alright so input header so probably it's
gonna want like to be able to set the
initial value of the label as it comes
in so we'll think about the label as
being part of its API and then when the
label changes we're gonna want to you
know initialize the value of the of the
inputs of the input value and the label
in the in the toolbar
okay so first what we're going to do is
is kind of build build this piece up
using some kind of more basic techniques
and then we're going to introduce data
binding
kind of towards the end to show how the
data
my name is really just codifying these
these techniques that we can do raw by
hand it's just going to do it in more of
a shorthand way all right so let's see
okay so first we're gonna make the label
part of our API so this is a kind of
polymer syntax for defining a label and
I'm making an observer for it and one
you know key thing to note is that in
polymer 1.0 defining an observer is just
shorthand for creating a setter on the
element for the label property and
calling the label change you know the
the observer function that I put there
so that's that's all that's happening
under the hood is that is that little
bit of shorthand some sugar for helping
you define a setter and in calling a
function and then when the label changes
I'm just going to propagate that value
to to my local Dom right so if we look
at this kind of back in context when the
label changes that observer is going to
run from the setter and we're just going
to propagate propagate the label to do
the children all right so it's pretty
straightforward again we're using the
mediator pattern here right the the
children in the local Dom are getting
initialized from the parents API right
so mediator better all right next we're
gonna want to allow the user to change
the title right so we're gonna want to
catch an event coming up from the input
I'll use the input event and then the
host is going to mediate that so the
host is going to be listening for the so
the custom element the input header is
going to be listening for the input
event from the input and then setting
that value back to to the host which
then can propagate it back to the
children okay so here I'm using polymers
declarative event handler syntax and
again this is just shorthand for calling
add event listener again these are all
the things that we kind of sugared as we
started building a lot of elements
you're like man it just stinks to like
write imperative code to call add event
listener and get a reference to the
thing you want to listen to so let's you
know let's just make all that easy so
this is kind of the shorthand that we've
added for doing that so on the
when the input event fires from the
input we're gonna call handle input and
then we're just gonna set the value from
the input back to the host and again
that's going to trigger the observer so
when the input value comes up sorry the
input event comes up we're gonna set the
value to the host the host label
property so this is the host the the
input header and then that's going to
trigger the observer to then send the
data back down do the children right so
this is kind of just the classic you
know instantiation of the of the
mediator pattern in polymer so we've got
an API coming in label and then that the
host the custom element is responsible
for getting that information to its
children and then listening for events
and doing you know what it needs to get
its work done okay
so again for a pattern that we're gonna
be using over and over this can you know
this is pretty clear it's very readable
but it can just be a lot of typing so
this is where we introduce polymers data
binding shorthand and the you know the
real key thing here so you know data
binding you know of late has gotten kind
of a bad rap it's got a kind of a
love-hate relationship with developers
right because well it's really
convenient it can hide a lot of the the
complexity of what's going on
and so the key thing to know is that in
polymer 1.0 the data binding system is
100% just codifying the thing that we
just wrote here so this notion that you
know typically the host is gonna have a
property it's gonna want to send that
down to his children and then maybe when
some events happen it's gonna want to
send that data back up to the host right
so the data binding system is really
just codifying well exactly what we
wrote here and we'll go through that so
first we can use polymers you know curly
curly you know mustache type annotations
in the template you know similar to
other other libraries and what this is
doing is say you know anytime the label
changes on the host set that to this
property on on the child and so it's
it's like almost literally just
replacing this code that would that we
did here right so by virtue of putting
those mustaches up here I can basically
just eliminate this code out of here
but really what's important to think is
by putting those things there you're
acting as the mediator you're you're the
host acting as the meteor saying when my
label changes I want to send it here so
it's you know one-to-one mapping all
right so then if we if we visualize that
again it's gonna look exactly the same
it's just that the it's it's the
bindings that are making the data flow
down rather than your own code again the
mediator pattern here
so finally it'd be nice if we can get
rid of this eve this event handler too
so if you kind of look what's
interesting is that the information that
we need it needed in the event handler
or this you know it's the same two
pieces of information that are up in the
binding right so we want to set the
value back to the label the only thing
that's missing is what event should
trigger it right and so this is where we
introduce polymers double colon syntax
in the binding and it basically just
allows you to tell what event should
handle the the reverse flow we can we
can put that right there in the binding
and that allows us to eliminate this
code altogether as well so now we're
back down to you know a very declarative
sorry and then you know if we walk back
through there you know my purpose in
showing this is that what's happening is
exactly the same the code that's running
is almost identical so when the event
comes up the the the the event that
we've that we put in the in the binding
is going to handle setting the value
back to the host and then the host
through the through the binding is going
to set the values back down to the
children right so again I just want to
keep resizing that polymers data binding
system is really just codifying this
mediator pattern and making it really
fun and easy easy to use all right so
what if we wanted so I started out I
started out with it with a raw input
here but you know we have some fancier
inputs in the catalog so let's say we
want to replace the raw input with a
custom element right so I can go to the
catalog and get this this paper input
which is really fancy when you click in
it there's a little you know label that
swoops up and you know it's a very nice
thing but it's a it's a custom element
built with polymer and you'll notice
that the the name of the event chain
here so again yeah using composition the
name of the event changed here instead
of the input event I'm listening for the
value changed event and that's because
if we go to the to the API documentation
for paper input it has a its value
property if you know fires an event
called value change when it changes and
this is actually another part of polymer
shorthand it's sugar for helping you do
this really quickly is if we look at the
implementation of paper input when it
declares its value property you can just
put this this notify true flag on and
that's just shorthand for saying when
the value on the host changes fire an
event so that anyone who's using me
knows that my value change and this kind
of helps helps reinforce the mediator
pattern it helps give us a nice pattern
for knowing when when data on the
children changes in the the host above
being able to do something about it and
when we when we when we're binding to
polymer elements because they all you
know all notifying properties in polymer
use this same event event syntax or
event convention the name of the event
we can just eliminate the the event name
from our binding so kind of throughout
the rest of the of the the day-to-day
you'll probably see a lot of you know
code slides that are that are just
jumping straight to this because it's
very convenient you know once you kind
of understand how the the underlying
internals work it's very convenient to
just use the the syntax which is kind of
codifying that that mediator powdering
the way that we reason about data moving
in the app all right so the last thing
I'm gonna do is go to the catalog and
just sprinkle some some more paper
elements in here because they look
really good and these aren't really you
know affecting the data handling in the
app at all it's really mostly just for
view and presentation and give give some
some nice effects so I've got a paper
toolbar I've got some icon buttons and
then what's key here is that the paper
menu button kind of gives you this
really nice pop-up accessible pop-up
behavior for free and so kind of with
that with just what we have on the
screen here we've kind of completed this
this input header so we've got kind of
our first element done and it's got all
that functionality that you see right
there really as a virtue of composition
so we're able to kind of pull in
elements that other people have created
that they give us some really nice
functionality
and then you know we've codified the
data handling in there in our bindings
using the mediator pattern alright so
let's kind of review what we just did so
we we started out thinking locally so we
broke off there's one piece of the
application we made that into an element
of itself we use composition right so we
went to the catalog when we found some
elements that we could use in the
private implementation to get this job
done so those went in there and then we
wired up the interactions using the
mediator pattern and exposed you know
itself to the outside world through its
API and the only API we need on the
impetus the title and so when we go to
use the input header kind of all that
complexity fades away we can just think
about using this as just a normal HTML
element normal element in the Dom and it
has a label property and then we can
compose this into the next element and
so on and this is really where the three
concepts kind of kind of loop back and
repeat on each other so by you know kind
of hiding the implementation detail and
just giving it a simple API at the next
level up all we have to do is think
locally about that element what do I
need to get done I don't have to worry
about input header anymore that's all
that's already done I just have to
interface with it through my API and
mediate the the data handling form and
then this cycle can just repeat over and
over and over as we're building me up
it's a bit like Russian nesting dolls
right so like you know inside one doll
you can just put another one inside of
that one can be can be more and more and
more
do you like my metaphor Russian Russian
nesting dolls I thought it was kind of
it was kind of unfortunate that I like I
googled Dutch nesting dolls and
apparently there's no such thing so I
tried to like maybe I could make them
look a little Dutch and I was there just
look kind of stupid so do we have do we
have
are there some Dutch people in the crowd
yes okay so this the Dutch masters there
didn't really fit with this attic of my
slide so I went for this
you get it yeah that's I'm gonna I'm
gonna prance around we call it Miffy in
the in the rest of the world it's 999
Jim yeah okay all right it's a Dutch
character for those watching on the
livestream
okay okay all right so we're we've
completed our input header here and so
we can move on to the next part of our
app so let's let's move to this this
this element we'll call this the chat
thread view and so when we start out
we'll think about kind of the data that
might be backing this application so we
might have an array of threads each
thread would have like a title and a
messages array and then each message
might have some some user and some text
so we'll think about kind of the thread
being the API to our element here so
we'll define the thread on our API here
it's an object it has the title and
messages property like we just saw and
next we're gonna use composition so we
just built that input header we're gonna
use it here so we're gonna compose that
in here again all we have to think about
is the input header and it's labels so
we're just gonna go and bind the the
thread title to our input header right
and so basically we're kind of done with
that piece so we can move on next we've
got the the list of messages that are
going to be in there in the chat thread
so again here we're gonna use
composition so someone has already gone
through the hard work of creating you
know a really high-performance element
that handles repeating templates of Dom
and keeping them in sync with data and
that's called Dom repeat and we ship
that just in the core of polymer because
it's such a useful element so I'm gonna
use Dom repeat I'm gonna bind our
messages array to the items array of Dom
repeat so again just going straight to
data binding here so when the thread
changes we're gonna propagate its
messages property two to Dom repeats
items and then Dom repeats going to be
responsible for creating one instance of
the template for each element in the
array and then keeping that data in sync
and then inside each template we can we
can put stuff so
I'm just gonna use a really simple paper
item I'm going to bind the text to them
of the message that the chat message in
there and I'm gonna bind that just to
the text content and then we're kind of
done with the the top part and the
message list the last thing we need to
add is the input that goes at the bottom
we're going to type in post new messages
so we'll make some room so I'm gonna go
back to the catalog grab that paper
input again it's pretty handy but
instead of using data binding here
because when you think when we hit enter
as a new message we're not really like
binding that to data we need to take an
action right we need to create a new
message and so here I'm just gonna use
our normal Dom technique so I'm gonna
add a add an event listener so I'm gonna
listen for the key up event again using
our declarative declarative event syntax
and in the handle input event handler
I'm going to kind of look for a key code
thirteen right the Enter key and I'm
gonna take an action based on that so
I'm gonna basically create a new
messages object and and push the push
that on to the the the threads and
messages array and just a side note here
I'm using polymers structured data API
so it's we provide some API in polymer
for allowing you kind of anywhere in an
element to modify structured data so
objects in arrays properties of objects
and arrays and and ensure that any
element that you've shared that with
using the data binding will be notified
of those changes and that structured
data system although the details aren't
is important it really leverages the the
exact same event system that we use for
for normal property changes alright so
with that we've kind of completed the
the chat list really just by composing
three things together we've got all the
functionality that we need and again you
know even though all the code fits on
the slide here you know it's pretty
compact when we go to use the element
again all that details just gonna fade
away and we can just think about using
this element as an element with it with
a thread property on it all right so
that's pretty cool okay so we'll kind of
round out the application here by
looking at the the chat thread list this
thing over on the left
and I'm just gonna skim through this
because by now you're probably getting
sick of me you see in the mediator
pattern and that sort of thing but it's
all gonna be the same concept so if we
think about the the API we're gonna take
the threads array in and then its job is
going to be to show a list of those
threads have some selection for it and
we can actually go grab a paper menu is
a nice thing that allows you to do
really quick selection of some stuff
that you repeat it out and then I'm
gonna use the array selector which is a
another element that helps us do
selection of an array and produce that
back out as a selected thread so again
the API of this element is just gonna
look like it takes a threads over again
and it produces a selected thread out
right so that's pretty simple and then
we're gonna go and kind of tie all these
things together so we'll go kind of up
one level so we're going up the the
Dutch nesting dolls and we're gonna tie
these together into an element called
chat view so it's gonna look something
like this I'm gonna take the chat thread
list that we just made we just skim
through we're gonna put that next to the
chat thread view right and then kind of
for the purposes of the app we need to
get some data in so for now we'll just
use a iron-ajax so this is another
element that we have that allows you to
do declarative Ajax saying just put it
in as an element and then that produces
a property response property I can bind
that to the host to the chat views
threads property bind that up to the
host and then the host can decide to
press that down into the chat thread
list chat thread list is going to be
responsible for selecting one of those
so that's going to come back up as a
selected thread property on the chat
thread view then I combine that back
into the thread and so here you know
it's very clear pattern that I'm really
just composing some things together and
then mediating how they how they hook up
in my this particular context so we'll
just go through the code really quick
it'll be really simple we have an iron
Ajax it's going to produce a response
property I'm binding that to the threads
property of the host then the host is
going to turn around and bind that
threads property into my chat thread
the threads property into the chat
Threadless threads that's going to
create a selected thread property so I'm
going to bind that back to the host and
then finally I can bind that into the
chat thread beam as selected thread and
with that we've sorry and then one last
thing just for the for the view I can
wrap this in a paper drawer panel which
gives us a nice left/right responsive
kind of master detail view layout that's
responsive down to mobile and with that
we've basically completed the
application you know and we've kind of
done all this functionality there's a
little more detail in the thread list
that I that I skipped over to kind of
fit it in the in the time for the talk
so let's recap what we did so we started
out we're thinking locally right we
created that input header and then
composed it into another element and
then and then we were just thinking
locally about that element we didn't
need to worry about the input header we
composed any of the chat thread view and
then that chat thread view just got
composed into another element chat view
right so by using this one tool we just
kind of keep doing the same pattern over
and over and we can get to increasing
levels of complexity and here we kind of
pose this as the app but it doesn't
really need to stop there we could we
could because this isn't although it's
an app it's not anything special at the
end of the day this is just another
element and maybe if the requirements
changed and we needed to say integrate
this app into something more complex
like Gmail it would just be an element
going into into our bigger application
right so really if you think about it
once you learn this one tool the custom
element how to use that tool it's really
the only tool that you need you can just
kind of keep using it over and over just
like the the Russian nesting dolls or or
the dust nesting dolls you can just keep
leveraging the same two old custom
elements over and over and over alright
so that's the that's the talk the the
code for the app that we just built is
up on github my name is Kevin
thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>