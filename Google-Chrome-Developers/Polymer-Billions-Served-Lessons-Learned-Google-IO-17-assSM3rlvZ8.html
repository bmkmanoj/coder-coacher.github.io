<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Polymer: Billions Served; Lessons Learned (Google I/O '17) | Coder Coacher - Coaching Coders</title><meta content="Polymer: Billions Served; Lessons Learned (Google I/O '17) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Polymer: Billions Served; Lessons Learned (Google I/O '17)</b></h2><h5 class="post__date">2017-05-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/assSM3rlvZ8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning everybody who is excited
for this 8:30 caffeinated polymer doc me
so fun fact about this title we came up
with it like a couple of months ago
because for i/o you have to do
everything in advance and billions is
true
you heard Rahul yesterday in the keynote
said that you know there's over 2
billion users of Chrome now every Chrome
has a chrome history or Chrome settings
that uses polymer so polymers are like
over 2 billion people which is kind of
Awesome but then like a week or two ago
somebody tweeted that they had just
deployed on every mcdonalds many screen
polymer so now we're literally serving
those billions get it mcdonalds serve so
yeah let's talk about it I'm Monica I'm
not older a fun Twitter and github and
Internet places and I work on Palmer I
work on polymer elements usually in
building things with polymer which is
why I really like giving this talk
because I'm kind of like you I'm a user
of polymer I complain whenever polymer
doesn't do the right thing for me
and this is quote from Woody Allen that
was like a shark it has to constantly
move forward or it dies and Woody Allen
the inventor of react we all know this
yeah and he said this this is true we
look at the web and it changes every
year we have web components we have
service workers it's always changing
this is also true of polymer polymer one
came out three years ago and it was
awesome but since then the platform
changed a lot and then the world changed
a lot and we've learned a lot of things
from you users of polymer about what you
wanted to do so polymer 2 also had to
change and what I want to do in this
talk is tell you a story about all of
the things that came from polymer 1 all
of the things that changed in polymer 2
and white actually means something and
whether useful for you in polymer 1 we
have this approach of like a
one-size-fits-all to the library we went
from proof of concept to production and
we basically filled in a lot of gaps at
the platform did in the house we made it
so that it was
really easy for you to make an element
this is what it looked like we had this
like one giant function that wrapped
everything would register your element
for you would create a prototype would
give you behaviors if you wanted
inheritance because you didn't have
prototypal inheritance it gave you a
like declarative listeners it gave you
host attributes it didn't matter if you
wanted all of these things it gave them
to you anyway and it didn't work for you
to have these things and it was awesome
and the reason why I had to do this is
because two four years ago the web
component standards were kind of a key
we didn't have a good vendor story
Safari was like definitely not into it
chrome was like yeah web components
Firefox was like sure we'll do anything
but like the spec wasn't really there we
didn't really how we didn't have an
agreement on this spec it wasn't super
clean some of the things were really
messy we didn't have any best practices
nobody had made a lot of custom elements
so but you have to maintain custom
elements we didn't really know what to
do so we made a thing but was really
easy to use web components were like
we'll see how this goes which means that
the basic use case for a web component
was really nice you could like take
Palomar out of the box spend a little
bit of time and bam you had like a
button you had a fancy input you had
anything you wanted the problem came
when you use polymer for a while and it
became this like advanced user and in
that case however I didn't really know
what to do with it if you wanted to use
it like a really big application or like
for example chrome setting it's only
ships it to Chrome and a lot of the
decisions that polymer or polymer
elements made or directed is like
filling in platform gaps
polymer elements use two ships a promise
polyfill if your Chrome settings and
you're only shipping things to Chrome
which definitely has a promise
implementation also shipping a promise
polyfill is really annoying and the
problem was that you couldn't like take
things away from polymer and this came
because we realized there's very
different needs when you're building a
library based on who your target is your
these are very different if you're
building like a leaf element something
like an input or a button that's is at
the bottom and gets used a lot
versus making like a giant view nodes
like the entry point in your application
that aggregates all the things these are
very different elements you have to
think about them very differently which
means the library has to be held very
differently
so if in polymer 1 we have this
one-size-fits-all everything is an
element is an element is an element in
polymer 2 we have this Alec cart with
the concept and I hate this Alec card
because Kevin used it and I has an
accent on it because I speak French but
they never put the accent on it so it's
really annoying that I have it here but
basically idea of polymer 2 is that you
get to pick and choose what you need if
you don't need something you don't pick
it you don't bring it in your
application so as part of the polymer to
release we did three things we updated
polymer Tunes of u1 specs which are
awesome having six classes they're
delightful we removed all the weird
abstractions from polymer one if you've
ever used fall number one all those like
polymers Dom calls that were there
because we have to like hack around the
platform you don't need them anymore
because the platforms here and we also
try to do this in a minimally braking
way and this was really important to us
because the cleansing wave of fire of
updating your application whenever a
library changes is really frustrating
for everyone so we wanted for like the
change from one to two to be really
smooth and again this is why it helps
that I work on elements and not corn
because Kevin and Steve would update the
library and be like we made these
changes and I'd be like you broke my
input and I have to use like 17 hours to
fix it and we're not going to do that
because nobody's going to want to do
that but what I want to focus on today
is these actual new changes that are in
polymer two that came from the v1 specs
but like all of the awesome modularizing
and features breaking that we did the
reason why we got to do this and the
reason why we were able to monetize
polymer 2 is because the platform caught
up the web component standard is really
awesome now it works everywhere in
Safari has a lot has a custom element in
shadowed our implementation never
thought I'd see the day but it's here
and we have an awesome cross vendor
story which means at the library we can
now take a step back and like focus on
how to actually help you solve problems
not on just like filling gaps and like
writing polyfills until the end of time
which means now you get to use the
platform you can make web components you
don't even need polymer but if you want
to use polymer we're there to like
empower you to help you do like solve
all of the we
annoying problems that you might have
and all the boilerplate that you might
not want to write one of the things that
we used to tell you in polymer I said
this so many times last year I don't
think I can even remember is do let's be
lazy in order to make your application
fast you have to use less of polymer you
couldn't like give back features of
polymer you just had to like be very
careful about using them and we didn't
want to make this mistake again in
polymer too so in order to we have like
an opposite very positive approach which
is do more if you need to when you start
with a custom element you start from the
bare metal you get HTML element you get
nothing if you need some sugaring or if
you need like declarative getters from
polymer then you can subscribe and be
like hey polymer help me with this thing
don't give me everything else I didn't
ask you for data binding just give me
the one thing that I asked you for and
that's exactly the entire like
methodology around polymer too and why I
think it's really awesome and the reason
why this works is because we now have
options
we split polymer into like these
individual mix-ins and these options
that you can basically subscribe to so
when we start off with an element I'm
sorry this is at the bottom you start
off with HTML element so this comes from
the spec this is a platform it's just
whatever you extend to make a custom
element and then on top of it you might
want help with something you might want
help for example with like declarative
getters and setters I personally don't
like writing getters and setters and
keeping all my attributes and properties
in this thing it drives me absolutely
insane on top of that you might want
help with stamping your template
templates are really nice and I'll tell
you all about it in a little bit but if
you got used to polymer 1 templates
polymer 2 also has templates in the same
way data binding is the thing that you
really don't want to roll on your own
it's really nice if the library helps
you with that and that's another feature
that we can we can help with and finally
all the declarative goodness that you're
used to from polymer 1 like declarative
listeners or like synced properties and
stuff like that these are all features
that you might want help and you would
expect help from a library like polymer
the really awesome thing about this
graph is first of all it's a rainbow and
second of all it corresponds to exactly
the mixes that we have in polymer so the
getters and setters come from something
called property accessors and then the
template comes from templates
damn it Sam's the template it's the best
name thing of everything and it was all
the ways to the top to polymer element
which has pretty much everything that
you are used to from polymer one the
other awesome thing is that because
they're individually split you get to
control the size of polymer that you
include in your application if you know
you're not going to need data binding
and you're not going to need like to
stamp your template or anything you can
just like take a 2 point 2 K hit that's
like the smaller than your header image
in your application so that's pretty
much fine even polymer element that has
all of the things is just 11 K it's
really small so what I want to do in
this talk and I think it's like I'm
really sorry today 3 because it's going
to be a lot of code but I want to tell
you exactly how you would use each of
these mix-ins because I think that's
really important so that's a whole power
of polymer 2 and I'm going to do this
with a fairly contrived example so I
have a button and every time I click it
you get a balloon and that balloon is
obviously an emoji because nobody has an
image of a balloon lying around that
legal will approve to use in this talk
and I have two attributes on it I have a
limit and I have a counter I want a
counter to be reflected so when I say
reflected I mean that if I update the
property the attribute is in sync and
gets updated as well I don't want the
limit to be reflected so if I when it
boots up I start up with a limit or not
but then if I update the property the
code considers this new value but it's
not going to be getting reflected as an
attribute you may do this for
performance reasons this is how a lot of
the actual HTML elements work so like
the native input element has a lot of
properties is not actually reflecting so
even though this is a contrived example
I thought it was like a sort of similar
thing that you might do in real life
so that's our element all of the code
that I'm going to talk about so that you
don't like take serious notes or
anything is at this URL so glitch is
this awesome new thing that the lovely
people from fog Creek put together it's
basically like a Jasmine on steroids is
a new developer environment where you
have like a client and a server they
give you like an express server and you
can have node modules and stuff and it's
really useful for demos like this and
the other awesome thing is that the it
generates a random name for a project
whatever but in my my random name was
aspiring chauffeur which I thought was
really appropriate
it's like driving you around on your
Polaroid experience so that's the link
go to and have fun with it you can like
clone it and remix it in whatever okay
let's get this going we're starting with
HTML element we're going to make a
custom vanilla a custom element with
vanilla JavaScript no polymer at all
there's two parts of making a custom
element we have to dislike define a proc
prototype which is what the element does
and then we have to tell the browser to
associate a tag without prototype and
that's what the custom elements that
define line does basically says hey
browser whenever you see my element I
really mean this actual thing and then
the next thing that the platform gives
you is a bunch of lifecycle methods
which are basically callbacks whenever
your element does something interesting
you get a constructor when you do it you
get something called a connected
callback and a disconnected callback and
these are whatever you attach an element
we append it to the document or you
remove it and then you get this awesome
attribute called change callbacks so
whenever you change one of those
attributes in the markup you get this
callback and the way this works is that
you subscribe to a list of attributes
you care about so something like a
counter and limit would be here the
reason why you have this list is because
you don't want to react to every single
attribute that changes so you specify
the ones you care about cool so here we
go this is most of the code in that
element there's like another getter and
setter don't panic we're going to go
through every line you know it's a lot
of code so the first thing we're going
to need to do is create a shadow root so
we can put our Skiles encapsulate them
be really awesome and you can do this in
the constructor you can do this in the
connected callback you can do whatever
you want in the connected callback is
where I do my rendering code and here
this render function it's basically a
giant boring function where I create Dom
in styles in JavaScript you could have a
style node and appended here I chose to
do this because I was lazy and terrible
this is not the greatest way to do it
but it's not cuz we're going to use
templates anyway and what this is doing
is just creating a button having a click
Handler on it that increment function
basically just adds one to the counter
until it hits the limit if there's a
limit it Styles the button what
it's just like normal Dom creation once
you're done with that we have the
attribute change callback here there's
like an interesting philosophical
problem you can pick a camp to live in
there's two ways you can do this you can
have properties or attributes be the
source of truth if you have attributes
be the source of truth you would do all
of your work in here and just like
customarily update the property just to
keep it in sync I prefer to keep my
properties visas our source of truth so
all I'm doing here is just updating the
property and doing all the work in my
setter and the reason for that is again
I don't want all of my attributes period
all my properties to be reflected so if
I did all the work here that means all
of my properties were reflected and
that's kind of lame it's also slower
setting an attribute isn't all free it's
it's actually quite expensive and
finally if you have properties be the
source of truth they get to have types
your integer can actually be to the
integer not to the string so when you
add one to it you don't get 21 balloons
like I did the first time I made that
element so here's our setter and as I
promised I'm going to reflect that
attribute if I want to and then I'm
going to call display and this is take a
moment here because this is the first
deliberate piece of code that I actually
wrote because up until now it was mostly
just like gluing things together and
like boilerplate and my render function
but what I'm going to do in display is
just take my counter and basically
repeat an emoji balloon all the time and
this is why images suck in emoji rules
because you can just enter HTML yeah or
text content if you want I like to
enable cross scripting there is here
cool but that's it that's my code I have
a display function it gets updated we
didn't need a library to do this this is
a small element but it was still a lot
of boilerplate code imagine if your
element is enormous and you have to do
this for like 17 properties you might
have that gets a little bit messy so
this is where polymer can help you so
let's do this again the same element but
with less of this boilerplate and the
first thing we're going to use is
property accesses remember property
accessors gets you basically get in
those centers they access your property
is good it
I just figured that one out right now
I've been using it for months great
never ask so this is the code that we
left off with this is what we had and
now I'm just going to like mangle it and
make it better
the first thing I'm going to do is
rather than extending HTML element as
before I'm going to extend property
accessors and it builds on top of HTML
element it's a mixin a higher order
function goodness JavaScript the next
thing I'm going to do is call this
enable properties function so this is a
little bit of a little bit of
boilerplate that turns on your
accessories and the awesome part about
is that you get to control when exactly
you're going to turn them on so we tend
to do it and connect a call back because
that's after all of your attributes have
booted up and as for vehicle change call
back has been called for your initial
stage so basically in kinetic callback
you're now ready
here's your element has booted up for
this initial attributes and you're like
sweet now make me getters and setters
and properties for them and then as a
result you also get this new call
backhauls ready which comes after
connected callback and after flush
properly enable properties has been
called so after all of your properties
have been set and this is where I can
now do my rendering so I can actually
boot up with my initial state with
properties that's awesome all of this
code about observed attributes and all
my getters and setters can now go away
because that's the work that polymer is
doing for me now and I'm going to
replace it pretty well and I'm going to
replace it when a thing called
properties changed so much like
attributes change this is properties
change the difference is that this is a
batch call so if you set like three
properties in a row you're not going to
get three callbacks you're going to get
a one call back that says hey buddy you
said three properties you want to deal
with this which is awesome because if
you're just going to call display over
and over again if I update both the
limits and the counter you don't want to
like call it twice you just get one
batch callback and here you can see that
I'm going to explicitly just reflect the
counter attributes but not all my other
at row all my other properties that I
might get a callback for awesome we've
already cut the code in half we're doing
great words and we've just added like
2.2 keys to it awesome we have one more
line of code which is a static function
on your class that basically says
polymer please pay attention to this
class and every time I have a property
of an attribute make a property getter
and setter for it so that's also a lot
of the sugaring that comes from polymer
until you hit polymer element is on
static functions on your class because
that basically what it does it has to
like not notice me notice me pay
attention to me which is great so that
was property accessors remember we got
it we got properties and attributes
being said and sync and like free
getters and setters the next thing we
get is template stamp because if you
remember my render function was really
horrible and you don't actually know
what this looks like it's a pile of DOM
and a pile of CSS maybe it's good maybe
it's not it's unclear but what I really
want to replace it with is a template
templates are awesome we use them in
polymer 1 templates are the fastest way
to stamp static Dom we really like them
also your editor understands them and
displays them as HTML and CSS so you can
actually be like oh yeah I see the
button it's kind of style and in this
the template is identical to what I had
before so the host it's the same styles
my buttons are the same styles I
literally just copied it into a template
I didn't do anything else the other
awesome thing about using template
stamps and polymer is that you get
declarative click declarative event
handlers so now rather than I could add
an event listener to my button button
dot add event listener a function and
bind it but why not let somebody help me
with this and this is an awesome way to
be helpful and much like in polymer one
template stamp also gives you items of
interest it's this idea that if you put
an ID on something in your shadow Dom
polymer will just like I cache that ID
and so you can access it by like this
dollar output again you put you this geo
you could query select for it and like
put it somewhere in your class so that
don't query select every time you need
it but this is an extra layer of
sugaring that is really useful and we
found people really liked sweet now that
we have this template we can like cut
off more code my entire goal in this
talk is to like start with a bunch of
code and like leave you with nothing at
the end this is how that's going to
progress so this is where we left off
the first thing we're going to do is
going to update this extension so we're
now going to extend
template stamp which uses property
accessors which uses HTML element it's
Turtles all the way down and then I'm
going to cut off everything that has to
do with rendering because again I'm not
doing this rendering my hand anymore
template stamp is going to do it for me
so I'm going to delete it and then I'm
going to replace it with if I can get
this click going in my ready callback
which remember I had from before I'm
going to append I'm going to append my
Dom so I'm basically going to get the
template from somewhere in my document
and you can use your favorite way to do
this and I'm going to create my shadow
roots and append by to my template and
this is going to create like this dot
dollar and everything for me and ready
and that's it that's all that I have to
do for a template scam so now I got to
like takeaways on render function and
take away they're like the awful part
about it and convert it into a template
yes the next thing and this is my
favorite part of polymer is property
effects which gives you data binding
data binding is my favorite because
everything just like magically gets it
except in sync and properties get
updated without me having to call this
dot this dot this dot all the time so
this is our old code and now it started
like hiding code away from you that
doesn't matter to make you feel less
scared 3:30 in the morning so I'm now
going to extend property effects and now
here you can see that like is no longer
Turtles all the way down because
property effects requires template stamp
and everything below it so it's just
going to do all of the all of the
turtles for you but property effects
also builds on HTML element is still a
mixin and I'm going to get rid of my
properties changed remember the only
reason why I had this properties changed
is because I wanted to keep my
attributes and my properties in sync and
also I needed to call that display
function that like reached into my DOM
and was like you need to put balloons
needs more balloons but if I have data
binding I don't need to do this by hand
that's the whole point of having data
binding so I'm going to remove that
function I'm going to again call a
static method on my on my class which is
going to do that reflection for me so
now we have this great reflective
property call that says if you see a net
of property cold counter also make sure
it's an attribute and keep these in sync
so I don't have to do that anymore and
now if we go back to my template to
actually use the data binding we use the
display method as before to like reach
into output and update it so what I'm
going to do instead is use data binding
inside of output which is going to call
the display function every time my
counter property gets updated and then
my display function is really easy just
says you know number of balloons I care
about that's it
is awesome we're like most of the way
there the only other thing we still need
is you know sugar and spice and
everything nice declarative properties
and property observers all that like
nice syntax that you're used to from
polymer one if that's the thing that you
want to use so this is a code where we
left off and look whole before we even
go to it look how like clean and
straightforward this looks I have a
constructor my element is floating up I
have a connected callback it's when
something gets attached ready is when
all my properties have been sent I care
about some observed attributes and I
literally have code to make this element
work which are the display and increment
functions nothing about this looks in
any way like boilerplate or weird but we
can still do better so I'm going to
extend polymer element now and this is
like a new kind of custom element that I
can extend and I'm going to delete
basically everything that was not code
that I deliberately wrote all I really
wanted this element to do was to display
balloons and increment every time I
press that button so that's what I
expect that element to do so I'm going
to cut away all this boilerplate and
then replace it with this properties
object that looks very similar to what
you're used to from polymer one I have a
bunch of properties I have a counter
property it's a type number so I can add
one to it really safely it's reflected
to an attribute it starts off at zero I
have a limit property it's just a number
don't really care about anything else
and that's it this was code that I
wanted to write at the next thing I have
to do is put a little bit of glue for
automatic template finding because if
you still remember in that already
function I still have to like find the
right template that I wanted to stamp
and I really just want polymer to
automatically do this for me and this is
what that's what the static getter does
it says look for the template called
like that the long-serving my element
Tagg and the way this works is by
wrapping everything in a doll module and
this is why it looks exactly like
polymer 1john module is a custom element
it has a template it has the definition
of the element and is going to glue that
template to the element that's being
defined kind of like in an awesome taco
in the polymer team we usually call this
like it looks like a taco because your
doll module is like the tortilla and
then you put all the goodness in it like
the meat and the cheese and not the
cilantro I'm one of those people
allergic to cilantro fluence is awful
which is why I want to show you this
awful emoji that is like 90% cilantro I
want to find the designer at Apple who
is like I've seen a taco before it has
cilantro and apparently onions that's a
fair like in California there's tacos
ever I don't understand it
so that's it that was our colored so I
just want to go through all the five
things again so that you know them
HTML mint is off the beginning property
accessors are how you get you know
getters and setters and keeping your
properties and attributes in sync
template spams lets you you know use
templates for stamping rather than awful
CSS in JavaScript or other awful
situations you might find yourself in
property effects is going to give you
data bindings and polymer element gives
you the properties block and declarative
observers and listeners and the things
that you're used to from polymer one and
the reason why I'm really excited about
this and the code that I showed you is
that I filled it with polymer to where
actually it's been saying this in
polymer one too but I think it's
actually becoming true and polymer two
that polymer is kind of like jQuery for
web components and not in the sense that
you don't use it anymore and you have
four copies of it that you haven't
forgotten you haven't remembered in your
site but in the sense that like it
actually helps you write things really
easily when jQuery came out Dom
manipulations were hard writing things
that worked on ie and Safari and was
there even a safari in Chrome were hard
and jQuery helps you with that you got
to write the same line of code and it
worked the same way everywhere and
Polaroid is that for you rather than
like letting you write all this
boilerplate if you want to use a library
you can do it and it's going to do all
the heavy lifting for you it's not going
to make decisions for you it's just
going to help you do whatever
you already wanted to do and the way
this works is because II six classes are
amazing and this is the thing that we
didn't is to have in polymer one you six
classes code looks like platform code it
doesn't look like weird framework II
code that you had to do so that your
framework works is just put the platform
1c to do look at this code that we this
is the last bit of code that we left off
with I have a class it extends something
that's inheritance that make sense I
have some getters or like some static
getters and setters they have some
objects I have some JavaScript it's just
a normal class it uses polymer but it
just looks like normal cone and the
awesome thing about inheritance everyone
is that we actually get elements
inheritance now which is the thing that
I've been asking for years so this is if
you want to extend from this element all
you have to do is just update what
you're extending so I can now have a
child element that extends from this
element that we've been working on for
ninety slides and it can update because
it's extending it it can update anything
so maybe I don't want to show balloons
every time maybe I want to show cats in
three times as many because obviously I
want more cats and balloons and that's
really easy because it's just a normal
class extension I'm just going to update
what that display function does and be
like this particular child is just going
to display a lot of cats and I can do
the same thing with the template I can
have the child have a specific template
and you can override the template
function that polymer uses to display
your template and be like listen polymer
you take whatever template my parent had
and shove my template at the end or in
the middle or wherever placeholder is
you control these things and this is
really awesome because I think these are
ways in which polymer really helps
elements in particular with it with
inheritance but remember we have like
these different kinds of elements that
we have to think about because everybody
has different needs and I think at the
bottom something like a leaf node would
be paper-checkbox paper-checkbox in
polymer one lived in a really hard space
because it has to be very performant
this is the chrome settings page and in
chrome settings they try to use
paper-checkbox
sorry chrome history actually and
basically for every item of history
paginate it
you had a checkbox maybe you're showing
100 checkboxes no matter how fast
paper-checkbox was it still wasn't fast
enough to actually render and not to
like cost the page extra second so we
couldn't make favorite checkbox fast at
the time because people would also
wanted like 17,000 features from
paper-checkbox
such as making it a tri-state so you can
use it in trees being able to style the
label via being able to control where
the label goes around the checkbox I'm
not making these out these are real
features that people ask for it is very
hard because we didn't have enough
control to both make it extremely fast
for one use case and extremely feature
'fl for another but the amazing part
about polymer 2 is that now we get to
control this paper-checkbox
can be one of these like vanilla custom
elements it needs to be super fast it
doesn't have any data binding it just
like has one bit of CSS maybe needs you
know property accessors but it probably
doesn't even need templates damn it can
be incredibly cheap and incredibly fast
and if you want to add features to it
you can inherit from it or you can just
like add features to it later but
paper-checkbox by itself can be super
fast now a different element paper input
is still one of these leaf elements but
it's really complicated and really
expensive it has to do everything the
native input is which is 21 different
things for the record and also has to
look pretty because the input element is
hideous so it gets to use more of the
sugaring that polymer can provide but on
top of that we have something like gold
credit card input and for the record I
had to blur that visa icon because
you're not allowed to show the visa I
find without asking for permission Thank
You Laura Cass but so gold tooth implant
looks exactly like that paper input
right let's go back to it and let's go
forward to it up yeah
it looks exactly the same it's just
basically paper imported with like an
extra icon and like a validation of your
credit cards
the problem is in polymer one we didn't
have inheritance so it's literally all
of paper input copy pasted into a
different element do you think gold
cesium foot has all the fixes that have
been going on for the last term paper
input no it doesn't it's really broken
this is very inheritance helps so in
polymer 2 we can now update the
horriffic
element and be like listen you're really
just a paper input with these two very
trivial changes and this is going to be
amazing it's going to make maintenance
awesome it's going to make these
elements actually beloved again I hate
them so much
I had to copy paste so much bone but
yeah this is how it helps element this
is really great and the final last kind
of elements that we were talking about
is this thing that sits at the top of
your application and has to just
aggregate a whole bunch of things this
is a bunch of elements from our shop app
and news article is basically like the
article that you're looking at and it
depends on like a whole bunch of things
the category that you're looking at the
page that you're on the routes that
you've been been set on in you could set
all of these properties by hand you
could have a listener every time like
the route changes you can go and like do
news lists lists equal something news
articles category for something you
could but you don't have to that's why
data binding is amazing that's why
polymer is really good at this so this
would be the kind of element that you'll
probably only have like one of them in
your application or a couple so you
could throw the kitchen sink at it use
all of polymer this would be totally
fine and it'd be awesome so these are
the ways in which polymer helps elements
but polymer also helps apps because this
is the other kind of target audience we
care about and we listened a lot to
people who are using elements in their
applications and were like what are the
biggest problems that you have so shadow
styling and style encapsulation is
amazing it's really really awesome if
you're making one of these leaf elements
that you want everybody to reuse in your
applications and not accidentally stomp
on their Styles that's a whole point of
it it's a little bit hard if you're
starting with this like monolithic
application that has like random CSS and
17 different CSS files and you're like
I'm going to go gung-ho on web
components and you might have a problem
with that because style encapsulation is
going to go a little bit in the way if
that's the problem that you have was
polymer to helps with it because again
everything is just a JavaScript class
you can just it's override and extend
things that are in the way so this is
what the not
thermal attach tom function from polymer
element is it creates a shadow root and
puts content in it if that's not a thing
you want just override it and say just
put my dominant and it's going to be
fine and this is great another thing
that we've heard that people might want
is define your elements just in script
and not depend on not depend on
templates and again this is super easy
you have a template function the
templates getter that polymer element
uses just replace it with rather than
fetching the template for you
automatically replace it with a string
or however you're stamping your
templates normally that's the thing that
polymer can help with it and all of this
works because yes it classes are finally
like you're amazing and we can use them
and they're here this is what the
platform always wanted us to do Yogi
Berra the inventor of functional
programming once said that when you come
to a fork in the road take it and I
think this fork in the road is web
components they're here and they're
awesome and they've given you this
promise that how you build an element
doesn't matter you can use vanilla
JavaScript you can use polymer and I
think it's really awesome and I really
hope that you take this fork with us and
start using web components also polymer
2 yay thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>