<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Developer Tooling for Web Components (Google I/O '17) | Coder Coacher - Coaching Coders</title><meta content="Developer Tooling for Web Components (Google I/O '17) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Developer Tooling for Web Components (Google I/O '17)</b></h2><h5 class="post__date">2017-05-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tKvNeNGmOtU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right hi everyone thanks for coming
I hope everyone's having a really great
Google i/o my name is Justin Finney ani
and I'm the tech lead for the polymer
tools team which means that right now we
are going to talk all about developer
tooling for web components so the
polymer tools team maintains a whole
suite of tools for web components
developers and users from linters to
test runners to an entire build system
so obviously we're going to talk a lot
about tools but tools weren't used in
isolation tools are used on things and
they're used to accomplish certain tasks
so we really can't talk about tools in
isolation either we have to talk about
all three tools tasks and thinks things
like web components obviously and
polymer but also progressive Web Apps
service workers testing the purple
pattern bundling offline es6 compilation
HTTP to push and something that's maybe
the hardest task for some developers
sometimes it's just getting started
so that was a lot of concepts and words
I just flashed up on the screen and
that's not even the complete list so
what does all this mean that we have all
these capabilities and responsibilities
to deal with well on the positive side
it means that the web is now a capable
application platform we can build
amazing and truly native app like user
experiences but all these capabilities
also means that there's a lot of
complexity to manage and this can be
pretty challenging
so this is where tools can help tools
can help make this manageable and they
can help guide you towards harnessing
these features effectively and easily
and so on the polymer tools team we
develop our tools with a few goals in
mind first we need to meet the unique
needs of web components users and
developers and when I say that I do mean
web components developers not just
polymer developers our tools are
designed to work with all
web components so these needs includes
things include things like linting in a
world of extensible HTML documenting all
of an elements API surface like
attributes and events and styling or
bundling HTML together for production
then we want to take advantage of the
new features the web platform has to
help deliver a great user experience and
a great developer experience features
like service workers native imports HTTP
to the template tag and so on next we
want to enable and automate the best
practices that the community and our
teams have been putting together to
develop and deploy great apps our tool
should guide you down the best path by
default and finally we want to make all
of this extremely easy our goal is to
make our tools as powerful as necessary
but it's easy to use as possible anyone
should be able to create a fast loading
http/2 pushing serviceworker enabled
offline capable progressive web app with
web components that delights their users
with a few simple commands and that's
where polymer tools come in so now let's
do a quick overview of the tools we
maintain and how they relate to each
other and some of the tasks that you
need to handle as a web developer here's
a little diagram I drew of how our tools
are put together our tools are organized
around a set of core libraries that are
tasks specific things like
initialization linting local serving
building and powering many of these
libraries is a static analysis system
built specifically for the web called
the polymer analyzer you'll notice that
these tools are laid out here roughly
chronologically in the order that you're
going to need them during development
and this matches your development cycle
from getting started into your editing
and running and testing cycle and then
through building for production so we
can take a tour of these functions in
the tasks they handle going through the
development process step-by-step let's
start with the polymer CLI since most of
our libraries are integrated and brought
to you via the CLI
the COI is our multi-tool for web
components and progressive web apps it
has a number of commands to help you
through all phases of development and we
put this tool together and we put
everything together into one tool to
make these commands easy to discover and
easy to use together and I'm very very
happy to say today that we released
version 1.0 of the polymer CLI earlier
this week after a year of development
this was a lot of hard work put in by a
great team of people and we think it
really helps web developers Thanks okay
so the CLI can be installed from NPM by
running NPM installed SG polymer - CLI
and this gives you the global polymer
command from there you can run polymer
help and get a list of all the commands
those are supported so I'm going to go
through the most important of these
commands but before I do that I want to
go over a couple of key concepts that
we're going to refer back to as we go
along things like the polymer analyzer
that I mentioned the app shell
architecture and the purple pattern the
first is the analyzer so I mentioned
earlier that our core libraries are
powered by the polymer analyzer the
analyzer is an engine that can parson
understand HTML Javascript and CSS and
it follows the imports between these
files to determine your entire projects
dependency graph and by doing that it
knows exactly what you use and where you
use it we then use this information for
linting building and generating Docs and
so on next is app shell architecture so
this is a pattern for structuring single
page apps so that they're well organized
fast and can be loaded incrementally
within our tools we break this down into
three special types of files the first
is a single entry point which is the
initial file that's loaded by our by the
browser the entry point bootstraps your
application and in client-side routed
applications it's typically code loaded
from many different URLs may be slash
home slash profile a blog post URL and
it has to be very very small because
this file might not be cached well
because it's served from all the
different URLs the entry point then
loads the shell and the shell contains
your common application logic may be
shared UI components like headers and
footers and menus but also the router
and when the shell loads the router
boots up looks at the URL and decides
what view to load and then we have
fragments fragments are usually these
lazily loaded views but they can also be
other lazily loaded components or
libraries together these pieces lets you
build an app where you load just the
file need just the files needed to
render the page the user is currently
looking at and last we have the purple
pattern this is a pattern that the
polymer team developed as a way to
describe how to serve and render
lightning-fast progressive web apps
purple stands for push your critical
resources render your initial route then
in the background precache the remaining
routes and finally as the user navigates
your app later you reload the routes
they go to on-demand either from the
cache or from the network and if we put
all of these concepts together we can
look in an example app structure so here
we have the app shell at the top which
lazily imports a couple of views which
then import the rest of their
dependencies and some of our tools need
to understand a little bit about this
structure so we let you describe it
pretty simply in a file we call polymer
JSON and we have fields for the entry
point for the shell and for the
fragments and then when we talk about
purple loading what we mean is that when
a user visits a particular view you want
to push all of the resources that view
depends on these ones highlighted in
pink here and that way they load as fast
as possible and then in the background
you want to pre cache the remaining
views in their dependencies ok so that's
the end of the key concepts now let's
get into the actual tools and let's
start off with you Nick command I'm
going to go to a little demo here and
pray to the demo gods
ok so switch to my computer alright
hello alright so I'm going to start off
with an empty directory here
and we're going to initialize a new
application with the polymer init
command so you see we get a menu year of
different kinds of templates we have the
element template the application
template the polymer starter kit and a
template called shop we're going to
choose the polymer 2 starter kit which
is a really good starting point that's
why it's named starter kit and you
probably didn't see there quick but it
created some files and now it's
installing all the dependencies with
Bower and this is somehow working over
the network so I'm really excited
alright so there you go it installed
everything we can look at the yeah yay
for the network so we can look at the
files on disk here it's kind of hard to
navigate there so we'll open it up in my
editor and we can see that it gave us
let's see a source directory this looks
like we have some elements it gave us an
index.html this is the entry point I was
talking about it just sets up some
metadata and we have our polyfills and
imports the app creates the app you can
see we also create a manifest for you
this is required for progressive web
apps so by default we're creating a
progressive web app for you we even have
a service worker down here and then as I
mentioned the polymer JSON file where we
describe our fragments so looking at the
files on disk is mildly interesting but
what you probably care about is looking
at how this template actually looks in
the browser so we're going to use our
local dev server with the polymer serve
command and that's going to start up a
server for us we're going to take this
URL here and copy it into our location
bar and here we have an app so this is
the polymer starter kit you can see it
has a number of different views these
are laser reloaded views so when I click
on them they're being fetched over the
network and if we open up dev tools we
can see here that the app is progressive
that's nice the menu turns into a drawer
and we can go into the elements panel in
introspect what the app created for dom
when it booted up so here's the main
application element so one nice thing
about web components being native to the
platform is that Chrome's dev tools now
becomes a web component to the
per tool because chrome understands web
components the dev tools understand it
too so we can see here if we drill into
the application element that we can see
the shadow verb so now we can see how
the internals of our custom elements are
put together and how they compose and we
can also interact with these elements in
the JavaScript console so dollar sign
zero would get us the last element and
printed on the console we can see that
this element it's not just a unknown
HTML element or a div or something like
that if we look at the constructor we
can see that is actually the custom
element class defined in our application
and because this elements groups there
we go because this element has an API
that actually lives on its Dom node we
can interact with it so notice how we
can change pages here we go to view one
and view to that's driven off of
property on the element and we can go
ahead and set that to view too and when
I hit enter here this is actually going
to change pages and change the view too
so dev tools now gives you you know a
way to interact with the structure of
your app as custom elements it can be
very powerful all right so that's an it
and let's go back to the slides there we
go so that's an it
you saw the built-in templates that it
has but we also allow you to install
third-party templates so this is based
on the yeoman generator and any NPN
package that starts with generator
polymer in it it's installed locally
will show up in that menu there and we
have some really nice templates that are
available on NPM one that has a custom
build so you can use gulp another that
doesn't even use polymer just shows you
how to use vanilla web components one
that serves you how to use redux with
polymer and another one that shows you
have to use the Vaadin elements and then
you can of course publish your own
alright next let's move on to linking so
linking is done with the polymer link
command and i have another demo for you
if we switch back over to my laptop
there we go awesome thanks so we can run
the polymer lens command and we can see
here
that well we didn't ship you a template
that hasn't errors so that's good yeah
yay so we can go ahead and make some
errors and see what the linter does but
seeing lint warnings on the command line
isn't that exciting what I'd rather do
is show you how we've integrated the
linter and the polymer analyzer into the
IDE with our set of IDE plugins so here
I've opened up the project and I'm going
to go into one of the elements that we
have this is the main application
element and so we can look around and
one of the features that our IDE plugin
has is hover over documentation not only
for JavaScript or for HTML so here I'm
hovering over Dom module which is a
built-in element and we can see we have
nicely formatted docs with syntax
highlighted samples so that's Dom module
we can come down to the main template
for the app and see we can look at app
header layout and get the documentation
for that so that's really really useful
when you're using elements for the first
time it's the one thing you might want
to do when you're editing is use a new
new element so we're going to use one of
our favorite elements here paper button
and hopefully you can see that on the
screen but we have a green squiggly for
a warning there and it tells us the
element paper button is not defined and
the plug-in knows this because we
haven't imported that element yet so we
need to go fix that we're going to go up
to the top of the file here where our
imports are and I'm just going to copy
this paper icon button import and change
it to paper button all right oh but you
see we have a warning here - this says
unable to find the file because I didn't
remove this last paper icon button so
let's do that and hopefully you notice
how fast that was the polymer analyzer
in the IDE plugins are built to
incrementally analyze your files so
we're not realising the whole project
here just the file we edited and now if
we go down to where paper button was
used we can see that there's no warning
and if we hover over it we get some
documentation so this will tell you how
to use the element and we can see that
there are some attributes here so we
might want to use one of those
attributes like raised alright so if we
start typing raised we see that we get
documentation for the attributes
including the data type and if we hit
return we get the code
for that too so this is a really nice
productivity booster for when you're
writing HTML templates okay so you're
using this new element paper button you
might be curious about how paper button
works and so we've also added jump to
definition if you hit f12 we're going to
be brought into the paper button
definition here this is actually in our
third-party dependency folder and this
even works for attributes so if I
highlight raised and hit f12 we're going
to go to the definition of that
attribute within that element so this
brings a really advanced level of IDE
integration even to HTML template
editing and this also works with all web
components not just polymer if you use
jf doc and your web components they too
will show up in your IDE this way okay
and that's the IDE demo back to the
slides all right so you saw some of the
features there we meant HTML and
JavaScript introduce errors and warnings
we have hover over documentation code
completion and jump to definition for
the warnings that we produce we have
undefined elements properties and
attributes will tell you about invalid
binding syntax and invalid HTML imports
we also have rule sets which we've
introduced recently so we have a polymer
one rule set and we have a polymer two
rule set we also have added this polymer
tool hybrid we'll set so in the polymer
team we tried to make it very very easy
to upgrade from polymer one to polymer
two and as part of making that
transition easy we invented this thing
called hybrid elements and these are
elements that work in either polymer 1
or polymer 2 and the way they do this is
by using that subset of features which
is available in both versions
so this linter rule set right here will
warn if you're using anything that's
only available in polymer 1 or
vice-versa so this should be a big help
when you're upgrading from polymer 1 to
polymer 2 the polymer ID plug-ins are
right now available for vs code and atom
and you can install them via the normal
methods for installing the extensions
and that does it for the winter
ok next move let's move on to serving so
we have a development server built into
the CLI we do this because when you're
developing from a local file system
loading things from the file URL
hits a lot of security roadblocks so
most people need at least a static file
server and we added a couple of
conveniences on top of that the first is
for reusable components so HTML imports
work a lot like es6 modules where you
have to import by path and the way we do
this is we import by relative path that
reaches up out of your package and down
into a sibling package that's your
dependency and so if you have a reach a
URL that reaches up out of your package
that might not actually exist so what we
do in poly serve is we remap everything
to look like they're siblings so that
you can access your dependencies without
having to do a build step the other
convenience we add for applications so
if you have a client-side routed
application with some nice URLs you
might have some URL with a long path if
the client can't handle but doesn't
actually exist on the server so rather
than sending a 404 or what we do is we
send back that entry point file that you
set up in your polymer JSON and it gives
that file a chance to boot upload the
router and handle the URL and try to
render that URL as it can and finally
we've added Auto f6 compilation so all
browsers these days all the current
evergreen browsers support es6 but we
also support some older browsers that
don't in turn support es6 like IA 11 so
what we do is sniff the UA string on the
server and if we detect that your
browser does not support es6 well
automatically on-the-fly compile all of
your JavaScript using a very standard
preset to es 5 and if this isn't working
for you for some reason chrome dev tools
can do some funky things and pretend to
use another browser be another browser
you can always set a flag to either use
the auto compilation or always compile
or never compile all right so that's the
server next let's move on to testing
everybody should be testing so we built
a test framework into the CLI and you
run this by running polymer tests and
this uses one of the oldest tools that
we have on the polymer tools team web
component tester and this is a series of
helpers that designed to make testing
web components more convenient so we
bundle in
popular libraries like mocha Shiloh -
and a few others just to make it
convenient to write tests and then we
also have this concept in web component
tester of HTML test Suites so because
custom elements lives in the Dom they're
often created by actually being in the
mark-up of your application and so it's
very natural to write tests where you
want to write actual markup to test how
your element operates right and so we
have HTML test Suites and then on top of
that we've added a declarative test
fixture helper called appropriately
enough test fixture so here we can look
at what an example of test suite looks
like and you can see that at the top we
set up our environment we import web
component tester and we import the
element that we want to test and then
next we have a test fixture and this has
a template with an element in it and
here we want to test the man attributes
that's a property in that element so our
markup contains the attribute and then
we were one when we run our test logic
we call the fixture function which looks
up the fixture by ID stamps it to the
document and then returns your reference
for the content of that fixture and then
finally you can run whatever tests logic
you need here we're testing that
attribute set on the element actually
reflects to a property so this makes it
very very easy to write web component
tests you can launch it with just
polymer test which will try to find
every browser on your system and run it
in all the browsers or you can choose
one browser with a - L option and this
will get the test runner started launch
a browser window which combines all the
results of all your test Suites into one
window and then gives you a fairly
standard report where yeah all your
tests pass and hopefully you have more
than two which I have here okay so a web
component tester if actually built on
the same web server as polymer serve so
this means you get those same
conveniences like packages being mapped
to siblings or the entry paul entry
point fallback routing for applications
and auto es6 compilations so that it's
easy to test on IE 11 okay
now let's get to building for production
this is the largest or most complex part
of the CLI that we offer and you do this
by running the polymer build command but
before we get into the details of build
I want to talk about some principles
that we have in the build system the
overarching principle here is that
builds are optional optimizations on
your project we want your project to
work as it is as source on disk and this
is so that you can have a really fast
edit refresh cycle without building so
one reason why we do this is because we
want to get out of the way we want this
to be fast but another reason is because
you might be using other tools that
require building in order to run your
projects like a compiler like Babel or
typescript or maybe a SAS or some other
processor so we don't want to have any
kind of conflict there so you'll be able
to use those and our tools don't have to
run also something that's kind of unique
with our tools is that we don't build
based on the file locations on your
system we don't build based on globs or
some complex configuration we built
based on the dependency graph so once
we're able to find the entry point of
your application we can find all the
files that we need to process in the
builds and our build system has a bunch
of built-in optimizations we want these
to be easy to use best practices for
progressive web apps so we have
minification bundling compilation and
then fancier stuff like Service Worker
generation or push manifest generation
and our build system forms a pipeline
somewhat like what you would use in gulp
in fact we let you use our build system
from gulp and the way it works is that
the files in your project come through
into the analyzer and that actually
discovers all of the files that are part
of your project it then splits them out
into your first party sources and your
third party dependencies just in case
you want to process those differently
and then it feeds them into an HTML
splitter we like to write scripts and
styles inline on the polymer team so
this lets us extract those out into
separate files so that they can be
processed per file type so then we go
into those profile type optimizations we
rejoin the split files that we created
and then finally we feed them to global
optimizations like bundling or
serviceworker generation
and we control all of this with the
build section of a polymer JSON file
here you're able to specify one to many
different builds that you can create
while you run the build command and we
have options for all of the different
optimizations here and they're pretty
simple you can just turn them on and off
and next up I'm going to run through all
these options and show you what they do
but while I do that I want to show you
why they matter why is it important to
run these optimizations what do they do
for you and in order to do that we're
going to measure we're going to measure
how long it takes to load an example
application after we've applied these
different optimizations and of course
for that we need a test subject and so
we're going to use the shop example
application this was a demo built by the
polymer team in order to show off and
prove out these best practices that we
determined are good for PWA s shop makes
a great example because it's a
full-fledged ecommerce site it has a
home page as product listing pages
product detail pages it even has a
shopping cart in a complete checkout
flow it pretty much does everything but
actually ship you the shirt and so we're
going to measure things in chrome dev
tools and I want to mention something
that's really really important if you're
using dev tools for performance
measurements and that's that your
development workstation
even your notebook is likely a lot more
powerful and has a lot better internet
connection than your users most
applications these days their users are
possibly mostly coming from mobile
devices and are on pretty bad networks
so it's really really important but if
you're going to measure in dev tools
that you turn on network and CPU
throttling so here I've chosen the
regular 3G profile which gives us 100
milliseconds latency and 750 kilobit per
second download speed and then very very
importantly I turned on CPU throttling
5x slow down here and this is important
because your mobile devices just can't
parse and execute JavaScript nearly as
fast as your laptop or desktop so before
we start diving into numbers we need a
comparison point here so I took the shop
application and I actually de optimized
a little bit and I made it so that it
early imports everything it's no longer
lazily importing the views so this is
kind of like a naive structure for
building an app and it doesn't have any
minification and it doesn't have a
serviceworker so I ran this through dev
tools and I got some numbers we have 5.9
seconds for first meaningful paint on
the initial visit and four seconds for
first meaningful paint on a reload so
we're going to apply some optimizations
one by one and see how well they do
against this baseline and the first one
we're going to do is minification
because pretty much every app does
minification you would be kind of crazy
to go to production without doing it so
this is kind of like the standard
optimization it's great because it makes
all files smaller and in our system that
splits apart HTML we also minify inline
scripts and styles too and so the theme
I'm going to go with here is that we try
to make all of these optimizations as
easy as possible to apply and so we have
a couple of options that you can add to
your polymer JSON which will turn
minification on for the different
languages and if we turn minification on
we can see that we've brought our
initial load first paint down time down
to 4.4 seconds which is 25% better than
what we started with so this is a
no-brainer that's a big advantage we
should definitely do that okay next
we're going to look at an optimization
we call insert prefetch links this adds
link rel equals prefetch tags to all the
entry points and fragments in your
applications and the benefit of this is
that when you're about to load of you
and it has a bunch of dependencies that
need to be loaded this tells the browser
upfront the entire list of what it's
going to load so it can download them
all in parallel this reduces a lot of
round trips that we would be required to
load a resource parse it find an import
load of another resource and so on and
so you can get some of the benefits of
HTTP to push by doing this not all of
them but some so this is good for
environments where maybe your server
doesn't support it and again this is
very easy to apply you just turn the
insert prefetch links option to true and
then we can measure with the results and
you see we've gone from 4.4 seconds down
to 3.1 seconds this is another 30%
improvement so this is a great
optimization that's easy to apply to
your project
next let's look at Service Worker
prefetch so service workers are a really
really powerful tool they're essentially
a background worker a network proxy and
a programmable cache but with all that
power comes very little guidance and
structure on how to use them
coding one of these by hand would be
very complicated in PDS so we auto
generate one for you and the one we
generate those two things first it pre
caches all the dependencies of your
application in the background so you get
very fast transitions when your users
navigate and second it makes your
application automatically offline
capable the way we do that it was we do
the same entry point fallback routing
that we do on our dev server if the user
goes to a URL while they're offline
that's not in the cache instead of you
know sending a 404 or a response the
service worker will send the entry point
which allows the router to boot up and
it to handle that URL and render the
view you went to again we want to make
this as easy as possible so you just put
ad Service Worker true and your polymer
JSON and if you do that you see that
well a first meaningful paint number
didn't really change it went from three
point one to three point two that's
basically in the noise is the same but
look at what happened to the first
meaningful paint repeat visit that went
from two point six seconds down to 0.9
seconds which is a 65% improvement there
that's huge and this is a benefit for
some of your most important customers
these are your repeat visits or your
signed-in users people who like your app
people who maybe have installed it to
the home screen and are tapping on the
icon and expecting a native app likes a
slowed experience may be faster than
native app actually sometimes okay next
let's take a look at lazy loading lazy
loading is not so much of a tool but a
technique but I want to talk about it
here because of how much work we put in
our tools to support lazy loading and
the idea with lazy loading is that you
only import what the current view needs
to render and you import everything else
on demand as you need them in a polymer
we have a couple api's to do this one is
the import href function which adds a
new HTML import to your document and the
other is the thing we've released
recently called lazy imports where you
can
claret of Lee described the lazy
structure of your application and if we
apply this to our other optimizations
you see that we've now brought down the
first meaningful paint number to 1.9
seconds and this is another 40 percent
improvement over previous and the first
meaningful paint out of the repeat visit
stays there Oh point nine lightning fast
so that's good and finally I want to
talk about bundling so here's where
we've taken care to play well with lazy
imports we do smart bundling so bundling
normally merges all your dependencies
into one bundle and then the more
advanced tools like us and web pack will
actually there we go I was promised the
shoutout well actually bundle things
into multiple bundles if they can detect
the Lazy structure of your application
so our bundle our bundle err is lazy
importer where it generates multiple
bundles depending on this lazy structure
of your application and the way it works
is by analyzing the dependency graph
here so what we do is we look for every
file what is the combination of entry
points that require that file to load
and then based on the unique set of
entry points that we discover each one
of those becomes a bundle and so now we
can get a very fine-grained bundling
that works well with your lazy import
structure no matter what your lazy
importing the only problem with this is
that it's possible to create too many
bundles and have a negative impact on
your performance so what we've added on
top of this is this idea called bundle
strategies and a strategy takes a bundle
manifests and it modifies it and returns
a new bundle bundle manifests and the
one we've included in the CLI has a
heuristic where it says if any entry
point is required by more than say two
or any bundle is required by more than
say two entry points it combines those
all into a shared bundle so you get one
per view plus one shared bundle and this
ends up being a pretty good option and
we also make this incredibly easy to use
by just simply setting the bundle
property to true in the polymer JSON and
if we apply this on top of all your
other optimizations we get our first
meaningful paint number down to one
point five seconds which is really fast
on the 3G network with a slow CPU and we
still keep that blazing fast Oh point
one second repeat visit time so
altogether we've had a 75% reduction in
first meaningful paint time or four
times faster all for just setting a
bunch of options to true okay so next I
want to talk about compilation it's not
really an optimization but it's required
for older browsers so with custom
elements we have this interesting
situation where custom elements have to
be es6 clappers but we support some
browsers that don't support es6 so on
one hand they have to be on 6 vs 6 and
on the other hand they can't be es6 and
let me show you why this is true when
you write a custom element you extend
HTML element this is a built-in class
very similar to array or map and when
you extend a built-in element you have
to have a real constructor with a real
super call so that the system can
initialize that built-in object properly
and when you compile a constructor to es
5 you don't end up with a super call you
end up with something like this where
you're calling the constructor the super
constructor like a function and if you
try to do this in a browser that
actually has that built in it'll throw
an error so again we have this thing
where custom elements have to be es6 but
you can't run es6 on my 11 so we try to
take care of this for you and your tools
in our tools and what we do is we
recommend that everybody write their
elements and distribute their elements
to bower an NPM or whatever as es6 and
then you only compile them if necessary
at the application level and this is
because the app is the place where you
know what browsers you need to support
what environment capabilities you're
targeting and so the app is the thing
that knows what compilation needs to
happen and the polymer tools help you do
this because since we're based on the
dependency graph of your project we can
compile all the JavaScript that's
reachable from your application so you
can create two builds one the cs5 one
the cs6 and if you have a smart server
you can serve es6 to all the modern
browsers and yes 5-2 browsers like IA 11
but not everybody has a smart server so
we've made it possible to produce
Universal builds that you might deploy
to a static file server like github
pages and we do this with something we
call the es5 adapter which patches up
the custom elements environment
on browsers that natively support it and
forces them to kind of accept us five
subclasses of HTML element and again we
want to make this extremely easy to do
so all you have to do in your build
configuration is set compile to true for
JavaScript okay so that's what Bill does
the minification bundling compilation
all the stuff and even though we've
tried to make each individual item here
as easy as possible to turn on or off
it's still a lot of things to understand
keep in your head and to configure so we
want to make this even easier and so
recently we introduced build presets and
we include what we think are the three
most common and useful presets for you
to use we have ef5 bundled for your
older browsers or for the universal
build we have es6 bundled for newer
browsers but maybe your network or your
server doesn't support HTTP to push and
we have es6 unbundled for that full
purple incremental serving and so this
is what happens to your polymer JSON
file when you use presets you can go
from specifying each one of these
individually to just specifying the
preset and again the theme here is we
want to make this as easy as possible it
shouldn't be difficult to build an
incredibly fast app even for emerging
markets okay so that takes us through
our whole development cycle from getting
started all the way through building for
production or does it you can't just
build for production right you have to
actually put your app into production
and so we're adding a new step to the
build chain now which are the tool chain
now which is targeted at deploying your
app and so now I'm happy to announce
that we have a new initiative that we're
calling a purple in a box and this is a
series of purple reference servers
they're smart servers that can do
differential serving and serve es6 to
the browsers that support it yes five to
those that don't and use HTTP to push
depending on whether the browser
supports it we're building out
configuration that's generated based on
the CLI your dependency graph for these
servers and we have initial versions for
nodes that works well on App Engine and
also for firebase
the note version is the first one we're
releasing it's in a preview state but
you can look at it now this works for
node and app engine and you can look at
it at the git github organization
polymer and purple desk server des node
and you can also install it right now on
NPM to send p.m. install purple - server
so the server is CDN and edge cache
friendly so even though it serves
different resources to different
browsers they all exist at different
URLs so they can so they can be cast
aggressively at the edge cache and it
also is designed to work with HTTP to
push proxies this is what App Engine
does where it takes an HTTP one server
and if you specify certain headers in
your response it'll automatically turn
those into HTTP to push requests all
right so now that really brings us to
covering the complete development cycle
all the way from getting started through
editing and testing through production
and that's basically my talk and if
there's any one thing I want you to take
away for this from this talk it's that
polymer tools make it really easy to
start develop and build with web
components and polymer so that you end
up with a fast purple enable offline
capable progressive web app and that
does it for me thank you everyone for
coming out</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>