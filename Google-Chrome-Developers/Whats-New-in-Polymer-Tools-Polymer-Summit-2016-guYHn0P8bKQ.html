<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>What's New in Polymer Tools (Polymer Summit 2016) | Coder Coacher - Coaching Coders</title><meta content="What's New in Polymer Tools (Polymer Summit 2016) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>What's New in Polymer Tools (Polymer Summit 2016)</b></h2><h5 class="post__date">2016-10-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/guYHn0P8bKQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright hello good morning everyone
thanks Monica and thanks to UM for
getting the day started and thanks all
of you for being here I hope everyone's
really excited for day two my name is
Justin Finn yani i leave the polymer
tools team and i'm really really excited
to tell you this morning what we've been
up to recently so yesterday you got to
hear all about the future of polymer and
web components you heard about the new
web component standards which are now
starting to ship native and browsers
like Chrome and Safari and you heard
about polymer 2 point 0 and how it
builds on these new standards and is
even smaller easier to use and more
interoperable with other libraries and
just like the polymer core library we're
also working on some major upgrades for
the polymer tools so that they work with
those new standards polymer 2 point 0
and so that they're useful for the
entire web components ecosystem in the
next 45 minutes or so we're going to
take a tour of our tools recover some
thoughts about why we build tools
updates on a few of the core tools in
our toolbox and finally a look at how we
actually deliver these tools to use so
you can use them let's start by looking
at why we build tools and why we even
have a tools team on the polymer team
the polymer team hasn't always built a
lot of tools in fact the core library
team is famously averse to tooling what
they and really probably most of us love
about the web platform is the immediacy
of working on it that instant edit
refresh cycle so their tools consisted
of basically an editor and a browser and
that's pretty much it components and
apps and tests would load in the browser
without any build step required at all
by not adding too many layers of
abstraction the hope is that there's not
as much need for a complex tool chain
but you almost always need at least some
tools and because we're using these new
platform features like custom elements
and HTML imports many of the existing
tools didn't quite work how we wanted so
first we needed a dev server that could
like easily serve up components in there
dependencies very easily and then we
needed a bundler that worked with HTML
imports and then we really wanted a test
runner that worked with our component
first workflow and could load multiple
HTML files and this need for tools went
on and on and on until we ended up with
this virtual kitchen drawer full of
tools and this is very very hard for our
team to maintain but much worse than
that we ended up with many many pages of
tools in our documentation and this is
hard for our users and it's especially
hard for users who are new to the
polymer and web components world so at
the beginning of this year we knew that
we needed to a dedicated tools team and
we knew that we needed to go back and
Riaan vision our tools as a cohesive and
organized sweet that's easy to approach
and understand and this was also a good
time to stop and ask a really really
important question why why is the
polymer team building tools in the first
place well the tools we had already
created didn't come out of nowhere like
most tools we built them because they
solved real problems but what kind of
problems will web development in general
as we all know has many many problems to
address and as we all know web
development has many many many tools to
address them but with polymer and web
components we have these new and unique
problems to deal with that the existing
tools don't address for one HTML and CSS
are now extensible understanding HTML
used to be pretty easy there's a fixed
set of tags determined by a committee
and tools like text editors and linters
could just build in a hard-coded
database of elements in their attributes
with custom elements this all changes
and now hTML is an open-ended set of
tags so how do you know what's valid
HTML anymore same thing with CSS CSS
used to be global and have a fixed set
of properties but now with shadow Dom
and custom variables CSS has scopes and
an open-ended set of properties knowing
what's available to use is a lot harder
now
there's also many different ways to
write an element already at the summit
you've seen a few we have polymer 1
point 0 polymer 2 point 0 is class
syntax its legacy syntax we also have
vanilla custom elements that don't use
any library at all and we have these
other web component libraries like
sketch a s bosonic x tags and reactive
web components and i'm sure a lot more
than i'm not even aware of and then with
HTML imports HTML files can now import
each other like libraries and modules
and other programming languages this
ability for HTML to form a dependency
graph is completely new to web
development tools in existing bundlers
and winters and minna fires they just
don't know about this new structure of
HTML and so we can notice something
about all of these problems they're not
polymer specific they apply to web
components in general and this brings us
to a really really important principle
that we have on the tools team the
polymer tools are not just tools for the
polymer core library there are tools for
web components in general our goal is to
help all web components developers and
users I think this is something really
really unique to the web components
ecosystem but because of the inherent
interoperability of web components the
success of any one web components user
or library is a success for us all
because together we grow this entire
interoperable ecosystem so this is one
major motivation for tools to solve
problems that are unique to web
components but at the same time that
we're in the midst of this web component
sea change other parts of web
development ours are evolving as rapidly
as ever there are a whole slew of new
technologies and expectations that are
drastically changing the way we build a
web apps and especially mobile web apps
to offer a truly great mobile experience
apps now have to have what was until
recently a fairly sophisticated
structure supported by a sophisticated
tool chain on the polymer team we've
been trying to codify these best
practices into a pattern that helps you
craft an optimal loading experience and
we came with it up with this acronym
that you've heard about
purple prpl and that stands for push
render precache and lazy load purple
involves things like using HTTP to push
to push exactly the resources needed for
a given route service workers to pre
cash and apps resources and / route
bundling when push isn't available these
techniques are critical for engagement
and to compete with mobile app with
native apps and tools can help make this
manageable the goal of even defining a
pattern like purple is to make it easily
repeatable and repeatability is
something that tools are really really
good at so this is another motivation
for polymer tools we want to take these
cutting-edge techniques and make them
standard practice we want to make things
like optimal loading and offline support
the default when starting any new app so
that's why we're building tools this is
what gets us to work in the morning
let's look at what we actually build our
tools are organized around a set of core
single purpose libraries like the
project initializer test runner and the
build system these tools each address
this problem along the lifecycle of a
project from getting started all the way
through building for production and then
we take these tools and we integrate
them all and deliver to them deliver to
you them to you in the polymer CLI and
then powering most of these tools is a
common analysis engine that allows our
tools to really understand your project
now let's take a look at that engine
that powers our tools a few months ago
we embarked on a project to build a new
and flexible static analyzer for the web
which I'm really happy to talk about for
the first time it's called the polymer
analyzer the analyzer helps other tools
understand applications and components
in this new extensible world
applications made up of many different
types of files using new elements and
written in different libraries its job
is to dig into this complex graph of
resources that make up an appt find and
extract important features like element
definitions and HTML imports and then
provide a convenient API for our other
tools to operate on this structure
and it does this all with plugins so
that the analyzer can be extended
without changing its core implementation
the analyzer comes with several parser
plugins so it understands HTML
Javascript CSS and even JSON and in the
future we can add support for additional
languages like typescript it also
understands many different ways of
importing files into each other like
HTML imports in line and external styles
and scripts and soon it will support
native JavaScript imports and it has a
large set of plugins to support
different ways of writing custom
elements like Paulo ER and vanilla
custom elements so when the analyzer
processes a file it parses it with one
of its parser plugins here HTML and then
it scans the document looking for
important features with its set of
scanner plugins for instance we have an
HTML import scanner and add-on module
scanner that can find add-on module and
parse the templates in them and then we
have a polymer element scanner which can
find a polymer element declaration and
find important features of it like its
properties next the analyzer parses and
scans any imported and inline documents
until it's analyzed everything in your
application so here we have an import
that's importing another file and the
analyzer finds that and then finally the
analyzer can resolve references between
features and really understand what's
going on and here we know that this tag
is an instance of a definition in
another file the analyzer extracts a lot
of information about elements it
understands this basic API its
attributes properties and events it
knows how to style an element it knows
about its prototype chain its superclass
and mix-ins and it knows how to use the
element to how to import it and it can
get its documentation and then this
information is available to all the
other tools that build on the analyzer
as part of the analyzer work we're also
adding a new feature to help our tools
better understand app shell style apps
that use lazy importing we call this
declarative lazy HTML imports the
analyzer in his plugins work well
because of the declarative nature of
HTML
polymer the more that your application
is declarative the more that we can tell
what it's doing without having to run it
but lazy imports today use an imperative
API that trips up static analysis if we
take a look at a typical app shell style
app we usually have a shell that's
loaded before rendering it then
dynamically loads the code needed for a
particular route to actually load a
route you almost always see a snippet of
code like this this is a method that
takes a page name and then it loads the
associated HTML import with a page with
import href but our tools don't
understand this imperative code and so
you get problems like linter warnings or
maybe the bundler might miss some files
declaratively the imports allow you to
specify the imports you will load right
in your markup lazy imports are like
link tags like HTML their link tags like
HTML imports but they use a different
realm attribute and they have a group
name when it's time to actually load an
import you do it by group not by URL and
we provide a behavior to help with this
and by using group rather than URL tools
like the bundler can change URLs around
without breaking your code and by being
in markup tools like the analyzer in the
linter can see these lazy imports and
know that you're going to import this
URL in the future so you can try out
approve preview of lazy imports today
the works of polymer 1 point 0 we'll be
adding polymer 2 point 0 support pretty
soon and doing a real release and before
I finish with the analyzer let's talk
really quick about linting because it's
such an important consumer of analysis
information we're rewriting the polymer
linter right now on top of the new manna
lizer and this is going to bring some
nice improvements to you very soon the
existing link command in the CLI is
already very useful it checks things
like you declared properties that you
use in data binding or that the elements
you use are actually defined and
imported but the current linter has a
hard-coded set of rules that only works
with polymer 1 point 0 elements and like
I just talked about it does it doesn't
work very well with lazy imports so
because the new analyzer is powers the
linter it understands all the different
types of elements that the analyzer does
not only that but we're making the
linter itself extensible so that new
linting rules can be added by users this
is especially important for internal use
at Google and for our enterprise
customers who often have stricter
policies they want to add an enforce
we're also adding rule sets which we're
going to use to offer different linting
modes like a polymer 1 point 0 mode a
polymer 2 point 0 mode and a hybrid mode
choosing the right rule set will make
sure that you're only using the features
that are available in the specific
versions of polymer that you're
targeting so the main inside of the
analyzer is that web applications are
not just HTML and they're not just
JavaScript they're built from many types
of files and many ways of importing them
we might have HTML Javascript CSS images
and more and so we can't rely only on
JavaScript tooling or only on HTML
tooling we need something that brings
them all together which is exactly what
the analyzer does and then we can do
some pretty awesome things with the
results the new analyzer is key to our
goal of supporting many different tools
and many different web components
library if you use or write a web
components library we encourage you to
get in touch with us so we can help you
write plugins for the analyzer and if
you write tools or interested in using
the analyzer please get in touch with us
so we can help out as well it's still
very early the api's aren't completely
finished but we want to launch with
support for as many web components
libraries as we can alright so let's
next talk about package management yay
all right as you all know we use Bower
to distribute all of our polymer
packages and Bower works really well for
us actually but the ecosystem has been
coalescing behind NPM and many of you
have asked for npm support so that you
can use a single package manager and
there's even an infamous issue on our
github repo issued 326 published
sub-projects on NPM and add them to
package.json if you can see the small
text there this issue was open almost
exactly three years ago
day and it has 202 lively comments on it
now n pam support it turns out it's much
harder than it seems at first and while
we haven't solved this issue yet i don't
wanna get your hopes up we're not going
to announce npm support right now um
yeah i'm sorry but we did come up with a
plan at least and i want to go over that
plan and i want to talk about some
really really awesome progress that's
been made recently so the plan look like
this the first thing we want to do is
publish raw packages to NPM so not make
any changes to them we generated
package.json files from our bow j sounds
and we just threw them up on NPM and we
said if you can figure out how to use
them let us know we knew there would be
some problems especially because NPM
installs things possibly anna nested
structure and that's difficult for us so
the next step was to find or build a
flat package installer something that
might take an NPM installation and
flatten out all the packages and then
step 3 we needed to build a hour plus m
p.m. release tools something that
smooths out some differences between
Baron NPM packages and then actually
tries to install and test our packages
from both Bauer and M p.m. so that we
can make sure that we push working
packages to both repositories and
finally once we have all that and we
know that you know you can trust that
when you install something from NPM or
Bauer it's going to work we're going to
publish all of our working packages 10pm
so step one we did a while back and we
publish things as is to NPM and like we
suspected people weren't able to get
them working that easily so we started
working on this design for a flat
package installer along with everything
else we're up to at the time when
Facebook got in touch with us and gave
us some really really really awesome
news and that also news was yarn which
you might have heard about so they were
working on this new package manager
which uses the NPM registry and they
asked us what we would need to use it
and so we started working with them and
gave them requirements the filing issues
and we were a little busy to submit
but they were very happy to add the
features that we needed and we've got
yarn to do the one thing we really
really needed which is flat installation
with proper version conflict resolution
this is huge for us and not only that
not only can a user say they need to
install things flat but a package can
say that it requires a flat installation
and this is what all our packages are
going to need to do because they won't
work if they're nested so this finally
makes yarn a viable replacement for
Bauer and it really unlocks our NPM
support plan step 2 there was by far the
most difficult thing and the arm team
basically did it for us so now we can
move on this is where we're at now we
can build this release tool which is
going to change some small differences
between Bauer and mpm and then we're
going to be publishing everything to NPM
although you have to use yarn to install
them yarn is a really really big deal
for us for mpm for the entire front end
development community we're super
excited I think some of the yarn team is
here today we're very excited to
continue working with them and make sure
that it works great for polymer so this
is our plan for EM p.m. stay tuned we'll
have we'll have news on this very soon
alright next let's talk about bundling
and code splitting alright today we're
announcing a new version of our
vulcanized bundling library and we
renamed it to simply the polymer bundler
bundling your code is extremely
important to reduce load times of your
application before HTTP to serving many
small assets files would just cripple
your apps loading performance but even
with HTTP to bundling can be important
to squeeze out every last bit of
bandwidth and sharted bundling or
sometimes called code splitting which is
creating more than one bundle for your
app is increasingly important to make
sure that bundling doesn't actually work
against you by increasing your load
times because you include too much in
your bundle but sharding can be a bit
complicated there are lots of different
ways to break your code into shards and
different options are suitable for
different applications and different
environments the polymer CLI supports
sharting and it makes it really easy to
do bundling with a good general sharding
strategy and this is powered by
vulcanized today but vulcanize itself
doesn't do sharting so we had to add
this logic on top of vulcanized that
called vulcanize over and over again for
each bundle and this was slower than it
needs to be and it wasn't very flexible
so now we're taking that bundling logic
of vulcanized in the sharding logic of
the CLI and we're combining them into
the polymer bundler and along the line
we're teaching the bundle or some new
tricks so that it can produce much
better shards in many different
scenarios to understand what the bundler
does and how it works let's imagine a
simple apps shell style app with a shell
and three lazy loaded routes the show
always loads first and then based on the
URL it dynamically loads the appropriate
entry point and these entry points all
have dependencies some of them shared
between entry points and then usually
there's some dependency kind of like
polymer that are shared by just about
everything and so the trick in say a
purple app is to only load what's needed
in a given route and this ensures that
your route loads as fast as possible but
the trip the the challenge when bundling
is to not bundle way more than is needed
which would accidentally slow down
loading so what we've done with the new
bundler is make it strategy for bundling
and splitting your app pluggable and
we've made the default strategy
configurable with a single parameter
that can control the number of shards
that you get the way that we calculate
bundles is to build up this table that
map's files to the unique set of entry
points that use them and this is already
one way that you could bundle your app
where each row is a bundle but this is
usually far too many small bundles to be
useful you might end up with a bundle
for every possible combination of entry
points so this is where strategies come
in the bundling strategy takes this fine
grained bundle plan and modifies it one
strategy could simply be to merge
everything together in one huge bundle
and that's what vulcanized us and the
strategy the CLI currently uses is to
bundle everything that's used by more
than one entry point into one shared
bundle and then bundle everything else
into a bundle with it one entry point
that uses it this is what it looks like
in the CLI you end up with one shared
bundle for the shell the common
dependencies and then you end up with a
bundle / route this is usually a pretty
good approach but in a really big app it
can result in a really big shared bundle
which basically defeats the purposes of
charting so we made this strategy
configurable by allowing you to set a
threshold and only if a file is used by
more entry points than that threshold is
it put into the single shared bundle
otherwise it's put into a bundle just
for its unique set of entry points so we
think this is a way that lets you easily
go from one bundle to one shared bundle
to many bundles depending on the needs
of your application and then if you have
even more custom means you can write
your own bundling strategy so we're
going to be rolling out the new bundler
very soon in an upcoming release of the
polymer CLI and we'll keep you posted
through the usual channels okay speaking
of the CLI it's up next on our tour
the CLI is the gateway to our tool suite
it's the first and main tool that most
polymer developers are going to directly
experience we announced the CLI five
months ago at Google i/o as part of the
polymer app tool box and our main goal
was to help you build progressive web
apps and purple pattern apps and we
wanted to offer a turnkey out-of-the-box
experience that automatically produced
extremely fast loading and rendering
apps that took advantage of things like
client-side routing lazy loading push
pre caching and worked offline and the
CLI helps you build apps like that by
default we also wanted to use the CLI to
solve two very big problems we saw with
our existing tools discoverability and
ease-of-use because we had built up a
set of many many separate tools over
time it was difficult for our users to
find everything they needed and it was
often hard to use these separate tools
together so the CLI solves this by
including everything in one install and
by integrating the tools ensuring that
they all work together so to talk about
that let me bring up my teammate Fred
shot he's going to talk about the CLA
everyone all right I'm gonna start by
stealing a line from Peters talk
yesterday is everyone feeling excited
let's try that again is everyone feeling
excited yeah does anyone feeling
overwhelmed so we won't fill in a little
dread well the CLI is going to help make
that all better because the CLI is our
gateway to the tool suite it makes using
all these tools in developing with web
components faster and easier so I'm
going to give an overview of its five
different commands real quick and we're
going to deep dive into one of those to
show how the CLI fits with our greater
tooling ecosystem so five commands the
first one is in it and it brings custom
templates right into your project to
help you get started so let's say you
have a great idea for a new element this
thing is going to be huge it's gonna get
thousands of stars on github Rob's gonna
invite you to do a poly cast this
thing's going to be awesome well you can
get stuck creating your environment
setting up baauer setting up mpm setting
up your tests or you can just run in it
element and it brings a custom element
starter template right into your
directory all automatically we also have
a starter application template same
thing really bare bones to help you get
started or if you'd like something a
little more feature complete we have
polymer starter kit which is a
progressive web app already configured
to use cool navigation using app drawer
and a lot of other goodies so these are
all really cool templates that help you
get started quick it comes with four
bundled with a CLI in total but my
absolute favorite part of this command
is that you're not just limited to those
four you can actually create your own
templates publish them to NPM and share
them with the community and so we're
already seeing a ton of community
templates pop up for working with
internationalization es6 Google App
Engine all of these are custom templates
built by the community and usable by
anyone so we've only really been talking
about this for
months now and already we're seeing
templates pop up so thanks to you guys
who've created them I can't wait to see
what we do in the next you know months
years to come so that's an it serve the
surf command will create and start a dev
server for you automatically so you can
see your code in the browser while you
work on it no configuration necessarily
it's built for web components and does a
lot of good stuff to help you develop
quickly Lin Lin's your project helps you
catch errors fast test helps you test
your code by setting up a dev server to
automatically run your tests in the
browser right from the command line and
build helps you build a web app for
production and these five commands
together represent an entire developer
workflow and it helps you get started
serve lint and tests help you develop
your code quickly and build finally
helps you get a web application out to
production users so the analogy I like
to use for the CLI is that it's like
your Swiss Army knife for web components
it's simple it's easy to use and it's
always available to you in your project
so each of these commands is worthy of
its own talk but I'm going to focus on
build so I can show how the CLI relates
to the rest of our tooling ecosystem so
let's talk about it build takes your
project and processes it to make a
optimized web ready version of your site
ready to deploy so what do I mean well
alright yeah this is it making your
website it starts with your project and
the first thing it does is pass it
through the new analyzer that Justin
mentioned earlier and this lets us do a
ton of cool stuff in the build process
for example it can analyze exactly what
files and what dependencies you're using
and filter out all the other ones that
you're not and so this resultant builds
that are about 96 95 we saw percent
smaller than your actual development
directory by filtering out all the
unnecessary stuff in your component
start
nc's directory it does a ton of other
cool stuff in the build pipeline which
you'll see in a second the next thing we
do is optimize your code so we minify
your code we can run your JavaScript to
babble we optimize it for production use
and older browsers next we bundle your
code and so we combine files together
based on the analysis that we did
earlier so we combine them where we can
to reduce the number of requests that
your users need to make and then we
generate a service worker for you again
because of the enamel analyzer we know
exactly what files you need to pre cash
on the browser to get an offline
experience for your users and that's it
so with a CLI you get this full build
pipeline from start to finish already
configured and ready to use and so we
launched this and it was great people
are using it they were using on their
projects but we started to get a lot of
feature requests and it turns out people
like to customize their build process
who knew and so we could have kept going
and okay add new features and new
options and new options for new features
but we had to take a step back and
remember that we were working on
something that was simple and easy to
use and we were doing that but we were
kind of leaving our advanced use cases
more complex apps out in the out in the
rain and if we kept adding feature after
feature to try and help them as well we
wouldn't have a simple Swiss Army knife
we'd have something like this and this
is probably the best representation of
software that's hard to work with I've
ever seen and that was until I realized
that that's a secret compartment in the
handle filled with more tools and now
that is the most just amazing photo I've
ever seen and so I think we've all
worked with something like this right
like that some software that was trying
to do way too much and just ends up
hurting you and so we knew this wasn't
what we wanted to build we knew we
wanted something easy to use and simple
and the CLI was never meant to be the
one tool to do everything it was meant
to bring together the best parts of our
ecosystem in one easy-to-use way and so
we knew that this
build logic shouldn't be living in the
CLI it should live in its own library
that anyone could use so if you wanted
to create your own build pipeline you
could do it and we could give you the
tools to help so I'm going to show you a
quick example of what this looks like we
only need two things from the polymer
build library the first is a polymer
project which is going to power our
build stream and the second is add
service worker which is a helper
function and now let's recreate this
entire build pipeline using some
JavaScript the first thing we need is
your application your code and we're
going to get that with two different
streams from the project sources and
dependencies now we split it this way so
that you could handle those differently
if you'd like you could maybe process
your sources in a different way minify
your dependencies totally up to you
flexibility and power are the names of
the game name of the game here so we're
going to combine them into one merged
stream and then we're going to analyze
them and that's going to power the rest
of the build stream then we're going to
optimize them and we're just going to
run it through some minification here of
different tools for different code one
thing really cool split HTML and rejoin
HTML pull out your inline code into
their own files in the build pipeline
and that's that lets these tools see
them and minify them before combining
them back into inline JavaScript CSS
once again next we run it through the
bundler which helps bundle them which
Justin talked about earlier and finally
we write your build to disk and then
create a service worker the order on
those is is flipped but the result is
the same you now have a complete build a
complete build pipeline written in only
a few lines of JavaScript and now you
can do anything so now with JavaScript
you can hook into one of these places to
run something else you can remove things
you can add new code add new minna fires
you have complete control over what you
want to do here and so that's really
what we're talking about when we talk
about the CLI and the rest of these
powerful tools we want to give you one
way to bring them all together that's
easy to use doesn't take a lot of work
to get working but we also want to give
everyone the tools to go out and explore
and create their own
different implementations as they need
them so this provides a really nice off
ramp from beginner to intermediate usage
into the more complex use cases as your
project grows and matures so that's just
a quick quick overview both of these
tools are available on NPM the CLI helps
you work with web components really
easily polymer build helps you build if
you'd like to do something with a little
more control and we're really excited to
keep developing these I'm now going to
hand it back to Justin to talk a little
more thank you all right I hope most
you're able to use the CLI it's a very
convenient tool give us some feedback
we're going to try to do a final release
at some point coming up here in the
future the CLI is just one way that we
expose our core tools to users but your
terminal isn't the only place where you
work you certainly spend much more time
in your text editor than you do at the
terminal unless you're one of these VI
or emacs users and so there are some
really important problems to solve while
you're editing code first running crash
is a really really bad way to find
errors it's much better to see the
errors as you make them if you can next
api's and documentation are hard to
remember and jumping between your editor
and documentation just slows you down
and also large code bases are hard to
navigate text search isn't really
advanced enough for programming and you
want something better than that so
luckily these are all solvable problems
and they're solved in a lot of other
programming environments and the
declarative nature of HTML and web
components gives us the opportunity to
deliver a world-class editing experience
for web apps so it only makes sense to
bring our tools right to where you work
in your editor oh I forgot to advanced
in my slides here's some bullet points
so I'm happy to announce today that
we're releasing a set of text editor
plug-ins for polymer and I'm not going
to tell you about it I'm going to bring
on our other teammate Peter who's going
to talk more thanks a lot Justin I am
really excited to be up here to finally
unveil our work that we've been doing on
editor plugins providing a fantastic
developer experience has always been
part of the plan of the polymer team but
it's only just very recently that our
tooling infrastructure has caught up to
our ambitions so I'll start by talking
about linting we released last year
polyp poly wind our first pass at
linting it's very powerful gives you a
lot of great warnings and great
information about problems that they
come up as you're writing web components
but we learned something else from using
it and then getting feedback with people
it is too slow I mean for linting to be
a really productive part of your
developer experience it has to be
instantaneous anything less and you
start to lose faith on it you start to
lose trust in it you start to fall out
of your flow and you start questioning
ok what's the lint are doing is it
helping me here and worst of all it can
sometimes start to make your text editor
start to stutter all that's totally
unacceptable so we've been working with
the new analyzer to have incredibly fast
incremental updates of analysis of your
code which lets us do much faster
linting the analyzer also gives you very
precise information about what's going
on in your source code so we can give
you very precise underlines of problems
so let's take a quick look so here is a
text editor it's called Visual Studio
code it's open source released by
Microsoft it's very smile fast smooth
and extensible and here it's running our
new editor plugin and you see we've got
a red squiggle underneath that HTML
import this is
index dot HTML file and it's underlining
right at the where the problem is we get
an error message also notice how fast it
is as i'm typing each single character
the moment it's correct squiggle goes
away it also understands inline
JavaScript so the moment that there is a
syntax error led is fine who is fine
equals syntax error string everything's
fine okay so that's lending lending is
nice lending is good what else can we do
what about intelligent contextual add
you type auto completion so here we've
auto completed the paper spinner element
I can a control space I get all of the
docs extracted right out of the source
code can scroll through them can push
enter autocomplete the element papers
offenders a really awesome element but
it's got a very simple API let's take a
look at another element that also looks
very simple but has a surprising and I
think underappreciated lee rich and
detailed api paper button okay so let's
take a moment go through what happened
there with every single edit to this
file every single key press we are
reanalyzing this file and the editor
plugin notices there was a new import
added so it tracks down that file parses
it analyzes it scans it extracts the
metadata for those elements including
documentation from javascript and HTML
comments and it puts that into a cache
and that cash is available as you're
typing to power these these auto
completions so once i added the paper
button import I get paper button and
paper ripple now also as custom element
auto completions okay so I'll select
paper button and now I'll move my cursor
over here I push control space and I get
Auto completion of the properties and
attributes on that element
and we're able to extract a ton of
structured information about these
attributes so I know the type I know the
docs for each of these attributes I also
know where they were defined and if they
were defined in another file or as part
of a part of another behavior I can see
that too so for example toggles comes in
as part of polymer to iron buttons date
how many people here knew that you could
use paper button as a toggle a limit
like for a checkbox or a radio button I
had no idea yeah i see about ten hands
maybe it's a really powerful element and
I think it's really I'd appreciated
because it's kind of hard to track down
all the documentation it takes you out
of there flow to do it you snake up here
buttons a paper button okay but actually
what I wanted to do here is just have a
simple paper button with a little shadow
so select raised I'll start typing
because I want to customize it a little
more and I get it narrows down the auto
completion as you'd expect I'll select
elevation by hit and read the docs I can
mouse over and I get a pop up with the
documentation for that attribute okay so
it's a number and the number is zero to
five bigger is a deeper shadow okay
that's nice so i'm gonna select one i
might tweak it later but what if i
wanted to go a step further maybe I
wanted to understand how that shadow
effect was implemented how that raised
material design aesthetic comes in I can
move my cursor over the raised attribute
and push a single button f12 and jump
straight to the definition of that
attribute
notice that this is in a totally
different file this is paper but not
HTML and not only that it's not even
part of my project my project has
index.html this is in my components
directory that's not a problem for the
analyzer and that's not a problem to the
editor service my hands the elevation
there let's jump to that definition oh
right this isn't a totally different
file this is in a behavior right so now
I'm in paper button behavior at HTML
okay and that's actually in a totally
another package paper behaviors Peter
button behavior to HTML so that was
coming in from a behavior mixed into the
paper button element and then made
available right there in your editor so
you might notice that I've been saying
custom elements web components not just
polymer elements here we mean that as
Justin was saying earlier we built the
analyzer as a pluggable extensible
system for where you can it can notice
multiple different ways of writing
custom elements and declaring them so
let's take another look at another
example so this is a one hundred percent
vanilla custom element declaration the
beauty of this is you can copy and paste
this code directly into Chrome Canary or
Safari technical preview and it just
works with zero dependencies this is not
a polymer element this is not an element
of anything but the web platform I can
jump into index.html and I'll import
vanilla jas and then immediately I get
auto completions for this vanilla custom
element
we've extracted the documentation and I
can autocomplete it go over to its
attributes I get all the completions of
its attributes as well with
documentation and type if it's annotated
I can mouse over for the pop-up and
select it and jumped a definition that's
right every single feature that I
demonstrates a day for polymer elements
works exactly as well for vanilla custom
elements and we do not want to stop
there if you're in the audience and you
use another custom elements framework or
the author of one I know there's a
couple of you in the audience we really
want to work with you come join us on
github or did in the slack channel we
have a tools channel and I'll be opening
up the editor channel just after this
talk so we have had one more dilemma
while we were implementing this as I
started to think about editors I went
around to the polymer team there's about
20 people on the team I started asking
them about what editors they use and I
discovered a kind of shocking fact there
are maybe 20 people on the team and
there are at least six editors in active
daily use it's kind of crazy right but
it's also really good that means that
the editor ecosystem is really
competitive and there's lots of really
great editors out there with lots of
features that are vying for for your
user experience but what do we do as
plug-in authors well we're taking
inspiration from a number of other
projects including rust go and
typescript in implementing a standalone
editor service this is a simple nodejs
binary that well it's a complex nodejs
binary the exposes a very simple JSON
API and this Jason API is expressed
exactly in the terms that every text
editor understands file names line
numbers column numbers see so your
editor can say hey my user is on line 15
of index HTML third column and
push my jump to definition button what
do I do they don't know the text layer
doesn't know about HTML doesn't know
about JavaScript doesn't know but any of
this stuff just says what do I do
where's the definition and the editor
Service says vanilla jas line 2 column
13 exactly the information that you the
text editor needs to pop up in a new tab
and direct your cursor exactly where
that definition is so we've proven this
out we've implemented plug-ins for
Visual Studio code as you've seen
sublime text and of course Adam
all three of these plugins support
instantaneous as you type editing I
linting and contextual intelligent auto
completion of custom element tags and
attributes and we're just getting
started we have an alpha release today
it's out now the polymer editor service
is here it contains full documentation
of everything you need to know about the
protocol and how to add it to your text
environment of choice and we have one
step install in a demand vs code today
APM install polymer ide for adam and you
can do that EXT install in the vs code
actions pop-up so to recap the editor
plugins make it wait super easy to edit
and maintain your custom elements web
components application with as you type
linting add you type documentation auto
completion and jump to definition for
making it really easy to navigate a
large and growing code base with that
I'll hand it back to Justin thank you
very much
yay that was really really awesome I'm
super excited for all of you to use the
editor service and the plugins we've
been testing it on the team and it's the
kind of improvement in development
workflow that makes your not just more
productive but happier because it
removed so much frustration in
day-to-day development I mean I
personally want feedback as soon as I
can get it and I want to see many
mistakes as soon as I make them and this
is exactly what this delivers so we're
really really really excited about this
we hope you are too and that concludes
our tour of tools we have a lot of
changes coming up that we hope will make
you happier more productive polymer
users and with projects like the
extensible analyzer and linter we hope
to serve the entire web components
ecosystem this is something that's
really important to us we think
interoperability is a huge strength of
web components and we hope to push that
forward as much as we can you might be
wondering when you can use all this so
as you saw some of it is available today
the CLI is in beta now the ID and
plugins are in preview now and the new
linter and bundler will be in preview
soon available through the CLI and then
we're going to be working on NPM and
yarn support very very soon all right
that does it for us thank you so much
for joining us have a great day</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>