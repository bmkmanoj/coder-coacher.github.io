<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Edge Conf 2: Rendering Performance | Coder Coacher - Coaching Coders</title><meta content="Edge Conf 2: Rendering Performance - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Edge Conf 2: Rendering Performance</b></h2><h5 class="post__date">2013-09-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/DjcSbvBWSb0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text"> 
ANDRE BEHRENS: OK, so we're
gonna be talking about
rendering performance, or as I
like to think of it, the war
on purple and green.
I'm sure you've engaged
in that yourselves
from time to time.
On our panel today, we have
Josh, Josh Peek from GitHub,
Ariya Hidayat from Sencha.
We have our opening speaker,
Jonathan Klein, from Etsy.
We have Paul List from Google.
And we have Eli Fidler
from BlackBerry.
So let's just go in with
the presentation.
You ready to go?
JONATHAN KLEIN: I think so.
 
ANDRE BEHRENS: Can we get
the presentation up?
 
JONATHAN KLEIN: OK.
When we talk about rendering
performance, we're really
talking about this
number here.
Most monitors and devices we
have today are rendering--
ANDRE BEHRENS: Mic.
JONATHAN KLEIN: Hey, that's
a lot better.
Thanks.
Most monitors and devices we
have today are rendering at
about 60 frames per second.
So when we talk about rendering
performance, we're
really talking about trying to
get your application to render
at 60 frames per second with
all animations, with
scrolling, et cetera.
If you do the math on this,
it means that we have 16.6
milliseconds, approximately,
to get a paint event done.
So any time you have a paint
event that's taking longer
than that to render on your
page, you're going to get jank
on the page, and it's
gonna be slow.
Luckily, we have tools today
that make this pretty easy to
see what's going on.
This is an example of
Chrome DevTools.
All you do is turn on the
continuous page repainting
mode, and then in the upper
right section of the page,
you'll get a nice meter that
tells you exactly how long the
paints are taking.
This is on the Edge
Conf website.
You can see here 2.7
milliseconds for this paint
event, and then there's a meter
on the right there that
says it's ranging between
2.6 and 4.6.
This is very, very
fast paints.
If our budget is 16.6
milliseconds, then 2.7 is well
within that budget.
And as you scroll, the page
this meter will adjust,
depending on how long the
paints are taking.
So anytime you see this meter
spike above 16.6 milliseconds,
you're gonna get that jank
that I talked about.
And jank is something that
I'm sure we've all seen.
It's basically when you're
scrolling a page and it hangs,
or animation is happening,
and you can't scroll--
any time where the page
performance drops below 60
frames per second.
And, again, this happens pretty
widely on the web
today, and it's a pretty
big problem.
And that's the term that's
been generated for it.
What causes jank, now that
we know what it is?
Well, this slide I pulled
directly from the Jank Busters
Google I/O talk earlier
this year.
And I think it gives a good
overview of the main things
that are important
to think about.
These things really fall
into two categories.
So first is unnecessary
paints.
So this is if you have, maybe
your paints are fast, but you
have too many of them.
So you try to jam hundreds
of paints into a
single scroll event.
And that's just not gonna
perform well, no matter what
you're doing.
And the other category is long
paints, so these are examples
where you might have a single
paint event, but it takes more
than your budget of 16
milliseconds to render.
And there are some examples
here of different event
handlers that can cause that
problem, CSS issues, and just
visually complex pages.
Why do we care about jank?
Why do we care about rendering
performance in general?
People have talked a lot
historically about page
performance itself, but this
idea of rendering performance
is fairly new.
During Edge London earlier
this year, we heard Shane
O'Sullivan say that Facebook
artificially lowered the frame
rate on their iOS and Android
apps from 60 frames per second
down to 30 frames per second,
and engagement collapsed,
according to him.
On a native app, it's
pretty easy to get
60 frames per second.
If you get down to 30,
that's pretty bad.
So they artificially did this
to, he said, a small segment
of the users, maybe a few dozen
million users, and it
caused major problems.
At Etsy, we did a similar test
in the sense that we started
pre-fetching JavaScript on
our search results page.
When the JavaScript came down
the pipe and was actually
executed by the browser,
we got janky behaviors.
So, essentially, you'd see in
the Chrome console that the
JavaScript came in,
and then the page
performance would degrade.
You couldn't scroll the page,
and it was really nasty.
We were monitoring all the
business metrics on this page
when we were testing this change
out, and as soon as we
rolled it out, the business
metrics got a lot
worse across the board.
So we'd rolled it back, and we
were unable to make that
change with the current
implementation.
And this is all to say that
right now, in many cases,
rendering performance is more
important than full-page
performance.
If your page is fully loaded,
you might think OK, I'm done.
It happened quickly,
that's fine.
But if the user can't scroll and
interact with the page or
your animations are slow, it's
gonna really torpedo
engagement.
How do we fix it?
Well, that previous slide I put
up has some good advice.
Basically, we just use the tools
that exist today to hunt
down these painful repaints, or
unnecessary repaints, and
then fix them.
Again, these things come from
visually complex elements,
but, luckily, the designers
are telling us today
that flat is cool.
So it's very easy to have a
nice site and a fast site.
All you do is just have a
flat, no gradients, no
background images, no, no
nothing, right, just flat
colors, and then you're good
to go on all fronts.
But seriously, what are some
real techniques that we can
talk about today that make
an impact on rendering
performance?
The first is using
requestAnimationFrame instead
of setTimeout.
Historically, if you wanted to
execute something on a often
basis, but not as quickly
as possible, you'd use a
setTimeout in JavaScript to
delay that event a given
number of milliseconds.
And people would do things like
take 1,000 milliseconds
to divide by, et cetera, try
to get 16.6 millisecond
execution times.
But we'd rather have people
use, going forward,
requestAnimationFrame.
This is a native browser API
that can optimize these
rendering events.
It can do things like turn
off the animation
till the tab is hidden.
It can optimize battery usage
on mobile devices.
And since it's a native browser
API, it's just gonna
be more efficient at
doing animations.
Support across browsers is
pretty good, certainly in
modern browsers.
You can shim it for older
versions of IE, but it's well
supported across all modern
versions of browsers.
Another thing to point out is
that consistent frame rate is
better than a high variable
frame rate.
So if you can get your page to
render consistently at 40
frames per second the entire
time, that's better than
having it render at 60
sometimes, but as soon as the
user scrolls or an animation
fires, it drops down to 30 and
bounces back and forth.
That's a terrible experience
for end users, so you wanna
make sure that the page
is rendering in
a consistent fashion.
 
Another technique is
to paint less.
So we talked about how
having too many
paints can be an issue.
A lot of the time, this comes
down to just batching your
paints together and trying to do
these large updates to the
screen fewer times, so just
one slightly larger paint
that's still within your budget
of 60 milliseconds, but
not having tons of paints that
execute on every scroll event
or every hover event,
et cetera.
You can consider the
translateZ hack.
We have some experts on the
panel here today that can talk
more about that.
But, essentially, when you add
translateZ, zero, to an
element in CSS, it doesn't
actually animate that element,
but it does move it to a
different compositing layer,
which can be very useful for
something that's being painted
very often.
So it'll get put under
the GPU, and the GPU
can optimize that.
Speaking of the GPU, you wanna
make sure you're optimizing
how often you're uploading
textures to the GPU.
The GPU is extremely good at
manipulating textures that
have been shipped to it, but
if you saturate that bus
between the CPU and the GPU by
trying to push textures back
and forth, you're gonna
have problems.
So this really comes down to
understanding when you're
forcing stuff to go to the GPU,
and trying to make sure
you're not doing that too much,
but doing it enough to
leverage it when
it makes sense.
And then, finally, this comes
from a post that was written
by Paul Lewis, one of our
panelists, over here.
Don't guess it, test it.
It's really hard to give you
hard and fast rules for
rendering performance on the web
today, because they're so
specific to the site
characteristics.
It can be a single animation
that's causing your problems.
It can be a single CSS
rule, in some cases.
So it really comes down to using
the tools to find out
where your page is slow.
If you want more resources,
there's a great site put
together by some folks at
Google, jankfree.org.
It aggregates slides, videos,
and articles about this topic,
and there's a lot of excellent
information on there.
And with that, I'm gonna turn
it over to the panel.
ANDRE BEHRENS: Here,
you want to switch?
There, you hold that.
 
OK.
We're gonna try and get up the
contribution screen here.
Beautiful.
OK, so let's go to our
first question.
Pete Miller.
Could someone get a microphone
to Pete?
 
PETE MILLER: Question.
 
So anonymous question here.
If there were a YSlow for
rendering performance, what
would its test be, what changes
would be easiest to
implement, and which would
have the biggest impact?
ANDRE BEHRENS: All right,
someone from
the panel wanna go?
Paul, do you have an
idea for them?
PAUL LIST: I think we covered
this in the introduction talk.
A YSlow for rendering
performance is, I won't go so
far as to say useless, but it's
pretty, it's gonna be
very difficult, because what
are we looking for?
We're looking for
layout problems.
What triggers the
layout problem?
Is it that you clicked
in this button up
here in the top corner?
Is it that you were scrolling,
and we did something
parallaxy, and that caused
the layout problem?
You start to get into very--
it's very specific to your
application where your
problems are going to show up.
So having an automated testing
framework is gonna be tricky.
That's not to say we shouldn't
try it, but it's not always
gonna be the easiest
thing to do.
So it's something that you run
into YSlow where it goes hey,
you did this, and
you did this.
We should look at it, but I'm
not, at this point, sure how
broadly effective it would be.
JONATHAN KLEIN: Yeah,
I think it's really
hard to automate that.
But because YSlow is partly
used as an on-demand tool,
that's kind of what
the DevTools
provide for you today.
If you're using YSlow in the
sense that you just pull up a
page and run it manually through
the Chrome extension,
that's what you can do today
with the existing tooling and
see the running performance
for your given site.
So we sort of have something
similar, it's just very, very
difficult to automate,
as Paul was saying.
ARIYA HIDAYAT: So one thing that
you can do is to apply
specific restrictions
in your project.
For example, Jonathan mentioned
about not using the
requestAnimationFrame, so you
can put some checks in your CI
system to prevent somebody from
accidentally put that use
of setTimeout.
So if there's a new additional
setTimeout code, code appears
on some of the JavaScript files,
that should trigger a
warning because, well,
the project used
requestAnimationFrame by
default, for example.
JOSH PEEK: Yeah, I guess the
YSlow stuff normally runs on
page load, but, obviously, all
these rendering performance
problems are something
that's happening
as your app is running.
So there's not really a way
to profile that initially.
So it's basically what we
already have now, which is the
timeline view of showing
all these problems.
And Chrome does a
pretty good job.
I like the new little warning
icon you get when you trigger
a layout in the timeline.
So that's a pretty good
situation to be in right now.
PAUL LIST: Yeah, and there
are some other things.
There are things like telemetry,
which Adobe had
been using brilliantly
for Topcoat.
So when they're checking code,
telemetry is a Python-based
framework that the Chrome
engineers use.
And it runs a bunch of tests
against pages for things like
smoothness of scrolling.
And that's definitely something
I'm interested in
looking at a little bit more
because there may be things
that we should be looking at
that just give us at least an
insight into how the change we
made in our code affected
rendering performance.
And it may be that there's a
certain amount of scripting
that's required from the
developers to set this up in a
meaningful way for that
particular project.
But that might be something that
we wanna take a look at.
And if you're interested, give
me a shout after this because
I'm actually really interested
to find people who want to try
it, to bust out telemetry
and give it a go.
ELI FIDLER: I think also--
I mean, the question is really
what are the magic bullets.
I do this on my site,
and it gets fast.
And there's enough things
going on in rendering
performance, in most cases, that
there isn't a hard and
fast rule there.
Things are very different
on different platforms.
So in addition to being specific
to your site, it's
specific to the device that
you're running on.
It's specific to the version
of the browser that you're
running on that device.
And so testing is really
the best way.
And testing on as many devices
as possible is the best way,
which is not, I'm sure, what
everybody who builds content
wants to hear.
But, of course, there are some
things that are good and that,
I think, people have started
to do a lot more.
Being declarative is usually
better than being imperative.
So if you're going to do an
animation, use CSS animations
or CSS transitions.
Browsers are getting much better
at optimizing things
that are left up
to the browser.
And, historically, you haven't
been able to do that because
performance hasn't been good,
but now it's a lot better.
ANDRE BEHRENS: Well, thinking
about YSlow is not just the
specific implementation
detail.
When I think about other people
that I work with and
multiple levels, are there any
big obvious thing-- like part
of YSlow's power is
just the marketing
message that it delivered.
We have these things.
Oh, OK, we should definitely
all be gzipping everything.
And it sort of consolidated
things that had been known.
ELI FIDLER: So I think CSS
transitions, as opposed to
JavaScript animations, is an
obvious one that most people
are getting now.
My personal one that I've
noticed a lot is people really
like one pixel offset,
one pixel blurred
drop shadows on text.
That's a really expensive
operation.
Don't do that.
 
ANDRE BEHRENS: All right, think
we'll move on to our
next question.
Jake Archibald.
 
AUDIENCE: All right.
So tricks like translateZ,
putting that on an element is
quite often a silver bullet in
terms of performance, but
could that be an anti-pattern
tomorrow, like when we used to
tell people to concatenate
strings using array.join.
We now know that's faster than
just doing string plus string.
Is translateZ gonna
be the same thing?
 
PAUL LIST: Possibly.
There are three steps, I think,
to most performance
problems, which is, first of
all, there's the don't do it
stage where we just blindly tell
you do not do this thing,
it will be bad.
Then there's the next step where
we go ah, now, we can
make it less bad if you were
to do this thing, which is
where I kind of categorize
the translateZ hack.
It's something we'd rather you
didn't have to do, but
sometimes you've gotta step in
and do it just to kind of hint
things up a little bit.
Then there's the final step,
which is hey, this is not a
problem anymore.
Now, there's the other thing
where you go, oh, actually,
all of a sudden, it's
an anti-pattern.
So the array concat versus
array.join versus string
concat thing is the one that's
often mentioned.
And I think the only thing you
can do there is profile.
Again, we've said it before.
But it's like if you're
profiling and it's part of
your build process, then when
something changes in the
implementation, you're
going to see it.
You're gonna go,
whoa, something
went really slow here.
I wasn't expecting that.
What was it?
And you can figure out what it
is that's actually triggering
your problem.
So, yes, it may be a problem
in the future.
There's no crystal ball gazing,
as far as I can tell,
but profile is the
answer for me.
JONATHAN KLEIN: Yeah, on that
I would say that anytime
you're doing something that's
known to be a hack, like,
that's definitely
a hack, right?
That's probably not gonna be
something that we want to be
doing forever.
So anytime that you feel like
you're adding some code that's
just not standards compliant or
it's, translateZ(0) doesn't
make a lot of sense from a
future proofing point of view,
I think it makes sense to
abstract that stuff away.
Because chances are, it's gonna
change going forward,
because it's not
part of a spec.
It's just a work-around.
PAUL LIST: Yeah, one thing I
really don't like, if I'm just
being me for a second, is the
fact that we don't give you a
way to say that you want
something on its own layer.
I don't have a problem with
a developer saying that.
There's kind of a balancing act
of should the developer
have to worry about layers
versus should the browser just
take care of everything.
And in a perfect world, yeah,
the browser would maybe get
everything right for you.
It'd be able to guess your
intent perfectly.
But if it can't, then surely the
best next step is not to
provide a hack, but to provide
a decent API that says yeah,
you know what?
If you need to call
this, call this.
This is what it'll do.
And if you want to abuse it,
OK then, that's your call,
you're the developer.
And we trust you.
And you're not an idiot.
 
That's just generally how I feel
about this kind of stuff.
JOSH PEEK: Yeah, it's
definitely a leaky
extraption--
PAUL LIST: Right.
JOSH PEEK: --of course.
So I think if the layer
compositing system is
something that you really need
to be concerned about as a
developer, it should be an
explicit opt-in, not going
into this magic voodoo property
that you read about
on Stack Overflow and
you don't really
understand how it works.
But having an explicit API for
declaring layers is, I think,
a good idea, if that's something
we need to be
concerned about.
ELI FIDLER: So translateZ(0) is,
obviously, a hack to force
compositing.
And I think it's actually a
really good declarative API
if, right after you put that on,
or at some point later in
your page, you're about to
animate the value of
translateZ, or you're about
to animate the value of
translate3d.
Then you are exactly saying this
is something I'm setting
now, because I'm gonna
animate it later.
And that's why it does
what it does.
So that you have your content
promoted into a layer, so that
when you animate it, the
next frame is ready.
And a number of properties
are like that.
Those are the properties right
now that force compositing.
And they're there specifically
so that if you are going to
animate them, you're primed
and ready to go.
And maybe there are more things
that should be like
that, but I'm very hesitant
about saying that we should
introduce a new property that
says promote to layer, because
promote to layer isn't something
that web developers
should care about.
PAUL LIST: If you don't have
that, then you have this thing
where developers can't get
good performing code.
If they can't get a good
performing yet, they don't
have anything other
than a hack.
And so either the browser has to
infer perfectly the intent
of the developer and get it
right, or we have the
alternative, which is give them
a way of saying no, this
is what I really mean.
And they're doing that through
this sort of back door at the
moment, which kind of makes me
feel uncomfortable because it
does give rise to hey,
implementation's changed, now
your expectation needs to
change, which is, I think, a
slightly unfair position
to put a developer in.
But, maybe that's just me.
ANDRE BEHRENS: Yeah, it's kind
of interesting that's what the
distinction is between
translateZ and promote to
layer in terms of actual
developer life experience.
AUDIENCE: Can I jump
in for a sec?
ANDRE BEHRENS: Yeah.
AUDIENCE: I feel like I've seen
developers animating top
or left, setting something
position fixed a lot and then
not realizing that that's
going to have different
performance implications than
animating something with
translate or even
margin-right.
So I feel like if we wanted to
let someone animate top, but
give it the performance of
something in its own
compositing layer, then using
some sort of layer-promoting
API would make sense, in
that case, potentially.
ELI FIDLER: I mean, your
specific example right now
also does force a layer
on most platforms.
If you set something to fixed
positioning and then animate
top, it will.
 
ARIYA HIDAYAT: Just adding one
more twist to the topic.
We also have to remember that
translateZ, or even
compositing layers just half
the equation, right.
For example, if you do that, but
you try to animate, say,
blur radius or border radius, it
doesn't really help because
there are only a couple of
properties that you can apply
to the GPU texture that can
be executed by the GPU
efficiently.
So, again, explicit, or
implicit, or half explicit,
half implicit, web developers
still need to know that only
certain properties you can
run on the layer itself.
ANDRE BEHRENS: Right.
PAUL LIST: And, generally, I
mean, the way I sort of always
pitch it is you're gonna promote
to isolate to layer,
that's probably gonna
get painted.
Or you just want it-- cause
you're gonna move it,
translate-- oh, sorry-- move
it, scale it, fade it, or
rotate it, I think.
ARIYA HIDAYAT: And filter.
PAUL LIST: Yeah, or filter.
And those, Paul actually helped
me figure-- he came up
with those four, which
is really helpful.
So if you're gonna do one of
those things, or if you're
gonna paint something and it's
gonna affect other elements,
then it's a good time
to isolate it.
Other than that, it's, like you
said, it's probably not
gonna offer you anything, and
you're potentially creating
more of a problem because you're
gonna have upload a
texture for that layer
to the GPU.
And if you're on a constrained
device, like a mobile one,
well, you're gonna pay
that tax every time
you change that layer.
JONATHAN KLEIN: One of the
interesting things, I think,
about the web that's happening
right now is we have sort of
two, or not even two,
but whatever, a
gradient of use cases.
Because the browser is now
becoming this platform where
you can do complex animations,
you can do full gaming
experiences, et cetera, but you
can also build a pretty
static website.
So when you talk about
developers shouldn't have to
worry about this, well, if
you're building a high
performance game in the browser,
you probably should
have to worry about
that, right?
But if you're building your
blog, you shouldn't.
So I think there needs to be a
facility for both camps of
people to be able to use these
tools effectively without
having to worry too much if
you're on the low end.
But you should be able to access
those APIs if you're
working on something
really complex.
ANDRE BEHRENS: I think we'll
move on to our next question.
Ben Holland.
Grab the mic.
 
AUDIENCE: Hey.
So we have reasonably good
tools and insight into
rendering performance in a
dev environment but not
data from the field.
What events or metrics would we
ideally like to be able to
measure and report on
for real users?
 
JOSH PEEK: The only thing we can
do live in production is
measure the window
performance APIs.
Those are pretty great,
but those only
effect the initial load.
You don't get anything
after the fact.
So being able to tap into the
timeline from JavaScript and
get those actual values
would be great.
I mean, we do some stuff where
we profile method times and
then report these back
over AJAX in our
production app, so.
But you can't get access to any
timeline data live from
JavaScript, so having those
would be great.
 
JONATHAN KLEIN: Yeah, I'd love
to have real user data in
production as well, but I'd also
love to have even better
synthetic tooling around
it for remote use.
So what I mean by that is to
say right now, there's no
JavaScript API into the frame
rate, for example, that the
Chrome DevTools gives you for
that rendering meter.
So it'd be great if you could
just hook into that with
JavaScript because then you
could write tools that would
basically change different
events, hide nodes while
scrolling the page, and then
read off those frame numbers
and the paint numbers.
And then you could very quickly
narrow down, in an
automated fashion, on the area
that's causing a problem.
So I think that's kind of the
next step is how can we get
code around that paint meter
so we can easily find out
where the problem areas are.
PAUL LIST: I think that's
interesting.
But is that in a lab
environment or
is that in the live?
The reason I ask is because if
you're talking about live--
say, frames per second-- it's
very difficult to separate
signal from noise, because you
don't know if it's contention
at the OS level, if it's a
badly configured monitor,
terrible GPU drivers, contention
at the Chrome
level, or browser level
contention actually within the
page and a bottleneck there.
So just a simple frames per
second probably wouldn't give
you that much.
But in a lab environment, where
you can be pretty sure
that there's nothing else
running and so on, then that
seems to me to be a reasonable
first step.
JONATHAN KLEIN: Yeah, I was
thinking in a lab because
right now, if you wanna take a
page and figure out why its
rendering performance is bad, it
takes a lot of work, right?
So if you could build better
tooling around that in a lab
environment, it could be very
fast to narrow down where the
problem is.
But, yeah, you're right.
It's not gonna work very well
in the real world today.
ANDRE BEHRENS: I think we
have a question from
the room, James Ide.
 
AUDIENCE: Hi.
So, for some context, I feel
like a lot of the performance
characteristics of how browsers
work, like a lot of
the things in Jonathan's slides,
are understood by a
lot of web developers, and the
DevTools have gone great.
Even I11's really great now.
You should check it out.
But understanding how the
browser works is great if
you're a one-man show
and you're building
your own web page.
And as soon as you start to have
a large team working on
your product, it's very easy
for someone to introduce a
regression.
So I'm wondering, for example,
at Facebook, we have a library
called REACT, which helps avoid
layout thrash when we
render our web pages.
And I'm wondering if there
are, let's say,
organizationally scalable APIs
that the browser vendors can
provide to us.
So, concretely speaking, maybe
asynchronous APIs to decode
images, or asynchronous APIs
to commute, compute the
dimensions of a DOM element,
things that are synchronous
and slow down the
page right now.
Are there these types of things
that the DOM could
provide to us that you think
would be helpful?
ELI FIDLER: So I think that's
actually one of the most
interesting areas of active
development in at least most
of the popular web engines
right now.
Definitely WebKit and Blink
are both working on--
they call it different things--
but some sort of
incremental layout where certain
properties, when you
request them from JavaScript,
don't trigger a full re-layout
of the page.
And I can't give you a list
of what works right now or
anything because a lot of this
is research code right now.
But this is a very good example
of where the browser
can make things fast without
you changing anything.
So right now, there's a couple
of properties that you asked
for, like offsetWidth, that will
trigger a full re-layout
of the entire page and doesn't
technically have to, but,
right now, the way that
the engines work,
that's what they do.
So stay tuned.
But there's a lot of things
there that are getting faster
without web developers having
to change things.
In terms of adding new DOM APIs,
we have standards bodies
and they accept public
comments.
And definitely we've seen a lot
of people providing that
sort of feedback.
ANDRE BEHRENS: We have another
question from Mike Petrovich.
 
Mic.
 
AUDIENCE: So to Jonathan's point
about synthetic testing,
I know Etsy does synthetic
testing for initial page speed
performance.
But what if we did something
like that with using Selenium
test in a synthetic environment
that would
actually, in a context-sensitive
area for
your app, kind of how it's meant
to work going, clicking
around, 200 milliseconds later,
clicking this other
element, and that's all
affected by different
rendering speeds, and also
JavaScript evaluations.
So it's a more of a real-world
example than just, straight
up, how long did it take
to render this?
And it doesn't work at a
generalized level like, there
seems to be a consensus, but
on a very contextual basis,
what about using kind of
automated behavioral tools
such as that?
JONATHAN KLEIN: Yes.
We sort of have that today
with webpagetest, right?
So Pat's here, and he built an
awesome tool that allows you
to do multi-page flows, and see
screenshots for every step
of the way, and look at
waterfalls that show
JavaScript execution, and see
how long those things are
taking, and even monitor CPU
during that process.
So that's, I think, the best
proxy we have for it today,
but, again, one of the
challenging things is that we
can't currently get data on
frame rate or paint events out
of the browser through an API,
so that's where you sort of
run into that wall.
So you can get part of the way
there, but you can't-- you
still can't calculate how long
a paint takes, as far as I'm
aware, unless you patch
Chrome, maybe.
I don't know.
PAUL LIST: Telemetry actually
runs Chrome with a very
specific flag,
enable-GPU-benchmarking, which
enables a GPU benchmarking
API.
And that will give you some
stuff, and, in fact, yeah,
that's the reason telemetry
can get the data out.
Then the other thing you can
do is connect to DevTools--
it's over the web socket--
and get it to run, do the thing,
pull off the timeline
data, and then check for paint
records and so forth.
So there are things there.
They are not, I would say, that
easily, sort of like,
sort of grunt-taskable and just
easily inserted into your
workflow today.
And I think that's something I'm
very interested in, is to
whether we can actually make
that a thing that's easy for
developers to just include
in their build steps.
ARIYA HIDAYAT: A good example
of the use of telemetry is
Adobe Topcoat project.
I think they have a fantastic
dashboard that shows how long
does it take to render a
button for every single
revision of the code, the CSS.
So if you accidentally change
the CSS and it slows down the
rendering of button, then you'll
know it immediately.
I think this is all using
Chrome telemetry.
ANDRE BEHRENS: All right.
Next question, Chen It Tsai.
AUDIENCE: Yeah.
 
ANDRE BEHRENS: Microphone.
AUDIENCE: Down front.
 
So the question is how can
we track the performance
detriment that third-party
scripts, such as ads, social
buttons, or anything you wanna
add, have on rendering
performance, and, I guess, steps
to kinda mediate that
without being too hacky?
 
JONATHAN KLEIN: Come back in
two hours or whatever.
[LAUGHTER]
PAUL LIST: I think profile.
I mean, you should know how
your app is running.
And then you should know what
happens when you add that
thing in, and see what
the change is.
If it's hideous, then you
need to make a decision.
I think operating blindly
with your code is a
very dangerous approach.
It's just, for me, it's
fairly simple.
Get used to the tools
that are available.
They are great tools.
And just go-- make sure you
understand how it runs before
and after the third-party script
to know whether it was
worth adding it in.
I mean, anything you add is
going to have a tax, right?
It's just whether you're happy
to pay the tax, right?
That's really the question.
ELI FIDLER: I mean, we've talked
a lot about painting.
We find that a lot of the issues
about badly written
third-party code is not so much
about painting, but about
adding extra event handlers or
doing busy work when other
things could be happening.
And the remote Web Inspector,
Chrome DevTools, or whatever
is available on all the browsers
today, are really
good at showing you had a scroll
event, and somebody had
an on scroll handler, and it ran
for five seconds, and it
came from Facebook.
Facebook doesn't actually have
a scroll handler that takes
five seconds.
[LAUGHTER]
ANDRE BEHRENS: OK.
So let's go on to
the next one.
Ed Soden.
 
AUDIENCE: OK.
So it was an anonymous
question.
What is the easiest thing
browser vendors could do to
make it easy for developers to
optimize the performance of
their sites?
 
[LAUGHTER]
JONATHAN KLEIN: No, no one--
JOSH PEEK: It's just the
YSlow question again.
Like, what are these magic
things you can do.
JONATHAN KLEIN: Yeah, I think
more to that point, we talked
about this in the last
session, actually.
Because browsers are now being
put on watches, and glasses,
and really low-end phones, it's
hard to say, well, what
can the browsers do to just make
our jobs easier, because
devices keep getting
lower powered.
So I think we're going to keep
seeing new environments for
browsers to operate in.
And it's hard to say, oh, well,
the browser will just
fix it all.
We don't have to do any work.
PAUL LIST: More tools.
That's the only thing I can
think-- more tools.
But that's gotta be balanced,
cause you don't want, if
you've ever used tracing,
tracing is brilliant, but it's
overwhelming at first when
you hit that thing.
You're like what have you
just done to my eyes?
So it has to be balanced.
But I think if we could, for
example, you can't actually
drill down in Chrome DevTools
today inside paint records.
You know that you spent some
time painting, but you don't
know what was painted.
We recently added details on
image decode and resize, so
that you know which image was
decoded and resized, which is
invaluable.
So we can continue to iterate
and improve the tools so that
you're in no doubt
as to where your
bottlenecks have came from.
But, to make your life
easier, you're the
ones writing the code.
ELI FIDLER: I mean, I make
browsers, so I need you to
answer that question for me.
But one thing that I always ask
when I go to conferences
like this is I talk to web
developers and I say what are
the tools that you need that
would tell you things that you
can actually act on?
So when I ask what do you need,
and people tell me I
want to know what's going
on in the paint record.
And then you say, oh, but that
will be different tomorrow, or
that will be different on
different device, by an order
of magnitude, which it often is,
that becomes information
that's very difficult
for them to act on.
So there are some developers who
deliberately target every
single device out there with
individualized code, but those
developers are very rare when
you have the kind of money and
time to spend on that.
So , tell us what you need to
know, and we will try to make
that happen.
Also, we try to just make
everything fast.
ARIYA HIDAYAT: So I have this
gut feeling that, in the near
future, the rendering
performance tool, especially
with painting, will fall
into two categories.
One is how to improve from 10
frame per second to 30, and
the other one is how to go from
40 to 60, or 58 to 60
frame per seconds.
Because what you're looking for
is that quick fix, so that
instead of 10, you run at
30 frame per seconds.
ANDRE BEHRENS: I think
we have a question.
AUDIENCE: So just to say one
thing that you can do is tell
us there is a problem.
So I think, granted, we don't
have best practices exactly at
how to solve it, but given--
I get the point about
doing synthetic
testing, but you also--
most people in the panel agreed
that the profile of how
many frames per second you
get varies per device.
And, of course, you can't
simulate all these different
situations.
If we had some sort of real-user
monitoring at least
telling us, hey, there is a
problem on whatever Android
device X on this page frequently
enough, then that
would motivate me to go buy that
device and run some more
tests, just to sort of balance
the different effects, even
ahead of having the best
practices, for exactly how
would I fix my codes
to make it go away.
JONATHAN KLEIN: Yeah, I think
that's a great point.
And something that that brings
to mind is that with the YSlow
tool release and the web
performance movement that's
been going on for the past 10
years, we've had a lot of
studies that come out saying
look at the top 1,000 Alexa
sites and how bad they are
in these best practices.
That hasn't happened yet,
I think, with rendering
performance.
So I think it'd be useful
just to see--
have somebody go out and look at
popular sites and be like,
look, there are problems here
on these devices, on these
browsers, and just sort of
expose it on a wider basis, so
people are aware
of the problem.
Because I think in this
community, it's obviously
well-known.
But I think in the wider
community, people don't think
as much about rendering
performance.
ARIYA HIDAYAT: Does anyone know
if Google reduces page
rank for sites that are slow?
[LAUGHTER]
PAUL LIST: I'm not saying.
[LAUGHTER]
PAUL LIST: No idea.
ARIYA HIDAYAT: I'm
just asking.
PAUL LIST: I have no idea.
 
ANDRE BEHRENS: All right.
Our next question comes
from Dunston Caston.
 
AUDIENCE: Hey.
So my experience with paint
performance usually drops
frames with garbage collection
events and memory management.
What responsibility should web
developers take on for those
two things, memory management
and garbage collection?
 
PAUL LIST: OK, so the immediate
thing is that GC
causes jank because GC is almost
guaranteed to push you
over that frame budget
of 16 milliseconds.
Your only option is to
try and avoid GC.
This, I think, depends on how
big a problem this is for you,
how much memory churn you
actually have, how much time
garbage collection is actually
taking, and how often it runs,
which is gonna be very
specific to your own
application.
There are things--
 
we have, on HTML5rocks, we have
an article about using
static memory pools to recycle
objects and so forth.
You're avoiding object creation,
which tends to be
good for the GC.
But, personally speaking,
I don't believe it's--
People have requested can we
have a garbage collection API?
And I would be concerned about
a browser including that
because that one could get
really hairy very quickly.
 
ANDRE BEHRENS: What would
be the problems?
PAUL LIST: The browser is
uniquely positioned to--
your page is not the
only thing that's
running in the browser--
so it's in a unique position
to know when
garbage should be collected.
And if you were to force the
issue, you may, basically,
make the wrong call.
This is one of these times
where, as they say, the
browser is the one that has all
the information and knows
when it's the right time
to pick up garbage.
Ideally, you want it to do it
at the best point for every
application that's running,
but that's the nature of--
ARIYA HIDAYAT: But what if the
GC API is just a strong hint
for the browser to do garbage
control when it's possible?
PAUL LIST: So if you do that,
then what happens if it
ignores you?
Or if you get different browsers
ignoring you at
different times?
Is it any better than
the browser just
making the call itself?
ARIYA HIDAYAT: But that's the
same situation like the
translateZ layer hacks, right?
PAUL LIST: Yeah.
No, exactly.
And so some of this stuff is
just real world, yeah, we're
just having to do
this right now.
We wish we didn't because
we just want to get
stuff that runs well.
ELI FIDLER: I mean, we've gotten
complaints, mostly from
sites that do permanent
animation all the time that
GCs are a problem, and that's
things like games.
And if you're writing something
that is truly
interrupted by GCs on a regular
basis, then you just
have to create less garbage.
But building a game that's
gonna run at 60 FPS while
doing complicated things is a
hard problem, no matter what
environment it's running in,
and no matter what language
you're running it in.
So I mean, you can't expect that
the browser is just gonna
do it for you.
And I don't think that you could
make an easy decision.
Even if you had a guaranteed
API that said GC now, you
couldn't make an easy decision
about when to call that API.
 
ANDRE BEHRENS: Well,
what would--
I'm curious.
We hear again and again, and
when we talk about rendering
performance, we have to test,
we have to look, you have to
look at a specific thing.
What is the brightest sign of
hope for the next thing that's
gonna be easier to handle.
I'm curious, if anyone
has a perspective.
PAUL LIST: When you say
easier to handle.
ANDRE BEHRENS: I don't know.
Like certain things, in the
sense of the timeline view,
maybe at least getting a handle
on it, easier than it
was, like you could
actually see it.
I know the inability to
see pictures in the--
Like able to see picture decodes
and say, oh, that was
a picture decode.
That's what that thing was.
Having that show up in
the tools is a easier
thing to deal with.
Is there anything that either
is going to go away or is
gonna be much easier
to test for?
PAUL LIST: In terms of going
away from a Chrome
perspective, there is--
image decodes and resizes
are, at the
moment, extremely expensive.
And as we all probably
know, 60% of the
average page is images.
So if you can fix image decoding
and resizing as a
bottleneck, that helps
enormously with that problem.
So our engineers are definitely
looking at ways to
make that a thing.
The other problem that you often
see is the main thread,
the contention on the main
thread being so high, such
that work can't continue, and
the app becomes unresponsive.
We are looking at ways
of basically
reducing the workload.
That doesn't always necessarily
mean firing off
more threads, which I think is
the sometimes muted idea.
 
In Chrome's case, we have a
fairly thread-heavy app, so
just creating more threads
wouldn't necessarily solve it.
So what you actually wanna
do is do the work
in a smarter way.
So for example, putting more
work that is suitable for the
GPU to go to the GPU,
that kind of stuff.
From a developer's point of
view, none of that actually
requires action, other than try
and reduce the work that
you're doing, which has
always been the case.
If you're layout bound,
try and reduce layout.
Even if layout gets faster in
the browser, you still want to
do less of it.
The performance is the
art of doing the
least amount of work.
 
ANDRE BEHRENS: I think
we have a question
from the crowd, Serosh.
Yes.
Microphone.
 
AUDIENCE: Hi.
I have a very simple question.
So a few weeks ago, I was
developing this web
application.
I don't have any complicated
CSS going on, no timeouts,
very simple layout.
But it just uses
lot of images.
So it picks you out images
from Picasa, and
it shows it to you.
And it's just slow, especially
the first time.
The rendering performance
is really bad.
So what, as a developer, I
can do to increase that
performance?
 
PAUL LIST: That's a really--
that is a tough one right
now, if I'm honest.
From my point of view,
we don't have--
so when the page is rasterizing,
it does the image
decodes and resizes in line
as a sort of dependency.
It gets this drawbit mapline
where it goes OK, and now I
need to draw an image, and I
need to decode that image, and
resize it, if necessary.
And then I can actually
put it in,
rasterize it into the page.
And that all happens in line.
If it was decoupled from the
rasterization, and there was a
gap where it was and then
it appeared later, that
might be one thing.
But as a developer, there's not
a lot you can do, apart
from, perhaps, batch in your
images is something you could
potentially look at.
Because it's all
done on demand.
Again, this is from a
Chrome prospective.
It looks at what it needs
to rasterize.
If that's 30 images, 30 images
are gonna get queued up for
decoding and resizing
in one go .
It might be--
it depends on the app-- but it
might be better to hold off
and go, can I do these one by
one or just over a few frames,
so that I'm not hitting
everything at once.
That's sometimes maybe a thing,
but I offer that advice
without knowing the
application in
detail, so use it wisely.
ARIYA HIDAYAT: Does it need
to show all those
30 images at once?
AUDIENCE: So no, not really.
And that was one of the
things I tried--
Not really.
And that was one of the things I
tried to do, so to just show
the images, whatever is visible
in one page size.
But even then, first time, you
are getting, let's say, 10
images, it's visibly slow.
And I've seen similar pattern
in other website, too, like
the well-known websites, so
I wasn't sure if there's
anything can be done about it.
PAUL LIST: And we are trying
to reduce the tax that is
levied for decodes
and resizes.
ELI FIDLER: I mean, we just
had a whole panel talking
about images.
Images are expensive.
Having to touch every pixel in
an image and doing decodes and
things like that is an
expensive operation.
There's fundamentally no way
around the fact we have to do
a lot of work when
we show images.
But the techniques that were
talked about in the last
panel, especially if you control
your images-- in your
case you may not--
but putting low quality images
in as placeholders, and then
asynchronously bringing in
higher quality versions.
Or carefully choosing what types
of images that you're
using, what compression formats,
that sort of thing,
for whatever's fast for your
specific operation, is
something that you can do to
optimize image-heavy sites.
But fundamentally, images
are expensive.
There's no way around that.
PAUL LIST: It's interesting, as
a side note, that when the
last panel was talking, there
was obviously a lot of
discussion about bandwidth.
And that's only part of the
picture when you're talking
about images, right.
Which is the other side of this
is how long, then, does
it take me to decode
it and resize it?
So you actually need a
full understanding.
You could save time on the
transfer of an image, yay, and
then have something that is
actually really horrible to
decode or is horrible to resize
on the other side.
So your overall picture is
actually either worse, or the
same, or better, but you need
to understand the whole life
cycle of an image to actually
know whether or not you're
doing the right thing.
And also the low quality
placeholder, switch that with
a high res one.
Could be really good, but then
you're also trading off the
fact that you probably have a
second request to get your
higher res image.
So it's not just a
straightforward, often,
anyway, and it's very specific
to your app and what it is
that's worthwhile doing.
ARIYA HIDAYAT: It'll be
interesting to see if, in the
near future, instead of a single
CPU alone responsible
for images, we could have
GPAC core processors.
PAUL LIST: Ooh.
ANDRE BEHRENS: I
think we have a
question from Jake Archibald.
 
ELI FIDLER: While he's getting
the mic, image decoding is
actually hardware accelerated,
in many cases.
AUDIENCE: So on the scrolling
to load images thing, like
when they're out of view,
use a scroll event to
bring the images in.
I just wanted to point out that
that's a kind of massive
anti-pattern on a mobile,
because if the radio falls
asleep, or any device with a
cellular connection, waking
that radio up comes with
a huge latency and
will ruin the battery.
Now, on the resource priority
spec, we've got a new
attribute called postpone, which
hands that power back to
the browser and lets
the browser
sort of render without--
it can defer the image loading,
downloading, if it's
out of view.
 
PAUL LIST: I would love, as well
as deferring the image
downloading, I'd actually
love the ability to
defer decoding as well.
I don't see why you'd have
one, not the other.
Don't load this.
OK, do load it, fine.
But don't decode it.
OK, do decode it.
It's fine.
That seems to go hand-in-hand
to me.
And unless I'm crazy,
it's possible.
ELI FIDLER: That's exactly the
magic of Web Audio for audio,
cause decoding the audio is
expensive, so you want to do
it first, so it's ready.
Maybe we can do Web
Audio for images.
Somebody write a spec.
PAUL LIST: That's
a great idea.
 
ANDRE BEHRENS: Next question.
 
Matt Todd.
 
AUDIENCE: Hey, this is an
anonymous question.
What have been the biggest wins
and wastes of time at
real websites?
And I think balancing that
between front-end developers
and web developers, but also
from browser implementation
and development, what have
been really rewarding
endeavors, and what have been
huge wastes of time that have
taken more time to actually
produce any kind of benefit
whatsoever?
ELI FIDLER: We still see a lot
of sites that, in busy loops,
add one node to the DOM, and
then ask for a property that
requires you to do a layout,
and then add a note to the
DOM, and then ask for a property
that requires a
layout in a really tight loop.
And this is a huge
anti-pattern.
We've been telling people
this forever.
Most people are pretty good
about batching nodes dumped
into the DOM and that sort of
thing, but still a ton of
people do this all the time.
JOSH PEEK: I feel like that
doesn't happen so much where
you see the tight loop, but it's
more so that you have all
these other components on the
page, where one will add
something to the DOM, then
something unrelated can
trigger a compute stop.
And it just happens as
you render this page.
So a lot of it's
uncoordinated.
It's not these little tight, I
mean, they're the tight loop
things, I think, for painting
and rendering.
But a lot of people just have
all these components, and then
some affect the DOM, and
some require reading.
So I think you see that among
just having a ton of
stuff on your page.
PAUL LIST: From my point of
view, the biggest waste of
time I think I've seen would
be CSS selector matching,
which is remarkably fast.
And if you're optimizing your
selectors for matching, that's
probably not something you're
going to see a return on.
The thing that I've seen the
most use come from would be
promoting for isolation, putting
elements onto their
own layer when they're
frequently painted.
That's the one I've seen
work the most.
JOSH PEEK: I agree mostly on the
selector matching stuff,
but if you look at some really
huge DOMs that have maybe like
30,000 nodes, and you have just
a buildup of all this
CSS, and typically people have
so many descendant selectors
that just target an
anchor element.
And if you add a ton of anchor
elements in this DOM, that's
going to add up.
So it's not like every rule
matters, but there's ones that
you can call out.
PAUL LIST: Right.
No, for sure.
But I would argue that was a
fairly extreme case, unless
I'm misunderstanding
your description.
I think for most people and most
applications where the
DOM is not 30,000 nodes--
wow.
JOSH PEEK: It's GitHub
commit diffs.
PAUL LIST: Boo.
ELI FIDLER: We see a lot
of sites that are
over 100,000 nodes.
PAUL LIST: Really?
Wow.
Just gonna let that
sink in for a bit.
ANDRE BEHRENS: Jonathan,
I was wondering what
your experience was.
JONATHAN KLEIN: Yeah, that's
the-- unfortunately, the big
wins have been removing content
or removing design
elements, so removing drop
shadows off of every element
on the page kind of thing, and
things like getting rid of
animated carousels.
Sometimes those things are hard
to pass through because
the designers or the UX people
really want that.
But at the end of the day, you
have to test it, right?
And if people want a jank-free
experience more than they want
drop shadows, then that's what
you should give them.
ANDRE BEHRENS: We have a
question from John Mumm.
 
AUDIENCE: Hi.
We've talked a lot about images
decoding and resizing
being very expensive.
Do we know of any example
libraries or example
implementations that use web
workers and transferable
objects to have a significant
impact on this?
PAUL LIST: Oh, dear.
Yes, now.
I did do, actually, an
experiment with this one,
where I actually created canvas
elements for all the
images and used workers to
decode and resize the images.
And so you can do it is
the first answer.
Whether you should do it becomes
the next question.
And no would be--
[LAUGHTER]
PAUL LIST: --because
you have to manage
all the images yourself.
Is it in view?
Is it decoded already?
Have I decoded this
thing before?
All these things that the
browser does fantastically
well for you, you are
now having to
take care of yourself.
And you could shoot yourself
in the foot so hard and so
fast that I feel duty bound to
say you can do it, but don't.
But you can do it,
and it's cool.
ELI FIDLER: Especially on
mobile, I think it will
definitely, definitely
not be a win.
So even if you can get the
image decoded a couple of
milliseconds faster, the amount
of time that you're
gonna be moving pixels around,
saturating your memory bus,
and the battery impact of
running these web workers at
the same time is going to be
way, way worse than just
decoding the images normally.
PAUL LIST: Right, because
you're gonna spawn a new
worker, right?
So you haven't got enough cores
on mobile, probably, to
support that decision.
And it's going to be slow
because it's JavaScript.
But you are in control.
I mean, you are in
total control.
So that's the trade off you're
making, control for all that.
ANDRE BEHRENS: OK, we have
another question from Sergei.
 
AUDIENCE: Hi.
We had a lot of challenges
explaining network
performance, basically, the
other side of performance, to
designers and business people.
And a lot of rendering
performance, actually, is much
closer to the product they might
actually understand.
Do you have any suggestions on
how we organize the process
for making them understand all
of these other issues?
ANDRE BEHRENS: Jonathan?
JONATHAN KLEIN: Yeah, I think
similar to network
performance, you have to kind
of show it to them, right?
And, in a lot of cases, it's a
lot easier to see rendering
performance being problematic,
especially if you have low-end
devices that you can
show people with.
So I think it's a question of
getting it in front of them.
And like you said, it is
closer to the product.
It's closer to the design
side of things.
So I think it should be easier
for those people to have it be
more intuitive.
But I think demonstration
is the best option.
ANDRE BEHRENS: Yep.
ELI FIDLER: I think also demoing
on cellular instead of
Wi-Fi helps a lot.
PAUL LIST: If I just demoing on
a constrained device, pick
one, oh, it looked slow,
it looked fast.
Which would you rather ship?
It tends to be pretty easy
then, I think, or easier.
JONATHAN KLEIN: And then one
thing that was really
successful for WPO was just
business metrics, right?
And we have some of
that data now.
It's starting to come out, like
from Facebook and like
Etsy, so I think showing that
information is really
important to say this does
really impact engagement.
ANDRE BEHRENS: We have a
question from Paul Irish.
 
AUDIENCE: I think I was gonna
mostly ask about the same sort
of thing, but I'm interested
in ways to communicate what
the impact--
because like network
performance, page load time is
a really easy metric.
We can track that across
browsers, across different
connectivity, rendering perf.
There's not much in the way
of numbers that we can
demonstrate, say, this is the
impact that I had, or this is
where our problem's at right
now, where we need to
bring it down here.
So do you have any ideas on
making things a bit more
quantitative, so that management
and clients can
really see the impact that we
have and then understand that
there is a problem that
we need to solve
before we get into it.
JONATHAN KLEIN: Yeah, that's
a great question, because
everybody quotes these stats,
like 100 milliseconds on
Amazon was 1% revenue, but you
can't say 3 frames per second
was half a percent revenue
or something like that.
So I think we just have to have
real studies that have
been done by real companies,
and ideally, companies that
are in your market.
So again, it's a tough problem,
but I think we need
to have more people doing
experiments, and be willing to
slow down half their traffic
to 30 frames per second and
see what happens.
PAUL LIST: Right.
I mean, we are now at the point
where the browser is
capable of 60 frames a second,
which hasn't always been true.
But now that it is, we're sort
of playing catch up with the
page load time part
of performance.
And now we need to ask that
question, and say, as an
industry, as a body of
developers, we are interested,
I hope, in seeing how the actual
runtime experience
affects our users and how much
it affects our users.
Because we don't know today is
it the same, is it less, is it
more than the page load time?
Because they load once,
hopefully, and run
it for a long time.
So 100 milliseconds is different
on rendering for
page load is a very different
deal to repeatedly hitting
them with 100 milliseconds.
But we don't know
how big that is.
So yeah, we don't have a good
answer, I don't think, on how
much it affects the
bottom line.
But I think we need to find
out, and pretty quickly.
 
ANDRE BEHRENS: All right.
I think that about wraps
it up for us.
Are we ready for lunch?
 
Oh, someone has a microphone
ready to go?
AUDIENCE: Yeah.
ANDRE BEHRENS: Oh,
that's fine.
AUDIENCE: One question.
Actually, my biggest problem
with rendering performance is
that I cannot describe my
intent to the browser.
I cannot describe my intent that
I want this element to
have higher priority when
rendered over another.
And I think that's the biggest
problem for me when we're
talking rendering performance,
that the browser is making
false assumptions of what my
intent is in my layout.
And I think this goes together
with images.
This image should be rendered
before that.
This box should be rendered
before this box.
What are we doing to look into
that so I, as a developer, can
declare my intent to the
browser, so the browser can
make, or the rendering agent,
can make a more intelligent
guess of how things should be
composed when layouting?
Because now we're talking
about translateZ.
That is, to me, like a hack.
First of all, it's not hardware,
forcing hardware
extortion in IE.
And I, as a developer, I should
know about layers.
That's a implementation detail
in the rendering engine.
I just want to declare my intent
that this layer is
either higher or lower priority,
and then you guys
should figure out the rest.
Are we looking into
these things?
Is there any proposals
coming up?
 
PAUL LIST: So there's
one, yeah.
OK, first of all, the browser
should do everything for me is
one thing I'd wanna
pick up on.
I don't know how much
I agree with that.
I don't think I agree
with that.
 
The way I would normally phrase
this is if you write
spec compliant code, you should
expect spec compliant
responses from the browser.
But there is no promise
of performance.
Now, the promise comes
through the fact that
everybody wants fast code.
Browser vendors want to give you
fast implementations, and
so that's something you should
seek, and you should ask for,
and you should push
for, definitely.
But I think it's very difficult
to hand-on-heart say
a developer, any programmer
should be completely divorced
from the system they're
programming on.
I can't quite bring myself
to say that.
I think it would be a nice
thing, but I don't think
that's realistic.
Is that something that we
are looking to improve?
Yeah, always.
I think there's always
a definite
balancing act of APIs.
If they're overly prescriptive
and you don't get enough
control, then you end up with
what I think is the outcast
situation where you can't
polyfill it, you
can't bridge that gap.
 
At least if it's too difficult
or it's a horrible API--
and I would argue that things
like WebGL actually are very,
very horrible, from a
developer's point of view.
But at least you can
polyfill that.
You can at least add on
something like 3JS.
So I'd rather it was
that way around.
But it comes through developer
feedback, saying we don't
think this works, we
don't like this.
ANDRE BEHRENS: OK, and I think
that is really it.
[APPLAUSE]</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>