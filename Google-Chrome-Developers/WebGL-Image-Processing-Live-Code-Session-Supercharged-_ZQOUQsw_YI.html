<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>WebGL Image Processing: Live Code Session - Supercharged | Coder Coacher - Coaching Coders</title><meta content="WebGL Image Processing: Live Code Session - Supercharged - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>WebGL Image Processing: Live Code Session - Supercharged</b></h2><h5 class="post__date">2017-09-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_ZQOUQsw_YI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">it is 2:30 p.m. UTC plus one and that
means it's supercharged time hi I'm
Sarah and I'm Matt and we are gonna do
some WebGL so buckle in let's go all
right time to do some WebGL
I think you have never done life going
like this before no not like this
you have a little loan though and maybe
some people here today will have seen
what you did you've done it's possible
you have done a gif decoder yeah
JavaScript quite interesting because
yeah if you haven't done it the gif
format is a bit weird but today I mean I
was gonna say we're gonna do something
less weird but and again we're doing
WebGL which not less weird no no not at
all so let's talk about WebGL but before
we get into the coding straightaway
because I feel like there's a lot of
misconceptions are been out there about
WebGL and OpenGL and how it works and
what it does and I don't know help me so
the first thing to realize something
that confuses a lot of people is that
WebGL is open jail the API is basically
the same yes
WebGL one is OpenGL ES 2 which may not
mean anything to you but like if you
find tutorials on the web for how to do
OpenGL pretty much directly applies to
WebGL because I'm I think what I one of
the things I do know is that it is
pretty much one-to-one the C API put
into the JavaScript world more or less
which is not necessarily a good thing
because if you used to web api's this is
gonna be a whole lot different so
there's a lot of weird stuff that just
it's stuff that just looks weird because
it doesn't look like JavaScript yeah the
next thing to understand is so people
think of WebGL as a way to do 3d
graphics and that is what a lot of
people use it for but when you're doing
3d graphics with WebGL or OpenGL you
have to do a lot of that work yourself
really all OpenGL does is draw triangles
on the screen
really fast yeah because it doesn't in
most of the crossing in parallel right
graphic cards are because basically
cards with process on them that have up
to like 10,000 hundred thousand course
something receding powers endures
something ridiculously high and you can
run code on them in parallel so I think
we should start by you explaining what
you're gonna do and how it's gonna work
but before that I want to say hi to
everyone who's watching hi as always I'm
gonna be in the chat so if at some point
you find a bug you have a question or
don't understand something you can use
the hashtag supercharged on Twitter or
use the chat on YouTube on the live
stream and I'll be monitoring that and
will throw you like a little curveball
every now and then to see if I can trip
him up or not and that's why I said
let's go okay so what we gonna be doing
so as I said the WebGL is for drawing
triangles and you can do whatever you
like with that so what we're gonna do is
we're gonna do some 2d image processing
we're gonna take an image and draw it
into a canvas we're gonna do some
manipulation of it change the brightness
or you know maybe make it change
brightness across the width of the image
filter well think of something and yes
we're just going to process an image and
turn it into something so they're
different so why not we are just using
the normal canvas but using a WebGL
context for that yeah so it's gonna be
the same HTML canvas element but you can
access it in a WebGL way yes well I'll
show in a sec but yo you there's that
the context the way that you talk to
this the keys of screen estate yeah yeah
so instead of getting of 2d context
we're going to WebGL context
okay so just talk about how WebGL yes
because I don't think it's something we
can expect everyone to know about not
everybody has done game development or
OpenGL tutorials necessarily and it is
quite a bit different from all say
normal abs but the api's usually come
across with when doing web development
yeah okay so um my toe I'm gonna show
you roughly what what WebGL does
so with WebGL you give it a bunch of
information which has to include the
positions of some points on the screen
so you you define some points oops you
find some points and the you write a
small program that you sent to the
crackers card called a vertex shader
that takes in whatever data that you
that you give it I think I was one
confusing it's called a shader but
nowadays it is just an arbitrary code
program in the graphics card pipeline it
doesn't only do shading it can do a lot
more but originally I guess they were
used for creating shadows and that's why
they called others but now they've moved
on evolved into more complex and
powerful beasts so your vertex shader
she's the first of your two web GL
shaders what that does it takes some
input that you give it you can give it
whatever you like and there is beta
a young numeric data and it has to spit
out the coordinates on screen of a point
so here we've got three points there
let's say we have some more and then
what happens is that once up for every
three points that WebGL gets it
assembles those into a triangle so take
the first three points and make one
triangle to the next three points make a
new triangle so what this vertex here
does is convert your arbitrary data
which in the game context would be I
guess the points of your 3d models that
are somewhere in the 3d world and would
convert them to on-screen positions so
if the vertex shader is where usually
the whole perspective distortion thing
happens which you're not going to do
today because we're doing 2d image
processing okay okay so you run the
vertical your vertex shader runs it
gives you the points the graphics card
goes away in turns those into triangles
and then does rasterization which is
that it takes each triangle and it works
out which pixels on the screen intersect
with the triangle so here's my beautiful
no it was
just screen coordinates which doesn't
necessarily correspond to individual
pixels is just floating point numbers on
screen coordinates and then it figures
out for you if these three points form a
triangle which pixels would be affected
by that triangle right and then for
every pixel that is part of that
triangle it then runs the second shader
called the fragment shader and this
basically it runs it can have some
information that's been passed through
from the vertex shader or from elsewhere
but it basically say has to output what
color is this pixel so the vertex shader
says where are the corner where is where
is this point on screen yeah and the
fragment shader says what color is this
pixel that's all that they do there's a
distinction between fragment and pixel
but I don't think it's worth sitting in
- yeah I still hadn't understood it
myself so let's just let's just say the
fragment shader colors pixels and we can
work with that
you know the you know the graphics
libraries like the indirect XA is
actually called a pixel shader I think
okay cool
so that's the basic process we need to
provide we need to create two shaders a
vertex shader fragment shader one which
outputs positions one which outputs
colors and then we need to bundle up
some data to pass to the vertex shader
so that it knows how to get those
positions and then and then it should
draw our thing on the screen that's the
basic process so let's try that let's
see okay so let me yeah SEC so code so
HTML file it's literally just a body
with a script tag to load our script
because even much else dude was just
gonna do everything in JavaScript in
this case so our app Jess here first
thing we're gonna do is we're gonna
create the canvas it's where all the
magic starts so again canvas you
probably know it it's this Dom element
that you can get access to with a
drawing context and can start drawing on
it but you can also get in different
contexts usually you use the 2d context
to have line
drawings or ellipses some form of
visualization or animations but you can
also get a WebGL context which turns
this context object into this very thin
wrapper around the OpenGL API exactly
so here I'm going to get that context
I'm gonna put it in a variable called GL
mostly for consistency with everyone
else historical reasons that context
gets called jail that's true I think any
every controller Doctore own calls it GL
SIL so oops I get a web well yeah I get
a WebGL context then we can do some you
know basic stuff with that we want to
say hang so the WebGL context can draw
on just part of the canvas so one of the
first things we're going to do is set
the viewport a viewport so we're gonna
see it goes from zero zero to the GL
drawing width your drawing height this
is saying I want the WebGL part two
outputs yeah the whole cameras want to
fill the cameras so by default I think
the canvas has like three hundred by
hundred and fifty pixels or something
like that yeah we can't change that but
we gotta change it later maybe but this
basically just ensures that GL knows
what kind of what size or the Candice
we're working on yeah and to make it so
that we can actually see where it is
we're gonna set a clear color for the
for the canvas which could be anything
I'm gonna make this one sort of orangey
can't type and think at the same time
it's an overrated skill for software
engineering anyway and then we're gonna
say that the canvas should be cleared
okay so over here I can refresh here
okay so when you clear the canvas
there's multiple things that can be
cleared yeah don't worry about that but
we need to specify that we want clear
the color buffer so we use the color
buffer bit so one thing and even if you
haven't done 3d program you might have
heard of that you have the buffer for
the image that you're rendering but also
a separate depth buffer where you store
how far away an object from the camera
so you know if another object should be
painted above it or not be painted at
all so that's something you can clear
separately here we'll only care about
the color buffer but because yeah we
only 23d once again there is at least
one more other buffer than we haven't
mentioned but like yeah buffers we're
clearing the colors repairing the colors
don't seem cause that's the one that's
being visualized and we clear it okay so
here is our canvas and the color orange
it has you promised it's awesome great
success done see you next week
okay so we've we know that our canvas
has been created and that where we're
working with it live brilliant not what
we're here for though so I said that we
need to create some shaders so we're
going to take some source code that we
write and compile it into a shader that
the language that you use to create
shaders is GLSL it's kind of sea liner
kind of look it's supposed to look like
sea but it does kind of work differently
there's some things that are nice about
it some things that are not nice about
it some of the nice things because it's
today with vectors and matrices and
things like working with those it's
super easy but it's very unforgiving of
syntax yeah and I remembered earlier in
the day it used to be even harder to
write writers because there was no error
messaging whatsoever just not work you
get a black screen and it would sit
there and look for ten misses and I :
did I miss type a variable name nowadays
you do get some error messages to make
it a little bit easier to figure out
what you did wrong
yeah and also because I haven't
mentioned it yet this is what production
writing code oh it's not in there it
would probably make sense - in the end
wrap it up in a custom element but for
now it's gonna because WebGL is is quite
the complex API because with being
powerful there also comes a lot of
ability to do things wrong a lot of
things to do in general and we're gonna
have a bit of setup work so we thought
we wouldn't use as little distraction as
possible yes
so you know even putting the shaders in
a separate file you're just gonna inline
the coat right away because it's just
yep it might as well I agree just go
straight to a template string so here
I've written the part my buttocks shader
and it's going to set this GL position
variable which is as we said before this
shader is all about outputting a
position and we're going to make a it's
it's a 4d vector it's a it's like a four
element array there's X Y Z and W W is
like magic for perspective stuff yeah
yeah worried about perspective today so
we can just ignore it
yeah more or less it just needs to be
one then it works Zed we're gonna set to
zero because again we have no depth if
you're curious about the fourth
coordinate lookup homogeneous
coordinates on Wikipedia like the ride
so we actually have a first example here
something that GLSL is good for which is
that I'm gonna i'm creating a vector for
I'm gonna use a vector to which I happen
to find you and then just pass in the
extra two parameters to make it four
elements long so here we're going to say
that this shader needs an attribute
which is a vector that's a two element
array basically we're gonna call
position so this is the data that we're
going to pass into the shader which
we'll show how to do later we're going
to take that position which is going to
be a 2d coordinate and then we're going
to expend it using this back for yeah
constructor into a 4d vector which is
what GL position needs to be that shader
is now done so I just tried the
2-dimensional position into a four
dimensional vector so GL is happy well
that's all that's happening really it's
no so rhythmic
so precisely our our fragment shader
which I'm gonna shorten spreg shader the
the sauce is similar it has a main
method and then it get called here the
output is a color which is at the
variable GL frag color this is also a
vector force so it's the red green blue
and alpha unlike when you're doing like
CSS codes and things all of these are
float variable floating point variables
from 0 to 1 so what color should with
this one let's go
something a bit more purpley whatever so
that basically tells us if any Pig side
is covered by our triangle will now get
this color assigned exactly okay and
there's a couple of extra things
well one extra thing I have to do here
some reason WebGL doesn't like defaults
for certain things so we had to have to
say precision high P float we have to
say what precision all of the
floating-point numbers in their shader
ah is it ever not high P a lot of people
use medium P I guess the P stands for
precision yes I guess it makes it faster
yeah if you use medium P but less
precise well you only have so many
pixels right all right cool so I could
have you say no we are basically we're
just getting data and we're using it as
a position straight away and then we're
just saying everything is covered by
triangles is now purple purple yeah okay
so that's our source code let's make it
into let's make it actually oh yeah now
it's just a string
we still need to tell so the thing is
it's a language right and you would
think I see like language needs to be
compiled yes so first of all we need to
create some objects on the graphics card
so what gel has this great love of
creating an object on the graphics card
and then like making a pointer to it so
we did it's a it's a fairly old API
yeah it's we create we create a shader
and we say what type it is this one is a
vertex shader
that there's two shader types there's
about a sailor in the fragment shader I
think in newer versions there is the
geometry shader which we're not going to
get into today because crazy and you in
fact have are new versions of OpenGL not
WebGL you have the compute shader as
well for doing this too far but you can
competition
we don't have that and we don't need
that for a little bit of truly image
processing no so we create our shader
objects but these have nothing nothing
in there's just like oh the strings are
still in JavaScript yeah it's just a
place on the graphics card that we can
refer to it's literally just an idea
this we have a handle on them I think
it's called the verge Ida and Franco two
variables are handles for these two
shaders and now we got a like push our
stuff into there exactly so we say that
for the vert shader handle we're going
to attach the virtue Eider source the
string the source and we're going to do
the same for fractionator so we've
attached the source and now we can
compile I was about to ask if there was
already a compiler but apparently it's
not no no it is not at so it can pass
sauce compiled shader so we're going to
compile the virtue aider and your
compiled Soph all the people who've
joined us in the meantime because you
know not everybody can get you a
notification that we go live
straightaway
welcome this is supercharged this is my
colleague Matt and today we're gonna do
some 2d image processing using WebGL and
what that means is we are getting in the
deep end we are writing shaders and
stuff so so far we have set up a canvas
and we have turned that canvas into a
little OpenGL context and now we can use
the OpenGL API from the web hence why
it's called WebGL and are just about to
upload our shaders to the graphics card
compile them so that we from now on can
determine how the positions are turned
into pixels and how these pixels are
then colorized exactly so we've got a
we've got our shaders and they could be
used independently we need to say that
they work together in a thing that yeah
because if the one that's supposed to
pass data from one to the next booth of
reticule it outputs the position and it
started with triangles and ascend using
the fragment trader they need to be
compatible right yeah so at the moment
like they don't interact but later on we
will add a way in which they interact
and they will have to be compatible so
we can have we could have hundreds of
different shaders and can
combine them in many different ways and
we've combined them is in a program so
we create a program again this is just
an object on the graphics card and we
get a an ID back and handle to it
then we attach our shaders attach shader
so we use a program and we use our
worksheet ER and then same again with
the break shader so we attach the two
shaders to our program we then link them
so we call linked programs that we have
compiled the shaders there now as like
programs on the graphics card now we
link them to one program telling that
program that they need to work together
yes so at this point it validates that
they are compatible our kend does the
plumbing in the graphics card to make it
into a single single done time yeah
whatever it does all graphics cards are
different and there tend to be secret
exactly what it does
just see the API black boxes oh good now
as I said we could have hundreds of
shaders we can also have hundreds of
programs linked together but only one
program is used at any given time so we
finally have to say that we're going to
use so use program and we're going to
pass in oops the actual program are so
you can have multiple shaders linked to
multiple programs but you only can have
one that the data that you are that you
have on the deck that is being passed
into right and switch programs but it
would be separate runs of the graphics
yard so to speak
so for more complicated things you have
different shaders that do all sorts of
different things and during one frame
you might set things up use one shader
draw that set things up for another
shader draw that you use multiple
shaders in a frame so you multiple
programs in a frame and those programs
can be composed of whatever shaders you
like so we've got our shaders set up
linked them into a program cool now
we're ready and it's going to see that
the Chad is coming alive with people hey
everyone as always ask questions ask
away I'm gonna forward them if
appropriate you can
use the hashtag supercharged on Twitter
which I'm monitoring and if you want to
like actually understand how we draw
things because we're close to actually
having something you like you had
something else get already we had a
yellowish rectangle yes it's an
achievement it's super exciting purple
okay
so first of all time around again
literally back to a drawing course yes
and so to have oh here's what I made
earlier which is a thing so um Blue
Peter reference therefore all you UK
kids okay so we want to draw an image
which is a rectangle and we can only
draw triangles but luckily we can
because that would OpenGL does best draw
rectangles and do it in a highly
paralyzed fashion so we have our
rectangle so that's the fun thing about
thinking about OpenGL WebGL that we are
gonna more or less run the Prashad
approve it we rode in parallel in a way
that each pixel has its own thread more
or less more or less so because graphics
card have like sixteen thousand course I
think you said yeah we can do that so
yeah each car will probably used for
like a hundred pixels or something yeah
to make your whole image madness okay so
we split up our our rectangle for our
image into two triangles ingenious so
the reason why we have to do this is
because if there was no triangle our
fragment shader wouldn't get run and we
couldn't change the color off that pixel
which is what we want to do exactly so
we're just can't we're gonna say we you
know our frankly a vertex shader stays
where the corners of the triangles are
works there and then we find the the
pixel colors within that triangle with
no triangle there's no colors so we need
to say where these corners are to make
two triangles on the screen now in WebGL
in our shader when we set those output
coordinates those coordinates for
various reasons go from minus 1 to 1
minus
one is the left or the bottom of the
screen and one gets up and right
why goes up X goes right on the screen I
know this is smeared for you so I should
be doing this Y goes up X goes right but
it goes from minus one it's a left to
the left border of the screen or the
area and plus one is the right border
yeah I mean I had a way of making so
let's draw in our axes here whoops it's
a little a little wonky
I'm Sarge in here zero so this is minus
one as pain as a little set a little
thick I'll get by it's readable I'm this
one the complex number so assist ah I
see what I did there I didn't intend to
do that yeah so the coordinates of our
triangles it's over here we have let's
split well it's they've all the corners
hanging around like this I don't know
why I did them in this order I just see
you know not even the mathematical order
no this one minus one so it's an
interesting question like why don't we
just use regular j/s with canvas because
this would be so much faster or it's
gonna be so much faster if we're gonna
do proper image processing where each
pixel will have a considerable amount of
math and maybe even dependent on
neighboring pixels and it's doable with
the normal canvas in JavaScript it's
gonna be slow because you will have to
run in a four loop and you would run
this single thread over the entire image
and if you do that on full screen
resolution on a Retina display and
you're gonna have a good time with GL it
can do every pixel a separate thread and
it's gonna be snappy fast arguably 60fps
so you can be amazed if it wasn't yeah
unless you really really like I think
like really like blurring filters at
high convolution rates will probably not
make it but yeah that's what we gonna do
today okay so we've got a we've got our
four corners I'm gonna make them into
three triangles we're going to do that
as we can have we're actually gonna make
our two triangles there's going to be
triangle which is a B C and another one
which is
c/d yep so when we have a vertex shader
it takes it takes some positions yeah we
need to pass in those positions in the
correct order so we just figured out the
the letters of the triangles now we can
replace the letters with the actual
coordinates because we also have them in
the diagram yep
so let's write in our vertices now when
we're passing data to the graphs card
generally you want to use an array
buffer where you can have to use an
array buffer because you have to specify
the the format of the data so that it
fits nice it's a binary choice with the
graphics card works fine areso yeah so
we're going to create a new float 32
array we're going to create it from some
data which is loops which is our
coordinates which I believe we're minus
1 minus what minus 1 that is the left
yep
that is the table 1 1 top right so yeah
our first triangle these are the two
dots start from the bottom left again
and I move to the top right and then we
move to the bottom right interesting
question what is an array buffer I guess
it's something if you don't necessarily
know if you don't haven't gotten in
contact with this kind of thing Narae
buffer is JavaScript's take on having a
raw memory where you actually have a
chunk of sequential memory and you can
have arbitrary data in there and they
need to figure out how do you want to
interpret these sequence of bytes
because you can look them in chunks of
four and say these are 32-bit floats
which is what we are doing you could
take the same data and interpret it as
integers or something else and this is
the way to make sure that we are
actually transferring a certain memory
chunk to the graphics card it has the
correct format if we just took an array
it would technically be up to JavaScript
to figure out is this integers is this
floats and this way we can force a
representation so we can transfer it yep
okay so we've got our data now just like
send it to the greatest right now it's
still only JavaScript so again we need
to create a WebGL object and this one is
going to be this is going to be the
vertex buffer it's going to be a hey
buffer very simple object so again we
just get an ID back and now we're gonna
say what to actually do with that
so buffer just again chunk of memory yes
this sank on the graphics card though so
now we have a chunk of memory with data
in it in JavaScript a chunk of memory on
the graphics card with nothing in it
guess what we're gonna do next
well that is that yeah almost first of
all one of the things that's a little
weird with WebGL buffers is that you
can't just say create a buffer and then
store data in it he'll be mad
that'll be almost simple no one expects
that so what instead you have to do is
you you have like named types of buffer
so what we're gonna do is we're gonna
say we're going to bind use the bind
buffer method to say that the named
buffer array buffer points at our vertex
buffer so you can so if an aside
correctly you can have as many buffers
as you like but only one of them ten
take the role of being the array buffer
at any point in time so it's like a slot
it's like this buffer it's now the array
buffer and you do your work and then for
the next draw you can take that out and
take another river you are now the array
buffer exactly if I wanted to populate a
hundred buffers I would have to do this
bind buffer a hundred times I see your
buffers yeah okay yeah now that we've
bound that we can then send some data we
can use the buffer Bufo Bufo data we can
buffer some data so we say what the
target is and this is that array buffer
so as I say it is not vertex buffer it
is array buffer sure so you don't ever
reference it by the vertex buffer
variable by just by the buffer that has
the current role array buffer yeah so
you have like this level of indirection
in there which is a theme you'll find a
lot in OpenGL by the way in this case I
could have put the
if a call right in here because it's
literally the only time I use it this is
nice this is allows us to explain yet
there is two different concepts but you
know okay so buffer data so where we say
what the data is
it is our vertices vertices and then we
say we're going to give a hint to the
graphics card about how this is used and
the usage here is GL static draw there
are a bunch of options here but this one
basically says this data doesn't change
so in theory the graphics card can
optimize for this some graphics cards do
some don't some apply as badly some you
actually want to use the wrong kind
because of those it makes it slow but
we're gonna be we're gonna be good
citizens and say this is static because
we are never going to change this buffer
data okay
we've got the data now when you talk you
up to our shader now in our shader we've
just got this we're gonna attribute and
we've give it a name so this is yeah
that's all this variable already that
will come in yes this is how it will
come into the shader so in order to say
how our data matches up we need to get
what we need to get an ID for this
variable so we're going to use we're
gonna say that the position location
which is a wonderful little linguistic
it's the location in the shader of the
position variable also it's like it's in
this location in your shader script so
that you can basically then in every one
inject a different value exactly so in
in the shader when it compiles it
assigns an index to every variable so
you can from outside say I'm putting
this data into index 0 and it will be
whatever variable is has index 0 so
you're not referring to the name so
you're not passing string around ok nice
again a level of indirection yeah cool
so we get an ID doesn't go juggling all
of this in your head exactly
so this is
that's right get at tribal location so
we're looking inside our program for the
attribute called position ah someone
asks so these C programs and that
process for formula shaders ya can
receive user inputs mo by bypassing the
browser no no but we as the developer
can set them to values and that means
the run changes so we that is our hook
into our statically compiled program to
make our scene look different so one
example would be we could say this is
where our camera and in the next one we
don't have to recompile the program but
can just change that bit and now the
camera will be a different position in
the scene will render differently so
it's basically if you want to think
about it like C programs
it's like command line flags yeah in a
way maybe yeah yeah the WebGL say it has
no access to anything that you don't
pass through from the JavaScript side
it's completely I said unless you as a
bit of a give data to it it's being the
engine it'll be a pretty serious floor
in the web sandbox yeah that wasn't the
case okay so we've got the location so
now we can say that we can point the
data correctly series a vertex a trip
pointer so we're going to say that the
index which is the position location the
we're going to send through each time
it's going to take two values so the
size of the data for each run of the
shader so so yeah it has a chunk of
memory there's some data but it doesn't
know what format data has we know it's
pairs of two because I screen
coordinates and there's six in total
yeah what we need to say that we need to
tell the engine that that's how he's
supposed to go through with this chunk
of memory
exactly so on each on each run of the
shader take two values out of the array
the the type of those values is
float normalized is false and I believe
it is suspect they're just normalized is
false I don't know what that does first
stride this is how far is it from the
beginning of one set of data to the
beginning of the next set of data so if
you had so you've got like 10 bytes of
information or 10 floats of information
per vertex in your array but you're only
is passing to through at time I'd say
that size is 2 but the stride is 10 so
that you you move 10 my boards together
there's it's not relevant so you can
skip over that for every yeah it's sort
of yeah allows you to skip data we're
gonna set that to zero which means just
use the size yeah which is handy and
offset how far into the data does its
into the arrange of the day to start it
starts at zero so that tells the shader
how to look up the data yeah almost
there we need to enable vertex at rib
array is it position location so we need
to enable this so I'm guessing you could
have if you say you can skip it you can
probably say the first two bytes of my
10 bytes are a position the next two
bytes are the color of this vertex other
normal whatever what have you and so
that's why you need to say these you can
enable multiple of these vertex ultimate
point urse yeah yeah exactly
so in this case we've just got one is
two bytes on so here we say that we want
to actually enable this location yeah so
that it will every time we run it take
that data because we could say that the
shader doesn't care this particular
shader in this and run it doesn't care
what you want it to tailor data here we
do so we've enabled that now we can
finally do some drawing whoa exciting
we're getting a campaign so we call the
draw arrays method because we are
drawing based on on a on a raise of data
our mode is triangles because here from
the the autocomplete there's triangle
fan triangle strip
there's point in wine okay we're doing
triangles because it is the most useful
thing to do yeah we yes um so we're
going to draw some triangles we're gonna
start with triangles zero and we're
going to draw so it's not triangle zero
we're going to make it from vertices so
we're gonna start with vertex zero we're
gonna go we're gonna draw see that's
confusing a bit I mean you say I'm
drawing triangles then you tell the
number of vertices is another number of
triangles exactly because that means
what if I you say seven then it will try
to read beyond the buffer and I don't
actually know everything will explode
because that doesn't make a triangle
that's why I would say I would expect it
to be a number of triangle because then
it can't go wrong unless it go negative
or something weird but what triangle fan
and triangle strip oh thank you
anyway not today um Sammy just check
that I got all the parameters there yep
just yes 3d breath okay so the moment of
truth is happening we set up the canvas
we compiled and linked our shaders we've
got some vertex data we assigned it we
set that sent the data to the graphics
card we assigned it to a location in the
in the shader will it will it draw will
it draw let's let's check or a yellow
triangle and it turns purple first try
I'm legitimately impressed this should
not have worked on first try
this is like writing the Reg X's that
are correct on the first try so I mean
proof that it's still that is actually
the yellow is still behind this because
we have clearly at the yellow and drew
drawn two purple rectangles on top so
what we're going to do is I'm going to
move in move one of the the corners in a
bit so that's like triangle because
you'd have like a little if we move this
one the minus 1 1 minus 1 1 let's say
make those minus 5 and not 5
there we go so you can see the color has
moved in and the orange is still behind
it I believe you know all right so that
means we have now reached the point
where our entire canvas is I want to say
under our control it means for every
pixel on the canvas our vert fragment
shader is going to be called yes so
let's do something cooler than pink okay
so I'm gonna add in one step at a time
slightly different to what I told you I
was going to be doing so don't freak out
so one of the things you can do is you
can calculate information in your vertex
shader and send it to the fragment
shader ah and and a cool thing happens
because obviously in your vertex shader
you only only runs three times per
triangle but your fragment shader gets
run hundreds of times depending on how
many pixels file is that it will
interpolate the values so if so let's
say that the top corner let's go back to
the diagram here so let's say that this
corner up here this corner here is red
red so this corner up here starts red
and this corner down here oops
is also red is yellow then what will
happen is that you will get a gradient
so as it goes from here to here it will
go from red to yellow as well so we
assign data to our vertices saying this
vertex top left has the additional data
the color red the other one has the
color yellow and for every pixel in
between that doesn't actually belong to
a vertex it's gonna just interpolate by
saying okay this is like 50 person in
the middle so it's gonna be 50% of red
50% yellow means some kind of orange
yeah
and so we get a gradient for free so
yeah it's not really so I said colors
but it's just some data so we already
showed that color
a full value array of a vector for yeah
so I could say that the vector for for
the B corner is a color that represent
the red and the one for the yeah a
corner is a color represents yellow and
the individual numbers in those vectors
will gradually go from one to the other
as it goes as it goes my explanation was
a little bit high level I admit I was
just saying it's gonna miss your colors
it's actually just the numbers the raw
data it's one of those things that bears
saying twice just because it's like a
lot of its variable I guess it's
something that can really come into
advantage yeah and a bit mind-bending
sometimes yeah so that's what we're
gonna do is so I'm gonna save through
what I'm actually gonna send through is
the coordinates so the the coordinate of
the corner of each corner I'm gonna send
that through from the vertex shader to
the fragment shader so that we have a
value which is our actual coordinate
within the rectangle ah okay so yeah
basically in the coordinate system from
minus one to one I'm gonna change that
to be yes so yeah so I will change that
to be from zero to one because we need
that later when we're looking at
textures okay the varies yeah so first
of all how do we communicate between the
shaders so we have a thing called a
varying which means that it varies over
there yeah the coordinates it's gonna be
we're gonna use a vector - and I'm gonna
call it text chords is the coordinates
for the texture as as I discussed and we
need to set that same thing up in both
shaders so that they can be just got I
didn't nature they have the same name
the GL engine is automate gonna figure
out that whatever I put out in the first
vertex shader is gonna be put into the
same variable in the second executive
exam Attica lis link these things to
some magic so in vertex shader we'll set
what that is so the text chords it's
going to be now there's a bit of magic
here so it's going to be our position
which is already a to Chopra's
is the one that goes from minus one to
one it's our screen position right the
yang we drew earlier - one - one - one -
one
so for each coordinate what we need to
do is we need to multiply it by that so
add one to get it from as from most ones
we want to be 0 to 2 and then divide by
2 to get it to 0 to 1 there was a lot I
think there are the ones I think I
believe you say we shift the entire
thing to the right I'm gonna try to make
it from the yours place so we have here
- 1 1 we add one so it goes from 0 to 2
we just shifted the entire thing and
then divided by 2 so one of the things
you might think you have to do is at
okay so text chords dot x equals
positioned X is Texas or something that
is a predefined thing by GL or something
a name that you've chosen it's a name
that I have chosen so we could call it
Dibble dooble yep cool we're not going
to because that seems like a bad
variable name okay well that was what
hurt ray I always do that but you know
yeah so you might think you have to do
this you have to set the X and then the
Y but because shaders are designed for
doing things with vectors and matrices
you can just do it to the whole to the
whole vector will have to do that so
what this will do is it will take each
element of the position and add one to
it and then each element of that vector
and / - magic that's pretty neat yeah so
now when we look up text chords in our
fragment shader it will have the
interpolated value of all so we can
actually use that to get the color also
you can just visualize it basically yeah
so here so like I used up here I used
our 2d vector to make it back yeah to
complete the vector okay we're gonna do
the same here so this is going to be our
X okay so let me try to predict this we
have now for each each vertex it's gonna
output its own position in text course
but it's after using the - 1 - 1
coordinate system it's you it's gonna
use the zero to one coordinate system
correct and then we're going to these
are going to be interpolated for the
pixels in between and be you
as the red and yellow parts of the color
so that would mean that we go from
having blue in the top left corner to
white in the bottom right corner and the
other two colors on the other course
that you just can't figure out green red
plus blue so turquoise and purple well
let me know because there's a zeros when
it's zero green oh plus the blue yeah
you're right you're right but you're
almost right I think you've got the
corners the wrong way around oh oh no oh
yeah I don't know what to quarter ah
it's all blue I expected flipped yes is
it is flipped because zero zero is now
the bottom left corner white oh yeah
alright the Equality system is sorry
yeah I was usually in on the web the
coordinate system starts top left yeah
and GL does not it it grows towards top
and right yes it doesn't help it in
Eric's finish and left and right or
backwards where is in WebGL from bottom
up backwards so when we're explaining it
on camera with our hands oh god it's
usually wrong that doesn't see that does
seem a little wrong I feel like I've
done something wrong but um looks good
to me
there's no there's no red or green when
would that be you have always blue sorry
there's no does it go from purple to
cyan I'm actually colorblind oh this is
a terrible demonstration for me it looks
correct yes
yes to everyone whose joint late welcome
glad you joined anyway because the more
the merrier we are doing some WebGL and
what we're gonna try to with WebGL is
something it has nothing to do with 3d
we're just gonna use WebGL as a really
really first triangle drawing engine and
do some image processing so if you think
of any kind of filter usually apply to
images we're gonna do that in real time
with WebGL because you can because sorry
quite interesting so we can mess around
with colors like that let's do something
more like what we said we were gonna do
the guinea we're gonna use an image so
considering we're using we're working in
WebGL that probably needs textures
exactly
texture it's just some data but it
happens that you treat it as an image
and you can put an image in it so it's
an image I see a recurring theme it's
just like the graphic cards take some
random data and they teach the graphic
card how to interpret that data yeah so
we're gonna create an image this is just
standard Dom I think you're adding a new
there oh yeah yeah now I can actually
know this is JavaScript API so I know
that the source is going to be I caught
it image JPEG somebody just said time to
build the game of life in WebGL I think
that has been done with somebody
implemented the web the game of life in
just shaders which makes it really
really fast it's somewhere it's good fun
so when our image is loaded and is ready
to be used let's do all of the rest of
our stuff ours we don't got to do
anything until the image loads because
we needed to be ready to unload to the
to the credit card graphics card yeah
anything to a credit card now let's have
a chip in it but I don't think it could
fold is I mean okay so obviously in
production code yeah you might be using
requestanimationframe to say when you
draw things I'm just gonna say once the
image is loaded we're ready to go so how
do we use the image we need to create a
texture object so so yeah hmm basically
saying again I mean a chunk of memory to
put image data in instead of random
vertex data that we have you didn't
guess it is create texture just like we
had cream spatial create program create
shader and create everything else
let is legit we call it create
everything else so for textures this
wall we need to do the binding but
there's actually two levels of binding
here so you need to say which unit the
texture is going in because in the
shader you can have up to well it's
graphics card dependent but let's say
you have eight textures you can refer to
single shader so that there is a limit
you can have a certain number of
graphics cards on the graphics textures
card so you can have you have lots of
textures on the graphics card ok but
when you in in a shader you can only
refer to oh yes more than I refer to a
limited amount I'm a single run of the
shader so we we want to say that we are
using active texture is what as you can
say texture zero number because that's
it's the zero is the default for when we
access the shader I get their texture in
the shader and then we actually need to
bind the texture the name that we're
using here so before we have the name
array buffer this is going to be texture
texture 2d the thing we're binding is
our texture then we actually set some
set an image into that so text image to
GL Giada thanks image 2d so our target
which was texture 2d as I said yeah we
are so we actually want the other edge
count for you so I'm really excited to
see that there but the last parameter of
this function as you can see from the
visual code autocomplete is the pixels
which can be an image but it can also be
oh it's not like a person but it can
also be a bitmap in HTML image element
or an HTML video element yes isn't that
exciting lots of things can be drawn
into a canvas which is awesome so so
what is the internal format is RGB a
it's going to have great green blue and
alpha the format of the image that we're
getting is RGB a because all image image
elements that Dom elements come through
that way the actual type is so each of
those elements red green blue alpha is
going to be an unsigned byte in
in the file obviously get them as a
float yeah shader and the thing we're
actually passing through is our image
okay thing we load it at the very top we
made it on onload for yes I'm just gonna
pass that in because I guess that is the
very slight additional convenience that
WebGL has over OpenGL website you know
you're on the web at the least I can do
is help you convert web image formats to
OpenGL image formats yes now we have to
set some parameters on and our texture
basically the the graphics card likes to
work with textures that are power of two
in size so that they are say 512 by 512
am able to o4a by target before right
our image is just an arbitrary size so
we have to say how yeah we have two
other deals at some set some parameters
that tells you how to deal with it
so we're going to set the it's the
texture wrap texture wrap s so wrapping
can happen horizontally or vertically
some reason those coordinates are s and
T I guess what it is for is that if you
at the in the end you're gonna pick
pixels from the texture and ask what
color is this pixel what should happen
if you actually request a pixels outside
the image that is we're wrapping comes
in should have wrapped around and you
just keep going in circles sort of just
repeat the last pixel at the edge these
are the parameters we are starting here
because for some reason it makes opengl
work with images on arbitrary sizes I
think you said it before so it is
basically a magic incantation to make it
work don't think about it too much you
don't have to do this with WebGL too but
with WebGL one you do so we also set the
the minute
yeah what to do if and the min filter
and mag filter is if we're if we're
blowing up the the image so that one
pixel of the texture is going to take up
more than one pixel of the screen what
to do and vice versa if more than one
pixel of the texture is going to be
widget until one
in one pics on the screen what to do
here we're using nearest-neighbor
filtering yeah because that's you know
what she's linear it will look better
basically everything I would if multiple
pixels are squished into one screen
pixel or the other way around it's going
to interpolate between them so we can
now access this texture in the shader
we've set it to be texture zero which is
the default one in the shader we don't
actually have to hook up anything there
cool so here we need a kind of variable
that's known as a uniform which is a
thing that is the same for every run
yeah so for all the paper global that
are having that are running this program
in parallel a uniform is gonna have the
same value in contrast to a varying that
can vary across parallel running
instances of your shaders that's what
the two differences are the name says
arabic infiniti because that uniform can
change between runs when we draw the
next version of our I mean next time we
call drawer arrays we could have set the
uniform to some house
so here the type is a sampler 2d which
is a thing for sampling a texture
sampling meaning what I said before
asking what is that pixels color exactly
that's taking a sample in GL speak so
we're going to call the texture 2d
function we're gonna pass it in our
sampler say where we're gonna get it
froggy and we're passing our text chords
say we're in well as an arrow planned
this so now our fragrant color should be
the color of the image for every part of
the and hopefully let's see how that
boom it is upside down but we have a
picture I mean the the flipping around I
think is how we can fix pretty quickly
I would assume yeah so one of the first
things I'm going to do here is I'm just
gonna quickly magic up some style way I
make it bigger so the canvas is going to
be what abacus I make it
I don't know what the aspect ratio is
we're just gonna go until they watchin
whatever I've done something different
beautiful and it is vertically flipped
because
being something I did not write down and
maybe should have done so for the web
there is actually an extra feature in
WebGL that is not in OpenGL which says
all my textures are back upside down ah
that's convenient because when you get
it out of an image element it is upside
down from what it would be in most
OpenGL libraries well we're just gonna
do it ourselves because you know we're
already in trade off anyway might as
well yeah so in our case I'm just gonna
say that in our text cords I'm gonna say
that text cords why cause one mine one -
oops I can't type yeah so that's
basically what used to be one is no zero
which is to be zero is now one it's a
flip of the white cord and it should be
the right way around so now suddenly the
picture of Australia has become a
picture I know Italy maybe so one of the
things you might notice here is that
I've made it bigger but it it's now very
Pixley I don't know if you can see that
on the stream it's a very pixel I mean
that isn't from even from a giass
website I know it's because the canvas
still only has its default number of
pixels which is 300 550 so it would
probably increase that as well yeah so
I'm gonna do say the canvas width can be
the image ducked natural width so we're
gonna say whatever the natural width of
the image is so the number of pixels in
our canvas regardless of how it looks on
screen number of pixels in a canvas is
going to be whatever was in the original
image so if we stretch the canvas around
whatever we like it will always be just
as good as the original image there we
go much so we're going to use this
situation at this this moment to make a
very short pause they're gonna try to
restart the stream real quick to fix the
audio is apparently going oh dear we
have been out of sync a little bit so
I'll wait for apparently we're already
fixed I was quick all right you may
continue thank you
so now that we've got our image going I
guess I could set the no.1 so now we
said image processing so let's talk
about how we might do some processing
one of the things we can do in our
fragment shader we can do a little bit
of calculation of this color perhaps so
this is where we finally fulfill the
title of today's episode because we're
not going to just draw an image we're
going to do make some image processing
happening so we're going to take it
we're gonna process it to look
differently in some way so one of the
things we can do is there are various
filters that exist if you use image
editing stuff you get all sorts of
filters let's change the warmth of the
image so I'm going to set up a a
variable I'm just going to make a float
and I call it warmth I'm gonna set it
for the mount I'm just I'm just gonna
pick a value out of out of thin air now
this this filter when I saw how this was
done I don't know if this is how it's
done in every image app but it seemed
magic one filter
you probably know is usually in this
image app you can make a picture look
cooler or warmer which gives it like a
blue light bluish tinge or like a nice
orange tint on beach pictures a warmth
filter is always nice yeah so we're
gonna instead of sending this straight
to the freight car I'm gonna pull it out
into a variable alright as that I can
manipulate it you could salute many of
live gl for a color I'm pretty sure but
and then we do is you say that colored
are oh so our all of the vectors so
back-to-back three back for all the
vector types you can refer to them with
X Y Z W if you're talking about them as
coordinates yeah
or RGB a if it looking that there's a
color it's just like an alias
so here where I say color to are I'm
saying it's just the first the first you
look as well
no probably maybe I think it's just the
two so R minus equals warmth no sorry
plus equals because one positive values
to make it feel warmer and colored up B
minus equals warmth which if you know
whether that's doing color wise that
just seems mad it's just gonna bump up
the blueness sofort when you make it
warm it's gonna bump up the redness and
bump down the blueness okay and vice
versa
yeah now what will happen here is that
potentially our warmth our color values
could go below zero or above one but let
just be clamped to zero is something
that allows for us just for free so it
will happen in the graphics card when he
actually gets sent as a pixel yeah well
when it works out what the actual
colored set from the float value it will
do it then okay we can say it won't
happen immediately so color dot are they
sewed on a similarly B negative which
sometimes it's what you want if you do
some further processing after and you
want to be aware off like this overshoot
or undershoot whatever the right charm
is and it's got the values not lost
right away but you can be sure that the
stuff on screen it's gonna be correct
data and this looks much warmer yeah
I'll make it cooler that's simple
just make that negative much cooler so
again you can do things like so
brightness that there are lots of there
are lots of different ways of doing
these filters that are like people have
studied the psychology of perception and
they're the physiology of your eyes and
they work out these cool mathematical
models and then other people come along
let's just say it's approximately just
eyeball it add some numbers so
brightness is the same sort of thing
we're just going to say well okay we're
gonna do them right colored RGB eye
we don't want to add the opacity yeah so
this is this is known as Swizz lling for
reasons I'm not actually hundred percent
sure where you take a vector and just
use a part of it I'm just going to say
add on the brightness all right so now I
have got to have a cooler but brighter
picture and it is a fact brighter yeah
amazing and because this is happening
machine about Photoshop yeah it's yeah I
think it's a little way to go before we
get there maybe but I mean this is the
principle for a lot of these films and
the thing is we could actually animate
these parameters and it would run at
60fps and I'm willing to bet that it
wouldn't be as smooth if we just
JavaScript canvas if you had to do these
operations and every pixel like add some
value so the RG and B value it would a
be painful and B being rather slow so
whenever you want to do like per pixel
animations WebGL is the way to go I
think we are pretty much on time now so
I'm really happy that we just were able
to show ya the actual processing bit to
happen um as always I'm gonna ask you to
give me the core effort so I can put up
on our github repository which is in a
new location actually it's now in the
Google Chrome labs organization
it's the UI element samples the clothes
gonna be in there we're gonna add some
comments so you can play around you can
implement your own processing you can
switch the hour and the B around to make
the red part be the blue part in the
blue up in the right part and destroy
your image why wouldn't you thanks
everyone for watching
great to see again that there's always
people showing up in the chat and asking
questions and being involved what we do
thank you very much for doing this no
worries thank you lots learned and I'll
see you all well next time around bye</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>