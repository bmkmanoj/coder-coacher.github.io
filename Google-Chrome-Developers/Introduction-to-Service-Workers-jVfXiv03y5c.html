<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Introduction to Service Workers | Coder Coacher - Coaching Coders</title><meta content="Introduction to Service Workers - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Introduction to Service Workers</b></h2><h5 class="post__date">2017-04-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/jVfXiv03y5c" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">service workers are at the core of
progressive web app techniques for
resource caching and push notifications
in this session you'll learn what a
service worker is and what it can do for
your apps a service worker is a
client-side programmable proxy between
your web app and the outside world it
gives you fine control over network
requests for example you can control the
caching behavior of requests for your
site HTML and treat them differently
than requests for your site's images
service workers also enable you to
handle push messaging now service
workers are a type of web worker an
object that execute the script
separately from the main browser thread
service workers run independent of the
application they are associated with and
can receive messages when not active
either because your application is in
the background or not open or the
browser is closed the primary uses for a
service workers are to act as a caching
agent to handle network requests and to
store content for offline use and
secondly to handle push messaging the
service worker becomes idle when not in
use and restarts when it's next needed
now if there is information that you
need to persist and reuse a course
restarts then service workers can work
with indexdb databases service workers
are promised based now we cover this
more in other materials but at a high
level a promise is an object these are
the kind of placeholder for the eventual
results of a deferred and possibly
asynchronous computation service workers
also depend on to api's to work
effectively fetch a standard way to
retrieve content from the network and
cache a persistent content storage for
application data this cache is
persistent and independent from the
browser cache or network status now
because of the power
of a service worker and to prevent
man-in-the-middle attacks where third
parties track the content of your users
communication with the server service
workers are only available on secure
origins served through TLS using the
HTTP protocol will test service workers
using local host which is exempt from
this policy by the way if you're hosting
code on github you can use github pages
to serve content their provision with
SSL by default services like let's
encrypt allow you to procure SSL
certificates for free to install on your
server Service Worker enabled
applications to control network requests
cache those requests to improve
performance and to provide offline
access to cached content but this is
just the tip of the iceberg we will
explore some things you can do with
service workers and related api's
caching assets for your application will
make the content load faster under a
variety of Network conditions two
specific types of caching behavior
suitable for use are available through
service workers the first type of
caching is the precache assets during
installation if you have assets HTML CSS
JavaScript images so on and these are
shared across your application you can
cache them when you first install the
serviceworker when your web app is first
opened this technique is at the core of
application shell architecture now note
that using this technique does not
preclude regular dynamic caching you can
combine the pre cache with dynamic
caching the second type of caching is to
provide a fallback for offline access
using the fetch API inside a
serviceworker we can fetch request and
then modify the response with content
other than the object requested use this
technique to provide alternative
resources in case the requested
resources are not available in cache and
the network is unreachable service
workers can also act as a base for
advanced features
service workers are designed to work as
the starting point for features that
make web applications work like native
apps and some of these features are
channel messaging API which allows web
workers and service workers to
communicate with each other and with the
host application examples of this api
include new content notifications and
updates that require user interaction
the notifications API is a way to
integrate push notifications from your
application to the operating system
native notification system the push API
enables push services to send push
messages to an application service can
send messages at any time even when the
application or the browser is not
running push messages are delivered to a
service worker which can use the
information in the message to update
local state or display a notification to
the user background sync lets you defer
actions until the user has stable
connectivity and this is really useful
for ensuring that whatever the user
wants to send is actually sent this API
also allows servers to push periodic
updates to the app so the app can update
when its next on line every service
worker goes through three steps in its
lifecycle registration installation and
activation to install the service worker
you need to register it in your main
JavaScript code registration tells the
browser where your service worker is
where it's located and to start
installing it in the background for
example you could include a script tag
in your site's index.html file or
whatever file you use is your
applications entry point with code
similar to the ones shown here this code
starts by checking for browser support
by attempting to find Service Worker as
a property in the navigator object the
service worker is then registered with
navigator dot Service Worker dot
register which returns a promise that
resolves when the service worker has
been successfully registered the scope
of the service worker is then logged
with registration dot scope
you can attempt to register a service
worker every time the page loads and the
browser will only complete the
registration if the service worker is
new or has been updated the scope of the
Service Worker determines from which
path the service worker will intercept
requests the default scope is the path
to the Service Worker file and extends
to all directories below it so if the
Service Worker script for example
Service Worker dot gif
is located in the root directory the
Service Worker will control requests
from all files at best domain you can
also set an arbitrary scope by passing
in an additional parameter when
registering in this example we're
setting the scope of the Service Worker
to slash app which means the service
worker will control requests from pages
like slap slap slash lower and slash out
slash lower slash low directories like
that but not from pages like slash app
or slash which are higher a service
worker cannot have a scope above its own
path
this is in your service worker file
service worker dot j s now thinking
about installation once the browser
registers a service worker the install
event can occur this event will trigger
if the browser considers the service
worker to be new either because this is
the first service worker encountered for
this page or because there is a bite
difference between the current service
worker and the previously installed one
we can add an install event handler to
perform actions during the install event
the install event is a good time to do
stuff like caching the apps your static
assets using the cache API if this is
the first encounter with the service
worker for this page the service worker
will install and if successful
transition to the activation stage upon
success once activated the service
worker will control all pages that load
within its scope and intercept
corresponding network requests however
the pages in your app that are
open will not be under the
serviceworkers scope since the
serviceworker was not loaded when the
page is opened to put currently open
pages under serviceworker control
you must reload the page or pages until
then requests from this page will bypass
the serviceworker and operate just like
they normally would service workers
maintain control as long as there are
pages open that are dependent on that
specific version this ensures that only
one version of the serviceworker is
running at any given time if a new
serviceworker is installed on a page
with an existing serviceworker the new
serviceworker will not take over until
the existing serviceworker is removed
old service workers will become
redundant and be deleted once all pages
using it are closed this will activate
the new serviceworker and allow it to
take over refreshing the page is not
sufficient to transfer control to a new
serviceworker because there won't be a
time when the old serviceworker is not
in use the activation event is a good
time to clean up stale data from
existing caches the application note
that activation of a new serviceworker
can be forced programmatically with self
dot skips waiting service workers are
event-driven installation and activation
events fire off corresponding events to
which the serviceworker can respond the
install event is when you should prepare
your serviceworker for use for example
by creating a cache and adding assets to
it the activate event is a good time to
clean up old caches and anything else
associated with a previous version of
your serviceworker the serviceworker can
receive information from other scripts
through message events there are also
functional events such as fetch push and
think that the serviceworker can respond
to to examine service workers navigate
to the serviceworker section in your
browsers developer tools different
browsers put the tools in different
places
check debugging service workers in
browsers for instructions for Chrome
Firefox and opera
a fetch event is fired every time a
resource is requested in this example we
listen to the fetch event and instead of
going to the network returned the
requested resource from the cache
assuming it is their service workers can
use background sync here we start by
registering the service worker and once
the service worker is ready we register
a sync event with the tag foo the
service worker can listen to sync events
this example listens for the sync event
tagged foo in the previous slide do
something should return a promise
indicating the success or failure of
whatever it's trying to do if it
fulfills the sync is complete if it
fails another sync will be scheduled to
retry retry syncs also wait for
connectivity and employ an exponential
back-off the service worker can listen
for push events push events are
initiated by your back-end servers
through a browsers push service this
example shows a notification when the
push event is received the options
object is used to customize the
notification the notification could
contain the data that was pushed from
the service service workers can be
tested and debug in the supporting
browsers developer tools screenshot here
shows the chrome dev tools application
panel there are lots of great resources
to help you get started and find out
more access them from the materials that
accompany this video in the lab
materials that accompany this video you
can practice working with service
workers and learn more about
intercepting Network requests</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>