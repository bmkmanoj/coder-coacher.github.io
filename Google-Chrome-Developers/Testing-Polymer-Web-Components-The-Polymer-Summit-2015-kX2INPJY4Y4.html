<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Testing Polymer Web Components (The Polymer Summit 2015) | Coder Coacher - Coaching Coders</title><meta content="Testing Polymer Web Components (The Polymer Summit 2015) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Testing Polymer Web Components (The Polymer Summit 2015)</b></h2><h5 class="post__date">2015-09-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/kX2INPJY4Y4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hey guys how's it going
so this is testing with polymer
featuring web component tester and
Friends we're gonna talk about testing
how well the polymer team tests what
we're gonna talk about how the polymer
team tests the web platform features of
the future by way of introduction I'm
Chris Joel I'm software engineering
contributor to the catalog of polymer
elements you can also find me on github
at Robo Dynamo sorry on Twitter
Robo Dynamo and on github at C data so
test-driven development and behavior
driven development these things are
really important when it comes to
testing we're not gonna be covering
these in detail today we have a baseline
expectation that you guys are familiar
with this stuff expectation frameworks
assertion frameworks very important I'm
gonna assume that you have at least a
passing familiarity mock stubs and spies
these are kind of an advanced testing
topic but I'm also gonna kind of gloss
over them and assume that you've seen
them before and we're definitely not
going to talk about why testing is
important we all know the superhero who
thinks that you doesn't need to test his
code we all know better don't be that
person so how many of you guys think
testing is hard or you know maybe it
could be easier like could stand to be
improved can I see a show of hands yeah
yeah I've heard a little bit of FUD that
web components in particular or you know
kind of tricky to test not easy to
reason about I'm happy to be the one to
assure you that not only are they easy
to test web components can make testing
the whole the whole experience of
testing just much better and the polymer
team has built some great tools to make
the whole experience even better than
that so we're going to talk a ton about
testing web components I want to set
some baseline ground rules there are a
lot of details that go into really good
test Suites and in particular I want to
talk about three qualities that I value
in my test Suites these aren't the only
things I like but they're pretty high on
the list a good test test suite should
be order independent
if desired I should be able to run my
tests in random order and in fact as
some of you probably know most test
Suites out there support this feature
you can just run your tests in random
order test which should be repeatable
with consistent results if I run a test
once and it passes it should pass if I
run it again immediately afterwards of
course there's no avoiding the
occasional haizen bug but for the most
part you want your tests to be
consistently repeatable and third you
really want your tests to be dry don't
repeat yourself test Suites can grow in
unexpected ways so we need to keep
repetition to a minimum every time you
copy and paste something while filling
out your test suite it should be
considered a code smell so I mentioned
that the polymer team has built some
useful tools for making testing even
more delightful tool at the center of
our testing world is web component
tester you guys have probably seen this
if you've gone through some of the code
labs we call it WCT for short on the
polymer team WCT is a batteries included
solution for rapidly building out robust
test Suites for web components what do I
mean by batteries included MOCA provides
a baseline for BDD and TDD styles chai
is included this provides expectations
and assertions also so non Jas is on
board
enabling easy mocks stubs and spice do
you want to test your run your test
suite in multiple browsers at once of
course you do
your web developers selenium is built
right into a web component tester WCT
can drive multiple browsers with just
one command we have general selenium
support built-in so we also added
support for sauce labs sauce labs is
basically selenium in the cloud so you
can run your local tests in virtually
every browser configuration just
configure WCT with your sauce labs api
and you're good to go some of WCT zone
features are built using a published
plugin API so you can teach WCT a new
trick if you want
what does testing web components really
look like with
VCT well writing tests for WCT is as
simple as creating an HTML document
first include the WCT runtime in your
head and import the element you want to
test for this talk I'm going to be
testing a polymer element called paper
button you guys are probably familiar
with this one as you can see I've
imported paper button dot HTML in my
head we want to test the element in this
natural habitat the HTML document so
next I add paper button into the body of
the document to use as a test fixture
for my test and below the button I begin
a script tag where I start a mocha TDD
style test suite here are my tests we is
just gonna be called paper button then I
fill out the suite and add a test to
kick things off this test isn't very
robust it's really just pulling the
button out of the document and testing
that it's okay but it's a good start
putting it all together we have a nice
example of a basic test in WCT note that
we didn't have to do any extra work to
get TDD or search or expectations it's
all included and if the syntax looks
familiar to you it's because we're using
the tools that you probably already use
so now that we have our test suite I
want to try it out at first I'm gonna
spin up an HTTP server and open the test
HTML in my browser there we go just copy
paste the URL
it's looking good since web components
are just HTML it should be really easy
to run the tests in a web browser and it
is in the real world paper button needs
to work in as many browsers as I can
throw at it this is where WCT really
starts to shine watch what happens when
I run my tests right through WCT WCT
finds all the browser's on my system and
runs the test suite against them so far
chrome stable canary Safari Firefox
they're all looking good here's our
button test suite again there aren't
many useful tests in here yet I want to
add some tests that test real features
in paper button first I need a feature
to add tests for every paper button can
be given a toggles attribute this
attribute makes paper button toggle
between on and off each time you click
it here's the normal button and here's
the toggle button every time I click it
it toggles between on and off this
causes an a property on the button
called active to be set to true or false
okay so I know what feature I want to
test in the button first I write out my
test the toggle button activates when
clicked now I select my paper button
from the document and assign it to a
local variable here I'm just using query
selector to pull the button out of the
document after I run this code button
will be assigned to the button in my
document and here's the meat of the test
I set toggles property to true which
makes this button a toggle button then I
click the button and activate it and
finally I check that the button is
activated by expecting the active
property to be true here I'm just saying
expect button dot active to be equal
true let's put it all together pull the
button out of the document make the
effects on the button and then set my
expectations this looks like a pretty
solid test but what about the normal non
toggle button
we should probably test that a normal
button behaves correctly as well this
turns out to be a super easy test to
write this is very similar to the one we
just wrote the main differences are that
we don't set the button to toggle and we
expect that the active property is false
so before we go any further I have to
point out that a new problem has come up
now you may already know this but at
Google engineers have a tradition called
testing on the toilet so trust me when I
say this we're experts on leaky state
state leak is a common accident in test
Suites and we just had that accident
let's look at the new tests all together
I know this is a lot of code to look at
in one slide but can you find the leaky
state here I'll give you a second to
check it out raise your hand if you find
it the value of toggles is set in the
first test it doesn't get unset before
the second test this means our second
test will fail if it runs after the
first one these tests are not order
independent the order in which state
leaks makes a big difference the tests
are not runnable in isolation either
they depend on li state and will often
fail without it leach state could change
across our test runs if I did run these
tests in random order I might get a
failure or I might get in a success who
knows the worst part about all of this
is that we did something that seemed
right but it didn't work right after all
test fixtures in HTML represent global
state in our test suite and the internal
state of each element is difficult to
reset hygienic ly well thankfully
there's an element for that web
components are here to help as it turns
out there is a custom element that
enables us to address this problem for
testing polymer elements we created the
test fixture element this element
packages a same approach to declarative
HTML fixtures in order to use it first I
create
test fixture element and give it an
appropriate ID I'm just gonna call this
one paper button because I'm testing
paper button next I'm going to add a
template to my test fixture element the
contents of the template are going to be
the HTML I want to test so I'm just
gonna put a paper button in here bring
it all together I have a template that
gives context to my paper button test
fixture using the test fixture couldn't
be easier I'm gonna create a setup
function for my test suite to help keep
things dry in setup I call a new mocha
helper called fixture the fixture named
paper button then stamps his template
into the Dom and returns the contents
after this code is run button will be
assigned to a newly created paper button
here it is with the rest of the test
suite our test fixture will handle
creating a new button at the beginning
of each test then after each test the
test fixture will automatically teardown
the HTML by removing it from the Dom as
our test suite grows we can add as many
new test fixtures as we want here I've
added a new test fixture for a toggle
button this is great because it means
when I want to test toggle button
features I can just stamp the toggle
button test fixture different test
fixtures can be created for all kinds of
scenarios and the best part is since you
control when the test fixture is stamped
you can wrap side effects like Network
requests or timers so far so good we've
covered some very useful tools but
there's still some other nice toys that
even we've been working on to help make
testing polymer an even more delightful
experience I want to cover some of those
with you briefly so you guys can stay on
the horizon of testing polymer I already
told you about the new fixture elem or
fixture mocha helper we also created
another mocha helper called stub this
helper enables the tester to replace
partial element implementation with
custom methods here I'm replacing the
click method on paper button with a
custom implementation the new
implementation logs
to the console instead of the default
behavior this is great because now I can
capture side effects from clique being
called on the button for the raishin of
any test that uses this setup the custom
implementation will replace the original
implementation you don't even have to
use this directly on a button reference
you can just say for all paper buttons
I'm going to stub this implementation
and the best part is the implementation
is automatically reset after each test
this uses non under-the-hood and so
those of you who are familiar with sonon
will be nodding your heads stub methods
are justesen on spy's which means during
my test I can run expectations on things
that happen to these methods here I'm
checking things like how many times was
clique called or what arguments were
passed to clique or what order were
different methods that I've stubbed
called in we've also introduced a
replacement helper this helper replaces
matching element children in all other
elements for the duration of the test so
that's a little bit to swallow so let me
walk you through what that means it's
very easy to use first I call replace
with tag name that you wish to replace
and then I also tell it what alternative
tag name I want to use how is this
useful here I have two representations
of an element I'm working on called X
custom element the first is the actual
template of the element it has a paper
button inside so every time an X custom
element gets created paper button will
be created as well what I want is to
remove paper button from the experience
so that I don't get any side effects so
I've replaced paper button with fake
paper button the effective template when
this element gets created is going to be
the one below where a fake but paper
button is created it still gets the same
attributes in the same content but it's
effectively a fully stubbed-out element
and just like stub and just light
fixture all of the changes are reverted
at the end of each test
last but not least we have a topic that
I am particularly excited about polymer
element authors consider accessibility
issues to be top priority bugs testing
elements for accessibility or Russians
has become a major area of exploration
for us Alice Boxhall and Laura Palermo
will be giving a great talk on
accessibility later today so definitely
check it out Alice in particular has
done a tremendous amount of work on a
Chrome extension called accessibility
developer tools you should also check
that out if you haven't seen it
everybody should have this installed
some of you may have heard of it here's
a screenshot of what it looks like in
action for those of you that haven't one
of its major features is that exist
it'll allow you to do an accessibility
audit on any arbitrary page of your site
here I have done an audit of a major
American news outlet it looks like they
have some room for improvement wouldn't
it be great if they could just add this
to their web component test suite now
they can dan Friedman has done a great
job and integrated this directly into
web component tester you can use
accessibility suite against any text
test fixture in your suite it'll cause a
suite of 26 audits to be run against
your fixture dom accessibility suite
will automatically filter out audits
that are not relevant to your DOM and
failed audits will cause your test suite
to fail accessibility testing is a very
tricky thing to automate correctly and
the accessibility developer tools are
certainly not exhaustive we're exploring
more strategies in this area and there's
definitely more to come so today I
showed you that web components are not
the web component testing is not hard
in fact web components to make the whole
testing experience much easier and bring
new advantages to your test suite and
you learned about a bunch of exciting
tools that the polymer team is working
on to make testing web components and
polymer elements even better thanks for
coming to the summit today and for
taking some time to learn a little bit
more about testing polymer and web
components
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>