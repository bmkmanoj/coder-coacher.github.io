<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>PWAs in any context (Progressive Web App Summit 2016) | Coder Coacher - Coaching Coders</title><meta content="PWAs in any context (Progressive Web App Summit 2016) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>PWAs in any context (Progressive Web App Summit 2016)</b></h2><h5 class="post__date">2016-06-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/8dr_IUGwsO0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">see I what's up I'm Donald max of a Bob
Dodd and today I want to talk to you
about how we can make sure that as we
build our progressive web apps that all
of our users can access the content in
those apps now Paul just showed some
really cool examples of how to build
amazing components and as he hit on
repeatedly in his talk you know we know
that performance is not just a nice to
have performances kind of a crucial
aspect of a good user experience we know
that users will actually abandon an
application if it doesn't have the
performance that they expect but it's
often the case that when we're designing
these components and these applications
we're doing so based on our own
experience and our own physical
abilities so we're designing for the
range of users who really see and
interact with the world as we do meaning
anyone who falls outside of that range
is going to be excluded from our design
so these users aren't abandoning our app
they're actually prevented from using it
in the first place and so as to sign
errs and developers it's important that
we not only consider how we interact
with the world but we really think about
the full range of human abilities and
this becomes especially important when
we're talking about mobile because as we
use our devices in different contexts
and in different environments we may to
experience situational or temporary
impairment so to give you an example I'm
sure many of you have had the experience
of trying to use your your phone or some
electronic device outdoors when it's
really sunny and you need like you can't
really read the screens doing this thing
right you need some additional contrast
on the screen so you can actually read
it so if we have a design that also
factors in the needs of low vision users
folks who also benefit from increased
contrast and their reading experience
then what we end up with is just sort of
a more robust application it works well
for those users it works well for us as
we take our mobile devices out in the
Sun in other words accessibility just
equals good ux
I'm in the crazy slider too there we go
accessibility is just good UX right so
this is what I want to talk about today
how do we make sure that all of our
users can access the content in our apps
I'm going to do this by splitting this
talking to three parts so the first part
is looking at really the diversity of
users that are out there and touching on
the accessibility topics that affect
them then I want to look at tubic areas
that developers often miss which are
particularly focused on focus and
semantics but i want to start just by
understanding who our users are and the
kinds of assets of technology that they
use now i'm going to focus on users with
permanent disabilities but again I want
to reiterate that issues of
accessibility really do affect all of us
ensuring that users with disabilities
can access the content in our
applications is just going to make a
better experience for everyone but
having said that let me get some numbers
out there because I think these are
pretty fascinating so according to the
world health organization about fifteen
percent of the world's population lives
with some form of disability so to put
that another way we're talking about
around 1 billion people worldwide and we
can roughly split these into about four
different sort of categories of
impairment those affecting visual senses
those affecting motor and dexterity
auditory senses and cognitive senses and
want to cover each of these individually
starting with visual senses so users
with visual impairment you can kind of
split them into two groups those folks
who might be completely blind and have
no vision to those folks who might have
limited or low vision so someone who is
completely blind might use a screen
reader this is talk back on Android to
interact with their device they may also
use a Braille reading device to access
their desktop and have it sort of
translate the content for them in that
environment so that's users with no
vision users with low vision they may
also use a screen reader or row now go
back there we go they may also use a
screen reader or they may choose to use
screen magnification and might use a
built-in zoom that's at the browser
level or sorry at the operating system
level as you're seeing here
might use browser zoom just you know
command + to zoom in the page let me
also use something like high contrast
mode so here you're seeing that the
background of the foreground colors have
been swapped to increase legibility so
that was a that was vision for for motor
impairment these users really span the
gamut of folks who maybe would prefer
not to use a mouse because they have
something like repetitive stress injury
something like carpal tunnel syndrome or
maybe even just like a broken arm or
sprained wrist all the way to someone
who might have be or who might be
physically paralyzed and have a limited
range of motion so for these users they
may be using head or eye tracking
devices this is an example of a program
called Dasher which uses a webcam to
track the user's head and eyes and help
them type they may also be using a
keyboard or a switch device as you're
seeing here to actually drive their
computer they may also use voice control
so there's a lot of different mechanisms
that they can use for auditory
impairment these users range from those
who are profoundly deaf just someone who
is hard of hearing so I'm actually in
the heart of hearing camp I've got about
ninety percent hearing loss on my left
hand side so for these users you want to
make sure that you're not relying solely
on sound to convey information in your
app so making sure that if you have a
video right you've got captions that
you've got transcripts but you're
providing some kind of alternative if
sound is part of your interface and
finally for cognitive impairment this is
really a broad area that can be
difficult to quantify but its pants
conditions like ADHD dyslexia autism
just to name a few and while the
accommodations for these groups are
obviously extremely diverse we
definitely find some overlap with things
like zooming to make it you know easier
to read and easier to concentrate on the
page so this is a Chrome extension for
someone with dyslexia it applies color
gradients to the text to aid in their
reading order and help them read in kind
of a more linear fashion so broadly
speaking these are the four categories
that we need to think about when we're
working on accessibility in our app now
because accessibility is so broad and
the user ship is so diverse it can be
helpful to have a guide to make sure
that we are covering each of these
groups we can find that in the form of
the web content
accessibility guidelines to data or what
CAG mechag is basically a set of best
practices which have been put together
by accessibility experts to really try
and like like explain what it means for
something to be accessible and what KAG
is extremely comprehensive but it can
also be overwhelming I know some folks
look at that and they're like that is
not a thing I'd want to read right now
right so to help mitigate this the
webbing group has actually taken what
KAG and distilled it down to a very easy
to follow checklist which is targeted
specifically for web content so if you
were watching those videos earlier and
you were wondering well how am I going
to possibly cater to all these different
users and all these different assistive
technologies I think the short answer is
to nail that checklist okay figure out
what the primary user journeys are in
your application if creating a new
account is is an extremely important
process that you want all users to
complete and take that user journey and
for every step along the way make sure
you can check off those relevant
checklist items and do this for every
phase of your process right so get your
your product managers bought into it get
your designers bought into it and make
sure this is you know you're having
accessibility audit senior design review
your developers bought into it get your
QA team bought into it and checking
these things to ensure that it you know
the burden does not rely on one person
so with these checklists in hand we're
actually ready to start exploring some
of the fundamentals which will need to
actually complete those checklist items
and I want to start by looking at focus
and really like like what is focus like
what does it mean for something to be
focused in the browser if we really try
and get down to first principles so in a
nutshell focus determines where keyboard
events go in the page to give me an
example if I go and I click on this text
field that act of clicking on it
actually focuses it and from then on as
i'm typing on my keyboard all key events
are directed to that element which in
this case newest to display the
characters as i've typed them now some
users drive their computer entirely with
a keyboard or some other type of
discrete input device so for these users
focus is absolutely critical because
it's their primary means of reaching
everything on the page it's also really
important for
our screen reader users because we're
building something like a single page
web app and we're adding new content to
the page right we're fading in a new
page or something like that and we need
to direct focus to that page so the user
knows that it's loaded they know it's
available and their screen reader can
announce it and we'll talk about that a
little bit later on now a lot of the
controls that you're familiar with
working with things like button input
select all these elements are implicitly
focusable what that means is they are
naturally inserted into the tab order so
user can reach them hitting the tab or
shift tab keys on their keyboard and
they have built in keyboard behavior
supports so if you take a select element
and you hit the up and down arrow keys
right you can select something space or
inner it'll select something right so
they have a lot of goodies built into
them already but not all elements are
focusable so for instance this this
header here this paragraph of text this
image of a cat these are not focusable
because there's generally no need to
focus something if a user can't interact
with it or provide it some sort of input
now if you're worried that someone with
a visual impairment might miss some of
this important content don't be that's
why we have tools like screen readers
it's a screen reader sole job is to read
headings and read texts and read the
content of an image using alt alt tags
so don't make something focusable if the
user can't interact with it that might
seem like you're helping out but it's
actually detrimental to the user
experience and this brings up and
extremely interesting an important point
which is that if you build your
interactive controls out of these sort
of non focusable elements a div for
instance then your users may not
actually be able to interact with it at
all so I'll give you an example using
pulse site nav this is actually not
Paul's exact side nav I've modified it a
little bit but you can see here that
I've got my little hamburger menu up
there in the top left and obviously I
want to tab over and click that to open
my menu and right now my focus is on
that little start anchor up there in the
header so as I
tabbing around or hit hitting shift-tab
in this case you'll see that my focus
never lands on the hamburger menu
because it's a div and it did is not
focusable so if I am a keyboard or
switch device user I'm a potentially
never be able to click on that menu ever
so how do we fix this this is obviously
a bad user experience well the
straightforward thing to do is instead
of using a div we can just use a button
element right so now when the user goes
to tab over to it because button is
easily styled we can make it look like a
hamburger menu now they're inside of our
drawer things are all good a side
benefit of using a button element in
this case is that the browser actually
has built-in magic that you get for
using certain tags like button sew a
button element if you give it an onclick
handler and someone lands on it they
focus it in a hit enter or spacebar even
though they didn't click with their
mouse technically the browser will just
say enter space bar yeah I'm going to
run your onclick handler for you if
however you have a div and you make it
focusable and i'll talk about how to do
that later and you have an onclick
handler on that and someone hits inner
or space bar nothing happens you
actually have to add an additional key
down handler and then you have to check
which key was clicked inside of the key
down handler so there's really no
benefit to using these kind of like less
or non semantic elements to do this kind
of work in other words don't fight the
platform here so the browser has a lot
of built-in stuff it's trying to save
you from having to write extra code but
I realize you know there's not always a
native element that has the behavior
that you need or as is often the case
there might be a native element but it
might be really hard to style things
like you know checkboxes and radio
buttons input file that thing's
impossible so if you are going to go and
build a custom control it's important to
remember that you just have to add that
keyboard support back in I can do that
using the tabindex attribute so tabindex
lets you kind of configure the focus
behavior for an element and it can be
applied to pretty much I guess many or
most HTML elements at am and x value of
0 is going to just insert that element
into the natural tab order meaning
someone can hit the tab key on the
keyboard and will easily reach it it
also means that we can call its focus
method
to programmatically focus it so here
I've got this very fancy button that I
have created right now if I press tab
focus just just going to move right past
it so i give it tabindex0 now when I
press tab focus lands on it and we're
all good tabindex negative 1 means that
the element will not be in the tab order
but this can be really useful if you
still need to programmatically focus
something using javascript or if you
want to like temporarily disable a
control so what I've got here is kind of
a list control and I have like a like a
hundred items in this list so i wouldn't
want all of those to be keyboard
focusable a users can hit tab over and
over and over and over and over again to
get through them I'd like the entire
list to be a single tab stop so user can
just like move into it and move out if
they need to you but when they're inside
of it maybe if they hit the up and down
arrow keys or something similar maybe
then I can change which item is
currently selected so to do this I'll
use a technique called roving tabindex
or roving focus and you can see here in
my markup my currently selected item has
a tab index of zero and so what I'm
going to do is listen for the user
hitting the up and down arrow key when
they hit down i'll just move the
tabindex0 to the next element I'll call
focus on it that directs all of our
attention to it but if the user once you
that can still tap out of this control
but when they tab back in right the last
thing they interacted with is focused
for them this is an extremely useful
technique if you're building sort of
complex controls and and other elements
it has obviously great browser support
so you had tabindex for quite a while so
definitely commits this one to memory if
you're building anything advanced or
super fun like that now you can also
have a tab index value of greater than
zero you can have a tab index of like
five which just means it's going to jump
that element ahead of everything else in
the tab order and this is basically
considered an anti-pattern but I wanted
to include it for completeness sake so
that you know that it is a thing that
you could do the reason why this is an
anti-pattern is you can end up creating
a super confusing tab order if you do
this and you're mixing matching
components may be lies and they're using
tab index greater than zero right things
could get wild pretty quickly so in
general you want to avoid tab index
greater than 0 if you can help it now I
want to revisit the the site name of
that Paul showed earlier because it
presents an interesting
of use cases for tabindex if we think
about a side nav when we open it right
we want the user to be over there right
in the drawer right either clicking a
menu item or just missing it we
definitely don't want them over there
behind the overlay may be interacting
with the page when they shouldn't be but
if someone is using a keyboard or a
mobile screen reader to open our drawer
there's really nothing that
automatically moves them into that side
nav drawer and I'll show you an example
of what I mean by this so this is a
mobile safari running voiceover this is
hands down the most popular mobile
screen reader set up out there about
seventy percent of the people surveyed
who use mobile screen readers use mobile
safari and voiceover and you can see
this little black rectangle up there on
the the reload button so that is where
my screen reader is currently like doing
its thing and I want you to watch what
happens here so I'm gonna start swiping
to move the screen reader I'll land on
the hamburger menu I'll double tap to
select it it looks like I'm inside the
hamburger menu but I'm actually or sorry
looks like I'm inside the drawer but I'm
actually still just in the header I'm I
was still sitting on the hamburger menu
now I'm just moving through the header
when I probably shouldn't be I might be
interacting with the page when the
author isn't expecting it so my users
context hasn't been updated they're not
even sure if the menu is open yet and if
you have a site that has one of these
kinds of menus and you have not done any
work to direct the users focus into the
to your drawer this is probably how a
blind user or a screen reader user is
going to interact with your app so how
do we fix this this is obviously not a
good situation to be in well one
approach is to find a suitable heading
inside of that drawer I've got this one
right here that says menu and that seems
like a good one and i'll give it a tab
index of negative one so remember when I
give something a tab index of negative
one it's not in the tab order the user
can't reach it hitting their keyboard
but I can programmatically focus it
using javascript so now when the drawer
opens I can call its focus method and
now the user is going to be directed
inside of here and they can start acting
on the drawer very easily so I'll show
you an example of that right so same
experience we double chap the drawer and
we just move
right to the menu and the user can keep
moving with their screen reader they
know exactly where there are and they
have that nice sort of continuity to
their experience so this is a technique
called managing focus and can be
extremely extremely valuable for your
user experience it's useful for
situations like this it's useful if
you're building a single page web app
and you're fading in a new page so super
good technique to have in your back
pocket now let me show you another issue
that I found specifically relating to
tabindex and this side nav so this is a
more of a kind of desktops a version of
the site and I want you to pay attention
to what happens to my keyboard focus as
I tab around the screen so I'm gonna
focus those two things and then it kind
of disappears and then it focuses that
anchor so so watch that again we're kind
of moving around in the header let me
just disappear for a little while and
then we focus that anchor in the page
now I'm actually hitting tab the whole
time we can't see our focus ring anymore
and what's happening is because we have
that drawer off-screen and because
inside with that drawer we have acres
and things like that focus is just
moving off-screen it seems like it
disappeared but it's actually just you
know over there somewhere where the user
can't see it now we probably don't want
someone to be able to interact with
off-screen content especially for kind
of trying to hide it on purpose again
this would cause sort of an error state
in our application possibly and it can
be very confusing for the user so how do
we fix this by the way I see this all
the time you should go to some big
websites and start tabbing around this
will totally happen to you ok so how do
we fix this because it's a super weird
situation to be in well the first idea
is like well the things off screen right
so let's let's set it to visibility
hidden you know off-screen that makes
sense it is hidden anyway and this would
totally work but if you recall in Paul's
talk he talked about primed elements and
he talked about flip and he talked about
this idea of having your elements
already kind of like in the Dom already
like ready to go and if we set them to
visibility hidden then we're going to
destroy the compositor layer right we're
gonna have to do all that work all over
again every time the user presses a
button so that seems like maybe that's
not the best solution and to me this is
really frustrating because I feel like
developers and users should not have to
choose between 60 frames per second
animation
and good accessibility so I I tried to
come up with two solutions to this
problem the first is to ignore Paul and
say I win and I get what I want and set
it to visibility hidden anyway and the
reason why this is potentially workable
is because as Paul mentioned in his talk
you do have about a hundred milliseconds
from the time a user clicks on something
until the time you know you need to
start animating so if our drawer is
simple enough then maybe we could get
away with actually setting it to
visibility hidden and recreating that
layers the way we do this is we listen
for the transition end event for when
that drawer is off-screen right I check
to see hey does it have the side nav
visible class which was you know how I
know that it was either on screen or
off-screen if it doesn't I'm just going
to set it to visibility hidden do you
sort of like vice versa for when we
animate it on screen so what does this
look like in the timeline here's Paul's
original version and the time that I am
interested in is this little block right
here so that's the time the yellow bit
there is the click the the end of that
blue rectangle is sort of when we
shipped the next frame so right now it's
about eight milliseconds in Paul's
current version well within that hundred
milliseconds range right and if you look
down here you can see the amount of
painting that we're doing so I've got
these two little chunks of painting that
are happening because this thing's
already in the Dom we don't have to
paint it much so here's the version
where I set visibility to hidden you can
see that there's definitely more paint
work going on but if we look at our our
time range here it's about ten point
four milliseconds so we added a little
bit of time but but not too much and a
lot of that time was actually idle time
so in terms of you know how this frame
stacks up with with Paul's version there
they're pretty similar and again it's
because we can get away with this
because the drawer is super simple right
it's a very simple element if you had a
bunch of images and much icons inside of
there and that may be more expensive so
this leads me to option to try i'm
calling the d tab inator unfortunately
there's really no easy way to remove all
focusable children of an element from
the tab order you have to go to every
single child and set it to tabindex
negative one you can't just set it at
the parent and have it cascade down
which is a bummer so that is
basically what this library does for me
I created d tab inator and I give it the
side nav element and when I set it to
inert I said all the children in
chamonix negative 1 i've set it to inert
false i restore all of their tab indexes
the way that I do this is really gross
but I wanted to show it so i have this
query selector all right and i had this
lovely query selector string inside of
there to select everything that could
possibly be focusable inside of an
element and this is you know this is not
entirely bulletproof there's weird
quirks here if you have like links
inside of SVG's or stuff of that like it
may not be bulletproof it may not be
perfect but it does probably for general
use cases do the right thing then for
each of those children I'm going to loop
through them if they already have an
explicit tabindex I'm going to save that
remember when we set that menu to tab
and ex- one because we wanted to manage
focus so I'm going to hold on to that so
I don't lose that information and then
I'll set everything to have an ex- one
regardless and when we're going to open
the drawer I just restore all those
values okay so here's the Detapa nato
version in the timeline you can see our
little block of time right here is back
to about eight milliseconds 8.4
milliseconds so we're pretty similar to
where we were with Paul's original
version and if we look at our paint time
we're back down to sort of like two
little blocks of painting so hopefully
we're in sort of the same ballpark now
again these there's there's sort of
trade-offs to each of these right the
visibility one you have to do a little
bit more more work there in terms of
painting but determinator you would also
have to add things like aria hidden
prevent a screen reader from going in
there so there's additional work that
would be required in that case but again
what I'd say is you know maybe if you if
you're if you're running into this
problem try one solution or the other
measure it see which one works better
for you and which one your team prefers
ok we talked a lot about focus I'm
switch gears now and talk about
semantics so this is the other half of
ensuring we have a good user experience
semantics is really crucial for making
sure that our screen reader users can
understand the content of our page and
the first question that comes to mind
when I think about semantics is like
well what does good semantics mean like
again let's get there first principles
what the heck does it mean if something
is semantically like rich or right or
whatever right and how
actually benefits someone and answer
this question it helps to think about
this idea of affordances so an
affordance offers or affords a person an
opportunity to perform an action and a
teapot is a really great example so a
teapot just based on its physical design
has affordances it has a handle and
because I've seen other things in the
world that have handles I know that I
can walk up to a teapot and pick it up
by that handle and interact with it no
one has to explain to me how a teapot
works now when it comes to graphical
user interfaces affordances still
represent the actions that we take but
now they're kind of more metaphorical
sew a button is a good example right
someone can't let go you know touch the
screen and feel the button so we try to
make it look like a three-dimensional
button that you might actually interact
with in the real world but the obvious
problem with this is that if someone
can't see the screen then they're going
to miss out on those visual affordances
so we need to make sure that the
information in our application is
expressed in a way which is flexible
enough to be accessed programmatically
by assistive technology which can then
create an alternative interface for
those users so I'll give you an example
of what I mean by that here I've got
some semantically rich markup so i'm
using a select element to create a list
and this is going to generate a visual
you i right but because I've used good
semantic elements it's also going to
produce this alternative you I it's
going to produce a spoken UI for a
screen reader user now roughly speaking
for for just about any element you can
expect some subset of the following
semantic information to be expressed for
it the element will probably have a role
so the select element in this case its
role as pop-up button it will have a
name and I don't mean like a name like
like the HTML name attribute when you
think of the name kind of like its label
or the so the computed text value of
that thing the element may also have a
state it's optional some elements have
states some don't and it may also have a
value again that's optional but in this
case we have a value of no preference
here so what's happening is when we
write HTML the browser does two things
it generates a graphical user interface
and it
it's a separate accessibility tree which
is just a collection of all that
semantic information that that I was
just going through this tree then gets
handed to assistive technology like a
screen reader and then that produces a
spoken UI for our user so this is
actually why semantics really matter
even though even though nav and div look
the same right because they don't look
like anything they just literally a
container semantically it produces
something very different in the
accessibility tree so as I mentioned
just like with focused native elements
many of them have implicit semantics so
for example voiceover on Mac when I
focus an input element with type equals
password it's going to announce secure
edit text to the user and just like we
saw a focus when we try to bolt
functionality on to non semantic
elements like a div then we end up
missing up on all missing out on all
these goodies the browser is trying to
give us for free so here's another div
button another very fancy button and
it's it's got tabindex0 so it's
focusable for sure but when a user lands
on it when the screen reader the screen
reader will say group because it did
it's just a grouping thing it's a
container right but that definitely does
not say to me that I should click on it
so again don't fight the platform here
whenever possible use native elements
because you're going to get good rich
semantics for free and just as an aside
like I hope at this point no one is
considering writing a div button ever
again if anyone leaves here and writes a
div button I have failed all of you but
there are times when you're going to
need to build something that just like
doesn't have a native element equivalent
you know or you need to just kind of go
off road and do your own thing and in
those situations you can use the web
accessibility initiatives accessible
rich Internet application spec or Aria
so Aria allows you to you specify
attributes on an element and then
basically modify that element semantics
you can think of it like doing surgery
on the accessibility tree however
semantics is the only thing that Aria
changes Aria does not change behavior so
I used to think if I put like a role
equals button on something that it
magically like became focusable and
worked awesome with a keyboard it's not
the case
all it does is change the semantics that
get expressed to assistive technology so
let me give you an example of using Aria
in practice so here I'm going to build a
custom control i'm going to build a
checkbox a custom element checkbox and
in this box down here on the bottom
right I'll show the output from my
screen reader just the textual output
right and the first question when I look
at those checkboxes okay i'm building a
checkbox I want it to be accessible what
do i need to add to this what sort of
aria do i need to add now there's two
approaches here the first you go look at
the Aria spec which comes with this very
helpful diagram or you could go check
out this document called the Aria
authoring practices guide and this
document is a bit of a hidden gem it is
pretty freaking cool so over on the left
hand side there you see all the UI
patterns that you could probably imagine
there's a ton of them in this document
right grid dialog tree like whatever
you're trying to build check box for
instance is included in there so you
click on the UI pattern and I'll take
you to a little section and it's just
going to walk you through all of the
support that you need to add to that
element in particular this is a whole
section down here dedicated to the aria
that I need to add to a custom check box
so it says it needs to have a role check
box I needs to have an accessible label
which we'll talk about it needs to have
a state of Aria checked if either true
or false okay cool so let's add this to
our check box I'm going to give it a
roll of check box and you can see now my
screen reader is announcing uncheck
check box nice now in the world of aria
role is the absolute most important
attribute everything falls out of the
roll okay there's a lot of re at roots
which don't even work if they are not
paired with the proper role so and you
can also see that now my state is just
defaulting to unchecked because the role
right so it's it's like trying to start
doing stuff for me it's like coming
alive which is cool when you see that
mitre box actually is checked so I need
to change that state so i can add aria
checked i can set it to true and aria is
sort of unique in that you always need
to pass it like a literal string value
of true or false most HTML attributes do
not work this way but this is the case
with Aria it's kind of a weird quirk now
the design pattern
to mention I need labels for this thing
and there are a couple options for how I
can label an element the first is are
you label which is really just a label
that you can apply directly to an
element a good use case for using Aria
label is something like a hamburger
button where I probably wouldn't have
any other text on screen to explain this
thing but I need to explain it for
assistive technology so what i can do is
take that button and add an aria-label
of main menu and now it will announce
main menu button nice ok that's good
that's one option the other option is
are you labeled by so are you label by
lets you specify another element to act
as your label it's sort of similar to
using the label element like it might be
with a native input but that that
element really only supports a few kinds
of children where's Arya labeled by can
be applied to just about anybody and the
cool thing about Aria label I is that it
can be composed so i can take other
elements and combine them together for a
bigger label in this case I got this
button that says shot now and feel like
I our text up there the screen reader is
just going to announce shop now button I
don't know what I'm shopping now for I'd
like to combine it with that header so
using are you labeled by I can take both
the header and the ID of the button
itself and compose them together to
create the label mins outerwear shop now
but nice so this is what I want to do in
my check box so I have this little span
here I'll give it an ID of sign drop it
into my labeled by and now the screen
reader is going to announce that I have
sign up checked checkbox there we go
nice now if you are building controls
and you want to verify your work is
correct I highly recommend you check out
the accessibility dev tools extension
created by my teammate Alice vauxhall
this thing is awesome it lets you
inspect your elements accessibility
properties the same way that you inspect
CSS and other things like that so here's
our sign up button and open it up go to
my elements panel find this element and
then I can go check out its
accessibility properties and see now its
role and its its values and its name and
all these other cool things so I don't
have to go around the screen reader and
manually test every single element so
this is super handy to have you can find
it at bit ly /a 11 y dash devtools
another cool example in the progressive
web apps space is this app created by
the polymer team called shop I really
love this app because I think it shows
off that you can build these bleeding
edge beautiful experiences using web
components using all the service are
sorry all the progressive web app tech
that we're talking about but still have
it be really accessible to so you can
see the text down here this is the
output from my screen reader and as I'm
navigating around it's giving me lots of
really useful actionable feedback rights
tell me that the proper thing that I'm
interacting with so definitely go check
out shop you can find this at a github
com / polymer shop if you find any
accessibility issues please file them we
want this to be like a like a showpiece
of web components and a good
accessibility all right we covered a lot
let's wrap it up really quick three big
things I want you to take away when
you're planning your applications make
sure that you're really nailing that
webbing checklist familiarize yourself
with what KAG and ensure that you know
you you can go through those user
journeys and for every major primary use
case you can check off the relevant
checklist items if you're building
controls you want to ensure that they
have good keyboard support and that
everything is focusable use native
elements whenever you can because it's
going to save you a bunch of work if you
need to create your own elements to do
something like tabindex to make sure
that the user can interact with them
also make sure that you're offering the
right affordances in your app so again
use native elements because they have
rich semantics for free but if you need
to go off-road can use something like
aria and that aria design pattern stock
seriously that thing's a lifesaver so
definitely check it out now if you're
interested in learning more about
accessibility myself and Alice vauxhall
we have put together this entire Udacity
course it's launching today I think
actually so if y'all go sign up you'll
be some of the first people so it's bit
ly / web a 11 why this is a multi-week
course it goes super in-depth on all of
these topics so definitely please go
check this out finally the main takeaway
that I'd like for you all to leave here
with is this idea that accessibility is
just fundamentally good UX ensuring as
many users as possible can access our
content should be our primary goal at
all times</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>