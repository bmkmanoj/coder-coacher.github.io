<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Do Less &amp; Be Lazy: Practical Performance Patterns for Polymer (Polymer Summit 2016) | Coder Coacher - Coaching Coders</title><meta content="Do Less &amp; Be Lazy: Practical Performance Patterns for Polymer (Polymer Summit 2016) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Do Less &amp; Be Lazy: Practical Performance Patterns for Polymer (Polymer Summit 2016)</b></h2><h5 class="post__date">2016-10-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/hHC9EOJzrQk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Steve arvo and I work on the
core polymer library as an engineer and
today we're going to talk about some
practical performance patterns that you
can use while making your polymer web
application and I need the clicker there
we go so performance is really a measure
of time the time it takes for us to load
and display content to the user the time
it takes from when our user clicks on a
button for some action to occur and we
know that if this takes too long your
user gets frustrated and they may bounce
in leave our site we don't want that but
exactly how much time is okay how much
time can we let these things take and
still delight our users with good
performance so Google has some
guidelines for this called rail and how
many of you have heard this term before
okay a fair number I encourage you to
check it out check out these tons of
information available online about rail
and today actually we're going to focus
on the ellen rail which stands for load
and the goal of the guidelines is to try
to load and display interactive content
to the user in just one second so we
know at least that gives us a goal to
shoot for but how will you measure this
how will you try to figure this out if
your if your app is hitting this goal
there's a lot of ways but one way that
we really like the polymer team is this
site called webpagetest org and it's
really easy to use you just input your
URL you can select a device in a browser
and connection profile like a mobile
profile it's really easy the the site
turns for a little bit doing some
testing and then you get a nice report
of how long it takes and it's going to
tell you if you're hitting that
guideline so if we do that for google
com then do we hit this guideline well
it turns out if you do this test on for
Google on like an average phone like a
nexus 5 and average you know mobile 3g
connection then typically when you test
this it actually does hit the rail
guideline but not really with any room
to spare
and as you may know from going to google
com it's not the most complicated
looking website so this pretty much
gives us an indication as you may
probably already know as web developers
that this goal is pretty darn tough to
hit and it turns out sometimes that if
the connection is flaky enough a flaky
3g connection sometimes for example then
you may not even get a response from the
server within that one second time frame
so you know we may not even be able to
do anything we're doing nothing and
we're still not hitting that goal so
this is tough this is a you know the
guidelines are basically telling us this
is what will please our users so it's
telling us that there's not a whole lot
of room for us to do work on our own and
so we should really take this sort of
seriously and pay attention to
performance and do whatever we can to
minimize the impact of the things that
we can control so going back to this
question of time and measuring
performance by by looking at time what
are those things that we can control so
first there's obviously the things that
we're downloading to the to the browser
this is the javascript HTML CSS that
we're all familiar with and the quantity
of that is going to be important
contributor to the overall time that
we're taking and second of course
there's rendering that content to the
screen and this is going to be basically
the other main contributing factor
that's going to lead to the overall time
that our sorry it's taking to load so
clearly if we can reduce either the
amount that we're downloading or the
amount of time we're seeing to render
then we're going to improve the
performance of our site that sounds good
i gives us some really concrete things
to look at and first what we'll go ahead
and do is dive into this idea of how
much we're downloading for the user and
see what we can do to control this so I
apologize because I realize you've heard
this term like in almost every talk it
honestly didn't realize this would be
the case but we are fans of this idea of
using the platform and specifically
let's just take a quick look at what
this does to the amount of content that
we're downloading if we do the best we
can to try to use the platform to help
us so first if we use web components
this is going to help us minimize the
amount of
framework code that we're downloading to
the user and in Taylors talk he
mentioned that polymer on Chrome for
example where all the native web
components features are implemented is
getting a lot smaller in version 2 point
0 where we don't have to let Polly pills
and if we use service worker which has
been mentioned also a lot today then we
know that this for downloading on the
second and subsequent loads we don't
really have to worry as much about this
question of downloading because we're
going to have this reliable cash that's
going to help us and and so it becomes
much of us less of an issue in that case
and finally you've also been hearing
about the purple pattern and again this
stands for push render use a surface or
sure to pre cash and then lazy load so
again it's push just the content that my
user needs for the initial route that
we're rendering use a service worker to
precash the remaining content and then
lazy lad that Lizzie load that on demand
as a users interacting with the with the
site there's a lot of content here and a
Google i/o this year there was a great
talk given that I highly recommend that
you check out we apparently like our
peas and polymer and there's a lot of
information there about what the pattern
means and sort of why we think it's good
and what you can do to implement it so
also at Google i/o we release the shop
app and just to be real clear this is a
demo app you cannot actually buy things
on this and this has actually come up
recently with users using it and trying
to say wondering where their shirts are
and this is really where we kind of the
crucible where we where we formed and
tested out the purple pattern and we
were really happy with the result you
know by using this pattern we were able
to improve the performance of the shop
app pretty dramatically using again web
page test to test this by you know
multiple seconds on each of the routes
for the site and at that point we were
pretty happy we thought we were onto
something we thought okay this is a good
pattern this is pretty straightforward
and useful for people and then a little
later this year the team that makes the
chrome UI which is actually just web
pages like you and I make they came to
us and they said
that what they needed to do was rebuild
this these pages they needed to use
Google's material design they were keen
to use polymer and we thought that was
great and then they said rail well the
users of Chrome demand that these pages
load in like just a couple undred
milliseconds almost instantly so they
laughed at that rail one second
guideline and they noted to us that the
resources that these pages need are
actually installed with chrome so they
don't have to worry about a network and
down legacy sources so you know they
didn't have to worry about a huge
component that was there we just talked
about so for them instead the issue of
performance was really the other
component that we mentioned this
rendering question so for the rest of
this talk we're going to really focus on
the idea of rendering the content for
our users on this to the screen and what
we can do to minimize the performance
impact of that so let's dive into that
now so again if we sort of look at this
concept of time and now we'll really
just focus on the time to render it's
really a function of two things first we
have the number of elements that we're
using to display our content and the
cost of those elements the average of
how much each of those is costing us and
going into that time and we can see
looking at this equation again if we
reduce the other those is going to have
a positive impact on decreasing the
amount of time we take so how are we
going to do that well it's not quite as
simple as this as going to the beach and
just relaxing but as the title of this
Hawk says we are going to try to sort of
use this mantra and do less and be lazy
this is really if you take one thing
away from this talk is it's this do less
means making less elements rendering
what we need and less work being lazy
means trying to do this efficiently and
doing just the work we need to
accomplish the task at hand the
rendering and then with the way the user
is interacting with the app so with that
in mind let's try to dive into some
specific techniques that we can use to
in this case we're going to first focus
on reducing the number of elements that
we're using to render that
critical content for the user so we'll
look at a few techniques that we can use
and the first one of these is called
incremental rendering and the idea here
is again just do absolutely what's
necessary and then sort of in seamlessly
in the background will let the rest of
the rendering occur and I'll explain
this with an example so you're probably
familiar with polymers Dom repeat
element renders a version of this
template for each in this case element
in the items array and if that array has
say a thousand items in it then we're
going to get thousands stampings of in
this case this my item element before
anything is running to the screen so I
mean if there's any if the my item
element has any complexity at all this
is very likely just going to take too
long so you know what do we do well we
actually recently added a feature to
down repeat called initial count which
is going to do this incremental
rendering for us by rendering this set
amount in this case ten items and then
letting the user see what's on the
screen and then seamlessly in the
background doing the rest frame by frame
usually very quickly and just filling in
the rest and this is pretty good
trade-off in terms of getting a good
first experience and having the rest
just kind of happened behind the scenes
and I'd like to mention also that in
polymer 2 point 0 version of this
feature this incremental count is
implemented by default so you'll get
this behavior without having to do
anything so another way that you can
accomplish something similar is to use
iron list which eric mentioned and this
is even better performance than Don
repeat because iron list only ever
renders just a bit more elements than
will fit on the screen and then lazily
as a user interacts with the iron list
and scrolls through it those elements
are reused and the model items that are
appropriate to be shown at given time
are displayed I would suggest using iron
list when you have a fixed view viewport
height and the content of the list is
mostly homogeneous then it's going to be
your best bet ok let's go ahead and look
at the next feature that you can use to
try to reduce the number of elements
that you need to render and that's
conditional rendering and will again
explain that
with an example so you're probably also
familiar with polymers Dom if element
which is again a basic tool that you can
use to accomplish conditional rendering
so let's look at how I've used it here
specifically because this is actually a
time when it's a good time to use Dom if
in this case it's going to render if a
property called usually false is set to
true I specifically named it usually
false because it means that in the
common case it's not going to be true
and we're not going to render this
content so again in that common case
we're going to render less elements and
the element inside here big view is very
likely to be kind of a bit of an
expensive element so it's a reasonable
thing to to hide behind this this use of
conditional rendering and it's not
always a good idea to use this kind of
conditional rendering sometimes it can
be a negative and let's look at that so
here we've used on if and the property
that we're conditionally rendering this
this content on is called usually true
which again means that in that common
case we're probably going to render this
content so it's actually not helping us
and the content that we're rendering is
just a div and it's really cheap so in
this case the conditional rendering
logic is that we're using here is
probably not even worth it not paying
for itself and if the content is this
simple then I would recommend just
showing and hiding it using CSS so don't
use Dom if here but use Dom if when the
condition is usually false and it's
going to help us in the common case okay
so one more feature that will look into
for reducing the number of elements that
we need to render is custom element
upgrade so there's a lot of potential
content here and I'm just going to focus
on the essential bits again with an
example so here we have an element view
template where we're showing this
bigfooter element and it's a footer it's
at the bottom it maybe it's big so you
know we've chosen in this case to not
let it render its full content when
we're displaying this initial view here
it's not essential and it's convenient
for us to put it in the Dom like this
because it lets us put some fallback
content in this case we chose to say
loading and we can use CSS to style the
element it's just a regular element like
anything else gives us a good way to
style it
and then based on some condition being
met we're going to call this load footer
method in this case and it's going to
use polymers import href which is a
imperative way to create an HTML import
and load it to load the definition for
the bigfooter element and that will
seamlessly go ahead and upgrade it when
that import loads and this is again a
good way to be lazy and do this work
sort of a little bit it's a little bit
less important than for that initial
render and therefore we can avoid all
the you know in this case loading the
content that we need you to load for the
big footer which will help reduce
download but also importantly not
rendering the shadow Dom with a
bigfooter element that's less important
for our initial render okay so to recap
to reduce the number of elements we've
used these techniques and that should be
pretty beneficial so again to review
word you know all of these techniques
are follow this duel SB lays the idea
okay so now let's go back to our
equation here we have time to render
number of elements we've talked about
techniques to reduce that now let's look
at this cost the cost of these elements
so we'll look at some techniques to help
us there so before we do that though
let's pause for a second because it's
really important to realize that it's
not practical or smart to try to reduce
the cost of every single element that
you make it's okay if some of the big
view elements that we make just want of
or a couple of take a little bit of time
to create the elements that we really
want to focus on the elements that
really we don't expect to be taking this
much time and especially the elements
that we are using a lot on the page and
we said that's all these high frequency
elements so high frequency elements
expensive elements are really the ones
to focus on so also important how are we
going to figure out which of the
elements you know meet these
requirements we need to use tools and in
addition to the chrome devtools timeline
and the profiler which I hope you're all
using we can use another tool that the
Palmer team is created called poly dev
and this is another way to help dive
into specific part you know specific
element types in your app that are
that are costly and help you determine
how many of them you're making and how
much they cost so that will help us
determine which type of element to focus
on so another tool that we've created
called poly perf is another example of
the thing that Eric talked about which
is a sort of metrics thing there's
actually almost everyone in our team has
a different tool for doing this and if
you want to make your own that's fine
too this is just one that we've found
useful and this is a tool that will help
us benchmark individual elements and
compare sort of different changes that
we can make and you know it's doing some
work here to try to to render the
elements a bunch of them and report
times back to us okay so as a final
thing that will do in this talk let's go
ahead and sort of do a case study of
trying to reduce the cost of an element
and here we've taken a ratings element
which is just something I sort of made
up for this and it's an element that you
can use to like maybe it's show a movie
rating on your site and you've decided
to implement you know you can click down
on it and select the rating and you know
it's a good candidate to try to reduce
the cost for because it's very likely to
be a high frequency element used in a
bunch places we might use it in a list
for example so let's kind of dive in and
see if we can find some ways to reduce
the cost of this element so let's look
at how it's made so first we have its
template and it's actually pretty simple
we actually made some good decisions to
start we realized that we could use a
little star emoji rather than having to
download an SPG your image for the star
we also used polymers strip whitespace
feature which is a convenient way to
knock out the text nodes in the template
they're really convenient for
readability but they do have a slight
performance impact and in most cases you
don't need them so in an element like
this but we're really trying to squeeze
all the fat of it's pretty reasonable to
do that so the next slide is going to be
most of the code for the element and I'm
pausing now because don't freak out it
looks like a lot here but the
actually almost all of this code and
we're going to go through it like
step-by-step to just look at what's
happening so first we have some
attributes and again I'm you showing
sort of a polymer 1 point 0 syntax here
that's hopefully a little more familiar
to people so we want to make the element
focusable and give it a role in aria
role so that it's accessible which seems
straightforward I do want to have a
little Mayo coppa here this is not
everything we need to do to make the
element accessible the other bits
actually don't have a significant
performance impact so I admitted them
but it's not complete we have some event
listeners in this case we have a key
down listener which is going to help us
with the arrow keys the left and right
arrow keys are going to advance and
reduce the rating and the down handler
here is is saying that you know we're
going to have some code here that will
set the rating based on the star that
the user clicked on we decide to expose
a public property called rating it's
pretty straightforward and we decided
that it should reflect to an attribute
and it's just an event when the rating
is set and we have an observer here and
the observer here is accomplishing the
rendering of the rating in this case
don't worry about the code but it's you
know it's basically looping over those
star elements and setting a CSS class on
them seems to a little seem
straightforward and we have a value
property which is our sorry the value
here which is setting the default for
the rating 20 so finally we have a paper
ripple you saw in the little video we
had a little ripple effect I didn't do
the work to make it circular it's a
little bit more work but it'd probably
look better and we're creating this
paper ripple and then in the down
handler we're moving it to the right
spot so it will ripple on the right star
and that's great we get a little
material design of fact we can use you
know we don't have to implement our self
or you can use that paper ripple paper
ripple element to help us so
straightforward pretty simple element
what is it how does it perform so we can
use poly perf and we can see that when
we do that I've compared adhere to the
native input element and I'm using the
tool polypro pair too it's actually
rendering 250 of these each in each test
so
in absolute terms the cost of the
ratings element is pre sheep it's like a
fraction of a millisecond about half a
millisecond which is not bad but I chose
to compare it to the native input
because it seems like it shouldn't be
that much more expensive than that I
mean it's a straightforward element we
want to make it as fast as we can so you
know it's and you know it's it's
actually a bit slower let me have six
and a half times slower than then input
so there's you know it's not quite where
we want it to be maybe so again now
we're going to dive in and take a look
at and try to go sort of step by step to
try to see ways that we can reduce the
cost of this element so we'll use this
technique the first thing that we're
going to try to do is look at our use of
composition and in this high frequency
element we're going to be a little bit
careful about it in general composition
is great but when you're really trying
to squeeze the fat out of an element
then we want to scrutinize it carefully
and you may have noticed on the previous
slide I use this element called shadow
card which is really just there to give
the the outline border of the element a
drop shadow and in this case it's
probably a little bit heavy weight to
accomplish that end probably not worth
it so let's try to avoid that and in
this case to do this in CSS is actually
pretty straightforward so let's just use
the platform or directly and use that
CSS and then we'll look at what impact
this has on the overall rendering
performance so we can see we got a nice
little improvement and you know again we
kind of overused an element there where
we really didn't need to letting the
platform just directly be a CSS do that
heavy lifting was a nice little
improvement okay so the next technique
we can look at is reducing the work that
we're doing in ready and attached and
specifically this is important because
these lifecycle methods are called
before our initial render of the element
so remember this paper ripple that we
created we made it in ready but you
remember that I said it's actually only
used in the down handler so it kind of
makes sense for us to do this work
lazily and
move the creation of the ripple element
to the down handler like this the first
time that the user presses down on the
ripple or sorry on the rating star will
make the ripple element and then use it
and then therefore we're doing the work
lazily so let's look at what impact that
has that's pretty significant we got a
nice bump here this is not totally
surprising given that paper ripple is
doing a pretty fancy thing it's doing
some complex work and by creating that
element lazily we save ourselves a good
chunk of work for that initial render so
we're getting there and not quite there
yet but we're getting there and the next
technique will look at is using CSS more
for dynamism we already did for the box
shadow now let's look at it for other
things so if you recall we had this
observer when the rating property
changed and we are using CSS but
indirectly we're using javascript to
imperative Lee set some classes on the
element and as it turns out we actually
don't need to do this at all and we can
use this fancy CSS instead in this case
we're choosing to use the fact that we
reflected the rating attribute to the
host and and tell CSS or use a selector
that knows about that and then use this
you know emptive type selector to say
okay well we're going to conditionally
style the star the appropriate star
according to that rating and this was
just enough to get rid of that observer
completely letting the platform do the
heavy lifting so let's see what impact
that has so that's a nice improvement to
using CSS for dynamism as much as we can
writing less code seems good let's keep
going ok so you recall I said that we
gave the rating property a default value
of 0 and as it turns out to accomplish
this render we don't need that
especially since we did it for use CSS
based on there being no attribute set
all the stars will just be black which
is good for our initial render so we
don't need this this can avoid
reflecting that initial property to an
attribute and avoid sending the event
and this is really good for our initial
render
let's see what impact that has so not
huge but we're getting there step by
step so one last change that will look
at is looking if there's any other work
that we can defer until after the
initial render and in this case there's
these attributes and these event
listeners and again those are not
critical to our initial render of this
element and again in this case where
we're really trying to squeeze all the
fat out we can avoid using this and
instead use a little helper that polymer
has called after next render which is
going to do the work after the render
and set these tabindex and the role and
add the event listeners imperative Lee
then which is going to again defer this
work until after render and get us our
initial render as fast as we can let's
see what that does okay so that was
pretty significant and got us pretty
much almost all the way to our goal of
trying to serve at least benchmark
ourselves against the native input so we
got a number of big improvements there
and again here's all the techniques that
we used and you don't have to remember
each one because really sorry taken
together of course we we looked at this
and we looked at some ways to reduce the
number of elements and their ways to
reduce the cost of the elements and
here's what I'm getting it that you
don't have to remember any of these
specific things you can of course review
for that but to keep in mind if you
remember one thing it's just that steel
listen be lazy because all of these
things that we just talked about really
express this main idea so here are the
things that I talked about in the talk
there's a link for rail the link to that
video for purple the download / poly dev
and that's available on the Chrome Web
Store this is the branch of the poly
perf repo on github which has that
ratings element built in you can
actually run those tests yourself and
check out modify whatever you want and
look into it and that's it for me my
poly Mon is awk doorbell and apparently
it likes to spout wisdom for long
periods of time so I want to warn you
about that but that's everything so
thanks and have good rest of the day</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>