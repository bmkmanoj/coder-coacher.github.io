<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>RAIL in the real world (Chrome Dev Summit 2015) | Coder Coacher - Coaching Coders</title><meta content="RAIL in the real world (Chrome Dev Summit 2015) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>RAIL in the real world (Chrome Dev Summit 2015)</b></h2><h5 class="post__date">2015-11-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/iIV1xPFXmBs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so obliging clapping a second time but I
guess if you're watching this on youtube
you don't know that I just did a talk
and speaking of which I should do this
bit where I explain rail just very
quickly these are the goals of rail
responding in a tenth of a second
animating at 60 frames a second being
idle at 50 millisecond chunks and
loading in under a second
so my job is to talk about rail in the
real world to apply rail and I guess you
know are any tips and tricks and to know
about that or to answer that you have to
kind of start with life in dev rel
because the thing about being in dev rel
is that we do get to test technologies
just as API is a landing we're working
very hard with the engineers who are
working on those and that's a part and
parcel of what we do is have like the
the crash test dummies are the web which
explains my gorgeous good looks and we
also get to test ideas some ideas are
good some ideas are not so good but all
the same we try and test them out anyway
in the last year I have been testing
rail amongst the other things I've been
trying out and I've been building web
apps to do just that progressive ones no
less this is the first one I've seen a
couple of times over the last couple
days it's called voice memos the idea is
it lets you record voice memos and you
can save them to the device and it works
offline and it uses indexeddb and es2015
stuff but you see there's all these
transitions and it's got a load quickly
and so on then there's this one which is
a guitar tuner which actually will tune
your guitar and this was a slightly
different bet I was trying to get
polymer to load under a second and get
itself bootstrap to meet the dials going
around and that's 60 frames a second as
well as processing the audio so that was
a different challenge altogether and
then the last one which I'm still
working on is a podcast player what a
handsome pair of gentlemen there with a
podcast you subscribe to again these big
hero transitions scrolling and all that
sort of stuff so the question then
becomes does rail work and the immediate
answer I can give you is yes it does
that's the good news
but like anything of this nature I think
it needs a couple of tweaks and the
reason I think it needs tweaks is just
because it's it's a model it's a way of
thinking but reality often just sort of
diverges a little bit we give you the
first example when you hear about rail
the first thing you might think is that
you know everything is equally important
like everything I've got these four
numbers that I have to meet and it's not
necessarily like that in my experience
so we can give you an example if you're
building a Content site your profile
your rail profile I guess might look
more like this it's more like the
classic performance profile where load
is super important getting that first
content on screen we don't necessarily
think it somebody's gonna add it to the
home screen or anything we just want to
get something up on screen animations
are important here because these are
going to scroll almost certainly and we
don't want janky scroll idle yeah you
could use a bit of that if you're gonna
beacon analytics type stuff back
but responses doesn't really rank that
high because probably it's linked to
linked sort of page refresh bounce
around from different URLs you know it's
not so not so heavy-duty there however
an app will have a different profile
altogether in my view an app is more
like this because you've got these
gestures you probably got big
transitions hero transitions that kind
of thing going on idle ism is quite
important here because you're probably
going to pull data from something like
indexeddb
and you're going to want to sort it
search it do that kind of stuff and you
don't really want to do that in a way
that gets in the users or bothers the
user sorry and then load yeah it's it's
there but hopefully you're using things
like a serviceworker
to really make these things fast and
snappy now you could argue that you know
it should be this way or the chart
should look that way and if you're up it
might look different I think the only
thing I'm saying is for me they're not
always just sort of four equal players
the other thing that I think it's that
kind of caught me out actually as I was
trying out rails I thought goodness you
know there's these four independent
things you know response is not gonna
play with the animations whatever the
reality is sometimes they group together
let me show you what I mean let's say
we're going from a list view to a
details view so I
tap on my item in the list that's a
response I need followed by a load and
then we do the animation to the final
state to actually have three free rail
actions going on here and that forces
into asking a question what is the
primary action in that situation we
throw it to you what would you say is
the primary action hands up for response
hands up for load hands up for the
animation okay it's an interesting one I
think I think the response is the most
important one the reason I think the
response is the most important one is
because it's the user driven one it's
the way the thing where they tapped on
something and they expect an answer back
so that I had for me that hundred
milliseconds becomes the the upper limit
interestingly enough in that case the
animation was the implicit response then
I always go in sort of you know this
sometimes grouped together in a funny
way I suppose that's what happens rail
headlines then don't assume the four
will be equally important figure out the
rail actions for your app but you know
it's actually really good to kind of sit
down and go and go yeah that looks like
the response that looks like they're
gonna group together when they do group
together figure out which one is your
primary and go from there
so with that what I want to do is I want
to step into each of these four areas
and show you how I try and get within
those thresholds responses is up first
target is 100 milliseconds and for me I
tend try and sort of break them out into
two categories the first is what I like
to call simple responses which is sort
of like a state change I suppose like
okay most of the time these ones are
very straightforward to kind of get
inside that 100 millisecond boundary
like tapping on a button or something
like that the more complex ones and you
can see another example here the
response load when animation ones which
really is a response I think those
become more difficult those complex ones
those combination ones what I do in
those situations is I take this approach
first of all I will set up
I'm out the idea being one or two things
is gonna happen I'm either gonna get
inside that hundred milliseconds or I'm
not now if I if I in this case fail to
meet the hundred millisecond window I'm
gonna show a spinner like for whatever
reason this is taking a long time I'm
sorry maybe the disk is slow have you
ever once in the network something like
that at the same time I'm going to
request the data then when the data
comes back in I'm gonna clear the time
out so if it's fired in under 100
milliseconds what we just clear it don't
worry about it it's it was a sort of
easy thing to do and I'll hide this
minute so if it has shown its you know
goes away one of those two is kind of
unnecessary but they're both needed in
this situation and then I can do my
transition to the details view when it
comes to like measuring the responses
say for example we're going to tap on
the hamburger button here to bring out
the side now the way I tend to approach
measuring this is with dev tools and
console time so for example in the the
button listener I start here with the
console that time which is me saying
right start tracking this one thing
please and then I'll do my side nav and
then I'll wait for the next frame so
when my JavaScript is finished they'll
still be Styles layout pane composite
and all that kind of work that needs to
happen and then the start of the next
frame it's a pretty it's a pretty decent
marker that says okay the previous frame
is shipped we've responded to the user
and so I'll just do time end if you do
take that approach and you've got say
you knowing this on desktop but you can
also do it on a mobile device and here I
have my my Android plugged in and I go
to Chrome inspect and I can click on the
inspect button and you see I get my
little device for you there she's great
go to timeline and I take a recording
bring out that side nav and I get my get
my details now two things here firstly
in my console I see this which tells me
how long it took for that to finish
which was 13 milliseconds but I also get
this extra row in the time line and now
I can start correlating that piece of
work with what was going on on the main
thread and what was going on the
compositor
all of a sudden becomes very easy to
kind of see when things are overlapping
you know oh goodness I didn't mean that
marker and that's because there's loads
of layout okay I need to figure
something out so it's a very quick and
easy way to start getting this data so
responses differentiate between the
simple and the complex ones and the
complex ones should normally be raced
with that sort of timeout and then you
can just go crazy with time and time and
to track your response times then you
can do what you you need to do with
those you can also use the window dot
performance the user timing API as well
here if you want to kind of beacon some
of that back I think like some
animations now I'm gonna go straight to
the how-to winner animations but because
the reality is we have eight
milliseconds here most people go I
thought you said sixteen and I did but
that's what everybody's got I'm gonna
say everybody I mean us and the browser
but the browser has overhead and it has
housekeeping to do and so we get left
with a window of about eight
milliseconds in which to do our work and
that's not a lot of time and so the way
to win is to work with the compositor
and the way to win and to work with the
compositor is to limit yourselves to
things that can be done just with the
compositor for example you can use
transforms or opacity here so I built
this site CSS triggers calm a while ago
and it'll tell you for every CSS
property what it's going to trigger in
the rendering pipeline give you their
their heads up there's only two that
don't trigger paint or layout and paint
and those are transform and opacity for
elements that have their own layer now
yeah there's the transform on the way I
do my animations particularly big hero
ones is I use a process I call flip
which I mentioned last year when I was
talking about building the chrome dev
summit site for the 2014 yes that one
and I've since given it your name first
last invert and play it helps you remap
your expensive animations to cheaper
ones like this let's say I want to get
this purple box from the top left to the
bottom right most of us I think would
probably go well transition on width
height left and top
the downside of those is that they
trigger layout and paint and they're not
something you're gonna be able to do at
60 frames a second typically typically
you might get away with it but probably
not it's definitely more challenging to
build but what you do is we start by
calling something like get bounding
client wrecked on the start position
this is the F of flip so we say where
are you on screen and what are your
dimensions next and this is where any
animations on whatsoever we add a class
that puts it in the final position the L
of flip like so we call get bounding
click get bounding client wrecked
because nice roll off the tongue kind of
API we call that again to find out where
it's moved to on-screen now what we can
do is we can apply a transform and we'll
just move it back to the starting
position as far as the user is concerned
nothing changed but we know we just did
it with cheap to animate properties like
a transform and the same is true for
opacity now what we can do soon and
switch on our animations and just let it
play forward which remove that transform
and it goes what we're doing here is
we're most likely taking advantage of
this setup where the user tapped and
then we do some kind of animation and
what we can do is we can take that
window of opportunity because like you
saw before it was like 13 milliseconds
to do my my response work well that left
me about 90 to do other things so what
I'm going to do is we do the first last
and invert part of flip there and then
we can play out nice and cheaply it
works we've used it on the Google i/o
website used it last year on the chrome
dev summit site it's used on all three
of my apps that build this year it's
great it works there are caveats and so
if you are interested in reading more
about it I do have a blog post that you
can grab there bitly slash flip -
cannons so genuinely applied to the
podcast one let's say you're tapping on
on the podcast it goes like that just
backwards it goes to the final bit and
squish it back in and then you play it
forward and you get close to 60 frames a
second by yes you get 60 frames a second
if it goes well
similarly to the response is when you
want to measure things like this you can
call consult on time do all the flip
stuff in this case I'm using transitions
so I can wait for a transition end and
then on the end of the transition I'm
just gonna call consult uptime end and
in dev tools I'm gonna see this kind of
thing and again I can see a couple of
red triangles just above the main thread
activity which tells me that my
framerate did drop a little bit but I
don't think there was anything I was
doing I think that was just one of those
things if you don't do with a flip like
animation it will probably be very
difficult to get 60 frames a second but
it's a big cheat and I love it so
animate with transforms and opacity
where you can flip your expensive
properties over to cheap ones and be
super cautious and avoid work during
Scrolls in particular if you can big
shout out to the parallax massive yeah
my favorite crew
next up idle now our target here as we
discussed before is 50 milliseconds and
the reason being that we want to be able
to respond to the user quickly so if
they're in the middle of something and
we're doing some you know idle time they
tap we want to respond so we can fish
our idle time of you know up to 50
milliseconds and we can still probably
get something to screen quickly enough
that the user feels ok about it now up
into
not so very long ago there wasn't a
great answer here as to like how do I
actually do this because you'd be in a
situation where you would have to kind
of event listeners to everything on your
page and be like well the user doesn't
seem to be doing anything because
there's not no events firing and I don't
know how long I've got but I'm gonna
guess so I'm gonna maybe try doing it
wasn't something that we could
realistically do Chrome currently as of
chrome 47 has requests idle callback
which is an extremely useful API when
you want to do idle work here's how it
works let's say I've got some tasks at
the top there and it's an empty array
and let's say gets populated and I know
how long my tasks should take maybe I've
got 100 of them and then I'm saying that
each one's going to take maybe one
millisecond what I do is I call request
idle callback
with my callback and when my callback
fires it gets this deadline object and
the deadline object has stuff in it one
of which is that time remaining function
and I can basically say there's like
while I have time remaining and as in
enough time to do a task and I have
tasks to do do the tasks if I run out of
time and I still have tasks to go I can
request another idle callback the
browser's in the unique position of
knowing what the user is doing what's
going on in the system whether the main
thread is free and how much time it
thinks you've got the schedulers inside
of chrome and blink are very good at
this so it can tell you like you've got
this amount of time this would be good I
wrote a post on Google web developers
about using requests I'll call back so
if you want to read more about it head
over there
the thing about idle time though is it
is a bit different because most of the
time we used to be like well I got an
event I'm just gonna do my stuff off we
go but you have to think differently
when it's idle time you have to think
defensively because you're kind of
running against the clock it goes you've
got six milliseconds go okay great and
it's a different way of working it spins
it on its head but it's fine
you won't get preempted by the way if
you go over that time it's just that the
reason the browser gave you that time is
because it knows what's going on if
you're looking for things that you could
do with idle time the basic answer is
non-essential work like beaconing your
analytics that's a good time to just
kind of say like I'm not you tapped on
that button to bring out a side nav I'm
not gonna send the analytics right now
I'll just request an idle call back and
you know maybe when the animations
finished or something like that or the
user is just like looking at the menu
that's a good time to kind of process
that work you have to think in small
deterministic operations rather than
right I'm gonna make all my Dom changes
now great now what you need to do say
for example if you were trying to do dom
work i'd suggest you either use
something like a V Dom or you do
something on a document fragment so
you're working kind of off Dom and then
in some future
requestanimationframe or something then
drop it onto the page and as I said
before you want to think a bit more
defensively you're kind of running
against the clock a little bit
load is the last of the rail and our
target here is one second or a thousand
milliseconds and I've added my own
little caveat there for the 75th
percentile which is to say most people
because most of the time on 3G or 2g
you're not going to achieve it straight
up because the radio might be off or the
user device is just busy doing other
things makes it very very difficult but
if you say something like for the 75th
percentile it becomes a lot more
achievable however it doesn't absent us
from making good decisions in the
architecture of our apps this is how I
try and approach it for something that's
built with vanilla so in the case of
voice memos inlining that initial view
is is super critical Rob Bob Dodd I
really messed up there Bob Dodd show
this yesterday where you have a skeleton
and you said this is the initial view
that you need and I'm gonna inline my
styles for that I'm gonna in this case a
inline an SVG and you know so the user
gets something pretty quickly on-screen
then we do like an async the first I'll
load on some JavaScript so it's not
blocking and that's going to start the
request for the views that we're going
to need in hopefully in the order that
we're going to need them then the case
of the app is actually quite
straightforward for me because I know
the user flow you're gonna record
something you're gonna see it's details
you're probably going to go back to the
list like that and I do the list you
know later because I don't need it up
front and then I can go back into the
details and play and so on if anything
there's a variant on this which is how I
work with polymer and the way I do say
so the guitar tuner uses polymer but
it's all custom elements and that I did
and the way I do it again is very
similar in line this Styles even for the
custom elements that I've got on the
page I basically make it look like that
so it's like everything's roughly in the
right place
and in fact it's very much in the right
place then with my JavaScript in place
I'm gonna lazy load on my various inputs
like that and they are all going to
request a polymer independently but the
way the HTML imports works is that you
can request the same URL 30 times and
it'll actually only get loaded once and
then all 30 would be satisfied so it's
kind of like they're all having a race
to get polymer and when polymer comes
back in they can all bootstrap and the
app is complete it works really well
when you're doing your testing for load
I cannot recommend webpagetest highly
enough it's where I always go what I
tend to do is I tend to switch on for
mobile 3G so I'd feel it's quite tough
I'll do something like first to repeat
view and the checkbox there at the
bottom is for capturing a video which is
really really useful when you just want
to kind of feel what it actually you
know what it's like to use to kind of
make the point though about the 3G and
even trying to make the right calls on
the architecture I get a speed index
here of 3403 ideally speaking I would
like to see something lower than that
maybe maybe 3000 maybe a little bit less
but the reason I'm not going to get much
better than that is because when I look
at the request for just the index.html
which had everything in to get that
initial view up you see numbers that
look like this the DNS over half a
second the connection Dan SSL
negotiation time to first byte but the
the content download the bit I'm
actually feel like I'm in control of is
very very tiny in other words there's
the flame transition don't mind if I do
99% connection it's like that it's like
all that other stuff I don't feel like
is really something I can affect and
this is what it's like on first few on
the left is desktop on cable right
mobile 3G off it goes it's pretty fast
but this is the bit where we go now I'm
going to bring it back to the 75th
percentile this is how I'm going to try
and win by using I did say it's a
spoiler serviceworkers yeah I'm nicely
gonna explain the code and so as workers
Jeffrey did a great job with that and
we've got plenty of stuff for you but
the important thing is by having a
service work on my numbers for repeat
views are really very very good and the
reason I'm visually complete slightly
after a second's because I do a nice
fade in so it doesn't think I visually
complete I could not do that I can just
snap it on I don't think that's quite as
nice so I take the hit on the numbers I
know I know what I'm happy with and this
is what it looks like in video Ready
Steady Go you can't say fairer than that
if a user has an app that does that they
are going to be so happy
Jake built an app called SVG oMG for SVG
editing and somebody remarked on Twitter
they said I just I didn't realize that
web could be this fast it's like yes it
really really can't and it's really nice
when it is and it's perfectly possible
as well so then load stuff I would say
inline your app shell CSS lazy load
absolutely everything else Bob did a
great job explaining that yesterday I'm
saying the same thing today far future
cache your JavaScript to your CSS your
images this is classic page load stuff
and use a serviceworker one other thing
that i've been working on which has been
a sort of like I suppose a 20% project
ish thing for me is something called big
rig and dev tools is absolutely amazing
and what I use on a day to day basis but
sometimes I just want a bit of a smoke
test for like rail measurements and be
like is that roughly doing the right
thing or maybe I'm looking at somebody
else's stuff and I'm just like how much
time is going in to JavaScript or not
and where's that
which JavaScript from which domain and
that's why I built big rig this is this
is big rig you can have a play with it
yourselves the idea of big rig is that
you make a project so let's say I make
one for the chrome dev summit website
that I'm you know we want to track and
inside the project you have actions and
actions or things you're interested in
they're rail actions essentially like in
this case I do load response and
animation so let's say I want to do the
the initial homepage load or something
like that it crazy for me and then you
go in it says upload a trace for this
action
what traces are Chrome's internal way of
measuring performance timelines are
traces effectively and you can get a
timeline file from webpagetest
so here i've got a chrome dev on a nexus
5 select that and it gets mobile 3G why
not and under the chrome settings you
can check the box that says capture a
dev tools timeline turns out really
quite useful that now if we go we start
the test and it takes a while when it
comes back in you see there's this link
here in the corner that says time line
so you click it and then you go back
it's a big rig and eventually it will
say this is what you spent your time
doing this is the parse HTML this is the
JavaScript it's with the styles that
layout the paint the composite and you
get that number those numbers
immediately and you can also go into the
extended information where it'll tell
you by domain where the JavaScript was
coming from so four thousand nine
milliseconds on the site itself and you
start to get this over time you can
actually build up a picture of you know
how am I
submitting my time across all these rail
actions so it's good for responses you
know like I'm gonna tap on a thing what
it does is if you give it a time line
foul with console time and console dot
time and it will use those as the labels
and it'll go now you've got one there
okay that looks like a response that one
looks like an animation and so on say
it's good for animations you know you
can give you those in frames per second
and again you can start to see how
you're doing there
this one's an actual real one Paul
Kinlan uses big rig to monitor his site
and you can see it there on the far left
hand side there's a big block of green
and big block of yellow and big block of
green he was like why have I got a big
block of green and we went to look at
this site and it happened
forgotten to resize down an image and it
caught it for him and he fixed it you
can see it's sort of settled down a lot
for him if you can post that the
timeline file the trace file to an end
point and it will process it and if you
do that with the hook you can see which
webpagetest
result it was and you can also say they
get commit as well so you can be like I
had a regression why can useful and in
his case in case you're curious that's
what the blame game looks like for him
I've suggested that he moment and lazy
load his comments
makes it quite easy to do that kind of
stuff so if you're interested big rig is
on the Google Chrome github org some
people don't want a UI though and that's
cool so there's an alternative which is
the globally installable big rig similar
kind of deal actually just on your
command line where you can go big rig
the file and it's the same timeline file
from before and I'm just going to ask it
to pretty print the results because
otherwise it'll return just adjacent to
you and you see here again it's the same
kind of details but if you want to you
know integrate into an existing flow you
can do that as well and that is under
node big rig what you do npm install'
and then there's this one as well which
is another tool that i've been working
on and these are all these kind of try
and make rail measurement just a bit
easier if you want to do it outside of
dev tools and there's loads to do and
there's loads i want to do one of the
things is like it's hard to do a scroll
test so i've got the big rig runner and
you can give it the site that you're
interested in tracking or just getting a
scroll test romp telling it to look for
the body element and i'm gonna pipe it
through to big rig see Chrome's open in
the background it just does an automatic
scroll test without me doing anything
and the end of the scroll test it spits
out the results which big regular and
pauses and says well that was a smooth
scroll and in animation and it was 54
frames a second and it tells me what I
was doing per frame kind of useful if
you just want to as I say there's smoke
testing how am I actually doing ok I
have not so much time so we'll come back
into the final thoughts on rail in the
real world rail
and those thresholds they genuinely work
if you build a site or an app against
those rail thresholds you'll find that
it feels just right it feels snappy it's
well worth dissecting your site into
those rail components and trying to
instrument your code with time and time
end and so forth and you could stick to
the limits they are very very good they
will serve you well and as always test
and use webpagetest use dev tools and if
you try big rig do let me know and with
that I will say thank you very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>