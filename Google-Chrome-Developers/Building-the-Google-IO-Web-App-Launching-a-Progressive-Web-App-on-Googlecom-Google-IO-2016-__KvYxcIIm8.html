<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Building the Google I/O Web App: Launching a Progressive Web App on Google.com  - Google I/O 2016 | Coder Coacher - Coaching Coders</title><meta content="Building the Google I/O Web App: Launching a Progressive Web App on Google.com  - Google I/O 2016 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Building the Google I/O Web App: Launching a Progressive Web App on Google.com  - Google I/O 2016</b></h2><h5 class="post__date">2016-05-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/__KvYxcIIm8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right that's my cue thanks guys I
really appreciate you waiting out in the
hot hot Sun this is building the Google
i/o web app the 2016 a version how we
built a progressive web app and launched
it on google.com it's a little bit about
myself my name is Eric bidelman I've
been on our developer relations team now
for over eight years a long time at
Google a long time on the same team feel
free to hit me up on Twitter if you want
to talk afterwards I might not have
enough time for questions but happy to
continue the conversation there so
during my time at Google of these last
eight years I've really focused on
building a lot of stuff I wanted to be a
web developer and there's no better
place to be a web developer than Google
I was fortunate to work on a number of
different projects over that period of
time we've worked on things like the
OAuth playground version 1.0 way back in
2010 2009 html5rocks
is a site that our team put together and
I was a core contributor for that for a
while I felt build developer sites for
Chrome and polymer and chrome status
which is the blink team and chrome teams
kind of website that allows developers
to learn about new features Santa
tracker is always a fun one that
launches in the holiday timeframe so
that you can play games and kind of
watch Santa go around the globe and
deliver presents last year we built the
Google i/o web app 2015 and most
recently I've also helped with the
developer site that we have for code
labs so for you doing a code lab here
today that's that's using polymer and
that's using the the site there so I
guess the moral of the story here is
I've gone through some kind of gray
period and then like in my later years
I've just like to switch into a blue
period but really it's kind of cool
because all of these sites are
open-source and all of these sites are
using open source technologies none of
them use kind of the Google special
sauce Google infrastructure the magic
stuff that Google hides away we've all
kind of used the stuff that you guys
have available to you as web developers
as well and we've really tried to do
that throughout the years so of course
today I want to talk about a new site
it's the Google i/o web app the 2016
version hopefully you've been to the
site before coming to the show and you
can see it kind of changes over the
course of the three or four months that
we work on the project depending on you
know kind of what phase we're in
registration happens the schedule comes
out today the experience of
the videos and live stream we call this
project Iowa so that stands for Google
i/o web app it's a state in the Midwest
where which is where I'm from but it's
also our affectionate name for the
project and we really do believe it's a
web app it's not just a web site that's
why we call it Iowa so if you hear me
say that that's what I'm referring to
and if you haven't seen it it's a it's a
true progressive web app again it's on
this domain a Google domain launched as
a real product the official site for the
product the the event it's got desktop
experience that they've got a mobile
experience it's written in polymer you
can see it uses material design so we
have things like push notifications
serviceworker we've really spent a lot
of time kind of making the site work
offline making it really well offline
full screen videos that's kind of the
bread and butter of i/o when you're at
the show right people want to see the
content especially if you're not at the
show you want to see the stuff on videos
and then if you kind of go dive into the
rest of the page it's a single page
application so you see transitions
between pages you see kind of cool
material design effects as they happen
of course the main thing about IO is the
schedule so that's kind of the
centerpiece for a lot of the time that
we spend so it's really cool it's a
full-fledged experience there's a lot
going on and that experience again
changes over time it's not just a static
site it actually really evolves quite a
bit so if you came today you actually
saw the countdown counting down to zero
and it flipped in this little fun mode
where you see androids head and a few
other cool things and that plays for for
10 seconds and then you get thrown into
for the next three days you get thrown
into a live stream experience so we've a
full-screen YouTube video and then users
can bookmark and save sessions and kind
of customize a schedule and and get
notifications about when that stuff
comes up so very immersive experience
very different experience depending on
where we are throughout the course of
January to May so we built a modern app
and we really had to utilize a lot of
new modern technologies and so we pretty
much used everything under the Sun when
it comes to the modern web platform not
just client side but also you know full
stack server side so again we spent a
lot of time making serviceworker happen
making offline experience great so that
was a big focus of what we wanted to do
with this progressive web app we
implemented push notifications we worked
on accessibility it's a single page
application using web components and
polymer and I'll talk
about why we chose that route we're
using new API is like firebase Google
sign-in our back-end is written in go
and app engine just again using the
developer products that you guys have
available to you as well nothing special
here we're just using the same stuff the
team that builds the app this year in
last year is actually a very small team
it's not a bunch of software engineers
at Google it's actually a team like
myself just 20% engineers that work on
our developer relations team and we
focus on different areas so if there's a
bug or something you know there's an
issue in the site you know who to blame
here now so if you didn't get in push
notification for this session you can
talk to Nicolas Garnier but I just want
to highlight again we're not using
anything Google internal it's using
developer products that everyone has
available to them and the team is not
kind of a dedicated team it's just a
essentially a list of volunteers so why
would a list of volunteers why would you
know 20% engineers at Google want to
build something of this scale and have
all this pressure put on them to be the
official site well we have some goals
every project should have some goals the
first goal is it's fun to write code
right we're engineers at Google too we
want to write code I will show code in
this presentation because I think we
solved some interesting problems along
the way and I want to share them with
you and how we we tackled some certain
things but it's also interesting for us
as people that talk to developers and a
regular basis to actually build real
things not just demo it's not just
sample code but actually build real
products with real users with real bugs
with people complaining in Twitter if
you do something wrong it's this fun
stuff and it's painful if we go through
the same experiences you guys do we run
into bugs we file bugs against our
product teams as well and this is kind
of one of the goals we have implicitly
is that by building a real product that
has real challenges we actually go
through some of these pain points
ourselves so if we're going to talk to
developers we should be able to speak
the lingo so we filed a lot of bugs
against different product teams at
Google we even reported you know browser
bugs to different vendors for certain
things like HTTP to push issues and so
it's really cool because it ends up
making the whole developer platform at
Google better just because we're kind of
using some of these new api's before
anybody else starts to use them we call
it dog fooding at Google so it's an
extensive project and again it's not
just a site it's not just that what you
see kind of
you know the visual part of it but there
is a whole architecture here that I kind
of want explain I don't you don't need
to know all the pieces here the port in
bits are that we have a front end right
it's written in web components I'll talk
about that we talked to a bunch of api's
Google YouTube analytics maps in between
our front-end and come to back-end in
the outside world it's a serviceworker
right you're gonna hear a lot about
service workers and progressive Web Apps
and so we wanted to actually exercise
and build you know real progressive web
app and so we obviously implemented
serviceworker to do some of the cool
stuff you can do like push notifications
wines in blue are authenticated requests
so we have Google sign-in you can log in
and personalize a schedule for i/o for
our back-end for that reason firebase
which is really really amazing real time
database in the cloud and the cool thing
we did this servers we actually shared
this back-end with the Android native
app and the iOS client that we have this
year so everybody is kind of syncing on
the same data if you bookmark a session
in one it shows up in the other app and
if you've ever used firebase it's
actually amazing this is the first time
I had real kind of experience using
firebase for a significant project on
the right here you see the native
Android app and you see this session and
you see Iowa our website on the on the
left and you can see what happens is
that when I bookmark you know the
session in one app the native app it
shows up instantly in the website as
well and this goes for the other way
around
firebase really for us became kind of a
communication channel it's not just a
database but it was a way to you know
listen to data and as that day to change
then update our UI so it was great for
them that was great for us and the iOS
client does this as well another goal we
had was to build a progressive web app
and all the usual suspects here apply
I'm not going to kind of dive into the
the basics of all you can do in
progressive web apps but we have you
know SSL we wanted people to launch us
from their home screen have that
experience just like a real app or a
real boy splash screen right so people
can launch us and get that immersive
experience that's what it looks like in
our app serviceworker gave us
notifications and for an event like
Google i/o it actually makes a lot of
sense to send notifications to a user's
device that was actually making the
experience that much better for the
event for users looking at an attending
i/o
and of course serviceworker gets you
things like push notifications it gets
you things like offline caching but we
actually went the extra mile and did a
fair amount to make firebase base work
offline and also make our dynamic
content work offline as well and I'll
talk a little bit about how we did that
so serviceworker for us unlocked a
number of actually interesting use cases
that we wouldn't have been able to do
without it the first is the push
notifications but again for us it was
about re-engaging users for i/o we can
send them reminders to rate sessions or
when sessions are starting when sessions
have been updated again this makes
actually the event itself a lot more
valuable to users fully off on
experience for us we actually did some
really cool things with caching offline
data to analytics so we are big fan of
analytics we want to know what our users
are doing on the website so the fact
that we can intercept network requests
in serviceworker while users are offline
is pretty cool you can stash those in
index database and then when the user
comes back online we just replay those
back to analytics and actually analytics
is happy to take this data you it can
take tit delay data and give you the
same kind of insight into what users are
doing while they're offline as when
they're online as well and we use
serviceworker as a performance tool so a
lot of people know about serviceworker
as kind of you know for offline and push
but we actually use it as a performance
tool and we track this over time what
you see here is visualizing our first
paint time in Google Data Studio 360 so
check that out I think it's a relatively
new product but essentially we're
reporting in analytics user timing data
are the first paint time that the
browser sends and you can you get this
with this API in chrome and Microsoft
edge and ie has this as well and so we
track this over time you can see our
first paints pretty good around April so
this is when a lot of people are heating
our app for the first time they're kind
of checking out the schedule for the
first time maybe they missed the
registration and missed the
announcements so that's kind of the
spike there so P time visitors and you
can see what happened over time is our
first paint went down because they're
coming back to us they're coming back to
us with a service worker and service
worker has had all the assets cash in
their browser
so over time this became a performance
tool and actually made our app faster
thanks to serviceworker
so speaking of first paint show some
wrong numbers for our splash screen we
actually be pretty good on mobile if you
don't build a progressive web app that's
not fast people are not going to use it
so we really honed in on the performance
so on webpage test in a 3G connection
with the Nexus 5 device we got about a
three point one first paint pretty good
on a hindered connection and of course
that repeat view is even better thanks
to serviceworker so the fact that people
are coming back to us we're painting
pixels faster because all of our assets
are in the cache there's no one network
at play desktop to even better because
there's not a hindered connection it's a
more capable device so about 357
milliseconds and a repeat view even
better in that case as well so those are
some the goals and why we kind of do the
i/o web app every year in house I want
to switch now to talk about some
interesting things in three kind of big
buckets challenges we face hacks we put
in place cool things like material
design how do we implement some of these
flashy things and material components we
wrote a single page web application
using web components I want to talk
about why we did that and how we did
that and offline of notifications I
think there's some interesting UX
patterns here and things like making
firebase work offline that are not
immediately obvious at least they
weren't to us when we first started
developed so let's talk about material
design moral of story here is we built a
web app that uses material so for that
we use polymer polymer has a rich set of
already kind of fabricated material
design components things like ripple
effects you see sliders drop downs
widgets dialogues the point is a lot was
already done for us when our design team
came to us and said build this hey we
already have some of this built for us
we don't need to reinvent the wheel and
that's kind of the power and awesomeness
of web components so we use polymer set
of materials anchor points we also wrote
our own custom elements I'll talk about
that some of the new elements the
polymer team is working on are also
things for like scroll effects so full
app layout elements and things that
manage on a mobile UI they manage things
like scroll States so you can see in
this demo here as the header kind of
goes out of place you transition between
a background image and a color when you
fling back down this the the scroll bar
or the top nav becomes sticky again and
so you can do all this yourself we could
have done this
but again we didn't want to it was a
herd he done for us we're lazy so we
implemented this this elements app
header element just drop this in your
page tell it how it should behave with a
couple of HTML attributes and what
effects it should do and then you get
kind of sticky position scroll header
behavior just like this so it was really
easy for us just to use and the other
thing we did with material is we have
these kind of full page transitions it
wasn't enough just to throw somebody on
a new page we wanted to make that purty
right so we did that using a couple
different things and I'll talk about how
we did that we had a simple routing
system nothing's nothing fancy here
basically just using the history API pop
state events history API and when
someone hits a back button or goes
forward we run this magical page
transition method so what page
transition does in our router class is
essentially goes through a list of
promises each kind of happens at a very
particular time to manage this state so
the example here you see what happens
when you transition between a page the
schedule page to the tending page and
you can see it in real time and slo-mo
what happens is the the header kind of
fades out and the content drops down and
fades out and then the reverse animation
plays so in order to run this we
basically first fire a Dom event this is
just a vent we made up page transitions
start and what this does is it tells the
current page hey this animation is
starting sort of do anything stupid like
run a bunch of JavaScript at this point
we want the performance to be really
good the second thing we do is we run
this kind of promise sequence we have
this little animation helper library we
call them and that's our Iowa namespace
very proud of that and we run exit run
exit animation and that's the thing
that's going to fade out the header and
drop the content down so that's what
that promise is responsible for in the
next promise sorry
the next promise we update state we
update state
I'll update the state of my slides so
the next promise we update state we just
basically select the new page and we set
our router to kind of the current URL
that's all that's doing next promise
calls the run enter animation and this
is the thing that fades in top nav and
slides in that content so the reverse
animation essentially of run exit
animation and the last thing we do in
this promise sequence is then fire a
final dumb event page transition done
and that tells the new page hey all this
cool stuff that you've just done is done
and you can then go ahead and do extra
setup logic or whatever you need to do
to initialize yourself what I like about
this is that essentially we have all
this asynchronous stuff going on with
CSS animations kind of lazy loading
dynamic selection of pages we were able
to rationalize it very easily with with
promises and inside of one these
functions it's using the web animations
API this is a new standard API in Chrome
and Firefox has has this in their
nightly as well run animation looks
something like this so when you
transition between pages we essentially
grab a couple of nodes out of the Dom
that title bar in that main content area
and declaratively in code using the web
animations API create kind of the
animation we want to run so transform
from zero pixels to negative 100 down
and fade out from 1 to zero give it an
easing function and a duration and then
you create a group effect and a group
effect is essentially a parallel
animation anything inside of this array
is going to be run at the same time so
both these keyframe effects the thing
that fades out the the title and the
thing that drops down the content are
going to be run at the same time and
what's cool kind of interesting thing
about this is this actually happened to
us our designers changed how they wanted
these transitions that happen what
things took place when the pages were
transitioning and so just by removing a
keyframe effect from the array or adding
it we were able to modify these
transitions very easy so web animations
API with promises really really really
great way I highly recommend it to build
material design websites so that's a
little bit about material design the
next thing I want to talk about is how
we use web components to build a single
page application again we're using
polymer here for its set of material
design components and we didn't want to
reinvent the wheel there
we want to reusability we're using a lot
of components everywhere in the site so
there's no sense to make our own but we
also built our own and so I built a
little bookmarklet to kind of visualize
how Iowa uses components anything in red
here is a custom element it's a custom
web component so you can see things like
the Settings panel has a couple of
custom elements in it the countdown on
the home page is a custom element that
knows how to count down to today the app
drawer is a web component and the items
inside of it
even if you scroll down on the home page
this little card at the bottom here if
we get to it that cycles Twitter
information is a web component it's
responsible for pulling in Twitter data
and then rendering and cycling through
that and also if you go to things like
the schedule page this is kind of where
we have more stuff going on right so
schedule items each of those items they
manage their own state their selection
state their pop up UI all that stuff is
a web component so we're using it in a
couple of different places on the site
so it made sense to make those reusable
components and you can imagine doing
this across a you know any website
thinking in components the collab sites
another example the top header here the
title and the description it doesn't
really make sense to make that a web
component because it's a one-off we're
only doing that once on the site but the
cards actually do make sense to make a
component we have those all over the
place they're used a number of times it
makes sense to make those reusable
chrome status is another example of a
site that uses web components so in this
case the left-hand nav here is
responsible for fetching the list of
chrome versions and rendering that list
that's all it does it's very good at
what it does but it was kind of cool to
make that kind of a compartmentalize
component just to do that very
particular task the polymer catalog is
another example of taking this to an
extreme they the polymer team
implemented a bunch of components and
they really wanted to exercise them to
build a UI in all web components and
they did that's why everything here is
read everything on that site more or
less is a web component and you can do
the exact opposite and this is what
github is done with their little
timestamps on the site anytime you see a
relative timestamp in github that's a
custom mount that's a web component and
so you see these all over the place
commit messages bugs all over the place
so it makes sense for them to make
reusable so you can use components as
much or as little as you need but the
point is you know if you have reusable
functionality it makes sense to make
that a component and we did this in our
application application as well so every
page in Iowa in our web app is a web
component IO - home page IO extended
page even the FAQ is a web component and
one reason we decided to do that was
because all the JavaScript and CSS and
markup particular to that page is all
kind of embedded inside of this
component we get all that goodness kind
of traveling around with us for free the
other thing we could take advantage of
is custom elements API so custom
elements the standard API in the browser
actually gives you life cycle callbacks
for very particular things that happen
in the lifecycle of a custom element so
for example when an element is created
for the first time you get a callback
for that when it's attached to the Dom
or when it's removed to the Dom from the
Dom you get a callback for that and so
for this it was actually great because
we could manage the state of our pages
very easily just by attaching ourselves
and utilizing the API that was already
in the web platform and we actually
extended the native API as well we
defined a couple of our own callbacks
for when the transitions were done and
when sub page transitions were done and
so you remember the example before when
you're transitioning between pages we
have that page transition done Dom event
that gets fired and essentially what
happens is the page just listens for
that event and then it calls its own
on-page transition callback so that's
the way we're able to manage some of the
jank in our animations just by attaching
ourselves to the native API so all pages
in our app are web components again it's
self self-contained kind of reusable
pages as people navigate between these
pages it makes sense to remove them and
add them to the Dom what we do is we
lazy activate pages you don't want like
the schedule page and the home page to
be loading at the same time right that
would be silly
so we wrap them in a template tag and a
template tag is another part of the web
component standards essentially anything
inside of a template is going to be
totally inert until the template gets
instantiated and the content is stamped
in the Dom so polymer has this feature
this dominant feature that says if
something becomes truthy then do that
for you it's kind of a helpful extension
to the template tag
and we do this through all of our pages
and we wrap this these guys in our
another custom element called lazy pages
lazy pages is dead simple all it does is
it knows about its children elements and
it knows based on the URL to stamp based
on the name there of each dum-dum F what
page should be activated so this is the
way we're doing lazy activation and
managing this single page app feel using
web components so if everything is a
component how then do you share state
across your app right how do the pages
communicate with each other the answer
for us was to do something similar to
like dependency injection if you're
familiar with that term we essentially
give every custom element that wants a
shared state an app property and defined
this app property on our window it's
just a global property that we can pass
around and kind of inject in each of the
web components so the example here is
sharing this app property between home
page and schedule page we use this in a
couple different places the example here
is we have a Google sign-in element so
when somebody logs into our app this is
the thing that's doing it it's
responsible for doing the OAuth flow and
what Google signing will do it'll change
app current user when the user gets
authenticated and then since we're data
binding in polymer we're just
essentially attaching and and wiring
these things together without any
JavaScript and so then schedule page and
home page can get access to current user
if when it changes what I really like
about this though is that as a
first-time viewer of this code you can
immediately kind of understand what's
going on so you know there's there's
pages right you kind of know what
they're called schedule page extended
page FAQ you know that there's this lazy
pages thing maybe these pages are like
dynamically instantiated or created on
the fly there's this app thing that
maybe gets shared across these pages you
can see that that app is responsive
there's these media query elements
chillin at the bottom they're you know
they're sign-in in this application so
there's a lot you can kind of you know
get from just by grokking the markup and
that's really kind of what I like about
custom elements and web components you
don't have to understand the details of
these but you can understand what the
app is kind of doing sure it stays all
over our app so we do a number of
different things we attach this to the
app global we touch things like is your
page transition done should your header
reveal itself when you're scrolling
what's the current user if
you're on what type of device so we can
show and hide different types of markup
based on that device and so this is how
we do shared state using components kind
of dependency injection and polymer we
use data binding but you can just set
JavaScript properties element dot app
equals this this global so it's just
using JavaScript under the hood so
that's a little bit about material a
little bit of why we use custom elements
for our single page application the last
thing I want to talk about is offline
and notifications so my first role for
offline so you have to let users know
about offline people don't expect a web
application to work offline I know I
don't I still don't even in 2016 when we
have things like service worker so we
really guide users through this entire
experience about being about being
offline when you first come to our site
the left image here shows you that we
show a little message a little toast
that says hey caching is complete future
visits will work offline so we
immediately let the user know hey we got
you covered
this thing's going to work offline we
spent the time to make this thing work
great offline the second thing we do is
that if people come back to our site and
there's a new version of our app we show
the message that says hey there's a new
version hit this awesome bright yellow
refresh button and so we really want
people to get the latest version of our
app because service worker is really
good at what it does it caches very
heavily that's great for offline it's
great for performance
but if you know they revisit our app and
they get the old version that's no good
either so we want to let them know that
we don't want to like hard refresh the
page because it's kind of a bad user
experience too and you see products like
Google inbox doing this and I think it's
actually really valuable really
effective the next thing we do is if you
come to us and you go to airplane mode
you have a flaky network connection and
we tell you that we say hey we think
you're offline but don't worry again we
got you back anything you're gonna do
just proceed as normal you can bookmark
sessions add or remove them it doesn't
matter that it's not really saving to
firebase yet but when you come back
online we tell you hey everything
checked out we added that stuff to your
schedule while you did it offline so
you're really guide users through the
entire offline experience so there's
kind of this like big elephant in the
room I talked about firebase a lot
firebase is really amazing real-time
database in the cloud
all the different apps the scheduled
apps for i/o this year use it as their
back in but what happens when you get
pretty little Dino right a web socket
API how do you make that work offline
well that's that's the challenge so it
was a challenge actually but what we
ended up deciding on was basically just
wrapped the thing in index database so
anytime you try to set data in firebase
stash it in ID be first try to write at
the firebase and then remove that that
stash data from firebase so in our
firebase es6 class we have a set
firebase data method that we call for
all firebase operations
takes a path of the bucket the the thing
we want to change in the database and
the value we want to set it to and then
we run through a list of promises
so we first push on to index database
with what the user was trying to do we
then set firebase data if we can update
the live database in firebase and then
we remove that information in the next
promise and if there's any errors we
just say hey can kind of write just
remove that stash data we want to try to
replay that bad state so this allows us
to make the app work entirely offline
you can use it just as you would online
so the example here is toggling a
session when a user wants to save a
session to their schedule or remove it
from their schedule
we have toggle session and take a
session ID and if it should be saved or
removed and the current user and then we
just go through this flow so if you're
authenticated that means you're online
so we'll just basically our firebase
reference pull your user ID from that
live connection and then we call that
that magic set firebase data method that
under the hood does index database and
sets the data and removes it now if
you're offline you'll drop down to the
else if you won't be authenticated so
we'll grab your cached user ID that we
have for you and then we just queue up
an operation and what queue operation
does is also just writes data to
firebase what you were trying to do and
then the value we're trying to set it to
so when the user comes back online and
maybe have a connection again we
essentially just have this an it app
function that pulls in the schedule and
then tries to load their personalized
schedule on top of that the things
they've bookmarked in their schedule and
so we've tried to replay that from the
cache so anything the users
while we're offline we basically just
try to replay it for index database and
update firebase if we can this is what
it looks like pretty simple actually so
load user schedule if you're replaying
from the cache we just read from index
database iOS simple DB is just a little
helper library that we have that promise
a Phi's if that's a word index database
and so we just read that information
from index database and then just update
our UI and that's the thing that
actually does the the cyan bar next to
the events that you've actually
bookmarked now if you're online that's
the easy case you just basically drop
down and we clear the cache and we
immediately just set up live listeners
to firebase and so that will subscribe
us to the data changes and we call the
same update schedule page UI starting up
online we go through this whole
authentication flow I just wanted to
show this code real quick because the
interesting thing we're doing here is
actually since we're on a Google domain
we have a lot of users we're sharing a
firebase across different applications
we wanted to scale it really well so
we're using this same hashing algorithm
to actually shard users in firebase to
different buckets we have 10 different
firebase buckets that users get bucketed
into and then we set up the reference we
authenticate you with Google's OAuth
endpoint and we replay that information
when you start up online so that's
offline that's something serviceworker
gets us we also have proper
notifications in the app and the rule
here and my role my personal rule is
that you have to let users know about
this the reason is because again people
don't know they don't expect to get a
notification to their device from a
website that's still bizarro so we guide
you through this experience as well the
first thing we do is we don't prompt
water right away we don't say hey can I
just have notifications permission the
user actually has to take an action that
requires notifications so they'll try to
bookmark a session well take them
through our sign-in flow for first time
users they'll go through the OAuth flow
when they come back at this point
they have to actually allow that
permission the browser API to go through
so we bring that up and then the last
thing that happens is we save that
information to firebase and that's what
calls this little toast that says it's
been added to your schedule second time
is easy the second time they're already
logged in
they've already enabled the
browser permissions so we can just show
them directly that message that says
this thing was added to your schedule
something we've did decide to do in our
app was actually have a setting where
people can then change the notification
permission we don't want they decided a
later point they don't want
notifications from our app we allow them
to change that setting the other thing
we deal with is what if people don't
want to be notified if they've hit that
block button they don't enable the
browser permission we can't send them
notifications but that's their choice so
that case they'll try to bookmark a
session they'll hit the block instead of
allow and we say hey can you please
update your notification permissions now
we decided to do this because we think
notifications for our app and for Google
IO are very valuable so we basically
have this link where they can go off and
learn more how to re-enable that
permission in the browser if they choose
to do so it's kind of a hitting setting
especially in mobile so we let them know
how to do that and how to update that in
chrome and we actually keep showing this
it might be a little bit pervasive but
again we think the notifications are
interesting so we said hey that thing's
been added to your schedule but if you
want to learn more how to re-enable
notifications here's how to do that the
other thing you have to deal with is how
do you modify your UI based on the fact
that the browser supports notifications
or not if you remember before we have
this Settings panel that has kind of the
description of what notifications will
give you on the site in this check box
and we also have special UI elements
like set a reminder for when IO starts
and in other devices or in other
browsers that don't have the feature we
have to you know modify the UI based on
that that feature detection so this is
pretty easy we basically just have this
class notify feature anything that's a
notification feature we put that class
on we feature detect the future text
pretty gnarly by the way if you can tell
you can't tell if the check for a number
different things to know if
notifications are available if you don't
have that feature we just applied this
global class two-body real quick dirty
hack and then we basically just hide any
UI element if you don't have
notifications very easy way to just
modify your UI based on effective
notifications so those are the three big
buckets I want to talk about and the
things and the challenges we tackled
where we tackle material design
components and
offline notifications I also want to
highlight just a couple of cool things I
we solved along the way we ran into
maybe their tips and tricks for you guys
to kind of take to your next projects
the first was to actually measure the
usefulness of notifications so we're
doing that in our serviceworker code by
handling the notification click event
and then essentially just constructing a
URL back to the user's schedule so when
they click the the item it takes them
back to their personalized schedule and
we append this UTM source notification
attribute this is a URL parameter that
Google Analytics understands and it
essentially allows us to know and
measure the usefulness of each of the
types of notifications we send so maybe
next year we're not going to do
notifications because they're not useful
again part of this project was
validating progressive web apps and kind
of a usefulness of all these these
awesome features the other thing we
learned is that serviceworker is a
pretty sweet technology right but it's
actually a real pain if you're trying to
develop with it you don't know if it's
your fault if it's the service workers
fault if it's you know the planets
haven't aligned like there's just a lot
of things you start to question and soda
buggy service which is actually pretty
painful sometimes but we learn a couple
things along the way that hopefully
you'll it'll help you so the first thing
is if you're developing do not turn on
caching do not use the cache API for us
we actually have a couple of gulp tasks
that run that generate different
versions of serviceworker and for our
developer environment our production
environment our staging environment and
for dev we basically don't use caching
so we know that serviceworker is not the
issue there
so we're guaranteed had like the latest
file changes and all that good stuff the
second thing is a lot of people don't
know if you just do command shift are at
least on a Mac it'll basically reload
the page in chrome without serviceworker
at all and so this is really handy to
get a quick gut check if serviceworker
if you think serviceworker is like
messing with your mind which is which it
often does the other thing that we took
advantage of was this about page in
chrome it's really handy just for
drilling into a serviceworker you can go
in there debug a page debug a
serviceworker code start and stop a
serviceworker kill serviceworkers a good
way to like start over from the fresh
user experience so I highly recommend
that and the dev tools team has actually
done a tremendous amount of work in the
couple of weeks maybe getting ready for
Google i/o and adding a bunch of cool
stuff for service workers inside of the
the dev tools so you can do things like
actually simulate a push notification
now to your app just by pushing a button
and that's really easy and awesome for
testing so anything we you know we built
a mobile app and really you know again a
firebase real-time web socket API you
know what does that mean for mobile
battery performance right if somebody's
viewing our app so we didn't know we
took a guess we said hey this is
probably pretty cool we can listen for
the page visibility API and just shut
off the WebSocket altogether when people
bring our app back up we turn the
connection back on I asked around Google
I asked around Twitter
nobody has data on mobile battery
performance and how web platform API is
affected so if you guys if anybody out
there has that data or is willing to to
share it and discuss with me I'm really
interested in it this was our best guess
and again we just kind of did this
because it felt felt good we're a big
fan of Google Analytics in the site and
for us it was very valuable to actually
in real time
get client-side errors and know exactly
what issues people were hitting in
browsers JavaScript errors so we report
everything to analytics any JavaScript
errors that happen we actually use this
during production pushes to measure what
people were doing and how are we how
crappy developers we are basically and
didn't think about cross browser issues
and stuff but it's kind of cool to see
these different errors rise to the top
and we were actually fixing them while
we were in pushes that's really easy to
do so we just attached ourselves to the
on error global on air event that is
fired and then on modern browsers you
actually get a full stack trace so we
have a file number a line number and a
stack in inside the JavaScript that we
push and we just send that to analytics
as an error event so it gets categorized
as a special event and then we know
exactly what error it was and hopefully
can track it down pretty fast you can do
the same for promises so in our app
we're using promises for just about
everything really love promises there's
two events for that unhandled rejection
and handled rejection handled and so
we're doing that as well reporting any
promises that were rejected that we
didn't think of and report in as
analytics the interesting thing here is
I just scrolled away from it but the
interesting thing here is that you know
just because a promise isn't handled
right away doesn't mean it's it's an
error right so our quick hack here was
to wait 10 seconds if you not handled in
10 seconds then you were probably an
error so we report that to analytics we
just push all these on handle promises
onto an array and then report those to
analytics there it is so just has
another error event unhandled promise
and then the reason it was unhandled so
that's it material design components
offline notifications how we built the
version of the web app this year used
firebase use material shared a back-end
with the different versions of the app a
lot of stuff to cover in you know that
45 minutes but I do want to mention that
the code has been open-source today so
if you want to check it out you want to
know how we did certain things file
issues ask questions send PRS you'll
help everyone that views the site it's
on github under Google Chrome io web
2016 and the app is of course at that
URL if you want to hit me up and ask
questions on Twitter feel free to do so
really do appreciate you guys coming out
today I know it's hot out there and
thank you for everyone watching the
video thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>