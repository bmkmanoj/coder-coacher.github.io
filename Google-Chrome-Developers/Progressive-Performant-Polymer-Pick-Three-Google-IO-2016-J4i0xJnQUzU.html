<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Progressive, Performant, Polymer: Pick Three - Google I/O 2016 | Coder Coacher - Coaching Coders</title><meta content="Progressive, Performant, Polymer: Pick Three - Google I/O 2016 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Progressive, Performant, Polymer: Pick Three - Google I/O 2016</b></h2><h5 class="post__date">2016-05-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/J4i0xJnQUzU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon everyone thanks for
coming out and joining me in this
awesome web developer igloo thing that
we're in it's pretty cool all right so I
got a ton of stuff to go through so you
guys ready okay all right my name is
Kevin Shaw I'm a software engineer on
the polymer project at Google and today
I'm gonna be talking about how a whole
series of new technologies shipping in
the web platform all fit together really
nicely to allow us to deliver
progressive performant mobile app
experiences to our users but before we
start I want to talk a little bit about
the polymer project and how we think
about our mission so polymer is a team
of front-end web developers just like
many of you and we work inside the
chrome organization at Google and we
actually collaborate really closely with
the browser's who build chrome the
browser itself and what we're most known
for our work on web components and the
polymer library our mission is actually
a bit broader is to help the web
platform evolve in a direction that
makes life easier for us developers and
the users that we serve and a recurring
theme that we see over and over is that
wherever the web as a developer platform
has failed us right wherever there are
holes or like annoying deficiencies we
see an amazing thing happen we see the
this vibrant web developer ecosystem
rise up and solve all these problems in
user space right so these often take the
form of new libraries and tools and and
you know JavaScript frameworks that all
kind of layer on top of the platform
right and on the one hand this is
awesome because it allows us to get our
jobs done and kind of without waiting
for the web platform to catch up we can
get our app shipped to our users today
but it's also good from time to time to
take a step back and realize that a lot
of these layers that we pile onto the
platform and start to take for granted
actually have real costs right so some
of the cost come in the form of
developer complexity so we've drifted a
long way away from where we could just
edit some HTML and refresh it in the
browser
to a world where starting a new web
project usually means wading through a
sea of complicated choices setting up
really complex tool chains and cobbling
together something that hopefully is
going to result in in something good at
the
right but more than the developer
experience you know as we're layering
and layering on to the the platform
inevitably this takes a toll on the user
experience as well right so this is a
real trace from a kind of a nickel
experience that our modern tool chains
and our modern frameworks pushes to
today
this is the type of experience that
we're delivering to our users on mobile
and actually really stinks right we're
before the user can interact with or
even get that first impression of our
site they have to wait for this big
JavaScript bundle to download and
execute on the client right and while
this worked on desktop for mobile users
it's a horrible experience and this is
what we're doing to them and it's not
just academic right mobile really
matters not only is it where we're all
spending a lot more of our time on the
web but it's the mobile web where the
next users of the Internet are coming
online for the very first time right
they're gonna experience the the
internet for the first time on their
mobile phones and it's in these far you
know parts of the globe that you know we
can we can't count on on fast devices or
fast networks right so if we're really
going to delight our users today and
capture the next billion users coming
online in the next few years we really
need to stop and think about how we can
start working a lot more closely with
the platform and undo a lot of those
workarounds that we've had to layer on
top and this is really the mission of
polymer is to help identify and fix all
those core deficiencies in the web
platform so that we can really start to
work a lot more closely with it to
deliver great experiences to our users
all right so that's kind of how we think
about our mission so in my talk today
I'm gonna cover a few things so first I
want to talk about the ideal user
experience right so if the trace I just
showed is kind of the the suboptimal
let's talk about what would be ideal
right so the ideal user experience then
I'm gonna talk about how we actually
have a lot of new platform features the
platform is actually evolved to help us
achieve this experience and then and
then we're gonna take all those platform
features that I'm going to introduce and
put them together into a really nice
pattern that we can all start using
today to start delivering much better
experiences to our users and then
finally we'll see it all
action so we've built some some demos
and we'll pull them up in the dev tools
and see it all working right so okay if
we're going to be talking about awesome
user experiences we need to decide what
makes an awesome app it all comes down
to user experience right so first when a
user first finds a link into our
application say they find a deep link
and from maybe something on social media
or from a search result they want to see
they want to be able to load that
content and interact with it as quickly
as possible right so they want a fast
load from a deep link but then once
they're in our application then they
navigate to other parts of the
application they also want fast
responses to those actions and then you
know native native applications really
taught us what good mobile UX looks like
and just because users are interacting
or accessing their content through the
web doesn't mean they they want some
lesser of an experience right so users
want that immersive Alcala app like
experience and then finally users want
to be able to access their content and
their applications when they're offline
or when then when the network is failing
right so it's really when we can check
off all these boxes that we know we're
really delivering an awesome experience
to the user we can hit peak awesome on
my awesome o meter you like that okay so
so how are we doing let's let's kind of
use this scorecard and evaluate a few
different approaches to building apps
and see how they stack up okay so back
in the old days we had web 1.0 right so
in this architecture when the user first
enters our application through some deep
URLs so here the user saying I want to
see a list of men's t-shirts right
that's what the URL says the server just
sit back HTML that gave them exactly
what they asked for right they got the
HTML that renders out the list of men's
t-shirts and then when they navigate
from there say they click on a product
detail link there and they might go to
the detail route then the server just
sent down exactly what they asked for
all right so this is basic stuff so
let's take a look how it's how it kind
of looks on the on the scorecard here so
because this server was sending down
exactly what the user asked for add in
at any point they got a relatively fast
load from the deep link right but it was
those full page reloads that really
killed the interactivity and and you
know when you access a web 1.0 site
today it just really doesn't feel like
the kind
native app experience that we we come to
expect right and then applications built
like this of course are tethered to
their server and just really don't work
offline and are really a frustrating
experience when you're when you're in a
subway tunnel or something right
so you know judging by today's standards
web 1.0 just isn't so awesome on our
awesome o meter right okay so fast
forward about ten years and we got the
XML HTTP request right the xhr so this
is the first time that we could
communicate with the server from the
client without doing a full page refresh
right so gradually we started to adopt
Ajax based approaches to building
applications we started shifting a lot
of the the application functionality
from the server into the client right
and so until eventually we settled on an
architecture that we kind of called
single page apps today right so in this
architecture when the user first enters
our route into our application the
server instead of sending down that HTML
they send a bundle of JavaScript that
contains all of the the code you need to
handle all of the client-side
interactions right and render out all
the client-side views and then once that
application boots up it looks at the
route decides what view to render
renders it out and then from there when
the user navigates through different
parts of the application they get a much
better experience right so if they've
switch to the detail view because we can
handle that route change on the client
we can immediately activate and render
that view without any any sort of a you
know going back to the server and if we
do go back to the server we might only
be going back for data right so we get a
much better much better user experience
here so because we're cutting out those
full page reloads when the user is
navigating around we get a much faster
response to user interactions and
because we're able to put all this
functionality client-side for the first
time we're able to really kind of build
a more immersive app like experience
right but we had to trade something off
for this right so before the user can
actually interact with anything in our
application they have to get this big
bundle of JavaScript down right and
because you know we're moving more and
more functionality into the client
typically we'll enlist the help of a
framework to help manage all of that
complexity and it's the and it's sorry
it's a it's these big bundles of
JavaScript that are blocking that first
interaction the
first impression that the user can have
with our site and so a lot of modern
kind of frameworks today try to chip
away at this problem through what's
known as server-side rendering right so
this is where we'll take the framework
and try and run it on the server as well
and have the framework output so the
first time the user accesses our site
we'll have the server output some
placeholder HTML that we'll send down so
we can get a fast first paint but then
the user is just kind of sitting there
looking at an interactive site until
that big bundle of JavaScript downloads
right they sell to wait for that big
bundle of JavaScript before they can
actually interact with the thing they
asked for they ask for the lensman the
list of men's t-shirts and they're
blocked waiting for the whole
application to come down right so this
is what we trade it off we trade it off
that fast load from a deep link to get
that fast interaction once it's on the
client and it's really these big bundles
of JavaScript that just aren't
compatible with those next users coming
online they have to contend with poor
networks right so here you can see that
single page shots were a big improvement
we really improve the user experience
but we're still kind of you know in the
middle of the awesome o meter so that's
the question how do we hit peak awesome
on the awesome amou o meter right and if
this sounds really hard
I can totally sympathize with you right
because for years the web has been this
bumpy platform we've had to cobble
together solutions and add lots of
layers and abstractions on top to make
anything go really but what I'm here
today to convince you of is that the web
as a platform has evolved and we have
some awesome new technologies that we
can use today that all fit together to
make this kind of ideal experience I
just talked about actually not only
possible but easy to develop so I'm
going to go through each one custom
elements is a new browser primitive that
allows us to decompose our application
into manageable maintainable components
without a lot of framework overhead HTML
imports is a way it's a new dependency
loader built into the platform for
loading those custom elements HTTP 2 is
a new networking technology that's
really well-suited to loading granular
dependencies such as like we will have
when we have a lot of components and
then finally serviceworker is a new
capability we have in the platform to
control the browser cache
and that allows our applications to work
offline so I'm going to go through each
of these forward new technologies in a
little bit of detail so we all have a
kind of a baseline understanding and
then we'll circle back to put them all
together into a pattern that you can
start using to build this awesome
experience okay so custom elements
custom elements solves this this need
that we have as developers to manage UI
complexity right so over and over we see
that developers need a component
abstraction to help us manage our code
right we want to we want a component
model for widgets like UI picker or like
pickers and and menus and and date
pickers that sort of thing
but we also want components to help us
manage our own code right we want to be
able to break our application down into
manageable chunks of code that we can we
give us more maintainability and reuse
across our applications right and
because the browser never helped us with
this it never gave us a primitive for
this we had to turn to user space right
and so over the years we developed lots
and lots of libraries you know over the
years there's been you can't count the
number of libraries that try to you know
provide this sort of component
abstraction to our to our development
workflow and while they work right they
help us manage that complexity and get
the job done they have all the costs
that we alluded to earlier right so big
they add to our JavaScript payload that
we have to download there's a lot of
JavaScript
you know runtime cost typically involved
and then once you've chosen the
framework for something as basic as this
component model you're locked into it
and then you you have to incur switching
costs as the fads in the framework space
change which as we all know they've
changed very rapidly right so custom
elements aims to solve all of this and
the funny thing is that the Dom has had
a component abstraction sitting in it
for like 20 years that we all carry
around in all the browsers that we have
and it's it's the Dom it's the document
object model I like to say that the Dom
is actually the original web framework
right it has the notion of components it
has elements which are well encapsulated
elements have concepts of data through
data float through events and their
their property and attribute api's
the only problem was that the Dom wasn't
extensible right browser vendors could
like when they added the video tag or
the input type date date picker but if
we developers wanted to build a better
date picker we were on our own we had no
choice we had to go bringing some
library or framework in to do that and
so that's what the web components family
of technologies aims to solve is to
unlock the power of Dom so that we can
use it as the framework and cut out a
lot of the complexity and abstractions
that we have to send down with every
application so to give you we've talked
a lot about web components and custom
element set at path i/o so just to give
you a really brief overview of how you
might use custom elements to help manage
the complexity of an application so
here's a kind of typical ecommerce
application and maybe I want to
encapsulate one big chunk of the
application like this product detail
view and I can use a custom element to
do that so I might create a new custom
element called detail view that
encapsulates all the the functionality
inside of that one particular part of my
application now once I register the
custom element with the Dom it becomes a
first-class citizen of the browser so
the the parser the HTML parser knows
what to do when it encounters a tag like
this it can instantiate the tag and and
the tag can do the custom element can do
arbitrarily complex work so in this case
we might have that detail of you render
out the kind of encapsulated
implementation of its view so it might
be composed out of some more elements
and those could be custom elements as
well right so we can continue to break
down our application using this new
browser primitive into a lot of fine
grained components that give us that
maintainability that we're looking for
right but then once we've kind of
defined that big chunk of application
view the detailed view it's all well
encapsulated and we can just treat it
like any other Dom node with it with a
nice property and event API and then
finally as we go and continue building
our application we might start building
other other parts of application views
and composing them together into
something that eventually looks like
kind of a modern application right so
this is the basic idea behind custom
elements we have a new browser primitive
that allows us to manage UI complexity
without a lot of framework overhead
right so before I move on I want to
touch on just one other detail the
custom elements spec and this is
something that the polymer team fought
really hard for
in the standards process and it's the
notion of progressively upgrading custom
elements so what does this mean this
means that when basically you can use a
custom element tag in your in your
markup without regard to whether you've
loaded the definition yet right so if
the browser sees a custom element tag
that that hasn't been registered yet it
just treats it as a lightweight Dom node
a very cheap kind of placeholder for a
node that can be upgraded later and then
at some later point we can choose to pay
the cost over the network to download
the the definition for that that part of
the application and we can pay the cost
of instantiating that part of the
application lazily later right so this
gives us a lot of fine-grained control
over booting up different parts of the
application to really improve
performance and this is all you know
made really easy and declarative through
custom elements so we can actually
define all of our application together
in markup in a very idiotic way but then
at runtime decide what parts of the
application we want to load right so if
the user came into the hoenn went home
route we might choose to only load and
register the home view based on that
route and keep the other parts of the
application dormant we haven't paid any
costs over the network and we haven't
paid any runtime cost to bring that part
of the application um and then when the
user navigates to a different route I'll
say the detail view we could do the same
with that right so we have this really
nice platform centric way of
progressively upgrading parts of our
application that really allow us to
achieve great performance so again
custom elements is this new browser
primitive one fell swoop it gives us
this platform based way to break down
the complexity of our user interfaces
and it gives us really nice control over
the performance of the application right
okay so that's custom elements we've
broken our application down into a lot
of maintainable pieces the next problem
we have is how do we load those pieces
into the application and so this is
where HTML imports comes in so it look
it solves this problem of needing to
load components which may depend on
other components when you think about it
the the browser primitives for loading
resources just really were not designed
for this era of modular app design that
we have today where one module might
depend on another
need a load you know eventually you need
to load a whole train did transitive
dependency graph write the script tag
just does not help us with that right
and so for years just like the kimono
problem we had to turn to user space we
had to design our own JavaScript loaders
and module systems right and while these
work and they're kind of super finicky
and hard too hard to configure the real
problem can be performance right so when
you take the whole dependency graph of
your application and you hide it in
JavaScript and some opaque loader that
the browser doesn't understand you're
not letting the browser optimize the
loading of that and browsers browsers do
a lot of optimizations around around
loading resources and then when you do
other hacks like take HTML and CSS and
encode that in the JavaScript you're
also hiding hiding those resources from
the browser as well right it's all
blocked on JavaScript and you kind of
opt yourself out of optimizations that
the browser would otherwise be able to
do like background parse has parsing of
HTML on a separate thread right so
chrome totally does this but when you
hide everything in in in JavaScript
you're just bound by your own code right
and so HTML imports aims to solve this
and it's really well-suited for loading
the transitive dependencies that you'll
need for building custom elements
because those dependencies typically
will involve some HTML in the template
some style to style a component in the
JavaScript to register the element and
because HTML is a format that can
contain all of those you get all that
for free in this one loader right so in
a typical custom elements example you
might depend on two elements right so
element a and B and so I can import
those with the HTML import tag then I
can use them so I might use them in a
template right and then finally I can
define a new custom element so this is
the the new v1 spec that's coming out
pretty soon so I can just define a new
HTML element class in the implementation
of that class I might stamp the template
that use those dependencies and then
finally I can register that new tag with
the Dom right so HTML imports gives us
this really nice import which tells the
browser to load those dependencies and
evaluate them use and then export right
so it's very similar to the import use
export style that es6 modules another
you know a platform-based loader that
that's coming down the line that hasn't
quite shipped yet will also give us but
HTML imports is really well-suited for
when you're carrying all these mixed
type of resources you can define them
all in HTML files and get them does all
through the HTML imports loader so in a
typical application you'll import an
element that you're going to use and
then you can simply use the element but
because the definition for that element
might depend on other elements right so
declaratively the browser knows what to
go fetch and basically the browser can
very quickly build up that dependency
graph and optimally fetch and start
parsing all of the resources that you'll
need to build up your application so
HTML imports gives us this really nice
dependency loader that's that's
well-suited for bringing in custom
element definitions okay so we've
defined we broken our application down
into these maintainable custom elements
we now have a platform based loader for
loading those so now we're going to face
the next problem which is that HTTP the
protocol that underlies like all of the
web is actually really bad at loading
granular resources right so this is
actually one of the reasons why we don't
actually go to production with those
JavaScript loaders that we create this
is because they would fire off way too
many Network requests right and everyone
knows that you know if you're gonna
build a good web application you can't
make juvie any network requests right so
how do we get around that we end up
bundling our whole application together
right and it's this bundling that can
really kill the user experience right so
not only are the tool chains to bundle
it all together you know super complex
and finicky and hard to get right it's
these bundles that can really really
impact user experience and that's
because as your application grows right
you might start off with three views but
then your requirements change you add
more views you have more views and your
application bundle just keeps growing
and remember this is blocking that first
experience that your user is going to
have of being able to interact with your
application so the next step that we'll
do you know once this app bundle gets so
big it's obviously kind of the long long
pole in the tent for our application and
so we'll add even more complexity to our
tool chains so a lot of you know
bundling tool chains out there now
support what's called code splitting
so we'll try an identify
the routes into our application and make
optimal bundles for those routes right
so if I go into the lists route if the
lists route requires these three
components list button and tabs I'll
make a bundle just for those and send it
down so I can get that route render more
optimally right over the network then if
the user goes to a different route say
the detail route then I'll create a
separate bundle for that route as well
right but inevitably when we start code
splitting our application up we find
that we have duplicated dependencies
between routes right because we're using
these reusable modules these reusable
components and then we're faced with
even harder choices so do we break that
out into a shared module and cause
another round-trip to the server it gets
us into this really hard you know
trade-off space so why do we twist
ourselves into contortions like this so
it turns out that the route cause the
whole reason we even bundle our
applications comes back to the HTTP
protocol right so this is defined 25
years ago and it is a really simple
request response protocol for fetching
documents and the key thing is that it's
a serial protocol if you request one
document you have to wait until that
response comes back before you can make
another request right so if that initial
page load once you start parsing that
you find that you have 20 resources you
need to download you would have to
sequentially request those over the
network and just those round trips that
kill our network performance and so the
browser will try and do better it will
try and open a whole bunch of TCP
connections to the to the server to try
and parallel eyes the requests that it
finds but it's generally capped at
around 6 right and it's this fundamental
limitation of the protocol right it's
not a it's it's totally a de facto thing
that led us to bundling our applications
up right and so the awesome thing is
that the platform has evolved right so
HG b2 is the next generation of the HTTP
protocol it really solves all of this
right so the key innovation of HTTP 2 is
that it allows us to multiplex multiple
requests over the same TCP connection so
we get rid of that the incredible cost
of spinning up new TLS connections to
the server to try and parallel eyes our
requests and it avoids that that limit
that we had so now as soon as we
identify all the sub resources that a
page needs we can just ask for them all
over that one TCP connection and make
sure that the network bandwidth is is
totally Maxima
for fetching those requests so it's a
dramatic improvement in in page page
loading speed but if we're trying to
load these granular components
individually as individual files we
still have a problem and that's as we
load one module and discover that it
depends on another module then we may
still have a kind of a chain reaction of
round trips to the server to get all
those resources fetched right and so the
awesome thing is http/2 has a solution
for this as well and it's called server
push right so server push allows a
server that has just a little bit of
smarts that can understand the
dependency graph of a given resource to
start pushing all of the transitive
dependencies that that resource is going
to need in that initial request in the
initial response if you look at it it's
very much like what we would have put in
the bundle that we sent down right so
HGB - with server push really allows us
to do the bundling at the network layer
and it paves the path for us to like
just totally get rid of all these
bundling tool chains right wouldn't that
be awesome the and you know it's not
just eliminating the tool chain that
that's the benefit here it's because
when you start pushing down the
resources by filename you're allowing
them to be optimally cached right so
we're cashing them by filename rather
than the actual contents of the bundle
being kind of opaque and hidden the
inside the inside the bundle and so in
that way when we go to request another
route that might have duplicate
components the browser can actually see
that those components are cached right
so again HTTP - is this awesome new
platform technology that really needs to
make us step back and think about all
these best practices we learned about
about how to serve our applications but
the cool thing about server push is it's
really easy to to configure so if you
have a HTTP request that looks like
something like this
your application server which could just
crawl the dependency graph of the
resource that was asked for index.html
in this case all I have to do is add
this new link header and that will
instruct a push compatible server to
start pushing all those resources at
once and then when you're when you're
using a platform based really nice
declarative dependency loader like HTML
words it makes it trivial for the server
to just crawl the dependency graph and
know what to put in those headers right
so you can see how all these things are
really designed they all come together
really nicely to allow us to start
eliminating all those hacks and
workarounds that we put on top of our
applications right
okay so we'll move on the last piece of
the puzzle is service worker and service
worker addresses this kind of
fundamental beginning of time problem
we've had with the internet which is
that websites just don't work without a
network right kind of sounds silly to
say but even though I brought a user may
have gone to your your website and
bookmarked that you know if they want to
come back to that later when they're
offline or happened to be in a subway
tunnel or something it can't load right
and up until now if you really wanted to
make your your content or your
application available to users offline
you had no choice but to deliver that as
a native application right because
native applications can be installed and
so serviceworker changes all this
service workers at the heart of a new
paradigm shift that we're seeing on the
web platform that you've probably heard
about a lot today and that's called
progressive web apps so progressive web
apps are still websites you still access
them through a URL and they're still
sending back HTML and JavaScript but the
difference is that progressive web apps
work really well without any install the
first time you access them but then as
the user keeps interacting with the site
it becomes progressively more useful to
them so it can then open up without a
browser connection because the entire
application can be cached it can get a
launch icon on the home screen and open
in a full screen experience and you can
even receive push notifications right so
it really allows us to progress from a
website into a full-fledged application
Alex Russell who wrote a kind of
defining white paper on this shift to
progressive web app said progressive web
apps are really websites that took all
the right vitamins right they do all the
right things for the user and it's all
powered by serviceworker so there's a
lot into serviceworker and there's a lot
on the web you can you can read about
them I'm just going to touch on a few of
the really key points so serviceworker
allows us to basically write code that
acts as a proxy between any network
requests being made by the browser and
the
network and so there we can intercept
and handle requests using our own code
and that allows us to do things like
intelligently cache those resources
using our own caching strategy right so
we have complete control over the
network cache and the cool thing is is
that once you've cache something in
serviceworker those urls become
available offline
so this is the first time we can
actually have that bookmark pull back up
that website even when the user is
offline and then because we have
complete control over the the network
and the caching process we can do new
types of things like background
pre-caching of other application
components that the user hasn't required
yet but may in the future right and so
through this process we can
progressively build up the loading of
the application into something that can
work offline so we'll touch on
serviceworker a little bit more but for
now just know that everyone should be
going and sprinkling serviceworker into
their applications because it it's this
awesome way to layer in this this great
user experience okay
you guys so with me I'm gonna really
fast okay so we've got these four puzzle
pieces custom elements allows us to
break down our application into
maintainable pieces HTML imports gives
us a new dependency loader for loading
those h-2b to is new networking
technology that allows us to get rid of
all those hacks around bundling and
actually load the components that we
need at any given time and serviceworker
lets all those components run while
they're offline okay so let's put all of
these together into a pattern so we have
a four-step pattern that you can use to
think about how these all four of these
technologies go together
okay so first we've broken down our
application into these kind of
maintainable you know decomposed custom
elements so now when the user first
accesses our site so say they go to that
list of men's t-shirts so they want the
list route the server which can
understand that HTML imports dependency
graph just pushes down the components
that are needed for that route only
write only the minimum components that
are required to get that part of the
application booted up right those are
going to go into the network cache so
we've pushed them down we've primed the
cache with the components we know that
that page is going to need then when the
application boots up it looks at the
route it says oh the user wants the list
I know that the the list part of the
application is encapsulated in the
ListView element so I'm going to load
the definition for the ListView
that's going to cause the ListView to
progressively upgrade right so the
custom element we get that deferred
upgrade and because we've already pushed
all the components that we know the
ListView is going to need those all come
out of the serviceworker cache and we
get that really fast first load of our
application and it's not just a it's not
just a splash screen this is actually
the content interactive content that the
user asked for okay so that's the second
part is we're gonna render that initial
content that user asked for as quickly
as possible now the third step while the
user is kind of enjoying their list of
men's t-shirts here we let the Service
Worker boot up in the background so this
can happen async kind of after the the
initial page load and the serviceworker
is going to go off and start pre-caching
all of the the other components that the
user hasn't hasn't asked for yet and get
those all installed into the
serviceworker cache so at this point our
application is available for use fully
offline but more importantly we can we
can now when the user navigates to a
different part of the application we can
lazy load the next parts of the
application out of the serviceworker
cache and allow those to be up those
parts of the application to be upgraded
right so if the user went to the detail
route we can now add the import for the
detail view the detailed view will
upgrade that part of the application
will come to life and those components
that are needed for the detail view get
pulled out of the serviceworker cache
there's no loading required because
we've already pre cached them right and
then we get that the next view rendered
in interactive quickly as well so let's
take a look at how that pattern stacks
up on the on the app scorecard so
because we've only sent down the
components needed for the route that the
user requested we get that nice fast
initial load from a from a deep link
into the application then from there
because any subsequent navigation
we've already pre cached all the other
remaining components in the background
so by the time the user goes to interact
with another part of our site they're
able to pull those up out of the cache
and render that part of the application
progressively and get a fast response to
those user interactions again we're
building up the entire application
client side
and as well see in a moment this this
totally gives us control over creating
that app like user experience and
because we're using the service worker
to precache all the components of the
application we also make the application
offline so it will work regardless of
your network conditions we have really
reliable performance regardless of
network condition so you see we hit peak
awesome on the awesome o meter right so
this is such an awesome pattern it
really improves the performance of
delivering applications to our users on
mobile and it's all using these browser
primitives so we were like we gotta give
this thing a name right so people can
start talking about and using it and
layering it into their applications so
we try to like whiteboard we try to put
the letters around and we have likes
Plath's please and it just did wasn't
working and then I just wrote down
exactly what we were doing right so
we're pushing rendering pre-caching and
then lazy loading I was like oh my gosh
that thing totally spells something it
spells purple right it's the purple
pattern yeah and see what I did there I
can have a purple pattern on my shirt
isn't it okay okay so again one more
time through the purple pattern we're
gonna push down the components for the
initial route that the user asked for so
we can get that fast first load and make
that content interactive we're then
going to render that initial route as
soon as possible and get it interactive
we pre cache the remaining components
using the serviceworker and then we use
lazy loading patterns to lazily
instantiate parts of the app as that as
the user moves moves through the
application so if progressive web apps
are like websites that you know took all
the right vitamins then the purple
banner is really like multivitamins for
progressive web app so lets us do all
the right things for the user right
gives us a really nice pattern multi
buttons like maybe they're even for
performance-enhancing drugs right
because it really improves the
performance of our progressive web apps
so enough talk about the pattern let's
see how the progressive or how the
purple pattern works in practice so the
polymer team spent the last few weeks
building this this demo application that
really showcases the the purple pattern
so it's a typical kind of e-commerce
application but it's very responsive it
has a lot of the modern
kind of look and feel that we expect
it's an immersive app experience all
powered by these platform primitives
custom elements imports serviceworker
and HC b2 so I'm going to pull that
application up in dev tools and as we go
through an initial load of the
application I'm going to point out where
each of these that the four steps of the
pattern come into play right so the
first time I access that URL see we get
a really fast load if I scroll up in the
network panel here you can see that the
initial components that that was
required to get that initial view
rendered were pushed from the server so
this is the canary dev tool is it'll
actually tell you when you're receiving
push push resources from the server so
we get those pushed to the server to the
client really quickly and you can see
right here because the server is
proactively pushing those there's not
normally you would see a bunch of stair
set stair steps as we discover a
transitive dependencies and need to load
those and load those all these
round-trip to the server but because
we're pushing them we get this really
nice clean everything comes out at once
just like as if we had bundled it right
so the next step is to render those
initial components and make them
interactive as quickly as possible so I
switch to the Timeline view here so here
using the screenshots we can see that we
got that initial view rendered really
quickly and you can also see that in
this application we we took some of the
less important components and decided to
lazy load those as well so after we've
sent down the initial payload to get
that you know they asked for the home
view with the the list of categories
here so once we've loaded that then we
can you know spend some more network
costs and runtime costs of upgrading
other parts of the application like the
the menu bar that's going to pull out
the the drawer on the left right so we
can really shard up the the delivery of
our application so we can get a much
faster progressive experience okay so
the third step is pre cached so if we go
back to the network panel and scroll
down you can see kind of we're off to
the right of the timeline now so this is
happening after that first initial load
we can see that the serviceworker booted
up and started pre-caching all of the
remaining components so we're loading
those and getting those into the
serviceworker cache ready for the next
step which is lazy load ok so if we
switch the elements panel these are the
the four view the five views here that
make up
application and you can see they don't
have the arrow that means they haven't
rendered themselves there's no Dom
inside of them and then as we move into
different routes of the application you
can see that those parts of the
application progressively upgrade by
again we're adding an HTML import that
loads the definition for that element
and here you can see that that element
that we loaded the definition for that
element and its dependencies were loaded
out of the serviceworker cache we didn't
go to the network they were already in
the serviceworker cache and so we got a
really fast load for that that next
navigation in the application so push
render precache lazy load all right so
hopefully this sounds awesome right it's
a really new way to work really closely
with the platform to deliver this
awesome experience so you may be
wondering can I use purple today right
or are these like way new platform
things or can I can I use them today and
the first thing I want to say is really
that the purple pattern is really just
that it's a pattern so it's not married
to these particular technologies right
so as long as you're you can push down
and get just the components you need for
the application you're using a
fine-grained dependency loader as long
as you're you're able to modularize your
application you can basically implement
the purple pattern with a lot of
different technologies but it's really
when you start using the platform a lot
more closely that all these fit together
really nicely and it allows us to cut
out a lot of those bundling tool chains
a lot of those heavyweight frameworks
and get a much better experience for our
users okay so just go through the the
status of the the four different
technologies real quick so custom
elements as you probably know the v-0
they kind of draft version of the custom
elements spec shipped in chrome about
two years ago and it's usable today we
just so now it's kind of in the in the
other key note that you know there's a
lot of a lot of companies going to
production today just using the
polyfills on other browsers so we we
ship a set of polyfills but the really
exciting news right is that this year
all four major browser vendors reach
consensus on the custom elements and
shadow dom specs which means that really
within the in all of them are really
hard at work right now working on
implementing that version
the kind of standard the version 1 of
that spec and within the next year or so
we expect to be able to use all of these
web components technologies without
polyfills so that's really exciting
next HTML imports also shipped in chrome
about two years ago and is usable using
a lightweight polyfill elsewhere HTTP to
this new networking protocol a next
generation of HTTP of HTTP has basically
shipped across all major browsers right
so you can depend on HTTP to being on
the client wherever and then you'll want
to check with your hosting provider make
sure that they have migrated h-2b to as
well right because it's a huge boost to
your you're serving performance Google
App Engine and and a lot of big hosting
providers are already moving over to
HTTP to the server push side of it is
probably that the most the newest part
of all of these technologies so Chrome
and Firefox have both shipped server
push support on the client and then
again a lot of so Apache an engine
engine acts a lot of the browser stacks
are now you know have implementations of
sort of a push that you can roll out and
we're working really hard right now on
the polymer team to build a reference
server so that people can actually start
deploying with this lastest service
workers so serviceworker also has
shipped on Chrome in Firefox and the
thing about serviceworker is that it's
awesome progressive enhancement that you
can add to your application so really
with all of these technologies you can
build a really performant application
and then as your as your your clients
have more of these capabilities like
service worker or server push you get
even more benefit out of them right all
right and then we're making this all
even more concrete today with the
polymer app toolbox so we just announced
this in the last talk the polymer app
toolbox is a set of custom elements that
all that are all geared towards really
building applications so they have
things like routing localization storage
integration but in addition to custom
elements we're adding some application
templates and a new polymer CLI tool
chain that allows you to really quickly
get started with a template so here you
can install the the polymer CLI from NPM
today here I'm going to create a new
project full
sorry so the basically the CLI is a
one-stop shop for it for everything
you're going to need to do while you're
developing polymer applications I'm
going to make a project folder here and
initialize it with an app template
that's all set up for this purple
pattern that I described has the lady
lazy loading and in builds to an
environment that's appropriate for a
push server it comes with a server so
you can just start serving this template
and see what it see what it looks like
again it's designed to lazy load each of
those views as you click through them
and the tool chain is is geared towards
building this it has a responsive app
layout using a lot of some of other
other app app based components so this
is something you can go really grab and
really with like three commands and in
node get started and start playing
around with the purple pattern today so
for more information on the purple
pattern and polymer you can go to
polymer project org we've got a brand
new section of the website up there with
the polymer app toolbox and all the
information for that you can get the
polymer CLI out of NPM today so NPM
installed SG polymer CLI you do help
there and see all the commands you can
check out the shop demo application the
demo application that I showed you today
it's all set up for server push so it
works really awesome on chrome that
supports the server push and we have all
the code for polymer for the shop
application on github so you can see how
we built it it's actually built off of
that template that I just showed and
then finally I want to invite everyone
to the second polymer summit which were
holding in London this fall in October
so there's a sign-up link here that you
can get it's on that it's on the web
site as well if you go to that and
that's it so I really want to challenge
everyone to go out and think about how
to deliver awesome applications using
the platform all right thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>