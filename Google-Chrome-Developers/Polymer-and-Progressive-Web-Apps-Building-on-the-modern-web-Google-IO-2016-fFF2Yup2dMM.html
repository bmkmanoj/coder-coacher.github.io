<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Polymer and Progressive Web Apps: Building on the modern web - Google I/O 2016 | Coder Coacher - Coaching Coders</title><meta content="Polymer and Progressive Web Apps: Building on the modern web - Google I/O 2016 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Polymer and Progressive Web Apps: Building on the modern web - Google I/O 2016</b></h2><h5 class="post__date">2016-05-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fFF2Yup2dMM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right good afternoon everybody my
name is Taylor savage I'm the product
manager here at Google on the Palmer
project so before we get started how
many people here are familiar with or
have used polymer or web components
before to build about Wow okay awesome
so I don't even have to do the talk
anymore that's great yeah so I've got a
lot of exciting new features a lot of
new exciting new products to talk about
but before we get started I really want
to begin at the beginning we have one
overarching goal on the polymer project
which is to build the tools and
libraries using the latest web platform
features so that you the developers can
build the next generation of web apps
and if you've been following web
development or if you were at the talk
that came right before mine you know
that the next generation of web apps are
here and they're called
progressive web apps so the polymer
projects mission is to provide tools and
libraries to make it easy to use these
latest web platform features to build
progressive web apps but that's a little
bit wordy for a mission statement so
let's make it a lot more concise the
polymer project mission is to use the
platform to deliver great user
experiences and the key part here is to
use the platform on the polymer project
we're not trying to build massive
abstractions we're not trying to build
meta platforms we're not trying to build
mega frameworks we're trying to let you
the developer use what's cutting-edge in
the web platform itself so that you can
focus instead on building instead of
building massive tool chains you can
focus on just delivering great
experiences to your users on the web now
as I'm sure you know traditionally the
web platform hasn't been a great
developer platform for delivering these
kinds of immersive app-like experiences
the lowest level visual primitive that
you get as a web developer is an HTML
tag at these HTML tags that you're
provided from the browser for things
like headings and paragraphs and lists
were great for document markup but
they're not so great for constructing
immersive app-like experiences and over
the last 20 plus years that HTML has
existed the language itself hasn't
really evolved much
and user expectations have evolved
significantly what has evolved and what
has gotten significantly more powerful
is JavaScript and so to create these app
like experiences on the mobile web we've
used JavaScript as an escape hatch we've
built meta platforms completely separate
from the web platform we built
JavaScript runtimes mega frameworks tool
chains all in JavaScript to allow us the
developers to be able to deliver aplex
periences and this might have been fine
on desktop where we have big beefy
machines connected by cables or Wi-Fi
but there's been a major change in the
web which is the mobile web and the
mobile web is incredibly powerful you
don't have to ask permission from anyone
to publish your application to the web
and then nearly every single device out
there is going to have a browser and
that user can access your application
that's awesome but the mobile web has
incredible reach and it reaches into
places where data connections are
limited where device hardware is limited
and for the next billion users coming
online today they typically have the
worst combinations of both of these slow
data connections and slow hardware and
so building these towering meta
platforms all in javascript to deliver
an app like experience just doesn't fly
on the mobile web
when flaky 3G connections of the norm
when slow CPUs are the norm you need
minimal overhead any minimal redundancy
you need maximal efficiency to be able
to deliver that great experience so what
do we do what do we do as web developers
how do we solve this new challenge of
the mobile web well the answer so far
has been more JavaScript we keep piling
on more and more JavaScript to get this
to the work to the point where now we're
running javascript on our servers so
that we can render our application we
can get get in a state where we can send
it down to the device so at least it can
paint and then we download more
JavaScript so that it can rehydrate and
boot up and then finally it's
interactive and this is frustrating for
users and as I'm sure you're aware it's
frustrating for developers as well we
think there is a better solution which
is less JavaScript use the platform
to build modern mobile web apps use
what's already there on your users
device the browser they have the vast
majority of what they need to run your
application sitting there right on their
device use it and thanks to powerful new
features baked into the web platform
this is increasingly possible it's
increasingly possible to as a developer
construct these engaging immersive
app-like experiences using what's baked
into the browser so again on the polymer
project we want to make it easy by
building tools and libraries to leverage
these new powerful features to build
less lower overhead higher quality
applications and so so far we focused on
two things on the polymer projects using
web components and building web
components so let's start with using web
components we want the browser itself to
be more capable by introducing the
notion of a standardized encapsulated
component into the platform itself the
hardest part of building a web
application today is just knowing where
to start and for just about any large
application of any meaningful size
chances are the place to start is to
pick a JavaScript framework and by my
last count there are approximately 1
million JavaScript frameworks out there
to choose from and this is a really
critical decision it's gonna be before
you write a line of code you're probably
gonna have to pick a JavaScript
framework and then every single line of
code that you write from that point
forward is going to likely be directly
tied to that decision to that JavaScript
framework that you picked
now javascript members can be really
really powerful it can give you very
useful features for structuring
large-scale applications features like
internationalization make routing easier
and they can also provide a really
convenient mental model to think about
how you're building this application
make it easier as a developer to create
that that large-scale app but there are
a couple of very high costs to using a
JavaScript framework or a meta platform
to build your application on the web the
first cost is a cost that your users pay
when you use a meta platform when you
use this big towering abstracts from
JavaScript not only do you have to send
down the code to actually run your
application but you need to send out all
this job
the script code to provide this meta
platform and then you need to execute
that platform code on the device before
your actual application code can execute
and make your app interactive and again
this might have been flying fine on
desktop with big beefy machines with
cable connections with Wi-Fi connections
but on mobile slow flaky 3G connections
of the NorAm slow devices are the norm
and using these abstractions your users
pay the cost both in time that it takes
to download the meta platform onto their
device and boot it up and also very
literally they pay the cost in their
data plan of the extra hundreds of
kilobytes or megabytes of JavaScript
that has to be downloaded just so you
can run your application on the web and
the second cost of these abstractions is
a cost that you the developer pay when
you build a component in your web app
it's directly tied to the framework you
chose so no work you do for those
components are useful in alternate
frameworks so if your next project
you're gonna choose a different
JavaScript framework because a new ones
come out you have to throw away all that
old component code that you've written
and if you're at a company with multiple
teams and they all have slightly
different stacks slightly different
framework stacks you can't share
components across teams using different
stacks so though there are many benefits
to using a large meta platform mega
framework your users pay the cost of
that abstraction and you the developer
also pay the cost of that abstraction in
terms of framework lock-in what if there
was a better way every single framework
has a notion of an encapsulated
component what if rather than a
framework having to provide that
encapsulate component the browser itself
let you define your own components and
those components could work with any
JavaScript framework that you might want
to use and you could pick components off
a shelf that other developers have built
an open-sourced that solve a problem
that you're faced with to use in your
own application and the components would
be compatible no matter what JavaScript
stack you're using this is the promise
of web components web components are a
new set of w3c standards web platform
standards
that extend a native component model in
the web platform itself because the web
already has a component model baked in
the dog the Dom has Dom nodes which you
can call methods on which have
properties and can send Dom events and
they have a declarative way to construct
that Dom with the HTML language but the
problem is hTML is fixed and with web
components you can extend the language
of HTML itself by creating new elements
that you can then use in your
application and capsulated reusable
components without the cost of this
framework overhead and what's great is
with web components HTML becomes your
interoperability layer every single
framework if it has to have an
application run on the web platform at
the end of the day has to speak HTML
it's the lowest level visual primitive
over the web and a web component
essentially becomes another HTML tag
just like your divs your PS or your
allies and so now that we can extend
HTML now that we can create our own HTML
tags we can then reuse them regardless
of what Java scrap Java JavaScript stack
we're using so one challenge is as many
of you know if you've been following the
web component standards it's taken a
long time so the very first version of
this web component spec came out in 2012
almost 4 years ago to the day and these
specs have gone through many changes and
this is just the nature of standards
work it's the nature of spec work but
I'm extremely excited that today thanks
to broad cross browser collaboration we
are in the homestretch for a web
component support so web components is
really an umbrella term for these for
lower level primitives template HTML
imports custom elements in shadow Dom
template elements are broadly shipped to
cross browser HTML imports are shipped
in Chrome and others are pending es6
module shipping but custom element
shadow Dom these are the really the two
most powerful primitives to Alette you
extend HTML let you create your own web
components and again thanks to broad
cross flat browser collaboration from
all the major browser vendors
custom elements and shadowed on specs
just hit a major milestone with v1 so if
y1 is the latest internet iteration of
these two specs why v1 we like to index
by zero and spec land I'm not really
sure but most importantly all major
browser vendors are on board with
driving implementations of these v1
specs Firefox edge Safari Chrome were
all the table all involved with
respective sessions to get to this point
with these v1 versions it's a high
priority roadmap item for the edge team
to implement Firefox and Chrome
implementations of v1 are already well
underway and Safari already has working
versions of v1 shadow DOM and custom
elements in their nightly builds so with
web components right around the corner
and using the polyfills that already
exists today to use these features many
major companies are already using web
components in production github today
uses custom elements for all of its time
stamps in emoji across the site and
twitter just announced that they'll be
using shadow Dom for all of their
embedded tweets rather than the much
heavier weight iframes
because shadow Dom provides a very nice
encapsulation for these embedded tweets
and the ecosystem around building these
web components is already starting to
accelerate and take off custom elements
that IO
which is a major aggregator a community
driven aggregator of web components
built by developers all across the world
already has 2000 components on it
written by over 800 authors and more are
being added every single day so browsers
are actively building support for web
components at major sites are already
using web components in production the
ecosystem is already beginning to
flourish broad native web component
browser support is no longer a matter of
if but a matter of when and when could
be as soon as later this year so in the
past when we've talked about yeah
in the past when we've talked about web
components here at i/o they certainly
have been on the bleeding edge of web
development and now web components are
just on the leading edge of web
development so as you saw web components
are actually for lower level specs and
they're great and they're great to use
but they can be a little hard to figure
out how to actually build an
encapsulated web component so we built
the polymer library to make it easier to
use these four specs together to create
your own web components we first
announced the developer preview of the
polymer library two years ago at Google
i/o and this was very much an experiment
we were trying to see we're working off
early versions of the web component
specs would it be possible to tie these
for low-level specs together to make it
easy for developers to create reusable
components and the answer was yes but it
needs to be faster so last year at
Google i/o we announced polymer 1.0 and
this was a huge step forward it was a
ground-up rewrite of the library focused
on making it fast making it lean making
it ready to use in production and it was
significantly faster three to four times
faster than the developer preview
version for element construction now
with 100 we wanted to show the web
component promise was not just
theoretical but you could actually use
web components in production today since
this one auto launched the library has
seen many many new features and
enhancements and it's gotten even faster
so since this one pi no release which
itself was three to four times faster
than the original developer preview the
latest version of polymer is now another
10% faster on Safari and another 25%
faster on Chrome for element
construction
so everything we do with polymer we
build it open-source first on github out
in the open and then we pull the latest
releases into Google's internal version
control systems so Google teams can use
polymer for their applications and
despite this hurdle google is well I
mean polymer is one of the fastest
growing front-end technologies within
Google over four hundred Google project
projects today are using polymer with
over 4,000 unique components built by
Google teams to use in their products
and polymer is already launched in
production across major Google
properties including Chrome translate
play music YouTube gaming google fly and
of course the Google i/o web app which
I'm sure you're all familiar with so you
can see how serious a strategic
initiative polymer is for Google and
that it's already being served in
production to over a billion users on
Google products and not only that
polymer is being used outside of Google
by companies big and small in fact
polymer adoption in the wild has quietly
skyrocketed there are over 4 million web
pages now using polymer on the open web
and many large companies are investing
heavily in polymer and web components
for the future of their front end stacks
and I want to talk about a couple of
these companies today the first is the
first is meta port a another part a is a
global leader in online luxury fashion
the net aparte engineering team actually
first discovered polymer at Google i/o a
year ago and since then started
replacing individual pieces of their
products with polymer elements and now
today they have a complete lifecycle an
end-to-end lifecycle for all the
components that they use across all
their different sites and pages they
have their own custom yeoman generator
for generating meta part de flavored
polymer components they generate
documentation for all of these
components to make it really easy for
engineers across the team to reuse
components that other engineers have
built they run integration tests and to
end tests for every commit to every
component across all the different
browsers that they support and then they
use these components across all these
different pages across the net a port a
site which allows them both to have
visual consistency because it's the very
same components and functional kiss tips
at sea
and this has made it much easier for the
net apart a team to scale this very
large multifaceted site by reusing the
very same components the second company
want to talk about that's using polymer
is BBVA and BBVA is a multinational
banking group operates in 35 countries
130 thousand employees 66 million
customers and you could imagine that
with such a massive operation in so many
different countries they're gonna have
many many different types of
applications to build and so rather than
building a native app a unique one-off
native app every single time they switch
to using all web technology based on
polymer based on web components and so
they have this internal catalog of all
the different components that all their
different teams use and build so that
they can instead of building one-off
applications can take components from
this catalog to assemble applications
and when I say assemble I really mean
assemble web components lend themselves
extremely nicely to drag-and-drop
WYSIWYG type construction experiences
and so they've built these sorts of
tools to visually create and construct a
nexus embolic ations and not of the
components that they've built and this
ease of application creation has had a
very tangible benefit on their business
for the first project that they switch
to polymer web components
they saved 70% budget and 50% time and
their engineering efforts are
significantly more scalable and easier
to manage
so in short since one auto polymer has
come become faster more feature-rich
it's seeing exponential growth here
within Google served over a billion
users and major companies are investing
in polymer and web components so the
polymer library is for building
components major companies major Google
products are adopting these components
in building components but they're not
just building components they're
building applications out of these
components and so we get this question
asked a lot ok web components are great
but how do I take these web components
and then construct an actual application
and our answer has always been well you
know components can be arbitrarily
complex you can build a component out of
other components out of other components
out of components out of components in
yada-yada-yada and you've got an app but
of course that's not a very satisfying
answer developers wanted more
guidance on how to put these components
together in a platform idiomatic way and
so recently as the team has been growing
as the project has been growing we've
expanded our focus a bit to think not
just about how to build web components
but then also how to take these web
components and bull build full-fledged
cutting-edge mobile web applications and
of course not just any kind of web
application but progressive web
applications applications that took all
the right vitamins and of course we
don't just want to help build
progressive web applications we want to
help build great progressive web
applications great user experiences so
how do you do this how do you build a
great progressive web app on the mobile
web with all of the challenges that that
entails and of course our answer is to
use the platform use the platform to
build great apps use what the browser
gives you to achieve minimal payload
minimal overhead design offline first
and this is a hard challenge and so we
wanted to make this easier to use the
platform to build cutting-edge
progressive web applications so I'm
really excited today to announce the
polymer app toolbox
and the toolbox is just a set of
components and tools based around web
platform primitives that make it easy to
build cutting-edge progressive web
applications so what's in the toolbox
well all the things you'd expect to
build a large-scale progressive web app
components for layout for routing for
localization for storage and then a
command-line tool to tie it all together
so let's go through each of these one at
a time the first is layout all UI design
begins with layout it's the visual
structure that makes up your application
and a high-quality immersive mobile app
requires high-quality app structure it
requires that a plaque look and feel
that users have come to expect on their
mobile devices and those high-quality
layout components things like toolbars
that'll disappear when you scroll down
and reappear when you scroll back up or
a drawer that'll open and then you can
swipe it closed with momentum these are
components that don't exist in HTML
there are no HTML tags for a responsive
drawer so we built it using the polymer
library the app layout elements an app
layout has a number of UI component to
make it easier to structure these mobile
app like experiences and they're
designed to be flexible responsive and
fast so app layout elements contain
components for things like toolbars and
drawers and headers they're flexible
they're not visually opinionated so you
can use them regardless of what your
application looks like they're
responsive by default so they work
across all different screen sizes they
make easy
they make hard things easy things like
these fancy scroll behaviors that users
have come to expect on their mobile
devices and they also critically help
ensure accessibility which is a crucial
feature for any application that you're
going to build
so let's take a look at a couple of
these components so here's a really
simple example of using the app layout
components this is a basic app drawer
layout you have a drawer to the left and
then you have this set middle section
content that Scrolls the tour opens and
closes with momentum you can swipe it
closed and then you've got this headers
header layout section which is this main
content section that the user can scroll
through and this is all done
declaratively in markup and you're just
writing HTML using these web components
and I want to draw your attention to
these two properties these two
attributes on the app header fixed and
effects fixed says I want this toolbar
across the top to remain fixed as the
user Scrolls and the waterfall effect
says I want a little shadow to appear
underneath the toolbar when the user
Scrolls down and when they get back to
the top make that shadow disappear so it
looks like the content is water falling
out from under the tool bar really nice
just little subtle user experiences that
make it feel like a top quality
application but you can get more
complicated with the app layout
components here's a very similar example
a little more markup and we have a few
more attributes on the app letter app
header here the first is condenses so as
you can see when you get to the top the
header is expanded and large and it
condenses as the user Scrolls down
reveals says when the user Scrolls down
below the header hide that header and
then if they scroll up slightly show
that header again and then the waterfall
effect is the same one makes it feel
like the content is water falling out so
really subtle polish that makes it just
look and feel like a first-class
progressive mobile web app and as you
can imagine there are lots of different
combinations for these different
attributes and so we built a demo called
test drive that lets you try out these
combinations literally check off tick
off the boxes and then experience what
that would feel like in an application
right there and of course the app layout
components are totally pluggable so any
animation that we provide if you don't
like it you can easily build your own
and plug it in to the app layout
components and get a completely custom
look and feel ok great
we can lay out our application what if
we want multiple views how do we route
between multiple views this is a very
common question that we've gotten what
router should I use
and we've always said they're just web
components use whatever router you want
there are tons of JavaScript routers out
there but we surveyed the router space
and we realized that most JavaScript
routers have this singular global view
of the world all the different routes
that you're gonna have in your
application and the corresponding views
that those routes are gonna show and we
wanted to build a router that didn't
just work with web components but that
worked like web components and that it
was modular and composable that it could
route from an entire application all the
way down to a single component so we
built the app route component let's say
you wanted to build a typical
application you've got three routes
slash slash items slash cart and you
want a route between these different
views you could use the app route
component to have a path that will match
on the route it will provide a property
saying whether that path is active or
not and you can very easily toggle on
and off different views in your
application but it can get a little more
complicated than that let's say you
wanted to extract data from that URL
from that route so you have slash slash
detail slash item slash detail slash
item ID and you want to extract that
item ID value so then use in your
application app route lets you do that
with this colon stick tax and it
provides the value of that item ID just
as a property on the Dom node and what's
cool about a Prout is you could have
this at the top of your document you can
have it globally like a typical router
or you could compose this app route into
the component that's responsible for
showing this detail view and so you can
delegate the responsibility of deciding
how to use this item ID value to the
component that actually is going to show
that view so the app route it's flexible
it's modular it's composable it doesn't
just work with web components it works
like web components it can know about
your entire app or it can just be
responsible for routing one small
section of your application ok that's
great we can let our application we can
route between different views what if we
want to localize our UI what if we want
to translate it in two different
languages again very common question and
we've always said they're just web
components there are a million ways to
localize an app use whatever one is most
appropriate for what you're building but
we wanted to build an idiomatic platform
embracing way to localize application
so we built the app localized behavior
and what's great about the app localized
behavior is it uses the platform it uses
the Intel object which is a standard
JavaScript object to provide
localization data and it's broadly
cross-browser supported and where it
doesn't support it there's a polyfill
and so to use the app localize behavior
you use it in any polymer component
that's going to be responsible for
translating strings so if you are
familiar with polymer and building web
components using polymer you'll this
will be very familiar syntax to you so
use app localized behavior you add it as
a behavior to your component and then
you give it to properties the first is a
language property which will be the
language that you want this component to
be translated to and of course we have
it statically defined here but you could
very easily bind to it to dynamically
switch it and then we're gonna give it
this resources property which is going
to be all the different keys and
translation strings that we're gonna
need for this particular component and
of course here again it's statically
defined but we could easily fetch this
off the network we could have it
globally on our window object however we
want to provide this resources to the
component and then to use these
resources to localize the component
anywhere we have a string instead of
that static string we're gonna bind to
this localize function we're gonna pass
it a key and any variables any of any
content that's actually going to need to
be in that string and so what you can
achieve with this is you can translate
simple strings with string replacement
but you can also localize currencies and
numbers and dates and it even supports
plurals and genders so a very simple
tool that uses the platform to elegantly
solve very complex news cases
okay we can look so we're doing great we
can lay out our application we can route
between views we can localize each of
those views now let's say we want to
store data and we want to store data in
the cloud or locally on the device to
then use in our application again very
similar conundrum how do I connect data
to my app there are a million ways well
they're just web components and again we
wanted to provide a platform idiomatic
way to take data from the cloud from
locally on the device provide it to an
application in a platform idiomatic way
so we built apps storage now what app
storage is is it's an essentially an
interface it allows you the developer to
create your own web component to connect
data from any service whether it's in
the cloud whether it's on the device and
surface that data in a way that your app
can use and the way app storage services
the data is in a very platform idiomatic
way that data is serviced just as a
property on the dom node and any changes
to that data are expressed as dom events
and conveniently that's exactly how
polymers own data binding system works
very much uses the platform owns what's
available there in the platform and so
app storage provides turnkey integration
with polymer zone data binding system so
let's give an example of how you might
use this say you're building a
notetaking progressive web app you're
gonna want to launch it from your home
screen because of course it's a
progressive web at you can add titles to
your notes you can add information and
details to your notes and all of this
data you're gonna store in a REST API
that you've built in the cloud but of
course it's a progressive web app so it
needs to be able to work offline so if
we go offline launchers from prior our
home screen if we're just relying on
getting the data from our REST API we're
not gonna be able to launch the data it
lost the application at all we're not
going to have access to the Internet to
launch that application but app storage
makes it very easy to architect your app
so that you can support this use case
very simply so here's how we're gonna
build it you're gonna build your own
component that implements this app
storage interface your cloud API
component and that's going to manage
communicating with your REST API in the
cloud and then you're going to use a
component app index DB mirror
we've provided as part of the app
storage components and what that does is
take any data that's passed through it
and it mirrors it into a local indexdb
instance and then that's going to pass
data into your app into your application
so here's how it looks when all the data
is wired up when you're online your
cloud API component has no problem
interfacing with your API with your REST
API it's gonna pipe that data through
this index DB mirror component which is
then gonna pipe the data to your app so
you're online all is well and good when
you go offline your cloud API component
can no longer communicate with its rest
endpoint but since we've been piping all
of that data through the app index DB
mirror component we have all of that
locally stored in an index TV instance
on our device and so we can boot up our
application even when we're offline but
what if you don't want to build your own
component what if you don't want to
build your own REST API to manage the
data what if you wanted to use say a
database as a service in the cloud well
fortunately there's an element for that
the app storage element with polymer
fire
so polymer fire is actually a set of
polymer based web components the
firebase team has built that makes it
trivial to communicate with a firebase
database instance and to use that data
in your application okay we're doing
great we can lay out our application we
can route between different views we can
localize those views we can communicate
with a back-end and store data but we
still need to deliver this application
to our users and remember this is the
mobile web flaky through G connections
of the norms slow devices of the norm we
need minimal payload we need minimal
JavaScript we need maximum efficiency to
be able to minimize the time to first
meaningful interaction for our users and
this is the great challenge how do you
minimize that time to first meaningful
interaction so there's the hard way we
can use the same old JavaScript escape
hatches we can build a massive tool
chain with heaps of JavaScript we can
server-side render we can get a fast
first paint with our server-side
rendered app and then download the meta
platform and then boot it up and then
make it interactive but it's frustrating
for a user to sit there watching a
splash screen and it's even more
frustrating as a developer to jump
through all these hoops to server-side
render so at the end of the day only
really have generated a splash screen or
a spinner and time to first flash screen
time to first spinner is not the same
thing as time to first meaningful
interaction so server-side rendering
like this to deliver an application
whether you get an app view or a spinner
is really a Potemkin village your user
still has to wait for your abstraction
to load before your application is
useful we think there is a better way
which is to use the platform to deliver
apps the tighter to the platform you can
build your application the faster it's
going to be especially on slow networks
and on slow devices let the browser be
your application and thanks to brand new
web platform primitives we can throw out
a lot of the old knowledge about how to
make an application fast on mobile and
embrace new primitives and technologies
that the browser provides so there are
really three important primitives for
delivering a modern mobile application
web components
which allow you to construct your
application out of these granular
dependencies out of these granular
components HTTP 2 and server push which
allows you to serve these granular
dependencies in a granular way to your
users without incurring massive round
trips and to most efficiently utilize
the bandwidth and then serviceworker
which lets you reliably cash these
granular components on your users device
so let's take a look at how these 3
primitives work together really nicely
so let's say we're building an app we've
built this app before we have three
routes slash slash items and slash cart
each has a view they share some similar
UI between the views if we built this
the old way as an old-school single page
app for each of these views no matter
what route the user hit we'd have this
monolithic index.html this monolithic
app just this monolithic framework and a
CSS file we'd send all of them down to
the client and then on the client the
framework would have to boot up then the
application would have to boot up then
it would have to match the route to the
view and then it would have to render
that view obviously very slow obviously
very inefficient but let's take a step
back we have three views here some are
independent some overlap in terms of
what they actually show on the screen
let's use the platform to serve this
application as efficiently as possible
so let's split the view down let's break
it down into individual web components
some of these components are going to be
shared between views some are going to
be unique to a particular view let's say
the user requests this slash route the
server can know exactly what components
are needed in order to render that view
and to make it usable on the device and
so the server can use HTTP 2 and server
push to push down exactly the minimal
dependencies the minimal components that
are needed to make that route to make
that view interactive without multiple
round trips and then we have that there
on a device that the user can start
interacting with with minimal overhead
and not only that we can take those
granular components and we can stick
them in the serviceworker cache and then
in the background as the user is
interacting with that first view the
serviceworker can start fetching
additional granular components from the
network and precache those it can get
those from the network and stick those
two in its serviceworker cache so that
if the user that navigates to the next
view slash items there's a good chance
that you'll already have every single
component that you need to render in
that view and make it interactive
already right there sitting in your
cache you don't have to go to the
network at all but of course it's not
practical to necessarily cache every
single dependency for your entire
application so for future views you can
lazily load and lazily instantiate
additional components that you need to
render those views and of course some of
those might already be sitting there
right in your cache and for those that
aren't you can use the server to push
down only the minimal set of
dependencies that the user doesn't
already have in their cache so there's a
pattern starting to emerge here you push
components that are needed for your
initial route you render that initial
route and make it interactive as soon as
possible you pre cache in the background
using serviceworker
additional components needed for
remaining routes and then you lazy load
and create future routes on demand as
the user navigates to them and we really
like acronyms on the polymer project so
we've been calling this the purple
pattern and the purple pattern is not
polymer specific it's just a pattern for
progressively loading and rendering a
modern progressive web app using these
new technologies and primitives in the
web platform so with the purple pattern
you get minimal payload minimal overhead
minimal time to first interaction and an
alt optimal user experience and the crux
of this purple pattern is the ability to
break up your application into
individual granular components that
require minimal overhead themselves to
boot up and that's exactly what web
components provides so now that we're
armed with the purple pattern and we've
built our app how do we apply it to our
own progressive web app that we're
building with the app toolbox now there
are a lot of different tools for
building and optimizing component based
applications and we wanted a maximally
simple tool to make it easy to get to
building application using this pattern
to develop and then ultimately to build
into play and so we built the polymer
CLI the polymer command-line tool and
the goal of the polymer CLI is to stay
focused and simple it provides just a
few set of commands that can help
support you throughout the entire
development experience whether you're
building a polymer component or whether
you're building an entire application
out of web components so this includes
polymer and knit which makes it really
easy to scaffold out an initial web
component or an entire application built
out of these web components and it'll
set up the folder structure that you
need for each of these two and we've
also built a set of starter templates to
get you started with different types of
applications that you might want to
build polymer serve will locally serve
your application or your component so
that you can play with it as you develop
and what's cool about polymer serve is
that not only will it serve your
component your application it will also
serve all of the documentation
automatically generated from all the
components that you're using to build
your application so you can develop and
on a second browser tab you can have all
the documentation for the components
you're using to develop so it's a really
great experience
polymer lint will lint your code and
check for common errors that occur when
you're building with web components in
polymer and then polymer build will let
us specify a main entry point and then
an application shell and it will
generate a bundled and unbundled version
of your application that you can then
serve the unbundled version is perfect
for serving with the purple pattern it
keeps those dependencies granular so
that you can use the purple pattern to
send them down efficiently but we also
generate a bundled version for a
fallback for browsers that don't yet
support HTTP two and polar build also
uses a tool called serviceworker
precache to generate these service
workers that do this pre catch
pre-caching prefetching and sticking
these components in the cache for you so
that if you don't want so you don't have
to write a line of serviceworker code
all of this is generated for you based
on your application
so that's the tool box layout routing
localization storage and a command line
tool to tie it all together and you
might be thinking didn't we just build
another stack didn't we just build
another monolithic stack but this stack
is different in fact it's not a stack at
all it is just a set of loosely coupled
interoperable web components that can be
used in piecemeal individually or
altogether and it's not a monolith and
each of these components is just a
lightweight layer on top of platform
primitives that already exist right
there in the browser so with the polymer
app toolbox we're showing that you don't
need a massive meta platform you don't
need a massive mega framework
you don't need an alternate platform to
build a high quality mobile web
application you don't need tons of
JavaScript you don't need a crazy
complex tool chain to serve it you just
need to use the platform and use all the
modern primitives that the web platform
provides now of course we didn't want
this to just be a theoretical exercise
so we built an app using all of these
techniques we call it shop it's an
e-commerce type application and it
doesn't actually sell Google gear so you
can't check out and buy anything's that
don't expect anything to show up at your
door but it's got all the views for a
typical ecommerce app it's got a main
splash pay homepage it's got a product
listing view it's got individual product
pages and it's got a cart and a checkout
flow and it's built and served using all
of these components using all these
patterns web components serviceworker
HTTP 2 in the purple pattern and it uses
polymer and the app elements and the
polymer CLI to develop and build so you
can check out this demo as well as
everything that's in the toolbox and
documentation about all the things that
are in the toolbox at the brand new
polymer documentation site WWL or
project org so in summary the polymer
projects approach to modern web
development is different it's different
than that of a typical JavaScript
framework because it uses the platform
it uses what's
ready they're in users browsers rather
than creating massive abstractions on
top and why is it important to use the
platform for performance on mobile and
thanks to these new powerful web
platform primitives this is finally
possible this is finally possible as web
developers to create these kinds of
engaging immersive app-like experiences
on the mobile web and so the result is
of using the platform is a first-class
progressive web app built out of
interoperable web components so if you'd
like to learn more about polymer or web
components or the purple pattern there
are tons more talks here at Google i/o
about exactly this progressive
performant polymer is right after this
one and there's another two more
tomorrow and if you have a time machine
or a YouTube you can check out the talks
that have already happened earlier so
I'm really excited by this I hope you
are too and if you'd like to learn more
about polymer about progressive web apps
about the purple pattern there's a
conference for that the next polymer
summit which will be later this year in
London so you can so you can sign up at
this link to be notified when
registration opens if it's anything like
last year's polymer summit that we held
in Amsterdam it's gonna be awesome there
were 800 developers in a beautiful venue
it was a full day of talks at night of
code labs and I'm really excited to do
it all again so that's all for today I
hope to see you at the polymer summit
and remember use the platform thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>