<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>To the Lighthouse (Progressive Web App Summit 2016) | Coder Coacher - Coaching Coders</title><meta content="To the Lighthouse (Progressive Web App Summit 2016) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>To the Lighthouse (Progressive Web App Summit 2016)</b></h2><h5 class="post__date">2016-06-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/LZjQ25NRV-E" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hey folks my name is jeff posnick and
i'm a member of the web developer
relations team at google so as you've
heard you go on a journey so everybody's
watching this either in person or
watching via the live stream we care
about building truly progressive web
apps and the thing is many of us have
put time and effort into our current
projects so building a progressive web
app doesn't mean starting from scratch
that as developers what we need is a
device and like areas for improvement
and different like tactical fixes that
we could apply to our existing code base
and and that spirit let's set sail on a
journey together and what we're going to
do is little by little we're going to
transition an existing single page web
app into a progressive web app all right
so this is our starting point we've got
this web app something I've put together
it uses the iFixit API to access repair
guides okay pretty straightforward the
initial implementation is a single page
web app that uses client-side rendering
okay and while this project uses react
the concepts we're going to talk about
really apply to any framework or vanilla
JavaScript it just so happens I was
using react for this project so let's
take a quick look at the initial
experience of running this in let's say
Firefox let me just confirm I have my
static dev server running right now go
up here what open okay see you some
repair guides click around a bit you
know it's it's all drinks from
client-side rendering it's you know
maybe not the fastest in the world but
it works you could view your content um
let's take a look at something else
let's take a look at what the experience
is
Safari and this happens to be safari
with javascript disabled some users have
javascript disabled some users are in
browsers that don't support JavaScript
you know this this is an issue and this
is what they say for a single page web
app not great and you know again this is
a function of being client-side rendered
and relying on JavaScript so let's see
what we could do now that we have a feel
for what the app does let's try to
figure out how we can improve on the
current implementation and what we're
gonna do is use that tool that Matt's
just talked about called lighthouse to
automate a whole suite of diagnostic
tests covering areas important for
progressive web apps so what we're doing
right now and our strong point is kind
of running it to establish a baseline
and it's gonna give us an idea of what's
working well and areas that we can
improve so we're gonna start the test
via a Chrome extension in this case but
you know as mentioned there's also this
command line tool that has the same
functionality if you prefer that when
the tests are actually really cool they
use the chrome debugging protocol and
they simulate a whole host of different
real world conditions to see how your
web app actually responds so let me pull
that up do this in Chrome Canary I am
kind of old school and just like doing
everything in incognito windows whenever
I'm working with anything so let's get
our own version loaded
let us ready to go over here quick
generate reporting you can actually see
it's doing its job it's using like the
dev tools ability to simulate this
viewport with some different things and
all sorts of other stuff and then get
our squash hopefully this is big enough
for folks to read um you know and we
have 30 out of 100 ok you know it's
giving us some nose here and it's giving
us some things that might be areas where
we can improve
serviceworkers not their meaningful pain
times not great you know we did have
this missing content and scripts weren't
available we have a bunch of other
things that we could improve so you know
the main thing is though we have a
really good starting point we know what
we need to focus on before we really
dive into the results and interpreting
them I just want to make this point that
lighthouse will help us identify areas
improvement but it's not our end
destination you know it's not the
ultimate source of truth as to whether
something is or is not a progressive web
app ultimately you know what matters is
the experience that your web app
provides to your entire user community
so in addition to running lighthouse
tests what we're gonna do is try web
apps across a wide range of browsers
operating systems and different network
conditions and you know I recommend that
everybody does that as part of their
normal testing and release process don't
just rely on lighthouse all right so we
have those results here are
opportunities for improvement you know
our speed scores could be better and
there's no content on our page from
javascript disabled and what we can do
for both of those is introduce
server-side rendering second it looks
like our web app lanoline so no surprise
we could add in a serviceworker
and you know finally there's missing
metadata about our application so as per
the lighthouse report and that could all
be addressed by adding in a web app
manifest and also adding in thoughtfully
chosen meta tags to accompany them so
we've got three concrete steps we can
take and we're gonna walk through them
each now using lighthouse and
cross-browser testing to measure how
effective our work is as we go
all right so let's first look into
server-side rendering with us what
that's all about you know what's going
to mean is that our browser gets a fully
populated functional page as part of the
initial a should be response rather than
relying on multiple requests to get
content on the screen and equally
important it means that our web app of
work and browsers in which Java Script
is unsupported or just switched off
entirely so not every web app is going
to be able to run with full fidelity
with javascript disabled but you know in
our case we should be fine it's a fairly
straightforward to add in server-side
rendering to our react application using
universal JavaScript and that means that
we get to share a lot of code between
the client and the server so not too
much work and we're gonna use Express
which is a node-based web server and it
plays really nicely with the react
router so while we're talking about
react now again other frameworks like
angular and ember have their own
solutions for server rendered JavaScript
so definitely check those out as well if
you happen to use those alright so let's
take a look at the actual changes that
we're gonna make in order to implement
that I happen to have a handy github
diff open so it's the real code and I
make this a little bit bigger so folks
you'd say and just scrolling up a bit
not too much that should surprise most
folks have done this sort of thing
before
you know we're adding in a serve task
that let's bring up our server and you
know scroll down a little bit this stuff
is important but we can't really focus
on it right now what I'm gonna scroll
down to is the part that actually
implements like our routing and figuring
out what to return so client and this is
very lightly adapted based on kind of
like the react router canonical example
so you know what we're gonna do is just
take our existing routes so we're using
on the client side and we're gonna match
against those with incoming request URL
on the server we have a few things to
handle different error conditions and
what we're then gonna do is just make
the request so the iFixit API
from the server it's gonna figure out
what data we need and the servers are
going to make those requests and provide
it to the client immediately without the
client have to having to get anything
else and we have a little bit of code
down here once all the data fetching is
complete we just have our initial
component that we're gonna then kind of
render to string using this react Dom
server helper method and we are going to
also take all that initial state that we
have on the server and turn it into
something and serialize that we could
end deserialize on the client and kind
of just have a nice experience where the
client takes over once that initial
payload comes down and finally just a
pretty straightforward index template
that just has placeholders for like a
state and for the reacts HTML that sort
of thing all right so that is what's
changed in the step and do all right so
we can actually now do is run that new
code and confirm make sure that our
changes have the effect that we wanted
in both and lighthouse and in actual
browsers all right so just switch back
over here and it's not really live
coding but it's kind of close so we're
gonna actually run our build process
again and get this guy that'll go and
our new server is going to start up and
this time we're going to be on ports
8080
once that's done all right
so okay let me just start this up yawn
and I'll test you in Firefox things look
good you know it behaves way we wanted
to behave that's great we didn't break
anything at least but let's actually go
to that Safari that has javascript
disabled still and see what the
experience is like there and we actually
have content this time so that's great
it's a net win for those users
if we click around a little bit and see
you know it's not the same smooth
transitions and other things you get if
you did have JavaScript enabled but you
know we're building application to view
this content and our users a subset of
our user population can now view it so
you know we should definitely consider
that win all right and let's also go and
rerun lighthouse should just close this
down start this up again
generated another report and you know
hopefully we'll actually be able to you
know assign a number and and measure
some of the impacts without that chain
hat change had and see their hard
lighthouse results okay so you know we
were at 30 out of 100 we're up to 44 out
of a hundred it's progress
and you know most importantly we see the
change is where we kind of expected to
like we have our page contains some
content when the scripts are not
available is now yes so that's a win you
know we actually also see an improvement
in the performance it's actually you
know the page load performance as fast
test is actually pretty significantly
better we were going from 2.4 seconds
down to you know 647 milliseconds for
the first meaningful paint so you know
server-side rendering was a win for that
so we're in the right direction that all
is cool all right so next up let's try
adding a serviceworker to address some
of the lighthouse feedback about speed
and offline functionality so first
important reminder I've heard a lot
today we need to treat service for her
as a progressive enhancement not all
browsers support service workers yet and
you know we want to be careful that we
don't do anything to degrade the
experience on browsers that don't
support it and it's also important to
keep in mind even in browsers that do
support service workers the very first
time the users visit your page the
service worker won't be installed yet so
having a good experience you know for
that case is super important all right
with that out of the way what we're
gonna do is use that half shell plus
dynamic content model that's been
mentioned a few times and you know this
is something that happens to work really
well with single page applications we're
starting with a single page application
it's kind of natural to adopt it in this
particular case and what it's gonna do
is take the shell which is all the local
HTML Javascript and CSS that we need to
render kind of like the outline of our
application and make sure that it gets
loaded directly from the cache whenever
possible and completely bypassing the
network
and taking the network out of the
critical path for getting things on the
screen is the surest way to get
consistent fast performance so that's
super important and we're next gonna do
is take a runtime caching strategy to
handle the requests for our dynamic
excuse me and dynamic content you know
in our case this is coming from the
iFixit API so it's gonna populate that
after the shell is loaded and under the
hood not surprisingly we're gonna use a
tool that matches talked about called
sw-precache and it's gonna generate our
serviceworker for us and it's gonna
implement all the caching strategies too
so you know not too much code that we
have to write it in this particular case
but what we really do have to do is
understand what our network traffic is
and understand you know what we're
actually requesting and you know this is
important because we have to actually
set up those routes and can't just put
an arbitrary URLs for that you need to
know what's going on you know I always
turn to the dev tools and chrome to do
this through other browsers that have
fantastic dev tools as well but let's
just go to Chrome for a second now yeah
we're gonna do this again in a fresh
incognito window let me open up dev
tools here make a little bit bigger
gonna network see what happens you know
I do this all the time this is just part
of it but when I'm approaching just a
new application new serviceworker you
really need to understand what's going
on you're in a network because you are
replacing this basically this is crucial
you have to make peace with this so you
can see some of the requests coming on
you know this is basically like our app
shell stuff this is our local CSS this
is our local HTML and then starts making
requests to you know in this case it's
stuff from cloud front node and the
images that are being displayed on the
screen and lots of images load in some
JavaScript and things like that and
let's click around a little bit you know
ends up happening not surprisingly is it
makes a request the iFixit API on the
client this time so you know the finish
I fix API request was made on the server
but now that subscribes taking over and
it's just making a request pulling that
information about that guide so you know
that's being pulled in more images
things like that okay kind of have a
feel for what's going on now so let's
take a look at how we actually
implemented the Service Worker in this
particular case so right I think this is
the appropriate if all right so this is
what's changed we're pulling in you know
that's our view free cash library and we
added a task to our build process you
know in this particular case we're using
gulp so using the syntax for that but
there are other ways of using
sw-precache folks you really like you
know NPM scripts you could put this all
as a command line or read an config via
Jason you know we're pretty agnostic
when it comes to that and there's some
boiler paper these kind of the
interesting bits for what we're doing
over here so first of all static file
globs this is a bunch of patterns that
match all the local static files and
these are the things that kind of get
requested as part of our app shell so we
just need to tell sw-precache where to
look and you know if we end up adding in
anything if we make any changes to our
JavaScript to be adding extra images
later on it'll just automatically be
picked up as part of the build process
which is great let's for us to worry
about next we have this dynamic URL to
dependencies section and this is this is
unfortunately a mystery to some folks
and definitely can do a better job of
explaining it so here's my attempt to do
a better job to explaining it you can
you could pretty easily figure out when
something that's just local on disk has
changed you know if you have an image if
you have CSS file that's in a local
directory you could just like calculate
the hash in figure out it's changed what
we're doing is you know taking these
dynamic URLs these are not things like
correspond to like actual HTML files on
disk and one example of that in this
case is slash show which is a URL we're
using
for our app shell and you know this is
effectively server rendered it's kind of
a composite of a bunch of different
things there's some JavaScript there's
some CSS there's the actual underlying
template for the overall structure and
all of those things go into uniquely
determining what the content is for
slash shell so in order to make sure
that we actually have a cache that's
automatically kept up to date for a
slash shell we need to tell a story free
cash
take a look at all these local files if
any of them change consider that this
slash shell cash content is basically
invalidated and refetch it and make sure
that we have the latest so you know
again if you're not doing stuff that has
like server-side rendering it's not as
important you can get away with not
doing it but it's actually a pretty good
solution for this pretty common use case
and very closely related to that is the
next section this kind of implements a
brute-force serviceworker routing it's
kind of like try so metric try some
morphic JavaScript sort of because we
have like the server that has to know
about routing we have the client that
has to know about routing and we also
have the Service Worker in this case a
hosta know about routing because you
know once you navigate to some random
URL with your initial navigation like
slash guide slash 1 2 3 4 5 or whatever
you know that's not a real URL that the
Service Worker knows about and we don't
want to just panic and give up and pass
on to the server we want to say hey
actually whenever you see something like
that which is a URL that you don't have
explicitly in the cache I would like you
to fall back to this cache content of
slash shell so it's basically doing real
you know brute-force routing we might
improve this in the future and have a
little bit more flexibility but for now
we're gonna route everything to show and
finally as mentioned previously you can
use sw-toolbox strategies for dynamic
caching within your sw-precache config
it just kind of saves having to maintain
things and to stuff
places and you know we went through the
process already of looking in the
network panel and dev tools we figured
out what our dynamic traffic is you know
we have these iFixit API requests that's
what they look like and let's use the
fastest handler which is basically still
while we validate for all those and for
the images let's do something little
different we're gonna use cache first
because chances are in image with the
same URL at this remote server is not
going to change it should be safe at
least for our case and we have the
dedicated cache we're using that max
entries there this is super important
you know it's something you can't
actually get just with the Service
Worker primitives right now we had to
build on top of those primitives and use
like indexdb to keep track of all the
entries in your serviceworker cache and
then allow you to you know expire the
ones once you reach that limit and
definitely think about it you know folks
don't have to use serviceworker toolbox
I'm gonna have to use free cache you can
definitely do vanilla serviceworkers if
you want but please keep this in mind
like if you are building something and
you're just caching things as you go you
really do need to think about your users
cache eventually filling up soon and
then we just have this defaults over
here of network first so you have a
little bit more poorly plate we add in
tasks and finally you know kind of
making sure that we're only attempting
to register our serviceworker if there
actually is serviceworker support okay
so that's what's changed and let's start
up modified version
that's step three now and as part of
this process you actually see that like
the Service Worker generation so
sw-precache will log a bunch of output
telling you what is caching and what
like the expected size of the precache
your initial payload is so see that
extra output over here and our server is
running again all right so we're gonna
just confirm that in chrome right now
you can remember see all this this was
the previous version especially stuff
from the network it's again kind of
close things out of it start fresh and
it was particularly case very first time
everything's still coming from the
network and you know this is because the
Service Worker is not in place yet so
that's expected and the next time though
that I end up reloading a page for
instance okay and we see our initial
stuff coming from the network we're
going to you know reload and now we see
what we expect so we actually see over
here from Service Worker so this is how
we could confirm just visually in in dev
tools that things are behaving as they
should all right our app shell is coming
from the Service Worker you could
actually see the fastest strategy in
practice over here where it's pulling in
an additional copy from the network in
addition to returning it from the cache
so you know you're making a network
request but most of the stuff is just
coming directly from the Service Worker
which is great and let's see how the
White House feels about that
so unfortunately kind of lost our
previous reports but I think we're at
like 44 out of 100 and hopefully we're a
little bit higher now
all right so we moved up a bit we're up
a fifty nine out of hundred so we are
making progress in the right direction
and you know again importantly the
things that we expect to have changed
actually did change confirming that you
know this is not all four knots we have
a registered service worker it responds
member offline and you know that all is
great also we try just tempting favorite
Chrome Canary I'm just gonna do the
offline over here and just again do an
application so it works okay if you
trust that that actually simulates
things being offline so okay definitely
making progress in the right direction
alright and finally let's address the
missing application metadata so these
are the options allow you to control how
your web app behaves when is added to a
mobile home screen primarily that's
mainly what they're used for and we'll
add the metadata in both the web app
manifest format and whenever possible
whenever it makes sense use equivalent
meta tags with the goal of supporting a
wide range of different browsers don't
just set this metadata and
discriminately though really you know
give some thought about each of the tags
don't just copy things that you saw in
an example you know some of them have
really important meetings like you know
whether you're gonna end up behaving
like a standalone application that hides
the browser's URL bar maybe that's not
appropriate for your particular case
that's fine you know as a developer you
get to make that decision and you could
do what you think is best for your users
that should be the ultimate goal all
right so let's take a look at what's
different we have our wonderful icon
that's been in we have our manifest I am
specifying icon this is a little
interesting I'm actually using that's a
UTM source equals home screen parameters
part of my start URL so if you had
Google Analytics running for your web
application you could actually keep
track of where it's been launched from
sw-precache actually
it was about these parameters and will
not cause you to have to cash like a
version that has slash of the version
that has slash UTM source he was home
screen it'll take care of that for you
which is nice and you know in our case
we're using display equal standalone and
here we have some later metadata we're
saying theme color setting your Apple
touch icon and we're setting this Apple
mobile web app capable content equals
yes tag and again not everybody needs to
use this exact saying all right so let's
take a look after making those changes
and see what effect they add we're gonna
run through the build process one last
time and you know what I'm actually
gonna do first is fire up iOS Safari
running in like the device emulator I
want to test what that experience is
like because you know we've added some
metadata that's relevant to mobile
safari let's see if it's actually doing
the only one I think I have it running
over here yeah local host 8080 we have
four basic about cool all right let's
see what happens when you try to have at
your home screen and a home screen all
right I mean it picked up our icon you
know in this particular case we're
adding to a home screen from the main
page so it's gonna use the main page as
the URL Paul Kinlan earlier talked about
some interesting ways of kind of
handling the case where a user might
have to home screen while you're on one
of the sub pages and redirecting to make
sure that it actually always takes them
back to the initial page when they do
launch that shortcut but for our
particular case pretty straightforward
you click on add we go over here scroll
over you know we have our web app saved
over there okay that's what we wants
let's take a look
hats again started fresh and cut you
know and let's take a look
this time at that if you new application
panel this all looks good you ever
metadata we'd see that sparse we'd see
like the actual theme color live so
everything seems pretty good let's see
if we have made Lighthouse happier with
us go through the report generation
process again and I think we were at
something like 60 out of 100 last time
something along those lines cool we're
up to 94 so yeah we went from fifty nine
out of a hundred and we had a bunch of
nose over here now we have some yeses
now so that's great so you know I think
that this process is definitely useful
as Matt mentioned previously as part of
like continuous integration in addition
to that process and you know making sure
that you didn't accidentally have some
regression that's causing like a really
big drop in your lighthouse score
you know that's super important just as
one additional check but okay so we're
getting to the end of this talk but as
developers our journey really is never
over you know new features like
constructible response streams that Jake
was talking about earlier for instance
as I rolled out more widely present
additional opportunities for enhancement
and you know I hope you'll be inspired
to follow my lead though and use
lighthouse to guide you towards the
ultimate destination and that's a
progressive web app that delights your
users you need to focus on your users
all right here's a few links I mean I'm
a little short on time definitely check
those out I'm gonna just highlight in
particularly progressive web app code
labs you could do them in person here
for folks who are watching this via
video you could go to that URL
definitely walk you through a lot of the
stuff that we talked about in this
session in a hands-on way all right
so thanks everybody please grab me
afterwards
on Twitter if you wanna chat more about
the progressive web app journey</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>