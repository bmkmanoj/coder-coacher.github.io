<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Making Chromestatus.com a Lightning-Fast PWA (Polymer Summit 2016) | Coder Coacher - Coaching Coders</title><meta content="Making Chromestatus.com a Lightning-Fast PWA (Polymer Summit 2016) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Making Chromestatus.com a Lightning-Fast PWA (Polymer Summit 2016)</b></h2><h5 class="post__date">2016-10-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Rd0plknSPYU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">today we're going to talk about Chrome
status which is the chrome team's
feature dashboard and how we made that
into a lightning-fast progressive web
app using polymer that's the official
title but this is the actual title it's
everything I've learned about building
apps in polymer in the last four years
in 30 minutes or less so there's a lot
of stuff a lot of stuff I've learned
about web components and polymer in
those last four years launching
Production apps really getting involved
with web components can't cover
everything today so feel free to hit me
up on Twitter this is me my name is Eric
bidelman I'm a developer advocate for
the chrome team I work with the polymer
team really excited about web components
I'm a digital jedi at Google which just
means i talked to developers around the
world and try to help them build modern
web apps during my time at Google I've
spent time just building stuff so on dev
rel we you know build samples we write
tutorials we help developers use the new
emerging technologies but every once in
a while will actually build real things
which is fun for us right we get to do
things you guys do out in the wild we
get to use open source technologies get
to use things like github gulp all this
really cool stuff so it keeps us up to
date we're sharp we can talk to
developers about this stuff but we also
open source all of these projects so you
guys can learn from them a couple of
cool examples here are html5 rocks which
is something my team put out just a long
time ago I don't know if html5 is really
a thing anymore but it's still around
you can go check it out polymers website
we built and that's gone through a
couple iterations as polymer is change
and web components have changed today
we're going to talk about chrome status
Santa tracker it's almost the holiday
season so we're starting up that project
again that's using polymer you can
follow Santa around the globe as he
delivers his little presents very cool
stuff for interactive good use of new
bond attack Google's code lab site is is
done in polymer and also the google i/o
web application the last couple years is
something we do in-house and it's a
progressive web app and using polymer a
lot of cool stuff so today i'm going to
talk about chrome status how many people
know what chrome status is or have ever
used it before nice not enough people
all right so good thing I'm up here
talking today about it so chrome status
is the chrome team's kind of dashboard
for what is
happening in chrome and in blink the
rendering engine so you can go in here
you can check it out it's basically the
list of features that have landed in
chrome that are going to land in chrome
things that we're thinking about
proposing and putting in chrome so if
you're ever a question of like what
landed in chrome 53 you can go to Chrome
status and find that information right
away we also have things like being able
to file bugs easy for each of the
features in the list you can drill into
features you can see what other browsers
think about a certain feature if they're
going to adopt it or implement it or not
and we had some other cool information
on this site that I'll talk about such
as samples and some other things so this
is using polymer it's using App Engine
and that's chrome status calm now it's
not just chrome that's in this browser
dashboard business anymore so we have
Firefox as a platform status page where
you can see what they're working on
WebKit has one of these on WebKit or you
can track what WebKit is landing and
things that they're thinking about and
ie has this too so Edge has a really
really comprehensive dashboard with
stats and other things you can check out
and so as a developer this is really
really awesome right you can go in you
can see for each of the different
browsers now exactly what they're
working on what they're thinking about
implementing what they're not going to
implement and so you can kind of hedge
your bets if you want to adopt a feature
or not so let's take a tour before we
dive into Chrome status I want to talk a
little bit about where this all started
all these dashboards that the browsers
are working on so this all started
really with the fork from WebKit when
blink when the chrome team decided hey
we think we can do a new rendering
engine and the web was like oh my gosh
there's a new rendering engine it's
going to be the 90s again chrome just
going to launch all these features
really quickly we're going to fragment
the web luckily that hasn't been the
case because blinks set out with a
really really awesome mission and the
bink the blink mission is to basically
improve the web to innovate on the web
as quickly as we can but also be good
citizens about him so we don't want to
just introduce features into chrome
without having some consequences or some
justification or going through the
standards process we don't want to be
that fragmented web that we came from so
in 2013 we launched an initial version
of chrome the chrome dashboard on chrome
status this is what it looked like it
was literally a single page application
in every sense of the word it was one
page but it was a start it was an iframe
to a Google spreadsheet and engineers
would go in and update the spreadsheet
add new features you know file bugs and
as a developer for the first time you
could kind of understand what chrome was
working on you could have complete
transparency into what we're going to
put in chrome what we had already put
into chrome so it sucked as far as
usability like gun it was an iframe you
couldn't really navigate this thing as a
massive spreadsheet with you know dozens
and dozens of features so that wasn't
good enough but it was a start right and
it was part of this being transparent
with the blink effort so I spent the
summer learning polymer and web
components and I think chrome status is
one of the first if not the first
production application using web
components and polymer and so that was
kind of my goal was to adopt and try
these new features and build this thing
out and so we did we spent some time
building it that was hard because the
specifications were changing so if
anybody's been around for a while and
I've done web components in the last
couple years you know that the api's
have changed and the now what we are is
in v1 where the browser's are actually
employing these newest standards but
bleeding on the edge was really tough
back in 2013 so just two examples here
in custom elements these names were
changing literally by the month so blink
engineers would implement api's the
standards bodies would bike shed the
heck out of it and then they would come
back and go back and forth back and
forth so it's really challenging early
on but we made it through it and in 2014
we launched chrome status again kind of
gave it a UI refresh you have this nice
list of infinite scroll features it used
polymer 0.5 it was a proper web
application with database integration on
App Engine chrome engineers could go in
they could add a feature that could edit
a feature we have folks from opera and
Microsoft contributing keeping its data
up-to-date it uses a you know it's a
fulcrum system so it's a great example
of a server-side rendered application
I'm kind of using old-school technology
and new school technology so if you want
to check up a source and learn how we
did it feel free to do that it's
responsive so it works on mobile you can
actually use the thing on your device
the really bad part about this early
version was that it was slow it was
really slow so we got feedback and we're
like oh my gosh like his web components
slow is polymer slow so we built the
same we really gave you like jazz up
about web components it turns out after
some investigation by the chrome team
we use chrome status as kind of a
vehicle a testbed to benchmark and to
optimize web components within blank and
chrome so there's a lot of low-hanging
fruit right these were new api's new
things that were added to the platform
it just hadn't been optimized yet so
there's a lot of cool stuff early on
that they basically just looked at
chrome status figured out why it was
slow and made blink and chrome better
one example is shadow Dom right the
browser doesn't have to do all this you
know style recalculation across the
entire page anymore it can actually do
less work since we have shadow DOM and
scope styles so we fix that in this bug
here another one was just sharing just
just being better at cashing things
across you know thousands of web
components you might as well share the
same style information across those
components and so just by doing that one
actually sped up chrome status quite a
bit and some other really interesting
ones you know if you dry if you
literally put an empty style tag on your
page it went through this crazy n
squared code path and blink and just
destroyed performance like just a blank
style tag that's fixed so you can do
that now but it wasn't at the time and
this wasn't particular to web components
either which is kind of something that
no one had never done I guess on the web
before or we didn't we didn't realize it
at the time so the blink engineers made
that better and there's some other good
ones on here insert before write a
really common Dom API that was
identified it's kind of slow we made it
twenty percent faster as part of this
investigation so blink got faster chrome
got faster because web components got
faster then polymer 1 point 0 came out
so I spent another summer rewriting the
app yet again so I wanted to use polymer
one point out it's faster it's slimmer
also all the cool material design
elements that the team had been working
on so that's kind of where we are today
in 2015 2016 using polymer one point oh
it got a little bit of you I refresh
it's a little bit easier to use across
mobile and desktop it's a full
progressive web app now which means
we're using serviceworker it works
offline and we spent a great deal of
time actually making it fast too so not
just for folks that have service worker
but our first render is really good
we're using things like HTTP to push and
preload to get some of that critical
stuff to the screen as quickly as we can
we also been doing work on samples so
chrome from the chrome dashboard is all
about features but you probably want to
know how to use those features so my
team
as part of kind of chrome releases we
implement new little juice on github you
can check them out all the source code
is up so you can learn about these
features and learn what's going on
something is kind of cool with chrome
status I want to highlight real quick
before we jump into the guts of it is
the metrics section a lot of people
don't know about this or don't really
understand where it's coming from
essentially we had the question of like
what features are being adopted on the
web and can we expose this information
to developers so they can understand
what features are being adopted on the
web so if you drill down into this usage
metrics button here on chrome status so
until you get this list right there's
their stack ranks of CSS features and
JavaScript features and HTML features
and we have timelines as well of the
different features and how they've been
adopted over time so this information
actually comes from chrome if you opt
into this setting basically chrome
reports crashes right if your browser
crashes we want to know about that to
make chrome better but it also reports
anonymous usage of CSS features HTML
features and JavaScript features on on
web pages and so we can gain some
insight into how these features of being
used across the web what happens when
you toggle the setting in chrome is
chrome starts logging information to
this crazy page called chrome histograms
and you can see this page is kind of
neat little ASCII graph with these
buckets on the left here 0 through 57
and you can see you know it's obviously
recording something but what is it
recording well it turns out if you dive
ended the chromium source you can see
the mapping between this bucket number
and the actual feature so number two
here in histograms XML is the CSS color
property so I can see that but you know
by know probably surprised that the CSS
color property is something that's use
across the web a lot so it makes sense
the fact that bar graph is a little bit
taller so we aggregate all this and we
expose it externally and publicly on
chrome status so you can see here that
if you look on chrome status that color
property is about sixty percent of the
pages that chrome loads use the CSS
color property so it's really cool you
can kind of gain insight into how
features are being adopted over time and
so we have metrics over time you can
track things like the fetch API so
really up and the right with this one
developers going crazy for it it's easy
to use
it's part of service worker it's got a
great polyfill story and so that's why I
think the adoption is up taking so well
CSS flexbox right it has gone through a
little bit of a shaky ground with
different changes in specs over the
years you can kind of see people get
excited about it drops down and comes
back up ultimately people are adopting
it about twenty percent of the web uses
CSS flexbox shadow Dom v0 is an
interesting one this is the kind of
shadow Dom as in Chrome today not the
new one that Apple and other folks are
implementing what happened at 2014 is
that polymer is 0.5 came out which use
native shadow Dom if the browser had it
so you see really good adoption around
Google i/o time people get super excited
about start using polymer and over time
as people migrated from 0.5 to one point
0 at one point 0 doesn't use native
shadow down by default you can see
native shadow DOM is kind of on the
decline a lot of people using polymer
and because they're not using the native
stuff anymore that's what's happening
recently the Chrome settings pages and
send some really large Google properties
have started using polymer 1 point 0 and
it opted in to native shadow Dom so you
see that usage go back up so one reason
we expose this information is part of
this mission which is to introduce new
features as quickly as we can but again
be good citizens about doing so so this
actually drives Chrome's deprecation
policy this information is this usage of
these different features drives our
decision to deprecate features in chrome
and so you can see I'm chrome status
there's actually some features that have
been deprecated because they've dropped
below a certain threshold of usage we
know they're not used on the web anymore
they're below a certain threshold so we
can safely remove them from chrome so
that's really awesome all right so let's
talk about Chrome status and how we
built some of this stuff so talk a
little bit about the architecture how we
kind of arrange things and built built
the site but also performance and I
think you really have to start with
performance because it really kind of
dictates the architecture of the site so
the most important thing for Chrome
status is how fast you go from this
white screen to this list of infinite
scrolled features that's I call that the
time to features that's the first
meaningful paint for chrome status so
for that we're using the purple pad and
you're going to literally hear the
purple purple said like a thousand times
at this conference this is my moment to
say it so it's pretty
load render sorry push render preload
and lazy load too many peas but
essentially it's be lazy do last load
fewer things up front when your page
first loads and so we're really taking
advantage of that on Chrome status to do
as little as possible when the user
first visits the site so let's take a
look at that our first paint on a brand
new user Nexus 5 chrome 3G connection is
about 1.9 seconds first paint which is
pretty good for that scenario and you
can see what happens over time is kind
of the app shell loads very quickly and
then the features eventually come in at
about 3.8 seconds so that's that time to
features that's when the feature list is
actually there and users can actually
use that page on that site so that's
pretty good but of course it gets even
better thanks to service worker and
having the ability to cache things
offline so the repeat view is 1.9
seconds first paint again but that time
to feature is the thing that actually
matters for chrome status is is dropped
by about eight hundred milliseconds so
we're pretty pretty excited about that
and that's again because of Service
Worker network is completely out of the
picture at that point they're just
loading things directly from the cache
as far as the architecture is concerned
for Chrome status we chose the app shell
model for us it made sense just to have
kind of the top nav and some of the the
UI their load right away for our first
paint and then as the dynamic content
comes in right from the database which
is that feature list that's how we load
that in and so we're leveraging things
like the h2 push server push and preload
some of the new protocols you can take
advantage of to get resources very
quickly to the user's machine I decided
to inline you know small amounts of
JavaScript and CSS because it really
didn't make sense to make those extra
requests it's a very small payload so we
just put those directly in the page
using server templates and then a sink
down the board so async loading
polyfills async loading you know imports
so we don't block the rendering of the
page async loading that features list
there's a lot of stuff we have to manage
asynchronously and that's basically just
using promises so big fan the promises
to manage all that asynchronous behavior
and then things like service worker gets
us a fast first paint the structure of
the app using this app shell model is
just using custom elements so it's using
a little bit
of polymers custom elements so the app
layout elements really awesome for
responsive design we basically get that
for free by using these elements and we
basically use server templating right
good old-fashioned Django Python woohoo
that gets injected inside of the light
dom of these elements and you basically
have a server-side rendered app nothing
really fancy here just kind of
interesting that you're combining these
two worlds now we also hand-rolled a
couple of our own elements for certain
things right one offs that we needed
things like this this list of features
are sorry this list of chrome versions
is chrome metadata tag it just fetches
the list of chrome versions from it from
a database and renders that in our app
drawer and the bread and butter of
course is this this infinite scroll list
of features where you can drill in it
can kind of discover more about what's
landing in chrome and for that we're
using the iron list element so this is
really awesome performance tool that we
found we have a list of features so it
made sense to have an iron list of
features that was essentially a an
infinite scroll lists right it manages
this Dom for us we don't have to worry
about features being added over time and
we're just generating massive amounts of
Dom because it only renders what we need
so that was really effective to reduce
some of the load time on chrome status
I'll show you how much to before we
introduced iron list into this features
we're basically just server-side
rendering you know crap ton of features
4,400 elements in the Dom on page load
which is way too much way too much like
modern apps use like less than a
thousand gmail inbox all of these that
was about 1.2 seconds so way too slow
for an experience like this when we
introduced iron list drop this down to
about fifty three elements on page the
super good and then of course the blow
time dropped dramatically as well so
check out iron less if you have anything
like a grid or a list for your page it
works really well this year we spent a
lot of time making a progressive web app
so all of the usual suspects apply here
we have add to home screen experience a
splash screen you can see what's
happening in the video here we spend a
great deal of time making offline work
really well so we're using the
serviceworker precash and toolbox
libraries for that so we don't have to
deal with some of the craziness that
service worker has lighthouse which is
an awesome tool for kind of gauging how
your app is a progressive web app we get
about a 95
lighthouse check that out it's a CLI
tool but it's also a Chrome extension
and it kind of goes through the list of
things you need to do offline is kind of
interesting for Chrome status we're
doing something that's a little bit
different for for the UX we do have a
service worker which I'm not really
going to go through but the cool thing
that we're doing is actually showing
users how much data were pre cashing in
the service worker so essentially what
we do is we wait for this this promise
to resolve this loads are imports since
we have h synchronous lope imports we
want to know what is resolved and loaded
and then we can use our custom elements
at that point after that we get the list
of things we've cashed in the cache API
and essentially calculate how much we've
cashed and then we present this little
toast message which is a custom element
that shows hey this site's going to work
offline it's ready to use its using
servers worker and we've cashed about
eight hundred kilobytes of data so
oftentimes people say like how much data
should we cash in service worker you
know how much is too much and so one
thing we're experiment with here is just
showing and being upfront with that and
we can track this overtime right we can
decide hey maybe if it gets to a
megabyte later that's too much stuff
we're pre caching our app is growing too
big let's kind of whittle it down so
being transparent about what you're
doing with offline so that's some stuff
that's interesting for Chrome status in
particular to Chrome status for the last
couple minutes here I want to talk about
just generally good things you should be
doing in all of your polymer apps and
just generally good web stuff things you
might often forget to do the first is to
lazy load right this is part of the
purple pattern be lazy load less up
front that goes with the polyfills as
well probably full official life someday
we won't have polyfills because the
browser is right now implementing api's
but until we do we can lazy load them
and do use proper feature detection
right just as you would any other
polyfill and this this applies to the
web components api's as well so in
chrome status I wrote a method called
lazy load web component polyfills if
necessary that's literally the method
call it's very descriptive but you know
exactly what it does and we feature
detect the v0 web component AP is using
this little script here and then of
course just dynamically load the script
tag if the browser needs it or not so we
can save network requests in browsers
like chrome or any browsers that have
these ap is
number two is opt in to some of polymers
performance flags so FYI btdubs this is
polymer one point out this is not to
point out the new hotness so two point
oh actually you don't need any of this
it's on by default but these are one
point of flags that you can opt into so
the first thing you do is basically set
up this object before polymer loads okay
and you construct a kind of an object
and you can specify certain performance
flags one of those is to use native
shadow done right if you're in a browser
that has native shadow Dom you should
opt into that you get the benefits of
style scoping you get the performance
optimizations I talked about the blink
made to the native API s and so you can
leverage that by using the Dom shadow
flag lazy load max basically what this
does is it tells polymer to delay some
of the work it has to do when your page
loads and delay that until an instance
of your component is created so instead
of doing all this kind of fix up work
and shimming styles and mimicking shadow
Dom at page load time it waits it rates
to run that stuff when an actual
instance of your component is stamped so
it's another good optimization for good
fast page load the last one here is to
use native properties right I think all
the modern browsers now at least the
latest versions have CSS custom
properties so you might as well opt in
to those and get the benefits of the
native CSS engine instead of using
javascript to parse stuff last pro tip
always if you can use asynchronous
imports this won't block the rendering
of your page it records a little mill
work on the behalf of the developer to
know when things are loaded but
ultimately your users are going to be
happy with you because you're not having
that white screen of death for for so
long number three avoid web fonts so i
did a side-by-side comparison for chrome
status we were using Roboto and then you
do a side-by-side comparison with just
the native installed api font on the
system you really can't tell the
difference right and so I said well
let's just remove Roboto all togethers
no point to make requests for Roboto
waste bandwidth and also have to deal
with things like flash of unstyled
content might as well just show the user
the native stuff so it got a lot faster
just because of that so use those
sparingly if you can number four is to
leverage things like h2 server push and
link rel preload so there's a couple
ways you can do this the first is to be
declarative
can declare a link preload in your page
and that tells the browser hey I'm going
to need this resource eventually you
might as well just go fetch it and so
that's a high priority resource that the
browser will download you'll stick it in
the cache and then when the browser
actually needs import data HTML it'll
use it from the cash what I recommend
though is using the HTTP header that
will actually get sent with the page
itself so you kind of bootstrapping the
browser's cache ahead of time before the
page ever gets downloaded and so it's a
little bit faster than telling it hey
download the page and then look for this
preload link and you can also create it
in JavaScript right if you want to lazy
load things after the fact you can do
that just create a link tag set the rel
to preload and then append that to the
page so there's a couple different ways
you can take advantage of this new stuff
so I got so excited about push last fall
that I want to make it really easy to do
an app engine because ultimately chrome
status is on App Engine so I wanted to
make easier not only myself because I'm
selfish but I want to make easier for
you guys too so I wrote a couple of
things and hopefully you'll find them
useful the first is this manifest
generator it's a little notes script
that you could run against your app and
what it does is it finds the static
resources on your page so it outputs
this little JSON blob and in this case
it found a CSS file a JavaScript file
and my HTML import and so it outputs
this JSON and then you combine this with
another library for App Engine so you
just decorate your handlers and
reference this JSON file and what this
is going to do is it going to server
push all the resources in that JSON blob
with your handler this is really awesome
because you can basically don't have to
know how to construct the link cutter
you have to worry about that you just
run these two scripts and you get h to
push for free on App Engine very cool
number five is make a custom icon set so
polymer has all of these material design
icons you probably familiar with iron
icon and using them and they're based
their kind of grouped in different
collections and so what I did for chrome
status was kind of decided hey I don't
need all of these icons I just need a
few right anyone from this icon set one
from this other one and so I create this
tool you can go to poly icon appspot com
and essentially it just allows you to
create a custom icon set for your app
can pick and choose the icons you need
it
puts the HTML cut and paste it in a file
and boom you've got a custom icon site
with only the icons that you need in
your app so this is good I saved about
one or two hundred kilobytes just of SVG
download in my app just creating custom
icon set so prune your icons download
less again be lazy load let's stuff
number six is lazy load non critical
components now I'm not going to talk
about the mechanics of how would you
this Steve the next presenter is going
to but i want to show you how we're kind
of leveraging it in a real app on chrome
status so this usage metrics button here
is actually a web component and when the
user clicks it for the first time that's
when we actually load the import for
these web components inside of it so you
can see what happens in the network tab
that's when the paper menu a vulcanized
bundle and javascript file come down
second time the user clicks it's
basically a no op because the browser's
already you know downloaded it's already
in the cache and so at that point we can
just show the drop down immediately so
this is a great way to kind of load less
up front in your app and lazy load
things as users interact with your app
the same is true for this little ? here
which brings up this help screen that's
just lazy loaded as well using the same
technique number seven and the last one
is measure measure measure measure
measure measure so i spent a great deal
of time just you know either bring a
chrome status making it better making it
faster but ultimately you push new
versions right and the app changes the
profile the app changes you continuously
have to kind of know what's going on in
your app so if you want i rolled a
little library to make my life easier in
chrome status and hopefully you'll find
this easy as well it's called at metrics
j/s it's a small little library you can
use to basically wraps the user timing
API and so if you want to know how fast
for example a JSON file takes to load
you can create a new metric call it
features loaded call start to start the
recording call end and log and you can
log that information to the console to
continuously see the stuff as you
iterate in your app what's cool about
this though is that since it uses the
user timing API that API integrates
directly with the dev tools so if you do
a recording you can actually see you
know features loaded my two metrics here
in this app and you can see how they
kind of stack up with the rest of the
iming in my app so this is really nice
the fact that I API you can visually see
it amongst the things into devtools is
really really valuable and this also
works with webpagetest so anything that
you mark on the timeline using the user
timing API or using app metrics jas will
get marked in webpagetest you can share
that link and also track this stuff over
time so we were already using google
analytics on crump status know what
users are doing so I also just threw in
this API call to track performance over
time so if you use this library you call
this call you're using analytics you can
end up tracking performance in your app
over time there's really no point to
roll your own dashboard or set up
anything like date queries or anything
like that analytics has all that for you
if you just use the user timing API and
call the raw analects protocol or use at
metrics and so you can see here that the
load event for that features is kind of
slipped over time definitely need to do
some work after the show so with that
that is my time again my name is Eric
bidelman it's a tea bitel and now I
believe I'm going to turn it over to
Steve here's the list of resources if
you want to take a screenshot of that
before he comes up and all the libraries
and stuff I talked about and thanks
thanks London and live stream thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>