<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>End-to-End Polymer Apps with the Modern Web Platform (Chrome Dev Summit 2017) | Coder Coacher - Coaching Coders</title><meta content="End-to-End Polymer Apps with the Modern Web Platform (Chrome Dev Summit 2017) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>End-to-End Polymer Apps with the Modern Web Platform (Chrome Dev Summit 2017)</b></h2><h5 class="post__date">2017-10-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Wu2GCRkDecI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name's Taylor savage and I'm a
product manager on Chrome's developer
experience team which encompasses the
many different open-source web developer
products that we build here on Chrome so
I'll be talking today primarily about
one product in particular which is the
polymer project and about how the
developer experience team has been
thinking about leveraging all the
different features you're hearing about
on the modern web platform in order to
build fully end-to-end applications but
like a typical product manager I kind of
want to start today by taking a step
back taking a 10,000 foot view about why
we build developer facing tools and
products and libraries in the first
place on Chrome and the role that we see
our products playing in the broader web
development ecosystem so our biggest
product that we build on the chrome team
is as you might guess chrome the browser
and our focus on building on when
building chrome the browser has provide
the absolute best user experience
possible and so we've built many many
features within Chrome to make this
happen
things like chrome sync an autofill tons
of security work countless optimizations
to make page loading faster and more
efficient that you've heard about in the
last two days things that you're at
we're talking about it at chrome dev
summit but at the end of the day a
browser is really only as useful as what
exists on the web to browse so we don't
really make Chrome great you really make
Chrome grade as web developers with all
the things that you build so chrome is
just a window onto that it's on to the
applications and web sites that you
create so the quality of the user
experience on chrome the browser product
is very fundamentally tied to the
quality of the sites that get put on the
web it's on the chrome team in addition
to building chrome the browser we're
looking for opportunities to also build
products that help you web developers
create and distribute really high
quality sites and the trick though for
our team is to figure out where our
effort is best applied for maximal
leverage because as everybody here is
very well aware the open source web
developer ecosystem on its own is an
amazing massive place they really need
us your products for web developers are
coming out every single day are being
built and being open sourced there's
certainly no lack
innovation and innovation there's
certainly no lack of diversity in terms
of the tools that are available for us
to use today's open source web
development world though is subject to a
dominating force which I affectionately
like to call the JavaScript industrial
complex and this is the positive
feedback loop between all the different
types of players in our ecosystem the
open source project themselves tooling
that's adjacent to these projects
content creators who write blog posts
who tweet on social networks conferences
trainings that people pay for to learn
more about these tools all these
different aspects are all really
critical to generate all the projects
and documentation and education and
support that we rely on every day to do
our job but the dynamics of this
JavaScript industrial complex will
sometimes reward shorter term optimal
solutions at the expense of what might
be optimal in the slightly longer term
now we all want to build tools that and
we only use tools that solve problems
that we're hitting right this instant on
the web platform and so it's these sorts
of tools that solve our problems today
that tend to benefit the most from the
system as you'd expect now fortunately
the web has been designed to be an
incredibly flexible platform and so many
of the problems in web development that
we hit can totally be papered over in
the short term with tools but
unfortunately with the continual
application of these tools we risk one
adding a ton of extra complexity to our
workflows and to ultimately ossifying
ourselves at sort of a local maximum we
all know that getting stuck sort of
micro optimizing at a local maximum is a
sure path to obsolescence so on the
developer experience team on chrome we
try to focus specifically on solving the
problems that we have a unique
opportunity to solve so one big unique
angle that we have is our proximity to
chrome the product so you have
particular expertise when it comes to
how the browser works for example we
have ability to try to influence the
overall web platform and so we look for
gaps in the ecosystem where our
particular contexts and skill set will
be particularly valuable so we work on
products like chrome dev tools which we
can bundle directly with chrome itself
which would communicate with chroma to
very low level I'll help you inspect and
debug your website we build things like
lighthouse which can seamlessly and
deeply integrate with the dev tools
protocol to express our particular
vision of what makes a good fast
high-quality site and help you
your own site against that bar but
another unique position that we have on
the chrome team that helps inform what
developer products we want to focus our
time on is our inherently long-term view
so the web has a very long time horizon
and we here on the chrome team are
fundamentally tied to that long time
horizon we're in a very fortunate
position in that sense and that we're
very deeply committed to the very
long-term health of the web so we on
Chrome chrome is gonna be here a long
time and we can't really afford to get
caught up in short term hot trends
because we're playing a very very very
long game and often what this means is
that the best investment that we can
make on the developer experience team on
Chrome is an investment in improving the
underlying web platform itself
so now here's the rub with that strategy
which is the web platform moves
extremely deliberately it takes years
for a new feature in the web platform to
get designed agreed to ship cross
browser and they're hugely there's a
huge cost also to taking features out of
the web platform if it's even possible
to do so we have to be extremely careful
and thoughtful and deliberate when
considering what new features we can add
to this platform the road to changing
the web platform is a very long one
you've got to get a spec written and
then get it generally agreed to across
the different browser vendors and you've
got to implement it in a browser and
then you've got to ship it in that
browser and then you've got to
inevitably fix the bugs that come up
after you shipped it because you've
broken it and it's not useful yet and
then you've gotta wait until it's in
enough browsers shipped and available
for developers to use that the developer
ecosystem will actually start taking
advantage of it so for a fundamentally
new feature of fundamental change to the
web platform itself to get baked in it
requires a dedicated group of people
fighting for that feature in it for they
very very long haul four years maybe
even a decade and so we dedicate a part
of our Chrome web platform team to fight
specifically this fight to analyze the
ecosystem and then work with other
browser vendors to come up with new
features that plugs holes in the
platform and then fight in the trenches
for the years to actually see these
these new features come to life so this
is where web components and the polymer
project come in so we noticed a few
years back that web development was
getting more and more complex that the
ecosystem was getting increasingly
siloed and locked into
frameworks many of which at their core
we're solving fundamentally the same
problem which was providing a same
component model on top of the web
platform and again the lack of a sane
web native component model is exactly
the kind of problem that can totally be
solved in the short term with tools but
in the long term will only really be
able to drive towards simplicity with a
fundamental change to the platform and
so we set out to create web components
now a long story short long story short
after many years web development
standard the web component standards
have finally crossed a major finish line
web components have been natively
supported in Safari and chrome for a
while now meaning that there are over a
billion mobile devices out there right
now in users pockets that have native
support for web components so web
components are a reality of today's web
platform and we're starting to see the
ecosystem adapt to these new powerful
web platform features we're starting to
get to that kind of last phase of the
component flowchart new new development
frameworks like ionic stencil j/s have
really exploded onto the scene based
entirely around web components other
frameworks like glimmer and Spell allow
you to output components as web
components and existing frameworks like
angular and view and pre-act now provide
first-class support for web components
so you can check out custom elements
everywhere to see the latest progress on
first-class framework support for web
components and web components usage in
the wild is actually really taking off
kind of under the radar but it's really
taking off so we just had a fun
realization on the team the other day
after seeing another team at another
massive company tweet about one of their
web components based launches which is
if you go and if you look up the top 16
global brands in the world so that 16
most recognizable companies in the world
nine of those companies over half of
those companies have a product that is
using web components in production and
many of which are using polymer so what
components might not be like instant
hacker news to the top gold yet but the
adoption is very very real in fact if I
were starting a company that was trying
to make money on web development I would
absolutely pick web components as my
technology so on the polymer project
we're continually trying to evolve the
polymer library as these web component
standards evolve and reach different
and maturity to make it as easy as
possible for the standards to cross the
finish line and also for developers to
take advantage of web components in
production earlier this year we held our
third annual polymer summit in
Copenhagen where we heard from 25
different speakers about the state of
polymer and also innovations more
generally in the web component ecosystem
so we heard from major companies like
USA Today and a lot of Electronic Arts
who are using polymer to be able to
quickly spin up new pages and websites
with a consistent design language and
with minimal extra engineering effort
and we also gave a sneak preview of the
forthcoming next major version of the
polymer library which is polymer 3m so
polymer has always been about making it
easier to build web components and
specifically making it easier to build
web components being as close to the
platform as possible and so polymer 3
ATO is a small very small evolution of
the library to come even closer to
realizing this ultimate goal there are
two major changes to polymer with
polymer 3 dough the first is will be
moving from bower to NPM in order to
distribute polymer and elements built
using the polymer library and the second
is will be switching from HTML imports
to es modules in order to load polymer
and polymer based elements so the
reasoning behind these two changes is
fairly straightforward as everyone seems
to intuitively get although major other
other browser vendors have agreed to and
shipped custom elements chato and we're
already seeing those worded in the wild
we haven't been able to reach consensus
around HTML imports and today's close to
the platform way to load code is via yes
modules so on the polymer project we're
going to follow our own model we're
gonna use our own motto we're gonna use
the platform and move to using yes
modules in order to load polymer and
there's some really really big exciting
advantages with this switch for one
polymer will become much more compatible
with the workflow and tools and other
libraries that JavaScript developers are
already familiar with and polymer
elements and applications will also be
able to run without any polyfills at all
on Chrome Opera and Safari and when edge
and Firefox chip custom elements in
shadow Dom Polamalu polymer will run
completely polyfill free on those
browsers as well and on the polymer
project we also really really care about
making it
transitions between versions the library
as easy as possible as you've seen we've
had some really really big users inside
Google and outside Google who have
thousands of elements that can't do a
major one-off transition and so we're
working on building an auto upgrader
tool that will mechanically and
automatically up create your two data
elements and even back to one auto
hybrid mode if you're familiar with that
to polymer 3.0 so it'll be an automatic
transition it even upgrades your tests
for you so you can learn much more about
polymer 3 at OU by checking out polymer
project org and the blog for updates
we're still working on a bunch of
tooling and support for three deado and
we expect to have a stable release
sometime early next year so keep an eye
out for that
so three ATO polymer is really the
culmination of what we've been trying to
do on the polymer project make it
possible to build platform native
components as close to the web platform
itself and we really think that the web
component technologies are a
transformative changed the way that the
web platform works but components are
really only half the ballgame it should
also be trivially easy to take these
components and assemble full-fledged and
to end applications and when it comes to
today's organ AMA Courvoisier web
components into apps we tend to agree
with Sam here we think there is a lot
left to do in terms of improving the
developer experience of building and to
end applications taking advantage of web
components and we also think there are
some really interesting opportunities to
take some other cutting-edge changes to
the web platform along with web
components marry them together and be
able to build really blazing fast and to
end apps that you can deliver to users
on mobile seamlessly and quickly so I
don't have a product per se to announce
today but I do want to take the second
half of this talk to kind of throw out
some of the key ideas that we've been
kicking around on the developer
experience team for the shape of what an
app building solution might look like
so Kevin Shaw an engineer on the polymer
team went into detail of many of these
ideas at his talk at the recent Palmer
summit so I encourage you to check that
out if you're looking to dive in a
little more so really there are four
main problems that we are thinking about
when it comes to going from web
components to entire applications the
first is how to structure your
application for maximum performance how
to factor your UI appropriately
how to manage state within your app and
then how to actually serve your
application in production so we'll dive
into each of these and see how we're
thinking about kind of marrying a bunch
of the web platform features into doing
these each of these steps of building an
application really effectively
so first structuring preferred
performance the number one way to make
sure that your application misses its
performance targets is to start thinking
about performance after you've already
finished building your app and I think
we've hammered this concept home quite a
bit at this chrome dev summit so there's
one overarching principle when it comes
to structuring your web app for
performance which we find consistently
invaluable
which is to minimize overhead every
single bite of your web app as you've
heard again and again has to go through
this epic journey before it finally gets
rendered on a user's mobile device every
byte runs into so many opportunities for
bottlenecks flaky networks slow devices
the only guaranteed way to achieve good
performance on mobile is to do less and
unfortunately what we see again and
again is an attempt to improve
performance by doing more so a lot of
the front of world today is enamored by
the concept of server-side rendering as
a means specifically to good performance
where we send down server rendered
static HTML to get the Year Y on screen
while the user is waiting for the rest
of the app bundle to download but unless
your application is mostly just static
kind of passive content what the user
actually wants to do is interact with
your app they want to select a departure
date or sign up for a newsletter or
bookmark a house and server-side
rendering doesn't really help with any
of this interactivity it just gives them
something to look at while the rest of
their code loads so they can actually do
what they'd come to your app or your
website to do so if you still have to
send this large bundle of JavaScript
down to transform that initial rendering
into something that's interactive the
user is still going to be frustrated and
if you don't believe me here a couple of
real life examples of how popular
server-side rendering applications
perform on relatively slow 3G networks
as you can see server-side render the
initial view really really quickly but
the problem is on a slow Network it can
take a really long time for the
JavaScript to load and that leaves the
user looking at a screen that looks like
they can interact with it but this can
be an incredibly frustrating experience
so I want to I want to make the point
that this is not to say that server-side
rendering is wrong absolutely not it can
certainly improve the user experience by
getting pixels on screen quickly
definitely a good thing to do rather it
just says that there are no
shortcuts to delivering a good user
experience we need to focus on the right
metrics from the beginning and so we
think on the developer experience team
here that for a lot of apps the right
metric should not be first paint but
rather time to interactive and the best
way to ensure a good time to interactive
is this don't make the user wait on
anything that they haven't asked for so
what this means is only send exactly the
code that a particular route requires in
as few round trips as possible sending
as little duplicate information as
possible and this sounds easy enough it
sounds fairly intuitive but in practice
this has historically been very
difficult given the bias of existing
front-end tooling so this is why we've
developed in a spent so much time
evangelizing the purple pattern which
gives a straightforward pattern for
factoring an application for optimal
delivery
so with Purple's start by factoring code
around decoupled routes that fit
together into an interactive experience
use server logic to push down only the
components or the data that a given
route needs and eliminate round trips we
render and make that initial route
interactive as quickly as possible we
use serviceworker to pre cache the next
parts of the app in the background and
then we lazily import this pre cached
code it's needed for subsequent routes
from the serviceworker cache so we
summarized this pattern as purple push
render precache lazy import so purple
gives us a really nice pattern to ensure
we're giving the user exactly what they
need for a particular route and no more
but to ensure we're delivering the
ultimate best user experience we can we
want to measure iteratively as we
develop and so we recommend using web
page test for this web page test
recently introduced a new easy mode that
you can go to that's pre-configured for
testing on mobile devices and on 3G
networks so make sure that you've
enabled lighthouse on webpagetest.org
slash easy and then just enter the URL
that you want to test and click start
test and once testing is finished you
can click this lighthouse score button
here and then under performance you can
see this time - interactive number and
this is the number that we want to
optimize so there's a lot of different
advice out there for what to target for
time to interactive and what we like to
say on the chrome team and I think
you've heard in a few talks at this
conference we talked about aiming for 5
seconds for time - interactive
we think this is generally a really
strong target for a good solid user
experience we think though that the
absolute highest quality sites can do
even better down to 3.5 seconds to
interactive and this is the target that
we'd shoot for on the products that
we're building on develop experience
teens specifically so we can leave as
much Headroom as possible for you the
developer to build sort of more complex
apps and still get a really really fast
time to interactive so on these settings
first bite from a good edge caching
server after SSL negotiation will be
around two seconds so this leaves us
with about a second and a half to get
the routes payload downloaded rendered
and ready for the user to interact with
and we found that this translates to
roughly 50 kilobytes of code and data
that you can send for the initial
critical section of your route so now
polymer 2.0 starts at around 12 kg zips
leaving you with roughly 40k of budget
for the critical components that you
need for each route and we found the
best way to kind of get these
recommendations across in the best way
for us to internalize them as a team is
to give them a name and so we're calling
this one purple 50 so for building fast
apps on the modern web you get a really
big head start when relying on web
components for your component model
because you don't have to download any
extra code to provide that component
model it's already baked in there with
the browser we also think that any
modern app building framework should do
everything possible to help developers
stay underneath this purple 50 rule for
any particular route in their
application so that's how we are
thinking about structuring performance
for performance by minimizing the amount
of code that has to run for any
particular view the next step in
building an app will be to factor your
UI and actually assemble these different
views into a full-fledged application so
again web components really really
helped us here so we'll want to leverage
reusable components wherever possible
because the best line of code is the one
that you didn't have to write so just
like NPM is the go-to source for
JavaScript libraries web components org
is your go-to source for reusable web
components so for a lot of our app UI we
can stand on the shoulders of giants in
the community and stop reinventing the
wheel and just use web components that
others have already created for us now
we talked a lot about when about when
we're talking about web components about
so
leaf node elements in terms of the sorts
of UI widgets like buttons and dropdowns
and sliders that the user directly
interacts with and are sort of the
lowest the lowest nodes on your tree but
we also think that web components can be
hugely valuable for sort of app level
structure and organization as well using
the standard web component model for app
components in your app can have a lot of
different benefits so we can achieve a
smaller payload and get to that purple
50 number by using built in browser
features rather than having to kind of
download our own extra code on top we
can get strong encapsulation for free
which is hugely useful when scaling up
to a large team while working on the
same codebase
we get great built-in developer tools
support for web components via Chrome's
dev tools and most importantly we get
the full flexibility in terms of being
able to reuse our structural components
so as long as you're using custom
elements and properties and events as
your component interface and as long as
you're using shadow Dom to encapsulate
the rendering of the component how a
component does its rendering is totally
just an implementation detail so with a
web component you can extend from
whatever web component base class you
like without losing interoperability how
the component actually works is an
implantation detail it's a dependencies
are an implementation detail so this
inverts the traditional model that we're
used to when building web applications
we can build for example an entire
application out of polymer elements but
that's just one choice down the line you
could switch some of your components
over to using a much simpler element
based class for example than what
polymer provides and those can work side
by side in your application with polymer
elements one at a time we can try out
using sketch es in our application
without changing any other part of our
app and someone is bound in the future
to make an even better web component
based class and we can introduce
improvements to our app incrementally
without throwing the whole thing away
each time so think about that if you
wanted to change an app from one
framework to another there's no
incremental path to make a change like
that yet this is entirely possible when
we're using a standard component model
so this is one of the very real benefits
of web components even for app level
views we can dramatically lower
switching costs for us without
sacrificing our ability to innovate and
change incrementally over time we don't
lock ourselves in at all when we're
assembling our application so now that
we've built our UI we need to bring our
application to life by loading it with
data and dealing with user interactions
that will change that data so
applications state management is perhaps
an area of web app development where the
platform sort of has the least to say
and so we get a lot of questions about
how we do a managing state on the
polymer project so two years ago at our
first polymer summit
Kevin gave a talk called thinking in
polymer that put forth the concept of
the mediator pattern for how we think
about coordinating state changes between
web components so in short a mediator in
the mediator pattern owns a scope of
other components and is responsible for
propagating data to those components
listening to events from those
components mutating state and
propagating changes to that state back
down to components in its scope but also
up via events to any owner of this
particular component and the meteor
pattern is really useful creep for
creating reusable standalone elements
that can handle their own complex state
changes internally but also communicate
those state changes externally to anyone
that might be interested and this sort
of stand-alone state management ensures
that reusable web components are easily
portable between any application top
context and work just like any other Dom
node that you might be used to so we
often will build full applications by
composing this simple pattern together
over and over and over and over and
eventually if you have a top-level
mediator which is controlling the whole
nested tree of components and you have
an application however the community has
also shown that there can be lots of
benefits to having less granular and
even global mediators of state so
particularly as components become more
app specific and are largely used with
as generic components come together to
hold application logic having one
mediator for all application data can
make your app much easier to reason
about and it also opens up a whole suite
of nice developer workflows that we'll
get to in a minute so there are lots of
the
Global mediator patterns and those
mediator pattern is like flux formalized
this concept of one central place to put
application state that's passed down two
components and one place to dispatch
events that cause application data to be
mutated and passed back down so we can
really just think about this global
mediator of state as a generalized
global mediator pattern like I described
before for your entire application now
there are lots of choices out there to
implement this global mediator pattern
that worked just fine with custom
elements too many to go into but we
purposefully made polymer very low level
and very flexible precisely so that you
could have many different options for
how you want to manage date in your
application but a lot of times
developers will say just show me one way
to manage state that works and if you're
that person we do think that Redux is a
really good choice and a lot of people
have had a lot of success with it so the
redux library is very simple with very
little magic and a relatively small
footprint it follows a very easy to
understand mediator pattern and as
complexity of your application grows
there's a large ecosystem of add-ons
Redux that can help your application
scale and complexity so these usually
come in the form of ways to abstract and
streamline async flows in your in your
application patterns it is also
fortunately very very simple to
integrate Redux with web components so
let's go back to our global mediator
diagram and make it specific to redux so
the Redux term for the global mediator
that manages state is called the store
elements then subscribe to state that is
passed down into an element's properties
via a SUBSCRIBE callback and a place of
events the elements dispatch what are
called actions to the store and we write
functions called reducers that then
return a new state object with changes
to the data that have happened based on
actions that have occurred so there's a
bit of a trade-off involved going from
localized state management to global
state management but one of the key
benefits that is is that it opens up a
really nice set of developer workflow is
like the dev tools that ship with redux
since actions that change state are
centralized it's trivial to log every
action that happens in an application
and to see the entirety of application
state all at once so there are lots of
ways to connect custom elements to redux
and it's fairly simple to do but one
approach that we really like is to
villager views as generic elements that
accept properties and fire changes based
on user interactions just like any other
reusable web component that you might
create and then subclass that generic
element to create a more application
specific version of the element that is
connected to the store by subscribing to
the store and setting properties into
elements and then listening for Dom
events and dispatching Redux actions as
a result so aqui pro tip also to point
out if you're looking to into a global
state management technique most of them
don't come out of the box with a way to
separate all your different state
management code they lead you towards
one big blob of global state management
logic and this is an opposition to our
sort of purple concept only loading the
code that you need for a particular
route now this is totally possible to
achieve with redux but it definitely is
something that we want to pay attention
to in our implementation so I'll give a
quick example for code for how we'd make
a redux connected custom element so for
let's say we're browsing
we're building a browsing style sort of
explore view in our application and
we've built our explore page component
which takes properties and events and
then we're gonna make a subclass of this
explore page that will be specific to
our app like a bra application and hook
into our global redux tour so in the
constructor we can call Redux the
SUBSCRIBE method and dereference state
out of the store and then set it into
our elements property interface and here
we're using polymer todos set properties
API which provides a really efficient
way to do a batch of multiple properties
into an element and next we can add
event listeners for any custom Dom
events that will be fired from that
element and then we can call Redux is
dispatch method to notify the store of
actions that have taken place and will
you will do this by using functions that
create an action object so Redux calls
these action creators and will do that
for any of the events that we need to
that with our component will it will
emit that need to update global state
and remember this explore page j/s is
lazy loaded only with the slash explore
route for example
so rather than loading all of the state
management code with the app we want to
load it and install it alongside only
the components that need it so you can
add a little code to enhance Redux that
the ability to incrementally build up
global logic in the store so that logic
that manages the part of the state that
a component depends on can be
lazily loaded along with the component
and then added into the store likewise
any non-trivial logic needed should also
be separated out and loaded along with
only the components that need them to
ensure that you're achieving optimal
delivery so we're gonna continue
experimenting with patterns for state
management and how we think they can fit
into a web component based application
and I also want to give a shout out to
the polymer redux library which is a
community library that approaches
finding polymer components to redux in a
much more declarative fashion so like I
said before there's a lot of innovation
happening in this space and Redux is
really just one choice and virtually any
of these global patterns can work
totally well with web components really
seamlessly so finally once development
as our app is complete and we're ready
to deliver it to our users
we'll need to host it and serve it to
clients and although a lot can be
accomplished by statically serving our
client application there are a few
minimal features that we feel are
required to be implemented on the server
to really achieve this optimal user
experience so we want to be able to
serve our app shell for all rich URLs in
order to enable client-side routing we
want to serve either route based
dependencies using HTTP or route based
bundles for non push capable browsers we
want to serve different builds optimized
to target different user agents we want
to serve static content also for search
engine crawlers that might not execute
JavaScript so if you're doing a lot of
work on a reference server that does all
of these good things called purple
server node which is designed to work
hand-in-hand with build output from the
polymer CLI so a lot of things you heard
Sam talk about a little earlier today
we're trying to kind of make much easier
to achieve with purple server nodes so
this is a node based server that's set
up for client-side routing and it also
has built-in presets in order to serve
optimal code depending on the browser
capabilities of a particular client so
it has presets to know which browsers
have es6 support and can take advantage
of custom elements sub classing and
which need es5 compiled code it can also
differentiate between that those that
take advantage of HTTP to push support
to serve granular components for better
efficiency and caching and those that
will need bundled code and will also
serve the optimal set of code for a
client given what the client can
actually execute so last it will also
leverage a new project that we're
working on called render tron for those
BOTS and crawlers that don't execute
JavaScript and social network crawlers
like Facebook
Twitter in order to serve a fully
rendered HTML for optimal SEO and social
snippet generation so stay tuned for
more on that and you can check more
about the purple server nude beta here
on github so that's it those are the key
aspects that we see in taking advantage
of the modern web platform to ship fast
and high-quality apps and also reduce
your pain during web development so you
can really start to see how the
interplay of these different web
platform features web components and
serviceworker and HTTP 2 let you achieve
a result that's greater than just the
sum of the parts so we're gonna keep
exploring on the Vella per experienced
team ways to package up these concepts
and make them easier for you and your
teams to take direct advantage of but in
the meantime I encourage you to take a
look at some of the latest with web
components and start applying some of
these concepts and ideas to your current
web applications so thank you so much
and stay tuned for more coming from
polymer</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>