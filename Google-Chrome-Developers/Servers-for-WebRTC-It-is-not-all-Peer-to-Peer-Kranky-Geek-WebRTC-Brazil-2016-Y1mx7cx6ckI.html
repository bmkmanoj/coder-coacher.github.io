<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Servers for WebRTC: It is not all Peer to Peer (Kranky Geek WebRTC Brazil 2016) | Coder Coacher - Coaching Coders</title><meta content="Servers for WebRTC: It is not all Peer to Peer (Kranky Geek WebRTC Brazil 2016) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Servers for WebRTC: It is not all Peer to Peer (Kranky Geek WebRTC Brazil 2016)</b></h2><h5 class="post__date">2017-01-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Y1mx7cx6ckI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thanks sorry that's how you mentioned my
name is Chad hard
three years ago I started up a blog
largely to help me make some notes and
meet some of the other technical people
inside Weber to see called Weber C hacks
and that's really got me much much more
into the industry today I'm going to
talk about servers for Weber to see so
hormone touched on that part of that in
the previous presentation there was a
lot of questions here that were very
server specific I hope I'll answer some
of them probably not all of them but
certainly some so as everyone started
out usually when you see Weber see you
hear about it's all it's peer-to-peer
right and you could send VoIP here up
here and there's a lot of focus on the
browser and the browser the browser in a
mobile app and then you usually see some
sort of diagram like this that shows
just the signaling stuff down there and
I always like starting out I was always
very you know kind of scared of like
what's going on here I you know I knew
how to program I was you know on in the
browser and do JavaScript but you know
the server-side stuff was hard so I can
say there's server side stuff it doesn't
have to be that hard it can be in some
situations but definitely getting going
it shouldn't scare you off and I'm gonna
walk through some of those aspects
during this talk here so if you go into
more detail and this is actually from
the w3c whatever see spec there's
actually a lot of elements here it's not
just two little browsers right and a
bunch of these are the actual servers
here and I'm gonna explain what these
things are there's four main types of
servers in WebRTC right
there's signaling which basically you
always need there's NAT traversal and I
spent some time on this this is really
important especially for production
environments you mean realistically
probably should have this in your in
your application development environment
but there's different levels you can do
media servers and gateways they're
really application dependent
depending on what you want to do and
we'll discuss some of those applications
in a moment so let's start out right
away from signaling and I think as we've
discovered now Weber see is not just
peer-to-peer you need to have this this
signaling server right whatever sees
peer-to-peer for media all right but
Liberty is not period of here for
signaling and why do you need signaling
we just talked a moment about this thing
called session description protocol I
can say I spent many many hours with
help from experts trying to build an STP
guide here it is a very very complex
thing but it's important because you
need SCP basically defines the
capabilities and permissions of what one
one side what brought what one browser
can handle and it needs to share that
and negotiate that information with the
other browser all right so all that
information is encapsulated inside STP
right and while it's possible to Tomita
blade manipulate STP and there's a lot
of actually use cases where you might
want to do that today most of those are
more advanced use cases and certainly if
you're just starting out you really
don't need to worry about STP and in the
contents STP what you do need to worry
about though is how do you get STP from
one browser to another browser or you
know from one of your clients
to another client and that's what
signaling is all about it's about
transferring that STP from one browser
to the other browser right so one of my
favorite ways to illustrate this is
actually using one of the official
github one of the official Google
sources on github here I'll just load up
my browser all right and I like this
because it walks through the process
that you saw her mom present just
previously right step by step so we
start by getting the media right that's
our getusermedia is here
screen here right we create a peer
connection right and this next step is
really where the signaling part comes in
right we're gonna create an offer right
and you can actually see that actual
offer down here again this is just for
illustrative purposes if you're doing
more advanced situations you can
actually go in and edit this and change
this if you want to prioritize certain
codecs or capabilities or remove certain
types of network connections you can do
all that there's other ways to do it too
but that's available to you right so
then we're gonna set our offer right
then we're gonna go to the other side
we're going to create an answer right
we're gonna right so this seems like
there's a lot lots of the process when
you see it at first but really if you
just go through some of these samples
you can see there's in reality there's
not as much going on as you might think
right there's a lot of things that go on
that are automated and taking care for
Carib for you as part of the api's
so the next step is okay you need to
send this STP from one browser to
another browser how do you do that right
you need to have some sort of server
right you need to have something that
transfers that and the reality is like
the server could really almost be
everything all right there's actually a
spec written that says it's a sending
Weber to see via avian carrier right
which means a bird a pigeon a passenger
pigeon right because in theory it
doesn't actually work with most browsers
but you could actually send this SDP you
know sticking it on a carrier pigeon
send them off and then take that SCP and
interpret people like fitball have gone
so far as to you know reduce that SDP
down so you can send it with a tweet or
close to it right but to create you know
a signaling server it does not have to
be very complex you just need something
that will pass at STP from one side to
the other side last week we had a great
session in San Francisco focused on
mobile but as actually as just kind of a
you know an introduction and one of the
slides from one of our sponsors talk box
there says our Carano Corral put
together just a really simple 32 line
signaling server here right and as you
can see on the screen that this is
actually all you need for a lot of
applications here and all this is doing
is just taking you can see a message
from one client takes it and broadcast
and sends it out to all the other
clients right so not the glance over
signaling it can get pretty complex but
actually most the issues with signaling
don't really have to do with WebRTC most
the other issues are general elements
that you need to deal with with your
application in the first place right so
you need to find you know who can
actually create a session right who
who's allowed to use the system right
and that's you get a user authentication
right to what level what degrees were
they allowed to do you know what
controls they have there's security and
access controls right if you're dealing
with mobile environments and you don't
want to kill your battery
and you know your your signaling to be
too chatty and keeping your phone on you
know keeping the the network awake the
whole time
you need to think about things like push
your notification services one aspect
that I will say can get very difficult
especially as you get into large-scale
production dealing with millions tens of
millions hundreds of millions its scale
Daniel Peterson later on today has a
really great presentation and I'll talk
through a lot of the aspects of scaling
out of service right so they'll spend a
lot more more time on that topic and in
general there's a lot of other things
that your application is doing that you
need to consider and if you have a more
robust advanced application odds are you
already have some sort of signaling
mechanism of some aspects there so the
real then the challenge comes in to how
do you map some of those existing
application capabilities into what you
need and what you want to do with WebRTC
and so how do you get or use a signaling
server one approach to get them getting
started with WebRTC is actually just go
to you know communications platform as a
service provider like we have some you
know our sponsors Twilio and talkbox are
two examples of those since what
signaling is and basically a mandatory
part of Weber to see every CFAST
provider has some sort of signaling
built in to their framework right but if
you don't want to do that as I showed it
can be actually really simple to run
your own right and there's several you
know a frameworks out there some of the
some of them I've listed here that can
help you get going really quickly or
help give you some basic signaling at
the end of the day if you search on
github you'll you'll find dozens or
hundreds of potential signaling options
and different ways to do this beyond
that there's a lot of other you know
more generally or more specific
signaling messaging type services that
are designed specifically for sending
messages between between elements right
or mediating those sorts of things and
you can see some of those here like
firebase PubNub you know even Google
Cloud messaging
which Daniel talked about a little bit
later all right so that's signaling the
next segment here we're going to go
- is nat traversal firewalls right and
these are devices that are part of the
network and one of the challenges with
WebRTC versus say existing telecom
systems is when there's no connection
you can't just go tell your user oh I'm
sorry you have to go change your network
right
no-one's gonna go and tweak their
firewall the router just so they can
make a call with you right so a lot of
the work that's been put into web
urgency and the standards are about
getting around that sort of process so
you as a user and your users you know at
home or in at work can just have a very
quick simple call with Weber C without
having to worry about the network or
making any changes all right so to start
out I like to talk about the the NAT
problem right and that stands for
network address translation right and in
traditional web systems you have a web
server here right and they're really set
up for you you know your users at home
or at work for talking to those web
servers right and this system works
pretty well you know systems are to do
this all the you know the network
configuration for doing this is is
pretty well-established right if there's
something out in the world wide web
generally you're allowed to go get it as
long as it's over HTTP and you know
follows usual parameters WebRTC breaks
this right because now we're talking
about doing peer-to-peer media right
we're not just going from a server from
from your client to the server we're
actually going from client to client
right and we're just sending things
direct right it's peer-to-peer and
that's really where a lot of the issues
start to come into play right so most
networks are behind these NAT devices
right and that devices exists for a lot
of reasons but you know fundamentally
before ipv6 there wasn't enough address
space out there and for management
purposes your ISP or your IT manager
generally put in some sort of NAT device
and you had a local address right so a
couple examples of local addresses here
right and these addresses are used you
know
then the the local land the local
environment behind the net and what's
exposed externally is a different
address right and the problem with
WebRTC is I need to have this client
talk to that client so how do I know
it's address right well if the only way
the way these clients look to the
outside world it actually shows the
external IP address right but they
really reach this client I need to know
how to get through that external one and
also find the local internal address
right and be able to differentiate that
between you know one of thousands
hundreds thousands tens of thousands of
potential clients within that local area
network okay so that's problem number
one problem number two is there's
different types of traffic right there's
TCP and there's UDP which is more
beneficial for VoIP because you know TCP
is has reliable connections it'll
retransmit but in most cases for voice
for IP there's no time for that
retransmission right if that packet or
that message doesn't get through it's
too late you're better off just throwing
it away and not bogging down the network
right and TCP and UDP they follow
certain port ranges all right
particularly UDP and our common practice
for security reasons for a firewall is
basically just to block anything that
doesn't look like it should be there or
that you don't want to have access so to
prevent external hackers from
penetrating your network or finding some
some service and exploiting it right so
firewalls very typically block certain
ports or they block UDP altogether ok so
just just to recap some of the problems
and some of the addressing scheme that
you should keep in mind when using
leverage see there's there's three main
aspects to to addresses and you need to
remember you know one is the IP address
right and I showed all ipv4 addresses
but this could also be ipv6 right
there's ports that need to deal with
those common ports like 80 and 443 but
then there's a whole big range of UDP
ports out there and then there's the
protocol that we talk
about UDP or TCP and one of the great
things that's built into Weber you see
and that's been standardized to help get
around some of these firewall and NAT
problems
it's called interactive connectivity
establishment or ice right and yes you
see here so the ice is a protocol for
allowing you know a client behind a NAT
or firewall device to talk to another
one that may or may not also be behind a
NAT or firewall device and there's two
types of servers that handle ice
transactions and I'll go through it in
more detail what these things are all
right but the first is a stun server
right sessions reversal utilities for
NAT they're pretty archaic names right
but the second one is as a turn server
and I'll show what these are so the
first one is the Sun server right and we
talked about the problem here I need to
know as a user what is my you know
basically what is my external address
look like so I can include that
addressing information externally right
and the easiest way to do that just like
you can usually you know and you know
some web pages web sites are for this is
let's just go out to a server and ask it
what is my IP address right so it goes
out stun server basically is you do a
request and ask what is my IP address
and it returns not the internal one it
turns the external address that it sees
here right the second type here is a
actually essentially acts like a relay
server right and this is turn so when
you can't make a connection via stun for
whatever reason turn servers generally
have a well known public IP address
right that both clients can reach just
like your web server and the media ends
up being relayed through that media
server or through that turn server right
so comparing these two items important
things to remember your one is stun one
is relay all right when it comes to cost
right stun is very scalable because it
doesn't have to do much right you're
just basically asking for an IP address
it sends back that information turn on
the other hand is very much more
intensive right because it's relaying
all your media right and someone has to
pay for that bandwidth and that server
at the end of the day right so turn ends
up being a lot more expensive
another channels return if you don't
architect your network right or have
enough you can actually introduce delays
and Layton sees which can hurt quality
right so how often are these different
types of relays and turn servers needed
here so generally stone is is almost
always needed I asked for run he'll be
giving a talk later on to maybe pull
some stats from his call stats IO
database to see you know what's the
latest on the number of users that need
to have a relay to be able to use a turn
server it's around twenty four percent
right and talk box you know another
sponsor is here with us today is this
data is a few months old now but for
them you can see it ranges quite a bit
from day to day or from month to month
but on an average is somewhere around
you know ten ten percent or so of turn
server of all Weber's he calls require
this turn server so you can see you know
even though turn is expensive if you're
running a production network is it ok
for 10 percent of your users not to be
able connect or make a call in most
cases I'm guessing it's no so this is
why it's really important to include a
turn server right and using these turn
servers is actually is is relatively
simple actually making use of a turn
server and I'll show you quickly how to
do this here so the first thing you want
to do with a turn server is actually
just get a nice service object all right
go here a load up my terminal briefly
let me just clear right and you'll see
here in this case I'm gonna use a turn
server for one of our sponsors Twilio
this is a very simple REST API call most
of the vendors of people who offer turn
servers have you know libraries you can
iterate in to make this and so I'm just
going to do this very simple REST API
call to the turn server
essentially asking it for a nice service
object right and I'll walk through what
that looks like in a moment and then I'm
just gonna pipe this to do a simple
Python command just to format it make it
look nice right so you can see here what
this returns is a list of different ice
servers right and I'll walk through I'll
show it a moment let me walk through
here what some of these things are and
you can see the first one is a stun
server right you can see this other one
here is a turn server and there's a few
different varieties you can see they use
different protocols here TCP and UDP
right and ideally your turn servers
gonna give you a bunch of different
options for connecting right so in case
you come across some firewall that for
whatever reasons blocks you TCP or block
certain ports on TCP or blocks UDP you
have many different options for getting
through and connecting
all right and as you can see here is
just a recap same thing shows the
different objects I think I touched on
most of this the key thing with turn
servers I'd say almost 100 percent of
the time they're gonna have some sort of
user name and password right because
it's using some sort of network asset
and you don't want someone else just
hijacking and relaying media through
your server and in running up your your
bandwidth bill right so there's always
some sort of credentials and generally
there's time to live element with all
the turn servers - right and this this
lets you know how long those credentials
or those actually turn servers are valid
for all right so I showed a couple of
different types of ice candidates and
protocols right so you know the turns
over you go out and you ask it for
different options so some of the options
we've talked about a little bit UDP
again this is really what's best for
VoIP this provides the lowest latency
and overall the best performance all
right but sometimes it's blocked you
know the next alternative is TCP right
and if TCP doesn't work for some reason
if there's you know some you know packet
inspection going on that might be
blocking it the the last option is
actually doing TLS over TCP encrypting
the traffic now TLS over TCP in some
ways is not great because you're
actually encrypting the traffic twice
you know weber sees traffic by default
is encrypted and you're crypting again
it's not really providing any security
benefit on top of it you're just doing
this to hopefully allow you know so that
the firewall permits the traffic to go
through right and you'll see turns s
candidates right for for this as you see
in this example I have here the last one
is turn s right that lets you know it's
TLS over TCP right and if we look you
know different types of you know turn
what kind of turns types most of them in
general allow
turn over TCP you know followed by you
know I'm sorry
most allow turn over UDP that's the
biggest chunk this blue one here again
thank you for enforcing some of this
recent data right turn TCP is a smaller
and generally you know the the you know
the turn TLS element is the the smallest
portion that's required are used in
network and then most turn servers
actual as I showed in the two examples
of before they're gonna try all these
right and hopefully your connection will
be made in priority of provides the best
performance or best capabilities alright
so just to recap some other terminology
you saw there there's a couple different
ice candidate types right a host
candidate is when you can use a local
address so probably what happened when
we tried doing the jitsi meet call of
that hermanas used to open the session
most of us since we're all in the same
network were probably able to use a
local address and connect that way right
that's known as a as a host candidate
you might hear another term called your
reflexive or server reflexive candidate
right that's an address that's returned
from a stun server right it's reflexive
basically get reflected back unless you
know what your address is and the last
one is relay right a relay candidate and
that's coming from a turn server right
and we can actually some other great
tools on Weber seed github io there's a
lot of tools you can use to test your
ice connection all right this is really
helpful when you're trying to diagnose
or make sure your turn server is working
right it's really good to be able to go
and use some third-party code to do this
you see here I've already pre-populated
from the from the I servers object you
know the the servers I had here but
essentially you also use you put it in
the address that gives you you put in
the username and the password right
you'll see typically stunned servers
oftentimes they'll require a user never
pass
because people aren't as concerned about
using those you can add additional if
you want and you basically go and you
gather candidates and you can see here
this will vary you know you you can you
can try this on your mobile phone you
get a different set of candidates than
you would you know here in office at
Google
I got a completely different set of
candidates inside my hotel room you
could filter this if you want to just
look at relay candidates I'll just look
at all of them here quickly all right
and you see a bunch of different options
including UDP UDP over ipv6 UDP over
ipv4 all right so this shows you all the
different basically ways or methods that
are being tried to connect your one peer
to another peer right again this all
happens as part of the ice process
behind the scenes so in most cases you
don't need to worry about this unless
you're doing some more advanced you know
troubleshooting Diagnostics the key is
really to emphasize that this is all
stuff that it's happening as part of the
ice process and you're gonna get these
relay candidates and and reflexive
candidates when you use a stone and a
turn server all right
included a couple other links here will
show later on a another great cool tool
from the official Google web or C source
you know test Weber State org there's
some capability to test there I just
showed you the you have some of the
other trickle ice testing sample there
too so when you go from you want to
actually use or deploy your own turn
server or when you're considering using
a turn service there are a couple things
that they keep in mind just probably the
one of the highest level the simplest
ones to start out with is you really
want to have some level of redundancy
and ideally geographic distribution
right because especially if you have
users that are distributed throughout
the world right the turn server relays
media right so you want to consider the
latency that happens between the user
and that turns over and turns over in
the other side
if the turn server I'm trying to call
you know from here in Brazil and my turn
server is up in my home in Boston and
for someone else is down here in Brazil
right that's gonna be a really long loop
and delay it's not gonna lead to a very
good voice quality it's much better if
my audience is in Brazil to have a turn
server that's in Brazil or one that has
a very low latency our close connection
so just to conclude on the turn server
section here yeah what are some of the
ways to get a turn server well most of
the see pass providers include some sort
of turn option again this is something
that everyone should have in production
if you want to run your own there are
several options out there my personal
favorite is the co turn server which is
widely used but there are others as well
and there are several dedicated turn
services right where perhaps you don't
want to use a larger kind of
communications platform as a service
you know API set you just care about
having access to that turn server and
doing some of the things I showed you
earlier where you just basically go and
get the ice servers and add that ice
servers object into your peer connection
there's a bunch of services that allow
you to just do that right and they
generally charge you you know based on
bandwidth for the amount of bandwidth
you use all right so next I'd like to
talk about media servers right and
there's a few reasons why you might need
a media server all right hermanas talked
earlier about doing multi-party calls
right this is where you have multiple
users you know calling in the same line
similar to what we showed early on with
with the you know the the ISTE video
mean recording is another actually very
you know common popular application for
making advantage of media servers any
time you want to do any sort of media
manipulation this is another aspect
right perhaps you want to do some image
processing on the stream that's new to
processor intensive to do locally or you
want to take advantage of some cloud
algorithms to do that right so media
manipulation is another one and live
broadcasting it is another emerging
application for using media media
servers first I'd like to start and talk
about the multi-party
scenario right and who ever see is a you
know peer-to-peer technology when it
comes to media right so the simplest
approach to start out with doing a
multi-party call is to just connect up
multiple peers and add them all together
and this is a perfectly valid you have
that little possible technically
possible thing you can do but you'll see
you know doing you know adding a third
party it's not really that big a deal
right you don't have that many different
streams to deal with right but as you
start adding more and more parties you
can see that there's this exponential
effect in terms of the number of streams
that each client needs to deal with and
also for your overall network the number
of amount of bandwidth that's required
to send all this information around and
the challenge here is especially if
you're dealing with mobile devices or
anything on a battery more streams you
have the more decoding requires it's
going to chew up your battery and
probably not lead to a great experience
so the traditional way of solving this
product this problem is through an
approach called an MCU a multi-point
control unit right and this essentially
just takes all the streams and you send
your stream to a centralized media
server that centralized media server
mixes it together and sends it back out
to all the clients all right and this is
actually a pretty from a client
perspective this is a pretty simple
approach right you're not you don't have
to deal with connections and
connectivity to you know potentially you
know dozens or however maybe of other
clients you only dealing with connection
to one other element right and dealing
with that connection right and that
other element takes care of everything
for you
now the downsides of this is this
approach is actually very processor
intensive on the server side right so
this requires a lot of capacity and as
I'll show here in a moment
part of the challenge with MCU is it
doesn't actually give you a whole lot of
layout options because the MCU is taking
in all those streams you know mixing
them together into a single stream and
sending that back and generally when
that mixing happens it's downsampling or
downsizing the image it's you know
resizing things so the people on the
other end aren't gay
the same images that are being sent out
and you know as using these services
generally you need to define to decide
exactly how do you want to have that
screen be laid out oftentimes to save on
processing capacity the MCU will
actually include a view of yourself
right which is you know might be a
little bit weird to see yourself with a
little bit of delay there in a unmarred
fashion so some of the downsides of the
MCU beyond just a general cost right
because they're very CPU intensive tend
to be there they're limited in layout
options and they don't give the client
really any ability to control or limit
ability to control what the layout would
look like so another approach emerged
called a selective forwarding unit and
SFU and this essentially acts like a
video or a media stream router and I
should add in here the primary use cases
for all these tend to be video but
there's no reason audio would work with
any scenarios the advantage of the audio
is generally a lot less bandwidth so you
can actually get away with the SFU or
with the the peer-to-peer approach a lot
more but you know as I trade in the
slide it doesn't make the problem go
away it just lets you add more clients
than you could potentially otherwise all
right so transitioning back to you know
the SFU this is a much more flexible
approach all right where instead of
relying on the the central media server
to do all this processing and mix things
the client basically sends up one stream
in a very lightweight process the SFU
sends back this basically copies that
stream and sends it back to everyone
else and this is much more lightweight
because the the SFU only needs to do
decryption
to pass it along right and this ends up
being a lot of cases a lot more scalable
a lot more cost-effective you're
basically passing on some of the cost
burden of the media server you know from
the from the media server to the clients
which lowers your price and helps
increase scale but as you can see some
of the downside here is
if this can end up using a lot of
bandwidth you know both in your network
and and potentially on the receive side
in your clients so a new newer more
advanced method for dealing with that
bandwidth issue is known as simulcast
right and unlike before where basically
the SFU was you know just passing along
generally a high bitrate stream or
single type of stream simulcast is
basically each client
you know simultaneously sends more than
one media stream generally one is of
high bitrate HD type stream and
generally the other one is a lower
bitrate type of thumbnail right and so
both of these streams get sent to the
SFU right and the SFU generally have
enough logic and intelligence to say you
know not everyone out there needs to see
you know 10 or in this case five
different HD video streams at a time
usually the way these calls are set up
is you have one active talker that gets
the most real estate whoever's
presenting or speaking and everyone else
gets a smaller thumbnail alright and
this allows you to scale up a lot higher
because now instead of sending back all
those HD video streams you know down to
every client you're just sending you
know a series a few smaller thumbnail
you know low bitrate video streams right
and as a client you in this case I'm
showing an example from from the jitsi
video bridge that we showed earlier but
Google Hangouts works the same way as a
client you have the ability to select
actually I want to look at this this
person or this screen right and the SF
you can then then has the logic to send
each individual client whatever streams
they request right so there's a lot more
flexibility a lot more control and
ultimately this ends up to much better
user interfaces and user experiences on
the application side alright so this is
really the the state of the art of of
you know media servers and where people
are going today now there are additional
and more advanced techniques coming I
know time to cover that today but in
general most applications you can do
pretty well with an SFU or
a simulcast application today so you
know how do you get or new how do you
use a media server well many of the C
pass providers you know have generally
have something or they're adding
something here so you can always go
there there are a number of open-source
products out there that you can go and
take advantage of their capabilities and
use cases vary quite a bit you know some
of these are SFU some of these are MC
use some of them let you do either one
and there are you know use cases where
you want to do an MCU or might you know
work or others where I am Steve doesn't
make sense and you just need the SFU
right and then there is an industry of
commercial vendors who sell software
based systems or hardware based systems
that do media servers - right so again
this is for applications that require
larger scale multi-party video all right
there are a number of tricks and hacks
you can do to try to increase the number
of users you can get inside a
multi-party situation without using a
media server but generally there's
always some limits or some other
limitations that if you go big enough
you want to have a media server alright
the last topic I won't spend a lot of
time on but I did want to introduce is
gateways and this was talked about in
some of the Q&amp;amp;A previously right
gateways are for when you're not just
talking browser to browser right
sandra weber sees good for that but what
if you want to go and make a call from a
browser to the telephone network right
to somebody's mobile phone you know
through the native dialer app or to
someone someone at home right there are
gateway products right the core part of
gateways basically need to do two things
right there's some signaling aspect and
there's some media aspects all right the
media aspect at least is a little more
standardized right because it's
standardized by WebRTC so you need to
convert that media from SRTP DTLS inside
WebRTC to something else and generally
that's just plain RTP without encryption
but it might be and oftentimes there's a
codec conversion or there might be a
conversion of codecs from the
opus codec which is most commonly used
to more in this case a telecom oriented
codec signaling aside can be a little
more complex right because Weber C
doesn't define exactly how you need to
do the signaling it just tells you need
to figure out a way to pass STP from one
side to another through that offer
answer mechanism right you need a way
then to convert whatever signaling
mechanism you have to the standardized
signaling mechanisms that are out there
in the in the existing telecom telephony
world with protocols like SIP right so
just to conclude here right you can't
completely ignore servers right a lot of
cases you don't need to have all these
servers right but you at a minimum you
have to have a signaling server right
and you really should probably have a
stone unturn server oftentimes stun and
turn they're the same and one server if
you don't want to actually pay for a
stun server a lot of people use the
Google one which they leave open and
allow you to use and so just included
with some considerations on the
signaling side if you can leverage the
existing application infrastructure and
the existing signaling mechanisms that
you have already in your application
that will make things a lot easier right
if that's not possible or if you don't
have that or it's not practical at least
getting started signaling can be you
know pretty easy and you don't actually
need to have a lot of code or we can
take advantage of open source or other
you know commercial products out there
that's travursel aside again just
reinforce probably the the biggest
problem that comes into play with people
that are new to Weber to see when they
start to deploy it is some portion of
their calls don't work because they
never deployed a turn server right you
have to deploy this media servers
important for multi-party recording you
know very specific situations these
comes in play you know only the only
matters if your application needs one of
these things right if your application
doesn't then you don't necessarily need
to worry about media servers if you are
dealing with multi-party video the state
our state of the art is
you know is NSF you with simulcast and
lastly if you do want to connect to some
other network most typically you know a
sip network that's out there and
existing corporate environments you're
gonna need to have a gateway to do that
and there's a number of products and
techniques
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>