<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Data Flow in Polymer Elements and Apps (Polymer Summit 2016) | Coder Coacher - Coaching Coders</title><meta content="Data Flow in Polymer Elements and Apps (Polymer Summit 2016) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Data Flow in Polymer Elements and Apps (Polymer Summit 2016)</b></h2><h5 class="post__date">2016-10-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/pAW4YDLtPVs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is gray-gray Norton I'm a
technical lead and manager on the
polymer team and while I've been doing
web stuff for a long time I'm actually
pretty new to the team I just joined in
May right before Google i/o and I'm
super excited to be here at my first
polymer polymer summit so today we're
gonna be talking about data flow this is
a topic that we get asked a lot about
especially now that more developers are
building not only apps not only elements
but also apps with polymer because
polymer basically provides a powerful
side of low-level tools for managing
data but it's not very prescriptive
about how you use them it's really up to
you to figure out how to structure your
app and the fact is that the way you
move data around can have a big impact
on the performance of your app on how
productive you are and writing your app
on how easy your code is to test and
debug and on how well things scale is
your app and your team grow so we're
gonna cover a lot of ground some old and
some new some that Rob touched on just a
little bit ago but before we dive in I
thought it would be fun to kick off with
a too long didn't watch slide and I
realize might actually be a little bit
risky because I'm all that stands
between you and lunch so if you promise
not to leave I'll show you what's on it
so this slide is you know a little bit
flip and intentionally oversimplified I
said a moment ago that polymer isn't
prescriptive and that hasn't changed in
the last 45 seconds but I wanted to
start off by giving some props if you'll
excuse excuse the pun to unidirectional
data flow Rob obviously is a big fan too
and frankly you know this is a hugely
influential pattern that it really is
has come to dominate thinking in the
front-end world over the last couple of
years for it largely by the the react
ecosystem and there's a lot of good
there we think it's a great pattern for
building apps with polymer as well and
we're seeing a lot of polymer app
developers adopted of their own volition
and it's something that you can expect
to see more explicit support from us for
going forward okay so with that spoiler
out of the way let's take a quick look
at how we'll spend the next twenty
minutes first I'm going to spend some
time recapping last year's thinking in
polymer talk with a focus on the aspects
that are most relevant to data flow and
then we'll be into the meat of our
agenda reflecting on some key
differences between building elements
and building apps exploring some
trade-offs between unidirectional and
bi-directional flow and then touching
again on a few of the changes that Rob
mentioned around polymer 2.0 in this
area so at last year's polymer summit
our friend and colleague Kevin chef gave
a great talk called thinking in polymer
and if you haven't seen it I highly
recommend that you go to youtube and
check it out but this year kevin has
more important business he and his wife
are expecting a baby girl any day now so
he stayed back in San Francisco and I
sincerely hope since it's like 4:45 in
the morning that he's not watching but
in case he is hey Kevin we miss you but
in any case his talk provides a useful
foundation for our discussion so I'm
gonna hit some of those highlights over
the next few minutes so for his talk
Kevin built this simple chat demo that
you see up there and there's no back end
to it he probably could have used
firebase and done really well to be
honest and it does just enough to be
interesting so you can view threads post
messages edit thread titles and that's
about it but it was a good lens for
examining polymer fundamentals and it's
also a good sandbox for us to explore
some data flow ideas so we use it again
this year and with that let's jump right
in so what does it mean to think in
polymer it all starts with components of
course but components you know aren't
unique to polymer virtually every modern
approach to front-end development is
based on components what does make
polymer different from many other
frameworks and libraries is that instead
of bringing its own component model it
uses the one that the browser provides
the dumb so the Dom really has all the
pieces of a basic component model if you
think of it it gives you a composition
letting you assemble view
use a taps from basic building blocks
and has some basic facilities for moving
data around in the form of attributes
and properties and events it has a
native declarative format you may have
heard of called HTML and critically
extensibility so with web components for
the first time developers have the
ability to extend the semantics of Dom
and that is is really the the missing
piece to the puzzle so Kevin's app
showcased a number of custom elements
produced by the polymer team like the
ones you see here but more importantly
it demonstrated how you can build your
own reusable elements like this input
header and how you can also compose your
app from what from the ground up or from
the top down depending on how you want
to think about it entirely using custom
elements so we've just made a pretty
good pitch for the DOM and web
components
but what's polymers role in this well
again as Rob showed really clearly with
his talk a few minutes ago
polymers purpose in life is to sprinkle
a thin dusting of sugar over the web
component goodness of the platform
basically our aim is to make it easier
for you to build custom elements whether
you're developing reusable components or
entire apps and to that end polymer
provides a declarative format for easily
composing custom elements here we're
using it to build the input header for
our chat view app and in the main point
to note here is that this is just a
native HTML template with some text
annotations sprinkled in and those text
annotations manage the flow of
properties between the host element and
the elements within its shadow Dom it
we'll take a closer look at those
annotations in a couple of minutes
in the same vein polymer also provides
some convenient helpers for defining
your api's and behaviors for your
elements like this simple format which
you know and love for declaring
properties but features that that
polymer provides are really
based around a certain way of thinking
about the component model and the way we
think about it is in a pattern called a
mediator pattern so in this pattern a
custom element acts as a mediator
encapsulating the elements that it's
built from orchestrating interactions
between them and exposing an API for
other elements to use now conceptually
you can think of a custom element in the
mediator pattern as having a model that
it uses to play its mediator role and
the model really as inputs has facets of
its own API and it can pull a lot of
levers that are exposed by the api's of
the elements that it encapsulates and
the model also incorporates whatever
logic is necessary to make it all work
together so I'm introducing these
concepts because we're going to use them
now as a lens to think at a higher level
about how we design data flow in our
apps and of course much of a typical
elements job as a mediator is about data
flow so without further ado let's dig in
now as I mentioned and if you've been
developing with polymer you certainly
know about polymers broad array of
low-level features for managing data and
you know we'll touch on many of them
before we're through but our goal is not
a comprehensive walk through all the
features so for anything we don't cover
I can highly recommend both arthur's
thorough documentation on the site as
well as Rob's awesome series of data
poly casts alright so I want to go back
to the template for our input header and
think about it with a mediator pattern
in mind so with that in mind we can look
at this template and it turns out that
the entire model in this case we just
talked about the concept of a model for
a mediator the entire model is specified
in this case entirely via the
annotations in its template and there's
no imperative code there's no observers
this fully describes how this element
works specifically it uses a number of
bindings to orchestrate the flow of data
as you can see here and of course the
square brackets here are one-way
bindings curly braces are two-way
now if we want to think critically about
dataflow it's important to understand
how polymers data features work and how
they impact things like performance and
code complexity with that in mind let's
go ahead and visualize how data actually
flows through the input header as
specified by its might as bindings in
its model so input header contains a
bunch of elements but it turns out that
only these three are directly involved
in data flow so we can simplify our
diagram of it and you can see there we
have arrows representing all of the
bindings in the model including the one
two-way binding between the title
property and the value property of paper
input now suppose that the view
containing our input header wants to
specify what kind of icon to display it
sets the input headers icon property
starting the flow of data and as
expected the bindings propagate the
provided value down to the related
properties on the paper icon button and
in the next slide is really intended to
look at what those bindings might cost
us see what's happening under the hood
Rob talked through this a few minutes
ago so I'm just gonna very quickly
summarize the data flows at runtime
essentially because polymer at load time
has done a bunch of work for us so based
on annotations we provided in the
template Paulette polymer automatically
generated a setter and this is
pseudocode it's not exactly what's
happening but it gives you an idea of
what happens when that property is set
so it's simple but what about the
two-way binding we can take a similar
look at that in this case when someone
types the property value the value
property rather of paper input changes
and that triggers the upward flow of
data up to the title property of
implementer and again it's a very
similar mechanism here using the
information about our mediators model
that we provided in the template
annotations we give polymer enough
information
to do a lot of work under the hood for
us in this case that sets up an
eventlistener to listen for the value
changed event and that works for us
because paper input meanwhile be a very
similar mechanism had an automatic event
dispatch added so as was the case with
our one-way bindings this two-way
binding is lightweight and performant
because it's based on native platform
features non bubbling events and
ordinary event listeners so in a
nutshell this is really basically how
dataflow works in polymer and we refer
to refer to the underlying mechanism as
property effects because basically it
means that setting any given property
deterministically causes a particular
set of effects to occur and when one
properties effect causes another
property to be said the chain reaction
that follows efficiently moves data from
one place to another and all the
examples we just looked at where based
on bindings the exact same system really
underlies our other data features like
computed properties and observers so I
just want to take a quick pause here
because we're about to zoom out and now
look at more app level data flow but
before we do i I just want to make a
point about two-way bindings because
after all the whole world including you
know several people who've just gotten
up on stage are talking in glowing terms
about unidirectional data flow and
two-way bindings are inherently
bi-directional right so does that mean
they're evil let's go ahead and take one
one one more look at our input header
diagram and to cut to the chase you know
I can't think of any good reason not to
use two-way bindings in a case like this
and there's you know several reasons so
first of all the design of the element
explicitly requires that the title of
the input header and the value of paper
input be in sync at all times and the
model doesn't do anything else with that
value so having them bound is exactly
the behavior we want the other thing to
note is that
you know the values in question are all
scalar values so we don't need to worry
about unintentionally mutating something
out from under someone who may have
passed as a value and at the end of the
day if we weren't using a two-way
binding we'd essentially need to code
the same logic ourselves by hand so as
we move upward to look at app level data
flow we may find that there are cases
where we choose not to use two-way
bindings for other reasons but in this
case it's a perfectly good idea all
right then
onward and app word let's take a look at
data flow from the app perspective using
Kevin's chat view app as our example
so the original app the Kevin built for
last year employs bi-directional data
flow but in preparation for this talk I
basically built an alternative version
actually few alternative versions using
unidirectional flow and in a couple
minutes we'll compare and contrast the
two approaches but in order to evaluate
them first we need to understand the
apps model as a whole so where as
reusable elements tend to have
relatively simple self-contained models
an app's model more often consists of
nested structured data slices of which
are often shared across views and that's
true even in the case of this simple app
so here's a reasonable structured
representation of the chat view apps
data it has a list of threads and each
thread in turn has an ID a title a list
of messages each message has a user and
the text of the message and we also have
an object representing the user we know
the user's name and then we have an
object that we use to keep track of the
last message they've looked at in every
thread so that we can show the unread
thread count and a little icons next to
the unread threads in the list and then
lastly we have a bit of application
state the currently selected thread as
is here as well so in addition to the
data we also need to think about what
actions the user can take in this case
as we discussed very simple you can
select a thread post a message or set a
thread title but there's sort of a piece
in between or a related piece and that's
basically the set
of mutations that we might make to our
applications model as a result of events
that are either driven by the user or by
the application itself
and this is actually really the meet
when we're trying to decide how to
structure our app this is the meet of
the things that we need to consider
because where we choose to make these
mutations is all about what kind of data
flow we have so armed with this top-down
model of our app we can now evaluate our
options for flowing data and until now
we've been framing this choice in terms
of directionality but as I suggested
just a second ago
I actually find it easier to think about
in terms of distribution of
responsibility so one option is to
distribute responsibility for a model
fairly evenly between the views of our
app with each one taking ownership of
certain aspects and this tends to result
in bi-directional data flow the other
option is to concentrate
responsibilities in some central place
with individual view models then
becoming extremely simple and this tends
to produce unidirectional flow so here's
a simple schematic diagram representing
the distributed version of chat view the
one that was built last year and it
shows how we distributed the
responsibilities between the various
components so most of the choices here
are obvious the mutations of the model
were basically assigned to the piece of
view that was responsible for displaying
the related data there's really only one
piece of this the question of where to
update the last red thread that could
have gone in either place but the
interesting thing to note here is that
we have our chat thread view updating
the last red message and we have the
chat thread list sort of calculating the
derived data that's based on that and so
we have sort of a an implicit coupling
if you will between these two two views
through the same piece of structured
data that they're mutating and that
leads to some complexity so here's the
corresponding diagram
for the centralized version and you can
see our our model there is much thicker
in chat view and the other thing to note
here is right now I'm showing this
centralized view as living inside of the
chat view view I also actually built a
separate version of this using using the
redux library in which the store sits
outside the view altogether and there's
there's a polymer redux library that
that binds redux to suppress so don't be
worried if if you don't like the look of
a big chunk of logic sitting inside of
you element but in any case you can see
it it's much simpler because effectively
all of our mutations are happening at
the same place so here's a slightly more
complex for you and of course in
building the app you know Kevin used a
lot of bindings and so it was very easy
very declarative it's actually a very
elegant code to do the distributed
version of the app that he built last
year but the interesting thing is that
underlying it you still get a fairly
complex model so that complexity is
there even though it's it's somewhat
hidden from the niceties of polymers
bindings index and here's the
corresponding diagram for the
unidirectional version just simple
one-way bindings
ok so now we've looked at it sort of
schematically I just want to touch on a
few we're not going to look in detail at
the code but we're looking at the by
direction or the yeah the bi-directional
version the distributed version and you
know one a few things to note so
whenever we're making mutations to our
structured data we end up using the
polymer provided non-standard ways of
doing that so here instead of calling or
a push we're calling this dot push and
that's some notifications of the changes
we we make in one view propagate to
another similar similarly we're using
this dot set here and then here is a
complex Observer that is dependent on a
number of some deep paths to to
basically observe changes and again this
is this is some complexity here because
what it means is that in a view where
you're declaring one of these observers
you need to understand the structure of
some fairly deeply nested data so
basically again you have sort of a
coupling that maybe feels a little
uncomfortable I won't talk about every
selector but it's it's another sort of
abstraction that comes into play as a
result of the fact that we are
distributing our mutations across views
so let's look at some highlights of the
unidirectional approach so this is one
of the views in the app and the main
thing I want you to notice here is that
the bindings are all purely one-way so
we don't have any two-way bindings
another thing to note since we're not
mutating any data inside the the model
of the views we need some other way some
other mechanism to signal that an action
has taken place and a mutation needs to
occur so here we're just using polymer
1.0 event fire method I also
experimented with a more react style of
actually passing
functions down as properties and
Lowenthal that works too but you need
something like this to implement
unidirectional flow and then here's the
the actual app template and again purely
one-way bindings there are no two-way
bindings anywhere in this app at all and
you can see it's listening for for those
events that are being fired by the by
the child views so the other interesting
thing to note is because the the view
elements became so thin in terms of
their model the version that I ended up
working with the Redux version of the
app was almost identical to the one in
the in the pure polymer unidirectional
version I did which was another nice
advantage so the one piece we haven't
shown is how we actually respond to the
events in our in our main app in other
words what is the logic look like in
that centralized model and it it doesn't
look you know again Kevin's version
almost purely declarative everything's
in templates there's a few sort of
one-line functions here we actually have
you know some some longer bits of logic
and effectively what we're doing is
we're listening for the specific events
like setting the thread title you can
see the last line of this we're calling
it this dot underscore update function
and it turns out that all of the event
handlers call that at the end and then
we just have one centralized update
function where we take our are now
updated data structure and we use a sort
of an immutable approach we you can see
that there's a call here to object a
sign so if we since we know we've
changed the data we we ensure that it
bypasses or that it it doesn't get
tripped up by polymers dirty-checking by
creating a new a new object and we do
the same thing with the messages array
by calling slice and of course in
polymer 2.0 with by default and
skipping the dirty check some of these
things wouldn't be necessary although
they still might be performance
optimizations in any case a little more
code in the centralized unidirectional
way but also a lot looser coupling
between the views and and the containing
app and I think ultimately because we
have a lot of code here that's really
easy to look at in the debugger for
example you know I don't know if any of
you have run into cases where you know
something's gone wrong with your
bindings and you're not sure why they
can be pretty difficult to debug in code
like this is very easy so again it's not
a case where it's clear slam dunk
there's a lot of really nice things
about the distributed bi-directional
version but there are definitely some
some good advantages that I think would
become greater as your app grows and
your team grows to the unidirectional
approach so again I just wanted to point
out the polymer redux library built by
Christopher Turner if you're interested
at all and experimenting with polymer
plus redux
I recommend it it's very small does its
thing well and then again just a
reminder of the some of the relevant
changes in polymer 2.0 I mentioned the
one the the big one that bribed it as
well which is that by default that's no
longer doing a dirty check on objects
and arrays the other one that he also
mentioned but not quite in this context
as I think an interesting thing to
speculate on going forward because if
you do end up writing an application or
a code base that depends entirely on
sort of centralized unidirectional model
then there's actually a fairly
significant percentage of the code in
polymers data layer that technically you
don't need in that scenario and so if
you combine that fact with the sort of a
Lockhart model of polymer 2.0 you could
imagine defining your own element based
class that was you know a lot lighter
weight and again these were the things
that we were optimizing for and the main
thing that I the main takeaway here is
you know you need to understand
what your team looks like what your app
looks like and think about some of the
trade-offs you know that we looked at
here today when making the you know the
choice for how you want to structure
data in your app that at that URL I will
upload my experiments right now it is a
placeholder readme but within the next
couple of days I'll put it up so if you
want to go and watch that repo you'll
get notifications and it might be
interesting to play with the concepts I
certainly had fun so with that enjoy
your lunch enjoy the rest of day one and
we'll see you around
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>