<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>What's next for the web? - Google I/O 2016 | Coder Coacher - Coaching Coders</title><meta content="What's next for the web? - Google I/O 2016 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>What's next for the web? - Google I/O 2016</b></h2><h5 class="post__date">2016-05-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/bK6Ah68jEX8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good afternoon I'm Chris Wilson I'm a
developer advocate on the web team here
at Google joining me is my colleague
Francois also from the web team first I
want to apologize for all the crowding
in the long lines we're working it out
will be much much better next year and
for the web track particularly it all
goes uphill from here we have three
great talks in a row on the web track in
the amphitheater right after this talk
so rush right over there afterwards and
we have a nice big room here so we're
here today to show you some recent
advances in the web platform some
current work that's going on and sketch
out a bit of what's next for the web I'm
going to cover a ton of ground I'm going
to talk really fast I'm very sorry but
you're going to see short lengths to
additional references on almost every
slide in here so there's lots more to
cover lots more information you can get
and I want to start by saying first and
foremost in case you haven't been paying
attention progressive web apps are
amazing I've personally been working on
the web platform for over two decades 23
years ago as of a few weeks ago and now
is the first time I can happily say my
dreams getting realized you can build
really awesome engaging user experiences
using only the pure web platform you can
and should build on this stuff build on
serviceworkers and manifests and
everything today we have a great stream
of talks starting orth with Rahul's talk
and that'll teach you how to build
amazing progressive web apps however
that is not what this talk is about I
like to think of progressive web apps as
what's now for the web and we're here to
talk about what I like to call the new
shiny the bleeding edge of web platform
features these are features and api's
that may not be shipping yet they may
not work across browsers they may not
work across different devices they may
need you to flip on some experimental
Flags I'm going to dive reasonably
deeply into some of them some of them
I'm just going to whet your appetite for
I also want to say there are a few new
shiny features not covered in this talk
specifically these credential management
web payments Houdini features in CSS web
assembly and some other atmos crypt
stuff web component shadow dom dev
these we have great talks on these later
today and tomorrow or catch them on
video of course but I'm not going to
cover them here so with that in mind I
want to first focus on some of the web
platforms recent advances in developer
ergonomics and performance and
ergonomics is kind of a big fuzzy word
in this context so this is basically
features that make your job as a
developer easier by making common tasks
easier or quicker in many cases enabling
developers to do deeper performance
analysis or performance improvements and
I want to start by recognizing some of
the stuff we've already shipped here
some of the stuff that's already out
there in common practice like promises
so I would hope promises aren't new to
any web developers here promises are
really just a way of creating a
consistent pattern for asynchronous
api's rather than the confusing mess of
ever so slightly different callback
mechanisms we used to have or heaven
forbid in some cases synchronous API is
that blocked and we need to change the
mindset of web development to be
non-blocking so promises are now common
practice in new web api design we've
recast HTML media element play to return
a promise for example something that's
been out there for a while but now it
returns a promise because you can use
this common pattern also a bunch of the
upcoming api's we're going to talk about
here web bluetooth and web USB and web
MIDI they all use promises as part of
the API as well as the fetch API and who
here is a web developer who has not yet
used the fetch API okay so I'm talking
to you
fetch really just lets you make network
requests it's very similar to XML HTTP
requests also called xhr because XML
HTTP requests I can say about twice
without stumbling on it the main
difference is that fetch uses promises
which enables a simpler and cleaner API
you can kind of understand what this
code does without even really
understanding anything more about fetch
it avoids the callback hell and all the
complex api of xhr and it directly
integrates
JSON and other data types xhr kind of
grafted them on after the fact so those
codes pretty straightforward this is
what it looks like in xhr it's a little
bit Messier no it's not too bad but I am
skipping the whole ready state
monitoring that you usually have to do
with xhr which is pretty messy and the
real beauty of fetch shows up when you
combine it with arrow functions from es6
because then it gets this clean and this
looks super out of curiosity how many of
you use arrow function syntax regularly
already okay
that's that's good to know we're trying
to figure out how adopted arrow
functions are and how we can just talk
about them but the challenge with this
by the way the challenge with this usage
of fetch right here is that that JSON
call is still atomic we still need to
get all the data we need to fetch it all
before we can pass it off and parse it
as JSON so there's an effort underway to
really unlock the power of fetch and a
number of other api's called streams now
streams is a fundamental building block
there's a bunch of different
applications of streaming a thorough
explanation of all of streaming and how
it works would take pretty much all the
time we have left
but suffice to say that my colleague
Jake Archibald he said back in January
that streams would be the thing of the
year for 2016 now Jake may be a little
bit excitable I'm not quite as pumped as
he is about the ability of streams to
transform the word cloud into the word
but in every document but he is
absolutely right that streams are a
critical piece of building performant
progressive web apps because the point
of streams is to enable progressive
progressive piping and the really
critically important piece which we're
still working and getting fully deployed
is being able to construct new streams
and then progressively stream data
through processing and rendering you can
process data as you're still fetching
the rest of it and then progressively
render it this is especially important
when you're building an app shell
architecture because you're frequently
fetching
data from multiple places and you need
to combine those progressively today
usually you're gonna wait till all the
resources come in Punjab to gether and
then pass it off to an HTML parse and
that's not very progressive you'll
actually have to wait till everything
comes in you'll hear a lot more about
Apps shell architecture in the FIR ass
of web app sessions but Jake cooked up a
little video demo that I wanted to look
at and this video shows a comparison of
Jake's offline Wikipedia web app being
rendered on the server on the far left
and then a naive serviceworker client in
the middle then some hacks to make it
faster and then a fully streamed
progressive web app architecture on the
far right so let's play the video and
it's worth noting the server render
actually is the slowest to get an
initial render on the screen it's nearly
eight times slower than any of the other
ones but it's actually faster than any
of the non streamed ones at getting the
final render on the screen and this is
because the non streamed app shell
architectures have to wait until all the
data sources have been fetched before it
can combine them all and send them into
the parser so this is going to be
critical for high-performance
progressive Web Apps and in fact for
some types of apps app shell
architectures may cost you a little bit
of performance today whoops
so I want to continue the performance
team I want to talk about some other
exciting features we've been building to
help you build high performance
applications the first one of these is
called a request idle callback now many
sites and I'm sure a lot of your sites
have tons of script to execute not all
of this script is associated with
getting stuff on the screen for the user
for example if you send analytics data
while the user is scrolling the page
your web app is probably going to jank
visually
obviously you're going to have a poor
user experience in that case so request
idle callback lets you tell the system
hey I've got this task run it when
you've got some time make use of those
idle gaps in this performance timeline
in the same way that adopting
requestanimationframe let us schedule
animations properly and maximize our
chances of hitting 60 frames a second
request idle callback works together
with requestanimationframe it lets a
scheduled non rendering work when
there's free time for it so it's really
pretty easy just make sure you keep your
tasks fine-grained obviously if you have
a hundred millisecond task to run it's
going to be a kind of a problem and then
call request idle callback whenever you
have those tasks to be done and let it
let it take care of it there are some
ways to make sure that your your script
does actually run in a reasonable amount
of time if you have long running tasks
you probably really want to move those
into webworkers just like now but both
Facebook and Netflix are actually using
request idle callback today to make use
of idle time to do non-critical
processing tasks I had to get a cat
picture in so this is this is the cat
picture part another major initiative
and continuing this mission to eliminate
jank is a feature called passive event
listeners and I love this one because it
ends up being so incredibly simple to do
this is a new Dom feature shipping in
chrome 51 that enables developers to opt
in to better scroll performance smooth
scrolling performance obviously it's
critical for a good experience on the
web particularly on touch devices in all
modern browsers have a threaded
scrolling feature that lets them
basically render
scroll separately even when there's
expensive JavaScript running and the
main UI thread the problem though is
that optimization gets defeated if you
have touch or wheel handlers event
handlers because they might prevent the
scroll completely by calling prevent
defaults we don't know if it's going to
call prevent default during the event
handler so we have to wait until the
expensive JavaScript gets done so
passive event listeners let you tell the
system that you're not going to mess
with the default scrolling behavior all
you're saying is I'm not going to call
prevent default so scrolling doesn't
have to block on that event and it turns
out this is far and away the most common
case in fact in Chrome for Android 80%
of the touch events that get called that
ended up blocking scrolling don't
actually prevent scrolling they don't
call prevent default so 10% of those
events end up adding at least 100
milliseconds of Jack to the to the start
of scrolling and in 1% of the events it
adds at least half a second of Jack so
let's take a quick look at how dramatic
this changes this demo let's go ahead
and play the video this is a CNN page
with the touch events annotated as
passive on the right hand side on the
left hand side it's just the normal page
there's no other changes and notice how
it doesn't really affect the experience
at all except the one on the Left keeps
janking every once in a while and it
pauses so you get a lot smoother
experience and CNN didn't actually have
to prevent scrolling they didn't they
didn't ever call prevent default so
unfortunately the default scroll handler
if you have an event handler is often
janky and this is easily preventable
jank let's go ahead and go but there we
go
so how easily preventable this is it all
you have to do when you set up your
touch and wheel handlers is just add a
passive true option so that they'll to
say that they're never going to call
prevent default that's all you need to
do so pull out your laptop's get your
code let's all wait what's cool
maybe not I really do have a lot to get
so I'm not really gonna wait but
intersection observer is the next
powerful feature this one you actually
have to work out a bit but intersection
observer basically just enables you to
understand the visibility and position
of Dom elements you can easily observe
when elements come into view you could
do this before but not very efficiently
there are a lot of problems with it it
was generally a little flaky so let's
look at the code to do this you
basically just set up some element that
you want to observe create an
intersection observer object with a
callback that checks for intersections
and then when you're ready to interact
tell the intersection observer what
element to observe whenever it
intersections change it gets called your
event handler gets called this by the
way is pretty much straight out of the
code sample that we have on line I'm
sorry that we have on line that's linked
at the bottom here and when I locked my
screen and I want to switch over to the
demo machine this is a demo that another
teammate of mine
Cermak crew created it's an infinite
scroller that works by observing an
element near the bottom and inserts more
elements so you can see on the scroll
bar on the right it'll suddenly when I
get to the end it just keeps going
because it's adding more and more and
more and more and more and more elements
super fast like that's the coolest thing
is it's really really fast there's a
delay as it sort of simulates a network
a network pull of this data but this
feature actually when you combine it
with data caching be a serviceworker
it's going to be so incredibly hot for
doing infinite scrolling of photos and
things like that foot back to the slides
and I did want to mention by the way
another feature very briefly link rel
preload this shipped in chrome 50 lets
you surprise surprise
preload resources we had link rel
prefetch but that was really for the
next navigate not the current page so
preload is destined for the current
navigation it
it has an AZ attribute that lets you set
the right resource priority so say this
is an image or a script or whatever and
because it works well with reuse it can
also be used to load but not execute
JavaScript okay
this is a reminder for me to breathe at
this point so I don't run out of time
and I hope you're still with me we're
not even remotely done at this point but
next up HTTP client hints now this is
moving to a little bit of a different
area
these are HTTP headers that enable
content negotiation but based on the
user's device or environment just like
the accept header let browsers say what
type of format they prefer client hints
let clients indicate what kind of
specific preferences they have about
appropriate data like how big images
should be for example so the client
hints that we support our device pixel
ratio super handy for mobile devices
preferred width for resource the
viewport width sometimes you scale based
on that and there's also a new one the
save data client hint request oh wow my
clicks got crazy the save data client
hint request which lets servers know
that users have have a preference for
reduced data usage so either they have
high transfer costs like per byte
payment or they have a slow connection
speed or something like that so you can
say hey I want you to use a lower
bandwidth version so this basically this
is something built into the browser you
don't do this in your client code but on
the server you can respond with one of
these header to one of these headers by
passing back different versions giving
in a more appropriate version of the
resource if you know that it's a low
device pixel ratio probably send a lower
resolution image and so on also in
chrome 50 we finally support to blob on
the canvas element this has been a super
long time coming like I think somebody
said six years but I didn't check back
to make sure
this is great news though for anybody
who generates images on the client-side
because if you want to upload these to
your server or store them in indexdb or
anywhere else for future use you don't
have to to manipulate a base64 encoded
string that you get from two data URL
you can now work directly with the
encoded binary data you can even draw
image blobs to another canvas context
with a great new API the create image
bitmap API also landing in Chrome 50
because decoding images for use with a
canvas of course is pretty common the
problem is that decoding images is also
pretty CPU intensive and you always want
to get everything that CPU intensive off
the main thread so image bitmaps lets
you manage these images without having
to do that step between base64 encoding
the data that way you can pass things
back and forth across threads draw it in
a canvas in the main thread just like
you would any other image element canvas
video whatever and this lets you really
optimize your image loading across
threads another great way to avoid jank
now speaking of images I know I'm going
super fast here I don't want to dive too
deeply into the details of all the work
across the media stack because we've
done tons of it across WebRTC and
everywhere else and you might expect
some of these those of you who know me
might expect that I'm going to get up
here and talk about all the web audio
features because I love web audio but
I'm not I'm going to resist the
temptation there are three media
features that I want to mention and the
first one is so incredibly boring I
didn't even put an image on the slide
because this isn't really a feature this
is actually a chrome code change chrome
now has a unified media pipeline that
goes across desktop and mobile and we
don't pass off so much to the Android
media stack this unification means we
have more consistency across platforms
for features like caching decoding and
encoding and it makes developing and
debugging across these platforms a whole
lot easier since it works the same but
the second and much more interesting
media feature that I do want to mention
is the mediarecorder API now
mediarecorder makes it easy in fact
pretty much trivial to not only capture
video and audio which we could already
do but encode it and save it like get it
as an encoded version of itself and for
all those people who have been pinging
me on Stack Overflow for years with Web
Audio questions about how do I get an
mp3 file to upload to the server this is
how you do it media recorder so let's
take a quick look at the demo here we go
there's actually sound now too but so
this is obviously a really simple demo
let's flip back to the main screen again
to their slides I mean thank you the
important part of this demo though Wow
is this is the main part of the code
from it this is what does the heavy
lifting all you have to do here is
create this mediarecorder object with
the right options to say this is the
type of encoding this is whether I want
video or video and audio or whatever and
then as data comes in there's a non data
available callback and all you have to
do is handle it and for most types all
you really do is stuff those blobs
together and at the end you just say
okay give me one blob and that's your
data file that's encoded already for you
you can save it to disk you can upload
it to a server whatever you're done the
final media API I want to mention is
media sessions and media sessions is
really about integrating with the apps
platform media focus so custom platform
media controls or media keys like the
play button on my laptop those things
are now exposed to the web some of these
features are implicit like media playing
notifications some of them are explicit
api's you can write to if you're
developing any kind of media playback
API or media playback app go take a look
whoo all right I want to recognize a few
CSS features CSS variables first of all
more accurately known I guess as CSS
custom properties landed in chrome 59
these are great for reducing repetition
in your CSS also for easy theme
switching and if you build a lot of
simple sites not a lot of dom nodes no
widgets you don't really you're not
going to care about this feature just
you know tune out for 20 seconds or so
on the other hand if you build a lot of
complex sites with lots of widgets use
third-party widgets for example CSS
containment helps you optimize the
performance by containing the effects of
those rules and
you can also use containment to protect
your site from getting its performance
affected by third-party widgets next up
CSS font loading font loading was first
implemented in Chrome 35 so quite a
while ago but the font face set in
interface which just came in with chrome
48 lets you check individual font faces
and their download status so all in all
you can really dig into how fonts are
actually getting loaded and utilized by
the web engine and at this point you're
thinking I'm just going to get
progressively shorter and faster at
dumping features at you and just tell
you go look it up so I'm gonna take a
quick break from organ Amma creatures
and talking about those switch gears and
before I talk about new bedrock
capabilities I want to talk a bit about
how the chrome team has changed their
approach to moving the web platform
forward over the past year or two first
and foremost I hope you get Google
really does love the web like at Google
everyone I work with absolutely loves
the web and one of the most important
messages I hope you walk away from this
with is that we believe we have a
mission of moving the web forward and
when I say the web I don't mean the
Chrome web we really want the web as a
whole to be awesome and we don't believe
that our job is done until feature ship
interoperable across modern browsers
because if they don't ship across all
browsers you don't really get to use
them all the time and as an example
we're not super bullish on the idea of
vendor prefixes
anymore because that ends up building a
single vendor web which isn't great
today we have a four pronged approach to
being responsible at how we move the web
forward first and foremost of course we
have different channels I think probably
everybody knows something about the
channels we have a stable Channel that's
what average users use all the way to
the canary channel which is basically
the latest in highly experimental
features all crammed in
but secondly we put experimental
features behind experimental flags so if
you want to use web Bluetooth which
offense was going to talk about you're
gonna have to go turn it on in chrome
flex it's not going to just show up even
in Canary third we're actually building
new infrastructure this is a new thing
we haven't really talked a ton about
this in public although we have
mentioned it before this feature called
origin trials which is a way of taking
some of those experimental features and
letting a web developer test it out in
the wild briefly via a key that they
have to ask for so it's specific for
them but it is in stable bills like it's
a feature that's going to get turned on
for an average user
however like you can get broad feedback
then like you can see what happens when
an average user uses this feature but
you it shuts off after a given point in
time so none of these lasts forever
they're pretty short term and
additionally if too many people are
using this feature it automatically
shuts off too because we don't want
these features to get baked into the web
platform we don't want people thinking
hey this is just part of the web now
when they're not and then finally we
have a core policy of incubating all of
our substantial new features we do this
through a w3c community groups that I
personally co-chair the web incubator
community group my co-chairs call this
the ycg I personally prefer wicked but
you know whatever this is designed to be
a lightweight way to make and discuss
standards proposals like have a semi
organized fashion around it but you know
not spend all our time planning charters
and things but still properly managing
intellectual property and getting all
that contribution upfront so all of our
new substantial features go through this
community group okay and finally by the
way part of keeping the web platform
healthy is removing api's that are no
longer necessary when they get replaced
by new api's or their experiments that
just didn't work out we should pull them
out
so this is actually just the
deprecations from the last three
releases of Chrome we're looking at
removing bigger features too like
requestautocomplete or even html5
appcache
but we do have policies about how we can
remove them so don't worry we're not
going to yank things out that people are
are still using so let's talk about new
capabilities that we're adding to the
web platform before we talk about truly
cutting-edge you know stuff that is
really experimental since I am on stage
I'm gonna seize the moment I'm going to
demonstrate the success of my personal
pet feature and somebody out here I'm
sure knows what it is because somebody
asked me about it earlier right before
we I went on stage make sure I'm set up
here web MIDI so I can tell a few of you
know what MIDI is MIDI is a more than 30
year old standard for connecting
keyboards and synthesizers music
instruments keyboard controllers like
this one to computers in each other and
a couple years ago when I first started
playing with Web Audio I said hey I
really want to control this from my
keyboard controller so I put together a
standard worked in the w3c and we
shipped it in Chrome last year Firefox
incidentally just started their code
review for their implementation which is
awesome and since last year a lot of
music vendors have jumped on board and
started using the web platform to
deliver their experiences
Yamaha shipped their reface series of
synthesizers with their sound mondo web
app as a way of doing editor librarian
services my new Novation circuit groove
box you dumped new samples on it by
plugging it into the web you don't have
to install software and the coolest
thing though the absolute coolest thing
that I've seen was last year came from
an artist and let's go ahead and switch
to the demo so Madeon is a French EDM
artist he dropped an album about a year
ago a little over and
put up this Web Audio based remix board
on his website let's make sure we have
audio on here alright so this basically
let his fans and I am one by the way I
actually really like his album it lets
his fans remix sounds from the tracks on
his album it's like a pre laid out grid
of stuff you can play but that we make
awesome guys that he worked with on this
they decided to take an extra step and
they hooked it up to this this is a
Novation Launchpad it's one of the most
common electronic music production tools
I own two of them and if you've heard of
Ableton Live this is kind of like a
minimalist preloaded version of this and
I can control this entire app from this
device let's switch over to the camera
let's see if I've got this lined up so
you can see it alright
okay left one on so I really I really
just always wanted to do that so go
ahead and switch back to the slides I
could do that for hours but I probably
shouldn't move along so my point here
though is not just hey look at how
awesome this is or you know whatever
because that I could say too but my
point here is that hardware device
access unlocks some tremendous potential
just like enabling seller ometer support
really unlock some amazing user
experiences in mobile devices early on
that's true with other new hardware
capabilities too we want to continue to
unlock those capabilities so I want to
dive into some more experimental
features and bring up francois to talk
about web bluetooth thank you Chris
my show of hands how many of you are
familiar with Bluetooth Low Energy
Technology okay
that's going to be fun so I'm based in
Paris France
hence the accent and quite fortunate
these days to work on a new web API that
will allow a website to discover and
interact with Bluetooth devices in
JavaScript but first why Brutus
I mean why Bluetooth the world bluetooth
actually comes from the Danish King aha
Latin aka our Hal Bluetooth so I'm not
going to lie here we don't really know
if you had a bluetooth or not but what I
can tell you that at the end of a 10th
century they were not perfectly kidding
there
oddly enough in the Nordic runes the
edge from Arad and the PIA from Latin
once merge consisting the official
Bluetooth logo whatever Bluetooth has
grown a lot in 20 years along it's
different version the latest major one
the version form which is like six years
old now introduce the brand new
technological Bluetooth Low Energy or
theory so we are not talking about
headset mass or casas the car stereo
system anymore
unlike of the technologies such as Wi-Fi
and internet which have continuously
broadcast a increase the transfer rate
of a diversion really took a radically
different approach here they thought
let's try to design a technology that
could easily be integrated into
thousands of devices that are not yet
connected and that cost almost nothing
it turns out that when you're trying to
reduce the cost of manufacturing and
maintenance of a device you are looking
directly to its energy consumption
basically if you want to create a device
that consume very till nowadays you will
probably use something like a CR twenty
thirty two battery okay I'm sure I'm
going to teach you something great today
do you know what means twenty thirty to
twenty is actually the twenty millimeter
diameter of the pencil while 32 is a
treated two millimeter height just to
give you rough ID the energy provided by
this kind of battery allows your body to
function for about twenty seconds it's
not that huge' this explains the
transfer rate which are significantly
lower and inverse
reduce do not worry though it's not that
bad
PL is primarily targeted to a connected
object for which the need for speed is
low and the autonomy crucial ok demo
time Krish is currently holding in his
hand a device a pili device actually
called the play well candle and this
does exactly what you think it does so
can we switch to the computer yep so I'm
going to click on the connect button
here label candle you just here I click
on the connect button and now I can just
change the color to red blue green and
and even set my favourite effect the
rainbow one that's the rainbow it's okay
it's just the candle by the way the blue
to special interest group predict that
within 2 years nearly 96 percent of all
phones and tablets will have Pirie it's
going to be everywhere can we go back to
a site now before I show her the web
Bluetooth API works
let's review together very briefly some
basic concept of how works Bluetooth so
there are two distinct role in ble the
central and the peripheral the device
known as central is the one that will
search for nearby devices in order to
initiate a dialogue it can be your phone
or your laptop and the peripheral is one
that will contribute rebroadcast its
presence to anyone who will listen it
can be a heart rate sensor a beaker or
fridge once connected the peripheral
will usually stop broadcasting is
present and then the central can start
to interact with the GATT server of the
peripheral which contain all the
services exposed in the peripheral they
are Bluetooth standardized service such
as the battery service the heart rate
service but you can of course create
your own finally each service contains
one or several characteristic that have
their own properties you can read the
value from a characteristic like the
battery level or you can write a value
to a characteristic and even be notified
when a value change
I will explain this later so just in
short it's not that complicated so how
does that look like in JavaScript my web
application will play the central role
and the device I'm trying to connect to
will be the peripheral so first I want
to discover a nearby Bluetooth devices
and for that I will call navigator that
Bluetooth that requests device which
will show me a model figure in which I
can pick a device from a list of
Bluetooth devices keep in mind that this
list is filtered with the filters key of
the option object that is anything but
optional the goal here is to prevent a
list to contain too many devices in this
example for instance I'm looking for a
device that advertised the battery
service I did not make sure it before
but when you broadcast your presence you
can also add some additional data so
since the battery service is a Bluetooth
standardized service I can simply use
the string battery and of course service
in short once the user has selected the
device and click the permanent
you now have access to a Bluetooth
device object that contains device them
and the accessible services there are
two important things here to note first
this function can only be called if the
user interact you to the webpage first
in this case a click on a button is
enough secondly it only works on HTTP
secure pages do not worry though it
works perfectly fine on localhost as you
developed what we want now is connected
to God server mentioned before and for
that I will simply call device the
Catholic connect and get a gutter
instance when the peripheral is actually
connected and now let's treat the
battery level of a Bluetooth device once
I get the battery of a characteristic
from the battery service I can now call
the read value method to get a data view
JavaScript object which contains the
remaining battery percentage other
device writing to a Bluetooth
characteristic is as easy as reading it
this time let's use the heart rate
control point characteristic to reset
the value of the energy expanded field
to zero on heart rate monitor device
what I'm doing here is calling write
value with a bite of one I promise there
is no magic here it's all explained in
the official Bluetooth documentation
and now to be notified when the heart
rate measurement characteristic
challenge on device I only need to add
the appropriate event listener to this
characteristic and start notification
then every time its value changes the B
function will be called with a new value
damar time let me show you what I mean
by notification I'm currently wearing a
ble heart rate sensor which measure my
heart rate in real time
I'm usually between 60 and 80 but since
you are all looking at me right now
I expect this to be a little bit higher
so can we switch please I will click on
this little heart find my heart rate
sensor and connect so let's see
now to prove you that it's really mine I
will do some push-ups and hopefully it
will be higher okay that's right Michael
is going to be Holliday because okay why
is it I'm sorry I come to bar I'm just
me herded a lot lower practicing this in
the team approach C okay I'm not the
only one having fun with Bluetooth
devices a colleague of mine Lin has
plenty of little toys at home for which
he has created several web application
on his Chromebook Anki Drive for
instance is a racing game in which you
control a car via bluetooth he also
created a web application for ble
printer as soon as the famous bb-8 was
out he bought it and wrote a web
application for that few weeks after
that another developer Dan Jenkins
hacked Liang's devote to make the bb-8
and l2b hate dancing change color to the
Imperial March by using the webview
api's more recently he found a purely
LED device called dirty at fries and
coolant risen to Hackett funny thought
let's insert a Bluetooth propeller into
a stuffed grumpy yet attached some
balloon to it make it fly and control it
from a web app because why not if like
me you like to understand how Bluetooth
things works I recommend you install
their official Android apps and enable
the developer option in the Android
settings that allows you to capture all
Bluetooth packets from there it is as
simple as analyzing packets
Google and opera are as we speak
implementing this experimental Web API
in their respective browser we are
hopeful that other browser vendors will
follow an adventure out of this API when
it goes with w3c but the real question
is can you play with it today and the
answer is yes it is verbal behind the
experiment of like web Bluetooth in
Chrome OS Chrome for Android marshmallow
and Chrome for Linux if your naughty
part you can see a fan with chromium
built
and regarding my classics and windows
support we are working on it like really
so he had two thing that will help you
hopefully get started with web Bluetooth
is a simple web app that will generate
all the just read boilerplate code to
start interacting with a Bluetooth
device enter a device name service
characteristic define the properties and
you're good to go if you're already a
Bluetooth developer then I suggest you
give a try to the web Bluetooth
developers to your plugin it will also
generate the webview to JavaScript code
for your Bluetooth device it is still
early days but I think you're gonna like
it
okay so here we are web site can now
control Bluetooth devices just like
native apps baho okay count down there
is a big difference here a web
application I can share it with a simple
link that anyone can open in a browser
it may sound stupid / obvious what I
just said but this is the power of the
Web today to interact with a Bluetooth
device for the first time here's what I
have to do go to a store accept the
terms and condition why don't you take
myself search for the app install it I
accept the permission lunch it scans for
nearby devices and only then I can start
to interact with the device wouldn't it
be great if I could just give the last
tab that's exactly one mission of the
open-source project called the physical
web make interacting with smart devices
as simple and fast as possible okay so
how does it work for real I will be
brief here has the physical web session
already happened this morning but again
this is very simple
each Bluetooth device will continuously
broadcast in addition to its presence a
URL so now as long as bluetooth is
enabled on your phone you will get to
see in your notification bar some URLs
filtered by the web service which are
broadcasted by nearby Bluetooth devices
think about a birth I can tell you it's
next up
parking manner that lets you pay would
you adjust your phone in the cloud or
even just a dark color broadcasting it's
on a contact information it is already
available to all of you on Chrome for
iOS and chrome for android so now let's
step back a little bit and think about
the integration with the web Bluetooth
API
imagine if the web site broadcasted by
the Bluetooth device would allow me to
interact directly with it from my phone
at no time I'd have to install an
application from a star a simple click
on this physical web notification would
be enough for me to get to interact with
the device this is the power of the
physical web the web bluetooth is about
to implement this picture with an
upcoming object called referring device
this will allow you to access directly
in JavaScript to the Bluetooth device
that broadcasted the URL when user
clicked on the physical notification so
let's wrap up I realize this might sound
overwhelming so I recommend you simply
Google web Bluetooth symbols at the end
of the day we find all samples article
specification and demos and we even have
to collapse you can throw in the
calabria one will take you through all
the steps to create a web app to control
the playback candle and another one to
learn more about the polymer elements
dedicated to web reduced and with that I
will give back to Chris Thank You
Francois
so we are pretty much out of time one
final hardware API I want to mention
that we're exploring is Web USB now
don't let the title scare you the idea
is not to let the web get access to
every USB device in your computer or
device that would be a little crazy Web
USB is about enabling specific new
devices that have their firmware
available to be accessed by the web that
actually say I want to be accessed by
this domain so this is really more about
enabling a new class of devices than
enabling current devices to get accessed
by the web I want to wrap up there is
tons more going on on the web that we
couldn't cover here web VR is awesome
presentation API motion passed in CSS so
much good stuff there's even stuff that
we haven't really even totally started
designing yet persistent storage web
intents to let web apps actually handle
other data and do something interesting
with it but we are out of time I hope
you're as excited as we are about the
future of the web platform watch
developers.google.com slash web for more
and I'm going to personally be running
over to Rahul's presentation in the
amphitheater right now and hang out
there for a while but we do have mobile
office hours this afternoon from 5:00 to
6:00 and I think francois and i will
both be there if you have any questions
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>