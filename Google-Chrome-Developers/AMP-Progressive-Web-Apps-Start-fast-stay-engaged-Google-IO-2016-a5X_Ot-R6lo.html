<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>AMP + Progressive Web Apps: Start fast, stay engaged - Google I/O 2016 | Coder Coacher - Coaching Coders</title><meta content="AMP + Progressive Web Apps: Start fast, stay engaged - Google I/O 2016 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>AMP + Progressive Web Apps: Start fast, stay engaged - Google I/O 2016</b></h2><h5 class="post__date">2016-05-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/a5X_Ot-R6lo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">25:25 fish maybe hey good afternoon I'm
Alex Russell I'm a software engineer on
the chrome team I've been a software
engineer on the chrome team for longer
than I should probably admit on a stage
this big but these days I lead the team
that has helped bring progressive web
app technologies to chrome in
collaboration with folks in the web
development community and our partners
at other browsers and if you saw Rahul
and Dave's talk yesterday what you may
have taken away from it is that we're
serious about helping you adopt and
succeed with two technologies this year
for aggressive web apps and accelerated
mobile pages or in for short we don't
have time to get into all the technical
details about each of those technologies
today so I recommend that you check out
Jake Archibald talk on progressive web
app architectures and instant offline
and multi Global's talk on how amp
achieves its performance they go into
details that I wish I could had all the
time today to get into but what we're
gonna talk about today is end-to-end
performance across multiple pages and in
some cases even across multiple sites
how we can build reliable experiences
for users so I think we all know that
performance is money and we kind of know
it intuitively but the data really helps
sort of drive at home and if big shiny
graft doesn't hurt either so as to has
shared this data with us and what it
shows is that users who experience slow
sites bounce away from those sites much
more frequently than users who
experience fast pages so we talk about
fast and we talk about slow and
frequently we use confusing terms for
that do we mean when something's loaded
how smoothly it animates they mean how
responsive it is to me tapping on a
button something different than that
what do we mean when we say something is
fast or it has good performance
to get clarity on this question last
year Paul Lewis and Paul Irish
introduced the rail model for web
application performance and rail is an
acronym stands for response animate idle
and load because we like acronyms I
guess on the chrome team apologies but
to recap rail the R stands for respond
we want to respond within 100
milliseconds to any user action we also
want to animate at 60 frames a second
which means that we have to get frames
on-screen consistently every 16
milliseconds now the browser has to do
some work when we go and change HTML CSS
or DOM and that means that it has to
reapply that change and then go paint
that all the way out to the screen and
so we've probably got less than 16
milliseconds a good rule of thumb is to
try to get your main thread work for
animations done in 8 milliseconds or
half the total frame time we also want
to avoid timers that run forever in the
background waking up the CPU burning a
hole in your pocket draining your
battery quickly and so when we're idle
we want to do work in collaboration with
the browser but we also want to break
that work up into small chunks
preferably we're preferably around 50
milliseconds each that's at that size we
can make sure that when the user taps
next time we can respond within the 100
millisecond window the last bit of rail
is load we're gonna talk a lot about
loading today the goal here is to try to
get something to the user within a
second if it takes longer than a second
the user starts to lose focus the user
experience research on this is you know
decades old now and pretty conclusive
people aren't able to really keep
themselves in the tasks that they were
trying to accomplish
so if you aren't familiar with illegal
herbs high-performance browser
networking I recommend that you read it
it's maybe a good thing to put you to
sleep at night someday or something to
read on the way home from i/o but it
goes into great depth and has lots of
research about how mobile networks
specifically conspire against us and
aleeah's research shows that because of
resource transitions at the radio level
DNS TCP HTTP and TLS setup it may never
be possible for a user on a 2g or a 3G
connection to hit the l2 hit that one
second load time you can't even get
hello world done in that case if you
have to transition out of a low-power
state on a mobile device and Ilya said
something to me the other day that
really rang true which is that a 4G user
isn't a 4G user most of the time and I
commute using public transit in San
Francisco and I take a train that is
occasionally connected I see my phone
jumping through a bunch of states all
the time and it frequently starts an LTE
as I descend into the station and then I
go down to the Train I get 3G for a bit
and then I'm off and I'm back on to
something else it gets up the 3G again
and then it transitions up to LTE even
when I have those full bars on that 3G
connection they can still take seconds
for something to come back and the
reason for that delay is the radio
resource control and all of that set up
time so the web isn't today particularly
reliable even when we have full bars
it's also the case that we wind up using
language that is confusing about what it
means to be loaded so even if we're
trying to measure this experience it's a
little bit difficult because we don't
share a common vocabulary
some people say loaded they might mean
Dom content loaded you'll see this in
dev tools and dump out the loaded as
when most of the work has been done to
construct the Dom but if you've got
asynchronous scripts or if your delay
loading content that may not actually
correspond to what the user cares about
same for onload onload doesn't take into
account potentially the fact that you've
got asynchronous work happening
so the structure of your page matters
and makes these not necessarily reliable
indicators of bloating
there's dom stability which we think of
is like when it's actually sort of
finished constructing or visually
complete this is what a lot of industry
professionals use when thinking about
webpage performance today because it's
less subject to the same sort of error
in gaming that you see from other things
but visually complete doesn't mean
interactive I think can be visually
complete and I can't maybe use it I
think what we really care about when we
say something is loaded is time to
interactive when can I start using this
thing you put something on page when can
I tap our tools today take us away from
that time to interactive goal in some
really weird ways and we're starting to
see a new generation of frameworks and
tools that are optimized for that first
experience that first paint but it may
not be interactive Paul Lewis
illustrated this pretty brilliantly on
Twitter the other day I'm shamelessly
borrowing his charts and this is
basically the first architecture that
you could choose our tools make this
possible today
pretty fluidly you can go and build a
single page application which trades
away initial load time for eventual fast
interactivity and this is great once
that initial JavaScript is loaded I can
do things in Gmail very quickly indeed
but I have to wait a long time so this
is great for it experiences that you
live in but it's terrible for
experiences that are transient when you
just want a thing watching the loading
bar is basically the worst thing in the
world more and more we're seeing the
uncanny valley which is where you have a
server-side framework that takes
application state it dehydrates it into
some HTML that captures the current view
state re-inflate sit on the client side
and then from there it boots up all the
JavaScript to finally make it
interactive this is super unsatisfying
and it's particularly unsatisfying on
low-power devices on flaky networks like
phones so I think what we're really
after is interactivity the pattern the
purple
that Taylor Savage showed you yesterday
really highlights how we can do better
here by putting interactive pixels on
screen and only loading the resources
that we need right now it's also the
case that articles wind up in this
uncanny valley today because of
third-party content amp was designed
explicitly to address this for article
content so amp me purple and a lot of
new technology we're putting into
browsers and into the web platform are
necessary because today the web is slow
the web feels terrible because there's
all this third-party stuff it's all
analytics tracking poorly structured
pages badly considered font decisions
and it's easy to miss how bad this is
because we wind up doing most of our
development and dev tools on the desktop
so the computer that I lug around with
me every day
is a quad core i7 MacBook Pro it's got
six megabytes of l3 cache it's got four
cores that have a 14 deep instruction
pipeline it can dissipate 47 watts it's
got a GPU that's a separate chip the
other phone to carry the other device I
carry with me all day every day is my
Nexus 5x and if that thing dissipated 47
watts it would release the magic smoke
that causes computers to work so these
differences are everywhere and they're
most obvious in script execution this is
why mobile is harder than it looks here
for instance is last year's i/o site it
was made with a pre 1.0 version of
polymer polymers gotten a lot faster
since but what we'll see here because we
get Dom content loaded at 700
milliseconds on my desktop on a Wi-Fi
connection this is a fast connection
this is a fast machine this looks great
that animation after onload the onload
happens at a second and a half and that
animation is super smooth the total
JavaScript time for this
is only 600 milliseconds that animation
again transitions out very nicely and we
get to interactivity at 4 seconds pretty
good I take that feels good this is the
exact same document on the exact same
Wi-Fi network except on my Nexus 5
connected over USB to Chrome : inspect
same dev tools but a very different
picture in this version of this same
study we get down content and loaded at
two and a half seconds script blocks the
UI thread for two full seconds onload
happens at five and a half seconds and
we've got four seconds of total
JavaScript running we still get smooth
animations for all the work that we're
doing and interactivity slips a full
three seconds from where it was on the
desktop again this isn't the network
conspiring against us this is just the
CPU okay so mobiles are this is
framework X I'm the names have been
changed to protect the slow the first
render feels downright instant on my
desktop its interactive at 500
milliseconds the total JavaScript time
is less than a second and on my macbook
pro this absolutely meets rail this is
an outstanding experience they've done
server side rendering but on the Nexus 5
the first P is really fast
but it goes downhill from there so the
script gets started pretty quickly again
I'm on Wi-Fi but it locks the UI thread
for 10 seconds that loading spinner that
they put up in that initial paint stops
it stops spinning because the CPU is too
bound that's pretty bad and we don't get
the interactivity to twelve seconds our
desktop dev tools are lying to us this
isn't good enough this is nowhere near
good enough so we've been working with a
lot of partners over the last year or so
and mostly I just sit down with them
with a phone and I plug it in and I show
them what it actually feels like and
when we do this engineers get serious
feels it's not great
sort of sad making now it is possible to
continue to use a framework but we have
to do it differently we have to use a
different style of constructing our
applications we can't continue it'll
pile into the JavaScript clown car and
assume that it's all going to be fine
it doesn't work that way if you saw
Taylor or Kevin's talks yesterday you
might have gotten wind of a new style of
constructing applications that the
polymer team is pioneering they call
their pattern purple and here's the shop
demo on again on my desktop MacBook Pro
and like framework X it's interactive at
400 milliseconds so what right everyone
can do that
and the total JavaScript time is two in
a millisecond so it's less but me you
know they hit rail so what's to see it
only shows up when you go to mobile it
only shows up when you're on real
hardware and the differences are huge
our first paint does acknowledge to the
user that we're doing work on their
behalf quickly but we're not seeing the
actual sort of UI this is just a thing
at the top that says hey we've got some
stuff but when we do paint those paint
painted pixels are actually interactive
you can use them immediately and the
reason that are interactive is that the
additional work that happens later to do
stuff in the background to fill out the
rest of the application is all happening
in small chunks we can continue to
scroll and interact with everything
that's on the screen this site feels
fast on a 3G device and on my desktop
it's interactive at 1.7 seconds which I
don't know I take that it's doing the
full second and change of JavaScript
right we saw earlier how two seconds of
JavaScript can be terrible but this is
different that initial wad of JavaScript
is getting run in it what is 460
milliseconds but then after that it all
gets broken up into fine grained little
chunks and so you don't feel 1.3 seconds
of JavaScript you feel that the site is
interactive and the way that they've
accomplished that is to use the platform
to lean on the platform to schedule the
work to use the platform to provide the
component model to use the platform to
provide the loading mechanism to use the
platform to provide the caching
mechanism to do granular dependencies
and use HTML imports to make sure that
things only happen when they need to and
I can't stress this is enough what we're
doing today isn't good enough and if we
use the platform we can get to good
enough
it isn't just advice limits our other
assumptions screw us too we tend to be
connected on Wi-Fi when we're in the
office testing stuff out and Wi-Fi is
got its own problems but it's nothing
like a real mobile network even dev
tools emulation of mobile networks
doesn't really accurately model the sort
of wild transitions that the physical
layer goes through and our protocols
aren't well adapted to those wild
transitions TCP doesn't know what it
means to have a physical layer that does
this also a lot of our tool chains have
legacy desktop assumptions built into
them from analytic frameworks to font
loading tools to your JavaScript
framework to start with they're making
me fundamentally wrong decisions for
mobile and that really shows up when
you're on a real device so these
problems can seem culturally and
organizationally impossible to overcome
that makes the goal of using the
platform to help us out seem impossible
even when we know what the right things
to do are technically that's what
motivated the amp team in part to
develop a set of off-the-shelf web
components that make appropriate
assumptions for mobile directly into the
format it's been amazing to me to watch
the amp team's progress over the last
year because once upon a time I helped
lead the team inside the chrome
organization that designed web
components in 2010 we expected that
there would eventually be a diversity of
frameworks and toolkits built on top of
web components that would be
interoperable as a result and what we're
seeing today is that diversity in the
wild you can use amp to build really
fast articles or you can use Mozilla's a
frame to build 3d environments or you
can use polymer or Vaadin to build these
really expressive immersive applications
seeing all the diversity really drives
home to me how many problems were
solving with the web and it also shows
how interoperable component model can
make us as developers significantly more
productive what we didn't anticipate
that was what the amp team did they
built a validator for their subset so
and takes a bunch of the misc features
of htmls legacy design decisions but it
marries those with a bunch of fixes that
it brings along for the ride and it
ensures through the validator that all
amp content meets amps design design
goals so what are those goals
I'd say basically that amp is trying to
enforce content modesty to do that and
follow some rules and those rules are
all enforced by the validator amp only
allows JavaScript to run in the main
document if it comes from amp that cuts
out a huge set of anti patterns but it
also means that you can't add custom not
ant behavior to your pages next amp
elements layout only once and they
always have proportional sizing which
means that you'll never see that thing
where you've got something under your
finger and you're about to tap it and
then that that doesn't happen in amp
documents amp also goes to great lengths
to get content on screen as fast as
possible delaying things that aren't
critical to the user experience it
batches work in the Dom to make sure the
layout engine can process things as
efficiently as possible it removes the
scourge of the modern web which is
multiple analytics frameworks loading in
all to instrument exactly the same thing
every single time it federates that out
from a single listener and lastly thanks
to all those restrictions and some
cleverness about knowing what state the
document is being loaded in and makes it
finally possible to do smart
pre-rendering from amp viewers and if
all of this sounds restrictive well
that's kind of the point
but the results speak for themselves the
Ann team reports that they're seeing
under one second average load times from
Google search results and at the same
time eight second load times are
experienced by 99
of aunt page viewers taking the same
corpus of pages and looking at their
other formats you see 22 seconds at the
median it's pretty bad
and Anthes so much better ants careful
design allows amp content to also be
hosted on the CDN and that's what's
happening here
The Washington Post has published these
articles which I see badged here with
that amp lightning bolts on the lower
left and when I tap in them the
transition is roughly instant because
the documents were hosted on Google's
amp CDN and they're the same documents
that the Washington Post put on their
own server but they can be pre-rendered
so that's what happens here once I load
Google News I can see that at some point
later once the news has loaded Google
News goes and preloads that thing that I
might tap on next and it can do this
intelligently now it's only possible
because amp knows how to avoid doing too
much work when it's being pre-rendered
if we tried this with arbitrary web
content it would make my phone really
really really slow but amps restrictions
make it saying to do this and what it
adds up to is a reliably fast experience
when I tap I get that document this is a
real trace I showed when I tell forget
that document rendered and interactive
in half a second I'm a real device
that's incredible so thanks to clever
pre living content restrictions and
cooperation between amp viewers and am
content we can finally get to a reliable
experience transitioning from browsing
to reading so let's see exactly what
that looks like on the Nexus 5 here
we've got amp the the Google News site
helping us transition to that experience
as fast as possible it's great and what
this does is it puts publishers like the
Washington Post and their content in the
very best possible light their brand
experience starts instantly that's a
great way to get introduced to users
so changing gears just a bit I want to
talk a little bit about progressive web
apps
if anthis all about putting restrictions
to improve on content to improve first
load progressive web apps are all about
improving experiences over the long haul
their app like they blur the lines
between web content and apps but they
keep the strengths of the web they add
reliability home screen access and push
notifications to an already strong set
of web capabilities you keep the same
easy discovery but you become apt like
through use this reduces the cost to
acquiring new users they're more
engaging and that can be reengaged
over time so progressive web apps why
are they called progressive web apps
well because they become apps
progressively you just start using them
in a tab and then over time they want it
being first-class citizens so this is
airhorn or calm it's the canonical demo
you can go try it out on your phone now
no no not now someone's gonna do it
aren't they okay
but if I go to air horn or calm
repeatedly eventually the browser will
prompt me to ask me if I want to install
it it's something I use and therefore I
might like once it's installed it can
launch full screen in an immersive mode
it can even be its own top level
activity in the task switcher and that
splash screen that gets generated for
the app is pretty nice of course just
like a regular native app that works
offline it'll always work it doesn't
require you to build a separate package
though you didn't have to put anything
in an app store you didn't have to go do
a dance and pray for the update gods to
let your new version through it's just a
website but it's immersive and it's
exactly the same code that you would run
on any browser obviously this works in
every browser but it gets supercharged
in browsers that support progressive web
apps browsers like chrome opera Firefox
and Samsung's ass browser so they're
progressive in two ways websites become
progressively enhanced with new
technology you just start from the same
base of stuff that always worked and
used add new stuff in this isn't broken
Khan
on browsers that don't support the new
stuff they also come become
progressively Appy that is to say they
become apps because you choose to
upgrade them in your experience to be
apps all these capabilities are
available all occur including push
notifications so I don't even have to
have it on my home screen in order to
get re-engaged through push
notifications but I can do that too for
more on that I recommend you check out
Owen Campbell Moore's talk on YouTube
it's also worth noting that these things
install instantly there was no sleight
of hand there when I tap that button and
sat and said added to homescreen that
was true it was already available
offline
there wasn't a process to wait through
and that's because the same resources
that are getting used in that full
screen experience are the ones that you
were already interacting with by the
time that we decide to prompt you to
keep it as a user the site will have
already cached that stuff offline you
also don't have to worry about finding a
login or digging it out of Evernote
document or somewhere in your Chrome
password manager someplace it uses the
same cookie jar what we're doing here is
using the web superpower which is URLs
to bootstrap a deeper experience with
users over time you don't have to choose
web or something engaging the web can be
something engaging not to get there we
have a quality bar and the first part of
that quality bar is to make sure that
the icons on your home screen are things
that are actually good icons and to do
that we introduced the web app manifest
format and the web app manifest is a
lightweight JSON file that you can host
centrally on your site and it contains
metadata that we need to understand what
the app like behavior of your site is
going to be it needs a few properties to
ensure a high quality user experience
first this is the Washington Post's
manifest file first we need a short name
which is to say what you're gonna see on
the home screen we need a long name so
that we can give the users more context
it'll have to have some icons including
one that's at least 144 144 pixels so we
can provide a high quality
and high DPI devices you can provide a
start URL which is the URL that gets
launched when you tap on the icon you
can tell us which mode to display it in
in this case standalone and for that
splash screen you can configure the
background color obviously using the
background color property the other part
of the quality bar is that we require a
serviceworker for progressive web apps
users expect apps that are on their home
screen to be reliably fast they have to
start instantly and service workers are
a requirement as a result to get the ad
the home screen prom airhorn accom had
to make sure that the URL listed in the
start URL on the manifest will work
offline surfers workers are supported
today in Firefox Chrome Opera and in
samsung's browser and Microsoft
committed this week to implementing
service workers in edge I'm very excited
about that
so service workers what are they well
they're programmable local proxy in the
browser for a lot more on that you
should check out Jake arts and Bald's
talk which I think is already up on
YouTube so let's see how it works
traditionally you need to traverse the
network every single time that you want
to put pixels on the screen and that can
fail particularly on mobile networks so
we're gonna have to make that transition
from the browser to the server at least
once right
but once we're there and we've got
content back to the user we can install
the serviceworker asynchronously in the
background but once the serviceworker is
downloaded and installed it will
intercept navigations and from there it
can hand back content directly from the
cache that is to say you can boot the
document without going to the network
you can do the same thing for content
and you can check for updated content on
the fly you can provide a loading screen
or a spinner to say hey I'm getting you
new stuff well showing the user the old
stuff this is what the best native apps
do and we can do it now too if we get
new stuff back from the network we can
send it back to the document and show an
updated UI this is pretty good this
allows us to be reliable in the face of
transient and flaky networks we got
pixels on screen without ever having to
go to the network
it's also worth noting that this
behavior isn't something that we baked
in it's not a one-off it's something
that you wrote the developer of example
comm in this case provided the service
worker code they can choose what to do
in each of these cases it's super
powerful so the life cycle goes like
this because we don't want you to break
the web by requiring service workers
again progressive enhancement for the
win the first time you go to a page it
doesn't have one that's okay but once
you do decide to install one and it
downloads in the background it'll get an
install event and that install event is
a chance to go cash assets offline once
you've done that and you've told the
browser hey I'm done installing you'll
eventually get an activator then just
before the next transition or navigation
if you happen to go idle at some point
the browser will kill the service worker
and reclaim the resources that it might
be using but the next time that it's
needed say the handle affection vent we
restart it and send the event then the
way to think about service workers is
that their progressive enhancement for
the network level so we're now - at the
point where between manifests and
service workers we can build
applications that deserve to be on the
home screen they can be trustworthy that
can be reliable even on flaky networks
you can always load the app shell
instantly and you can show the stale
data or UI state while you're going to
the network to get new stuff to the user
I think this is an underappreciated
advantage that native apps have had over
the web until now we don't trust the web
because it isn't reliable and we don't
know which pages to trust even if it
were by pulling some tabs out of the tab
and onto the home screen and ensuring
that those applications have to meet
this quality bar we now have a way of
communicating to users that these apps
deserve to be on the home screen and we
can do it without mangling our URL
structure or putting something in a
store so think of a site that you use
every day I think that site is probably
going to be a painful experience to try
to use in the commuting scenario when
you might happen to be going into a
train or going underground
but now think of some content that you
really want right now you want to check
something on Wikipedia that you've never
looked at before it would be a real pain
in the butt to have to go get that from
a store why should I sit there through
an application install to get that so
web sites are painful for continuous use
and native apps have been painful for
upfront one-off use so why is that I
think it's because native apps have been
able to amortize the cost of that
upfront download over multiple
interactions so there's a tipping point
at which you use an app often enough
that the lack of variants in the time it
takes to load the app and get to the
content that you want tips the balance
in favor and you don't feel the pain of
that upfront install quite so much with
service workers and progressive web apps
we've brought that power to the web
without having to give up that
lightweight first use the web is now the
best way to transition occasional users
to engaged users it lowers your
acquisition costs and it gives you the
same great reliability that native apps
have always had so progressive web apps
are websites that have earned the right
to be on the home screen by delivering
trustworthy performance so this stuff
has been pretty new for a while and
debugging it's been a pain over the last
couple of months one of the teams has
been building a new tool called
lighthouse it's a verification engine
that helps you verify that your site
meets the progressive web app insulation
criteria it automates checks to see if
you've got a serviceworker if your thing
works offline if it has icons that are
the right size all that stuff it also
verifies a bunch of things that are
fiddly to try to determine without a
real browser running and it does this by
automating Chrome so it works at the
command line but what you see here is
lighthouse wrapped in a handy Prem
extension these are the shop results you
can get it on github today and even
though it's in a bleeding edge state
where it only works in dev and canary
versions of Chrome it saved me tons of
highly recommended if you're building a
progressive web app so the Washington
Post built a progressive web app you
might have seen it yesterday
it's an incredible reading experience
and I'd like to introduce Chris new end
a senior engineer at The Washington Post
who's been involved in bringing both ant
and progressive web app reading
experiences to their users
hi I'm Chris Quinn and I've been working
on making amp a first-class citizen of
the Washington Post publishing platform
so our newsroom really loves speed and
performance literally we have monitors
all over the newsroom that display
average page load times for desktop
pages for a mobile site and more
recently our amp pages so I want to talk
a little bit about that so as a baseline
our responsive mobile site it loads in
about 3,500 milliseconds and based on
data since we launched with amp we've
noticed that it's more than twice as
fast and when we see our content served
from the amp CDN it's well under the one
second espoused by the L in the rail
performance model it's impossible to
ignore the performance benefits of amp
but amp does have some limits not having
custom JavaScript means that amp renders
consistently fast and feels fast for
users but it's also difficult to build
interactive content and that's something
publishers really like to do like
visualizations and quizzes so how do we
bridge this gap as we seen from previous
talks PW waves don't have these
restrictions they're normal websites
that are progressively enhanced with new
features and it's up to us as developers
to design and build the experience we
have full control over what we want to
do so in designing our PWA we don't want
to simply recreate our existing mobile
site we took some inspiration from our
native apps and some inspiration from
our amp pages and we use this tech demo
as a chance to rethink what's possible
on the web today so can can we switch to
the video
all right so we open up a browser and we
navigate to appear calm /pwa so in
sections load they start caching stories
for offline reading when you tap on the
sections that you're interested in those
sections will also become available
offline as a result of this caching
tapping on an article feels instant
because it's coming from the cache and
not from the network you can also swipe
back and forth to move between articles
in the same section and that feels
instant - but what happens if we go
offline so we go into airplane mode and
now you can see that sections which I
haven't visited yet are marked as such
but the sections that are in the cache
can still be viewed
so lastly if we keep using this app
chrome will eventually prompt us to keep
it to my home screen so let's go back to
it ah there we are now you can add it to
the home screen and we've got an icon
and launching it from the home screen
brings me to immersive version of The
Washington Post reading experience but
we didn't actually have to ship a
different app or upload it to the App
Store so in building this app we wanted
to make sure that the app show was
really light so because application
assets are a major factor in load time
and we still want to design for browsers
where we can't rely on an installed
serviceworker and to do that we've made
the decision to forgo libraries and
write the app in bare-bones JavaScript
and the overall applications shell is
only 280 K sounds kind of big but that
includes scripts CSS images fonts than
manifest resources and that's everything
to load the app offline on a 3G
connection on a first visit experience
is responsive in 3 seconds
we're already working on improvements to
shave off more time so how does it work
what we're doing is we automatically
cache each section the first time that
is visited and dirt that's during the
time that the user would typically
scroll through headlines and if you
swipe to the next article what's
happening is it's a cache hit
so the user doesn't see that you know
you're going out to fetch another
article or another piece of content it
just appears on the screen instantly and
that removes the mobile connection
variants from the load time equation so
on top of that if you're on the subway
and you lose connection for a few
minutes you can you can keep reading you
don't get the offline dinosaur so one
thing to note is that even when it's
service workers intercepting content
fetches we want different caching
behavior for different types of content
naively caching all the articles might
result in displaying stale content and
we don't want to waste the users that of
downloading something that they're not
interested in so to give readers a great
experience we looked at all the network
calls that we had to make such as our
application assets our section metadata
and article content and we handled them
through the service worker differently
based on their usage characteristics we
took advantage of some great tools
namely sw-precache in sw-toolbox
which you can find on github to help us
manage that caching strategy so let's
take a look at the configuration we use
with sw-precache so highly dynamic
content like the section listing goes
through the network first and that way
the user doesn't miss out on breaking
news like the top stories that changes
pretty fast but in the case of a flaky
connection we fall back to the section
list in the cache but article content
doesn't really change as often as a list
of articles in the section so what we do
here is we employ the fastest caching
strategy where we look up the article in
the cache fetch the content and return
whatever comes back first the network
fetch also updates the cache so that's
the next time you do it you don't you
know see stale stale content so with
respect to images those aren't really
gonna change so so we don't go to the
network at all if it's in if it's in the
cache well why bother
so in the case of no connection we try
to fail gracefully by providing some
visual cue that uncashed content is not
available and through the magic of
service workers that's what makes the
apps to work and now we have the same
offline reliability of native apps in
our web experience
so this experience looks quickly in as
you can see from the waterfall when the
service worker installs it begins to
fetch content for articles that there's
so there's always something to read
despite this pre loading though the
overall sides load the whole experience
the app shell the articles and images is
just over a megabyte and the user didn't
have to go through the App Store to get
this offline ready experience so we also
have a native app and it features some
of our best content and works reliably
offline but to get it you have to go to
the Play Store you have to accept some
permissions and then you have to
download it and that's about 40
megabytes which is great if you're on
Wi-Fi but that's a pretty hefty toll if
I'm on cellular so in contrast to the
web experience I can't use this app at
all until it's fully downloaded wopo
comm /pwa gives me content instantly and
it's also available offline which seems
pretty great something to keep in mind
is that service workers are constrained
by the web same origin model earlier we
saw how amp enables the edge of your
site to extend outward into other hosts
like the Twitter or the Google News amp
readers and the Google amp CDN that
powers many of these page views and when
users see a Washington Post article in
one of these contexts they're absolutely
experiencing Washington Post
storytelling even though it might not be
served from Washington Post com
so once users are already on Washington
Post comm it's a it's possible to
install service workers to give them
some really cool features but what about
users that have never visited the site
before so let's look at one user flow
Alice Costa news.google.com
she sees a Washington Post amp particle
front and center so she clicks on it or
taps on it and this loads instantly
because of amps clever restrictions and
the smart freeloading that enables
Google News to adopt it with confidence
next Alice taps on a link to the
washington post PWA from the sidebar if
she hasn't been to washington post calm
before this might be unreliable
slow or maybe even get heard the dreaded
offline dinosaur assuming Alice gets to
the Washington Post the PWA can
bootstrap the serviceworker in
subsequent visits will be reliable in
speedy but can we do better can we get
rid of that offline dinosaur as a few
weeks ago as of a few weeks ago it turns
out the answer is yes so working with
our friends on the amp team we
identified a way for the existing amp
install service worker element to
register a bootstrap file across origins
so here at the Washington Post we're now
including this snippet in all of our amp
documents that the amp element checks
the origin is currently running on and
it finds out that it's running on the
same origin as a URL for the source
attribute it directly calls the
serviceworker registration method on the
URL provided and this means that if you
visit an amp document on Washington Post
comm the PWA will get bootstrap directly
but what if they amp documents on the
CDN in this case the element looks for
the data iframe source attribute if it
makes the call that this is a reasonable
thing to load mostly by checking to see
if the origin document for the amp file
matches the URL in the attribute it
creates an iframe for that URL and then
loads it so here's the bootstrap file
we're using on Washington Post calm
right now and as you can see it's not
complicated it all it does is load the
serviceworker registration file so let's
take a look at it so if the browser
supports serviceworkers we call the
browser's registration method to ensure
that the serviceworker jeaious gets
started downloading installing
asynchronously in the background
from here we can handle a few special
cases if our app needs to so for
instance if there's already a
serviceworker registered we can listen
to see if a new version was installed or
if it's not being used or we can also
log errors back to the server in case
the installation fails so let's look at
our flow again Alice goes in
news.google.com
she sees the Washington Post amp
and tapping on the article loads it
clicked instantly but this time it does
something different the amp document
starts to install the bootstrap file
from Washington Post com so now what
when Alice visits washingtonpost.com
/pwa instead of a slow Network
experience or an offline dinosaur she's
guaranteed a reliable instant load so it
doesn't take a lot of data to install
and it runs quickly when we're in the
browser but how about when we started
from the home screen our progressive web
apps really able to feel as fast and
fluid as a native app we took a half
speed recording of both apps starting up
and stitch them together to find out so
this isn't slow motion but you can see
that once it's installed a home screen
the PWA loads as fast as the native app
I can start either the experience out I
can start using either of these
experiences at roughly the same time I
think this is a step in the right
direction for the mobile web so for more
alternative design patterns and future
directions let's go back to Alex
thanks Chris I really love the Brett
forgets about the Washington Post's
launched it has replaced my native feed
reader which didn't support offline
weirdly I'm using it everyday what Chris
showed us is a great way to get
end-to-end reliability full of
experiences starting at the edges with
amp and getting to deep engagement with
progressive Web Apps and as a user I can
move between those experiences with
confidence amp gets me a fast first load
in progress from progressive web apps
keep it snappy ever after this is pretty
great but we can do a lot more the
approach Chris outline isn't the only
way to build experiences that combine
Anthon progressive web apps we've
prototyped progressive web apps that act
like ant viewers what's the way the
Google News viewer does thanks again to
the anthon sauce serviceworker element
it's possible for a user to experience
amp documents directly the first time
they land on a site taking advantage of
that fast first load and once the
service worker installs subsequent
navigations can serve up an amp viewer
from the local cache exactly the way
that the Washington Post progressive web
web app works today you can get content
from the same URLs but they can get much
more immersive they can get snappier
they can load custom behavior I think
this is the future of amp and
progressive web apps the web has always
excelled in providing content on demand
and now we can extend that reach even
further amortized across all the
interactions that users have with your
apps the web is now the single best way
to deliver those experiences with
low-friction in addition to some of the
tools we've talked about today and talk
to me recommended that you go check out
on youtube the code labs on developer at
Google com slash web are a fantastic way
to get started building progressive web
apps if you've got questions about these
approaches or want to chat with us Chris
and I are both on Twitter and you can
try out again the washington post
progressive web app at wat phou kham
/pwa thanks for coming and we can't wait
to see how much faster you make the web
with anthem progressive web apps</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>