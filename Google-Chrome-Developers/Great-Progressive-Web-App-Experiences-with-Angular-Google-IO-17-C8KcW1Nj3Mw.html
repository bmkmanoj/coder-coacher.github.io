<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Great Progressive Web App Experiences with Angular (Google I/O '17) | Coder Coacher - Coaching Coders</title><meta content="Great Progressive Web App Experiences with Angular (Google I/O '17) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Great Progressive Web App Experiences with Angular (Google I/O '17)</b></h2><h5 class="post__date">2017-05-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/C8KcW1Nj3Mw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning my name is Steven fluid and
I am a developer advocate on the angular
team and I'm Alex Ricky Bahl I'm a
software engineer on the angular team
our talk here today is all about how to
build great experiences with progressive
web apps and angular and we're going to
talk a secretor still give you a little
bit of background on angular to make
sure we're all on the same page then
we're going to go ahead and talk about
how we can build progressive web
applications with angular and then we're
going to get into a live demo that shows
the latest tools that we've been working
on that make it easy for you to do this
so let's get started so first we want to
really kick things off with a basic
understanding of what angular is I like
to say that angular is a platform that
makes it easy or makes it easy to build
applications with the web and I use two
of these terms
extremely explicitly I use platform
because we're really trying to turn
ourselves from being just a framework
into more of a platform and by becoming
a platform we're really focused on
understanding and taking care of the
entire developer experience from start
to finish all the things that come up
for you as a developer all the
challenges you face we want to help you
across the board and I second say with
the web because while you can build
angular applications that target things
like installed mobile or desktop use
cases we really at the core are building
with the web as we do these things so
when we talk about angular as a team
there's kind of three values that we
talk about first we really value apps
that users love to use so building great
experiences second apps that developers
love to build so thinking about the
developer experience that we're giving
you with all the tools that we give you
and last a community that feels where
everyone feels welcome and this last one
is very important to us so if we look at
some things that github actually did so
they did a state of the octave or study
in 2016 where they studied what the top
contributor projects were across github
we saw that angular is actually one of
the top projects by number of
contributors and this is something that
we were really happy about right we want
a vibrant rich community of contributors
they're not only building and
contributing back to angular but also
contributing to the ecosystem across the
board whether it's things like helping
with consulting training building dev
tools or even just building components
there are thousands of components that
have been built for angular applications
that are all about helping you build
applications more easily so let's get
into how angular is really focused on
becoming a platform rather than just a
framework so the first way that we do
this in the place that are really story
starts is around this CLI so things you
don't know the CLI is really designed to
automate all of the different processes
and all the tasks that you have to do as
a developer it starts with scaffolding
out a new application where we're going
to give you the best practices out of
the box then we're going to help you
continue your development journey by
generating things like new components
and new modules then we go ahead and we
help you throughout the development
environment by giving you this live
serving environment so every time you
hit file save we're going to do all the
translation all the compilation all the
bundling necessary for this application
that you've just saved to be live in the
browser and every time you hit save we
want that to live refresh and it's fast
as an incremental way as possible that
makes it easier for you to develop then
once you've built your application you
actually want to go ahead and share it
and so using our ng build command you
can actually take all the work that
you've done and put it into a state
that's minified and as small as possible
ready to ship and we really focus on
making this digit older that we produced
by the CLI as easy and as portable as we
can make it last
we feel that testing is a key part of
the developer experience so we use tools
like protractor and karma under the hood
to give you all of the tools you need to
be testing your application from day one
every component that we give you
automatically comes with tests out of
the box by the CLI so the other thing
we're really focused on is IDE
integration with our language services
so the angular language service is a
service that runs on your computer and
gives your ID additional information
about what's going on and so you may be
used to traditional HTML completion
within your ID when you load a HTML file
but when angular sees an incoming
reference
from one of your components we can
actually establish a firm link between
these things giving you completion of
all the properties that exist within
your component but not only that because
we use typescript we can actually be
type aware with all the completions that
we give you and so we understand the
objects a little bit more inherently we
can give you additional support because
of that extra tooling we also have very
strong integration with data there are a
lot of different companies that
integrate with data in different ways
many companies integrate with firebase
due to its strong capabilities around
real-time data some companies are
starting to have graph QL capabilities
maybe they're using an Apollo back end
with an Apollo front end which has great
support for angular or many companies
still have traditional restful api they
need to be pulling down in parsing JSON
but regardless of what weight you're
integrating with your data angular has
integrated first party support for
pulling in streaming and then updating
the views with all that data as it's
flowing in there are a lot of integrated
solutions that angular is trying to do
for common developer problems and one of
my favorites is internationalization the
world is getting bigger right we need to
be building applications for broader and
broader audiences and doing so can
really dramatically improve the success
and the engagement that you get from
your application and so angular has
internationalization support built-in
you just add an IE teen end tag to any
of your templates and we're actually
able to automatically extract all of
those things in what's called an X list
file an excel file is an industry
standard translation file that you can
give to an internal translation house or
to a third party and they'll give you
back translated files which then we
build into the angular application at
Build time so and because we don't do
this at runtime we're actually saving
all of those performance challenges that
might happen if you were trying to swap
out these translations at runtime
another very common developer challenge
that we see is forms you want to be
pulling in data from your users but you
want to be doing it in a conversational
way where you're giving users
information about what's going on
whether or not they're providing right
information at the right way
live as they're entering data and so
whether you're building your validation
reactively with a reactive driven forms
or whether
you're doing it directly in your
templates we really support both the
common as well as a lot of the very
advanced usage patterns within angular
where we're going to give you a semantic
understanding of the model that comes
from your forms and combine that with
the ability for you to express rules as
well as CSS styles that then show up
directly within your components as the
user is interacting with them and so
it's really easy to reflect the state of
your application as it exists to your
users another thing that we're really
focused on as a platform is making
things better under the hood so between
angular versions 2 and versions 4 we
actually did something pretty dramatic
under the hood we rewrote our entire
view engine which is what your code
looks like after it was compiled and so
without changing a single line of code
when you updated from version to version
4 you saw about a 60% reduction in the
file size of your generated code and so
this is something that we really want to
continue doing as we continue to evolve
angular it's looked for ways that we can
make your applications better without
asking anything of you as developers so
this is actually a chart that one of our
community members created and what they
were trying to show here was because
they dreamt the reduction in their file
size was so dramatic they believe that
within a few versions their file sizes
might be negative which would be a
little bit funny to see another modern
thing that we do is we really look
across the ecosystem and in particular
we look at the standards that are
available on the web today and one of
those emerging standards is called
server push or oftentimes called HTTP to
push and so what HTTP to push allows you
to do is it allows you to send either in
your index file or in your headers of
your requests haiya you're going to need
some additional files in order to run
this page successfully and what that
means is your browser can start
downloading all the files that needs to
run your application without waiting for
that first round-trip to complete and
we'll see how this technique can
actually make your applications faster
sometimes cutting seconds off of your
load time we also help you target many
different modalities for delivery
because we focus on building
applications that are very portable so
we're giving the dist folder that it's
static can be hosted on really any
server anywhere across the internet but
we're also focused on other Modell
one today we're going to be talking a
lot about PWA s but we also support
things like installed mobile with ionic
or with native script we also support
desktop use cases with a tool called
electron which is basically shipping
down a browser as well as a node
instance and then connecting the two and
running your application on there and
what this does is by having access to a
node instance you can suddenly from
within your angular application get
access to things like the filesystem or
anything that would come from a native
system that may not be traditionally
available via the web a great example of
a company using angular and a lot of the
tools that we're offering is shopstyle
so they've built their web application
as an angular app and then they added
angular Universal to it
angular Universal is a technology that
allows you to run your angular
application on the server side and then
render it out to HTML increasing the
perceived performance of your
application and also adding capabilities
that improve things like SEO or screen
scrapers such as Facebook and Twitter
they've also recently announced that
their application is now a progressive
web application and so when you visit
their website you're going to see all of
the pages faster on every repeat load
and you're going to get a more reliable
and engaging experience so I now want to
we've talked about angular I want to
talk about how we can build even better
experiences by looking into progressive
web applications on the angular team I
really feel that progressive web
applications are a big deal in ways they
improve the lives of both developers and
users at the core progressive web
applications are about building a more
engaging experience for our users in
three ways that we're going to talk
about a few different times today so
we're going to talk about applications
that are more reliable so if I have a 2g
internet connection or maybe I have an
unreliable connection where I'm going in
and out of service progressive web
applications can help with that we can
also build applications that are more
performant and so that we give a better
user experience it's going to be better
more engaging by giving a faster
experience and lastly we can be more
engaging by creating notifications and
push notifications that allow us to
interact with our user even when they're
not using our application so our goal on
the angular team is to make your
applications better and so we're doing
this in regard to PW A's but
providing angular aware tooling that
allow you to more easily build
progressive web applications that are
customized and built based on the code
that you're already writing so our story
really starts with the serviceworker
when you look at what the CLI is doing
under the hood we're providing you an
entire build pipeline for your
application and there's one flag right
now in the CLI called serviceworker true
that adds the serviceworker
automatically to your application and
with that tooling we're actually looking
at your application code looking at the
code that's generated by web pack and
then using that as the configuration for
the serviceworker so we know which files
we need to store offline in terms of
your application code then when the user
is making requests to your application
the serviceworker lives in the middle of
those requests and is acting as a proxy
so that instead of waiting for the
server you can actually respond
immediately giving a much faster
experience for users and because the
serviceworker is the ultimate
decision-maker there you as an
application developer can decide if you
want to go to the network or if you want
to go to the local cache in order to
serve out those files we also handle
notifications following the best
practices so there's a prescribed way
that you need to as a good citizen of
the internet handle incoming
notifications to the user such as
displaying a notification at the top of
the window if you're on mobile and we
handle all those things automatically
for you
using our ng serviceworker service we
also allow you to do all the
registration for push as well as we give
you an observable that lets you know
whenever a new push notification comes
in so let's talk a little bit about
vision for the future so angular
serviceworker and all of the tooling
that we're going to show you is
available today but we really have a
more audacious goal on the angular team
we really feel that at some point in the
future we're going to make these tools
smart enough and we're going to make
some awesome enough that we can make
every angular application a PWA
out-of-the-box we really do feel that
the benefits of building a PWA are so
strong that if we can empower with great
tooling every angular developer to build
tw is by default that's a really great
world where users will ultimately
benefit today we're going to number demo
a number of different
rulz so we're going to look at adding a
taking a static CLI application that
we've built we're going to add a service
worker to it then we're going to make it
route aware then we're going to go ahead
and look at all the dynamic content that
the application is pulling in on how do
we cache those things then we're going
to go ahead and add a service or excuse
me an app shell which will as I said
increase the perceived performance of
our application then we'll go ahead and
increase the performance again by adding
HTTP to push and we'll finish things off
by making things more engaging by adding
push notifications to our application
with that I'm going to hand it over to
Alex awesome thanks Steven
hi everyone as I said the beginning I'm
Alex Ricky Bob I'm a software engineer
on the angular team I worked on a couple
different parts of our platform I work
on HTTP the angular HTTP library I work
on Universal which is our server-side
rendering component and I worked on the
angular Service Worker which is our
implementation of a serviceworker in the
browser
and aside from kind of those specific
things one of my goals on the framework
is to make angular an awesome tool to
build mobile and progressive web
applications so that's what I'm going to
show you today we're going to take this
little demo application I've built and
turn it into a fully fledged progressive
web app so this is the ng store it's a
store for superheroes so we sell masks
and superpowers I don't know how we
managed to ship you a superpower but we
can do that and so let's take a look at
this application under the hood I'm
going to jump into vs code and let's
look at the app module now if you've
written an angular app before this
probably looks pretty familiar if you're
coming from angularjs or you're just
starting to use angular this is an NG
module ng modules are the building
blocks of angular applications we use
them and compose them together to make
larger and more complex things so here
you can see we're importing HTTP module
which gives us HTTP support and we're
talking to firebase with that and we're
using the angular router and we're
actually using the angular router in a
kind of a specific way we are lazy
loading every single route in this
application and that's actually one of
angular's best practices for performance
we never want to ship code to the user
it's not intended to render something on
the screen right away and so I built
this application with the angular CLI
that Stephan will talk
earlier and if you've used the CLI
you're probably familiar with ng serve
the dev server that you mentioned when
ng serve does is starts up a process
that watches your code and when you make
changes it recompiles on-the-fly and
refreshes your browser so you can kind
of live edit debug build your
application so I built this app with ng
serve who are actually not going to use
it for the work that we're going to do
to make this a P Double A and that's
because a lot of the tasks that we have
to accomplish happen after the time we
take our applications production build
write the CLI produces our disk folder
with all the production assets that
happen before we deploy the web server
and so I'm going to be using this little
run script here that does a production
build of the CLI and then runs an HTTP
server in the district tree and in your
applications you probably have a little
bit more sophisticated of a build system
to do the steps but I'm going to use
this because we can see in one clear
place where everything is happening
let's jump back to our application here
and talk about what we're going to do as
Steven said
angular PW A's are reliable they're fast
and they're engaging so those are our
three goals we're going to make this
application reliable fast and engaging
and reliability is really about
separating this application and making
it independent from the network because
our users are on planes or trains or
submarines they're places without
internet or what's like the internet and
they need to load this application
they're going to install it to their
home screen and when they hit that
button they expect the application to
load like a native app so you don't
expect it to kind of wait or get caught
up with Network requests so to make it
reliable we're going to take all of the
assets we need to load this app and move
them to the device with a serviceworker
then to make it fast we're going to take
advantage of two different techniques
it's already using angular best
practices but we can go a little bit
further so we're going to add an
application shell which is going to
improve the perceived latency when
you're loading this application and
we're going to use HTTP to server push
to deliver all the assets we need to
load it before the browser even knows
the requests them and finally to make it
engaging we're going to add support for
push notifications for example if we
ship
someone in order we really should be
able to give them a notification that
lets them know that their package is on
the way and they're getting their new k4
mask so let's go ahead and look at the
tools that we're going to be using to do
this and there are two main ones the
first is the angular service worker now
if you've used a service worker before
you're probably familiar with
sw-precache and sw-toolbox which are
tools that the chrome team publishes to
make generating service workers for your
projects easy there's a new one that
they came out with called work box so
you may want to take a look at and all
of these tools work in a similar way
they generate a service worker which is
specific to your application it reads
your application configuration and spits
out a JavaScript file that you load in
the browser the angular service worker
is a little different it ships with a
worker script that we can just deploy
wholesales on to our web server it
doesn't know anything about our
application to start with so we'll also
provide it with a JSON configuration
file that lets us declare all of the
assets and all of the resources that our
application needs to load so the second
set of tools we're going to be using are
the ng PWA tools and this is a set of
tools we've been working on to kind of
automate some of the more configuration
heavy parts of building progressive web
apps you can absolutely do everything
we're going to do today without these
tools but I really recommend you use
them because it'll make your life a lot
easier so I have these installed already
we don't need to run that let's go ahead
and jump in and set up our serviceworker
right we're going to work towards that
first goal of making this application
reliable there are three things we need
to do with the serviceworker the first
is we have to take that pre-built script
that it comes with and copy it from the
serviceworker install and node modules
into our disk directory string a copy
from node modules angular serviceworker
in the cinah directory called bundles
and the script is worker basic min jf so
we're going to copy this into disk and
you have to write this down there
instructions on the serviceworker
repo on how to do this so we're going to
copy the pre-built worker into our site
awesome and now that we have it there
now that we're serving it we can need to
actually register it in the browser
and there are a couple different ways we
could go about this one of them is we
could just register it in the index page
but we need to be a little careful about
doing this if we register it in index
it's going to immediately start trying
to download all the assets that it needs
to make this application work offline
but that will happen while the app is
loading and so we'll have two kind of
different uses of the network competing
with each other and will slow down the
initial load so really what we want to
do is wait until angular is done
bootstrapping and then register the
serviceworker and we can do that in our
main TF file here we have our platform
browser dynamics bootstrap module call
this is what loads the angular
application and bootstraps it in the
browser and you may not know what this
call actually returns a promise and so
we can wait for angular to finish
bootstrapping and only then do we
register the serviceworker using the
navigator thoughts serviceworker that
register api and remember the script is
worker basic in jf and if we love this
on a browser to support service worker
it will work great will download and
install the angular worker but if your
browser doesn't this call will crash
right we'll be calling register on
something which doesn't exist so we need
to surround this with some feature
detection and check whether this API
actually exists before we try to call it
not every browser out there has
serviceworker yet and if they don't
that's okay our application is not going
to break right it's just going to not
have the benefit of offline caching and
that's called progressive enhancement so
now that we've copied the worker script
into disk and registered it it's time to
configure it so what kind of
configuration does it actually need
let's take a look at what it takes to
load this application here we have some
CSS assets that we need some JavaScript
some images to display we also have this
initial request for the home route right
just flash the worker needs to know that
that is a route of our application and
should we serve with the index file and
finally we have some data coming from
firebase right the Cape sale and the
products they're not baked into this out
we're loading them from a database and
so we need to tell the service worker
half how to cash those as well we have
to be a little bit careful with data
right it changes frequently so we should
be a little more specific about how we
want to cache it and when it should
expire so to get started doing this
we're going to use one of those PWA
tools that I talked about and this is
called ng u the U stands for universal
SW manifest and if I just run this
without any arguments it's going to read
the district that CLI built and produce
a static configuration that tells the
service worker all of the assets in our
application and how to catch them in
particular it's going to include a
content hash and what the content hash
does is let the service worker know when
it's time to up those those files so if
you deploy a new version of your app
with a new manifest and some of your
content has changed angular worker can
notice and we'll redownload and recast
those files in the background so next we
need a routing configuration and we can
write that by hand but we can actually
just give the tool our application
module and because it understands
angular it can read this and figure out
what our routes are from the application
module itself and so here we generate
the routing configuration as well and
that leaves us with those URLs from
firebase write those ones we have to
describe ourselves and so what we want
to do is jump into our application and
create an ng SW manifest file that's
angular service worker manifest in our
source directory and here we can specify
a dynamic caching configuration which
will let us cast those firebase URLs and
this looks a little complicated but I
promise you it's not so what we're doing
here is declaring a group of URLs that
will have a caching policy applied and
we can decide what that policy is so
we'll call this the firebase group and
we really want to match the firebase URL
and we don't just want to match the root
of firebase we want to match every URL
under this space so we'll match it as a
prefix and then we get to decide exactly
how the angular worker should handle
this data one thing we might want to say
for example is
cash it for about an hour we also want
to set a lemon on it we don't want to
fill up the user's device with all of
our products that we sell and finally if
the if the it's a cash gets too full
right we need a way to expire things so
we have to tell the service worker how
we want to do that
I recommend police recently used caching
or LRU with the most important decision
we get to make is how we want the worker
to optimize for our data one popular
choice is to optimize for freshness this
is great for data that changes really
quickly it tells the service worker to
go out and get it from the network
always unless the network is down so we
always have up-to-date data but if we
happen to be offline we can use the
cache to fall back but because our data
doesn't change that often
I recommend caching for performance so
what this does is tell the angular
worker it's okay to use the cache to
speed up request we don't always have to
have the freshest data so it can go to
the network only when the data is not in
cache or when it's to sale and our tool
knows about this file and can actually
merge the static configuration that we
wrote or that generates with the dynamic
configuration that we wrote and so we're
going to take this and paste it into our
build script here so we're going to
generate a serviceworker manifest from
our app and the last thing we have to do
here is actually write this out to disk
so we write out this JSON file that the
serviceworker knows to expect that was a
lot that happened really quickly so
let's just walk through it real quick
first of all we copied the pre-built
worker script from angular serviceworker
and node modules into our app then we
registered it with navigator service
worker register and finally we generated
a manifest for it so let's see what that
did in the browser if i refresh the page
here we can see that angular service
worker downloads that installed and it's
up and running for this out and if we
come back to the network tab and reload
we can see it start to work right no
longer are we going out to the network
to get all of these JavaScript
SSSs right even the images are cached
the only thing that's not our firebase
URLs
what happened well this is the first
time the service worker saw those
requests they weren't in its cache but
if I reload the page everything is now
coming from the cache this application
no longer needs the network to start up
even that initial home request comes
from the Service Worker and we can prove
it
by hitting the offline button in chrome
and we reload will see our application
doesn't care whether there's a network
here that's reliability for you the next
oh yeah yeah that's awesome alright so
next let's talk about making us that
fast with app shell and to show you what
an application shell is I'm going to go
in and turn off JavaScript in chrome and
I'm not doing this because I expect the
end user to have javascript disabled I'm
doing this because in between the time
the index page downloads and the time
all your scripts load and angular
bootstraps the user will be effectively
running in a browser without JavaScript
and they'll see your page as it would
look and on a MacBook this is like you
know a half a second or less but on a
mobile device the user could be staring
at the screen for a few seconds and it's
really not pretty here we have a blank
empty screen with a little loading text
up on the top and if I were a user who
didn't really understood how this work
under the hood I would think this
application is broken it's not doing
anything it's just sitting here I'm
supposed to see my app I just see this
loading text right no indication that
it's actually loading anything so let's
fix this and we can fix this by using
angular Universal to generate us a new
index page that has our application
already rendered and we can do this with
another PW a tool called NGU app shell
and like before we pass that our app
module we're passing it just the type
script file we don't have to worry about
setting up a build first and we run this
it's going to generate a new index page
for us now the first glance this looks
great it has all of our application CSS
it has all the HTML that we want
otherwise render and this doesn't take
JavaScript
but the problem is it's actually done
too much this is the entire Home route
it's gone to the firebase and it's
downloaded our dynamic data right it's
rendered out the product lists and all
that but we don't want that in the index
we're going to save that index and push
it to our web server and cache it all
over the world and our data changes more
frequently than we deploy the
application what we really want is not
the display the home route but to
display some kind of loading route right
so we can go and write one in our
application and I've actually set this
up already so we have a loading module
which registers in loading route which
shows a loading screen component with
this h3 here and you could go and
imagine having a fancy CSS animated
spinner here I'm not great at animation
so I just have at h3 and this module
isn't actually installed on our
application right we don't actually need
this loading route in production what we
want to do is insert it into our
application shell and we run this will
generate that new index page but this
time instead of the home route we render
our loading route and so we can take
this command and paste it into our build
script and set it up
all right Renda Sh here we're going to
generate a new index.html with an app
shell so I'm just going to format this
so it's a little easier for us to
understand what's going on and the last
thing we want to do is actually write
this out to disk index at HTML we're
going to replace the one that the CLI
generated for us with the one that we
generated with an app shell and so let's
start this up and I'm going to go in the
browser I'm just going to leave
javascript disabled but I am going to
remove the old serviceworker because
we've updated our code and we want to
see the effect normally it would update
in the background but this is faster so
we expect to see when we refresh this
page we expect to see instead of this
loading text we expect to see our
material toolbar at the top and some
better indication that this app is alive
and running on the page so we refresh
that's exactly what happens this is
static there's no JavaScript still but
this is a much better experience for our
user this is an application that's there
it's awake it's running it's loading for
me right I just looks like I expected to
so when we turn on JavaScript again
we'll actually see is angular bootstraps
on top of this and will render the home
route right on top perfect that's what
we want it shows the loading screen
until JavaScript downloads and then it
renders angular fantastic so that's one
of our techniques for making this
application faster next we're going to
look at HTTP to server push and the best
way I can show this to you is with a
trace so I actually pushed this
application as is to firebase and
rendered it with web page tab and if you
think seven seconds looks like a long
time to load an application you're right
and that's because this is a really low
bandwidth high latency Network and kind
of a mid to your device this is a real
world test of an app and so firebase
delivers our index page here it's blue
square in about two seconds that's
pretty good kind of hard to shave this
down anymore and the browser immediately
realizes that it needs some other
resources to render this page
so it downloads the CSS file and for
JavaScript files and about six seconds
in angular bootstraps an angular loads
the router and the router reads your
route configuration and discovers hey
there's this lazy route that I need to
render I need to go and get more code
from the server so it fetches this lazy
chunk that's good we didn't download any
code that we didn't need to render this
application we did manage to make it
take almost seven seconds to render this
app and we can do better and we know we
can do better because we know the
resources with this page you think to
load even if the browser doesn't and so
we can just send them to the browser
anyway before it out and that's what
HTTP two pushes about so with firebase
you do this by writing some JSON
configuration and we can generate it
with our last and you tool of the day
ngu firebase push and just like before
we passed in what our application module
is and when we run it it spits out the
header configuration for firebase and
this sets up the header that Steven was
talking about that describes which
assets are needed for each page and are
pushed down and the thing I want you to
notice here is the Home route pushes the
first lazy chunk and the cart route
pushes the second one we've used our
knowledge of angular to figure out
exactly which lazy routes are going to
be loaded when you go to each route and
so when you run that through firebase
the trace looks a little bit different
we're still loading our indexes about
two seconds but this time even before
it's done we start receiving data for
all of the other routes sorry all of the
other bundles including our lazy chunk
and by the time angular bootstraps
around five seconds this chunk has
already been on the device and is ready
to go
so we can load our app in about five and
a half seconds instead of seven that's
awesome that's a lot faster
whoo yeah
all right and so the last thing we're
going to do to this app is we're going
to make it more engaging with push
notifications so let me talk to you a
little bit about how push works on the
web it starts with us in our application
registering to receive push notification
so we're a user we're using the app we
hit a button that says yes I want you to
push data to me and asks for permission
we say yes that's okay what we get from
that is a subscription object that
defines an endpoint that our server can
use to send data to that user that's the
URL and some encryption credentials and
we would send that to the server and
save it in our database and the next
time we need to send data to that user
we could get it from the database and
use an NPM package called web push to do
the right things with a push protocol
and deliver a message to this user but
we actually have no guarantee that the
user will be using our application at
the exact moment we push data to them
and so what the browser does is it
delivers that message to the service
worker and the service worker can handle
it in any way that it chooses one thing
it can do for example is display a UI
notification so on a desktop here that
I'll show up as a pop-up in the upper
right corner on a mobile device that
shows up in your notification tray the
service worker could also check whether
an applications tab is open and if it is
it can deliver the data to the app and
then the app you can do whatever you
need to update the UI maybe you show a
little badge on one of your icons up
here saying hey you have a message so
let's set this up the angular service
worker supports this out-of-the-box all
we have to do is turn it on so we go
back to our manifest the dynamic
manifest that we generated and we're
going to add a push section and all
we're going to do here is that show
notifications to true and this turns on
those UI notifications it tells the
angular worker whenever you get a push
display UI notification with the message
in it that makes it really easy to
configure what UI notifications you want
to see from your back-end and now that
we've done this we have to actually
register to receive these notifications
and here again we can take advantage of
angular serviceworker because it's
angular aware
it comes with a service that we can use
to interact with it so we can import
that and inject it into our app so we're
going to import from the angular service
worker and the service is called the ng
service worker and if you've used
angular you know we probably need to
provide a module to make this work so
we're going to import the Service Worker
module as well and we can add that to
our app module and now we can inject the
service so let's add a constructor to
app module and inject the ng Service
Worker into it so we do this with
typescript give it the right type that
angular will figure it out and there's a
few things we can do with this API we
can ask the service worker to check for
new updates of the app if it has one we
can ask it to activate it we can check
the service worker logs or ping it to
make sure it's there and we can also
register to receive push notifications
and we do have to pass one critical
piece of data which is an encryption key
and this makes sure that we're the only
one who can push data to our users so
we'll pass an application server key now
you would normally generate this with a
web push package on NPM I have one ready
to go because that's boring and now
let's go ahead and subscribe and what we
get back is a subscription and the
subscription object is the thing you
send to the server that identifies this
user and lets the server push data to it
so let's take a look at what it looks
like I'm going to call to JSON on it so
we sterilize it another thing we can do
with this API is actually ask the
service worker to tell us whenever a
push message comes through so if our
application happens to be running we can
get the data and deal with it ourselves
so let's console log out got a push and
we'll save the message let's go ahead
and run this
and jump over to the browser now I have
a confession to make I don't actually
own a superhero store so we don't have a
back-end that you can push data to you
when you ship orders but that's okay
because we can use the feature in dev
tools under the service worker tab to
emulate a push event and simulate what
it's like to get a back-end pushing data
to us let's go ahead and reset this and
make sure that it's deleted and we
reload the page the first thing we
should see is we actually get our push
endpoint logged out and this is that
object I said that you would use to push
data to the user so it gives us a URL
and our encryption keys that we can use
with the push protocol and now if we
jump into our tab and emulate a push
event you can see the worker gives us a
nice UI notification up here I can do it
a few times if I reload the page it
still works
clear this out and if I go back to the
console the service worker is also
sending us a message saying hey you've
got this notification and what this
means is in your application in your
back-end you can configure not only the
UI notification to send to show to the
user when you push a message but you can
also set up exactly what other data you
want to send down in case the
applications open so it can handle the
push in a more engaging way and then
helps us bring users back into the
application over time so with service
worker we've made this application
reliable with an app shell and with HTTP
to push we've made it faster and with
push notifications on the web we've made
it engaging this is now a fully fledged
angular progressive web app I'm going to
turn it back over to Steven thank you so
much that was awesome
if you can go back to the slides as well
so what's what's next for you as
developers if you want to take advantage
of this so we've actually pushed all of
the code he wrote and all of the links
and guides to this tool onto github so
we've got that top link there I'd also
recommend you take a look at a guide
written by Rob Dodson about debugging
service workers because service workers
fundamentally shift a couple of the
paradigms on how you develop
applications in terms of how it
refreshes how it reloads and so
understanding how to debug service
workers can be extremely helpful
so with that go ahead I hope you all go
and build serviceworker and progress the
web applications with angular please let
us know on Twitter if you have feedback
if you love it or you hate it and thank
you so much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>