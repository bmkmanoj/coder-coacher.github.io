<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Progressive Web Apps across all frameworks - Google I/O 2016 | Coder Coacher - Coaching Coders</title><meta content="Progressive Web Apps across all frameworks - Google I/O 2016 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Progressive Web Apps across all frameworks - Google I/O 2016</b></h2><h5 class="post__date">2016-05-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/srdKq0DckXQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello IO my name is addy Osmani
you are you might have heard of
progressive web apps and it might seem
like they went from being this great
idea to now being talked about
everywhere sort of escalated kind of
quickly now for many of us in this room
maybe you're working on an existing app
or you're thinking about the next step
you're going to be building maybe you're
building it with a JavaScript library or
a framework and maybe you have
progressive enhancement in mind because
you want to make sure that the
experiences you're crafting we're at for
as many users as possible
we're gonna keep that in mind today now
before we continue is probably useful to
remind ourselves what a progressive web
app is so progressive web apps use
modern web capabilities to deliver app
like X periences they evolved from pages
in browser tabs to top-level items that
exists on your users home screen and
they exhibit reliable performance now
this is an app called smaller pictures
that I've been working on it's basically
a photo app that lets you compress
images on the go and it's got features
like the web app install banner splash
screen offline support and when I got
some Mountain View I thought it'd be
useful to test this app out so I took a
picture of the bathroom in my hotel
something that I discovered after doing
this was that that bathroom actually has
a better github contribution graph than
I do
kind of
now you might be wondering well our
progressive web apps unique to Chrome
they're often talked about in the
context of the Chrome browser and the
answer is absolutely not in fact if you
take a look at opera on Android you'll
see that they've got a strong
progressive web app story as well
they've got things like the web app
install banner working splash screen
offline support thanks to Service Worker
and it's not just them if you take a
look at Firefox and Android as well
they similarly got a lot of explorations
in this area going on at the home screen
features offline support whether I
install banners being experimented with
at the moment when you're building a
progressive web app and you have
progressive enhancement as sort of a
core tenant of the experiences you're
trying to craft they just work for
everybody regardless of whether they're
on Safari on iOS or you know they're
trying to look at your content from an
area that might have seriously limited
connectivity when you're crafting these
experiences with architectures like
server-side rendering in mind it just
makes sense to be able to ship faster
experiences for everybody you might also
be wondering well our progressive web
apps a polymer only thing I do this year
we did show a first class experience for
building progressive web apps using
polymer but you can use any text AK to
create progressive apps in fact over the
last few months we've seen an increasing
number of really large apps launch using
progressive web app features the first
one is five miles sort of a Pinterest
meets Craigslist
they lost a full progressive web app
with an application shell architecture
at the home screen splash screen this
was built using angularjs and they found
that their add to homescreen experience
led to 30% better conversions
similarly Flipkart they saw three times
more time on site with their progressive
web app 70% better conversion rate from
their ads and home screen users that's
an app built using react and just last
week we saw C Leo app which is a local
market app for buying and selling goods
locally this is an app built using react
Express flux uses universal JavaScript
they found that their average Sethna
test session length inside the
progressive web app equals native and
they also found that the user
acquisition costs were ten times cheaper
than native because they used web push
notifications they saw improved user
retention and they used server-side
rendering and found that that reduced
bounce rates with things like sharing
posts and buying ads so today we're
going to talk about how to build
progressive web apps using react angular
and ember j/s before we do that let's
talk about waiting waiting is something
that we all have to do as a part of our
daily lives it's sort of this
frustrating thing you could be at a
restaurant waiting for someone to bring
you a menu or waiting for someone to
bring you your food and twenty or thirty
minutes could easily pass by and you're
still you know you're still wondering
should I should I go up should i p--
should I ask someone for a menu should I
ask someone if the food is ready you
could be waiting maybe an hour two hours
you know it gets to a point where you
start questioning your life choices and
you start wondering you know should I
just eat my wallet instead on the web
the equivalent of this is your users you
know considering leaving your site or
your app and that's not something that
you want so the key differentiator
between the old web and the new web is
native apps have got reliable
performance and that's something that
we'd like to be able to strive for with
the experiences we're shipping on the
web so how do we deliver native caliber
features while still being able to use
javascript libraries and frameworks well
before we talk about that there are a
few key moments that we need to keep in
mind when it comes to user experience
and performance the first is is it
happening time to first paint now this
is when you're showing your user a
splash screen or a loading indicator
basically some feedback that
communicates your navigation has started
in your page next you have time to first
meaningful paint this is the isn't
useful moment this generally focuses on
paints of above the full content
headline text something that they can
actually use and find useful then you've
got time to first meaningful interaction
so is it usable if the user goes and
starts
tapping around your UI is something
useful actually gonna happen now at i/o
this year we announced a new tool called
lighthouse lighthouse is a Chrome
extension and a CLI the checks that you
have your progressive about features in
check
it also has initial support for loading
performance metrics also on the slide is
web page test it's a tool that's been
around for quite some time but it
basically helps you performance profile
your sites on real world devices with
different types of network connectivity
profiles now one metric that both of
these tools look at is the speed index a
metric that looks at how visually
complete a page is and for the apps that
we're going to be looking at today the
rack taps the angler apps the ember apps
our targets on cable or going to be a
speed index of a thousand so ideally
things loading in under a second on 3G
our target is three thousand so under
three seconds and on repeat view using
serviceworker
our goal is to make sure that we're
loading things as close to zero as
possible if it's under a thousand that's
great but as close to zero as possible
so at i/o we're talking about killing
the offline dinosaur ideally we want to
be able to build experiences where
you're no longer having to play that
game you're actually giving a user
something valuable I spent two hours on
this slide and make poor life decisions
I'm sorry the underpinning of this is
serviceworker it's basically a script
that runs in the background separate
from your page response to events like
network requests and basically gives you
the ability to define really
well-crafted offline experiences now
serviceworker gives us the opportunity
really to start rethinking our
application architectures one such
architecture is the application shell
architecture and the idea here is that
we try shipping down the network as
quickly as possible
just to fit the content necessary to
load up our application UI so things
like two of our the drawer maybe some
cards and then later on we dynamically
populate that view with our content now
this type of model works particularly
well for single page applications but
it's nuanced you might be working on a
content heavy site and it might be more
important for you to get you know
texts down to your reason your users
first so just keep that in mind when
you're evaluating your options when it
comes to these types of architectures
but if the application shell
architecture does make sense for your
app the way that you achieve some of
these improvements in addition to
serviceworker is doing things like
relying on critical path CSS so in
lining the critical styles for your
application shell in the document head
and then a synchronously loading in the
CSS and JavaScript meaning for the
current view we can then use things like
the async attribute on scripts and
libraries like load CSS from the
filament group for being able to sing
Christine the content that we need and
the performance winds of such a model
are actually quite stark which will take
what you'll see if the six working there
is on repeat view it's almost instant
this is like the simplest version of the
application install architecture we come
up with and you've got instant
performance for the repeat visit
compared to the first visit where it
took much much longer so let's talk
about react react is a UI library for
creating interactive stateful and
reusable UI components built by Facebook
users a virtual Dom try doing the least
amount of Dom manipulation try and
keeping your components up-to-date and
it works really well on both the client
and the server now I'm a big fan of
hacker news I use it every day and I
thought you know maybe it'd be useful to
be able to try using hacker news offline
unfortunately a hacker news doesn't work
offline on the site you'll get the
dinosaur if you try using it by the way
this is the this is the dinosaur that we
have over in the mobile web area you
might notice that it has seems to have
like four legs for some reason and two
arms I just wanted to clarify on behalf
of the chrome team the back two legs
have been deprecated but they haven't
been removed just yet
plan on so back in 2014 hacker news
actually announced that they now have an
API an open API that anyone could go and
build a hacker news client with and that
API was based on firebase this is a
real-time API anytime someone goes and
makes a comment you can actually stream
that latest content through
your hacker news clients and so I
decided to go on github and try to find
out if anyone had been hacking on a
really interesting hacker news client
and I found this one by Johnny Buchanan
this is a really nice client it lets you
take a look at all the different views
available in hacker news you've got you
know new comments show ask jobs and
it'll highlight any time a new comment
is updated or someone has gone and
edited their comment unfortunately this
didn't work offline either and so I
thought you know it would be kind of
interesting if we went in and explored
what it would be like to take this
complex react app and turn it into a
progressive web app that worked offline
so the first thing we needed to do was
make it responsive I know that sounds
silly but it's still quite a common
thing for people to forget this one step
so we went in we optimized things like
the amount of viewport real estate being
used on mobile we wanted to make sure
that it actually used up as much space
as possible on iOS and on Android and -
we wanted to avoid things like
overlapping menu items so we fixed those
as well all of this is just done using
media queries and it's nothing
particularly special the next thing we
added was the web app manifest so when
is this project and I noticed that they
had a really tiny favicon and that
wasn't gonna cut it so I redid all of
the artwork in sketch and exported all
the icons out and set up a web app
manifest so that we could launch this
thing from the home screen and get a
splash screen this is what the manifest
looks like it's nothing you know
particularly crazy but we basically have
a background color set for the splash
screen and we have another color set for
the theme color and we've got our icons
defined in there as well now this
application is actually a lot more
complex than it might initially seem we
have this large set of complex real time
data being streamed to the client and
then we have this application UI this
skeleton that we're using across all of
our different views so we're gonna split
this problem into two parts the first is
caching our application skeleton and the
next part is gonna look at content
caching now for caching our application
skeleton we're gonna use two libraries
sw-precache which is a built tool that
will go and help you pre cache all of
the assets that you need for your first
application shell render and then
sw-toolbox which is a library for
handling all of your dynamic views and
content that might get rendered later on
now in this application like many react
apps we're just using webpack behind the
scenes for our module bundling but
precache been actually added on after
the fact so here I've just got some NPM
scripts set up for this project
I've got sw-precache setup is just
another step that I run after my build
is completed and I'm configuring it
using a pre cached config file and my
package adjacent so this is what the
config file looks like it's basically
importing in tool box it's importing in
some rules from runtime caching and I'm
able to configure things like what other
files I might like to have cache inside
there now in runtime caching I can
specify what other origins I would like
to be cached so in this case I've set it
up to cache anything coming back from
firebase from the hacker news firebase
API and I can also set it up to cache
things like Google Fonts or anything
coming back from the Google CDN my last
step is going and actually registering
my serviceworker so I have this
boilerplate code to my index file and
just make sure that it's registering the
serviceworker that's being generated by
w pre cache and once i go and i load up
my page and i look at a repeat view i
can see that all of my static assets are
now being served from the serviceworker
cache and dev tools so I go into
airplane mode and I check out this app
and I'm happy I've like I've already
opened this up before I'm starting to
look at content I've seen previously but
there's something wrong here
although my application shell
consistently renders really really fast
offline as soon as I close that app I'm
still in airplane mode I launch it from
the home screen I get this no content
the reason for that is the firebase is
offline support is limited to the
session that the user currently has as
soon as you close that off and you try
you know going and relaunching from the
home screen you're not going to be able
to get that same session data back you
need to actually cache it a little bit
separately so that leads us on to
content caching and something I've spent
the last four weeks trying to solve so
firebase generally you know because it's
real-time it works using WebSockets this
is just expecting some WebSocket frames
in dev tools you've got little bits and
pieces of comment data and metadata that
you might use to construct a comments
page
now I first thought you know maybe an
interesting idea to store anything that
comes back here in index TV
unfortunately I'd forgotten the indexdb
is the worst API known to man and should
probably be burned luckily there exist a
number of really good abstractions for
working with index TV things like local
forage exe IDB by Jake Archibald and so
here we are inside of our react up once
again I'm just consuming the firebase
API the same way you would today and I
thought you know maybe I could be a
little bit clever what if I built some
middleware that would basically proxy
anything coming back from the firebase
API to index DB and we just stored that
it seems like a not terrible idea right
seems like it would be be fine
unfortunately what happened there is if
you went and saw any story on the top
stories page and you opened it up about
10 to 15 seconds later you'd end up with
three or four thousand records in index
DB you wait another minute it'll grow to
four or five thousand because you're
dealing with real-time data constantly
updating index DV as you go on mobile if
you open up an app where you've had like
a large large number of records stored
because you know you've been looking at
lots of pages you want all of them to
work offline what will happen is they'll
you know in this app we had to iterate
over the entire collection it ended up
grinding chrome to a halt and that just
wasn't good enough so I then saw it said
okay well maybe I should rethink this
problem a little bit what if we just
used web workers so I was using local
forage I thought okay I'm gonna batch
all of my writes for this application
and only try storing them maybe you know
every 30 seconds instead
unfortunately indexeddb is still really
bad when it comes to these types of
problems and I found that that that just
still wasn't good enough for this out
and I had this revelation I was I was
sitting in an airport lounge and I
thought well I don't really need this
data to be entirely fresh I don't need
it to be updating every second so I have
every single comment and I realized that
firebase actually has a REST API and the
REST API allows you to basically go and
a static version of content from a JSON
endpoint and that's something that's
much much easier for you to cache so
imagine we have our Comment page and we
have all of these different comments I
just got like Jason endpoints for every
single one of them that I can go in
cache and that's what we do so I
introduced an offline mode into the the
react hacker news client Here I am I'm
still online I've launched my app and
I'm just gonna go and take a look at one
of the Google articles here you see that
this is a page that has a lot of
comments there's a lot of content here
we're scrolling we're scrolling maybe
I'm you know on the tube or on a bus or
something but I still want to be able to
view that content offline so I'm going
into airplane mode I'm just gonna
relaunch that app and with content
caching in place now using the REST API
I can actually cache all of that data in
the serviceworker cache API instead of
just using index DP and as you'll see it
just works I can load up any of the
pages I've previously visited and
they'll just work fine offline I ended
up delaying a 300 person flight 10
minutes just so I could get the pull
request in for this feature because that
was that was how happy I was I got this
working and one of the lessons there was
that I had to rethink what I wanted my
offline experience to be the technical
side of getting serviceworker setup and
caching setup that wasn't hard he was
just crafting the right user experience
next we're going to talk a little bit
about universal rendering so Paul Lewis
put up these really interesting graphs a
few weeks ago he said that you know in a
JavaScript based render you're usually
reliant on all of the script to be
downloaded parsed and evaluated before
you can render the page this ends up
wasting a lot of time when the HTML
arrives so when you would give the user
something meaningful on the screen
something slightly better is the
situation where we see a lot of
frameworks moving in at the moment you
have a server render with hydration
where you send a view to the user the
downside of this is that you're still
reliant on the JavaScript to actually be
loaded up before someone can interact
with your application this can result in
a little bit of an uncanny valley where
the user sees that you know the
application but they tap and nothing
actually happens somewhere that would be
amazing to see a lot of frameworks move
to is this idea of progressive rendering
and bootstrap where you send a
functionally viable but min
view in HTML your JavaScript and CSS and
the app progressively unlocks more
features as the user starts traversing
and navigating around it so I'd love to
see more of us moving that direction for
the server-side rendering portion of the
react HN up react router was just
amazing worked really really well on the
server we found that realtor reuse you
know most of our outs with very little
effort we just put together a very quick
Express server to get this set up some
of the little lessons that I learned
along the way we're just making sure
that we properly guarded ourselves
around Global's this app was still
making use of things like local storage
and session storage so we had to guard
ourselves to that wouldn't fall over we
have to minimize reliance on things like
the Dom the previous author was doing
things like using the Dom to parse out
the hostname so we had to switch away
from doing that now here's where we
ended up we started off in a place where
on cable we had a speed index of 2063
and by the time we'd added serviceworker
and server-side rendering and we used
all these content hashing techniques
together we got to a place where we had
a speed index of almost a thousand so
close to perfect now on 3G you know
where it's even worse we're still in a
pretty good place we're in a place where
we started off with speed antics of
almost a four almost four thousand and
we end up a little place where with
serviceworker caching and content
caching we've got a speed index of 1400
now these type experiences this is
something that you know I've done just
over the last couple of weeks on an
existing large react codebase so if
you're in a position where you have
something similar and you want to turn
it into a progressive web app it's very
very possible the tools are just there
so I encourage you to try that out next
up we have angularjs so angular is a
framework to spin around a very long
time it tries to tackle building complex
applications originally focused very
much around being data first and using
declarative HTML and data binding I'm
gonna talk about angular 2 but before we
do that I know that there are still
people that build on angular 1 or have
existing legacy angular 1 apps and you
might be wondering well a lot of this
progressive web app stuff great does it
work with angular 1 yes but with caveats
so I tried building an angular 1.5 app
just
and straightness and I started thinking
of what app I would build I initially
thought of building like an app that
would show me the nearest places I could
go and skydive then I realized that I
don't skydive the closest things to me
skydiving is probably zooming in on a
Google map really really fast and you
know that's basically the same thing so
I'm fine with that
so this is the app that I built it's
called cherry built this in about an
hour or two
this is using angular 1 as you can see
we've got at the home screen features
splash screen offline support with
serviceworker
unfortunately the downsides this app is
that it just doesn't meet our
performance budgets you take a look at
you know on 3G you take a look at you
know where your goals are for fast first
paint he's taking twenty five hundred
milliseconds for first paint in this app
our speed index metrics are you know
eight thousand eight thousand four
hundred that's crazy we shouldn't be
taking so long for our users to actually
be able to start using this application
luckily with serviceworker in place we
are able to slash these numbers in half
so if you're in a place where you can't
you know in the near term move over to
rewriting your application to use a
modern framework I would consider using
serviceworkers still going to get some
wins there but it's not going to be
quite as good as something that has
support for server-side rendering and is
developed with mobile in mind I think
this to angular 2 so angular 2 is
component based uses directives and has
an improved dependency injection model
and the angular mobile team have
recently been focusing a lot of their
time trying to make it easier to build
progressive web apps using their tooling
so we're gonna talk a little bit about
that now to get started with angular 2
apps a lot of the time they'll recommend
using the angular CLI this does
everything from setting up your
typescript and typings for you
bootstrapping your app using System GS
to load up your app and so we're just
gonna use that to very quickly scaffold
up a new app now one thing to keep in
mind is a new flag called mobile now
what mobile will give you is all of this
when you create a new app it's going to
give you a few extra things that help
you make a progressive web app things
like going and scaffolding you out a web
application manifest a build step to
generate your application shelf your
applications route component and service
worker support for application caching
so things like add to homescreen are
possible you'll still get the splash
screen you'll still get your add to
homescreen icons all of those are
fleshed out for you and the manifest
doesn't look you know too different to
the manifest you looked at today it's
exactly what you'd expect it to be now
in most of the time when we're
developing apps we use a site called
real favicon generator Don net to
generate our icons for us it just avoids
you having to handcraft these yourself
next up we've got the application shell
so by creating a new project with the
angular CLI and the mobile flag the
application already has a build step
configured to go and generate you an
application shell from your root
component so here we're gonna just use
the main component that angular CLI
created for us to create our application
shell we're going to do something with
angular material so let's say that we
will just add a toolbar to this
application
so we npm install the dependencies we
need for this toolbar and then we
register the toolbar inside of our main
holo mobile component in this case so
you see that we've got application shell
directors that are gonna help us with
setting up the application shell we've
got our toolbar in place this isn't
particularly useful just yet so we're
gonna go and we're going to add in a
proper toolbar in there inside of our
template so it says hello mobile so far
this is fine this isn't particularly
exciting what is exciting is these two
little helpers these two helpers are
shell render and shell no rendered and
these are kind of badass so shell render
will allow you to define any UI that you
want to splay on the screen before your
main angular bundle has completed a
synchronously loading in shell no render
is what's going to be a splayed after
the entire application is fully rendered
out meaning that you can define your
application shell declaratively right
inside of your component so in this case
we can do things like just make sure
that the toolbar and at least a loading
spinner so that thing that we wanted to
achieve for first meaningful paint is in
place and then we can use shell no
render for anything else that comes
after the fact now the angular mobile
tool kit comes with support for
generating a serviceworker that will
automatically cache your assets for you
it doesn't yet entirely support things
like dynamic caching but it does support
you know caching for your static assets
and you can go and you can start using
these on serve using the prod again
using the Prague
I've been hacking on a little dribble
API client called berry using this stuff
and I found it particularly good for
that offline support wasn't very
difficult to get in place and using the
CLI it's actually going to scaffold you
out one of these files in the
backgrounds this is an angular Service
Worker manifest it contains basically
all the files that are going to be
cached as well as a hash that allows
service worker to know whether or not
they're stale or not so what are the
numbers look like we're gonna take a
look at an angular weather app that the
team for and working on and this uses
the application shell model it uses
angular CLI uses a lot of the tubing
that they've recently been working on
and with lighthouse these are the
metrics that we currently get so first
paint is about a thousand eighty three
milliseconds that that could be better
speed indexes 2271 and the speed index
on repeat visit is five hundred
ninety-nine now these aren't these
aren't terrible numbers these are
actually pretty good numbers but we can
do better so recently the angular mobile
team have also been looking at offline
compilation now in angular 1 template
compilation can happen many times during
your applications lifecycle and angular
2 tries to move some of this work into a
build step making it a lot more
efficient so offline compilation happens
during build step as I said and it no
longer happens during the browser so we
convert things like templates into code
on the server so we don't have to ship
the compiler at all and what this leads
to in terms of application performance
is some stark differences fast first
paint is happening at 479 milliseconds
speed index is almost exactly where we
want it to be it's very very close to a
thousand and repeat visit is close to
nothing you're getting what's basically
an instant application on repeat visit
this kind of Awesome now we also wanted
to take a look at what server-side
rendering would look like for these
applications because we can do we can
still squeeze out a little bit more
performance here so getting to your
users getting your user the first view
really really fast is kind of critical
these days and angular vert universal
basically helps you achieve this with
pre rendering on the server
so the way this works is whenever user
goes and they click on a link to your
web app angular Universal is going to
server-side render the initial response
get it to you so user has at least some
UI in front of them they can take a look
at a couple of seconds later it'll then
synchronously load in the rest of the
bundle
it'll bootstrap the client will take
over this is sometimes called hydration
and it just means that you lead yourself
to having a pretty good perceived low
time performance overall some of the
interesting things that I came across in
this experience in the last couple of
weeks was that this notion of user
events being stuck in on candy Valley's
pretty much consistent across like
reacts angular and ember
even with server-side rendering your
first view you're gonna still end up in
places where you know your user can
still end up clicking touching pieces of
UI where they're trying to have things
happen and they'll just be stuck until
you know your entire content bundle has
ended up there so in the angular
community gap events is the term that
they use here so things that the user is
going to try accomplishing while they're
still what we're waiting for
bootstrapping to occur but thankfully
the angle team have been working on an
interesting solution called pre boots
that basically allows you to respond to
and playback events so you know I'm not
saying this is the the perfect solution
to this problem it's kind of very
interesting though if the user does try
interacting with your app as soon as it
has finished bootstrapping
it will replay all those events for you
so that they still you know they're not
having to redo work it's kind of
interesting so to get this set up again
we use Express we just import in angular
Universal which doesn't take a lot of
work and this is what the numbers look
like we started off with a speed index
of two thousand six hundred and forty on
3G once we've added an offline
compilation service worker Universal
rendering we're down to almost nothing
you're in a place where Universal
rendering is and has made a huge
difference this is very much true of the
react app we were working on earlier as
well server-side rendering makes a huge
difference really huge difference and as
you can see with serviceworker in place
again repeat visit it's close to nothing
users are going to feel it being instant
now the angular mobile team are working
on making all of the developer
conveniences around this stuff a lot
more low friction some of it thought
some of this work is still very much
early on they're working on improving
the serviceworker support adding
pass-through caching support a data
savings mode making sure that they're
looking at HB 2 and how that interacts
with serviceworker
and just improving the docks so if
you're working on an angular 2 app at
the moment go check out mobile toolkit
and finally we have ember Jas now ember
is a framework for building ambitious
web applications utilizes components
routing in amber is a core tenant there
and the member router similar to the
react router works for just fine on both
the client and the server now
interestingly frameworks have a bad rap
when it comes to performance right
henrik jorts aghhh
recently said in his opinion the data
for angular and this was talking about
angular 1 and ember flat-out disqualify
them for mobile use and this is mainly
down to bundle size like ember as a
framework still has a relatively large
bundle size now the amber team
acknowledged this a couple of months ago
and they've been looking at how they
could improve the situation with mobile
in mind so they've taken a look at both
first boot and repeat boot for this
problem now on first boot they're
looking at fastboot so their solution
for server-side rendering and I I really
love fast food I'll talk about it in a
minute and on reapeat both are looking
at serviceworker they're also looking at
some other interesting ideas things like
string loading which basically means
shipping javascript modules as strings
so that you only pay the evaluation cost
for the modules that you're using
and projects felt for stripping back
features that you're not using an ember
I was trying to think about what
progressive app I'd build for this and I
came across the idea of building a
puzzle app that would just say go
outside when you're complete it's maybe
not the best idea but ended up on super
cool blog which is basically a blog app
this is the final thing that we end up
building for ember basically this is an
offline first amber application that
works instantly meets our performance
targets use a server-side rendering
works without JavaScript and they
another way so let's take a look at how
something like this can be constructed
now applications in ember are crafted
using the ember CLI and you go and you
just install it let you you know
scaffold out your application
architecture a very basic file structure
go and serve it you get a very very
basic app out at the end of that now
routes and making sure that your routes
are right and you have a good routing
setup will make things like server-side
rendering so much easier so we make sure
that we in this application we've got
our routes figured out we've basically
got very simple routes we've got one for
different categories we've got going on
Lona display articles for and all of the
content for this application actually
just exists in JSON files I could be
using a back-end an API of some sort I
could just be caching stuff coming back
from firebase in this case I just have
all of my data locally and it just makes
caching a little bit easier so this is
what our very very basic application
looks like at the very start so we've
used ember CLI we've scouted out our
views added some CSS we're just you know
using templates to loading the content
there's nothing particularly complex
just yet now the first thing we're gonna
do is adding the web app manifest
similar to the other sites it's not
particularly difficult it's like
something that takes five minutes a lot
of the time so we add this in and this
just makes sure that when did the user
comes to trying to add the site to their
home screen or launch it they're able to
get home screen icons splash screen
icons in place next up we have Service
Worker support now about a year ago the
ember team said that they've been
watching some of Jake Archibald Service
Worker videos and they were really
excited about them one of the things
they wanted to do and this is this is
true I think of a lot of frameworks is
they want to take web platform features
and try to make them usable for their
users with as little friction as
possible and automate that process as
much as they can so ember wanted to make
this something that's free they're not
quite yet there with their baked in
support for serviceworker but luckily
the community puts together an add-on
for ember CLI called broccolis
serviceworker now one of the cool things
about broccolis serviceworker is it
happens to build on top of serviceworker
toolbox so that thing that we've been
using for our react app earlier on
now the configuration for this looks a
little bit like this basically we're
inside our amber environment I'm just
saying that I'd like to make sure that
debug messages are enabled and the
service worker is enabled but you
actually get control over a lot more of
my offline experience being able to set
things like never network first URLs
past include and exclude and when it
comes to Service Worker toolbox you
actually get quite a lot of control over
different network strategies we're able
to say well I'd like you to go out to
the network first and then fall back to
the cache or use the cache first and
then you know fall back to the network
or try to erase both strategies and make
sure that whichever wins actually
delivers you the content you've got a
lot of flexibility there so once we have
off lines for in place I'm able to
launch my application in airplane mode
and just view any of the content I've
previously seen I can go and read
articles I can go and look at menu items
and all of it just works offline pretty
seamlessly now next up we've got
server-side rendering with fast food now
I've got to be completely honest when it
comes to server-side rendering and
adding it after the fact to a framework
level application ember has got this
just down to an arts when it comes to
fast food I found this like the easiest
thing to setup and it took very very
little configuration so fastboot is
basically a middleware for rendering
amber apps on the server the idea is
that you know in a traditional client
side app your browser's first of all
gonna have to request a bunch of
different static assets from the asset
server and while those are loading your
users are just gonna end up having to
look at a white screen so the way that
they solve this with fast food is by
running an instance of ember in node on
the server when a request comes in we
already have the app warmed up in cache
and memory and they just tell the URL
you're trying to reach that you know you
want it rendered on the server and send
it back down so you install ember CLI
fast food an add-on to ember CLI and the
one thing I have to keep in mind here
was just making sure that anything I'm
using that's going to be fetching data
from other origins or an API takes in
mind that you know you're going to be
running this code both on the client and
the server so you end up needing to you
an isomorphic or Universal fetch
implementation and thankfully amber have
got one of those so I just switched in
the app the fetch implementation that I
was using so that any time I fetched
client-side data it would work fine on
both the client and the server and I end
up with this I'm basically able to get
server-side rendering working fine this
is actually working pretty fast on
Safari on iOS as well it might not have
serviceworker support yet but
server-side rendering just works fine
now one of the benefits to this is of
course that the content for my
application is all just there I'm not
waiting for any JavaScript in order for
the user to actually be able to read the
articles you know if they're in a place
where they have limited network
connectivity everything will just work
another benefit is that this works
without JavaScript enabled as well now
you might be wondering well okay great I
can I can read content but what about
you know my user UI I spend a little bit
of time re crafting the drawer menu for
this application entirely in CSS and
that just means that my user is able to
use some UI with the content in place
even if my JavaScript bundle is still
loading with the rest of the framework
and then we've got a little bit a final
performance optimization to squeeze as
much as we can out at the very end so
this is what our index looks like for
this application it's using some sub
template helpers and one of the things I
want to add is that critical path CSS
that we talked about earlier for the
application shell so we install an
add-on called ember CLI inline content
we can figure that inside of our amber
CLI built basically for this application
it's not got a lot of styles so I don't
really need to do anything special to
get my critical path CSS I'm just gonna
in line the entire stylesheet inside of
my document head and finally we've got
that that one problem of large
frameworks still being large frameworks
and unfortunately this is something that
the frameworks still have to solve on
their own now ember before you know you
gzip it is almost 700 kilobytes in size
and I don't want that necessarily to
block rendering now ideally I would just
be synchronously loading in both
vender scripts as well as the main
application code for my app but in this
case I'm probably going to end up having
to do something like defer because amber
doesn't actually concatenate scripts for
you by default and we've also got things
like gzipping that we could probably be
doing inside of the application so
gzipping is something we can also take
care of when it comes to deferring so
the async attribute allows scripts to be
downloaded in the background without
blocking the page write the FIR claims
to do the same thing except it's
supposed to guarantee script execution
order the spec says that it should be
downloading all of your scripts together
and executing them for Dom content
loaded unfortunately in some older
browsers that's not exactly the case in
IE you know less than 10 it might
execute your second script halfway
through the execution of your first
script
yay browsers but we're still going to
just use defer in this case to avoid
blocking but uh at the very end of all
of this so we've got server-side
rendering in place we've got
serviceworker in place as well we've
taken a speed index of almost 3,000
we've trimmed it down with server-side
rendering using fastboot trimmed it down
with the optimizations we've made even
further and we end up with this place
we're on repeat visit it's close to
instant it's close to nothing now I'm
really really excited about the amber
team exploring how to bake in more of
these ideas directly into the CLI I'm
also excited about the angular team
doing this and really excited about the
react community embracing serviceworker
as a core tenant in though the
applications were building there as well
so mystery takeaways for today are do
less and be lazy if you're gonna be
trying to ship bytes down to your users
try to ship the thinnest smallest bundle
possible this will benefit absolutely
everyone and be lazy just means lazily
load in everything else that you need
after the fact design for constrained
environments you know a lot of the time
we're building things these days we're
testing things out on high-end phones or
high-end computers a lot of our users
aren't going to have that they're not
going to have a perfect internet
connection all the time they're going to
be in places where they'll have limited
connectivity maybe using devices that
are like CPU bound or you know aren't as
powerful as the things that we're
testing on so if you're developing with
constrained environments and mines
you're gonna be able to ship experiences
that benefit everyone and they'll
hopefully lead to performance
improvements there and go for foot
ggressive because now is a good time you
know looking at all the frameworks and
libraries that we've been looking at
today all of them are exploring things
like server-side rendering all of them
have got you know the ability to use
serviceworker
as a first-class citizen and have it
work well and lead to performance
improvements have it lead to reliable
performance that thing that we're trying
to hit with the rest of Web Apps
everything else everything from like you
know setting up your web app manifests
and so on that stuff is still quite
trivial to do and that's not to say that
you know incident applications with the
things that I've shown you today are the
end it's really just the beginning
there's still a little bit of work that
we have to do on both the JavaScript
engine side and the framework side when
it comes to performance after the fact
so I've been focusing on load
performance a lot today there's still a
lot of what we can do after the fact so
that when your users are interacting
with the app it still stays instant
after that so please go check out our
new progressive web app page on web
fundamentals I hope that this has been
useful thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>