<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Custom Elements Everywhere (Polymer Summit 2017) | Coder Coacher - Coaching Coders</title><meta content="Custom Elements Everywhere (Polymer Summit 2017) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Custom Elements Everywhere (Polymer Summit 2017)</b></h2><h5 class="post__date">2017-08-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/sK1ODp0nDbM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hey how y'all doin good yeah all right
cool
so this talk is going to be about my
journey to try to get the whole world
using custom elements and some of the
interesting things that I've learned
along the way so I've been at Google for
maybe like a little over three years at
this point and during pretty much that
whole time I've worked on custom
elements and web components and it's my
belief that if you're building a UI
library and you're working at like a mid
to large-size company so you want to
build whole bunch of components and
share it with a bunch of teams that are
all on different stacks that custom
elements and web components are really
like the way to go about doing that
and this story is basically would have
been advocating for for all these years
and being the point person for custom
elements and web components means I get
a lot of feedback on that idea and
feedback that you know kind of looks
like that
right so this is a tweet from a fellow
Googler who was trying to use web
components with another framework and he
said you know every few days I see
someone like Rob say that web components
work in all frameworks all of our
problems are solved and it's really
clear that no one has tried any of the
above and you will notice that this is
tweet six be of a very long list of
grievances and subordinate sub
grievances that rolled up into the
larger tweet storm so very organized and
very emblematic of a lot of the feedback
that I've gotten over the years and it
kind of boils down to this we say that
custom elements should work everywhere
right that they are based on web
standards that they are the future of
the platform so we say that and then
like why don't they right and the more I
thought about this the more I started to
wonder if like perhaps we put the cart
before the horse and we maybe get so
caught up in the fact that we could
build custom metal
that we didn't stop and spend time to
think about how we should build them in
the first place and if custom elements
and the things that we build if they are
unpredictable or they are inconsistent
does that then make it harder for
frameworks to work with them and so
that's really what I set out to find out
so I split this talk into two parts the
first is my journey to identify what a
quote unquote good custom element would
look like and then the second part is
looking at how frameworks should work
with those elements and my hope is that
by the end of this you all will have a
better understanding of how to author
your components and also what to expect
when you try to use those components
with other frameworks or libraries so
let's dive into that first point what is
a good custom element and to start this
journey I actually went to the chrome
engineer who is in charge of
implementing custom elements API in the
browser and I said to them I was like
hey do you know if there are any
reference custom elements that I could
look at stuff which you think really
lives up to the standard am I thinking
there was that the people that write the
specs and the people that actually
implement the API is in Chrome surely
they've gone and built a bunch of custom
elements and they're like these are our
ideal components and all components
should live up to these um his response
was a bit surprising because he was like
nope none that I have seen and that
really got me thinking I was like hmm
right so we need to identify the best
practices for custom elements and I'm
not really sure how to do that but maybe
what we could do is a symbol like a
crack team of engineers and then
together we could probe the depth of the
HTML spec and we uncover all the
treasures that lay within that is
exactly what we did
working with my teammates Surma Monica
and Ava we began writing a set of
vanilla custom elements so not using
polymer or anything like that just
vanilla JavaScript custom elements and
we wanted to figure out how the heck
these things should actually be authored
and along the way we learned a lot and
in fact we're still learning a lot but
what I wanted to do is go through some
of the stuff that we've you know try to
capture so far I've been doing this work
inside of an element set which we call
the
two components so the how-to components
these are a collection of educational
custom elements we're saying that this
is sort of like literate code so we want
folks to actually look at the
implementation read them look at the
comments and understand why we did the
things that we did now I want to be
really clear these elements that I'm
talking about here these are not things
that you should use in production
they're not even styled really these
won't be going on web components org or
anything like that instead we wanted to
create a resource where developers could
read the source code kind of side by
side with the comments and then learn
from the elements and understand you
know why we made certain decisions and
then take that knowledge and actually go
apply it to the custom elements that
they are building within their own
company I want to be also really clear
that like this is a work in progress
project you know don't be surprised if
you're looking at the repo we start
changing things around because basically
as we learn new ideas and it happens all
the time we learn new ideas and we bring
them to all the elements we update them
all at once so again it's not a
production thing it's not something you
should actually use the code or anything
we just want you to like read it
interpret it and think about it because
we want to do is create a resource where
we can all learn in the open and have
discussions on github like okay well you
know why should we do this why should we
not do this so if you want to check
these out you actually can the repo is
available up on github here's a direct
link i don'ts you need direct link to it
and I'd like to walk through some of the
best practices we learned as we're doing
this so I split this up into kind of
three topics we're going to try and
cover how do you deal with shadow Dom
how do you handle attributes and
properties and how do you manage events
in your elements and I want to be clear
that what I'm going to talk about today
are guidelines so these are not meant to
be like rules or laws that you like have
to follow because the web platform is
not really consistent all the time not
by a long shot and so you should always
feel free when you're building your own
element to color outside of the lines if
you need you if your element calls for
it right
you get to make that decision
but having said that I do want to dive
into some of these best practices and
we'll start with shadow DOM and some of
the things that we learned now the first
question that comes to mind when you
think about shadow DOM and you're
building a custom element especially if
you're doing it as a vanilla custom
element you're writing all the
JavaScript yourself you're not using a
library or anything is like does my
element even need shadow DOM and I have
to admit like personally over the last
maybe a year and a half I kind of got a
little cranky with shadow Dom got a
little well frustrated with it at times
and I've got the team you know polymer
team they're like dude you gotta use
shadow Dom got you shot it on when
you're building custom elements you
always got to use it and I'm like hey
you know what like shadow Dom it can be
kind of annoying to work with the times
it can be hard to redeem the polyfill it
can be a little wonky and you know what
maybe you just don't tell me what to do
I don't build my own elements okay and
so yeah like deal with it boom and so
like that is actually how we started
this process we were like we're just
going to build vanilla custom elements
we're not going to use shadow Dom we're
just going to do our own thing so the
first element we created was a checkbox
here it is very simple how-to checkbox
right seems straightforward enough it's
a single tag it doesn't have any
children I didn't see why something like
this would need shadow Dom so instead we
were like okay cool we have a JavaScript
file for element definition and we have
a CSS file for all of the styles okay
but very quickly we discovered that if
someone takes your element and you're
using a global file sheet like that so
they take your element and they put it
inside of another element that uses
shadow Dom okay well now all of your
Styles are broken because you don't have
a way of getting your style sheet into
that other elements scope I mean maybe
they can like link out to your style
sheet or you could have like a build
tool or some build process like inject
your styles into their element or
something but it basically means that
like it's up to you and that developer
to figure out how you're going to get
your style into their scope so that was
a little I felt kind of not awesome
about that but whatever and oh I should
point this X is actually really
interesting there is actually a
discussion to see if we can streamline
this
a bit so there's a thread on the w3c
github where Steve Orville a member of
the polymer team has proposed this
notion of if you have a very simple
custom element like a single tag
something that doesn't have children or
anything like that could we maybe as you
registered the element also give it a
stylesheet object and that would work
almost like a user agent stylesheet just
for that tag so this is a really cool
proposal and I and something that
actually hope we land at some point but
today this is you know this is not real
it's not shipping anywhere and it made
me realize that you probably need to
create a shadow route if your element is
going to self apply any styles and you
might have a shadow route that only
contains a style tag and that's totally
okay the benefit is that your element
starts to become a lot easier for people
to reuse they can use it outside of
shadow DOM they can use it inside of
shadow Dom right and put it inside of
more complex elements and it just works
now as we were working through this
first element a conversation kind of
popped up on my Twitter feed and someone
said I'm kind of paraphrasing the
original tweet here but someone said you
know since we have things like CSS in
js4 scoping our styles do we actually
still need shadow Dom I mean can I just
use these like fancy build tools and it
was actually a tracer guard he'll be
speaking tomorrow who responded on
Twitter and he said you know style
scoping is a really cool benefit of
shadow Dom but aside from style scoping
one of the other major benefits is Dom
encapsulation so if you're building an
element when it like creates its own
children as part of its implementation
you can actually hide that hide those
children you can hide that
implementation inside of that bowl Dom
scoping bubble and this is really
crucial for framework interoperability
and so he shared a example that I want
to walk you through because I think it's
really interesting so let's say we're
building an element and we're building a
counter so just going to say the word
count and then have like a number next
to it like count 1 2 3 and so on right
so I've got a little bit here in my
template with the word count and I'm
going to slot because I'm going to
assume that this framework a library
that I'm using my element with but there
put the number in there for me I'm going
to create two versions of this element
so the first one is count with shadow so
here I'm creating a shadow root
I'm just appending my template content
inside of the shadow root when my
element is constructed the other version
I'm going to create is going to be
called count without shadow so this time
instead of using shadow Dom at all we're
just going to stamp that template
content into the light Dom I'm cheating
a little bit because slot elements don't
work outside of shadow roots but
whatever go with it go with it and it
does all right so let's look at what
happens when we try and use this inside
of something like react so in react I'm
got my little render function here and
I'm going to try and stamp out both of
those elements I'm just going to have
react pass in the count so every tick is
just going to pass a number as a child
of each of these elements 1 2 3 and so
on
so what do we get when this renders well
you might be a little surprised the
first element looks like we would expect
it to right it's got count 1 the second
element though looks totally broken and
I wanted to dive into that a little bit
so why is that so in this first
implementation all react can see inside
of this element is just the number 1
which is put inside it there now we know
there's a shadow root and inside of that
shadow root is the word count and our
slot tag but react isn't able to see any
of that because it's not piercing shadow
boundaries or anything and this is good
means our implementation is hidden if we
look at this second element though it's
kind of more interesting because it
seems like react created an element and
then put some text inside of it and then
it catched it to the document and then
our connected callback ran and all our
stuff stamped out after the contact okay
so already that looks broken probably
not what we want but it gets a little
bit worse - so the next kick react is
going to look at this and it's going to
be like uh in my render function you
told me about the number but you didn't
tell me about this div thing here really
what does that that's not not you didn't
tell me how to render any of that so
what's going to do it's just going to
delete it so the next phrase just throws
away all the light Dom children
and now we just have the number two
inside of that element now I did some
tests and I found that other frameworks
may leave your light DOM children in
place or they may not there's really
nothing to enforce that it's just kind
of a convention that they may or may not
adopt and so what we learn from this is
if you're authoring an element that
creates children you probably want to
put those children inside of a shadow
root that's because those children are
part of your implementation and the rest
of the page should not need to know
about them so after all of this thinking
going back to the original question does
your element need shadow Dom I think it
actually probably does and even though
it can be a little frustrating to make
you kind of cranky to work with it at
times shadow Dom is really important
because without shadow Dom you lose all
guarantees of safety you know if you
want to put your element inside of
another element where you want to put
your element inside of another framework
where there's other JavaScript actors at
play shadow Dom kind of protects your
implementation from the outside world
it's the little engine that makes the
framework interoperability story go okay
so that takes care shadow Dom quick
recap there definitely if you're if
you're self applying style it's probably
on the shadow root and any children that
you create should go inside of your
shadow group let's talk about axe roots
and properties basically how does your
element handle data and reflecting state
to the outside world this might seem
like minutiae this might seem like a
very boring topic to talk about but when
it comes to framework interoperability
bugs and issues this area is actually
where I found the most problems and the
most differences across the board and
this is like a really contentious topic
actually so even the chrome team the
people who work on specs and people work
on polymer have different ideas about
how elements should handle attributes
and properties and I wanted to try and
do my best to get to the bottom of this
and just put out you know some semblance
of best practices so when we think about
attributes and properties like what
would we consider canonical behavior it
was like okay well I mean where would I
even look to figure that out
well there's HTML right HTML has aspect
and it actually if you read the HTML
spec it explains how attributes and
properties should work on elements and
so it's like okay cool well uh I guess
we'll read the HTML spec and we'll just
do everything it says
I don't know how many of y'all spend
much time reading the HTML spec and
really diving in there it's actually
pretty gnarly the deeper you go if you
dig down deep enough you'll find
inconsistencies you'll find anachronism
you'll find stuff that seems to kind of
predate the current era of
standardization like older elements like
input are just super weird so I can make
it kind of hard to just fill out what
one would consider like the best
practices but for all its faults it's
also kind of the only model that we
really have to follow so if you can make
a custom element that's mostly
indistinguishable from the behavior that
built in native tags have I think
there's a really good chance that
frameworks will be able to work well
with your component so here are some of
the best practices that we came up with
the first is that for primitive data so
strings numbers boolean x' you want to
always accept that as either attributes
or properties ideally both so someone
should be able to just walk up to your
element and call like set attribute for
a particular thing or set up property
like a corresponding property and both
of those should just work and ideally
you want to reflect back and forth
between your attribute and your property
so let me give an example of that from a
native element so if we look at the the
native video tag how do you see this
behavior because it's actually pretty
interesting
so this element has a preload property
it also has a preload attribute right
the correspond I can go to this element
and I can actually query it and I can
say all right what is your preload
property value and I'll say by default
it's auto and I can set that property to
none you'll see it's sprouts in
attribute when I do that and I can then
read that property value again and it's
actually reading it off of the attribute
and it's like okay cool that's
interesting can we like mimic the
behavior of built-in elements with our
own elements and so my understanding
from talking to spec authors is that the
way this behavior is implemented in
native HTML is that their getters and
setters for all the properties and the
getters and setters are actually like
really dumb the only thing they really
do is just kind of reflect back and
forth to attribute so Mike I'm going to
make like a fake element here called
custom video and I might get her I'm
just going to try
get the value from the attribute if
there is one I'll return it if there's
not I will return a default value right
so this is that default Auto string that
we saw this was kind of interesting
because your co-locating the default
value with the with the property with
the getter and setter in the setter
all we do is we take the value that was
passed in and we reflect that to the
attribute and because the getter is
leveraging the attribute we have now
synced our properties and attributes to
change one change the seller right
that's pretty interesting we don't have
to write any additional code we don't
have like a little underscore property
that you're sort of like managing under
the hood and all this private state
instead these two worlds are just in
harmony now so that was really
interesting and so you can see this in
action with this like custom video
element that I created here so you can
go and you look at it and basically this
thing behavior so we can read the
preload property we get the default
value out of that getter we set it we
now sort of spring an attribute and then
we read the property again it's reading
it off of that attribute so for
primitive data I feel like this behavior
actually works quite well and it makes
things very consistent so someone can
fiddle around with an element still
called get attribute on it and get the
right data there are exceptions to this
rule so you might not want to reflect
properties that are like really high
frequency so for instance the native
video tag also has a current time
property and that you know is basically
every millisecond it's updating the
current time for the video so reflecting
something like that probably don't want
to do again in the HTML spec there's
inconsistencies and quirks when there's
reasons to color outside the lines it's
generally speaking primitive attributes
and properties reflecting seems like a
good thing and it can simplify your
mental model as well right
can help you understand how to write
your component if you just do this
consistently so let's get four primitive
data what about rich data like objects
and arrays so I think this is really
interesting because I think for rich
data you probably only want to accept
that as properties on your element and
there's reasons for this also you
probably don't to reflect rich data from
properties back to attributes and the
reason is because one it's expensive to
reflect right so stringify a big object
that someone passing as a property and
reflecting that that just doesn't seem
very useful
Tomer actually used to do this like
polymer 0-5 we reflected everything and
we stopped because people were sending
these massive JSON objects down and then
we would stringify at all and reflect it
for very little game we're just spending
a bunch of time parsing and unn parsing
javascript the other reason I think you
should avoid this though is because a
serialized object loses all of its
identity so this is something that my
teammate Justin pointed out and it's
pretty interesting so if you take an
object and that object has references to
other objects I mean you call you know
json stringify on that well you just
broken all of those references they
don't work anymore so you pass that to
some element and maybe the person is
expecting you know mutating that object
to mutate some of the original sub
properties and that just doesn't work
right so if you just take the properties
you kind of avoid all this weird string
bizarre onus so definitely recommend
that all right so fragile be some
properties quick recap you know
primitive data you want it as either
attribute or property you ideally want
both and you want them to reflect and
then for rich data objects and arrays I
think you're an element should really
just accept those as properties and
they'll make your life a lot simpler
last thing I'm going to be quick about
this is events when should an element
dispatch events now this seems like I
don't know kind of a weird question to
ask but then when you really think about
it it's kind of interesting because if
you look at native built-in elements
they do not seem to dispatch event in
response to like a host setting property
or anything like that I think there's a
good reason for this it's kind of
superfluous right you set a property and
some of your element dispatches event
like well you don't need to tell me the
the value I just set it right so it's
kind of weird to dispatch an event then
and if you're not careful you might end
up causing an infinite loop so you know
you tell the host hey this property
change and if the host is you know if
you've got like a unidirectional app set
up like you're using reacting Redux or
something like that the host is like I
don't care that the property change my
model says it's this and it sets the
property and the property says hey the
property changed and the house is like
no and then you end up in an infinite
loop
so you got to be careful about that so
for these reasons I recommend not
dispatching events in response to
downward data flow so when the host sets
a property and this actually differs
from how polymer does things so polymer
is going to fire events whenever you
change properties and this is actually
what powers polymers data binding system
but because polymer does the additional
work to guard against firing an event if
you set the property equal to the same
value twice and it's okay you don't end
up in an infinite loop but if you're
running just a vanilla custom element
then I don't think there's a ton of
value in firing property change events
so then that leaves the next question
which is like well then when should I
just batch events from a custom element
in here I think what you want to do is
you only want to dispatch events in
response to internal element activity so
it is internal element activity well
this give me things like a user
interacting with your control an
asynchronous task finishing like
something loading and we're an animation
completing basically anytime the
component knows something changed and
the host does not and we need to clue
the host in you need to tell the rest of
the app hey something new has happened
this is a good time to dispatch an event
and this kind of mirrors what native
built-in elements do so last recap
really click on an event don't just
watch them and response to down where
dataflow do dispatch them when your
component has special private knowledge
the recipe app does not have I realize I
went through all of these like what
super super fast in essica as you know
we're short on time and this is by no
means an exhaustive list
many of these are things that polymer
actually does for you already so if
you're using polymer awesome right you
don't even worry about this but I still
wanted to go through the process of
documenting all of these things and just
trying to figure out you know how stuff
should work so we've been collecting all
of these best practices that we've
learned while building the how to
components and we've actually created a
new section on developers.google.com
slash web all about building components
so this is a available today now it
basically takes all of our existing
material around web components and
custom elements and it organizes it
better so we've got API primers
checklist of custom element best
practices and a few example how-to
components are up there as well
demonstrating how to actually implement
those best practices so you can check
this out here's a direct link to it and
now that we've looked at custom elements
I want to switch gears now and this is
kind of where I think the talk gets a
little bit more fun because I want to
look at the other side of things and I
want to talk about how frameworks should
then work with custom elements and this
is like a really tricky problem to solve
because like as you all know there are
as many JavaScript frameworks as there
are stars in the Milky Way galaxy this
is not you know I not anything I have to
tell you this is science to know in fact
right I thought what we could do is we
could take just like a subset of the
most popular frameworks and we could
write some automated tests for them and
we could publish those results to the
web so we could track what does work and
what doesn't work and hopefully learn
from one another and so I'm really
excited to announce another project that
I've been working on this is a new site
called custom elements everywhere making
sure frameworks and custom elements can
be best friends forever the URL for this
is available at custom elements
everywhere com so you can play around
with this and check it out and but you
got to keep paying attention of those
talk to you I'm going to just give you
like a quick run-through of how this
works so every framework on the site has
a little section and in that section I
indicate how many tests they're passing
there's a little write-up to explain
like any quirks or gotchas or anything
weird like that
I've also gone through and tried to
track down every web components related
github issue for all these different
libraries so you can you know keep tabs
on everything in one place and of course
you can go down you can click this
little button and you can view all of
the tests for the framework you can see
all right what passes what doesn't pass
so you can have a better expectation of
like I'm going to use this custom
element and pre-act or angular or
wherever this is what isn't is not going
to work
oh yeah the way my arms around apologize
all right if a framework is not
represented here it is not because I
think that framework is unimportant
we're not awesome or anything I think
all of them are awesome it's just really
hard to write a web pack
for every framework I don't have y'all
try that it is not fun okay so I have
done my best here but I would love help
from the community to add more libraries
to this site I really want everyone to
feel like the tools that they use and
that they enjoy that they you know are
fairly represented on here the other
thing that I want to point out is there
are some known unknowns to this process
like have I rigorously tested every
feature of every framework and every
permutation of custom elements no not at
all okay I don't even know all the
features of all the frameworks but I did
want to start just like having this
starting point right just to help some
of these things shake out so when we
check out how we did so I'm going to go
through these scores in alphabetical
order starting with a for angular and
angular actually got a 30 out of 30 in
the test that I ruined actually was not
able to write any tests of angular
failed I'm talk about new angular not
old angular new angular okay and by the
way like I said known unknowns okay so
some of you are using new angular and
you're running into issues please like
open a PR open an issue on github and
help me track those down write some
tests the tests that I've written so far
angular passes all of them pre-act
comes in at 24 out of 30 so pretty good
about 80% react 16 out of 30 so 53
percent and we'll talk about why that is
and finally view with a 30 out of 30
again so they're getting a hundred one
thing that I think is important to point
out is that so far I have not
encountered any major issues related to
shadow Dom so long as the custom element
is kind of following those best
practices that I talked about before in
the past this has been an area where
things like totally did not work in
particularly was like polyfill but these
tests run you native shadow Dom and
against the polyfill and so far I
haven't had any shadow Dom issues so
fingers crossed maybe we're in a better
place today that would be really
exciting let me talk about the two areas
where we did actually encounter issues
though and that was mainly around
handling data so attributes and
properties and dealing with events and
the test for attribute some properties
these mainly check that you can pass
data to an element declaratively
using a framework binding syntax I can
get the data into my element like I need
to and I'm kind of generalizing here but
I think roughly speaking there's like
two ways that you can think of doing
this in the framework land there is what
I'm calling the manual approach where
the framework has explicit syntax that
you can use to tell it hey either set up
property on this element or set an
attribute on this element but it's sort
of up to the developer to make that
decision and then there's the sort of
more automated approach where there's
really only one binding syntax and the
framework has a heuristic that it uses
at runtime to try and figure out how it
should pass data to an element so I'm
going to go through each of these and
kind of like indicate which framework is
which so the game will start with
angular this is the binding syntax for
angular so this is how you pass data to
any element or component it doesn't
matter if it's an angular component or
custom element or whatever this is what
you use and basically what these square
brackets mean is it's telling angular
set the Foo property equal to bar where
bar is like some value inside of your
angular component okay in other words my
element dot foo equals bar so not only
can you pass primitive data this way but
you can also pass rich data this way so
objects and arrays right and that's
great like we talked about before and
the best practices that's how we want to
pass rich data so this works really well
if you need to explicitly set an
attribute for any reason you can do that
as well you can add this attribute
modifier to your binding and this tells
angular to explicitly call like set
attribute on the element right so you've
got total options their angular falls
into the manual bucket you can kind of
do whatever you want using their syntax
view on the other hand is similar but
they sort of do the inverse of what
angular does so for a component that
view creates itself like a component is
written in view jf I believe by default
it will pass data as properties but when
it encounters a custom element it will
pass data as attributes so that's like
saying set attribute but because view
also falls into the manual bucket along
with angular they have a dot prop
modifier and you can use on their syntax
and you can tell it explicitly pass the
property to an element which is good
again now we can pass objects and arrays
to elements cool react on the other hand
falls into what I'm calling the
automated bucket so it has a heuristic
that it uses to try to decide how to
pass data to an element currently when
it encounters a custom element it will
always pass data as attributes for
primitive data like a string or a number
or boolean okay maybe this is fine but
when we get to rich data this becomes a
problem because when you call set
attribute and react you end up with
something like this right and that's not
very useful okay I can't do anything
with that
so in react there is not a good
declarative way to pass rich data to a
custom element you can work around this
so you can grab a reference to the
element and in like your render function
you can you know manually like set that
property on it but because there's not a
declarative way to do it react kind of
fails if you test there again this is
more of a hiccup than like a total
showstopper you still can use custom
elements with react you just got to know
about this gotcha what's interesting is
the react team is actually discussing
switching this behavior to always
setting properties when they encounter a
custom element so this is an RFC for a
react 16 I think it would be awesome if
they did this and you can check out this
github issue to kind of like follow the
discussion
finally pre-act now pre-act it's
interesting because pre act like react
uses jsx but it uses a different
heuristic so when it encounters a custom
element it will use the property on the
custom element if it is defined if it is
available otherwise it will fall back to
using an attribute so the way this works
in pre-act goes like this it just does
like a an inch x it'll say if foo in my
element use the property and it's not
okay well we'll fall back to the
attribute then we'll treat it like
configuration this is pretty cool and it
actually works pretty well as a result
pre-act passes all the properties match
mutes tests that i've written so far
they also have a pull request that's
open so that if the element that it's
working with is not upgraded yet it
and it's passing rich data like an
object or an array it'll use a property
then as well lastly let's talk about
events so the test here check that you
can declaratively add an event listener
to the Dom events dispatched by custom
elements so the way this works in
angular is anything that you put in the
parentheses there
that is the event name that you are
telling it to listen to the value then
is the handler to run so this is like
saying my element add event listener we
changed one bit okay now the cool thing
is we can use basically any event name
that we want inside of those parentheses
so we can use lowercase that we can use
caps case which is good for things like
URL changed or like Dom ready right I
think of like acronyms and things like
that
that'll work camel case kebab case
Pascal case my personal favorite apps
whole case do you not actually no no no
no no no no no no okay
view on the other hand is like basically
the same behavior as angular so
basically anything that you put after
the V dash on directive it doesn't
matter what case it's in it'll work in
view so beaut is all the tests here
react is a little tricky because react
does not have declarative syntax for
listening to Dom events so react
implements its own synthetic event
system that kind of like sits on top of
the Dom event system for native elements
they have a whitelist of events that
they know to listen for but that doesn't
really work for custom elements because
you know we could dispatch infinite
different event names right so
unfortunately this looks really tempting
but it does not work bummer
again like the attributes and properties
thing before we can work around this you
can just grab a reference to the element
inside of your render callback and then
using like component did mount you can
just manually add event listener so
again the hiccup not a showstopper but
just something to be aware of I think
you have a github issue to bypass their
synthetic event system for custom
elements I think it would be really
really awesome
if they if they did this but this is
still being discussed
I finally get to pre-act so the exciting
thing about pre-act
is that it uses native Dom events so
this right here totally works
mostly it mostly works there's like some
gacho's the only problem here is pre-act
will take everything after the word on
and call to lowercase on it yeah so like
if your event was actually named food
changed with those capital letters it
would lowercase it - food changed all
over case and maybe never hear your
event right so I realize you're all now
thinking the same thing which is that it
means it doesn't support Apple case and
I know major WTF
anyway I showed this to Jason Miller
who's the creator of pre-act and he
created a pull request to add support
for asshole case I think Jason prefers
to call it mixed case events because
he's like Canadian very polite but like
we all know what he means with that I
think we're nearing the end and I just
wanna kind of like recap some of the
things that we learned along the way so
regarding custom elements I don't think
there are really any like rules which
dictate how you must write a custom
element but I do think there are best
practices that we can start to follow
which will make it easier for us to you
know right elements consistently and
easier for other developers to then
consume those elements that we create
and when it comes to frameworks the good
news is that like most of what seems
broken today I think it's actually very
easy to fix and there's already issues
open for most of it
and if we can generally agree on how
custom elements should behave and then
in turn how frameworks should you know
communicate with them based on those
assumptions and I think we're actually
pretty close for this cool Interop
framework utopia land right seeing that
we now have libraries which get
basically like perfect scores on the
test that I've been able to write is
really really encouraging I want to
thank all of these awesome folks so the
folks who worked on how to components
with me everybody who took the time to
review the custom elements everywhere
site and the tests and also just like
hash out these best practices with me in
dachshund
and everything these are all very very
nice people who are kind enough to share
their time with me and I really really
appreciate that I also want to thank all
of you for spending the time to listen
to me today I'm really excited to see
what you all build and I hope you enjoy
the rest of polymer summit
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>