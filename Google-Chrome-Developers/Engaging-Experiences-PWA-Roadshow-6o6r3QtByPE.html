<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Engaging Experiences - PWA Roadshow | Coder Coacher - Coaching Coders</title><meta content="Engaging Experiences - PWA Roadshow - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Engaging Experiences - PWA Roadshow</b></h2><h5 class="post__date">2018-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/6o6r3QtByPE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">progressive web apps give us an
opportunity to reset our expectations
and loudly declare we can do better when
building web apps I'm Pete a developer
advocate on the web team at Google
building an engaging progressive web app
goes beyond functional and ensures that
the whole experience is delightful
making it easy for the user to do what
they need to do slapping a serviceworker
on an existing app is easy and it will
improve the reliability of the app but
that alone doesn't radically improve the
user experience it falls short of the
full benefits of a progressive web app
building an engaging progressive web app
requires us to shift the way we think
about visual and interaction design from
the conventional web patterns and
instead consider some native patterns
the team at Twitter did a great job of
this with Twitter light compared their
website with Twitter light and their
native app things like the footer that
typically exists on the web aren't there
or have shifted into other places links
still exist but don't necessarily feel
like links and navigating between pages
feels more like a transition and less
like a navigation it's important to pay
attention to detail here native apps
have given users expectations around
touch interactions and information
hierarchy so it's important to create a
consistent experience for users to avoid
creating a jarring experience I could
spend a lot of time here but
unfortunately we don't have enough time
instead as you work on your progressive
web app check out similar apps on iOS
and Android browse I take triple for
design inspiration then spend some time
browsing the material design
specification and the iOS human
interface guidelines to increase your
familiarity with common UI components
and their interaction
the idea of notifications is not new but
it's now a feature available to web apps
and a great feature to help build
engagement even when the browser isn't
open web push notifications aren't just
a chrome thing
Microsoft has indicated they plan to
support them Firefox Opera and Samsung
browser already provides support
Carnival Cruise Lines one of the world's
largest leisure travel companies wanted
to enhance how it re-engages with its
customers the objective was to send
timely customized information that did
not have to compete with the customers
inbox and worked on all devices and was
easy to act on working with mobile Phi
Carnival implemented push notifications
for its mobile web users carnivals
customers clearly feel these
notifications are valuable to them with
24% of users opting in and a
click-through rate of 42% Carnival can
now reach customers on multiple types of
devices without having to wait for the
user to check their email and possibly
miss the opportunity to book their
vacation before their hold expires as
you plan your notifications ask yourself
are they important enough to warrant an
interruption if you're unsure allow the
user to opt into specific types of
notifications inside your app with their
own notification settings users want
notifications that have timely
information offer enough information to
avoid visiting the app are personal or
contextual and in short our day altering
let's take a look use notifications
primarily for time-sensitive events
especially if these synchronous events
involve other people for instance an
incoming chat is a real-time and
synchronous form of communication
another user is actively waiting for me
to respond calendar events are another
good example of when to use a
notification the event is imminent and
calendar event often involve
people you want to avoid notifying the
user of information that is not directed
specifically at them or information that
isn't truly time-sensitive
for instance the asynchronous and
undirected updates flowing through a
social network generally do not warrant
a real-time interruption let's look at
some of the other things that a
notification should be notifications
aren't emails the intent of a
notification is to tease the user so
that they'll open up your app or to let
them complete a task without having to
open the app don't interrupt the user
for low-level technical operations like
saving or syncing information or
updating an application if the app or
system can resolve the issue without
involving the user keep it personal if
it's a chat notification tell them who
it's from
don't create a notification if the
relevant new information is currently on
screen instead use the UI of the
application itself to notify the user of
the new information directly in context
for instance a chat application
shouldn't create a system notification
if I've already got the chat window open
and I can see it let's test our criteria
against some of these notifications this
is a great notification and it hits on
all three points my flights delayed it's
timely well it's helpful now it's
precise it includes the new flight time
and it's relevant it includes the flight
information hmm this one not so good
it's probably timely but we don't know
for sure it's certainly not precise it
doesn't say which card or why it's
probably relevant but it's my card but
which card I've got a couple of cards so
how do we make it better with a few
small changes and the addition of action
buttons it becomes more precise relevant
and timely okay
it's Google+ I don't think I need to say
anything more all right this one's
timely but who's it from
and what does it say with a few
adjustments like adding an image
adjusting the title to include who the
message is from and part of the message
in the body
I can much more easily decide what I
want to do with it
now if Google started its own
self-driving car company
I hope they'd call it goober in any
event this one it's timely my cars
arrived its precise I need to act on it
and get into my car and it's relevant
it's something I should be interested in
you're gonna have plenty of
opportunities to monetize your user
experience but don't blow it by spamming
users if you spam your users with
notifications they may stop allowing
them altogether alright question it's
timely I know Mary just answered my
question it's precise because it tells
me what happened though it could be
better if it gave me the answer but
fitting that whole answer into the
notification may be hard and it's
relevant it tells me who and what
happened there are three key steps to
implementing web push and notifications
adding the client-side logic to
subscribe the user your back-end to
manage who's subscribed and trigger
sending the message and finally the
service worker that will receive the
push event and show the notification to
the user on the client we need to
provide an easy way for the user to
subscribe or unsubscribe from our
notifications but before they can even
subscribe we need to get their
permission once we have their permission
we can use the push API to create a
subscription and get the push
subscription object you can think of it
like an ID for that users device it also
includes a set of encryption keys that
we'll need later to send a payload with
our message then you'll need to send
that push subscription object to your
server and save it so that you can use
it later when you're ready to send a
message to the user when you want to
send a push message to the user we
create the message on our server and use
the web push protocol to send the
message to the push service sometimes
referred to as an endpoint the push
service is then responsible for
validating the message and delivering it
to the device if the device is offline
the message is queued until the device
comes back online later each browser
typically has its own push service but
they all have the same API known as the
web push protocol and behave in the same
way the web push protocol standardizes
the way you send a message to a user and
provides instructions on how to send
that message the instructions include
details like who the message is for how
long it should attempt to deliver the
message and potentially a payload if you
include a payload it must be encrypted
so that way it can't be viewed by the
push provider the push service receives
the message validates it and delivers it
to the appropriate browser the URL for
the post service is the endpoint
attribute from the push subscription
object that we saved earlier using a
push service allows us to leverage the
capabilities of the device and shifts
the hard work to the OS there's no need
for us to be resident in memory or
maintain a connection to our server both
of which can quickly kill the battery
only when a message arrives does our app
wake up when the message arrives on the
device the OS delivers it to the browser
which then decrypts the payload wakes up
the service worker and fires the push
event where you can handle any
background tasks and show the
notification before we go too far we
need to create a set of application
server keys sometimes referred to as
vapid keys the application server keys
are a public
and private key pair that are unique to
your application the public key will be
used in the client side subscription
code the private key is used to sign the
outgoing message that allows the push
service to validate the signed message
against your public key to ensure that
the message came from you and helps to
prevent anyone else from sending
messages to your users there are a bunch
of different ways that you can create
these application server keys you can
create it yourself with something like
crypto create ECD 8 but if they yuck or
you can use the web push library which
is my recommendation and it simplifies
web push or you can also hit web push
code lab apps what Google comm one
reminder keep your private key private
don't accidentally check it into github
or anything like that once you've got a
handle on setting up the vapid keys you
need to get the user subscribed let's
take a look at how we do that
remember these are progressive web apps
so first let's check if the browser
supports serviceworkers and push if it
does will show the web push UI next we
need to register the service worker and
grab the registration then use the push
manager API on the service worker
registration to get the subscription if
we get a subscription object back the
user has already subscribed when the
user clicks on the subscribe button we
grab our service worker registration and
call push manager dot subscribe with a
set of options those options must
include user visible only true which is
a symbolic promise between you and the
browser that any time you send a push
you will show a notification and you
need to include your public application
server key that you created earlier if
the user hasn't already granted
permission to show notification the
browser will request this permission for
you with permission granted we get the
subscription of
checked back next we need to update our
UI and send the subscription object to
our server so that we can use it later
the push subscription object contains
all of the required information needed
to send a push message the end point is
the push services URL and the keys
object contains the keys needed to
encrypt the payload typically the
easiest way to send it to your server is
to Jason dot stringify it then use an
xhr to send it up to your server when
and how you prompt the user and ask
permission to send and show
notifications is really important if the
user sees the permission prompt without
any context they're almost guaranteed to
click block and if that happens your web
app will be unable to ask the user for
permission again they'll have to
manually unblock your app by changing
its permission state which is buried in
the Settings panel sync carefully about
how and when you ask users for
permission because if they click block
there is no easy way to reverse that
decision the good news is that most
users are happy to give their permission
as long as they know why the permission
is being asked in some cases asking for
permission early is important for
example instant messaging apps or an
email client for that case consider the
double permission pattern first show a
fake permission prompt that your website
controls consisting of buttons to allow
or ignore the permission requests if the
user clicks allow trigger the permission
requests prompting the user with the
real browser permission dialog with this
approach you can display a custom
permission prompt in your web app which
asks the user to enable notifications by
doing this the user can choose to enable
or disable notifications without the
risk of you being permanently blocked
whether com has added push notifications
to the Settings panel in their web app
let's take a quick look at their flow
subscribing and unsubscribing is easy
they've tied the users goals staying
up-to-date with the latest weather
information getting safety alerts and so
forth with the reason why they want to
send notifications when the user
subscribes and the SUBSCRIBE method is
called the browser checks to see if the
user has granted permission to send
notifications if the user hasn't granted
permission before it then prompts the
user by engaging with the user first and
giving them that chance to opt in you've
essentially guaranteed that they'll
click allow and everything will be
peachy but if you don't do it in context
and the user doesn't understand what
kind of notifications you're gonna send
or what the benefit to them is they're
more than likely going to hit block and
again if that happens the only way to
undo the block is for the user to go in
and change their browser settings you
really want to avoid surprising the user
by asking permission without explaining
what the notifications are for one of
the other things I really like about the
weather comm experience is that they
give me options about what types of
notifications I want I might only want
severe weather alerts or breaking news
let's check out the way to unsubscribe a
user unsubscribing is essentially the
same grab the serviceworker registration
then get the subscription and call
unsubscribe on it and then update any UI
in theory using the web push protocol is
easy it's not create your message
encrypt it using the user's public key
and your private encryption key then use
the vapid keys to sign it with your
private application security key next
set the right set of HTTP headers and
make up HTTP POST request to send it to
the endpoint which will then deliver it
to the device ugh the pain instead I'd
highly recommend checking out one of the
web push libraries the one I'll focus on
is node-based but they're ones for other
languages available with the web push
library sending a message is as simple
as calling the API first we need to
define the options which include the
application server key and some contact
info about my application the subject is
sent to the web push service as part of
the request to trigger the push and is
used if the push service needs to get a
hold of me I've also set a TTL of 120
the TTL property tells the push service
how long it should try and reach the
device to send the message a TTL of 120
means that it will try to reach the
device for a hundred and twenty seconds
if the phone is off or an airplane mode
during that time and the message isn't
delivered the endpoint will just throw
the message away by default the TTL is
four weeks the web push library handles
the payload encryption for me so I
simply need to convert the payload from
a JSON object to a string and I'm ready
to send the message send notification
the subscriber the payload and the
options that's it if it works we'll get
a 201 ok back and if it fails we'll need
to handle that in a catch block okay
so now what do we do on the client to
handle the message this is a pretty
simple push event handler if the push
includes a payload we get the JSON
otherwise it uses a predefined title and
calls show notification in addition to
adding a body you can also add other
properties to the notification body is
exactly as it sounds and can define the
text below the title the icon is a small
image shown next to the title and body
text you can add an image which is
particularly useful for providing an
image preview to the user and for chrome
on Android you can specify a badge a
small monochrome icon used in the
notification bar to portray a little bit
more information to the user about where
the notification is from beyond that
there are several
their additional properties that may be
helpful vibrate allows you to define a
vibration pattern that will run when the
notification is displayed tag allows you
to group notifications together if a
notification with that same tag already
exists the new notification will replace
the previous one re notify works
alongside tag without Reno defy the
replace notification will not vibrate or
play any sound when it's updated when a
user clicks on a notification by default
nothing happens it doesn't even close or
remove the notification to handle user
clicks we need to add a notification
click event handler to the service
worker in this case we simply close the
notification but we probably want to do
a little bit more than that actions
allow you to provide another level of
interactions to your users by providing
additional buttons that the user can
click with actions you can make it super
easy for a user to complete a task
without having to open your app for
example a user could reshare or like a
post reconfirm a dinner reservation or
place an order the choice is yours
to add actions to the notification we
need to add a new actions property to
the notification options and include an
action that will identify the action in
our event handler the title and an
optional icon now if the user clicks on
the notification or one of the action
buttons we still handle it with
notification click event handler but the
button pressed is defined in event dot
action if they clicked on the download
action button event action will be
download or whatever we set it to in our
options otherwise event action will be
undefined and will simply open a page to
example calm I've shown you how you can
fetch a document or open a window but
there are a number of other patterns
that you should consider when
implementing notifications you can
collect analytics about how users
interact with your notification by
handling the
notification close event you can pass
information from the push message to the
notification click event by adding a
data property to the notification
options and I've shown you how you can
open a new window but you can also focus
on existing windows you can merge
notifications for example instead of
showing all the messages in a chat you
can say something like there are seven
unread chat messages if the user already
has your app open one approach is to
send the message from the service worker
to your page this way the page can show
the notification or update the user
about the event or you can improve the
overall user experience of your web app
by caching webpages you expect users to
visit after clicking on the notification
of course these are just a few ideas
just remember the key goal is to
radically improve the user experience of
your app and push notifications are just
one tool that you can use check the
description for links to the slides from
this video and some of the links that I
shared up next we'll dive into how to
implement HTTPS and the key concepts
behind building secure experiences</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>