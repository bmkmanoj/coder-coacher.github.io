<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Using Web Components to Build PWAs (Progressive Web App Summit 2016) | Coder Coacher - Coaching Coders</title><meta content="Using Web Components to Build PWAs (Progressive Web App Summit 2016) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Using Web Components to Build PWAs (Progressive Web App Summit 2016)</b></h2><h5 class="post__date">2016-06-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/pBCDdeqzUlY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thanks for sitting around everybody
we're gonna talk about how to use web
components to build web progressive web
applications and the notion of
progressively enhancing your markup
using custom elements so this is me
it's a tee vital on Twitter and github I
got crazy sometimes I'm a digital Jedi
at Google which basically just means I'm
a web developer that helps other web
developers outside of Google build
really awesome web apps and I built a
number of web apps at my time at Google
so we've worked on things like developer
sites for html5 rocks we built
developers chrome comm polymers website
chromestatus.com Santa trackers on a
developer site obviously but it's kind
of a fun project that we work on on
developer relations so you can track
Santa around the globe see where your
deliver his presents
we built the codelab site that you see
here today at the show in polymer and
we've also worked on the Google i/o
progressive web app the last couple of
years speaking the last couple years
I've gotten really excited about web
components all these emerging standards
several new api's that allow us web
developers to build applications code
reuse reusability these are really good
things for the web and it's important to
know it's a set of merging standards so
it's not just one API it's it's a few
and you can use them each individually
that's totally cool but together it
becomes a web component and becomes very
powerful so they allow us to extend and
create new HTML elements that's the core
that's the principle here and over the
last four or five years since the
standards kind of first started to
evolve we've grown the community quite a
bit so there's web components org which
you can check out it's got articles it's
got people they're contributing that's
also where the polyfills are hosted if
you want to actually write an app in
production you can do that using the
polyfills so check that out it's a great
resource but browser supports actually
been been lacking so I think chrome 36
was the first browser tool and all of
the web component API so you can create
a component without the use of a library
that's really awesome
but browser supports been lacking and so
if you take away nothing today from this
presentation take away this slide
basically what's happened is that chrome
implemented the API is very early on so
shadow DOM custom elements template and
HTML imports this is what the API calls
looked like these are called now the v-0
TI's what's happened is that the
browsers recently got together and said
hey we want to you know tweak a little
things here and there about each of
these specs and they decided and came to
consensus and what's going to happen now
is there's a new version of shadow DOM
and custom Ellen's we call these the v1
api's so if you've learned about web
components in the past all the concepts
still apply same stuff still applies
it's basically just syntax and name
changes in this presentation I'm not
going to talk about template which is
actually supported in all the modern
browsers now which is great you can use
that without a polyfill and I'm not
going to talk about HTML just gonna
focus on the two that have have changed
and the implementation in the browsers
is well underway so Chrome has started
in on custom elements and shadow Dom you
can play with these today in Canary with
a flag over at Firefox Wilson Paige
who's an advocate there tweeted this
recently so they're actually started in
on shadow dom v1 custom elements has an
open bug they haven't started that yet
Safari last week in fact at WWDC and now
it's Safari 10 will ship with shadow dom
so that's two browsers this year alone
will have shadow DOM and they've also
started in on the new custom elements
API we thought that might land in Safari
10 but it did you just didn't get it in
at a time and over at Microsoft edge is
is playing a crazy catch-up implementing
all these things serviceworker push
notifications you see shadow DOM and
custom elements and web payments on
there so very exciting times for web
developers this stuff is coming in hot
love it
browser support really matters turns out
native support really matters we don't
want to use polyfills for the rest of
our lives right we don't want to drop in
a lot a needless library that we don't
have to and the notion that polyfills
goes away over time is the promise of a
polyfill the other reason browser
support really matters to me is because
if you look today at all these libraries
and frameworks they all produce and
allow developers to create components
but there's sort of no standard way to
build the component some use a lot of
javascript some use more HTML and
javascript some just use a massive
amount of HTML so the goal of creating a
tab strip is the same right you want to
create a reusable tab strip but the way
you get there is very different across
the board and so that's what web
components is here for it's here to have
a standard way to
create reusable components so a web
component tab strip would look something
like this it would be declarative it
would be my dash tabs we'll just call it
that it's got a selected attribute that
you can use to select the tab that's
should be selected and it's got div for
its content it's got eternal attributes
it's very readable and very clear what's
going on here
the other thing that people often forget
about is the fact that it's just DOM and
HTML that we're creating means were
integrated with the browser were
integrated into the platform so Rob
mentioned all these great accessibility
features that the browser and the HTML
elements are to give you were integrated
with that we can take advantage of
what's already there and don't have to
reinvent the wheel ourselves and we're
also integrated with every but web
developers ves best friend which is the
dev tools and I'll show an example this
this is polymers old site and I'll just
fire up the dev tools and show you what
happens and how you can kind of debug a
web component so this is a tab selecting
tab strip that we have for our code you
can kind of poke around and see the code
and then you see the live output on the
right there so I'm just going to open
the dev tools open the inspector and
immediately it's just Dom in HTML so I
can just poke around with the inspector
see what's going on see how this custom
element is built you see that there's
some shadow Dom attached to some of
these elements I can open up the console
and then I can start tweaking properties
Dom properties of this element so I can
change its selected property and you can
see it live update in the Dom since
we're integrated with the platform in
all wyott ways we can actually change
CSS right and affect how this component
looks just by changing the color of the
text of one of its panels I can discover
it's got a panels property and it's got
an API it's got methods so things like
updated panels we can call that and it
does something who knows what it does
but we're discovering that in the dev
tools and it's got a bottom property
this one happens actually changed the
way this thing renders and by changing
that you can see the live Dom update so
this is really cool and the fact that
we're integrated with the tools and the
platform means we can build apps even
better so if the rest of presentation
I'm going to show a lot of code web
components is one of those things where
it's a developer feature it's for us
it's not a fancy feature like WebRTC or
WebGL so it's not sexy it's actually for
ergonomics it's for you guys to produce
a reusable code so let's dive in let's
talk about custom elements custom
elements is sort of the foundational
piece of
components and allows you to create new
HTML and tell the browser about that
HTML so let's build a button there's no
better way to actually learn this stuff
than actually build something so we'll
start simple Willis very simple
component a button component now if you
probably know right HTM already has a
button but a lot of people stopped using
button over the years it doesn't look
that great you know it renders
differently in different browsers but
it's got a lot of great built-in
features if you think about it right Rob
talked about focus ability and keyboard
behavior it's got that built in when you
tabindex into this thing it actually
highlights itself and it has this effect
this gradient that applies it's got
special properties to treat it like a
button it's got a disabled attribute
that you can apply that actually affects
the rendering of this element and if you
put this in a different context if you
put a button inside of a form it
actually does something different right
it submits the form and participates in
the form submission so this is magical
and kind of cool we get all this stuff
for free just by declaring this on the
page but of course we want to create a
leave and better button we'll call it a
fancy button that's got a nice little
ripple animation when the user clicks on
it and it's got a box shadow if you
apply this raised attribute and we can
make this thing behave exactly like
button so I'm gonna do what Rob told you
not to do which is create a div button
don't do this this is just building up
the example but this is the way you
might start off with this right and you
could start off by using button and then
remove the default styles the browser
applies but we're just gonna have a
blank slate here create a div give it a
class better button and essentially that
class is just gonna style this thing to
look like a button so it's got a box
shadow it's got some border radius
it handles disabled state if you have
this disabled class on it so we're just
making a thing that looks like a button
but of course if you want this thing to
quack like a button you have to do some
things so we'll add a tab index 0 and a
role equals button that will actually
tell the screen reader that this thing
is going to be a button and will allow
users to keyboard into our button and
maybe right we want to have this ripple
effect that's that's the extra
functionality we're adding to the button
so we'll rip the element out of the Dom
and attach an event listener for that
and if the button isn't disabled we'll
allow people to click on it and we'll
draw the ripple animation so very simple
not much going on here but this has a
couple problems the first is that users
have to know how to style this thing
themselves if the kind of
know all that magic that we gave them
put that on their page and the second is
that we have to add a click handler for
all instances of the button that are
used on the page it's not very reusable
I can't really reuse this thing users
have to add their own tabindex equals
zero and a role equals button it's not
very component II so of course we can do
better and the answer is to use a custom
element for this we can create something
that's reusable so the first thing I've
done here is just replace div with the
name of better - button I'm creating a
custom element and custom Ellen's have
to have a dash in their name that's just
part of the specification we were
calling our button a better button and
instead of CSS classes to style this
thing I'm just going to use HTML
attributes it's a little cleaner to read
and it's going to map really well to the
JavaScript properties we're going to
define on this button in my CSS all I've
done is just replace classes with that
new tag name nothing's changed about the
appearance of this thing of course we
can do even better we can progressively
enhance this markup from its its itself
right now to something better we can
give it an API and use JavaScript to do
that and so the way you create a custom
element is just to find in es6 class
we'll call it better button and it's
going to extend the browser's native
HTML element so it's going to gain all
the Dom API and since we're creating a
button maybe you want to have a disabled
property just like the normal HTML
button has so we can do that in es6 just
to define a getter and a setter for
disabled and in this case what I'm doing
here is I'm keeping the attribute in
sync with the JavaScript property so if
somebody changes the JavaScript property
in in JavaScript we're going to actually
reflect that value back out into HTML
and set the attribute on the HTML tag in
the live Dom and other properties on the
web today do this to the hidden property
the ID property if you set them in
JavaScript they'll actually update the
markup as well so we can do that in
custom elements something else you can
do is go the other way so if somebody
tweaks an attribute you want to get a
notification about that you want to
react to that
and so Brad there's two special things
you can do in element code the first is
to define and observe attributes are way
array this is sort of a whitelist to say
any attributes in this array I want to
get a callback for and so what the
browser is going to do if it observes a
change
one of these attributes is call it
you're attached attribute change call
back it's going to be provide the name
the old value and the new value of the
attribute has changed too and here what
I've done is basically just look at the
disabled property when that happens and
set a tab index in an aria disabled
attribute accordingly so we're kind of
mimicking a but the button again by
adding this functionality ourselves
something else you can do is run code
every time an instance or your element
is to create it and declare it on the
page
so to do that we'll just define a
constructor and the first thing you
needed to an element constructor is
called super that's just part of the
spec it needs to set up the prototype
correctly and then from there you can
put in whatever you want so in our case
we're gonna define a key down listener
we want to actually have when people who
press enter on our button to react to
that and that's what this code does and
then we'll add that click listener that
actually adds the ripple animation so if
the buttons not disabled will allow
people to click it and draw the ripple
at the user's click location we can also
react to when our element is added to
the Dom or remove to the from the Dom
and so for that we can use the connected
callback this is a great time to do any
setup work in our case we're adding the
role for screen readers and we're adding
tabindex 0 at that time and disconnected
while we're not using it in this
component is actually very valuable for
things like cleanup so if you add a
bunch of event listeners in your
component or do other kinds of setup you
can remove it at this time the browser
will call that method if you're curious
on how draw ripple is implemented it's
pretty simple this is the way I've I've
chosen to implement it just a div with a
ripple class that styles this thing to
look like a a ripple effect so it's a
div with a border radius that kind of
just grows and fades out protip I'm
using CSS containment here we're
creating a reusable component that's
self-contained might as well tell the
browser to optimize this for so it
doesn't do it knows to scope layout and
paint that's awesome
we can just basically drop that in our
web components and the other thing I
want to point out about this code is I'm
doing and basically creating a
declarative style API and providing a
little bit of functionality and
flexibility for this component so if
some user that uses better - button
Styles the color the font text with red
we're basically styling that the same as
the background ripples can be styled the
same as the font color so this is kind
of cool you can do these things in your
components
and document how this stuff works for
users now we've got a component we've
defined it's es6 class the last thing we
need to do is actually tell the browser
about this new element and so the way
you do that is to use the custom
elements interface and call the define
method you pass it the tag that you want
to create and the class definition that
you just created and then from there the
users can use this element as if they it
was a div or a span or any normal HTML
element they can declare it on their
page they can use the new operator in
JavaScript with the element constructor
or they can call document create element
the same tricks apply that always
applied to the web so that's a lot of
stuff right if you think about there's a
lot of CSS involved to make it look like
a button we have a class that mimics all
the behavior of button and the last
thing we do is have the registration we
actually tell the browser about our new
element we can do better we can
progressively enhance what's already
available in the web platform so again
we have a button already in HTML why are
we reinventing the wheel why are we
mimicking everything it does for us why
don't we just progressively enhance the
button element well sure enough we can
do that custom elements allows you to
extend HTML that's already existing in
the web so instead of extending the HTML
element we're going to extend the HTML
button element we're gonna extend the
specialized version of that element and
then what happens is this is our entire
class definition so all that work we had
to do before with tab indexing and key
down listeners all of that stuff goes
away because we get the Dom properties
and methods that button has for us just
for free and then we add the extra
functionality in this case it's that
ripple animation with the click handler
so this is really convenient in element
and the way someone declares this on
their page is a bit different so instead
of using better - button they're gonna
actually declare a button and it's gonna
be an is better button so this button is
a better button that's how that reads so
we've done a lot right we've think we've
made a custom element it's reusable it's
a fancy button little little sexier than
the normal HTML button but it's got all
the benefits that the original one had
in it I want to take a little bit of
side and talk about this call here the
notion that you call custom elements dot
define with the tag
you kind of upgrade the element what's
happening is what is called an element
upgrade this is part of the custom
element spec you kind of endow your mark
up with an API by defining some
JavaScript that gives it its API and its
methods and properties so you take an
HTML element and you make it something
better so the notion here is that custom
elements are really just progressively
enhanced markup you're taking something
that doesn't have any functionality and
you're progressively enhancing it to
have functionality we've taken advantage
of this notion of element upgrades on
the developers code lab site that we
built it in polymer and if you dissect
this thing you can actually see where
the components live on the page so our
search bar is a component our sorting
and filtering widgets are components and
also this main section in the center is
a card sorting element that knows how to
rearrange its children based on the
users sort and filtering so that's how
this thing is kind of structured I want
to show it happens when we load this
page I'm going to slow it down to a 3G
connection so you can really see the
effect so we'll navigate to the page and
instantaneously it paints the browser
turns out is really good at just
painting pixels HTML CSS very small
payload and then eventually what happens
is the components fade in we'll see that
one more time because it's kind of fast
so first paint is really fast and then
as the components upgrade and get their
supercharged api they fade in
asynchronous value so it turns out this
is really fast I clocked this at about
2.2 seconds for a first paint on a nexus
5 3G connection and of course this would
get even faster with a serviceworker if
we had caching and the user came back to
the site so the way you do this is to
use another feature of custom elements
it's the CSS colon defined so you can
basically pre style elements before
they're ready before they get their
JavaScript API and you call custom
elements dot define so in our case I'm
styling that papertabs that's selecting
widget basically giving it a little
layout getting an initial height to kind
of replicate the styles that papertabs
defines in it and I'm also just hiding
it right and page-load is just hidden
and then when the browser removes this
defined pseudo class our element will
transition in so the effect is that
these things kind of just take up
placeholders and you see them just fade
in when they're they're ready
the rust that page is very simple just a
little bit of markup at the top to
describe the website we have that
sorting and filtering section that's got
some custom elements in it the papertabs
element and the main bulk of that that
intersection is this card sorting
element it's just a custom element it's
on the page ready to go everything's
server-side rendered so you all these
links just show up on page load and
they're styled to look like a codelab
card so this is great this paints really
fast the contents there the available
uses that could start reading it right
away and then eventually at some point
in the future we actually register these
elements in the browser and at that
point that's when the card sorting
element gets its API it gets its
filtering API in it's sorting API that's
not critical on page load so it's a
great great story for progressive
enhancement so let's think about what
we've done so far in a very short period
of time we've created a reusable
component it's got custom elements API
it's got reusable Styles if you drill
down into the dev tools you can actually
see a problem though one of the
implementation details is kind of
leaking right that's this ripple div
that we're creating dynamically is kind
of mucking with the user's Dom it's
taking up space implementation detail
they really shouldn't see that we can
fix that the answer here is to use
another part of web components which is
shadow Dom so if you think about today's
elements there's the Select element
right and you drop a couple a couple of
option tags in it give one of them the
selected attribute and somehow the
browser magically knows to render this
thing as a drop-down widget and select
the correct element that's kind of cool
if you add the multiple attribute to
this HTML element it completely changes
the way it looks so instead of a
drop-down you get this multi select
widget pretty magical the video element
a couple a couple of attributes on the
single tag you get an auto playing video
with you know video controls for free
where do these use UI controls come from
an input type equals date or any of the
various specialized versions of input
are pretty cool instead of a text box
right text input you get a UI that
allows you to select a date so this my
friends is shadow Dom the shadow Dom
allows us to do the same thing the
webbed of the the native browser vendors
have been using for a long time they use
shadow Dom to create these widgets and
hide away marker
and CSS we can do that inside of our
component as well so in order to use
shadow Dom inside of a custom element
it's just one or two lines so inside of
the element constructor we can call this
dot attach shadow that's going to create
a document fragment a shadow root that's
going to kind of attach itself to our
element and we could fill that document
fragment with anything we want any
markup you want in our case we're
bringing in those styles from the page
so users don't have to define them
themselves this is great because style
inside of shadow Dom are scoped to your
element so that means styles and
selectors aren't going to bleed out into
the page and page Styles aren't going to
bleed into your component so that's why
you see I've replaced some of the the
selectors here I've changed better -
button to use colon host that's the way
you style the element itself inside of
shadow DOM and my selector for the
ripple div has gotten simpler we're just
using dot ripple now and that's because
again these styles are scoped we can use
common IDs again we can use common class
names again they're not going to collide
with the main page because we're inside
of shadow Dom which has this scoping for
us and the last thing you see is I've
moved in this ripple div it's become
part of kind of the implementation
detail of my component users are not
going to see this inside of their Dom so
let's take a look at this when you do
this when you call this tat shadow root
what happens is that you get a shadow
root attached to your butter button
that's great we have shadow Dom in the
works and you can see that we have the
Styles you know scoped to this element
you can see the actual style information
this thing looks like the button but
it's actually lost something it's lost
that fancy button text that we have and
that users have declared and so the
reason for this is that shadow Dom is
kind of like a party you have to invite
things into it you have to invite things
in the outside world to render inside of
your shadow Dom for this you use
composition with the slot element slots
another element that's part of shadow
Dom that you can use for bringing those
things into your shadow Dom so let's say
I have a shadow down that looks like
this I have style information and a slot
element what's going to happen here is
that when someone declares a better
button on their page fancy button text
is going to get projected into this slot
it's going to render at that location
inside of my shadow Dom and the effect
is that you get the text back that's
exactly what we want you can also have
default content so if someone doesn't
provide the text themselves when they
use our component you can render just
button as the default text and you can
have an entire Dom tree in here if you
wish doesn't have to just be text and
there's also more advanced form it's
called named slots so we can have as
many slots in your component in your
shadow Dom as you want in this case
we're defining a slot with the name
equals icon and a default slot that
doesn't have a name when someone uses
our button like this maybe they want to
have a little gear icon next to some
text what's gonna happen is that the
name slot it's gonna get projected into
that location it's gonna render in that
slot and the settings text is going to
render in the other slot because it's
not using a name the effect is exactly
what you'd expect which is that gear
icon and a settings text so I think of
composition I think of a slot element as
kind of a declarative API for your
element it's a way to really provide a
level of functionality and customization
and this is exactly what the Select
element and those other native elements
are doing allowing for you to configure
their UI based on attributes but let's
say somebody wanted to use our button
like this they want a ginormous pink
button with a lot of padding and a
different ripple color well since we
brought the styles into our component
how do you actually allow for this type
of customization the answer here is to
use another new web platform feature
which is CSS custom properties
essentially CSS variables so what we can
do inside of our shadow Dom CSS is
basically have placeholders for users to
fill if they want if they so choose
support for this is really good right
now actually everyone but Edge has this
available as a native feature so when
someone uses your custom element
some CSS for better button they can fill
in the values if they so choose so
they'll define in this case they're
defining the button padding and they're
defining the size of that ripple
animation we're going to create and so
in this case we'll use those values but
if they didn't provide them again we'll
just use our defaults that we set up
ourselves so CSS custom property is a
great way to have like placeholders and
allow people to customize your component
and the styling of your internal
elements in your component so that was
fast let's recap what we did in a very
short period of time in less than 30
minutes we created a reusable button
it's progressively enhanced from the
native HTML button which means we have
all the benefits that the browser and
that element already gives us
keyboard behavior all the stuff that Rob
talked about baked in its self-contained
using DOM and CSS scoping of shadow Dom
it has an imperative API a JavaScript
API thanks to custom elements it's got a
declarative API thanks to composition
and the slot element and shadow Dom and
it's also configurable so we can have
people can use it in different ways with
HTML and they can also configure the CSS
that's pretty cool so this is why I'm so
excited about web components cuz it
allows for this flexibility allows for
the good reuse on the web again and this
is just a button you can imagine
building an entire app out of components
if you don't want to get started so if
we do want to get started go back you
can actually check out and try to use
some web components yourselves so
polymer has put together a really
awesome set of reusable and very useful
components for different types of things
and there's also custom elements do that
has a list of web components you can
check out so with that that's all the
time I have again this is me on Twitter
if you want to hit me up with questions
I think now we're going to transition to
a break we're gonna take 20 minutes
because those guys went over but I
really do appreciate you guys sticking
around thanks for time go componentize
at the web</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>