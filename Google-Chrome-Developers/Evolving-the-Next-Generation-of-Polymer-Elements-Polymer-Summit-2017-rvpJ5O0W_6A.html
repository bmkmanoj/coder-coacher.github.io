<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Evolving the Next Generation of Polymer Elements (Polymer Summit 2017) | Coder Coacher - Coaching Coders</title><meta content="Evolving the Next Generation of Polymer Elements (Polymer Summit 2017) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Evolving the Next Generation of Polymer Elements (Polymer Summit 2017)</b></h2><h5 class="post__date">2017-08-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/rvpJ5O0W_6A" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">everyone my name is de varville I'm an
engineer on the Palmer team and we're
here to talk about the next generation
of polymer elements like matt said we're
still pretty early in this process but
we're iterating pretty quickly as I hope
you'll see so it's this kind of reusable
elements that we're talking about
they're used in almost every app and we
have a pretty large catalog out of them
that we've published on the polymer
project they've been out for a while a
couple years since polymer one so we've
been asking ourselves what needs
improvement Matt give you a preview of
that and luckily we've gotten a ton of
feedback from our users both inside and
outside of Google and YouTube's built a
whole application with polymer they've
asked us to make elements faster people
come to YouTube to watch videos so we
make polymer faster that will make
YouTube better the chrome settings UI is
built with polymer and they've actually
asked us to make polymer elements
smaller which is kind of crazy since you
don't actually have to download them to
load the settings page in chrome but
they do have to download with a chrome
app so they told us if you make polymer
elements smaller like chrome download
faster and users like that and our own
team has asked us to make elements
easier to maintain they've specifically
voiced concerns about our behavior
system that we had in polymer one there
was a little bit cumbersome to use and a
little bit hard to to make maintainable
code with so they asked us to work on
that and of course all of our users
always want a lot more features we've
gotten a ton of github issues on that
and we actually know that all of our
users actually want all of these things
they want elements to be faster smaller
easier to maintain and have more
features to size is especially critical
if you're making PW A's that need to
load on slow 3G networks of course you
need things to be as small as possible
so
we thought about all this feedback when
we're designing polymer 2 and we
realized that the needs of these
reusable elements like inputs and
checkboxes and buttons are really not
the same as the kinds of elements you're
making when you're making big
applications when you're making these
application views you're concerned
really with you know getting data from a
server and transferring them
transforming it to the UI you know
managing those complex interactions you
really want the ergonomics of that
experience to be good when you're making
reusable elements you're concerned more
with size and speed and look and feel so
we realized that one size does not fit
all in polymer 2 we decided to throw out
our behavior system in polymer 1 and in
polymer 2 you really embraced the new
features and JavaScript classes and
mix-ins and that this would allow us to
make polymer 2 modular pay for play so
that features are there only if you need
them and that would allow us to hit more
of these use cases more optimally so we
did this for polymer but the existing
set of elements we've made what we call
hybrid elements and these are really a
bridge to the future we really haven't
addressed the feedback we've gotten in
these elements there they're really -
let's use transition from Palmer 1 to
polymer 2 seamlessly so with that in
mind we're sort of now starting to think
about what it means to make that next
generation of elements where we can
start addressing that feedback so we're
just going to take a look at some of the
topics that we're thinking about and
you're going to get an early pick at
that peek at that so first we're going
to look at you know addressing dot
feedback that we've gotten to make the
install smaller and faster really
directly then we're going to look at
using extension which is a new feature
in polymer 2 in what that means for
elements and finally we're going to dive
into some improvements that are coming
in the platform around styling all right
so let's start and we'll look at making
elements smaller and faster and to do so
we're going to go ahead and remake an
old friend of ours paper input inputs
are used in almost every web application
so we can make if we can make a small
fast one that'll be great this one has
this material design look and feel has
that animation that validation effect
with a customizable message and of
course we know we need all of the native
features from from the input element
accessibility all of the types
all that so as we want to remake this to
make it smaller and faster we need to
ask ourselves what's the minimum that we
need and we'll start by making a base
class and we can use this for this input
element and then maybe for some other
elements too so let's go back to the
modular design of polymer 2 we built on
top of HTML elements and we have a
number of mix ins here property
accessors exposes helps us manage
getters and setters and react to
properties changes templates stamp helps
you stamp a template property effects
gives you data binding and we wrap it
all together in polymer element which we
think is actually pretty good for
building these application view elements
it's just about 12 K minified in gzipped
and that's actually a pretty good
trade-off here but where we're making a
really small and fast element it's a lot
more than we need so we're going to
actually go down to property accessors
and use that and that's actually just qk
out of the box so it's going to really
help us with making the element really
small to make it fast we'll go ahead and
just use this mantra do less than be
lazy we want to do as little as work as
possible to render the element and then
do work lazily only as the user needs it
so the last few slides were actually
from previous talks that have been given
at Google i/o this year Monica gave a
talk polymer billions serve license
learn all about the modular design of
polymer 2 and I gave a talk last year
could see my standard uniform which has
all about practical performance patterns
you can use with polymer all right so
let's dive in a little bit too property
accessors and see what it gives us out
of the box so it helps us make accessors
which are getters and setters where we
can react to changes when properties are
set
it also helps synchronize with
attributes which is important when we
are using HTML it has an explicit API
for turning on the system called enable
properties and that's there to better
integrate with that boot up process as a
custom element comes in we take those
attributes and reflect them to
properties and we're able to process
that as one set of changes which is more
efficient it also triggers the ready
method which is you know life cycle
method that we add to allow us to do one
time an initialization work and finally
we have an entry point calls properties
change which allows us to react to this
batch set of properties
changing and in polymer element is
implemented for us and this is where we
get data binding and property observers
and things like that but in this element
we'll go ahead and implement this and do
the work that we need when properties
change to update our rendering all right
so now that we understand property
accessors let's go ahead and build a
little base class on top of it that we
can use to make our paper input
replacement we'll just call it simple
element we're just kind of experimenting
so that sounds good and the code is just
going to take HTML element apply the
property accessors mix in it's going to
call enable properties at the connected
callback is a good time to do it to get
that turn the system on and then it'll
define a template getter and we'll use a
string which is going to work well for
modules this is something that is
actually currently optional in polymer
element and it's all that will support
here and then we'll implement the ready
method and stamp the template into the
shadow root which is great for custom
elements we'll steal a feature from
polymer element the distal or sine node
map for IDs in our template and we'll do
this because we're going to be working
with those elements directly in this and
this is just so we don't have to find
them we'll call super ready this is
actually the easiest way to have a
broken element is to forget to call
super so definitely remember to do that
okay so that's basically all we need to
do to put into our base path property
accessors and then we made simple
element and then we'll make a thing
called simple input this is just going
to replace our paper input so let's take
a look at a few things about this we'll
look at what we call a decorator pattern
that I'll explain in a second then we'll
look at the template and finally we'll
look at some of the code specifically
the ready method and the properties
change method so first we're going to
use an approach we call the decorator
pattern we're going to ask our user
actually to put the input and the label
in the light Thumb of the elements and
this is actually a change we didn't do
this in paper input and it was a big
pain and the reason is because if we put
the input in the shadow Dom and we want
to customize or expose all the power of
the input element we have to forward all
that information it's a lot of
complexity to manage and it's not a good
trade-off so if we use what we call the
decorator pattern here it makes the
element a lot simpler
and we get all of that native
accessibility and the type capability of
the input out of the box all right so
let's define the template and we have
some styling this is kind of the minimum
that we could do to get that material
design look and feel I won't bother you
with that since you're all CSS gurus we
have a slot for the input which allows
us to project and from the light time
into our shadow route a slot for the
label and then some non semantic nodes
that we get out of the way and here we
have like an underlying node that helps
us manage that animation and that's
really all there is to it all right
so let's look at the ready method again
this is sort of our boot up work and
since we're using a simple element we
call super ready which is where we stamp
the template this is going to happen
before the element gets rendered so you
know that's fine but you know we have to
be aware of that work since we want to
make our element fast and so anything
else we're going to do we're going to do
after the first render of the element we
set up that CSS so the initial render is
free we don't have to do anything to get
it to show right and then after the
render we're going to immediately find
the input in the light column just using
some some shadow Dom API to do that and
then just add a couple event listeners
and use a private property here to track
its track the focus State and I do a
little bit more for the label too and
that's really all these easy to do in
ready for that setup work and then we're
going to go ahead and implement
properties change where we'll react to
those properties being set like focused
and and and a couple others and
basically we'll be manipulating the Dom
directly here I'm just going to add a
class to that underlined element just to
tell whether or not the element is
focused and that will manage the
animation we do a little bit more of
this for the label in the era error
message and we get this which is
hopefully looks almost exactly the same
as the paper input material design
look-and-feel has a little validation
guy and it's looking pretty good so how
do we do on size and speed well pretty
good it's just a little over 3k using
property accessors the little base box
that we used and then you know the code
that we have for the simple input
and now compared to paper input which is
a hybrid element which means it really
is not leveraging polymer to use modular
design and has all the legacy API from
polymer one it's actually ten times
smaller so that's a huge improvement and
by using the decorator pattern and
cutting out some of the features we made
it five times faster to render which is
again a pretty humongous improvement but
of course we know from our feedback that
the features that we eliminated users
are going to want so what are we going
to do about that well let's move to our
next topic which is extension and see if
this will help us at all so extending
elements as I mentioned is sort of a new
feature for Palmer - and we just get to
rely on JavaScript for doing this and
here's some things to kind of keep in
mind as you're using extension and
making elements and the first is to keep
our base classes simple we kind of did
that with simple element and simple
input so that's good using extension to
add features so that's kind of an answer
to how we're going to deal with those
missing features that we didn't support
and paper input yet and then importantly
if we can design our base classes with
extensibility in mind at least in the
sort of obvious ways that we can
anticipate who's going to make it much
easier for us as we extend them so as I
said JavaScript classes really give us a
lot of help with extending elements
because it's native now and that's great
but when we were kind of designing this
we were thinking about what about the
templates especially when we're defining
those templates of HTML we were kind of
concerned that we might need a system to
help us view the kinds of things you
want to do when you're extending
elements but if we're using modules
specifically we're using those
JavaScript string template literal to
define a template then that might
actually change things so we want to
investigate that and specifically we
want to look at TV use cases the first
is you're making a subclass of an
element and you want to wrap some
content around the superclass template
that's a common use case and then the
other common use case is we're making a
subclass of an element and it wants to
insert some content somewhere in the
middle of the superclass template and
hopefully we want to do this in such a
way that we don't have to copy and paste
the entire superclass template so let's
take a look at both of those use cases
really quickly this is just a contrived
example so we can kind of see what's
going on it's just a simple element that
asks how do you feel and then has a
little input to respond now if we make a
subclass of this will define the
template here and just use a string
template literal and the native syntax
here to refer to the super template we
get that kind of for free and then if
you want to do the wrapping we can just
go ahead and cert the content like that
adding a header there and then adding
another question kind of get that for
free so that seems pretty good but now
let's go ahead and say what if we wanted
to subclass this we realized that the
way that we've organized this here well
there's a header and there's a some sort
of list of questions can we make can we
design this element to make it better as
a you know better to subclass easier to
subclass so if instead we here we have a
template for the header and we expose
that then now we've created an override
point that a subclass can customize if
we do see the same thing for the
questions then you can see that we've
added very little to our base class here
and the rendering is exactly the same
but if we want to subclass the element
and make it look like this with a
different header and maybe a couple
other questions then all we need to do
is override the header template like
that and the question is template like
that it's just that easy
so we can kind of see that extending
templates when we're using those string
template literals is possible to do a
lot without a system especially as I
said using those string template
literals and using classes and mix-ins
for polymorphism just like we saw so how
can we apply any of this to the simple
input element let's go back to the
template and we know from our experience
with paper input that people want to do
a lot of customization with the actual
how the input looks in the material
design look and feel they're they want
to add icons to the beginning of it
maybe icons to the end of it and we
could add a lot of complexity to our
base class to support all of those needs
or we could just expose an override
point for the input template and that
adds a very minimal footprint to our
base class
but it's going to expose a lot of power
as we said pause the element for example
if we make something like this a credit
card input to make sort of show a credit
card after the input we could customize
that input template add some styling
call super add a little icon for the
check box or sorry the credit card and
then it would look like that
obviously we want to do a little bit
more to make a full credit card input
maybe restrict it to numbers validate
the credit card but our subclass gave us
a nice helping hand and it was really
useful so we're really excited about
leveraging extension to build new
elements and we know this because it's
going to help us factor our code better
if we factor our code better it's going
to be easier to maintain it's easier to
maintain we're going to have more time
to add features and we're going to have
a good helping hand there to address
some of that core feedback that we've
gotten all right so we'll move on to our
last topic which is some changes that
are coming to styling so you might ask
why we're talking about styling isn't
this a solved problem with web
components we have shadow Dom which
helps us encapsulate styling preventing
style leaking into or out of our
elements and we know that that
encapsulation is in tension with theming
which is a more global concern but we
have an answer for that which is CSS
custom properties natively available on
all major browsers now they naturally
flow down through the shadow Dom
boundary where we can use them in our
custom elements if we want to and let's
sort of sketch this out a little bit so
we understand it so I didn't show this
but here's a little custom property that
we can set here in a Content view that
might have one of those simple input
elements in it and then that CSS I
didn't show in the simple input we might
use a custom property like this where we
say okay we're going to default that
underline Cullerton to navy but we'll
make its edible in this case that's
going to be orange and that's what we
need to do to expose that color to be
fema Bowl to the outside world of our of
our element and that works great
and you know we also had in the styling
here and the simple input a little bit
of opacity and that was just you know
the designer set out there to make it
look good but then we might have a user
that says like oh you know that I'll
Cassidy I want to I want to be able to
set that to so now we actually have a
little bit of a problem and that is
because you know we could expose the
property for the opacity but then the
user might want to you know make the
padding different or any of the other
hundred property hundreds of properties
in CSS we have a scaling problem with
custom properties like this so there's
something missing here and on the
polymer team we helped propose add apply
which a lot of you may be familiar with
as an extension to custom properties and
we worked with tab Atkins who is a CSS
spec guru that works at Google and he
told us we actually put whatever
information you want as a custom
property and here we're putting the
opacity for the underline but we need a
way to make that go at the spot in the
custom element and that's where add
apply came in if we changed our variable
name to match here then within all of
those properties could be applied at
this spot in the custom element and this
would totally solve our scaling problem
so we see we have a pretty good story
with styling with shadow Dom for
encapsulation and custom properties for
theming but at apply is a really
important piece of that puzzle to solve
that scaling problem so I have some good
news and a little bit of bad news and
then some more good news
so first the good news although at apply
is not standard in any browsers today we
have a shim in polymer that's been
around since polymer one and carry
forward to polymer savin is used
out-of-the-box in all of those hybrid
elements along with the sort of spirit
of the modular design of polymer 2 it's
an opt-in feature that you can load with
the apply shim
but now the bad news is it's looking
like add apply is probably not going to
make it into native implementations and
browsers and the reasons are complicated
there's some issues with nesting there's
some issues with how it integrates with
what are called pseudo classes like :
focus colon hover didn't really play
nicely together and this is the link to
tap outcomes
where he has all the gory details and a
lot more information about that if
you're interested but back to some good
news tab and crew in the CSS working
group have a better alternative and
that's part and theme so why is it
better it's actually kind of how the
platform itself accomplishes this type
of theming as we'll see in a second and
it's also a revival of a previous
proposal from a couple years ago but the
issues with that earlier proposal have
been addressed so let's take a look at
that really quickly so this is a native
input element and it has an attribute
called placeholder which probably a lot
of you are familiar with it controls
what's going to be shown in the input if
there's no value there and when this was
out of the platform of course users
immediately said well I got a style that
I want to sell in a style what that
looks like and the platform answer is
what's called pseudo elements and they
have this colon colon syntax here and
you can see it's sort of similar to add
apply you can specify a whole set of
properties here and that's going to
customize how the placeholder looks in
this case it'll be orange and centered
so that's how the platform does it with
pseudo elements and the custom element
with this new proposal would do it like
this here's a slider element and it's
shadow root I can expose these pseudo
elements by specifying part attributes
so I make the slider have a track and
thumb that's style able be mobile and
then users would be able to target these
elements these pseudo elements like this
with that same colon colon syntax now
with part and then the name of the part
in params
and so this kind of solves some of the
same problems as at apply so that's
looking good it works better with pseudo
classes so that's great but notice one
issue which is we had to be able to
target the slider element it had to be
that element had to be inner shadow root
in order to style it spark we can't do
it from outside so it's not great for
theming we're theming is more of a
global question this is actually the
fundamental problem with the earlier
proposal for part it didn't support this
kind of composition so the new proposal
has an answer and that is forwarding
so here is kind of a crazy syntax that
may change it's a little early still but
using the spat arrow I can say users of
my content view element here can style
this sliders thumb by this new name here
slider one thumb and it's common
separated I could do the same thing for
the track but we also have a catch-all
that's proposed here and that would
expose all the parts with the prefix or
suffix and then from say that content
view element was in some my app element
I can target that exact sliders part
there with a slider one thumb and we'll
go and make that one blue so that's
actually pretty powerful looking good
for theming there's of course probably
the more savvy of your figuring that
okay well that looks a little cumbersome
I gotta forward all that information and
that's good that's explicit that's
probably what you want to do most of the
time but there's an answer for if maybe
you can't do that all the time and
that's : theme : : theme it avoids this
need to be required to forward
everything
so if we use : : theme then that part
name will be targetable anywhere in the
shadow root of the my app element even
in shadow roots and elements inside of
it so how might we use this in our
simple input example that we've kind of
been going through well let's go back to
the template and look at that div that
we had here that was for that underlying
animation that users wanted to apply
that styling to that we used at apply
for we can just add a part and that's
all you need to do so that's actually
looking pretty good and promising so
pardon theme were proposed earlier this
year at the CSS working group meeting
there's a lot of enthusiasm for it
because again as I said it's kind of how
the platform itself accomplishes this
same goal and tab is currently fleshing
out the spec you can have input on it if
you want we're actually right now in the
process of sort of thinking about what
this means and when this is going to
come actually natively in the platform
which we think is at least a year or two
out and now we might make a shim for
this in the meantime
and so then if we kind of zoom out again
and go back to the feedback that we had
at the beginning here making elements
faster smaller easier maintain and add
more features we kind of think that if
we make things sort of along the lines
of that simple input using extension
adapting to the platform as we need
squint a little bit that we actually
might have made a lot of progress
towards that so let me now go back to
the sort of demo that I showed at the
beginning here and this actually is not
it this is a new version that's sort of
we've been prototyping with some
elements made sort of along the same
lines as that simple input element you
can see that there's some missing stuff
yet it's not all there but the old
version was built with hybrid elements
and is actually a lot of code you know
it's bringing along all that polymer one
legacy API it's more than 100k the new
version so far again not done is just 6k
so that's actually a ton better and
we're really happy with that
so there's still a ton of work to do
still early but we're iterating pretty
quickly and that's all I have so thank
you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>