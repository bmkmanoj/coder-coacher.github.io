<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>What's up with Polymer 2? #AskPolymer -- Polycasts #54 | Coder Coacher - Coaching Coders</title><meta content="What's up with Polymer 2? #AskPolymer -- Polycasts #54 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>What's up with Polymer 2? #AskPolymer -- Polycasts #54</b></h2><h5 class="post__date">2016-09-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/WyafamduMF4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">
ROB DODSON: Hey there,
folks, Rob here.
Welcome back to the show.
So it's been a while
since we did one of these,
but I thought today
would be a good time
to do another episode
of Ask Polymer.
So I went on Twitter,
I asked folks
if they had any
questions for me,
and here are some of the
top questions that were sent
in by you, the actual viewers.
So first question is
from Micho, who asks,
how do I make the app-drawer
panel automatically
close when I click a
link in my application?
So that's a really
good question.
I think we actually
maybe used to do this
for you using the old
Polymer Starter Kit,
and we're not doing it now in
the new Polymer Starter Kit.
But basically what you can do
is you can actually wire up
a binding to the
opened property,
or the opened attribute
of the drawer panel,
and then you can just
toggle that value every time
the router changes the page.
So that might not make sense
when I'm just saying it
like this, and what
I'll do instead
is I'll drop a link down
in the description that
has an example so you
can just follow that.
And also, I think we might
just add this behavior
to the Polymer Starter Kit,
the one that we just rolled.
Maybe expected like
a point release
soon, when we just add this in
you don't have to wire it up
yourself.
So thank you for
that question, Micho.
All right, this question comes
from Eric Bidelman, who asks,
I hear Polymer 2's out.
What's up with that?
So yeah, maybe some
of you have seen
on Twitter and on
the Polymer blog,
we're recently
tweeting that we have
a preview branch of Polymer
2.0 available right now.
You can find that
over on the gitHubs,
and I will include a
link to that, as well,
down in the show notes.
So Polymer 2, the
main idea there is we
want to get folks onto the
new V1 versions of the web
component standards.
So Custom Elements
V1, and Shadow DOM v1.
The current version
of Polymer, 1.x,
is based on the old
V0 implementations.
Those shipped in Chrome, and
Opera, and some other browsers
experimented with those
versions of the standards,
but they are never going
to be the native one
that ships everywhere.
Instead, after
reworking things a bit,
the browsers decided
to make some changes,
and those changes
are in the V1 specs.
So that's what's
going to be shipping
in all the different browsers.
I believe Safari recently
just shipped Shadow DOM V1,
it'll be coming in
Chrome really soon.
And because there are
some breaking changes,
we needed to migrate
Polymer as well.
And the important
thing to note here
is that those breaking changes
for the web component specs,
those are probably
set in stone now.
So we don't have to worry about
suddenly a V2 appearing out
of nowhere for the web component
specs, or anything like that.
The nice thing is
that going forward,
web component should be
backwards compatible.
So yes, there are some
breaking changes right now,
but hopefully minimal pain.
I wrote down a few
things from Polymer 2
that I'm really
excited about, that I
wanted to tell you all about.
Stuff that I just
think is super cool.
Aside from moving over
to the new standards,
we're going to be providing
like a backwards compatibility
layer.
So if you've got a bunch
of Polymer 1 elements,
and you want to try and start
to migrate those to Polymer 2,
we have the old Polymer
constructor available to you.
So you can seriously just
do like a few small changes,
and voila, you've got
Polymer 2 elements.
But the other thing
that we're doing now
is we're baking in
support for ES6 classes.
So that's something a lot
of people really wanted.
Now, the default
and the standard
encouraged way to
build a Polymer 2
element is going to be to
actually inherit from a class.
And then you've got
all the niceties
of working with ES6 there.
We're getting rid of
things like Polymer.DOM,
which was always really
confusing for folks,
the whole shady DOM thing.
Instead, we're going to be
shipping a new, improved Shadow
DOM polyfill.
We're going to stop talking
about local DOM, and shady DOM.
all these random terms
that never made sense.
Instead we're just going to
say, hey, it's Shadow DOM,
we got a new polyfill,
it's nice and fast.
And we're making the data
binding system a lot easier
to reason about, too.
So if you ever had issues where
you would change an object
inside of an array, or change
an object's sub-property
and things just
wouldn't update, we
should be fixing
those in Polymer 2
to make that just a lot
more straightforward.
So that is kind of a
high level overview.
Again, I'll include a link
for the 2.0 preview branch
down in the show notes.
So you can go check
it out yourself,
read through the readme,
and give it a test run.
I'm really interested to
hear what all of you think,
so please leave some
comments down below
with your thoughts on that.
So thank you Eric
for that question.
Right, next question.
Sam Saccone asks, I hear you are
a corgi, what is up with that?
So yeah, that's true.
My spirit animal
actually is the corgi.
Thank you for that
question, Sam.
All right, our
next question comes
from Jerry, who asks,
how do I implement
ES6 syntax with Polymer CLI?
So today what you can do is
you can use the custom build
generator that we showed off, I
think, maybe two episodes ago.
I'll include a link
down in the show notes
to that particular episode.
And what that does
is it actually
gives you a little escape hatch
out of the Polymer CLI build.
It lets you actually
use the same node
module that powers
the Polymer build,
but it lets you also
hook into its lifecycle
and add your own gulp tasks.
One of those gulp tasks could
be something like babel.
So you could write all your
elements using HTML imports.
The Polymer build will actually
split out the JavaScript
into its own stream.
You then pass that
through babel,
and then it recombines it
all at the end for you.
So that's the option
that you could use today.
However, as I
mentioned before, we're
going to be rolling out full
blown ES6 support in Polymer 2.
So if you're able to
wait to Polymer 2 time,
we might have a better
story for you there.
It might be a little
bit easier to use.
So if I was doing this today,
I would actually probably stick
with just the current Polymer 1
syntax, and then wholesale move
over to ES6 when
Polymer 2 rolls out.
Hope that answers your question.
Thank you, Jerry.
All right the next question
is from Stephen who says,
I'm still confused about
how to load in third party
JavaScript in my elements.
So that's a question.
What a lot of people do,
I've seen two approaches.
One approach would
be, you just say, hey,
I depend on this
library, and you've
got to include the script
tag for that library
before you import your elements.
What I actually prefer to
do is to take the script
tag for whatever dependency
I'm depending on,
put that into its
own HTML import,
and then have my elements
import that file.
The nice thing there
is your elements
are now explicit about
their dependency,
because that link tag is up
at the top of their definition
file.
And also, HTML imports will
de-duplicate multiple requests
to the same resource.
So if you've got five
elements that are all
trying to import
the same thing, it's
actually going to only
be loaded one time.
So that's the approach that
I really recommend using,
that's the one that we've
used in some of our elements,
like the marked element.
So yeah, hopefully that
approach works for you.
And also, I think in the
future we're probably
going to also be
exploring things
like maybe how we can
use ES module loaders,
or something like that.
That's definitely in the Polymer
2 realm of possibilities.
So we might have an improved
story there as well soon.
So.
yeah, thank you Stephen
for that question.
All right, next question
comes from Thomas
who asked, once all web
component features are broadly
and correctly supported
in all major browsers,
is Polymer's job done?
So yes and no a little bit.
Definitely the job of
polyfilling web components
is done at that
point, which is great.
We want to get rid
of polyfills, we
want to get rid of any
sort of inconsistencies
that they introduce and just
be doing everything native.
But web component standards
are inherently low level,
and that's by design.
They're supposed to give
developers maximum flexibility.
However, that also means that it
can require a fair bit of code
to create your own elements,
stamp out your Shadow DOM,
put your templates inside of
them, and stuff like that.
So Polymer will probably always
be around in some fashion
to offer this sort of
helper support, right?
Sometimes we refer to it as
like sugaring the native web
component standards.
Just making you essentially
much more efficient.
So that has kind of always been
the direction for the library.
We wanted those polyfills
to sort of evaporate away,
and then you're just left with
this really nice clean helper
library that just makes you
more efficient as you're
building components.
So thank you, Thomas,
for that question.
All right, our
next question comes
from a user on
Twitter named GBX,
who says, how should
web components be
written to let applications
override their default locales?
So I am not personally
an expert on localization
or internationalization,
I can't even say it.
L10n, i18n.
There we go, that's the
easier way to go about it.
My teammate, Monica
Dinculescu has actually
written some behaviors
to help with these.
So the one that you
would be interested in
is called the app
localized behavior.
And basically, you
define JSON file
full of different localized
strings based on the locale,
or that are keyed
off of the locale.
And then based on
the user's locale,
it then, in your element,
it uses a little computer
binding to match
up whatever text
you're using to that JSON file
and use the right localized
version.
So our internationalization
library
works in a very similar fashion.
The one thing to
note is that these
depend on the
internationalization API.
And so if you're in a browser
that does not support that API,
you're also going to need to
include a little polyfill.
But that is linked to from
the repo for app localize
and the i18n behaviors.
I'll include a link to
these down in the show notes
so you don't have to
listen to me try and say
these words anymore.
But yeah, give those a shot, and
see if that helps in your app.
So thank you for
that question, GBX.
All right, next question is
from Vladislav, who says,
what's up with
2.0-- Polymer 2.0,
I'm assuming-- and TypeScript?
So there's no plans right now
to migrate over to TypeScript
or anything like that.
However, we do have a lot of
members of the Polymer team
who really, really
like TypeScript,
and we definitely
want to make sure
that we are
supporting it better.
So I think if you're
trying to do this today,
you can maybe use something
like the generator custom build
that I mentioned
before-- which we're
going to link to down the show
notes-- to add the TypeScript
compile step to your
gulp build process,
or something like that.
For 2.0 I'm not quite
sure what the exact game
plan is going to be, except for
I'm almost certain that we're
going to have some
better TypeScript story,
some sort of improved
story around it.
Because we have so many
team members who like it,
we have so many Googlers
who like using TypeScript.
I definitely want to explore
it more myself, so I definitely
we'll probably have some
more to talk about there.
It's a little early
days right now
for Polymer 2.0 to know
exactly what the strategy is
going to be.
But if you're
interested in TypeScript
and you're interested
in Polymer,
stay tuned, because
I'm sure we're
going to have something
more exciting for you
in the future on that topic.
So thank you Vladislav
for sending that in.
The last question
comes from Ido,
who says, how do I
share information
when I am transitioning
between two pages,
and what are the best
practices for communicating
between elements?
So I'm actually going to answer
this sort of in reverse order,
because I think the
second answer helps
answer the first question.
When you're communicating
between elements,
you actually probably
don't want to have
siblings talking to each
other, or anything like that.
We generally try
to discourage that,
mainly because it means
that element A has
to be coupled and know
about element B over here.
And we kind of don't want
that level of coupling.
Instead, what we
recommend is to figure out
a common parent between
both of your elements
and have your elements be kind
of like as simple and as dumb
as they can be and just
dispatch events out
to that common parent.
Like, hey, I was clicked
on, or something like that.
And then the common parent
can act as the orchestrator,
saying, oh, I hear that this
child over here was clicked on,
and I know that that means that
some action needs to happen
with child B over here.
What this does is that
keeps element A and element
B very simple, and re-usable.
And all your business
logic then kind of gets
moved up into that
higher order element.
And we usually refer to this
as like a mediator component,
and I'll include a link down
in the bottom to my teammate
Kevin Schaaf's talk.
I think this is
from Polymer Summit
maybe two years
ago, or a year ago,
where he talked
about this pattern
and how we tend to use
it in most of our apps.
So that's how we recommend doing
communication around the page.
And so then the
first question was,
how do I share information
when I'm going from page 1
to page 2?
Well, in that case, I think
if you have information
that needs to belong to
multiple pages, that,
to me, is stuff that belongs
in one of those higher order
components.
Like something that kind of
lords over all of the pages,
even.
And it's just binding it
down into the child pages.
And you can have that
higher level component
listen for changes coming out
of some of these lower level
components, and
changing its state,
and then pushing that down.
But that way, again,
you're simplifying things
so that the business logic
where you've got two related
things, the business
logic for that
is going to live
higher up, and they
don't have to try and
talk to each other
and figure out how
each other works.
So yeah, I hope that
answers the question.
I know it's sort of like
a broad, abstract answer,
but that's generally the
pattern that we recommend.
And definitely check
out Kevin's talk,
which covers it in
a lot more detail.
So thank you Ido for
that great question.
That about covers it for today.
If you yourself have
some questions for me,
you can leave them down
below in the comments,
or you can ping me on a social
network of your choosing
#AskPolymer.
As always, thank you
so much for watching,
and I'll see you next time.
OK, ready?
Localization.
Internationalization.
I just slam it all together,
so like, internationalizlation.
It's close enough.
That's why you just shorten it.
You write i18n.
</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>