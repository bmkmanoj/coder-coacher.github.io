<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>From Components to Applications - Net-a-Porter (Polymer Summit 2016) | Coder Coacher - Coaching Coders</title><meta content="From Components to Applications - Net-a-Porter (Polymer Summit 2016) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Google-Chrome-Developers/">Google Chrome Developers</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>From Components to Applications - Net-a-Porter (Polymer Summit 2016)</b></h2><h5 class="post__date">2016-10-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/DwrLEd0gBcA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thanks for the introduction Monica just
so everyone knows that I blitz through
this in 13 minutes 91 slides in
rehearsal and that's what they said just
cool it down so hi my name is Robin
Glenn and you can find me on Twitter I'm
Ariel legs and I'm going to talk about a
journey from components to applications
with being where we are and if i say to
you that I'm from the Big L you all know
where I mean right that's fun dialer but
I work here in London or the little L as
we call in some Tyler and I work for a
company called you can export a group
when online luxury retailer we are
multiple websites function and luxury
brands on in commerce this time last
year I was that way you guys are in
polymer summit but not here in Amsterdam
but we were showing off our first
polymer release which is the product
details page on that report a I wanted
to show you this so i could just link
you to a talk there so if you're
interested there's a previous talk mian
developer and UX designer did about how
we took it to production so if you're
interested in reading about that you can
do it then I want to talk about why web
components but I want to take a
different stance and not talk about it
as a technologist or so a developer but
I want to talk about it from a design
and ux perspective so previously our
design team would they would submit this
for a sign off so they would design a
page this is an example of a listing
page and they parted the company to get
sign off so we could go ahead and build
it what they found was the comments can
be quite subjective people would like
okay we like this here but maybe would
change this h1 and then what you get is
what bottlenecks but design
inconsistencies so what they wanted to
do is move towards a design pattern
coined by Brad frost called atomic
design we build in small atoms and then
a collection of atoms become a molecule
a collection of molecules become an
organism and they wanted to move towards
this pattern so they could eliminate
these bottlenecks but also get
consistency across their designs so they
were looking to get something like this
signed off instead so a collection of
components and that's what they will get
signed off and then when they wanted to
build something they would just
structure a few of these together so
this led us the design and ux seemed to
come up with this concept called atomic
components so we wanted to move the
front end to align with the new design
pattern that the back end was doing so I
want it go over the principles sorry I
want to go over the principles of atomic
components first of all is standardizing
the rhetoric so what I mean by that is
the front end team the UX the design all
the way to the API teams are talking
about the same thing in the same way
what this helps us do is get bendre
understanding of each other's problems
promote collaboration but then instead
of thinking in like technology problems
we think in customer focus problems the
next is granular thinking so we wanted
to break everything down to its finite
point there's a talker Apple say which
is using the simple stick so you just
break everything down into its smallest
piece so using those principles I'm
going to talk you through a natural
component which is called nap product
summary I'm going to use these
principles to build this component up
together so the first part is the
nucleus as a designer and a developer
you probably used to this point where
you break things down like what's on the
page so first of all is product image
I've got a badge which identifies what
type of product it is design a name
product description and price those are
just the the primitives of this
component that we need to build it so
next thing we layer some more stuff on
so let's look at States this component
will have some states the first is a
skeleton state this is the preloaded
state before the product date has come
back or its rendered completely this is
how it will look and then you have a
loaded state which is the next date on
top so next thing is interactions so now
we're starting to build behave
interactions into the component
so the most basic one is the link so it
generates a SEO friendly URL for the
href of where this product will take you
next there's some kind of interaction of
them hover or tap so it's like a
rollover state to show two different
product imagery we're going to build on
again I'm going to add some behaviors
and rules so we've got behavior for if
the image is broken for some reason the
image hasn't been uploaded we don't the
standard broken image so we style it up
a bit we also use responsive images
using image source set so it's another
behavior and we use schema tags to
identify what the product is I'm going
to go into that in more detail later so
it's add another one so testing it's
really important for the component to be
tested and so we can abstract some of
the complexity away from the intestine
so we do a couple of different types of
tests we do unit tests this is just to
make sure that the the product is
working how we expect it to so does the
product behave how we expect that when
we run these tests on sauce labs for
multiple browser operations we also do
SEO tests SEO tests are too sorry I
could have a Glock supporter SEO tests
are just to make sure that the product
looks exactly how we think it does for
rich media snippets finally it's visual
testing so what we do is with the level
of tolerance we test across different
browsers just to make sure that the
project looks the same on every single
browser sorry brothers okay so that's
our test then done next if documentation
documentation is really important for
our consumers and our other clients to
adopt this component so itself documate
thin using the polymer standards it's
also got a demo so how do use this
component version in we add versioning
so different consumers can change the
component but then subscribe the changes
when they want sorry next is monitoring
I'm sorry next is monitoring does this
component need some way of registering
how its performing in the wild and then
all of those together make an atom so
you can see this onion skin in effect of
all the different things that we want to
apply to the component building up a new
abstract complexity away so using these
principles let's build something I am
nowhere near brave enough to do this in
front of you so in Blue Peter style
here's one I built earlier and this
repos available and open so if anyone
wants to check this out and apply this
work that I've done feel free the repos
there my github is the RG so you can get
it so we're going to build a simple
product component so it's what the
NetSupport a when I showed but we've
just removed a few parts okay it's going
to be code heavy here this is how you
would use the component there's a
product attribute and that has a string
of five bit of JSON and that's the data
contract for that component that
everything that it needs is inside there
I don't expect you to understand it all
but this is how you line up with your
back-end teams to make sure that you get
this data through so here's the template
this is how you would use it you can see
there's a bunch of product or image or
different proper product attributes are
just being passed through from the
attribute we previously seen now I want
to focus on one specifically which is
price you can see that we never pass
price through so let's look about how
this works surprise is a property but
it's a computed property which means
it's going to get generated before the
component actually gets rendered so you
can see a simple private method their
computer oka lies price you pass it the
product rice and the locale let's have a
look how that works so here's a simple
method is private it's documented at the
top this is how you if you want the self
documenting code if you write like this
you'll get it all for free so what does
it do it's basically just returning the
price but using locale string to put the
currency and depending on the country
where you put the
order full stop so that's that's all
that methods doing let's look about how
we might go about test in this and we do
two different types of testing the first
we'll call a unit test so we use a web
component tester as you've probably
heard people talk about today and we
also use fixtures to stamp that in the
Dom to make sure it's clean every time
we run a test and what we're actually
testing here is we're calling the
private method stubborn some data in
there and just making sure it works how
expect it to so it's like this is a unit
test the next type of test however is a
component test this is to see does it
work inside the component is the
component doing what it's expected to
look like so you can see here we're
doing a simple assertion again using
fixture with the assertion is checking
the text content inside a selector
making sure it's the right value and
we're using this element dollar dollar
notation and the reason we do that is if
you just did a query selector directly
when you try and run these tests and
shadow Dom it can't pass the shadow
boundary so it'll fail so we use that
it's part of a shorthand for polymer Dom
just to inspect the next is structured
data so structured data is a way of
identifying what a product is what it
looks like so Google can come along and
see what it is there's a link there to a
product schemer so that how you mark up
a product and basically the two minimum
things you need to do is you need to say
hey this is a product and this is the
name and then you can pass this to
google structured data testing tool and
it will validate it for you like it's
done here is that correct so what we
need to do first is put on the host
attribute that it's a proper product so
this is all this is doing the host
attributes inside your polymer
constructor will allow you to do this
the next is we're going to mark the name
as the name with this item prop would
you saying that property name is the
name of the product so we want to be
able to do this its CI level though
right we want to run these tests at
automation we don't know just copy and
paste into Google structure data tool so
the module here that we created that
will act as a proxy and do that for you
so if you want to automate this testing
you can so again it's on my github
and if you get that repo you can do it
and I'll just explain quickly how it
works so this bit of code when you
setting up your tests you grab the
entire outer HTML and you're going to
pass it into this method that's
basically going to proxy a call off to
the API return you back some Jason that
you can run some assertions on so you
just need to get all of your HTML and
pass it straight into this module and
then you can run some assertions so
these assertions are saying are there
any errors is it a product is the
product name correct so now we've got
automation testing of Rich Snippets
which is awesome so we built a little
component we want to get to applications
now so this is a simple listing
application again built it's on github
that's available for you to check out
it's got full automation tests and you
can play around with it it's pretty ugly
i'm sorry but i just wanted to show you
some simple features that you can do so
this is the template you can see it's
got a few sub components so we use an
iron Ajax as a wraparound xhr requests
we've got a single product list header
so that's just the name of the list
we've got pagination which is the
controls and we've got a list of product
so you can see how we've broken apart
these sub components and each one these
sub components can have their own levels
of tests so they can be tested in
isolation so you don't have to test
everything together just how you expect
it to work let's look through some of
the things on here so we've got auto on
iron Ajax what this will do was it will
automatically make the xhr request for
you and then if you make a change to the
API call you will again automatically
make that call so we've got URL again I
would just want to look into this
because it's going to be important when
I build up this structure again the
computed style and we're going to pass
in products per page and page number the
page number here is the the key part
that we're interested in so just picture
this and i'll build it all back up but
just you know so page number here is go
into pagination and it's got two curly
brackets which means it's got to weigh
data binding and that's again going to
be really important when we build up
this application so let's look at some
of the components that
all it's doing is generating the title
so I'm not going to go into that but the
one below is pagination which I've just
tried the highlight for you there so to
look into that component so what's it
got its got some buttons previousnext
it's got a description to tell you what
page you're on and then on the buttons
we've got some unclick events and let's
look into those so we're going to call
pagination next so when we click it
we're going to set page number and we're
just going to increment it by one so
that's all we're doing would you send
hey when we click that update the page
number by one and that's it so what does
that do page numbers got this notify
property on so I know that there is a
data flow talk yesterday so people might
be kind of aware of this now so this
notifies just can say hey I've changed a
little my parent that I've something's
happened so now let's look at the list
the list here is a collection of
products but it's in a dom dom repeat so
what we're going to do is we get an
array of products back and we're going
to iterate through each one of those and
pass them into our simple product
component so we had that big stringify
json earlier what we're going to do now
is we're just going to pass this
reference directly into that and this is
called the mediator pattern and i'm
going to try and talk it through to is
hard to understand sewing to try and
build it back up so imagination you hit
next it increments that page number
that's alert in the application above so
the applications wrapping around these
two sub components so pagination tells
application a the page numbers changed
the page numbers computed URL then
automatically updates the API call an
iron Ajax on low on auto goes and makes
the call so the scholar made that call
got some more data is then passed it
down to the application and then the
applications pass it down to its
children so you can see the list would
update
okay so now he needs a more real world
stuff so we've added some pagination but
our customers want to know our clients
wanna know hey is anyone using
pagination let's add some tracking so we
can do that with behaviors so what we're
going to do is we're going to fire this
event pagination and pass the page
number then in our pagination component
we're going to inherit this behavior so
we can add this behavior called product
tracking behavior so when you create
behavior I'm going to show you how you
do that here it's just another HTML
import and you define it like this so
you're saying okay let's create a new
behavior add this property and inside
there will have a listener and the
listener is going to listen for
pagination and when it gets it it's
going to fire track event pagination and
here there's just a simple example of
how you could use request I will call
back to do some beacon in pagination
Paul Lewis has actually got a great
article on this it's linked in the
github and it's here but it's how you'd
use request I will call back now to
track that analytics so using these
principles that's all we had these kind
of patterns it was how we created our
new listing application which is here so
this has currently been rolled out and
beta to a couple of a few high-end
customers to who try out a specific
products for us first but if anyone
wants to see it come and talk to me
after this and I can show you it working
so I want to talk about some specific
parts of this we can and look at how
some of them work and what we build on
top of it so this is this is a sample of
the application and I know there's a lot
of stuff so don't like worry about
reading what's there but what I wanted
to show you is it's multiple components
all broken down on top of this one so we
have stuff for errors we have stuff for
certain customers and personalization we
are things for load-in States we have a
rotor we have a header all of these sub
components build up this application and
each one is tested in isolation so you
don't need to worry about that
complexity it's all abstracted away from
you so I want to talk about some of the
more exciting bits
in this application I think a quite
exciting so the first thing is
performance so we try and obtain the
rail guidelines and I want to focus on a
couple of things I'm going to leave it
run because it's actually quite hard to
talk when it's happening and show you
and then I was explain the theory so
it's a short gif so this is skeleton CSS
this is the load and approach that we
took so when there's no product data we
want to show something so it gets in an
on-screen as quick as we can but we
don't know what it's going to be so we
just scaffold out the page and intestine
what we did is we put this verse as a
spinner with artificial latency and
showed it to customers and people
thought the one with the spinner was
actually slower even though it's the
same artificial latency so it's just to
get sending on screen as quick as we can
okay so the next one it's pagination
I'll leave you watch and then try and
explain what happens okay so what we do
is when we're going forward we need to
get product data and load images and we
put a spinner only when it takes more
than 400 milliseconds based on rails
guidelines so and what it's actually
doing as well its spin is only there and
it cares about the images there in the
users view port so they don't care if
the bottom image hasn't loaded they only
care about what they're looking at so
this the spinner is based on the promise
of the image loading that's inside their
viewport and when they go back you can
see they're like it's instantaneously
moving back and so we don't show the
spinner or any transition it's just to
keep it going again this is to adhere to
the guidelines of rail next I want to
talk about telemetry or is it working if
so how well is it working if you've ever
looked into the web components polyfill
you'll see the fires an event called web
components ready when when it's like
bootstrapped itself you can actually
latch on to that and we do something
that's quite clever with it where we add
an event listener for web components
ready when web components ready happens
we try we'd run this try-catch so we
look for the component and the listing
page and we look for this door is method
and the dot is method if the
Constructors been upgraded will become
available however if it's not available
it will fail and throw this error so
what we're doing is we're saying has
that component been upgraded to a
polymer component if it hasn't let's
catch that error and then we beacon some
data back we say is polymer defined has
the HTML import for that component
successfully been imported and then this
just allows us to like understand what's
happening in the wild is it working if
it's not working how do we debunk lions
you lose all of the logging that you
would have gotten server so you need to
compensate for that somehow and this is
one of the ways we do it also we do some
availability API availability and
performance checks so this is like okay
did the API fail when we try to get
products so you can see that there's
some error rates there if it did fail
what's the status code what was the
reason that that API failed and then we
have some API latency so it's like how
long did it take to make that API call
and come back and these are great as
developers right we can debug and we can
look and we can delve deeper into the
what's going on with application but
they're not great for our business
customers our product owners you want to
know how well is this performing for our
customers so you also have some other
metrics so this is customer performance
metrics where it's more tailored about
how it's working for our customers so
the first one is time to remove skeleton
so when you saw the skeleton state and
when the products come in that's how
long it's taken but not since you landed
on the page since the first network
request came to our site it's rendered
painted and then remove that skeleton
how long's that taken so we can tell our
product owners okay we can say it's
within like under three seconds three
seconds ish that they will see products
from first tryna land on that page and
then there's time to load paginator
products so this is when you go right
I've click Next I'm waiting for the
spinner and that's removed and we can
have metrics on that is how long it
takes them so it's a summary I went a
little bit fast I'm sorry
hope that all made sense and there was a
lot in there but I just want to kind of
summarize these things invest time into
reusable accessible tested granular
components what I'll help you do is
promote code reuse your developers will
be able to find this code adopt it and
not reinvent the wheel every time you
create something this also helps for
design and experience consistency so
your site works and behaves the same
each and every time it also allows you
to abstract complexity away from your
applications so because you've put all
of this test in an effort into these
small little components your
applications don't need to have as much
coverage plug and play components
strange your application so you can
spend more time on customer experience
collecting and understanding customer
focus metrics and do the fun stuff you
don't to reinvent the wheel every single
time no one wants to write fetch or xhr
request multiple times you can use that
component and plug it straight in I sort
of a really nice way dislike summarize
this as we're in London as well which is
if you look at the pennies the pounds
will look after themselves and thanks
for listening as for you Robin</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>