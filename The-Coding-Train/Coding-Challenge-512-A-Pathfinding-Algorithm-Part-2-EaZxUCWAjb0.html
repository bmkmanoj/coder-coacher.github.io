<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Coding Challenge 51.2: A* Pathfinding Algorithm - Part 2 | Coder Coacher - Coaching Coders</title><meta content="Coding Challenge 51.2: A* Pathfinding Algorithm - Part 2 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/The-Coding-Train/">The Coding Train</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Coding Challenge 51.2: A* Pathfinding Algorithm - Part 2</b></h2><h5 class="post__date">2017-01-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/EaZxUCWAjb0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay welcome to part 2 of the a-star
pathfinding coding challenge now this is
looking kind of odd the end this is
where all we've got so far is that we
have figured out how to get from the top
left to the bottom right most
efficiently only if you could go right
or left so I think we the magic and
serve UT of the a-star algorithm will be
much more apparent if we add two things
to this algorithm one is the ability to
go diagonally but even more importantly
I would say is the ability to add
obstacles so what happens if there's
obstacles there at the top how's it
going to go around them and so this
second part of the video I'm going to
add both those things and hopefully
you'll see a more interesting result at
the end okay thanks for watching so okay
so what I'm going to do is first add
some obstacles so every spot could be I
guess we could call it like a wall so
every spot by default is not going to be
a wall but randomly if I pick a random
number between zero and one if that
number is less than point one I'm going
to say this dot wall equals true so I'm
going to make a bunch of spots that are
walls and then when I draw when I
display it I'm going to say if this dot
wall I'm going to always override it
with a black so the color is always
black if it's actually a wall so let's
do that and see if we get we can see I
have a random matter well now I'm not
actually using those obstacles yet so we
can see I have a random smattering of
things that would be obstacles and let's
also put the end back to the bottom
right corner so now what I want to do is
what I also if it's in the closed set
it's not a valid neighbor or right as
long as it's not in the closed set and
it's not a wall and not neighbor wall so
this makes these not possible spots in
the path and here we go
it's definitely different results than I
wait now than I expected so this is
actually business working I'm just
losing my confidence and I think we'll
be able to see it better if I add even
more obstacles so what I'm going to do
is I'm going to make this instead of
there being a 10% chance for there being
an obstacle and to make that a 30%
chance now look at this we have a
problem the bottom right is an obstacle
so it's never going to be able to get to
the end so let's do a little quick hack
here which is to say to make sure that
the start is never a wall and the end is
never a wall so even if it picked it by
accident you'll never be a wall now
there still could possibly not be a path
but you can see it's optimally there we
go
so this is a start and this is how it
really should look we're seeing the open
set we're seeing the closed set this is
actually working quite nicely it's quite
enjoyable to watch but look I just want
to keep refreshing it one thing I need
to add to this is I need to have it
elegantly stopped here's a scenario
where there's no possible solution great
you can see it can't though there's
walls blocking that bottom right corner
so we tried and eventually it got to
this point cannot read previous of
undefined the reason why I can't do that
is because if open set dot length is
greater than zero keep going otherwise
no solution so what I'm going to do to
guarantee no solution just so we can
sort of test it and have it elegantly
exit is I'm going to make almost every
single wall so you can see I get this
and I get this that line 184 so where do
I get that 184 which is right here so we
can't when it has no solution it didn't
get to the part where it actually
connects everything so so what I want to
do I want to like break out of the loop
because I'm in the draw loop there's no
like really elegant way of doing that so
what I want to do is I'm going to add a
variable
and they call it a no solution equals
true/false and then if there's no
solution where where where where am i if
there's no solution I'm going to say no
solution equals true and I just don't
want the code to break and so as long as
there's not no solution do this I'm
going to leave the previous the last
path that it tried to find so don't try
to find a new path and then also it
should say no loop and I might actually
so we can see that it left the last path
and then said isn't it isn't it isn't it
though where where am I now let's put
this back and we can see you know and
try to make something that's probably
not going to have a solution but we'll
get somewhere that's too much there we
go okay so you can see that there's oh
that could have a solution come on I
want something with like a medium length
possible solution there you go so you
can see that's the the best path that
got okay so now we should really add
diagonals to this right because I should
let it be able to go to a diagonal
neighbor that's going to make it kind of
yeah I don't I don't need that but
that's a possibility so let's add that
so what I want to do is look at the
sorry uh what am I doing here I want to
add the diagonal neighbors so where do I
add the neighbors I have a function here
this dot add neighbors so again there's
probably more elegant ways I could add
this but I'm just going to say as long
as I is greater than zero and J is
greater than zero then I can add I minus
1 J minus 1 right
that up to the top left and then looks
as long as there's definitely better
ways to add these neighbors as long as I
is less than columns - 1 and J is
greater than 0 I can add to the right
and up as long as I is greater than 0
and J is less than rows minus 1 I can do
to the left and down so the Bob doing
this in a weird order and then as long
as I is less than calls minus 1 and J is
greater than 0 I can do I plus 1 J minus
1 right so I have minus minus plus minus
minus plus plus oh that's not right it
should be plus plus I didn't do this
right I did the same one twice right I
did this one twice so this one last one
should be the bottom right so J plus
okay oops and there's an extra 0 here so
this should be this should be all of all
I can use return Thank You Alka in the
chat I'm such a doofus let me just did
prove this because I I don't like the
way that I have that I don't need this
rig silly boolean although I could just
say wood because you know it's a lot
it's a little extra if statement I could
say I could say which I too much code
notice how much I have to scroll I
really should reorganize this into
multiple JavaScript files but I don't I
don't need to I could just say return
and then no loop return is going to like
exit out of that draw function instantly
so and then I don't have to have this
extra silly if statement here which is
totally unnecessary
that will do okay look hey what happened
by no loop oh because I put return
before no loop that are called no loop
before return huh oh and by the way the
diagonals are in there now so you can
see oh you can see that the diagonals
are in there now
of course I do have an issue with this
heuristic which is that the heuristic
still considers the diagonal distance
the same as the distance the left and
right and you could make an argument but
still just one step like I'm a person
walking is it really that much further
for me to walk diagonally than to walk
left or right but I could also I could
strangely enough
use this amazingly I could use this
heuristic right - no yerzok it's
actually not a heuristic in this case
but it's the that taxi cab distance
between those the neighbors like if it's
just to the right it's 1 and if it's to
the bottom it's - oh that's not right
actually should be the square root of 2
so I I feel like I've done it up here
but let's um let's just do something to
make this a little bit to have something
to look at let's make it much bigger and
let's let's make the so let's just I
just want to kind of like watch it work
and we can see there we go done so you
can see here and in a way like you can
see that it's working on so here's
things so this is done I finished well
that was a very hard one and I'm sure
there are things so there's a bunch of
things about this something to say if
anybody has made it to the end of this
video here's and in the chat let me know
some things I'm forgetting number one
there are lots of things about what I've
done here that are particularly
inefficient for example if I need to
determine if something is in the open
set or the closed set I'm doing kind of
a linear time search through that list
to see if it's in there so some type of
bite tree based search binary keep I
think might be the right term you know
something it could add to this -
optimizes if this is like a massive
network of so many nodes it's going to
like run very very slowly
so that's one thing number two is I'm
you know I'm not doing the best job of
like thinking about the difference
between the diagonal movement and a
movement just to the left or up or down
so that's something that could be
improved these are things I'm going to
actually make a separate github repo
just for this example and and people can
contribute to that so they'll be there
like code that's exactly what I've done
that's in the that will be linked and
then there's a repo that people can pull
to to kind of improve and make this more
efficient so that's that's number two
number three is visual design I think it
could be creative about this what are
you using this for what's the
visualization of it you have like an
agent that follows the path what colors
are you picking how are you choosing
where the obstacles should be you know
there's so many more thoughtful things
one thing I'll mention is that I'll link
to it I have a tutorial of a maze
generation algorithm so the maze
generation algorithm generates a maze so
you could combine this with that to
generate the maze and solve the maze
with a star so those are some things
what else am I forgetting the past
doesn't look right still so actually
there are mistakes here I said this
thing about I should be dealing with a
diagonal thing better and I really
should because this this heuristic is no
good I need to go back to if I'm going
to allow diagonal movement I need to
change the heuristic to where is my
heuristic it's all the way up here at
the top to be that Euclidean distance
because moving to and I think this is
going to fix it
let's try yeah okay so up this still
looks wrong right this doesn't look
right up here okay I'm back there's an
edit thing that just happened there
because as I was summarizing the video
we noticed or I noticed and people from
the chat notice a very significant bug
and I spent a while trying to find it
and I was not able to find it
Walter cereal in the chat pointed it out
it is quite apparent to me now and so
there is a significant bug in what I've
done so far it's been there since the
beginning but we didn't really notice it
until we added the diagonals the
diagonals really made this bug come
alive so the issue is here as part of
the algorithm remember as I'm moving to
a neighbor right if that neighbor is not
in the open set it's a new thing we
found calculate its G how long did it
take for me to get there and then and
then throw it into the open set that's
what's happening right here if it's
already been in the open set it's
something I've checked before I only
want to determine if it's better is the
new of
the time it took me to get there is
better than whatever I laughs tried to
do with that spot here's the thing
though no matter what I'm updating its
previous location so what if it was
worse I don't want to update it G but
I'm updating its previous I shouldn't do
that I should only be updating its
previous if the G is actually improved
so there's a few different ways I could
solve this I could kind of move this
pre-chat only previous up there and then
I have to make sure I do it here I'm
going to do it by saying VAR new path
it's false so I'm gonna sue I haven't
found a better new path and I have found
a better new path if that new G is
better than its previous G or if it
wasn't in the open set at all in the
first place then it has to be a new path
because it's the first path and then I
only need to like recalculate so only
need to calculate this heuristic and set
its previous if I actually have a new
path please let this work so now I'm
going to run this again you can see
let's we're going to get it new map
we're going to assume that we're not
going to see any and by the way I'm
pretty sure this is what was happening
all the way back in the beginning
because for example let's take out
because it's been ever present all along
let's think there's no wall right look
what I get right now if there's no wall
zoom I just go all the way down the
center and what if there's no possible
diagonals if there's no possible
diagonals I'm going to take out the
diagonals all right no diagonal I'm
still doing that whole thing so anyway I
sort of thought something else is going
to happen but I guess I was wrong about
that so let's put the diagonals back in
see it go it goes straight down the
center that's the optimal path and then
and then if I add some obstacles back in
we can see if it can find its way there
this one will not find its way there
because there's no spot to let's let's I
want to at least have it and something
to end on and that kind of looks like
something okay great
so we have done this train whistle sound
I don't know
this video how long is this video and
it's funny I posted it do you know that
if you're watching the edited version of
this the original if you go back and
gets watched the livestream this is like
our as long as I were lots of times
ready to go get water and all that sort
of stuff you don't care about that so I
said a bunch of things about what you
could do with this I really think I'm
visually augmenting it thinking about
little optimizations in the algorithm
I'm sure people will add those things in
the comments you can fork in and
contribute the repo or just make your
own version of this try to have them
you'll think about could you make an
image right could the image of black and
white image create this map and could
you then trace the contour of the image
somehow what types of other ways could
you use this pathfinding algorithm
creatively with a game terrain a network
of cities there's so many ways you could
expand on this I hope that you enjoyed
this I hope you learn something hope you
take the code improve it let me know on
Twitter what you thought and I think
that's really about it for a star
algorithm in JavaScript coding challenge
thank you for watching</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>