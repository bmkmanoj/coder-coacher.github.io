<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>8.5: More on Objects - Processing Tutorial | Coder Coacher - Coaching Coders</title><meta content="8.5: More on Objects - Processing Tutorial - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/The-Coding-Train/">The Coding Train</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>8.5: More on Objects - Processing Tutorial</b></h2><h5 class="post__date">2015-07-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/V7k5bFQbhG0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so we've covered the basics of
object-oriented programming and we could
probably easily go on and on video after
video after video to look at all sorts
of different scenarios and complications
and different ways of sir and we will
get to some of that as we start to look
at lists and arrays multiple objects but
there's a few kind of key pieces that I
think I want to kind of mention I really
intended this would be like three or
four videos but I think I'm gonna give
you a survey of a couple added features
of Bob's jointed programming that even
if we don't get into in depth here will
get you kind of like thinking and know
some terminology you kind of do your own
google searching or look at examples and
you know complain to me to make more
videos at some point too so the first
thing that I want to mention is just the
fact that we spent a lot of time kind of
understanding the idea that a class is a
template for making an object and the
class has data in it and functionality
in it some variables and some functions
a key piece of information I think to
realize and think about is that this
data doesn't just have to be a float or
an int or just as a bunch of simple
numbers it could be other objects and I
think there are a lot of scenarios where
it makes sense to program this way for
example let's say you were making a body
object so we had a class called body and
the body conceptually has a head and
torso and an arm and some legs and a
hand right you know my terrible drawing
skills aside you can see that this body
is made up of multiple pieces and we
might start having things like Oh head X
head Y head size arm but what if we
thought about this that actually what a
body is is it is a head it is an arm
which is like the right arm and it is
another arm object which is the left arm
right and so what does this mean oh I
need to write a class that is the head
class and you try to arm class so this
idea of a hierarchy that the data of an
object could actually be other objects
and later when we see when we look at
lists of objects what if I have a
particle system with a thousand
particles I might have a knob
that has a list of a thousand other
objects in it so this is all of this
this idea of nesting of creating some
type of organizational hierarchy is
something you should be thinking about
as you start to build out larger and
larger programs okay so I just wanted to
briefly mention that another thing that
I think is worth kind of briefly
mentioning even though you kind of don't
really need it that much but you might
see it in some examples as you can
actually write more than one constructor
so I just want to come over here this
very simple example where I just have a
particle class particle class is just an
X a Y and a size and here we have two
particle objects notice the particle
constructor receives three arguments a
temporary exit temporary y temporary R
to fill the parameters of this object so
what if I wanted to do this and say okay
well if I specify the three arguments
then I want those arguments to be the
pieces of data for that particle object
but what if I don't specify any
arguments then I just want you to make a
random particle well this is actually
quite allowed and common I could write a
second constructor that takes no
arguments where the look where something
different happens to those variables so
this is what's known as overloading I've
overloaded the constructor minha meaning
I made two different versions of it one
that requires three arguments one that
requires no arguments I could make a
version that requires two arguments or
one that requires four arguments and
this is actually quite common in fact
this is not just limited to the
constructor after all in processing you
can say fill and give it an RGB or you
can say fill and give it a just a single
grayscale value you could give it four
arguments for an RGB and alpha and this
is something that the designers of
processing have put into the API many
different versions of the same function
that expect different numbers of
arguments and this might be something
that you think about as you start to
build out programs yourself so if I come
back to this we could now I'm going to
get rid of this third particle I could
say hey let me make this
second particle just be random as you
can see whoops
when I run it why is it always in the
top-left something is wrong here X is
random with Y is random height I don't
see why that should happen 4p - I'm
after sighs oh it's I'm sorry I forgot
that I had this extra piece of code in
it that's pretty good where the mouse is
sorry so you could see that every time I
run this that second particle is
somewhere else and now if I go back to
what it was before something like this
you can see now I'm specifying it's
always going to be over there so this is
something this idea of overloading is
something that you can do okay so
there's one last piece here that I want
to look at and good to just sort of
scratch the surface of this by looking
at a kind of simplified scenario but
this way of thinking I think will apply
to lots of things that you might do
every two arm I try to do at some point
so let's think back to this processing
sketch we have where we have these two
objects on the screen how do we get
these objects to communicate with each
other how do we know when they're
overlapping or not overlapping how do we
know how do they know their distance
apart what if we want something to
happen when they hit when they get close
versus when they get far so this idea of
having two objects communicate with each
other this is a kind of key concept that
involves some techniques that are a
little bit beyond just the basics of
object-oriented programming so let's
look at this for a second there's a few
different elements here one so let's
just take for a second how do we know if
two circles are overlapping or not
so each circle has a radius r1 this
circle also has a radius r2 we can
clearly see that these circles are not
overlapping and I can clearly see that
these two circles are overlapping the
key piece of information we need to know
whether they're overlapping is the
distance between them the distance
between them and what we can the way we
can determine if they're overlapping is
if the distance is greater than the sum
of the two radii this being one
idiots this being another clearly if you
add these two together the actual
distance is longer however if we look at
this radius plus this radius the
distance is shorter than the sum of
those two radii so this is one way that
we could determine if two shapes on the
screen are overlapping so let's come
back to this program and let's sort of
see what we if we can figure that out
here so I can say for example what is
the distance between P 1 X and P 1 Y and
P 2 X and P 2 y and if that distance is
less than the sum of their radii then
let's draw a green background so if we
run this no green background and if I
were to put them at as overlapping yes a
green background so let's do something
where I can put this piece of code back
in here where I can just kind of move
this one's location as soon as I come
over here we can see we get this green
background and let's make the let's make
the stroke weight a bit bigger okay so
just so we can see here okay so you can
see we get when they're overlapped we're
not but while I've done this what I
haven't really done is I don't like the
way that I did this I just kind of had
some gobbledygook code out here that's
like checking these values together but
really what I want to say is the
following if p1 overlaps p2 then draw a
bit green background if P 1 dot overlaps
p2 then draw a background okay so how do
I make this happen how do I write code
like this this is so nice actually
this this is what what if what's going
on here I you know I know we have you
know I have a display function I can
display p1 I can display p2 I'm now
if p1 overlaps p2 then do something so
what's going on here just like there's a
display function I now need to write a
function called overlaps and what is the
argument what are the arguments to this
function okay so let's start doing this
what the reason why I'm sorry I kind of
like lost my train of thought here but
the reason why this is useful is this
way of thinking in terms of object
orientation and having a calling a
function on object and passing another
object into that function this is now
unlocking the key to what code I
actually need to write I need to write a
function as part of the particle class
called overlaps so I can actually go
ahead and do that but I'm missing some
stuff right what I said when I say
overlaps I'm passing in another object
so now what I need to do is pass in some
other object I'm just going to call it
other so the overlaps function takes an
argument which is some other object this
is a little bit strange conceptually
because we're in the particle class and
yet I have a function which receives
another particle what you have to
remember is the idea here is you could
call the overlaps function on this
particle in reference to another
particle you could actually check if a
particle overlaps itself but that would
be kind of conceptually flawed the other
thing that I think is key here is notice
this function is inside an if statement
so P overlaps p2 has to evaluate to true
or false right it either does or a dozen
which means that this function needs to
return a boolean billion value so the
function overlaps receives another
particle and answers the question am i
overlapping that other particle yes or
no return true or false just for right
now I could just say let's not bother to
implement this let's just write return
true in there and I'm going to take this
out of here
and get rid of this stuff we worked out
before and now I'm going to run this and
of course it's always green
because I'm always returning true now I
could go back to this function and I
could return false and now it's never
going to be green but this isn't what I
want to do obviously in here now here is
the place where I want to write that
code where the object that I am right
now the particle object communicates
with the other particle object so how do
we do that I want the distance between
what okay I'm a particle object I'm in
the particle class I want my distance
between my location X comma Y and then I
want the distance between my location
and some other particle that's coming in
as the in the argument its location
other X other not Y and then if that
distance is less than this my radius
plus the other radius return true
otherwise return false so this is now a
function inside of an object which
receives another object as its argument
so that the two objects can talk to each
other they could compare their locations
they can compare their size and if we
run this now you can see it's working
again the reason why this is so useful
and it's not really emphasized here is
that I could now check if I have five
different particles I could just check
if p2 overlaps p5 or if p3 overlaps P 1
or P 4 overlaps p2 so I have a generic
function that checks if one object
overlaps another object now I realize in
making this quick example this is a
little bit tricky and it might actually
been a little bit simpler if I had you
know particle objects and bubble objects
and the particles check if they're
overlapping the bubbles because then you
wouldn't have this thing where you have
a single object checking another object
of the same type which can be a little
tricky but this is kind of a way of
thinking that you I think want to get
used to so as an exercise I might give
you the following exercise take this
idea re-implement this basically this
exact same code and instead of having
two particles have three and can you
make something different happen when
these two overlap versus when these
to overlap and I think that would be
kind of a good a good way to start so
how could you have one how could you
have maybe try for particles or five but
particles and have different things
happen with different combinations of
overlapping and see how that goes for
you you might also want to file this in
the back of your mind that later when we
get to looking at arrays and lists of
objects how would you have every
particle checking if it's overlapping
every other particle which is kind of a
tricky problem okay hopefully this video
did some good run and I'm going to stop
now</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>