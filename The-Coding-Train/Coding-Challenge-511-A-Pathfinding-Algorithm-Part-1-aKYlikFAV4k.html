<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Coding Challenge 51.1: A* Pathfinding Algorithm - Part 1 | Coder Coacher - Coaching Coders</title><meta content="Coding Challenge 51.1: A* Pathfinding Algorithm - Part 1 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/The-Coding-Train/">The Coding Train</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Coding Challenge 51.1: A* Pathfinding Algorithm - Part 1</b></h2><h5 class="post__date">2017-01-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/aKYlikFAV4k" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello welcome to a coding training
coding challenge
what does the cookie train bring us
today okay forget about that okay so
what I'm going to do is something called
a star is a path finding algorithm I'm
actually recording this part of the
video that you're watching after I did
the challenge was a bit of a mess I have
to admit you what you're about to watch
is quite a mess it took me two and a
half hours to sort this out I had a lot
of bugs but what you're going to watch
is a little bit shorter some of it's
edited out if you want to watch the full
archive of the live stream you can find
a link to that in this video's
description this is the final result
what I'm using is an algorithm to find
the optimal path from the top left
corner of the screen to the bottom right
corner of the screen going around some
obstacles and you can see here this is
that path and there's a lot of pieces to
this the video is going to be in two
parts so the first part of the video the
only thing that I'm going to do is look
at how to make the optimal path from the
top left to the bottom right with no
obstacles and not being allowed to go
diagonally and then that video will
finish and the second part of the video
will show you how to add diagonals and
how to add obstacles and so enjoy watch
if you don't see the second half publish
as part of my feed go check this video's
description to be a link to it okay so
enjoy all boards the code train and
coding train or whatever it is enjoy
this a-star challenge okay
so let's dive in and make the a-star
algorithm or an implementation of it in
JavaScript so first of all what is a
star algorithm the a-star algorithm is a
search algorithm meaning there's some
space of possibilities and you want to
search through that space for a
particular you know needle in the
haystack so to speak a solution an
optimal solution out of all possible
solutions and typically speaking or a
lot of search algorithms maybe I'll come
back to others a star is applied to is
typically applied to a path finding kind
of search problem so let's talk about
what I mean by path finding so here's
one scenario incidentally scenario that
a star can actually be applied to is
trains like how to make a optimal path
of freight trains between all bunch of
cities to get stuff from one city to
another so let's let's sort of imagine
driving or car
any so if you have a bunch of cities
I'll just you know and they're connected
by rows in some arbitrary way not
everything is connected to everything
and you're starting at City a and you
want to get to City B what is the
optimal path to get there that's the
shortest so you know we could eyeball
this and I could probably actually go
closer look you one path better connect
things a bit more add some more cities
right so you can see there's more
possibilities here like this would be if
I were to start here and go like this
I'm going to get all the way to City B
but I can see that this would be shorter
so you could imagine an algorithm for
just trying out every possibility you
could use recursion because recursion is
this kind of like self-referential
function because you're at one city and
you try all the roads out of that city
and you get to other cities and for
those cities you try all the roads out
of both cities and do those cities you
try all the roads out of those cities
and eventually some of those paths will
make it to the end and then you could
keep track of how long it took you and
which one was the fastest you can kind
of do a search every single possible
possibility what I just described to you
is essentially what's known as
Dijkstra's algorithm Dijkstra's is an
algorithm that looks at every possible
path and tries to find the optimal one
it works and we'll find you the optimal
one but it's not super efficient so a
star is because it takes a long time
like this wouldn't make the long but
they're like thousands of notes takes a
really long time the a-star algorithm is
is very similar to Dijkstra's algorithm
but it uses a concept known as
heuristics I have no idea if I'm going
to be able to spell this heuristics
heuristics is like a really fancy word
so what you use it you sound like you
know what you're doing but it's really
just a word for describing a I would say
one way to think about is an educated
guess so instead of having to check
every single possible route what if we
could just sort of make a guess you know
this route is probably going to be the
best like I kind of know if I go
backwards it's going to take me longer
than if I go forwards so I can skip
checking the possibility that goes
backwards so this kind of heuristic this
kind of educated guessing allows you to
skip checking a lot of the possibilities
and makes the algorithm much faster and
the algorithm is typically written with
a formula the portal is actually quite
simple although any time you write a
formula starts to be like oh my god is
this really what we're doing today but F
of F of N equals G of n + H of n so I
figured what all these things stand for
the H stands for heuristic the G I know
why what a stands for Mabel we'll look
on the Wikipedia page and see but so
okay so F of n is the it's like a cost
function cost being like for each one of
these nodes how much does that node cost
in terms of our time in getting from
point A to point B the path we're trying
to find so if it takes we the G is the
known amount like this distance for this
node is G if I then went to this node
next the G for this node is this
distance Plus that distance that's the G
so the G is the like actual others they
cost the time distance from beginning to
end now the H is how long does it take
so G being like how long did it take me
to get from the beginning ain't just
like how long is going to take me to get
to the end so if I knew what G and H
were not as a heuristic but as an actual
value for every single node I could seek
very quickly what's the fastest passes
the idea is I'm reversing this tree this
node this path and I get to here I don't
actually know I know how long it took me
to get here I don't know how long it's
going to take me to get to the end but I
could make an educated guess because I
know where the end is I know the end is
over here I don't know how to get there
but I know where it is and what's my
educated guess how about just the actual
distance between these two points if
there were no roads I could just go up
in my helicopter coding helicopter you
know it was really important it's a ring
to it
that's at Cody train has a ring to it
exactly but anyway if I could go up in
my helicopter just fly straight there we
take this amount of time and an
important thing about your heuristic
your educated guess in an eight a star
algorithm is you don't want it to ever
overestimate the amount of time
underestimates it you're okay and how
the algorithms going to work if you
overestimate it you could have a problem
in not getting a sort optimal answer at
the end and in this case you can see
that there's no way to overestimate if
I'm using the actual distance because no
matter what even if there's a road from
here to there that's the actual distance
if there's a lot of other roads there's
a lot of other roads so that's the basic
idea for every single one of these nodes
I want to cop figure out how long I know
how long it took me to get there and
then I want to guess how long it's going
to take me to the end and whenever I get
so and the way this is going to work is
if I'm here I'm going to look at all of
the possibilities so I could go here I
could go here or I could go here and
what I'm going to do is I'm going to
look at how long it takes what the value
of how long it took me to get there and
the guess of how long will take me the
end of each one of these and I can
pretty much see that this one is going
to win so I'm going to pick the one that
the total cost of how long it took me to
get there plus my guess of how much more
I have to go that's the way I'm going to
go and you'll see it's still going to
leave the others as an option it might
have to back up and check some of those
other ones later but that will actually
work okay so let's look at actually
trying to implement this with some code
right now so I have the Wikipedia page
open to the a-star search algorithm and
if I scroll down something that's going
to be helpful to us is this pseudocode
so a lot of you know first of all I'll
try to there's a there's a lot of
tutorials you can probably find examples
of the a-star algorithm I'm going to
make my own I'm going to kind of like
use this as a something to refer back to
as we start to program as a reminder but
I'll try to explain things as I go as
well the thing that the thing that I
need to talk about I can't lie because I
came over here unnecessarily is that I
the system that I'm going to build to
I'm not going to build this node-based
type of now I'm going to build a snow
tastes type of map it could be a little
bit different let's say this is my
canvas okay and let's say what I'm going
to do is think about there are cities in
a grid the canvas is a big grid of
cities like this and every single city
is connected to
every city around it like this I won't
keep drawing on this line so if I'm
trying to get to here you know I might
figure out the optimal path you could
imagine it's something like this or
remember and then at some point what I'm
going to do is I'm going to add
obstacles and see how the a-star
algorithm can solve going around those
obstacles so this is a generic way of
finding a path through any given pixel
space because pixel spaces are just
grids and we could do things like then
add a source tearing agent to follow the
path or that sort of thing or we could
kind of create a non-traditional grid a
network map like this but I think it's
going to be a classic implementation and
demonstration is using a system like
this and if there's a full grid I just
didn't draw out all the pieces so that's
what I'm going to do and we'll see how
that goes ok so coming back the first
thing that I want to do is I want to
have a two dimensional array that can
store information for every spot in the
grid so let me go to my code and what
I'm going to do is I'm going to create a
variable called grid and I mean it's
just I'm going to use some Java syntax
and you know what I'm gonna do too is
I'm going to say I want to have some
variables that say there's always
there's gonna be on let's start small
there's going to be five columns and 5
rows so the grid is 5 by 5
two-dimensional arrays are sort of goofy
in JavaScript what I ultimately want to
do is I want to say things like grid you
know 0 comma your grid grid index 0
index 3 is like the first column and the
fourth row you know counting starting
from 0 0 is number 1 0 1 2 3 is the
fourth one so I want to be able to refer
to any spot in the grid by its column
and row position but the first thing I
would do is just make the array an array
itself with a certain number of columns
so the array is an array of strip number
columns each column has an array for all
those spots that are in the rows so what
I will do here is I would say for VAR I
equals 0 I is less than columns I plus
plus and I would say grid index I is a
new array rows so this this is really
making a 2
arrey and if i then say console dot log
grid we can see what i've got here
where am i this is where my code is
running you can see what is it - what is
a two-dimensional array and it's 5x5 so
but it's in a it's an array of five
arrays with five things in it okay so
that's the grid now what do I want to
put in the grid this is a question so
now what I want to do is every spot now
here's the thing remember this algorithm
that I'm working on the idea is that
every single spot has a cost associated
with it how long did it take to get
there and what's its guess for how long
it's going to take to the end so I want
to store that information in each one of
these spots I want an object that can
know what's my I'm a node I'm a Cell I'm
in this grid watch Mike what's my cost
okay so coming back over here I'm going
to do another loop that's going to go
through every column and every row and
I'm going to kind of do this in an
object-oriented way I should say that a
bunch of things I'm going to do in this
video I'm doing for easy readability and
not necessarily for optimal efficiency
I'm definitely going to make the most
efficient version of this algorithm and
I'll talk about some things maybe later
at the end that will see that to be any
more efficient but I want to make each
spot in the grid an object I'm going to
call it a cell spot let's call it a spot
I don't know what a good name for this
would be so I need what I need it's like
a constructor function to create an
object so every object will have a F
value a G value and an H value right so
those are the things that I'm a couch
stop spot stop every spot every spot I
need to calculate the G the H and the F
value need to know for each cell in the
grid what are those values there are
some other things I'm going to want to
know we're gonna have to add a bunch of
things actually let's let's let's add
things as we need them so that I've done
that okay great so now I have a grid of
spots and now what I need to do now
here's the thing the a-star algorithm by
definition is a loop it's trying a lot
of possibilities until it gets to the
saloon
and then it's done so what I want to do
is have my example demonstrate and
animate the process so I'm going to do
something a little bit different than
probably what's found in that Wikipedia
pseudocode pseudocode I'm using I forgot
to mention I'm using a JavaScript
framework called p5 and as a set p5 ask
you to write a setup function which is
kind of the beginning and I make a
canvas and draw as a function that looks
it's an animation loop what you would do
like normally would like set or
requestanimationframe or something like
that in native JavaScript so what I'm
going to do is I'm going to use the draw
loop as the loop so if I go back to this
particular page we can see here where is
that loop there's this loop here while
open set is not empty so this is just
doing this thing to solve the problem so
uh so here's the thing what's going on
open set close set so this is a concept
that's part of the algorithm that's
quite important we have this idea of an
open set which is an array or a map or a
list or whatever the data structure is
that you're using I'm gonna just use an
array and we have this idea of closed
set so the idea is that closed set
stores a list of all the nodes that have
finished being evaluated so this is
everything that's done that you don't
need to ever revisit that's going to be
closed set open set are nodes that still
need to be evaluated we need to consider
and evaluate them they're not closed yet
the algorithm is finished when open set
is empty there's nothing left to be
evaluated okay actually that's not
entirely right so the algorithm is
finished there's two ways the algorithms
have finished one is I'm going to be
searching through nodes and if I ever
arrive at the end unfinished because I
arrived at the end I found the optimal
path all the way there that's the way
this algorithm is working however if I
have nothing left is open set to review
nothing left to look at and I haven't
arrived at the end I also have to stop
that means that means there's no
solution so it's possible we could build
a you know a path a maze of obstacles
with no
get to the actual end and so if there's
nothing left to evaluate you haven't
gotten the end it's also so these are
important open so close that starts as
empty open set starts with just one node
right at the beginning the open set just
has just the starting node so let's go
into my code again and let's create time
to make some of these global variables
just so we can kind of look at them in
the console if we need to or evaluate
them closed set so I'm going to create
two arrays open open list open set open
set and close set and what I'm going to
do right here and setup is I'm going to
say on this a little bit slow make I'm
going to make a start and an end and so
start I'm just going to be the top left
the start node is grid grid at 0 0 and
the end node is grid at columns minus 1
rows minus 1 so you know these could be
picked randomly or through a variety of
other ideas of the ideas that I want to
start here and I want to get to there
that's I want to find the task from the
top left to the bottom right of the
window ok so then what do I need to do I
need to say open set push start so we're
starting with open set I'm going to look
that's the thing I'm going to iterate
through and check every possibility
there ok and so let's look at the
algorithm we're going to talk about came
from in a second G score we're going to
talk about that F score these are a
bunch of things but here's really where
I need to start I need to say while open
set is not empty as long as there are
spots to be evaluated let me start
evaluating those spots so the thing is I
don't need a while loop remember I'm
going to use the draw loop so because
the draws already looping I'm just going
to say if open set is not empty so I'm
going to say the way I'll say that is if
open set is greater than open set length
is
greater than zero great we can keep
going
otherwise no solution or MSA no solution
right there's nothing left I haven't
gone there's no solution now what I also
want to do just because I want to debug
this as we're going is I want to write
something where I draw all the spots in
the grid and maybe I debug in some ways
this will be good for debugging so I'm
going to do I'm going to write another
double loop this is a long problem by
the way this could be a kind of long
video are you still watching me
this could be like multiple parts but
maybe I should do multiple videos I
don't know okay grid I J and I'm going
to do show so I'm going to write a
function each spot is going to be a
function to show itself and what I'm
going to do is I'm going to say this
show equals function now ah so how can
the spot show itself it doesn't know
where it is so I'm going to give each
spot an X in each spot a Y so when I
create each spot I'm going to pass in
the I and J so each spot knows where it
is this is going to become important
later actually and then in the show
function I can draw a rectangle like
this dot X this dot y but here's the
thing I have a sort of scaling issue
which is that if my window is 400 by 400
by lamp 10 by 10 columns and rows and
you figure out how wide each cell is so
I can do that with some global variables
I'll just make a variable W and H and
what I'll do is say that W equals the
width divided by columns and the number
of columns right if it's 400 and I have
10 columns each spot is 40 pixels wide H
is height divided by rows okay this is
pretty good this is pretty good
and so then I want to just multiply by
that W multiplied by that H and then
have it with an hyah probably need one
variable to be honest because I'm making
everything a square but whatever
let's say fill 255 stroke zero and let's
run this again we can see there's my
grid yeah you know maybe what I should
do is I'm getting ridiculous here as I
should make everything like one pixel
left so I can see the full grid but
whatever so you get the idea
there's the grid okay good call good job
okay
so what I want to do is I also want to
do some debugging so what I'm going to
do actually let's make this show
function get a color and forget about
forget about the stroke I could keep the
stroke but no stroke so what I'm going
to do is whenever I call the show
function I'm going to use a color so in
my debugging I could say I want
everything to be white but I also want
to look at the closed list and I also
want to look at the open list Oh close
list and open set close that open set
whatever I can't remember what we called
I'm gonna say closed set index I dot
show and I'll make these you know green
or close they'll be red I guess somebody
will come up with more beautiful and
interesting colors and nicer design
choices and open set set will be green
or open and so now if we do this oops no
scope is not defined oh hey no Stoke man
that does not make any sense no stroke
there we go okay so we can see things
are looking up here now I can see that's
my open set
nothing is closed yet so I want to have
this because I want to be able to debug
it as it's going I need to draw stuff to
see how the algorithm is working plus
this is going to open a lot of
interesting visual possibilities for you
guys okay okay so let's keep going now
what do we do we got it so we got to
start thinking about this algorithm so
let's go back to the Wikipedia
pseudocode
the idea here is okay current should be
the node in the open set that has the
lowest s so in other words other words I
want to evaluate Here I am I want to
evaluate all the open set possibilities
and what has the lowest F what's going
to be the best thing getting me to the
end so how do we find what some things F
is and which has the lowest F so first
thing I can do is I can say for VAR I
equals 0 I is less than look I is less
than open set length I plus plus so I'm
going to say of our lowest index equals
0 so I'm going to assume in the open set
you know there has to be something in
the open set and we can assume that the
lowest one is the first one the winner
the record-keeper the I could say winner
index or whatever I don't know what to
call it lowest index it probably has a
variable name in the pseudocode so what
I'm going to do now is I do need to say
if open set dot index is is less than
open set lowest index dot F Louis and if
it's such a long which is call it
winner-winner dot F if it's less than
then the winner is I okay so we're
looking to see if we have which one is
the lowest that's good that's an easy
algorithm Lu clear everything find the
one that's the winner
okay what do we do next so first thing
we have to say if the winner is the end
we're done so let's add that in right
here if open set winner equals n
remember n is a variable that's holding
onto that last spot then console dot log
done okay so that's word we're done so
we start with the open set we look at
all the pot what all the things in the
open set what's best if it's if the one
that's best is actually the end then
we're great then we're done okay
now
the next thing is ok so then we want to
whatever one we found current is the
node in the open set having the lowest F
score so you know what I should do I
should save our current equals and this
is really winning index I'm going to say
open set winner
wheter winter is coming except not for a
while
what about six book coming out so they
let out another another topic for
another time
so if current and avoid it has a lots of
typos here remember if you want to test
is something as equals in JavaScript you
use double equals if you really want to
test if you really want to be sure use
the triple equals so if courage is the
end were done otherwise what do I want
to do I want to add closed set
push current and then I want to say open
set remove current only this is not any
actual real code so here's one of the
tricky things what I want to do is there
is a function in JavaScript to add a
particular object to an array that's
push there is no function in JavaScript
is just arbitrarily say hey this thing
if it's in the array remove it so and
this is where I'm going to not do things
so optimally but what I'm going to do is
I need to find that object and remove it
and I'm just going to write a function
remove from array open set current so
I'm going to write my own function I'm
going to stick it just at the top here
function remove from array I need a
function array element and then what I
need to do is I need to loop through the
array but I want to loop through it
backwards I'll sort of say why in a
second
I is the length of the array I is
greater length of the array minus 1 will
be starting at the end going all the way
down to zero and if array index I equals
ELT then array splice i1 so what is I
just really quickly wrote a function
that loops through the array sees if it
has that element splice being a function
to delete a particular element add an
index from the array and only one delete
that one array somebody in mister
somebody can
can tell me a better way to do it but
it'll work for right now maybe I'll come
back and optimize that later well why do
I go through it backwards the reason I
go through it backwards is if I'm going
through the array forwards and I delete
something then all the elements come
back and I'm moving forwards I could
skip an array so skip an element so I
want to go through it backwards so you
want to remove it open set where are we
move from array current from open set
current add to closed set great so now
what do we do if I go back to the
algorithm I need to figure out I need to
figure out if I need to figure out
what's going to be what what should I
add which I add to the open set what new
nodes do I need to evaluate and if we
think about this right if I have just
gone if I started here right this is the
grid then try to fill out a little more
of this just so it doesn't look so empty
if this is the grid what I want to do
I've just evaluated this it's my best
nodes I only had one choice that just
went into closed set it came out of open
set now I need to figure out what are
some nodes I need to check next it's
anything that's neighboring that
particular node this one this one or
this one as long as they aren't knows
we've already checked or finished with
before okay
so how do I get the neighbors so I need
some way look I'm in wrong keyboard I
need some way of figuring out what are
all of the neighbors of current well
guess what I think a nice way of doing
this one way of doing this would be to
add a function in the let's add let's
add an array so let's have each spot
keep track of its neighbors and let's
add a function called add neighbors what
I'm going to do is do things like okay
so add neighbors from a particular grid
I'll just pass it in and so what I'm
going to do is I'm going to say this dot
neighbor's push
grid oh boy this is awkward this dot I
plus one I'm gonna do something silly
just to make it a little more readable
save our I equals this dot i VAR j
equals this j i might need those out the
back I'm losing my train of thought here
but this is fine I plus 1 J so there's 4
neighbors right I plus 1 J I minus 1 J
IJ plus 1 IJ minus 1 so these are the
four neighbors I want to add those for
each object I want to each object as
neighbors but there's an issue what if I
is not is on the edge so you know
there's so many nice and probably
concise and strange and optimal ways of
writing this but I'm going to do
something really simple which just says
okay as long as I is less than columns
minus 1 then I can add that neighbor as
long as I is greater than 0 then it's
okay to add this neighbor and then as
long as J is less than rows minus 1 very
tedious here the way I'm doing this I
can add that neighbor as long as J is
greater than 0
oh and you know what I call these X&amp;amp;Y so
I'm this is one of these things about
programming you kind of keep track of
your stuff and I'm not doing a very good
job of naming things in such a way
that's making it easy on myself I was
calling it I and J and then I call it x
and y so you know maybe I'll change
these to I and J because it's not really
the X and the y the X and the y is
really the location this I times so I
think this is going to be better and
then if J is greater than 0 add this
particular neighbor so here now I can
add all the neighbors now where do I so
this is a function for any given spot to
add neighbors that are in a particular
grid where do I do that
well you might think I kind of want to
do it here but I have a feeling this is
going to cause a big problem right the
reason why I can't do it here
it's because this is where I'm making
all the spots and I can't add the
neighbors while I'm making the spots
because I want to made the spot that's
next to it yet so this is very
inefficient I'm sure I could come up
with a different way of doing this but
I'm just going to add a completely other
loop just to do this again and say add
neighbors so I want to make all the
spots loop through everything you have
everything add its own neighbors okay so
now just let's refresh this and see I
don't have any errors okay oh I know
what the error is I need I wrote it in
such a way that I need to pass in
because maybe you want to add neighbors
from a different grid and some other
life that you have okay I could just use
it as a global variable okay great now
I'm going to look at grid and we can see
that each spot has an F G and H I and a
J and a list of neighbors and the
neighbors something's wrong here Oh
which look at this look at these comma
in a totally nonsensical location it
doesn't that's not right at all some of
some a lot of you are screaming at the
computer I'm sure hopefully you are just
saying in a nice way like excuse me I
might like to point out your small but
subtle error there okay
why debugging is good okay let's look at
this again let's look at this and let's
look at this spot and let's look at its
neighbors right it's got three neighbors
and where is it it's eyes it's like the
location zero comma one let's go back to
the Wikipedia page for each neighbor of
currents we want to see what to do about
each one
all the neighbors we're going to add to
the open set but before we put them in
the open set need to evaluate them
so first let's say for each neighbor of
current so what I'm going to do is I'm
going to go here and where are we in the
algorithm sorry right here so I want to
get all the neighbors current dot
neighbors I'm just going to put this in
a variable so I don't think current dot
neighbors all the time var neighbors
equals current dot neighbors I'm using a
for loop to check every neighbor for VAR
I equals 0 I is less than neighbors
length I plus plus okay
so this is every neighbor and then I'm
just going to say neighbor equals
neighbors index I so this would be
checking every neighbor now what do I
need to do for every single neighbor
well the first thing I need to do is
that neighbor if I'm moving to that
neighbor the G should increase by one I
started here right it makes sense that G
would be zero here right the amount of
time it takes me to get to this spot at
the beginning from the beginning is zero
so if these are the neighbors I can
actually yeah these are the only two
neighbors I'm not doing diagonals so I
don't know why it circles out I just
realized I'll add diagonals later we can
see what that does but so I could add to
go here or I could go here and the G for
each one of these should be one right so
another way of saying it should be one
is it's whatever was previously
connected to plus one right because it
takes me like ten steps to get to here
and then I'm going here then this will
be eleven steps so the first thing I
want to do is I want to say neighbor dot
G equals current dot G plus one right
except I don't entirely want to do this
so let's go back and look at the
algorithms a couple things I need to
check first of all what if that neighbor
is in the closed set if the neighbor is
in the closed set then I don't want to
evaluate it right because it's that by
that definition is something that's done
already I don't need to revisit it I've
already visited there through some other
optimal path okay so let's add that in
so what I need to do is first say if now
how do I say if an object is part of an
object so this is again where I want to
do some type of efficient search is a
search algorithm but a searching within
a search to figure out if something's in
a list so I want to make that more
efficient somehow here so what if
they--if closed set so as long as the
closed set does not include the neighbor
then I can change its G value right
although can I really so let's look at
the algorithm here
uh sorry back here so you'll notice in
the algorithm this says the tentative G
score the reason why I actually don't
want to just automatically give it a new
G score is I might have gotten to that
if it's not in the closed set it still
could be something that's been evaluated
already and I might have gotten to it in
a bit more of an efficient way so I need
to check some things because if it's in
the open set already but it's a neighbor
I might have gotten to it with a lower G
score I want to keep that lower G score
so what we're going to do is say I'm
going to actually say a bar I'm just
call it temp G so I want to keep track
of what the G would be and you'll notice
in the algorithm it says current plus
distance between current and neighbor so
in a more generic version of this
algorithm where the nodes like to have
different distances between each other I
would have to evaluate that but the way
that I've done this over here but you
can see this pretty well is that
everything has a distance of 1 ok so I'm
going to add one now now what I need to
do is I need to figure out is this
something that's actually already in the
open list so does the open open set
include that neighbor so I want to check
is it something I've evaluated before
because if it's something I've evaluated
before I want to figure out is this a
better G wherever kind of like way that
I'm checking right now have I gotten
there more efficiently so is temp G less
than neighbor G if that's the case then
I've got a better G so now I can be that
new G I want to be the new G that's
lower than my old G old G so if we go
back to do I get that right so right if
the tentative score is greater than G
score don't do anything I'm just kind of
doing it in the algorithms to ago
subscribing a little different way right
but so then if it's not in there if it's
not in the open list then great neighbor
G should have that score and
open set push that neighbor so all of
these things they're either already in
the open set and if they're already in
the open set of things to be evaluated
still I should see if I've gotten there
faster than maybe I did previously and
if they're not in the open set then I've
gotten there and add it to the open set
okay so once I've done all of this and
we've got to check to make sure I'm
still within the right loop here the
right if statement right I'm still but
I'm still within this if statement of if
it's a neighbor that's not in the close
sense long as it's something to them and
now we can see is here's where I need to
do up what I need to do is figure out
what it's a G score and what's its new
what's its F score that's interesting
okay okay so on what I'm going to do
here okay
so I need to figure out what it's a
score oh it's time for the heuristic are
you guys excited
here's watch I don't know a really long
video so far and I'm only now arriving
at the point where you need to calculate
therefore juristic so I'm going to say
neighbor dot H right this heuristic is
the heuristic but I just want to use
that word to the sound so fancy between
the neighbor and the end so here's where
I now need to make an educated guess
what is the how long can I guess that
it's going to take me to get to the end
so there are a lot of different kinds of
heuristics and they'll give you
different results but it's terrific I'm
going to use just right now is just the
raw Euclidean distance I'm going to
change it later because you're going to
see I will get plenty different results
but I'm just going to say what's the raw
distance so I know that that's always
going to be less than what it actually
is but it's a good educated guess okay
so coming back here I need to write a
function and I'm zoomed in I'm going to
write a function at the top function
heuristic and between points a and B so
I want to say var D equals the distance
and distance is a p5 function between AI
AJ bi DJ so that's just doing what's
known as Euclidean distance who uses
Green see I'm just like how long is the
line between those two points and then
return D so that's the heuristic so if I
come back now into my algorithm the H I
haven't run this and why I don't
recommend usually I like to run the code
a lot in between every to make sure on
the errors but here we go the that
neighbors H is the distance between it
and the end and then that neighbors s
right is its G plus it's H okay so the
whole point of this is to know how long
did it take for me to get there what's
my guess for how long it's going to take
to get to the end add those two things
together and that's the sort of score of
this particular node and once I've done
that what do I do
going this is don't need to add that to
the open set see that anywhere in here
oh I did that already open set add
neighbor okay great I did add that here
so it's either already in there and I'm
updating its values or it's not in there
and I'm updating it so there's a little
bit of something like this doesn't need
to happen again if I'm not updating the
G because the heuristic is never going
to change but it's fine it'll work
anyway okay so now that that's good I
think we're good ah came from so well
I'll get to that later we're going to
need the came from thing so let's just
run this see what happens well it made
it to the end well Don okay so let's
let's make a bigger grid does that
really work yeah oh that just doesn't
look right to me okay well I think
there's a bug in my code which I'm going
to have to find definitely but I can't
be a hundred percent sure I heard missed
a key part of this which I really would
like to add so if I go back to the
algorithm here you'll notice this now
this pseudo code is written with this in
with a particular kind of style I don't
want to get too far into but you can see
that these are like these maps like this
is a map of all the G scores for every
spot this is all the
F scores for every spot I've done it
differently in a different way I have
this you know two-dimensional array of
all these spot objects each of those
have properties but one of the
properties that each spot needs is to
keep track of where it came from like as
I'm going through this where what was
the node that was previous to it I can
think of that it's like a parent node or
the previous node because eventually
once I get to the end and it's done I
want to be able to trace back and find
what that optimal path was so what I
need to do here is add oops where am i
what I need to do in the code is I need
to say sorry I need to say neighbor dot
previous equals current okay so I want
I'm going to just use previous I could
say came from or parent by mistake
previous where this neighbor came from
is current and so you know what I might
do up here just to be kind of clear
about this is I'm gonna say this dot
previous equals you know undefined it's
unnecessary because by definition be
undefined or null or whatever but I just
want to like have that in there so what
I'm going to do then is when it finishes
this is where it finishes right wherever
the open set
whenever the best the item in the open
set the spot in the open set with the
highest F score right the G score and
the a score combined the lowest that is
the best one if that happens to be the
end then I'm done so now what I need to
do is I need to find the path and the
way that I'm going to do that is I'm
going to make I'm going to make this a
global variable just again so I can kind
of evaluate this stuff I'm going to say
the path path path and so what I want to
do when I find the path where as so much
code here would be nice to like organize
this better is I'm going to say path is
a new array and as long and I'm going to
say bar I don't think I can mess
anything up by messing with current but
I'm just a temp equals current because R
at the end and as long as temp has a
previous right as long as
there exists a previous what I should do
and then I should also say pass push
temp I should pass push temp previous
and then temp equals temp previous so
this is an algorithm kind of business in
my head here a little bit I think I need
to explain that's right what I'm doing
is I'm starting with an empty list and
I'm going to put the end in the list and
then the end is connected to the one
before it so that goes in the list and
that was connected the one before so
that would goes in the list so as long
as there is a one before it put the one
before it and now the thing that I'm
checking is the one that was before it
so this is a nice little algorithm to
sort of backtrack over that path and
then what I should be able to do is when
I'm done I should be able to say if you
know where I want to draw this I'm going
to do this down here for and I better
sorry I'm scrolling around like a crazy
person I'm just going to initialize the
path as an empty array up here so I want
to say as long as I'm not gonna fit I
want to loop through the path and I want
to say path index I dot show with a
color 0 0 255 so again I'm not being
soft about the colors the clothes set or
read the open set are green and the path
is blue so let's see what happens here
oh you know what I should evaluate that
path always why not right to see what
the current path is only gonna do it
when I get to the end which makes sense
that makes sense that's the path I think
I kind of check I feel like there's a
bug in the code so one thing is I'm just
realizing is I can be done and I can say
like no loop to stop the looping but
there's no reason why I shouldn't just
evaluate what the current path is like
every frame and I can actually just do
that right here so let's do that
whoa what am I getting okay so I think
things are actually working and maybe
we're going to see some improvements if
I like add a few more things to the code
and also it kind of add some obstacle so
let's let's just keep going with this so
what I'm going to do a couple things I
want to do first of all this really
isn't an act a good heuristic where's my
heuristic function here it is using the
Euclidean distance which is actually
just kind of measuring that distance
isn't really accurate when I can only
make steps that aren't diagonal like
this so there's actually a distance
that's run called a Manhattan distance
or taxicab distance which is just
measuring the difference in X and the
difference in Y so let me let me put
that heuristic in which I think will
give us some results that look a bit
more like what we might expect so I'm
going to put that into this the absolute
value of the I minus the G let's see the
difference between the I values of the X
values plus the absolute value of the
difference between the J or the Y values
so this I can run this now and we're
going to see we can see it trying to
solve this problem if this despite thing
is the reason why it's covering this
whole space is because in a way like the
the top and the bottom are equivalent
in distance so it ends up checking
everywhere but we'll be able to see here
that if I were to just change the end
spot for example to where do I set the
end the end spot to like the 3rd to 4th
row then actually what it's doing is its
optimally finding that pass very quickly
doesn't have to check every possibility
because what are we doing we're using
the a-star algorithm so there's a couple
things that I want to add to this number
one let's add some obstacles so
obstacles are really going to help us
understand how this is working and
number two let's think about adding
diagonals as well and how that works if
we add diagonals</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>