<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>6.6: Steering Behaviors: Path Following - The Nature of Code | Coder Coacher - Coaching Coders</title><meta content="6.6: Steering Behaviors: Path Following - The Nature of Code - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/The-Coding-Train/">The Coding Train</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>6.6: Steering Behaviors: Path Following - The Nature of Code</b></h2><h5 class="post__date">2015-08-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/2qGsBClh3hE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">now that we've looked at the dot product
and we understand the concept of scalar
projection we're ready to look at the
path following example the path
following steering behaviour so let's
say for a moment we have a path and a
path we're going to define as a line
between two points something like this
so what is our goal here I mean first of
all we should point out that if what we
want is a shape a vehicle a creature
particle whatever we're calling it to
follow this path no we could actually
just put it on this path and move it
using a little bit of math and
understand the formula for a line have
it locked to that path that's not what
we're trying to do here we're trying to
create a flexible improvisational life
like steering behavior where a vehicle
is attempting to stay on this path so in
order to do that we didn't I didn't come
up with this we're gonna look at Craig
Reynolds scenario so actually I'm gonna
you know let's keep going with this so
Craig Reynolds does a few things have
stuff in my way over here first he says
okay a path has a radius so we're going
to think of the paths radius as a
distance from the line kind of like a
width of the path so we can call this
distance from the lots from the from the
center of the path to each edge the
radius of that path so first a path has
a radius then let's say we drop a
vehicle into this world with the past so
we have a vehicle here now we can
clearly see this vehicle is off the path
so one of the things that's important in
a in the steering behavior is to
understand is the vehicle already on the
path or is it off the path and actually
we're gonna take that one step further
the very first thing in the Craig
Reynolds steering behavior path
following is check vehicles future
location Oh a few dates good a few days
since I made the last video so I don't
particularly recall but I'm pretty sure
this is something we looked at before
and if not this is something that epi
in lots of the steering behaviors this
idea of a vehicle being able to
understand its future location how does
it understand its future location well
it knows its current velocity vector
right its current velocity vector tells
it how fast it's moving and in what
direction and what a vehicle can do is
say if I were to continue moving at this
speed in this direction five moments
later which we could think of as five
frames of animation later or 10 frames
or 25 frames I'm going to be in this
location so this is the future location
and when we look at the code what maybe
will if we could pause for a moment and
try to find where is the line of code
that says here's my location here's my
velocity add my velocity to my location
okay now once we do this the next
question we have to ask is is that
future location on the path right is my
future location on the path is it is it
within the the this diagram here at
least the top in the bottom is it within
the radius of the path I mean recently
here we can see no it is not but let's
just say for a moment let's have it add
another vehicle here and say this
vehicle here's the future location is
that on the path yes it is so we can say
here in our algorithm if yes do nothing
apply no steering behaviour so Craig
Reynolds steering behavior algorithm
says if you if your future location if
your audio on the path you don't need to
steer I mean why would you bother
steering I'm on the path I'm path
falling I'm already on the path about
five five yeah I told you to apply a
steering force got it so this is good I
mean oh if we're always on the path we
do nothing but if the answer is no we're
gonna go to the next step which is find
the normal to the fathom path find the
scalar projection to the path fob so
find I'm like just call it the closest
point on the path so if for some reason
you skip the dot product video because
you know all about the dot product
then then you might want to go and this
is confusing to use and you might want
to go back and watch that but here this
is the moment where we're going to use
that scalar projection technique we're
going to take this future location and
connect it to the path and a
perpendicular angle so this is that
point that we found in step four the
normal the closest point on the path
this normal point then you know you
should think like we've done enough
already my goodness all these steps all
this math the diagrams getting a little
bit complicated but we're not done yet
Craig Reynolds take this one little step
further where he says boy I don't have
enough space here
he says predict I don't know I don't
know let me figure out a way to write
this let's just say move along the path
this is probably not now it's written a
little bit so this is by by just mental
it was my way that I'm stating this step
right now move along the path a little
bit what what what Craig Reynolds says
is okay so that is the closest point
along the path but this vehicle in order
to steer back on to the path let's in
the same way that we predicted the
vehicles future location let's predict
the let's move a little bit further
along the path to a future location in a
way so let's say we move a certain
distance along the path and now we have
this is now the target and that so this
last step yields us a target and the
very last thing we do is seek that
target so we just use this seeking
behavior so in essence the vehicle says
where am I going and my good moving line
is where I'm going to be off the path if
it is let me seek back onto the path so
remember every steering behavior boils
down to a desired velocity right what is
my desired velocity at this moment if
I'm already on the path my desired
velocity is my current velocity if I'm
not on the path my desired velocity is
the velocity pointing towards a future
target along that path so we have an
elaborate set of steps here but we
luckily we've learned all about vectors
we've learned all about the dot product
we understand about velocity we
understand
modeling motion we could we have all the
tools to implement this algorithm any
question okay right QQ you don't even
exist at this moment okay so let's take
a look at a couple things first let's
look this is Craig Reynolds site you
link below where you can find the the
demonstration of the path following
algorithm and you can see in this
dialogue a diagram I guess in this Java
applet that's running online that red
dot is that vehicles future location and
you can see as soon as that dot moves
off the path the vehicle starts to steer
otherwise it's moving at a constant
velocity you can also see on the diagram
where there's these red and white
circles which are showing the target
along the path that it's steering
towards so this is a great demonstration
excuse me
and I don't think I've ever done that in
one of these videos before could be like
edit that out maybe you didn't even
notice good okay so but let's look at
this what we need to do is look at this
in processing so this actually this is
quite complex the path is a lot of
points it's very curvy there's lots of
things being drawn in here
so the first processing example that I'm
going to show you simplifies a bunch of
things and in essence the major thing
that it simplifies is that our path
right now is just a straight line it has
a start point and an end point so it's
not going to be that interesting to look
at the result but at least we can work
out the algorithm and as soon as you see
I'm going to add a vehicle and you can
see look it's steering it's the students
it's off the path right I want its
future location while it's off the path
it's steering and as soon as it's on the
path you can see both of these vehicles
are now moving at constant velocity so
they're moving kind of slowly the path
to the straight line they're not really
going to go off the path anytime soon so
you know but I can add a lot more and we
can see the kind of behavior that we're
getting when I add a lot of these
vehicles that they're all kind of locked
onto this path now they all have varying
maximum speeds and maximum forces so we
you know we almost have this like
traffic like behavior and you can
imagine if we could make our path more
sophisticated and if we could even add
some more stuff later where to see if we
can add a little separation force
between these we've got something that
really starts to simulate
you know a crowd of vehicles on a crowd
of things
creatures on a path so let's look at a
few elements in the code in terms of how
this is being done okay so element
number one that I want to look at is
that we have a new class this class it's
called a path class and this is very
simple it just has a start point and an
end point and a radius so this is where
we're starting the point that I'm saying
here is we need an object to describe
the path but ultimately what we're going
to need is not just a path that has two
points beginning in an end we're going
to need a path that connects a series of
points right so that the path might have
a you know it can be much more
sophisticated than just a single
straight line but this is a beginning
here a start and an end the other piece
that we need to look at here is okay
well what's going on in the vehicle the
vehicle is the same thing we've always
had location velocity acceleration a
size back to the forest maximum speed
all that stuff we used to have seek we
had arrived we had flow field fault a
flow field function now we've added a
new function called follow and what does
this vehicle do it follows a path object
so now what we've said is if we look at
the main program here that we said I
don't know why they call them car here
every car can follow the path so we're
adding a new piece of functionality
we're saying the vehicle can follow a
path right so this is this is where the
guts this is where this entire algorithm
that we've worked out is all going to be
in that follow function so if you're
looking at this on your own time later
or you're pausing the video that's where
you want to go look look at that follow
function look at these steps find the
couple lines of code the corresponding
each one of these steps I'm going to
walk you through that right now for a
couple minutes okay so let's go to that
function and let's take a look okay the
first thing we need step we can see is
like predicting the object's future
location and look at how we're doing
this we make a vector that's the
velocity vector copy we say hey velocity
vector let's make a copy of you let's
set your length at 50 pixels and add
that to the location right so what we've
done is we've said hey here's an object
give me the velocity vector set its
magnitude to 50 pixels and
at the location that is the objects
future location and that what we've done
here right here in the first step so
great
we know the objects from a future
location we have to ask ourselves is
that location on the is that location on
the target well how do we know I'm sorry
if I can't say anything right today we
want to know is that future location
within the radius of the path how do we
know that we need to know the length of
this line is the length of that line
greater than the path less than that how
do we know the length of that line we
need to find this point we need to find
the distance between those two points
all that stuff is baked into this
algorithm we're gonna find the distance
to the the we're gonna find the distance
to the path is it greater than the
radius then we're gonna apply a steering
force how do we do that well look at
this we have this function get normal
point we have the we have the predicted
future location and we have a and B
which are the beginning and end of the
path we have the predicted location this
is a and over here the end this is B we
need to find this point so there's a
function that does that called get
normal point what's in that function all
of the math for scalar projection that
we did in the dot product you can go
back and look at that if you want I
don't I won't scroll down and look at it
that's where all that is once we have
that point we can find the distance
between the predictive location in the
normal point and if that distance is
less than the radius seek the target
along the path what's the target along
the path it's a point a little bit
further than that normal point which I'm
calculating here by just what is that
what is the vector of the path move a
little bit further along the path so you
can see all those steps are here step
one step two step three step four in
step five the very last step is seeking
that target okay so I think this pretty
much covers the basic path following
example but we still have a bigger
question to answer and so I'm going to
answer that in this in this video even
though what kind of gone I'm going on
a little bit longer than I had intended
if you want a really difficult exercise
for yourself pause the video now and go
try to take this example which is oops
oh I'm in the wrong place I was talking
for a while which is example six point
five take example six point five and try
to expand it for a path that has
multiple line segments but I'm gonna
talk you through that right now okay so
we know now based on example six point
five that we could follow this path what
what if I want to follow this path well
first of all how do we define a path
like this you know we could do all sorts
of crazy curve interpolation formulas to
make this really beautiful curve but the
point is if we can draw this curve
remember we're just trying to get a
vehicle that kind of looks like it's
following it so there's no reason why
our actual path data couldn't just be a
selection of points that's on this curve
so whether you're finding the contours
of an image or you have a data set
that's a graph if you can get the points
along the path right which we think of
as connect which the data wise will just
be connected straight lines but you
could visually draw it however you want
it's gonna look quite a lot like it's
following this curvy path then if we can
follow a single line segment can't we
follow a bunch of line segments so
that's step number one if we look at the
next example which I'm going to show you
shoot minimize this which it is right
here which is six point six the main
innovation here is our path class now
has an ArrayList of peak points are you
still are you awake are you still with
me
right it has an ArrayList of points it's
not just a start and an end it's point
zero point one point two point three
point four all connecting and making a
big path when I run this example you're
gonna see that here in fact every time I
press the spacebar I get a different
path and we can see look we have a bunch
of vehicles now following this path okay
now that we've figured out what the path
class has to look like let's give
ourselves a new scenario so I'm gonna
actually
draw a path as a series of connected
points which I'm arbitrarily from the
board it's probably way too complicated
we could see this this could be a path
that we want to follow and let's say I
have a vehicle and my vehicle right now
is over here and here is its future
location great so what's step two once
we have a vehicle's future location what
we need is the normal to the path we
need to find the distance from a future
location to the path so let's work on
that okay I got it I got it point we're
done yeah okay obviously I missed
something that was my little play-acting
thing here okay but because what what
did I miss
actually I got one right over here it
wasn't normal to the path I'm gonna draw
that perfectly there's one an even
weirder like let's extend this pretend
this line was like an infinite line look
there's another normal to the path
really over there so like there's all
these normals to the path because
there's all of these line segments I
could make one for this one for this one
for this one for this one I extended
this out what do we follow how do we
pick this oh my god
I think we're gonna be fine right we can
come up with something I mean uh first
of all you just read Craig Reynolds
materials to be like thank you you came
up with it but there's really it's not
too hard to think of it the whole point
of finding the normal to the path was to
find the closest point on the path to my
future location well we have a whole
bunch of options why don't we find the
one with the least distance so if we
pick the one with the least distance
which clearly from this diagram we can
see is this one the other thing is we
could disqualify anywhere the normal is
not actually on the actual path even
though you're big of all these lines so
this one can be disqualified instantly
and now we have to pick between these
three and there's four and five which we
can disqualify we can see that this one
has the shortest distance so this is
actually excuse me their target that
we're going to seek we're not seeking a
target over here or over there so this
is a methodology we can employ and is in
fact the methodology that you will see
in my processing example what we have to
do is say look at this line segment find
the normal look at this line segment
finally normal look at this one finally
normal this one find the normal this one
find the normal this one find a normal
all of those distances which one is the
shortest pick that one to seek so let's
see if we go looking our algorithm let's
see what's actually changed in the code
okay so this was the example we were
running let me turn it off for a second
and go to the code and we can find sorry
the they excuse maybe I'm looking for
the follow function talk amongst
yourself for a minute here we go right
so we have the same whole thing where
first we need to get our future location
by making a copy of our lawsuit velocity
moving forward from our Legation we have
that future location look what's going
on here now we were doing exactly the
same algorithm we did before but points
a and B aren't just the start and the
end points a and B are 0 &amp;amp; 1 1 &amp;amp; 2 2 &amp;amp; 3
3 &amp;amp; 4 I and I plus 1 so we're going to
do that find the normal point and find
that distance for every single one and
what we're looking for is the
world-record distance so if you walk
through this algorithm you see every
time we're gonna say hey is my distance
less than the world-record distance if
it is the world record is my distance
and that normal point is the one we're
going to save when we're done with this
algorithm then we just say hey as long
as remember that distance is greater
than the radius as long as we're
actually off the path let's seek that
target so so that's the full algorithm
it's really if you look at these two
examples they really are exactly the
same the difference is in the first
example we're just looking at one line
segment in the second example we're
looking at a series of line segments and
finally the one with the shortest
distance and if we run this again we can
see here that we get our vehicles
following the path and we can add a lot
of them we can keep what's kind of nice
about this which didn't occur to me is
that if you have a path that's changing
the vehicles will adjust which is kind
nice behavior somewhat similar there's a
lot of similarities here to the flow
field following right you really have a
set of vector so you can almost think of
this as a flow field that's just defined
by a path instead so what could you do
with this boy probably a lot of things
you probably have a lot of ideas let me
give you a couple exactly like move with
Perlin noise or something so think of
the points on these paths as as entities
with location velocity acceleration like
a what if you took like a springy
something from toxic lives which is like
a springy wavy thing and had things
following that's probably pretty
complicated yeah another thing you could
do is find trace the contours use edge
detection blob detection find the
contours of an image in a magical place
I would like point you to a video all
about blob detection which may exist
someday and I like dub my voice over
here and now I'll go to this video but
because I don't know why you put your
hands over your mouth when you does
anyway so but mostly I would suggest
another thing that you really might want
to play with is try try lots of
variations making the radius bigger the
radius smaller chain do things with the
vehicle in terms of affecting its
maximum force and maximum speed see what
type of on see how good and how bad you
can get something to follow path another
thing you could do is can you make a
closed loop path right you could make a
racing a simulation essentially by
having a path that closes its loop at
the end so right now this path has a
beginning and an end and the vehicles
wrap around but what if you instead had
a circular path so try that just
rambling okay
good good luck or just I don't know it's
like 11:30 in the morning I would like
to take a nap but it's not time to say
goodnight
okay the next video is coming soon</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>