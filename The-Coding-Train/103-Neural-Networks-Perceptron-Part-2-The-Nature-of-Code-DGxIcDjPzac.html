<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>10.3: Neural Networks: Perceptron Part 2 - The Nature of Code | Coder Coacher - Coaching Coders</title><meta content="10.3: Neural Networks: Perceptron Part 2 - The Nature of Code - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/The-Coding-Train/">The Coding Train</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>10.3: Neural Networks: Perceptron Part 2 - The Nature of Code</b></h2><h5 class="post__date">2017-06-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/DGxIcDjPzac" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello welcome to a follow-up on my
previous perceptron coding challenge so
if you happen to watch the previous one
if you hadn't you probably should go
back and watch it link in the
description
I created a simple perceptron as'
perceptron is a model of a single neuron
that receives inputs and then produces
an output and this is a very simple
scenario where the output is only trying
to guess whether a point is on one side
of the line or the other is it above
this line or below this line so in this
follow-up video what I would like to do
is really just refine this example
nothing really about the mechanics of
the perceptron itself but make this
example a bit more sophisticated and
allow for some more hopefully some
possibly some more creative
possibilities so first thing I got a
bunch of things I'm going to do I would
list them all but I can't remember
there's just going to say what the first
thing is the first thing is let me come
over here to the whiteboard so what I
did with the first perceptron was just
used the raw pixel coordinate of the
processing window I can't remember what
sisal is but you know it's like a 640 by
480 window and 0/0 is over here and you
know this turned out to be the line and
I was looking for points over here but
the idea of using a neural network based
system is typically to get some kind of
data input that's not based on pixels so
what I think that I want to do here is
just redo this example and consider a
Cartesian plane with zero zero in the
center and why pointing up so whereas
this is 0 and this is 480 down here you
know 480 would be kind of up here so I
would like to just redo this whole
example and then the line y equal X we
should see as appearing like this the
reason why I want to do this is the next
thing I'm going to do is create a
perceptron that will learn any division
of data points so it doesn't just have
to be a division that's slicing it right
down
middle so first let's make that change
so how do I make that change hmm
well where do I make the point I think I
had this I had this point object and the
point object makes a random point of
random point with a random exile in a
random y-value what I'm going to do and
I think you know I'm going to just make
these now random values between negative
1 and 1 negative 1 and 1 ok so the
random values are between negative 1 1
in some ways that's it done aha but now
right before I show them what I want to
do is I'm going to say px for like pixel
X and I'm going to map X which has a
range between negative 1 and 1 to 0 and
width map is a built-in function in
processing it takes a value with 1 range
and maps it to another it's very simple
math and I actually have a whole other
video which I will try to link to that
goes over the map function and why I
could do the same exact thing so let's
look at this except for with Y right
what I want is why when the Y value is
high I want it to be low in terms of
when it's high I want it to be it's
flipped right 0 0 instead of positive
pulling down to point up so I want to
reverse that mapping and the math
function does that for you by saying hey
when Y is negative 1
it should be at the bottom and when y is
1 that's the nicer way to say it should
be at the top 0 ok now if I were just to
run this and it kind of looks like a
whole lot of nonsense right didn't seem
to work well first of all I forgot I
forgot a major thing I did the mapping
but I'm still drawing the ellipse at
those knit at those values let me say px
py
ok good look at this there are all the
points and you can see how they're
divided but the line is drawn in the
wrong place so where do I draw that line
so I'm just going to change the
coordinates I'm bit of hard-code new
coordinates for the line we'll deal with
that later but so I'm going to say 0
comma height 2 with comma 0 and we
should see there we go there are all the
points now what's going on
for I had this thing in it in this
program where I would draw a red or
green ellipse whether or not the
perceptron had guessed correctly and
that's not working anymore because I am
NOT doing the mapping anymore so I need
to also just take this same exact math
and probably I should package that into
a function or make it part you know what
I should do I should make ha the point
object should just have a function
that's called get a get pixel X is a
little bit of an awkward naming get
pixel Y let's just call it
forget about pixel X and pixel Y so I'm
just going to calculate these on the fly
whenever I need them and pixel X will do
this return that mapping and pixel Y
will return that other mapping there we
go and then I could just get those
values here and get those values here
this should be the same but at least I
took that mapping and put it into its
separate function that way when I need
it here I can say PT that pixel X and
point got pixel y
so rather than draw the ellipse at that
point x and y I can trigger those pixel
X with pixel I functions like that was a
nice little like little addition I had
there this is exactly the same program
the only thing that's different is the
points now live in a traditional
Cartesian plane and then I'm mapping
those points on into the pixel space
when I want to draw them great so that's
step one of this follow up video
complete let's do step two so what is
step two I want to change what I want to
change here is this if X is greater than
Y I want to be able to have let's come
over here
any particular function so I could say y
equals
3x plus you know plus 2 right that would
mean if x is 0 then X is 0 then Y is
going to be at 2 if X is 1 Y is going to
be at 5 so you can see this is that
particular line so I want to be able to
train the perceptron to recognize this
versus this and I want to be able to
change this formula I can make it
negative 2x minus 3.7 I want to be able
to have any generic formula for a line
work with this example so let's add that
into the code so I think the easiest
thing for me to do and I'm just going to
put it in this tab is to write a
function I'm going to call it it's going
to return a float and I'm actually going
to call it s it's not like a terrible
thing to do f of X being the function
for and they'll call this like lying and
whatever I would call it f of X and I'm
going to say return what did I say 3 at
3 times X plus 2 so this function
basically represents the formula for the
line and I'm going to say y equals M MX
plus B right that's the formula for a
line we've seen this in other so funny
how all these examples have this like
two dimensional space with a line in it
is the simplest way to start working
with data and visualizing that data but
ultimately as I get further along these
machine learning examples we're going to
have these you know n dimensional spaces
that we can't even fathom or visualize
okay okay so now the one thing that's a
little bit of an issue with this is my
mapping is between negative 1 and 1 and
negative 1 and 1 I want to make sure the
line isn't kind of off and out of our
view so what I'm actually going to do is
I'm going to have this be zero point
three times X plus deer opponent again I
could have changed the mapping to
between negative ten and ten but I kind
of like this idea between negative 1 1
for whatever reason so I'm going to
change it to that and now what I'm going
to do at least just want to draw that
line so I'm actually not going to change
any of the code in this example I'm just
going to
can I draw that line so this is where I
previously drew the line so what I want
to do is I want to draw a line from net
what up from where I want to draw I want
to get the Y value for when X is 1 X is
negative 1 and the y value for when X is
1 and then I can draw a line between
those two points
so okay so I'm going to say negative 1 F
so let's I'm just going to say x equals
negative 1 y equals f of X this is x1 y1
and then the second point is x equals
positive 1 and y equals F of x2 y2 is f
of x2 so I'm going to draw a line from
x1y1 to x2y2 and you know this is a
perhaps a very long-winded way of
writing this but just to see what I'm
using is that formula for a line to get
the corresponding corresponding Y to a
certain X can we run this ooh what's
wrong with this function oh whoops I
have to say float X I lived in
JavaScript land for a second I must set
the type for that variable probably
everybody in this chat was probably
shouting me about that ok where's the
line I don't see it why don't I see that
line ah guess what guess what I forgot I
have to do that napping mmm all right
all right everybody settle down I'm
going to do it I mean everything means I
would ever use that pixel Y so I'm going
to say point p1 equals a new point which
is at negative 1 F of negative 1 I'm
going to do I'm going to write this in a
bit of a crazy way p2 is a new point ah
new point between at one F of 1 ok and
then I'm going to draw the line from p1
pixel X can I please type today p1 pixel
X too fast for this part I'm typing
you can pick the life and then P to
click selects P to picks a lot but look
at this why am I getting an error here I
want to make a point at a specific X&amp;amp;Y
what is point do what is the point
object do I can make a point at a random
point but I can't seem to make one at a
specific point well guess what guess
what
in Java processing is Java you can do
something called overloading just so
happens that I'm going to cover
overloading constructor overloading in
this case I could say I want to have
another way of creating a point and I'm
going to use the underscore kind of ugly
underscore notation but what I want to
do is pass have some arguments to the
constructor I don't want to call them X
Y because the point objects variables
are to X or Y so I'll call them X
underscore and that's going to be a way
that I can do this
I could also figure out the label but
I'm not going to worry about the label
in this case because I'm not using I'm
not labeling these points I'm using them
just to draw the line okay so now that
went away and I should be able to
there's that line so there's a lot more
there's a lot of work just to draw that
one line and you can see though I can
change the formula for the line if I say
you know minus negative point two now
the line is further down if I say minus
0.3 the line is pointing the other
direction so I can now create any
formula for the line and visualize that
in the window okay so now what's going
on here this is now so now that I have
this formula for the line I need to
change this no longer do I want to check
just is X greater than Y how do I
determine and I'm looking for my eraser
how do I determine whether a given point
is above or below the line so let's say
I have this line and the line is y
equals 3x plus 2 I know it should be
alright let me try to be more accurate
about
I'm going to clean it up more and I have
some points so let's say I have the this
is the Cartesian plane here kind of
drawing this is a mess okay so let's say
I have the point X X comma X's of three
so if X is three then this point is
three comma 11 right I think because 3
times 3 is 9 plus 2 is 11 so if I had
the point 3 12 it's above if the Y is
greater than the Y that would be on the
line and if I have the point like 3
comma 3 it's below if the Y is less than
the Y that would be on the line so I can
do that for any value of x so if I take
any value of x all you do is calculate
the point that's on the line
if you whether it's greater than or less
than so let's add that into the code so
here what I want to do is I want to say
a lot of us a line y equals f of X all
right I'm going to calculate the actual
Y value for this particular X on the
line then all I need to do is ask is the
Y value above it then it's a 1 or is it
below it then it's a negative one so you
know if you think that's done now and
there we go so we should be able to see
this perceptron over time learning to
figure out whether points are above or
below that line it's a little bit stuck
right now you can see that it's and this
probably has to do with learning rate
and you know how it started how the
initial weights were started but so I
want to kind of figure out like why is
it kind of stuck so why is this getting
one reason reason why this is getting
stuck and I mentioned it in the previous
coding challenge and I completely forgot
about it until now the bias so let's
talk about why does there need to be a
bias here's the thing let's consider the
point two zero zero when I say well this
is the point zero zero y equals zero
times
x plus 2 the corresponding Y value is 2
so 0 is below the line here's the thing
with my perceptron and I send in the x
value and the y value if I send in 0 0
no matter what these weights are if I
multiply the inputs by the weights in
something I'm always going to get a 0
coming out which can't be right and this
actually in this formula for a line y
equals n X plus B these wings are
actually just describing the rise in the
runs the right terms of the line the
slope the numerator and the denominator
you can almost think of this as I think
weight 1 divided by way 2 times X plus B
for bias the bias being the y-intercept
of that line where is it so what the
bias is is a perceptron is another input
that always has the value 1 but has a
different has its own weight called the
bias weight and now you can think of
this formulas y equals weight for y
divided by weight for X versus the other
way around somebody's going to tell me
in the chat plot times X plus wait for
the bias times 1 so hard this is times X
does this make sense so this is really
what the perceptron is learning we know
the formula for the line and we could do
all this with Mac's a neural network is
often referred to as a universal
function approximator thank you to the
chat who just posted that terminology
right we with a simple like two
dimensional space and a formula for a
line we can do the math directly but
here you can imagine once our data
inputs that gets which we have all this
data with lots and lots of inputs beyond
that are in n dimensional space we want
to be able to approximate a function to
work with that data and this is we're
seeing as beginnings of that here ok so
let's go now and implement the bias in
the code alright so for the bias there's
a couple things I want to do number one
is I'm just going
add that to the point I'm going to say
it has float b4 buy it which is call it
bias and bias is always equal to one so
every point is going to have an x and y
and a bias and then the perceptron now
needs to have three weights needs to
have the weights for the two inputs the
x and y and the bias and one thing I
might do is give the perceptron
constructor a number of arguments so
that we could have a sort of board
generic Piet perceptron and I could say
weights equals new float N and then when
I create the perceptron I want to say
perceptron three and then here oh this
was just something I had just to test
the code now the inputs should always be
an array of three things and is there
another here training should always make
sure to include that bias I think I was
able to get all of the and so let's run
this again we can see that it's still a
little bit stuck I'm pretty sure that I
have the correct code now but here's a
way that I'm going to be able to
determine whether it's working or not
what I want to do now is also visualize
what the perceptron currently thinks is
the line so remember this is where I
drew the the actual line the correct
formula for the line what I want to do
now is let me ask you I can do this with
the perceptron so I can say point p1
equals new point negative one and I'm
going to say what did I call the
perceptron brain brain dot guess why
negative one so I'm going to ask the and
p2 is one brain dot guess why and then
I'm going to draw the line oh let's call
this p3 and p4
so I am going to attempt to draw the
virginal line that the perceptron thinks
and this should be one so now if I go
into the perceptron and I say I already
have a function called guess guess why a
little bit awkward here naming wise
guess why and I have an x-value the
formula for the line
so the slope should be weights index 0
divided by weights index 1 and the
y-intercept should be weight index 2 so
I should return X M times X plus B so
something's happening here but I think
I'm off right maybe what I meant to say
was weights 1 divided by weight 0 so
this is the line trying to learn boy
it's really not doing a very good job so
I think I need to take a closer look at
this and figure out what if this is
really right I was just kind of trying
to guess so there's a way we can
actually do the math for that properly
remember the perceptron right the X is
multiplied by a weight the Y is
multiplied by a weight the bias is
multiplied by a weight all those are
summed so the formula for the line that
it's learning is actually the zero
weight times X plus weight index 1 times
y plus weight index 2 times B all of
this should equal 0 so that means weight
index 1 times y should be weight next 2
times B minus weight index 0 times X and
then Y shared equal weight 2 divided by
weight 1 times B minus wait 0 divided by
weight 1 times X I think that's right
it's pretty different than what I have
let's take a look
oh there's a major error here even
before I got to this thank you to Ethan
Elliot in the chat I forgot to
initialize the bias in this constructor
what a disaster so probably do save me
from myself I'm just going to initialize
it up there wonder it that's really good
so I never actually even had a bias so I
think this is actually working but I'm
not visualizing this line perhaps
correctly so let's go back now and let's
see where do I want to do that I'm going
to say y equals so let me let me use the
formula that I just used return so let
me do this I'm just going to create some
shorter variable names to make this
easier to look at and I'm going to say
return looking over here at that formula
I wrote over here I'm going to say
return ww2 divided by W 1 times B time
sorry times bias o times 1 device is
always 1 so W 2 device divided by 1 plus
W 0 divided by W 1 times that X value
now let's take a look and see now if
things are working as they perhaps
should I think you can see that it's
actually I flipped somewhere do am I
missing a negative oh this should be
negative switch this to negative
this looks very close but it's kind of
off right thank you to the chat somebody
in the chat just told me that my
equations are wrong and they are this
should be negative right because this
all of these had up to zero so I need to
take it to make this equivalent y1 times
y equals negative Y W to W 1 times y
equals negative W 2 minus negative W 0 X
so that's going to fix it ok so now I'm
going to say negative here and we're
going to run this and we're going to
watch the perceptron overtime and you
can see as it's correcting all those
circles are turning green with this
learning rate slowly over time the line
is converging to the correct spot the
perceptron learning line so you know
there's going to be a part three in a
part four to this because I think I'm
going to wrap up this particular video
there's some other things that I wanted
to add to this but at least now in this
video I've added the bias
I've made it so that I have a Cartesian
space I can work with and I can work
with any formula for a line as you can
see life is just one big refactoring and
there's so many things I could do to
refactor this and visually I still don't
necessarily love what I have here in
terms of explaining what's going on but
at least now let's just before I go
let's make a new formula shout out your
numbers to me nobody can shout out to me
eight nine times X plus point two or
let's do minus 0.2 minus 0.1 let's just
have a different formula for a line and
see that this again works we can also
probably have a much better sense of
what learning rate is doing like look
what happens if I make the learning rate
point two right now you can see how it
makes these very large movements so it
gets to the correct answer very quickly
but it can do the fine detail to really
find the correct spot
and if I make the learning rate really
ridiculously small you know you can't
even see mean it is in theory this line
is moving it's so small that I can't
even see it let's not be so crazy let's
do that when I came in to find the line
the line currently isn't even in the
space because remember it starts with
something random let's run this again so
this line is moving but it's just really
really really slow so it's all about
finding and that learning rate can
change over time I could start with a
large learning rate I should make a
slider to adjust the learning rate I
could start with a large learning rate
so it gets close look at that it just
pop locked right in and then I could
lower the learning rate for those
refined motion movements okay so a
couple things I want to do I think I'm
going to make a couple follow-up videos
on this they'll appear at some point but
there was a great comment in the
original first version of the coding
challenge about adding data that is not
part of the training set which of course
is very important in machine learning so
I'm going to do that in the next
follow-up to this perceptron coding
challenge thanks for continuing to watch
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>