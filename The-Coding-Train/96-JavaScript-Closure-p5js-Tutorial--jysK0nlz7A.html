<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>9.6: JavaScript Closure - p5.js Tutorial | Coder Coacher - Coaching Coders</title><meta content="9.6: JavaScript Closure - p5.js Tutorial - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/The-Coding-Train/">The Coding Train</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>9.6: JavaScript Closure - p5.js Tutorial</b></h2><h5 class="post__date">2015-12-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/-jysK0nlz7A" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">in this video I'm going to tackle a very
confusing but fundamental and important
topic in JavaScript programming
something called a closure it's a big
topic and I think I probably could do
several different videos around it I
could also probably slow into it a bit
more but in this video I'm just going to
look at it in the context of set
interval and kind of unpack everything
that has to do with the closure with
this particular example and then things
will be confusing and you'll feel a
little weirded out and I'll come back
and make some more videos based on
questions people asked with some other
scenarios that will hopefully make this
more clear but let's just give it a try
I think give it a try you can give it a
try by watching and I think it's going
to be ok so what is the scenario here
the scenario here is that I have and the
canvas is irrelevant it's just sort of
there to show that I could also have a
canvas animating the thing that's
important here are these two particular
Dom elements one of which you can see is
counting up a number every 500
milliseconds you could think of any
other types of thing you might do with a
Dom element that's doing some type of
animation and the second one is not
animating at all so how is the first one
animating now first of all again I'm
using set interval in a separate video
that I will reference at some point I'm
going to look at why you might use
requestanimationframe instead of set
interval but for simplicity I'm using
set interval right here so what set
interval does is it says call this
function time it right here every 500
milliseconds so every 500 milliseconds
increment a counter and update the HTML
content of that element by that amount
so what if I want to do the same thing
for the second Dom element well
certainly I could just add timer to HTML
you know counter and we would see here
that both of them are lockstep and in
sync but there's only one function being
triggered what if I want each one of
them and have their own interval so they
each get their own counter or they each
get their own time that they wait to
increment that counter you might think
of it here's a nice way of thinking
about this what if you had an object
right even if you like program to Java
or C++ and even JavaScript you had an
object each one of these things was an
object and it had properties associated
with it it had a counter and
had an amount of time it waits to
increment the counter a closure in
JavaScript is actually a way of doing
something very similar to
object-oriented programming where I want
to bottle up I wanted to create this
little container this bubble is close
your bubble that has all the stuff that
has to do with each one of those Dom
elements and how do I create that bubble
so let's come over here for a second and
let's just say and I feel like I'm in
the darkness today for some reason but I
don't know why this seems darker than
usual but it is what it is you can
hopefully see me and read this um so
let's just think about functions in
JavaScript for a second function rainbow
right you have setup and drawn p5 and
there's all sorts of window although
there's all sort of functions you can
write and define in JavaScript all the
time and I could have another function
down here I could call it on what's up
unicorn for lack of a better thing to
think of and now I have two functions
each one of them define separately
outside of each other and incidentally
if this is no different in JavaScript
and now I am really easing my way into
this but to say var rainbow equals
function right a function is just a
thing you store in a variable this
function is stored in the variable
rainbow this function is stored in the
variable rainbow and in JavaScript then
it's totally reasonable that you might
define a function inside another one so
this Unicorn function could be defined
right inside of here this means unicorn
is a local variable to the rainbow
function so if I were to call unicorn
here that would be totally reasonable
that would work if I were to call
unicorn down here I could not call
unicorn down here because it's out of
scope because unicorn is now only local
to rainbow now
what if I had a variable here like what
goes with pot of gold I don't know
what goes with rainbows got stars I have
a star's variable which equals 15 oh boy
why don't you choose a counter this I
like so like lost in my world of
rainbows which is just ridiculous at
this point and kind of embarrassing so
what if I have a counter variable in
here this is also a local variable to
the rainbow function now let's think
about this when I call the rainbow
function that means these codes should
be executing which means somewhere in
the computer's memory a counter is made
and stored what if I call the rainbow
function again well if I call it again a
new counter is made these local
variables inside of a function are
things that are generated again and
again every time you call the function
that should almost be in a way intuitive
or not it's basically you haven't
thought of before but this is something
you've definitely used before the same
is true of this function each time I
call rainbow a new function unicorn is
declared and defined which in some cases
might be very inefficient which is why
sometimes I don't want to like read
eclair that function all the time if
rainbow is happening over and over again
I wanted to have it outside just use it
in there but what if you wanted this
function to operate differently each
time you called rainbow well this is
precisely so this by the way is a
closure a closure is a function being
enclosed in another function and and
this idea of all of this stuff being
maintained all this data the variable
this function and including arguments
that might be passed in here as each
time you call the rainbow function this
bubble is made which a counter is stored
and a reference to this Unicorn function
is stored now there's all sorts of
weirdness and strange things you can do
with this newfound power of putting a
function inside a function and I would
love to get to all of these scenarios in
all of my videos but let's come back to
here this is precisely what I want in
this particular scenario right because
what I want are two counters so if I say
I'm going to I'm going to I'm going to
just make up a function for a second
make animation I don't know if that's Oh
make make make timer make timer
animation
all it right and then I'm going to
define that function make timer whoops
I'm defining it and I say var counter
equals zero so what I want to do is each
time I make the timer I get a new
counter so I could certainly call make
timer twice so that makes a counter
variable twice local only to this make
timer function but that's going to be
fine why because here set interval is
going to be called inside the make timer
function and if set interval is called
inside the make timer counter is no
longer a global variable then I could
define here's a nice little closure for
you
this time it function can be defined in
here take out this one look what's
happening here each time each so each
time I call make timer I create a
counter I set the interval and this
function makes use of that particular
counter so one thing that's really
important about thinking about scope and
JavaScript well I love stuff it's kind
of like weird to think about but it's
really interesting is that the scope
isn't just where your variables are
declared but kind of like when things
happen like this function is all set and
done but this set interval means time it
is going to happen later and later and
later so the closure even though this
function is executed and finished all of
the things made in here all the stuff
stored in memory is maintained it's
maintained as long as something still
needs it and time it still needs it
because set interval we'll be calling it
again and again so let's just look at
this and I'm going to call it just once
so this should work for just timer 1
let's look at this you can see timer 1
is now counting up right that's it's
doing exactly what we want it to do why
is it doing that because we create a
counter we call set interval and every
500 milliseconds the counter is
incremented and the Dom element is
updated but now I have this function
make timer it's only working for timer
one because timer 1 is hard-coded inside
there so why not just say I'm going to
just give it an argument call it ELT
generic elements so now I want to make a
timer for timer one same exact result
but now this is the magic the magic of
the closure I can make the timer for
timer - so this whole bubble this
closure bubble was almost like this
object this counter this time it
function to set interval each one of
these will be done again each time I
call that function for timer 1 and timer
to the closure being this function in
close even though this function is
happening later and later and later in
life in a lot of programs running that
all the stuff around it is maintained in
memory for it so now if we run this we
can see both of them what so what
happened I made a fatal flaw here I
still hard-coded in timer 1 so I have to
change that obviously the ELT the point
is to take the Dom element that's passed
in and then use update that one's
particular and you can see now here they
owe their both going why they're both
going exactly at 500 milliseconds each
so what if I add another argument here
500 and you know and this one will be at
312 so totally arbitrary and I add an
argument here called wait and now I add
wait there so now when I call make timer
and I forgot a parenthesis here
what I'm doing is saying make this
closure create a counter start a set
interval process with a particular
function and remember that function this
function if I were to put this right not
as a closure but out here it wouldn't
make any sense because ELT and counter
don't have any scope out here in the
global scope so I need that function to
be read Eclair
each time inside of make timer and here
we go let's make this happen okay look
at this and you can see now each one
individually is just operating on its
own time because they both been
triggered with one with 500 milliseconds
and one with 312 and this is a closure
so I could add a third Dom element and a
fourth one I could do this in a loop or
I could have them all animate I could
start and stop them I could store a
reference to the interval of different
buttons when I click on it it starts
when I click off of it it stops so
there's a lot of possibilities here
what I might suggest to you is think
about you know try to use this exact
framework and think about like well
what's something more interesting you
could do in terms of color or something
else besides just counting numbers the
other thing that I might consider is
what happens if you put those Dom
elements into an array can you loop
through them and execute a closure for
all of them to have them all doing some
type of animation um that sort of thing
so I hope this helps you get started
with this idea of understanding what a
javascript closure is and what it's for
I think this will come up again and
again in videos that I make it certainly
comes up a lot when making multiple API
queries it comes up I think an example
that I want to make that looks up
playing a musical melody it can come up
if I have an array of notes and I want
them to each to happen a certain period
of time so I look forward to your
questions and see if I can come back and
make some more videos to clear up
anything or to cover this more again so
thanks for watching I can't believe I
just made a video about a closure which
is something that I've ever even heard
of like less than a year ago I probably
heard of it but was like I don't know
what that is
so hopefully this made sense it was
correct so the internet will correct me
I'm sure if I was wrong and I will see
you all sometime soon good oh and this
is only 12 minutes I think that's kind
of amazing</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>