<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>9.4: Genetic Algorithm: Looking at Code - The Nature of Code | Coder Coacher - Coaching Coders</title><meta content="9.4: Genetic Algorithm: Looking at Code - The Nature of Code - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/The-Coding-Train/">The Coding Train</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>9.4: Genetic Algorithm: Looking at Code - The Nature of Code</b></h2><h5 class="post__date">2016-07-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/-jv3CgDN9sc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello welcome to part 4 of this video
series thing that I'm doing about
genetic algorithms ok what's going to
happen now in this particular video what
I want to do is actually finally I know
it's a good before videos look at the
code itself so I have a pre-made code
example as you know I'm not going to
write it from scratch it's coming from
the nature of code chapter 9 you can
find the link to the chapter and the
code in this video's description but
what I'm going to do is look at the
algorithm itself that I covered in
detail a couple videos ago and look at
where all those pieces are so what does
it mean to initialize a population
randomly what does it mean to do step
two selection to calculate the fitness
of every member of that population how
do you write a function in code to
actually do that how do you write a
function to us to pick randomly but have
each thing that you're picking randomly
have some sort of higher or lower
probability of being picked that's the
kind of a tricky problem we look at how
is that solved and then how do you do
this thing heredity how do you do
crossover how do you write the algorithm
for crossover how do you write the
algorithm for mutation and then have
this new population that you then make
the current population repeat over and
over again so I want to look at every
single one of these steps and find in
the code where those steps happen so
let's just start doing that okay
actually before I do that though let me
at least open up this directory here and
show you that how I have the code
organized so I have the code organized
you know there's the libraries folder
for the p5 chess JavaScript library I'm
using there's the HTML file which
references the JavaScript files and
there's some like kind of worthless
styling and style dot CSS but the files
that actually mat up to you are sketchy
ass that's where kind of the main
program is set up this initialization
state is draw this looping state is that
a population yes that's an object that
manages the array of all the elements of
the population so there's functions for
calculating the fitness values there
there's functions for doing the
selection there and then there's the DNA
JS file this is a really important file
because this file is actually this
object this DNA object as I look at more
sophisticated examples in future videos
the code in DNA ojs will actually be
present in almost all of them so a lot
of what's great even though this example
is kind of completely trivial example
because again I could just type to be or
not to be that is the question the code
in this example can actually be almost
lifted essentially verbatim to other
scenarios to write your own genetic
algorithm and that's kind of the next
video after this one I'll get to how do
you take this code and implement it in a
different scenario yourself but so the
DNA jess has that DNA object it has a
function for mutation it stores the
characters for each phrase that sort of
thing it's each individual element of
the population okay so let's go back to
the algorithm step one create a
population of n elements so let's go to
the code and where this happens is
actually in population chance and we can
actually see this happen right here I
say create population equals a new
population so the population is made
with three arguments a target which is
the target phrase to be or not to be
which I could change a mutation rate and
a population max so those values are
sort of stored also in that population
object and in the population object
itself this is the kind of key variable
this dot population know
don't forget don't forget this dot so
variables that are part of that object
itself are attached to it by saying this
dot population so this is a constructor
function that's creating a JavaScript
object and a population is made as an
empty array and then there are a certain
number of elements of the population
made as DNA objects so the so what the I
think if I come over here for a second
the population object itself is just a
big array of n elements and each one of
those elements is a random phrase you
know popcorn you know unige or whatever
these sort of weird nonsense you know
whenever each one of the members of the
population is a random phrase and but
it's not just a string so rather than
use just a kind of literal string what
I'm actually doing is creating a DNA
object and this is kind of crucial and
this is now where the DNA Jas file comes
in DNA Jas has an object itself which is
an array called this genes so if I come
back over here whoops
step on a light on a fan I think I broke
no I didn't break this anyway that light
went off smoke get a little bit darker
for a second a fact
hello everything's okay the fan is
blowing on my legs so this is the
population array each element of the
array is a phrase which is actually a
DNA object which itself is an array and
each element of that array being a
single character okay
so that's how each element of the
population is an array of elements each
element is an array of characters so
this is ultimately how the oops let me
come over here this is ultimately how
that population is made make a certain
number of DNA objects each DNA object
each element is a new car now one thing
that's a little bit goofy here is
wrote an entire function to make a
random character there might be an
easier way to do this in JavaScript but
I really just want random characters I'm
using that sort of ASCII table here so
I'm picking a random number between 63
and 122 and then converting those from
that number to a string using its
character code so like using the ASCII
table and if you're not sure what the
ASCII table is I'll try to include a
reference link in this video's
description to that so that is step 1
initialize okay step two being selection
now we need to evaluate the fitness of
every element of the population so where
does that happen
so one thing by the way that I think is
worth looking at but is this is this
main program right so draw by the way
look at this the draw function
essentially and it's funny how I'm doing
this in a slightly weird order
maybe I should flip this around but what
the population does what the population
object itself has all of these steps of
the algorithm written in a specific
functions so I could just say population
calculate the fitness of every element
population perform natural selection
population generate the next population
and then population dot evaluate why I
um that what that function does actually
is just sort of checks to see if we're
done so these are the three I kind of
don't know why I did this I'm going to
just right now put this first because
it's looping over and over again it
doesn't necessarily matter but I'm going
to calculate the fitness first because
this is sort of essentially the order of
the of the genetic Ram itself so this is
this is step two right here a selection
which calls that function calculate
Fitness which is right here uh-oh I
froze hopefully I didn't actually object
somebody in the chat will tell me if
this stop working there's this function
calculate Fitness and notice what that
function does it loops through every
single member of the population and
calls another function calc Fitness so
when I say count Fitness on the
population really what I'm just doing is
saying loop through the entire
population and
function on every element called cow
fitness and check the fitness against
that target phrase so now if I go into
the DNA object we can see calc Fitness
right here this is now a key key
function intogen any genetic algorithm
is the fitness function itself so you
can see what's going on here I start
with a score of zero I iterate over
every single character in the phrase if
the particular character in the jeans
array matches the character in the
target phrase increase that score by one
and the fitness is the score divided by
the total length so the number of
characters correct divided by the total
length gives you a percentage I got 9
out of 10 characters correct a fitness
score of 90% so you can see that's
what's happening and so that's step 2
selection calculate Fitness initialize
generate 200 random DNA objects step 2
calculate the fitness for those random
DNA objects okay now the next thing we
need to do is reproduction now here's
the thing let's come back over here and
talk about how this is going to work so
let me erase this for a second so if you
recall I had this idea of this spinning
wheel wheel of fortune' so here's the
wheel maybe there are you know a whole
bunch of members of the population each
with a certain fitness and depending on
their fitness they get a bigger slice of
that pie and then the idea is you spin
this wheel and you pick a parent pick
another parent well you know I could
actually build in the code like the sort
of physics simulation of a spinning
wheel but that would be a little bit
overkill there are a lot of different
techniques of of picking picking random
elements from an array based on
probabilities there's a snake Weir
technique where I can pick two random
numbers a kind of qualifying random
number it's a I forget what I called I
actually just recently made a video or
an example about this accept/reject
kind of algorithm but the algorithm that
I'm going to use is actually a very
simple technique that works well in this
case so let's say I have a B C and D and
I want a to have a 40% for a has a 40%
chance of being picked B has a 20% C ou
has a 15% oh why did I make the math so
hard on myself 60 75 no no I don't I
don't this is not going to turn out well
for anybody with 15% so we'll just make
um we'll make C 10% 40 60 70 and D 30%
okay now look at this let's say I have
an array this is the array and the array
looks like this a b c and d let's say i
want to pick a random element from that
array ABC or d each element has an index
0 1 2 or 3
so i could pick a random number between
0 and you know 4 but not including 4
each one of these has a 25% chance being
pit of pics i have a 1 out of 4 chance I
can't write 25% of picking any of those
what if however I were to write the
array a different way so I'm going to
write the array like this a a a a b b c
d D D notice I put a in that array 4
times I put B in that array 2 times C in
that array 1 time and D in that array
three times now there are 10 elements of
the array four of which are a so if I
pick a random value between zero and 10
not including 10 zero and nine right
four out of ten times I'm going to pick
zero one two or three at a two out of
ten times I'm going to pick a four or
five a B so what I can actually do if I
have a pot
is the population array that's the
actual population array in the code I
build another array which I think I'm
calling a mating pool I might call it
like Darwin or something where I take
these elements and put them in this
array a certain number of times
according to their fitness so the more
time something is in an array the more
likely it is to be fit picked and I
think if I come back over here for a
second I think I have so this is kind of
a just some other diagrams demonstrating
this idea right what if I have all of
these elements with a different
probability this is the spinning a wheel
approach but what if instead I just
create this big bucket and I put like a
in there so many times be in there so
many times Deena and I pick out of it
the more something is in the bucket the
likelihood the likelihood the higher the
likelihood is that it will get picked so
how do you do this in code if I go back
to the code again we're looking now for
this function natural selection which
says generate a mating pool so let's go
look in population and here it is notice
what I do this dot mating pool is now a
new empty array and and then ultimately
later on right down here there is this
code where I'm adding every member of
the population into the mating pool n
times so how do I figure out what that
number n should be well the you know
this I could probably use some
refinement there's different ways you
could do it but ultimately up here what
I'm doing is finding out okay what's the
number with what's the what's the member
of the population with the most Fitness
the highest Fitness value then what I do
is I take that objects that particular
elements fitness and give it a number
between 0 and 1 mapped from 0 to maximum
fitness so in other words what I'm
saying is I'm doing so for step where
I'm normalizing all these fitness values
now ultimately I kind of made up an
example here with sort of pre normalized
exact value like point four point two
point one point three but your
scores might just be like a whole lot of
numbers like this one got a fitness of
2,000 that's going got a fitness of
three this one got a fitness of 4228 so
what I do is I have a way of saying
whatever the fitness numbers might be
take them all and just have them have a
range between zero and one and actually
the next thing I do is multiply it by
100 so actually the range is between 0
and 100 and you can see that's what's
happening right here I do that mapping
then oops that I lost my oh I sorry I
lost control of my computer and then I
multiply that value by a hundred and
that's n that's how many times those
elements are in the mating pool itself
so if I were to just do something which
I'm a little bit afraid to do but I'm
gonna say console.log this dot mating
pool and I'm going to go back to the
sketch and run it and what you can see
is these are the mating pools right and
it's finished and you can see that there
are this array this this array is
actually quite huge I wanted to say this
don't think it might make more sense say
this mating pool dot length so you can
see this is how many things are in the
mating pool in the in the 15 to 20,000
range where as the population itself is
just 200 but based on their fitness that
mating pool is built much larger okay so
that's we're getting there
that is let me go back to this
particular algorithm so that is
selection so once I have the mating pool
then I'm ready for step 3 reproduction
all I need to do is I have the main pool
all the probabilities are already sort
of built into that big array right now I
just need to pick two random ones from
the array and we could go into the code
itself and we can see where that happens
look at this this four I want to do this
n times I want to make a new population
here are all the steps that's the
generate function pick two parents give
me a random index into the mating pool a
give me a rent another random index into
the manual now technically speaking you
might want to save yourself
ah do you know what if B equals a I want
to invalidate B and pick another one but
you know me I'm sort of being
loosey-goosey about this it doesn't
really matter if I by accident
our occasion pick the same parent twice
big deal so I have two parents parent I
play partner a and partner B both of
those are DNA objects that come from the
mating pool and then I simply call cross
over I take partner a cross over with
partner B and that is a new child
element and then child I call mutate for
the mutation rate and then I have that
new member of the population so this
happens n times I just say I have the
mating pool give me two parents cross
them over apply mutation here's the new
child it goes into the population this
happens over and over again so I've
really looked at every single element of
this algorithm here the last thing
though is we could look at what has
actually happened in cross over mutation
so again just to remind ourselves this
is the cross over step the technique
that I happen to be applying is take
half of one and half of the other and
put them together but certainly you
could take one from each one I think I
don't think I have a diagram for that or
you could do it a different way and then
you time using this probability to say
at any given random and there's a
certain chance that I might just change
that character randomly so let's look at
how those functions work now notice
where is that function happening I'm
saying partner a that's a DNA object
cross over with partner B that's another
DNA object so that code for the cross
over function itself is in this DNA
object which is right here so look at
this this is now the cross over function
first of all I'm creating a new DNA
object with the same length the same
amount of genes is this current DNA
object I'm picking a random midpoint
right I could just say oh the ran the
midpoint is always 5 or the midpoint is
always this genes dot length divided by
2 but I'm picking a random midpoint and
look at this this child's genes are
either coming from right if I'm on one
side of the midpoint they come from this
particular DNA objects genes otherwise
otherwise they come from the partners
genes so this is how I'm applying
crossover it's literally just a new
array take elements from one array or
from the other
ray and then mutation you can see here
mutation these are incredible credibly
simple fun then I have a new child DNA
object a mutation these are incredibly
simple functions all it is is hey let's
look at every single gene and just say
pick a random number between zero and
one if the mutation rate is point zero
one or one percent if I happen to pick a
random number less than point zero one
then just give you a new character
forget about whatever I got through
crossover give me a new character okay
so this is it
these are all of those pieces this is
the main program right in setup I have
what's the target phrase what's the
maximum population what's the mutation
rate then I create a new population
object and then I just walk through the
algorithm itself calculate the fitness
build the mating pool generate the next
population evaluate is just checking to
see how everything did at the end that's
and and then you know there's some other
code for sort of displaying all the
information using Dom elements and that
sort of thing but this is the key
algorithms all in separate functions and
each one of these functions calculate
the Fitness natural selection and
generation simply iterates over that
entire population right the population
object has a population array I'm always
iterating over that population array
calculate the Fitness for every element
of that array assigning a probability
for every element of that array picking
a random parent from that picking a
random element of making a new child for
every element array and all of those
functions are in turn in this DNA object
the DNA object stores the actual genetic
information it has a function for
calculating the fitness as a function
performing cross over and as a function
for performing mutation so these are all
the elements so I've kind of finished
this here I'm going to do a follow-up
video where I talk about a couple things
that I think could optimize or change
the way this works but ultimately what
the project for you in your head that
you want to think about for right now is
well what is the thing that you want to
make that you might want to try to
evolve are you trying to evolve a
particular design to make it more
beautiful or more intuitive are you
trying to evolve a particular animation
behavior of an element on the screen
and what might be you know how could
this algorithm apply to your scenario
what might be the genetic information
how are you how is ours how is I just
made this like weird like closing my one
eye thing expression at you I don't know
why but um how can how can you apply
this sort of algorithm an idea to your
particular creative project and that's
what I'm going to start to get to as I
look at a few more advanced or most
advanced is the wrong word but really
more sophisticated examples of applying
this so I'll see you in the next few
videos where I look at some other
scenarios and other things with genetic
algorithms okay bye bye quick addendum
here since I said I would do this for
those of you that are interested the
code for this example is also available
in the processing program environment
which is a creative coding environment
built on top of the java programming
language so if you're looking for java
classes to do genetic algorithm you can
find those as well and really ultimately
it's all kind of the same there's some
you know little differences the you know
we've got the sort of more classical
object-oriented programming where I have
a DNA class and a population class the
population itself is an array but one
thing you'll notice that's kind of key
is the mating pool I'm using as an
ArrayList in JavaScript arrays can
easily just kind of be resized and
things could be added and deleted just
with a regular array but in in Java
itself an array is a fixed size which
works for the population which always
has a fixed size but the mating pool
itself has to have a flexibly sized
ArrayList but otherwise everything is
essentially the same and you can see
here I have setup where I'm creating a
population object and draw where these
functions are being called natural
selection generate calculate fitness and
various things like displaying the info
by drawing text of what's going on on
the screen itself so look for the links
in this video's description for also the
Java code and if you have questions
about that please let me know thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>