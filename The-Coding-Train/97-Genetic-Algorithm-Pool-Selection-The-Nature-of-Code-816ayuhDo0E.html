<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>9.7: Genetic Algorithm: Pool Selection - The Nature of Code | Coder Coacher - Coaching Coders</title><meta content="9.7: Genetic Algorithm: Pool Selection - The Nature of Code - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/The-Coding-Train/">The Coding Train</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>9.7: Genetic Algorithm: Pool Selection - The Nature of Code</b></h2><h5 class="post__date">2016-08-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/816ayuhDo0E" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello and welcome to another genetic
algorithms video in this video I want to
talk about something called pool
selection based on fitness and actually
this this this video is inspired by a
comment that came in on github from
Sinclair zx81 who writes thanks for the
video regarding genetic algorithms in
this video you suggest an algorithm for
pool selection based on Fitness now if
you remember what was my algorithm my
algorithm was I have a bunch of elements
in a population like a B and C they each
get a fitness score like a fitness score
of 8 a fitness score of 2 and a fitness
score of 1 and what I do is I create a
pool a mating pool not a swimming bore I
don't got any of these things just some
computer thing which is an array but
essentially I create that pool and I put
a in a times a a hey hey I put B in
twice and I put C in once so there the
amount of times are in the pool is
relative to their fitness function and
then if I go and say magically pick me a
random element from that pool I am four
times more likely to pick a over B and
eight times is more likely to pick a
over C etc etc so you can see how their
Fitness in this case maps to probability
but this solution is not the greatest
greatest solution on earth or the
universe or whatever and this and the
reason for this as a sinclair writes is
the method you describe involves
populating a large array of elements and
this can actually you might have noticed
while I was doing the smart Rockets
coding challenge like there was a lot of
like stuttering at the end of the
generation so this could really be a
problem suddenly I made this array that
is like 100,000 or a million elements in
it and things can run really really slow
so Sinclair suggests a different
approach for selection a bit more
generalized and supports arbitrary
fitness values and should be fairly
quick so I encourage you to look at
Sinclair's code I'll link to this github
issue thread uhm but a lot of this code
uses sort of advanced JavaScript array
functionality stuff which is kind of
beyond the scope of what I'm doing so
I'm going to try to implement this
strategy that Sinclair outlines in a
sort of simpler way perhaps less
efficient but I'm going to try to do it
in this video now
what this strategy is also referred
- as often referred to as rejection
sampling or accept reject algorithm and
this is a kind of Monte Carlo method I
always just if any time I could say
Monte Carlo I'd like to say Monte Carlo
if I could just leave and go have some I
don't talk about gambling in Monte Carlo
there's a reason that they come back
over to the white board and so let's
talk about how this algorithm is
different what if I could pick so in
this case I'm picking a single random
number a random number and index into
this array what if we forget about this
giant array thing and what if I were to
just pick a B or C I would be picking if
this were an array 0 1 or 2 right I
would be picking a random value 0 1 or
sorry between 0 &amp;amp; 3
and I would say floor so what that's
going to give me is this function is
going to give me 0 1 or 2 so if I do
that if this is all I do then and this
should be a 1 up here if this is all I
do then I have a one-third chance of
picking a a one-third chance of picking
B and a one-third chance of picking a C
this will not do
because I want to have a higher
probability of picking a a higher prep a
medium probability of picking be at a
lower probability we can see scaled
according to their fitness so let's
think about what I mean by accept reject
so I'm still going to do I'm going to
have it this is going to be a two step
process step 1 is going to be this pick
a B or C now though step 2 with an equal
probability for each accept or reject
that's the question I need to ask
I picked 0 1 or 2 but am I going to
accept that as my pick or I'm going to
reject it and try again and here's a way
I could do that what if I also picked a
random number between 0 and 10 and if
that random number happened to be less
than the fitness score then I'm going to
say accept if it is not less than the
fitness score I'm going to say rejects
right and you could think about how this
might work
pretty often if I pick a red number
between 0
and Ted that's pretty often going to be
less than eight but very rarely good to
be less that mean rarely going to be
less than 1 or only 10 percent of the
time it's gonna be less than 1 but 80
percent of the time it's gonna be less
than 8 so you can see how this idea and
if I accept then I keep it and I use
that parent if I reject it then I go
back and pick again so I might have to
do it multiple times per pick but in the
end I'm going to have a way of mapping
mapping the fitness values according to
a mapping the probability of picking an
element according to its fitness value
so this is the theory behind it let's go
try to implement that in code okay so
coming back over here I want to show you
something I actually have a processing
example that I will link to the source
code for this and before I get to the
genetic algorithm I'm just going to run
this example and what this example is
doing right now is it's picking random
numbers between 0 and the width of this
window and it's graphing the
distribution of how often they've been
picked and look at that I'm getting kind
of an even distribution from the it's
kind of normalizing them to the height
of the window it's doing all this stuff
so you can see over time a good random
number generator should put pick an even
distribution of numbers across the
spectrum of what you're picking but I'm
going to now change something really
quickly in the code and I will and run
it again now look at this distribution
so this is now a program that's picking
random numbers between 0 and the width
of the window but it's much more likely
to pick higher numbers than it is to
pick lower numbers and it's you can see
this graph is actually just a linear
graph of like y equals x and how is that
working well I have this function called
accept reject and notice what it does is
it picks two random numbers why am i
casting it I must have written this at
one point in like a clips or something
because it's totally unnecessary to I
don't know why I have that there the
that extra it still works um you can see
that it picks two random numbers and
what it does is it says and this really
I want to change this variable name like
probability the probability whether or
not we should accept random number 1 is
equal to random number 1 so the higher
random number one is the higher its
probability and then I just check was
are two less than the
if it was return that value otherwise go
back and pick again
and I you know I have this like goofy
little thing here this hack where I'm
like if for some reason I tried to pick
a random number ten thousand times I
didn't get anything then something is
going wrong and let's at least get out
of here and not like being an infinite
loop but you can see how this code kind
of works so what I want to do now is try
to take this same idea and bring it into
the genetic algorithms but rather than
have the probability be based on the
random number itself right I want the
probability be based on the fitness of
that of that particular element okay so
I'm going to go back I'm going to leave
processing and I'm going to go back to
JavaScript and I'm going to look for
this natural selection function so let
me just make sure it's saved this is the
example that I'm running it's this to be
or not to be that is the question
example which is trying to evolve to be
or not to be and I'm going to go back to
here where I'm creating this mating pool
so I am now going to get rid of this
mating pool thunks goodbye I mating pool
okay
so I'm going to keep this maximum
fitness here and see that I'm going to
use it in a second but I don't need this
whole thing where I build this extra
mating pool and in fact this whole
function is kind of irrelevant except
for this maximum fitness value so I'm
actually just going to take this out and
do this maximum fitness thing in the
generate function so right here this is
the issue I need to replace this part of
the code this is the part of the code
where I pick parent a and parent B as an
index into that particular mating pool
but I don't want to do that anymore
instead what I want to say is I'm going
to just have another function of a say
accept reject something in the popula
I'm going to I need to pick a random
element in the population and I also
need to know I need to pass in that
maximum fitness will be about I need to
write a new function called accept
reject you know what it can just be in
this object so I just I think it would
be nice to encapsulate this in another
function
rather than write the code here
especially since I have to do it twice
so I'm going to write this down here now
as whoops this dot except and I forgot
oh my goodness nevermind I was trying to
use myself for it I'm going to write a
function called accept reject okay and
what I want to do is the first thing I
want to do is pick a random index so I
need to say random number between 0 and
this dot population length and the 0 is
kind of an optional argument that I
don't need so I need a random number
between 0 in the length of the
population and I want to floor that then
what I need to do is pick another random
number just going to call that R which
is a random value between 0 and maximum
fitness so I want some value that goes
between 0 and the maximum fitness if R
is less than oh sorry sorry if okay so
now sorry the the member of the
population the partner the parent is
this dot population index so this is the
actual partner that I picked so I'm
picking a random element from the
population this is kind of and then I
want to get and then I want to get like
that the index into the array and then I
want the actual object itself because
what I want to test is if that partner's
fitness is less than R let's think about
this no no if R is less than that
partner's Fitness let's think about this
right if the fitness values go between 0
and 100 I'm picking a random number now
between 0 and 100 if the partner if this
particular element has a fitness value
of 100 this second that random number
always going to qualify I'm always going
to accept it if it has 50 it'll be 50%
of the time if it's 25 the Finch is 25
milli 24/7 percent time and I can say
return that partner otherwise what do it
again so I want to say while I'm just
going to do this while true over and
over and over again the return will get
me out of this function so this
accept-reject strategy is going to
always pick a random population member
of the population pick a random number
and if it qualifies if it should be
accepted return it
I'm forgetting stuff I'm forgetting some
VISS dots people are telling me in the
chat line 51 and 52 yep thank you so now
this should be this dot except this dot
reject of this dot accept reject okay so
the other thing I want to do is I'm just
going to say be safe be safe equals zero
be safe plus plus and if be safe is ever
greater than 10,000 return null I don't
know what this is really doing but I
just want to like get out of that
infinite loop like I feel like
something's wrong if this takes 10,000
times to find to find a correct value so
so let's look at this and let's just see
how to know how did I do
let's run this okay so clearly I'm
getting an error the error is population
natural selection is not a function
right I eliminated an entire function
from this particular scenario sketch
jazz line 40 so I'm going to go to line
40 and I'm going to delete this function
doesn't exist anymore max Fitness is not
defined in
so I'm back after a little bit of
debugging I had some sort of significant
issues you can see right now what's
happening is I'm not kind of getting any
evolution there's a couple reasons why
this isn't this happening number one is
that my the fitness function that I'm
using at the beginning when I pick a lot
of random phrases a lot of them don't
have any correct characters and I'm
getting a fitness function of zero and
this new algorithm that we've designed
if the fitness value is zero this thing
has no chance ever of being picked
because I can never pick a random number
between zero and something that's less
than zero so I like a little bit this
isn't the best solution but it's a
little bit of a hack I'm just going to
in the fitness function add point zero
one so I can add a minimum the fitness
function is zero point zero the fitness
value is 0.001 so everything has at
least like a one percent chance of being
picked according to this rejection
sampling model that I'm now using but
there's another significant problem I
could run this I could run this again
now and it's sort of doing some stuff
now it's going to break here and there
or do weird things so then it's not
really evolving very well there's also a
major issue if you notice in the code if
I go back to this code this is what I'm
doing and the comment says it all
refill the population with children from
the mating pool so what I was doing
before is I had a separate array that I
was pulling from to create child objects
to put in the population but I'm no
longer doing that I'm now actually
picking from the population to put
things back into the population but I
can't be putting the next generation
into the population while I'm continuing
to pick the current population so what I
need is a whole separate array I'm going
to call this new population and it's
just an empty array and instead of
filling the existing population I want
to fill that new population and then at
the end I can happily say this dot
population equals new population so that
is a fix that I also need here and now I
should be able to run it and we should
see that we're back to our old tricks
again we've got to be or not to be
evolving up
I think there's going to be an issue got
to be or not to be but it's still going
there's a reason why it's still going
because I have a bit of code that says I
somewhere I believe in the in evaluate
here yes it says if the best fitness is
equal to the perfect score then you
finish the simulation the problem is the
fitness the perfect score is one but
remember I added point zero one to it so
I'm just going to change this to if it's
greater than or equal to the perfect
score being one 100% of the character is
correct I'm just going to check if it's
greater than that now because I had that
I added that point zero one thing so now
we should run this again and we should
see this is doing exactly what we did
before so there's really you know my
assumption here is there's not a
significant difference between the
behavior of this version of the genetic
algorithm and the one that I did with
the building the Large Array mating pool
but using this accept-reject strategy
this rejection sampling strategy I've
done away with this giant array thing
which I think in a lot of scenarios can
be a useful solution to use as well so
as an exercise you might go and find
these the smart Rockets example that I
built in a previous video in the coding
challenge and see if you can take that
and apply this accept-reject algorithm
and then that one in particular I know I
was building this really big array which
was making it run kind of slow and see
if it runs faster with this algorithm
okay thanks for watching this video</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>