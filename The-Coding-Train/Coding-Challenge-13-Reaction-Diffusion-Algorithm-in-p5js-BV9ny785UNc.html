<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Coding Challenge #13: Reaction Diffusion Algorithm in p5.js | Coder Coacher - Coaching Coders</title><meta content="Coding Challenge #13: Reaction Diffusion Algorithm in p5.js - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/The-Coding-Train/">The Coding Train</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Coding Challenge #13: Reaction Diffusion Algorithm in p5.js</b></h2><h5 class="post__date">2016-05-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/BV9ny785UNc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello and welcome to another coding
challenge in this coding challenge I am
going to look at the reaction diffusion
algorithm so I have a version of it
running right over there that is a
processing sketch that is implemented
the reaction diffusion algorithm I'm
going to implement it in JavaScript do
it from scratch in this video and you
can see that this allows you to create
this interesting kind of labyrinthian
visual in your canvas now there's a lot
of different ways that you can apply
colors and get different qualities to
the image but I'm going to look at the
sort of core classic reaction diffusion
algorithm using the gray Scott model I
will include some links below two
reference pages the one that I will
build the code based on is right here in
the browser that Karl Sims a Carlson's
tutorial page and so the idea here is
that I'm going to just sort of look at
the drop-dead simple classic algorithm
black and white pixels only and then
hopefully you after watching this or
using the code might come up with some
other creative uses and applications of
it so let's try to understand first what
this algorithm actually is and so I'm
going to close this window out and look
at this diagram so the idea of reaction
diffusion is kind of like you have your
screen and you're about to pour some
chemicals into it and those chemicals
are going to react and there's going to
be a lot of chemical a and then less of
chemical B and they're going to react
and defuse and that sort of thing and
then based on that how those chemicals
are arranged in the screen in this sort
of like dish petri dish of your canvas
I'm going to we're going to set a color
so if there's a lot of chemical a we're
going to make the pixel black if there's
no chemical a we're going to make the
pixel white and kind of everywhere in
between so that's the idea here
now there are a lot of different kind of
key pieces here and let's just look at
this quick diagram here thank you again
Carl Sims for providing the tigris or
this video of chemical a so the way it's
going to work is the Kansas is going to
be filled with chemical B and then we're
going to start to pour chemical a in to
the canvas the reaction aspect is
chemical a and B reacting and maybe a is
turning into B and the sort of diffusion
in this way is that chemical B is also
going to get kind of like removed from
it so there are some there are some key
constants in the system that are numbers
that you're going to see in the code one
is the feed rate which is how fast are
we pouring in chemical a
and then another is called the kill rate
I wish there was a nicer name for that
but that's what it's called which is how
what is the rate that chemical B is
being removed so this is the idea now so
and you can see here what we're going to
do is each each cell is going to have a
certain amount of chemical a and amount
of chemical B and those values are going
to have a range between 0 &amp;amp; 1 1 being a
lot of chemical a zero being none and
then that amount is going to be used to
set the color for a pixel and so you can
see here how this how this kind of works
we're going to do all this in code now
how look at this now we have this like
terrifyingly scary looking formula but
we can tackle this formula I'm going to
write here I'm here with you to tackle
this complicated looking formula so
let's put putting that aside let's kind
of make a quick diagram so the way that
I'm going to build this in code is I'm
going to have a two dimensional array
meaning I'm going to have a data
structure that's going to keep track of
each spot and that data structure is
going to keep track of an individual
cell call that a cell each cell is going
to have an amount of chemical a and an
amount of chemical B so what I need to
do is understand if Kevin if there are
moments in time there are generations
this moment in time next moment in time
so moment in time a zero moment in time
be zero what I need to understand is how
do I get the amount of a four moment in
time one based on some function of the
amount of a and the amount of B at time
zero so this is what we're looking at
and in fact over here that's what this
formula is showing you the new value of
a equals all this stuff based on the
previous value of a and B and some other
constants so this is what we need to do
there's a bit more to it than this so
you know I could say like Oh a one
equals the average of a zero plus B zero
you know / - this could be our formula
this would be a lot easier to implement
so that formula is just like this but a
lot more compliment complicated so now
but there's the reason why there's more
to it than this is because we have this
scenario here of an individual cell we
have to apply something called a
convolution you're going to see on the
show in a moment it's as a convolution
of a 3x3 matrix all this scary sounding
stuff so here is a three by three matrix
and this is a given cell and what I want
to know is what is this cells new values
of a and B based on its previous value
of a and B but not just it I need to
know also based on its neighbors so
these chemicals are reacting and
combining in a given cell also with what
are the chemicals next to it so the
comma convolution means take every
single one of these cells and multiply
it by some weight so if I were blurring
an image for example I could use a blur
as blur meaning the average of a
convolution of a 3x3 matrix of pixels so
the new pixel color is going to be an
average 1/9 of this color plus 1/9 of
this color plus 1/9 of this color plus
one night this card so I take all of the
colors and multiply them by 1/9 add them
all together I have the new color but we
have a different convolution here and
it's described in it in the diffusion in
the reaction diffusion algorithm so this
is the basic idea
I need a two dimensional array each spot
is going to have a certain amount of a
and a certain amount of B I need to have
a formula that for each cycle each frame
through draw I get a new value of a and
a new value of B and then a new value of
a and new value B and the math formula
is going to be something like this
but more complicated because it's also
going to involve all the neighbors so
let's start setting this up now
hopefully this is the basic idea let's
start setting it up to program okay so
now I'm back over here I am back over
here Oh was I not over there the whole
time I think I was over there the whole
time hopefully this was right uh so be
the chat tell me was I in the on the
whiteboard while I was showing that okay
so if I go back to I have this a blank
code here um and I'm going to go to my
canvas here and this is my canvas so the
first thing I need to do is create okay
it was good the first thing I need to do
is create my two dimensional array to
store all the amount the amount of
chemicals
each spot in the in the grid okay so
two-dimensional arrays in JavaScript are
kind of a funny thing
not funny ha ha funny a little bit weird
because arrays in JavaScript there's
just so many different ways you can make
them but ultimately what a
two-dimensional array is let me kind of
describe this to you briefly I'm going
to make an array called grid and you
could imagine like what if I did this
I'm going to write something like this
I'm just going to kind of type something
out for a second just to explain this
this my friends you are my friends
indeed is a 2-dimensional array I kind
of space it out like a grid but really
what it is it's just an array of arrays
to see how it's an array open square
bracket n square bracket and then it's
three arrays inside of it but I could
but so really a two dimensional array in
programming is just an array of arrays
so what I need is one array to keep an
array for here for here for here for
here right so I need the first array to
be the first row the second array to be
the second row the third way to be the
third row that sort of thing but I'm not
going to type it out man well for 3x3 I
could type it out manually what I need
to do is kind of is actually make it um
make it in code okay everything's gonna
be fine so I'm going to create that
faraman I'm gonna do it I am going to
use a particular style I'm going to do a
different I'm going to do it a different
so what I'm going to do is I'm first
just going to say grid isn't a right
it's an empty array and what I need to
do is I need to loop x equals 0 X is
less than the width of this canvas and
then we zoom back out X plus plus so for
every X and for every Y right for every
X ah stop oh I can't I I'm waiting for
my auto format that's not here for every
X what I need to do is say grid index X
is an array so I start with this array
and then I say hey let's make an array
and then
what am I going to put here grid X y
equals now what do i what do I need in
each spot in the grid now if I were just
if I only had a single chemical if I
only had a single chemical I would just
put in a single number in each one these
by have two chemicals I have an A and a
B so let's actually I think this is a
place where I could just make a literal
JavaScript object and say a is you know
there's zero of a and there is zero of B
so and you know I don't think I need to
be so long-winded about it this is such
a simple object I'm going to do this so
I make each spot in the grid each spot
in the grid for every X and every Y
there's an A and a B with zero of each
chemical and I'm going to need to change
that eventually but we're going to start
there so this is good I now have my grid
yay now here's the thing in order to
make this work right the hole this hole
is hauled all built on this idea of I
need to get the next generation amount
of a so I can't be massive if this grid
is the snapshot of all the chemicals in
a current generation I need a completely
separate grid to start filling in the
new values because if I were to use the
same grid if I start over writing the
values in that grid while I'm checking
other values neighbors everything's
going to get all messed up so what I
should do is I'm also going to create a
variable here called next and I'm going
to be kind of silly about it and I'm
just going to make two of these and say
next so I now have two two-dimensional
arrays and I think I just want to
briefly mention that I could have done
this so grid is going to be the current
and then next is going to be the next
one so I could have done this by also
using new array in JavaScript to create
a sort of fixed size but I know my array
should have a width and height as kind
of the number of columns and rows okay
so now we're in good shape so what I
could do what I want to do is just sort
of see that the basic idea of this is
working so what
I need to do is draw a color a pixel
color in the window based on each value
in that grid so by the way we're going
to need this double nested loop like a
zillion times so I'm going to just copy
paste that down here and one of the one
thing I'm going to do at the very end is
I'm going to say load pixels and then
I'm going to say update pixels and what
I'm going to do is I'm going to create a
color let's just make sure I'm going to
just make a nice you know pinkish
purplish color just to make sure this is
working and I would say pixels index oh
boy so guess what everybody I have a
whole video that goes through the pixel
array I should link to that from here
the pixel array in Java in p5 yes in the
JavaScript canvas is a pixel array that
has four spots for every pixel so I need
to figure out and it's one dimensional
so I go through the derivation of this
formula but I'm going to say pics equals
x plus y times width times four and then
I'm going to say pixels pics plus zero
equals a 255 and I'm going to this I
don't need and I'm going to say zero and
I'm gonna say 100 and then and this is
one one two and three so what I've done
here is I'm using a formula to find the
right spot in that array for every
single pixel every with every column in
every row and then I'm saying get make
its red 255 make its green 0 make its
blue 100 make its alpha 255 so I just
want to see that this runs okay great so
I filled it with a color so I do have a
way of setting every pixel color now
what I want is for these colors to be
based on the grid so I'm going to say
grid X comma Y dot a and I'm going to
say grid X Y dot B so so I'm going to do
the red and the blue as coming from the
two-dimensional array itself and we
should see all black but if I give
everything a
random amount we should see okay so what
am I missing here so I gave the grid a
random amount of a and a random amount
of B and what missing oh I did random
between 0 and 1 so what I want to do is
multiply these by 255 there's lots of
ways I could use color mode or get
around this but I'm just going to
multiply that by 255 oh and I'm gonna
have to say floor because it has to be
an integer I bet okay so I probably
could have done a better job at this but
there we go so you can see that this is
working I have a mechanism by which
based on the amount of chemicals I get a
pixel color this is the core thing that
we need so now all we need to do is say
like okay let's put this formula in
great so let's unpack this formula right
because right now and actually before we
even do that let's let's actually just
get the structure going so before I put
the formula in let's do some let's put
this nested loop in again and what I
want to say is now I need to use this
next right next index XY equals and let
me just do something like I'm going to
make up a formula this isn't the actual
reaction diffusion formula but what I'm
going to do is where's the camera
where's the screen i'm losing my mind
i'm going to say grid x comma so next
dot a equals grid XY dot a you know
times 0.2 and next then the next b is
the grids B times 1.2 so I'm going to do
that so this is this again this isn't
the correct formula we're going to have
to actually put in the reaction
diffusion formula but I'm showing this
is the structure by which I say the next
generation will be that so now if I run
this again up we come back to here well
it doesn't seem to be animating or
changing why so it's not animating or
changing because I'm still
drawling it based on grid so maybe what
I actually want to do is draw the next
one and I did get something strange
happening here so it looks different and
let's actually not let it go over the
values go over I mean so you can see
that it is actually doing something like
the values are different but importantly
here I don't see anything animating so
one of the major things that we need
here is and let's think about is
something called a swap are you with me
are you still paying attention I would
understand if you weren't okay so I need
a swap so this is a very common
technique in Celeron Amada systems and
other types of generation by generation
systems what I have here is I have a
prong side of this marker what I have
here is I have a two dimensional array
called grid and then I have one called
next so grid is all my starting values
then next is calculated and then next is
drawn to the window well what you should
then become grid again so I can get a
new next and draw that to the window so
what I need to do is swap them what I
need to do is say let me put next back
into grid and then I have a new blank
one to write on and I could just pull
grid over there because I'm it's the old
one I don't need it anymore so if I if I
want to have this continuous generation
I have the old and the new so new gets
calculated then new becomes old and I
could just use that old one that I had
to be the next new one and then new
becomes old then the new gets calculated
the new because well again so I need to
have a swap so I'm actually going to
write this as a separate function so at
the end of every whoops after I draw I'm
going to call a function called swap and
I'm going to write that down can you see
this I'm going to write this down
somewhere down here so I'm going to
write a function and called swap and so
what's going on here next I want grid to
be next and I want next to be grid I
want grid to be next and I want next to
be grid I want to swap them oh but this
is no good
if grid is next and the next equals grid
well the next is next because grid is
next we've got a problem here
so in a swap what I need to do is I need
to have a temporary variable that keeps
track of the old grid
so now grid can become next and next can
become that old grid temp so this is a
very simple swapping algorithm to swap
the values of two variables and that'll
do the trick for me so now if I swap
them this will get applied over and over
again so let's let's do point nine and
point eight just so we see something
happening here and you can see it went
down to zero very quickly and I could
you know I could say point nine five and
I could try doing 1.01 so you can see
it's going towards it's going to go
towards blue eventually so we can see we
have the system going on now again this
isn't this is the like Schiffman rainbow
reaction diffusion algorithm which isn't
very interesting at all so we have the
guts here we have the foundation we have
the two-dimensional array each spot
holds the amount of each chemical the
screen is colored based on those
chemicals and I have some formula to
calculate the new chemical value based
on the old chemical value so I don't
know how long I've been doing this for
but we're so close now all I need to do
is actually go and get that scary
formula from that webpage and stick it
in the code and we're done so let's go
take a look at that and it's going to be
a bit more difficult than I might have
imagined but let's see how it see how it
goes so now we're back to here so let's
look at all of these things okay a the
difference of the new a equals what a so
let's start putting this in so this we
can do difference of a equals new a so
I'm going to go back and I'm going to
probably need a lot more space here so
and I'm just going to do a for a second
the new a right equals what the old a
now I'm going to go back to this formula
plus plus now what da what is da look I
can't operate the computer sometimes I
went back Backson da is the diffusion
rate so where are those here we go these
are some typical values so this is by
the way is something that
you're going to after you watch this
video and use this example you wouldn't
want to like play around with these
values yourself or go look up other
values different values will produce
different kind of results so diffusion
rate of a is 1 so I'm going to in my
code I'm going to make these global
variables da equals 1 let's see what
else we got
DB equals 0.5 the fusion rate for B the
feed feed is how fast are you feeding in
chemical a is point zero five five I'm
going to call that feed just two because
f it can mean other stuff in programming
point zero point zero five five was that
it yep and K is zero point zero six two
VAR k equals zero point zero six two
that's that's sort of the kill rate how
fast is a be being removed so these are
the values that I'm going to need in
that particular formula so now I can go
back here and say plus the diffusion
rate of a time's up la upside-down
triangle applause 2d function okay so
let's let's make that something
temporarily that we're going to deal
with in a little bit so I'm just going
to say right now I'm going to say la
plus I'm going to make that a function
la plus a we're going to deal with that
later and times a times and you know
what I should do to make this shorter I
think something it could make things a
little easier is I could say a equals
grid XY a so that way I don't have to
every time I need that a value I can
just put a times a times my oh no - -
what a times B squared so a times B
times B and I'm going to I need a
variable for a boy this is a lot of
typing here I guess you could fast
forward now or put this on to x speed if
you're watching this still I kind of
want to like put this on multiple lines
also just so you can see it so whoops no
this should be here I'm going to do each
piece of this formula on a different
line I don't know if this is making it
- a times B times B so we have a times
the diffusion of a plus this Laplace
thing I have to get two times a minus a
times B times B and then now we have
plus the feed multiplied by one minus a
so plus the feed multiplied by one minus
a did I get that right plus the fee
multiplied by one minus a and I'm going
to put parentheses around these things I
think I'm sure it's right anyway but
this I think will help us a plus da at
the seam right a plus da times Laplace
so I so I'm going to just to be
consistent here I'm going to move this
down here and I think I now have all the
components of that formula a plus da
times the plus times a minus a times B
times B plus feed times one minus a does
that look right somebody watching this
in the live stream will correct me I
think I've gotten this right and we will
da Laplace times okay so hopefully I got
this right I have to do the same thing
for B why not just do it right now that
we're here so B is B plus the the
diffusion rate for B and I'm going to
make a Laplace be function which is a
little bit silly what I'm doing here but
I'm going to do it anyway times B and
then it is plus a B squared plus a B
squared minus minus K plus F times b k+
feed times b okay we're in good shape
here I'll put parentheses around this
just to be consistent so I think I now
have so I think I now have these
formulas now I didn't miss a crucial
point if you come back to this you'll
see delta T delta T is the
change in time for each iteration what
does that mean well the way the world
works is that time marches forward on
and on and on the way that computer
programs and animation programs work is
time marches forward in time steps
lockstep and how and we're doing this
calculation in this sort of like stop
calculate wait stop calculate wait stop
calculate so you know we can sort of
scale the amount of time that's passing
scale the calculation according down I'm
going to leave that as one and basically
my time scale is going to be the 60
frames per second that I hope that the
that the algorithm that I hope that the
animation plays out at but you can
really sort of change the quality of
what you're getting in the degree of
accuracy that you're getting by having a
smaller time steps you might try point
one point zero one point five and see
what you get but I'm going to kind of
just leave that out for right now for
the for the case of simplicity okay
so we've done everything now except for
this laplacian thing and so I'm
realizing by the way that this is
laplacian a this is not x a this is the
laplacian a thing so one thing I can do
is get rid of this times a and this
times B so what is that this is the
convolution so this is this particular
thing what I need to do in the laplace
function is look at the every single
amount of a in all of the neighbors I
need to multiply a weight and then add
them all together to get the new value
that's the laplacian function the
convolution so if we go back here let's
go back to this page and here it says
the laplacian is performed with a 3 now
there's different ways you could do this
but this is with a three by three
convolution with a center weight of
negative one
adjacent neighbors 0.2 and diagonals 0.5
this means the following so I need to in
this function look at every single cell
and apply a weight point zero five point
two point zero five point two point this
is the center one negative one and then
point two point zero five point two
point zero five
the diagonals get a weight of point zero
five the adjacent getaway to point two
and the center gets a weight of negative
1 we're trying to determine the
difference between that Center cell and
its neighbors and you notice it's in a
way these have higher weights because
it's like the adjacent ones are closer
to it than the diagonals so those
chemicals are going to play a larger
role in the reaction
you could try messing around with
different dyes now there are all sorts
of fancy ways I could write another
nested loop and kind of use some sort of
other two-dimensional array to keep
track of the weights I probably should
do that but I'm going to be a little bit
lazy right now and just do this in a
very hard coded manual way so let's look
at how I might do that so if I come back
here first of all let's just write them
so down here I'm going to need a
function called Laplace a and I'm also
going to need a function called Laplace
B and I'm just going to do something
right now I'm going to just say they
return the value 1 which is obviously
like wildly incur oh boy I'm not here so
I need to add these two functions sorry
I lost I didn't get back here I need to
add these two functions and I'm just for
right now for simplicity to make sure my
code runs just say that they returned
the number one so that this should do
something and I should get something and
I should get something so let's run this
and you can see okay so something's
working and you can almost even like see
it whoops see it like flicker do
something weird and interesting for a
second so that's good the other thing I
want to change by the way and I'll deal
with this later though let's leave that
now okay so but now I need to actually
do the correct Laplace function so what
I think I'll do is pass into Laplace the
function the current x and y and then
I'm going to do the entire calculation
in that function and I need to do it
with the grid right so what I need to do
is say something like the sum for a is
zero and then what I need to do is say
some a plus equal okay
what's the center the center is grid X Y
times that weight negative one so I need
to do this like nine times for all nine
neighbors 2 3 4 5 6 7 8 9 so the
adjacent ones are all multiplied by 0.2
so adjacent to the left is X minus one
adjacent to the right is plus one so
these get multiplied by 0.2 then above
and below is y plus 1 and y -1 those get
multiplied by 0.2 0.2 now I need to do
all the diagonals again this is like a
kind of terrible manual way of doing it
but it could do this in a loop in a much
nicer way but I think this is good for
figuring it out -1 -1 0.05 that's up
into the left plus 1 minus 1 and I just
need the same value for each one of
these ok then I need I need plus 1 plus
1 and then minus 1 minus 1 does that
seem right to you did I get oh no no no
I already did minus 1 minus 1 plus 1 so
I have oh boy I've been doing this for a
half an hour that's that's not good okay
look this is turning out to be a very
long video I should have done it in
multiple parts but it's too late now
ok so minus 1 minus minus minus plus
minus plus plus minus plus that's all 4
so I think I've gotten this right and
then I need to need to return and I need
to get those X Y values as arguments and
then I need to return that some a and
then oh and I'm not returning that whole
object I'm not adding out I'm adding the
a amount for each one of these and you
know so I could do this in a more clever
way by how so having it be one function
to add these objects together so now I'm
going to going to do the lip and I could
even like do a function that knows
whether it's doing the plus or a or b
but again I'm just going to do this
completely the totally manual way and we
can do another video I'm gonna I could
make this just a few lines of code and
I'm just going to be sitting here
come on sublime it's try its prying to
be way too smart for me I just want to I
don't want you to give me suggestions
sometimes I want suggestions sometimes I
don't want suggestions and this is silly
now that I called it this but I did so
I'm going to go I'm going to go all the
way through with it okay so now we
should we've got these Laplace functions
I'm
the convolution for every x and y i'm
adding up all the neighbors and the
weights so that should go right into
this formula and honestly I think we
might be done how do we be shocked if
this actually works we're gonna have to
debug what we missed but let's run it I
know there's kind of K so sketch is JA
great what I love what just happened
here so what just happened to cannot
read property zero of undefined so I
have I could kind of try to figure out
what's going on let's look at sketchiest
line 65 so down here there's an issue
here's the issue X minus 1 when is the X
minus 1 going to be a completely invalid
spot in the grid it's a completely
invalid spot if X is zero because
there's no negative one so I could do
some sort of wraparound thing or
whatever but I think what would be
easiest here would just be to say hey
you know what for this calculation I'm
not going to do the edge pixels I'm
going to start at one and I'm gonna go
to with minus 1 and height minus 1 so
I'm actually going to ignore the edge
pixels so I don't have that issue so
that should fix that now I'm going to
run it and look at this something kind
of crazy happened so I think I've got
the algorithm going here I'm a little
worried I have a mistake but the most
mostly the problem right now is that I
haven't really seeded this this in a way
that makes sense so I think the
traditional way these are done let's
look here is right I'm giving the grid
all random values is what I think would
make sense would be to fill it with B
right I want to fill the grid with B
let's run this it's blue and it or it
kind of turned red that's interesting
that's not what I expected to happen
but I'm going to just leave that that
and then what I want to do is I want to
give one spot like I'm going to say I'm
going to override that I'm going to say
like 100 100 dot a actually has a ball
out of a knit so I fill the grid with B
and no a and then I give one spot I pour
in a little a in that one spot why am I
getting this that's so interesting that
we're getting this weird square thing so
I must have messed something up
doo-doo-doo-doo doo-doo-doo-doo hello
I'm back I don't know where I would
that's gonna get edited somehow so
here's the issue I just I wanted to add
like a little bit of be like I filled
the whole thing with a actually switched
that from when I was maybe last in this
video so I filled the whole thing with a
and then I want to add a little bit of B
but that's not going to work just like a
one little droplet of be on one pixel
not going to get enough reaction
diffusion to make anything happen
I actually need to give it a blah a
block of like I need to pour a lot more
and so I need like a little area of so
what I think I'm going to do is I'm
going to say for and I'm going to use I
here just use a different like I equals
100 is less than 10 i plus plus no eyes
less than 110 i plus plus
now how you see the system is like super
interesting and I'm doing this not in a
very interesting way but I'm going to
use j j plus plus and what i'm going to
do is i'm going to take a whole area and
give it some be like a little 10 by 10
pixel area so every pixel from between
100 110 is going to get some beat right
every pixel is going to start with a lot
of a and no b and then this little 10 by
10 area is going to start with me and
what i'm actually going to do is just
for a second comment this out so let's
just see what this looks like
now why i'm getting this crazy
flickering you can't see that actually
interestingly enough i don't think the
flickering is showing up because i've
done something wrong with my rendering
but you can see though that oh whoa oh
now you're seeing interesting i don't
know what you're actually seeing on the
stream boy this is a really this was a
much harder web than I imagined but I'm
going to put this back in I'm going to
figure out what the flickering is there
why the flickering is happening okay so
you can see this is now finally working
I'm getting a weird flickering around
the edges oh oh I know what the problem
is I know what the problem is
because I'm not updating the edges the
edges need to make sure they're seated
with the original amount of stuff there
we go finally we're good so it took me a
little while there but the issue was
that I needed to
place an area of pixels in order to seat
it with some chemical be so this was
this was much but this would have been
good this would have benefitted from
this is benefit from a second run okay I
could just do this holding again and
probably get through it a lot faster
with less hiccups but hopefully this
helped you you can see now I now have
the reaction diffusion simulation you
can see this is one little area of
pixels and you know what happens if you
give it like like a circular area of
pixels or start stuff with like random
values what kind of patterns might you
get and you can see the reaction
diffusion algorithm is kind of
blossoming into this nice little flower
we can let it run for a little bit I'm
curious about the frame rate I'm it's
JavaScript is handling this pretty well
is is only 200 by 200 pixels so it isn't
it isn't a tremendous amount of pixels
for it to work with but so you might run
into some serious performance issues if
you do this in the browser it's going to
run a lot faster in processing of course
I'm sure there's like fancy shader WebGL
ways of doing this super super fast but
I think this kind of wraps up this
tutorial
so to recap just now that we've kind of
like just want to use this last few
minutes to kind of recap what I've got
is here we started out with in the code
we're going to walk through all the
pieces of the code now there is the grid
which stores the amount of a and B
chemicals across every pixel there are
all these constants which are associated
with the gray Scott implementation so
there's an amount of diffusion for a an
amount of diffusion for B there's a feed
rate and a kill rate so you can look up
different values for those like known
values that produce different patterns
you can also just play with those
yourself then I have to create these
two-dimensional arrays I need a current
and a next because I got to calculate
the next generation and then use the
current as the next generation then uses
the next I've got this cycling going on
and I'm starting and filling it each
spot with all chemical a and no B then I
start a little area of pixels the 10 by
10 area of pixels to put some chemical B
in and this is another place where you
wanting to play with this code you
should try something different like what
if you fill in around the contours of a
silhouette and you start getting this
like silhouetted person reaction
fusion pattern then in draw I do a bunch
of things number one is I just actually
implement that reaction diffusion
formula I need to calculate the next
amount of a and B based on the current
amount of a the diffusion rate to feed
the kill rate all of that stuff as well
as this sum of all of the neighbors so
the sum of all the neighbors happens in
these laplace functions that is lower
down the code again I would suggest and
I'd be happy to do this and post this at
some point if some wants to remind me
modified version I could condense this
into one function and it could also make
this happen in a loop but I think this
really shows exactly what's happening
and these weights again are defined by
the Simms page you could use you could
weight things you could have a five by
five matrix you could do different
things there so that's calculating all
those next values and then here the only
thing that's happening here is I'm now
setting every single pixel in the window
a color based on the amount of a and the
amount of B and I'm just using black and
white so it's up to you I think I could
go back you could say well the amount of
a could be the amount of blue the amount
of B could be bound the green you could
create rainbow cycling colors somebody
make a rainbow reaction diffusion thing
there's a lot of possibilities there for
how you could play this but this is all
of the code I think this is probably a
forty to forty five minute video I'm
assuming at this point and so please
play with this send me your feedback
send me your comments and let me know
how it goes
thanks for watching</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>