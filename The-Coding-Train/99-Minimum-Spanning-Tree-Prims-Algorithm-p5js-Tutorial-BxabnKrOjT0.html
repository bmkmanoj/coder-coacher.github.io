<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>9.9: Minimum Spanning Tree (Prim's Algorithm) - p5.js Tutorial | Coder Coacher - Coaching Coders</title><meta content="9.9: Minimum Spanning Tree (Prim's Algorithm) - p5.js Tutorial - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/The-Coding-Train/">The Coding Train</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>9.9: Minimum Spanning Tree (Prim's Algorithm) - p5.js Tutorial</b></h2><h5 class="post__date">2016-03-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/BxabnKrOjT0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello in this video I'm gonna give
myself a headache I can tell already but
I'm here to describe to you a problem
called the minimum spanning tree it's a
problem from computational geometry kind
of thing and I'm going to describe that
problem we're gonna look at a solution
that problem known as prims algorithm
named for somebody making print
presumably and then will implement it in
p5.js and as always I will also upload a
processing version of this as well but
I'm going to use p5.js to actually write
the code so first let me just show you
before I describe to you what the actual
problem is and the solution let's just
look I have a simple example preset
that's gonna that's the foundation for
what we need so if I just look at the
code for this example for a second first
there's just an array a blank array
calling it vertices because every time I
click the mouse I'm gonna create a
vector a vector being an object that
stores an x and a y so I'm gonna create
a vector with Mouse X Mouse Y where the
mouse is and then I'm going to add that
vector to an array and then you can see
in draw here I'm just drawing an ellipse
for every single one of those vertices
so if I run this program and I click you
can see here that every time I click a
vector gets added to that array and I
draw a circle for every one of those
spots so the question is what is what is
the minimum spanning tree problem and
this is a temporary whiteboard that I'm
gonna see how it works so bear with me
please what is the problem how what is
this problem once you have these points
so let's say you have the points and I'm
gonna make some random points the
minimum spanning tree problem says how
can i connect every single one of these
points every single one of these points
must be connected to another point and
if I add up all the distances I have the
smallest amount of distance so there's
lots of ways that I could connect them
all like I could just do this and
they're all connected but I could also
have done this and they're still all
connected and I could have also
done this and they're still all
connected and if I decide maybe he's
pretty evenly spaced out so probably if
I hope oh this is scary probably if I
were to draw a diagram like this and
then if I put another one here right
they're all connected like this but
that's probably if I add up those
distances it's going to be a lot greater
than if I connected them like this so
and it doesn't have to be a closed shape
it doesn't have to be a continuing path
the only thing that has to happen is
that every single point has to be you
have to be able to get from every point
to every other point somehow so this is
the kind of application that you could
probably create some kind of interesting
visual art project out of but it's used
it's a relevant practically it has
practical applications for example if
you wanted to connect everything with
some kind of like electricity or
telephone telephone people use those
anymore telephone signal you know and
you only had a certain amount of cable
like what's the way to have them all
connected and you using that you're
saving the most money using the least
amount of cable and I'm sure you could
come up with all sorts of other
scenarios for where this is relevant so
how do you solve this problem okay so
there's a variety of different solutions
to this problem some of which are more
efficient some of which are less
efficient some of which do it you know
more quickly or less quickly but the
solution I'm going to show you sorry is
called prims algorithm and it works as
follows what if we start with a random
point essentially let's start with this
random point okay now what if what we do
and we have this I'm going to introduce
this idea of an unreached Vernet vertex
or a reached vertex so at the start all
of the vertices are unreached there's no
line connected to it they're all
unreached vertices I can't get the
telephone signal to them and we're going
to start with one single and this is now
a reached vertex so what I want to do is
say okay what can I connect this one to
that has the least distance so this
particular
vertex I can check every others one and
I can see and I check the distance and
this one actually has the least distance
so now I have to reached vertices this
one is reached and this one is reached
now what I need to do is the same thing
I need to find not just the one that's
closest to this one but the one that's
the least distance between this one or
this one
so in other words if if this were here
I'd but you know this is a little bit
longer than this but shorter than this
and this I'm gonna go and I'm going to
go ahead and connect this here but if
this one is if this one is closer to
this one I'm gonna go ahead and connect
this now I need to say is this shorter
then this then this then this or this
and this so everywhere I have to check
every single reach vertex against every
unreached vertex and find whichever
pairing has the least distance and then
that gets and maybe maybe right now it's
this one and all these are reached and
then maybe right now it's this one and
then it's this one and then maybe it's
this one and maybe it's this one I don't
know if that's exactly right but you can
see that eyeballing it that's probably a
big solution so this is the problem now
let's go and write the code to solve it
okay I'm coming over here okay so what
is the first thing that we need to do
well the first thing we need to do is is
implement this idea of reached and
unreached so I'm going to create in the
draw loop I'm gonna create two new
arrays one for to store all the vertices
that have been reached and one to store
all the vertices that haven't been
reached at the beginning what's going on
here every single vertex should go in
sorry in unreached so I'm going to write
a loop here it's and I'm gonna say
unreached dot push vertices index I so
this is me just essentially cotton and
I'm sure there's somebody in JavaScript
land could tell me a better way to copy
an array into another array but one way
to do it is just say hey let me go
through everything in this one array and
put it on this other array so at the
beginning all the vertices right all the
vertices are unreached every single one
okay
come back over here now I want to pick
one vertex to start being the one that's
read
I need something to go in the reached
array so I'm gonna say var start equals
unreached index zero and then I'm gonna
say reached dot push start so I want to
put I'm sure I could you know whatever
this is silly to have a separate
variable I'm going to just put unreached
index zero zero not oh I'm going to put
one the first verdicts from unreached in
reached just to get us started okay once
we have that I need to do something else
if I'm taking a vertex from unreached
and it's going and reached I need to
remove it from unreached so I need to
say unreached splice zero so the splice
function set is like delete delete' the
zero element only I'm not done yet
the splice function wants you to say not
just which element do you want to remove
but how many so so I want to just remove
one element from that zero spot okay now
now I have an algorithm
I want my algorithm to go as I want it
the goal of this is to get everything
from unreached to reached unfortunately
this camera shut up
because I forgot to start it at the
beginning this video so I want
everything to go from unreached to
reached so here we go I'm going to say
as long as unreached dot length is
greater than zero I can keep going so
maybe there's another way in JavaScript
to test if the array is empty or not but
basically what I'm saying is as long as
there are still unreached vertices we
haven't finished the algorithm yet so
every single cycle remember every single
cycle we need to say what are the
reached vertices for every reached
vertex check the distance against every
other unreached vertex and find the
shortest distance so in order don't find
a shortest distance amongst a bunch of
candidates we always have to start with
something that's kind of the record if I
was trying to find the longest distance
it'll be easy I say this is the distance
bigger than zero then it's currently the
longest distance so the first thing I
need to do is just come up with I'm
gonna call it record some like large
number a hundred thousand so there's not
gonna be any vertices that are a lot
more than 100 thousand pixels from each
other in a 640 by 360 window then I need
to say for every oh and I probably
shouldn't know it's okay to use I for
every vertex in the reached array check
every vertex in the unreached array okay
for every vertex in the reached array
check every so at for every reach vertex
check every unreached vertex and what do
I need to do the thing that I want to
know is the distance between and let's
let's say v1 is reached index I and v2
is reached index J and I want the
distance between v1 x v1 dot y - V - X
and v2 dot y so the core algorithm here
is check every distance between every
reached vertex and every unreached
vertex now if the distance is less than
the record then the record is the
distance so what we're doing is we're
saying I want to find what is that
shortest distance at the beginning the
shortest distance is a hundred thousand
and the first distance is like three
hundred
oh it's less than it that's the record
then the next one is 250 oh that's less
than it that's the record then the next
one is 400 oh that's not the record then
the next one is one hundred oh that's
the record so we're doing every single
one always if we have a distance that
beats the previous record we have the
record so this is the core algorithm for
finding that shortest one but if I find
that shortest one what do I need to do I
need to store also the two vertices that
are involved in that shortest distance
so I I need to have in addition to just
the record I need the reached I'm gonna
call this the our index the reach index
and the unreached index so if this is
the case if I found that record our
index is I that's the index from this
array
and you index is J and in fact I don't
I could actually instead of storing that
now what we'll do that will do it with
the distance with the index so I got
those so so now you can see here I now
am storing IVA Lou kept ever checked
every reached every unreached found the
shortest one and once that's done once
that's finished what happens I need to
do exactly what I did up here right I
need to say put take take the unreached
one and put it in reached and then
remove it and then remove it from
unreached so this is my algorithm to I
found that new vertex remove it from
reach Mook route from one array and put
it in another array there's probably I
probably could like do this all in one
fancy line of code but it's nice to have
it in two and then while I'm here I
might as well draw a line oh I don't I
don't have those as global variables
that's fine
I might as well draw a line between
reached our index dot X so this is going
to get very long very quickly
all right next dot y and then unreached
unreached index dot X unreached
unreached index dot Y okay so let's see
I don't know did that work okay so line
45 I messed only oh because you know
what I'd better not here's a problem
right i mucked around with the arrays
and then I drew the line after so that's
definitely not gonna work right I need
to if I'm drawing the line right before
I start moving them around I should do
that so let's just see here okay so we
got kind of something happened and then
and then something didn't happen well
okay
so so let's think about this for a
second what what could - so this is the
core idea let's let's review for a
second how long have I been at this
13 minutes that's not terrible so we
started with every time we every time
there's something still EFT and
unreached we start with a record we have
two indices we go through everything in
the reached check it against everything
and under cha look at that that's not
right
v2 equals reached so the point of the
second one is to pull something out of
the second right that's clearly not
gonna work and yeah this looks like it's
working look at that and I don't like
the way the lines will look here so I'm
gonna say stroke two fifty five stroke
weight two and here
and you can see there we go we have our
minimum spanning tree as I add points
and conceivably by the way you know if I
wanted to just demonstrate this in a
different way I could say I could just
add like 50 random points right when the
program starts and I could say random
just with a random height and do this
you can see every time I run it we get a
new and the one thing I'll mention about
this is I'm doing in this program you
notice the whole algorithm is happening
in draw
so it's recomputing the minimum spanning
tree over and over and over again it
doesn't need to do that it but you know
it conceivably if the points were always
every time you add or subtract a point
you would need to recompute it and I'm
so you might be if you were using this
in something you might be more
thoughtful about only recomputing at a
certain point the other thing I'm not
doing here is this particular like
drawing is just sort of drawn and I
can't do anything with it so if I were
if I wanted to go further with this I
would probably make edged objects so in
other words I might have an array of
points or vertices or like a vertex
object I'm just using the p5 vector
object with create vector but then I
might create these edge objects so the
things that I could animate or change
color and put those in an array as
well.you and the place that i would do
that is right here right instead of just
drawing a line like i just did i figured
out the vertex I'm just going to draw a
line there I could actually create that
edge object all right so this is pretty
much the end of the video I'm actually
gonna look though I don't know if people
are posting quite I have this even
though if you're watching this you might
be watching this like 10 years from now
I actually am recording this
five and there are some people watching
this live so I'm gonna you could shut
this off now if you want but I'm gonna
just looking to see if there's any
questions somebody points out that okay
there are two improvements that are
pointed out in the chat which I'll
mention let's see if they still work so
first I just want to make this with just
20 so one is that I could copy the array
by saying reached reached equals
unreached the JavaScript function can
cat which I guess is like concatenate no
but then that doesn't it's not an array
it just joins them I'd have to then
split it or something but and then Oh
reached push unreached shift is another
way to put the first one in some people
are so there's all these other array
functions but that one's not gonna work
I'm sure there's another thing buddy put
it in the comments read the comments in
there there are all sorts of other kind
of array function so is there anything
else I'm missing here I think we did it
I'm gonna post this code a link to this
code please post your questions in the
comments cuz I don't know how well this
was explained or if this makes any sense
at all but I'm glad to have made a video
today on Friday it's 5:15 I gotta go we
just look is the code available
somewhere
yeah the code someone asks the code is
going to be there be a link in the
description it's not available yet if
you're watching this live I'm gonna stop
the recording and then talk to the live
people okay
bye thanks for watching this</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>