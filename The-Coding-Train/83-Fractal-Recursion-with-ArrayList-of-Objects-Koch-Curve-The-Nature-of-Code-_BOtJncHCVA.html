<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>8.3: Fractal Recursion with ArrayList of Objects (Koch Curve) - The Nature of Code | Coder Coacher - Coaching Coders</title><meta content="8.3: Fractal Recursion with ArrayList of Objects (Koch Curve) - The Nature of Code - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/The-Coding-Train/">The Coding Train</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>8.3: Fractal Recursion with ArrayList of Objects (Koch Curve) - The Nature of Code</b></h2><h5 class="post__date">2015-08-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_BOtJncHCVA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">in this video we're gonna look at the
Koch curve and ask ourselves the
question if we're using recursion to
generate a fractal pattern what if we
want the parts of that fractal pattern
to move or change or animate or do
something after that patterns been
generated if you go back and look at the
previous two examples we made it
wouldn't be so easy to do that the
recursive function just kind of draws
all that stuff for the screen that is
just there we don't have access to all
of those positions but there's a way
that we can do that let's first start
though let's use a tip why not let's use
a different fractal this time and we're
going to use the Koch curve so the Koch
curve as is has some similarities to the
cantor set which we just looked at the
Koch curve which can be used to make
little snowflake patterns incidentally
is we also start with a line start with
a line so here's our line now what do we
do we also the next step is divide the
line into thirds so the same thing we
divide it into thirds this is just what
we did with the Cantor set but now what
do we do we erase boy this looks really
the same erase the middle third okay get
my eraser here erase that middle third
and then the last thing that we do
though however is connect middle section
is probably a better way to write this
with an equilateral equilateral triangle
so this is the last step what do I need
to connect the middle section with an
equilateral triangle what does that mean
it means right we could imagine an
equilateral triangle sitting there where
each side is the same length of that
third but we're not going to use the
bottom so we're gonna connect it like so
so I guess connect the middle section
with its sides with two sides of the
equilateral triangle so that's our
production rule we went from one line
and at the end we got to this and what
do we have now we have four lines what
do we do with each one of those erase
the middle third erase the middle third
erase the middle third erase the middle
thirds
me and I didn't do this very well but
make an equilateral triangle make an
equilateral triangle make an equilateral
triangle make an equilateral triangle
hey let's do that again erase all that
we have one two three four five six
seven eight nine but we could do that
over and over again this is a fractal
you could figure out you could go look
at that Cantor set example you could
expand it a little bit and do a little
more math and you could be how you can
have the Koch curve but we want to do
something slightly different what if we
now want all the pieces of that Koch
curve to move what if we want all of
these line segments essentially to be
objects objects that could have physics
after all we've spent all this time
figuring out a lot of physics stuff we
might as well figure out a way that we
could apply it to a fractal shape not
all scenarios do you need this certainly
if you're doing a print design you just
need a static fractal pattern through
some recursive algorithm you could make
it but this is an important
consideration that does come up in a lot
of different scenarios so how are you
gonna do this and I call this because I
have to come up with lots of fancy names
the arraylist technique okay so what do
we mean by this arraylist technique
what's the difference well let's say for
a moment that we had an ArrayList ah
and we're back that we had an ArrayList
that's the other camera I'm gonna have
to fix that so we had an ArrayList and
inside we have also we have a line
object a line object maybe just has a to
P vectors a start and an end so we have
this line object and has a start and an
end and we have this ArrayList and what
do we do is that we put that line into
that ArrayList we make a line object and
we put it into the ArrayList the
recursion isn't a function that calls
itself it's going to be an ArrayList
that iterates over itself so this is the
ArrayList we can
at generation zero in a way at the very
beginning what do we start with we start
with one line object and now we say hey
in this ArrayList let's take this line
object use its start point and end point
and figure out what are all the points
for the next line object and then we
have one two the ArrayList suddenly has
four line objects in it and it's now at
generation one then it's going to have
sixteen line objects if I did the math
correctly it's at generation two
whatever the state of the ArrayList is
we're going to iterate over all of the
elements and for each element in the
array list produce four new elements and
I the way that I drew this I'd like to
draw it a slightly different way
remember when we did if you go back and
look at this cellular automata videos we
had this idea of a generation and we're
going to do the same exact thing we have
an ArrayList which is essentially
current and it might be represented by
this singular line and then we're going
to have an ArrayList which is next and
we're going to use that line to generate
the next ArrayList which will have four
line objects in it and then that becomes
the current one and we could do it again
and again and again okay
I hope this is somewhat clear so I but I
have no other than my own sometimes
inaccurate intuition but let's take the
next step forward and look at this in
the actual code and see if we can
understand it a little bit better
okay darkness sadness light happiness
okay
back camera was off so first let me just
run this and we're gonna see it in
action so here is the first line right
and notice here what do we have we do
have a Koch I called it a Koch line
right a Koch line object which has two P
vectors start and end okay
and now if I go back to the main tab we
can see hey what are we doing
we are making a line first at 0
comma height minus 50 and then at with
comma height minus 50 we add that to the
ArrayList and then hey there's one line
let's display it and there we go just
that one line now notice also that in
there's a key press function right here
which calls a function called generate
so when I press the key here you are
that's the camera when I press the key
look I generated the next generation I
took those that one line and somehow
turned it into four then I took those
lines and turn each of those into four
again and again and again and I could do
this to infinity but you could see
there's a limit to that kind of
resolution we have here and how much but
look at this interesting kind of quality
that we've got already giant arrow okay
so we can see that this works we're
getting the fractal pattern we could
imagine that there's some math involved
in how do we take that one line and turn
it into four but rather than look at the
math let's actually look at the guts of
this generate function and see if we can
understand what it's doing so here is
all that code and I want to talk through
it in a moment but first of all it looks
a little bit like gobbledygook so let's
kind of clear up one aspect of it look
for every line get points ABCDE and make
a bunch of new lines let's see if we can
make sense of that for a second
right if this was our original line and
this is what we're going to get right
this is start and this is end and what
do we need to make these four line
segments we need all of these points so
we need to calculate a B C D and E and
we can call this I don't remember what I
said in the code ABCD okay that's all I
did
so we need to get all how many points is
this five points if we have start and
end how do we get all five points and
then we can make what a new cottage line
that's between a and B and a new one
that's between B and C and a new one
that's between C and D and a new one
that's between D and E and all of those
line objects should go into our
ArrayList
that's exactly what's going on here for
every line we know what we started
there's just one but for every line
let's ask each line object where's your
ABCD and E points then let's make a line
for K to be a line from B to C a line
from C to D at 11 needy and add those
all to the ArrayList next next is the
new generation lines is the current
generation but once we make the next
generation the next generation becomes
the current generation right that's what
we're drawing we're drawing all the
current lines so when we start current
lines is one line then we generate we
make the next ArrayList with four lines
and that becomes lines and we see all
four of those there okay so this is the
process again it would be worth digging
into the math behind getting all these
points but that's not what I'm concerned
with right now I'm concerned with this
overall process which I think I've kind
of cover or your mom's gonna say one
more thing about it but now I've
forgotten okay so so this is what's
going on so let's actually okay sorry
let's just briefly pause and take a look
at how those points are calculated
because I think it's it's something
worth looking at you can see that some
of them are quite simple right
a point a is exactly the start point E
is exactly the end and if we go back
into the code we can say a and E are
quite easy point B is not that hard
either right point B is just hey it's a
point 1/3 of the length from the start
sorry 1/3 of the length from the start
that's point B and we can see here we're
just using reviewing our old vector math
days we make a point from but we make a
vector that goes from the start to the
end we divide it by three and we move
from the start and that's that location
so you can see C is a little bit harder
what do we have to do is C we had before
here we can make this vector we can
rotate this vector 60 degrees and then
move from here to there and that's that
point right the angles in an equilateral
triangle if you don't remember if you
make a triangle each side being equal
each angle is 60 degrees maybe I didn't
want to go over this math stuff but I
just kind of talked you through very
quickly you can see that's what's going
on start at the start divided by three
go to there then rotate that vector by
sixty degrees and then go from there so
again the part of this process of making
a fractal pattern is kind of mapping out
the shape and seeing if you can figure
out how to turn that shape into vectors
so that you can subdivide move along get
to this point that's what we're doing
but okay so I just wanted to briefly
point that out lips and butt back to
back to this so how did we go through
all that trouble after all all I have on
the screen is my static fractal shape
but we now have if I go into this if i
zoom in every single one of these line
segments is an object I know it's a
beginning point at its endpoint I could
grow flowers from there I could suddenly
put characters at all those points I
could have them all wiggle and move
around let's try that right what would
it mean to add a function here right
the Koch the Koch line is a start and an
end first of all I can start adding
physics I could add velocity get
acceleration and an apply force method
but we're not going to go that crazy all
we're gonna do is we're gonna add a
function I guess I'll do it towards the
top which is just called wiggle and what
I'll do is I'll say hey give me a random
velocity of random vector which I'll
consider a velocity and then hey add
that velocity to the start point right
so that's wiggling and I'm only wiggling
the start point you know you can wiggle
the end point will probably be more
interesting looking but let's just any
time I wiggle I'm just moving that start
point and okay I can't resist
let's get another random vector and
let's also wiggle let's also move the
end point so what we're doing is we're
making two random vectors and adjusting
the start and end location so now if I
go back to the draw and if I want to say
hey when the mouse is pressed
let me also loop through and wiggle all
the lines so right here I'm just adding
a little bit of code that anytime I
click the mouse whatever lines happen to
be the arraylist move them around so I
could run this sketch
and it's not doing anything different
it's exactly what it was before and I
could also run it but I can also click
the mouse and look this line is kind of
moving it around once that line moves
around I could go a few more generations
and look those lines can now move around
but I could continue doing the fractal
and those lines could move around so
we've kind of completely we haven't
completely lost the shape of the fractal
but it's gone a little bit awry but and
now we have somebody weird randomness
and maybe I could wiggle it but actually
remember which objects end point is
actually the start point of the other
object which would be super interesting
there's a great exercise for you to try
but this is the power of what we're
doing all these fractal shapes that
we've created if we make the parts those
broken parts that approximate the whole
shape if we make those objects in an
ArrayList then we can start to apply
things to them or know all the positions
to generate things from those locations
there's lots of things we can do all
right I think that's the end of this
particular video I've got two more
things to look at one is what happens if
we want to translate and rotate in the
process of making this fractal shape
it's kind of interesting and also I want
to look at the side concept of an
l-system
which is a recursive algorithm for
generating sequences of characters that
can be obstructions for drunk so those
are the two other things we'll look at
soon enough okay</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>