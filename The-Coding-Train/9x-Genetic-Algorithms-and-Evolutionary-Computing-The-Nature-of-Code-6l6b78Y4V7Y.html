<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>9.x: Genetic Algorithms and Evolutionary Computing - The Nature of Code | Coder Coacher - Coaching Coders</title><meta content="9.x: Genetic Algorithms and Evolutionary Computing - The Nature of Code - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/The-Coding-Train/">The Coding Train</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>9.x: Genetic Algorithms and Evolutionary Computing - The Nature of Code</b></h2><h5 class="post__date">2015-08-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/6l6b78Y4V7Y" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so I want to talk about genetic
algorithms and I first encountered
genetic algorithms with by watching this
video this is from 94 I'm going to play
a little bit of it for you this is a
project called I'm going to just turn
the sound off although this is a project
called evolved virtual creatures
actually the nice thing if you I
encourage you to google this and watch
it it's Carl Simms evolved virtual
creatures and the audio soundtrack is
kind of nice because it's like a
National Geographic style video but it's
all computer-generated creatures
so what Carl Sims did with this project
is create essentially this physics
framework for making these creatures
they're all these node-based creatures
so all these creatures are essentially
if I were to diagram them they're kind
of Li to think of them as particles with
spring connections in a way so they're
boxes and these spring connections are
muscles and they can expand and contract
and so Carl Sims was able to encode the
design for these creatures into a
virtual DNA and then say hey let me
stick them all into this physics world
and see how they do the ones that run
really fast jump really high swim really
well there's a water simulation in a
little bit those are the ones that I
will pick as parents quote-unquote to
make a strange virtual creature baby for
the next generation and they'll get the
better that they do the more likely they
are to reproduce and he evolved these
creatures to perform different tasks and
so looking at this I was looking at this
at a time where I was super fascinated
with just even just trying to model kind
of basic physics and so I wanted to see
if I could make something like this yeah
this is this is for the running sequence
this is the jumping sequence skip ahead
a little bit this is following a red dot
while swimming and what's really amazing
about this is it's very unexpected like
you would never design a creature to
look like that or do like that but this
one is very very good at kind of
swimming around in this water
environment and and at the end here
there's this like hockey like
competition where all these different
creatures try to compete for this green
tube so I
and so he would he would fill these
algorithms and then I kind of set them
up in this like physics 3d environment
and then had to like churn out frame by
frame what would happen right so you
know I don't know that's a good question
I don't know the exact process that he
used because in theory you don't need to
watch the simulation in order to find
out the result you might have just like
but we're watching the watching certain
creatures that were evolved and then
seeing them play out but it's all just
data it's all just numbers and that's
kind of what I wanted to get to into
description for how this worked and it's
like finally I have all these weird
gestures but there's a great all of this
is linked on there on the nature of code
website there's a further reading
section and there's a paper by Sims
which outlines how all this works in the
design of these creatures this one's a
cruel one that likes to beat up on it so
that I'm really not doing justice to the
soundtrack it's really quite nice but
you can watch that on your own time okay
so what I wanted to start with is kind
of talking through ok so the thing about
genetic algorithms is I for the book I
kind of divided my thinking into three
different categories and just erase this
which you know there is this genetic
algorithm or solving certain kinds of
computer science problems search
problems where a brute force method is
no good so if you need to check every
possibility it would take too long maybe
we could evolve towards the right answer
and then there there's this category
called interactive selection which is
really used in art design and we'll show
you some examples of that and then this
idea of thinking of ecosystem
simulations so what I wanted to talk
about first is the now looks like I have
a prepared presentation but these are
just images from the book but um so I
wanted to talk about the Infinite Monkey
theorem which is kind of a classic
classic test case a classic example of
an application of genetic algorithms so
the incident monkey theorem if you're
not familiar with it is this idea that
oh if we had an infinite number of
monkeys and an infinite number of time
and they're all just randomly typing at
these keyboards type typewriters
typewriters maybe keyboards iPads I
don't know that eventually they would
type the complete works of Shakespeare
and so this is theoretically true I said
those I believe to be true yes it is
theoretically true but the problem is
it's not something we could ever
understand our experience in our
lifetime and just to like make this
argument for a second so let's say we
have just the phrase to be or not to be
that is the question that phrase is 39
characters long so let's say we have a
simplified keyboard it only has 26
characters and one spacebar so just to
type a T there's a 1 in 27 chance of
typing a T right now if you know
anything about probability then
probability if we have if we want the
probability of two events happening in
sequence we multiply the probabilities
together so the chance of typing T o is
1 1 out of 27 times one out of 27 so the
whole phrase 1 over 27 to the 39th power
is a 1 in that big number a chance of
that occurring randomly so that's a very
large number which is kind of hard to
even fathom but that's not even for the
complete works of Shakespeare that's
just for to be or not to be the question
so and I worked it out a little bit with
that if there's a similar discussion by
the way on Wikipedia if you go to
Infinite Monkey theorem which kind of
goes through the same sort of stuff but
if you did if you were able to have a
computer simulation that could do 1
million random phrases per second it
would take that many years for there to
be I don't think I put this up here for
there would be a 99% probability that
you would have at least gotten to be or
not to be that is a question somewhere
in there so if it's much longer than the
entire much much much longer than the
age of the entire universe I think like
on Wikipedia when I was reading it the
other day it said something like if you
had a monkey for every atom in the
entire universe it would still take you
know anyway just way too long that we
can't possibly understand
so the point this is a stupid problem
right because we could just type to be
or not to be the question that is
question if we needed it but it
illustrates the point that there are
some problems for which you don't know
the answer like we know the answer here
some problems you don't know the answer
for which it still it would take that
long by brute force method so a genetic
algorithm is a way of saying ok what if
we had a population of phrases so let's
just say Phi for a second we're trying
to evolve the phrase cat
and we had a population of phrases like
bad car and hog sprayer to think of just
say P as a three-letter where I don't
know I can only think of like weird
uncomfortable words anyway be a bunch of
hat hat is good what what what PA thank
you there you go okay so a bunch of
phrases what we could do is evaluate
these so the way the genetic algorithm
works and I think I have you know I like
to sort of write this out but I'll just
use these there's this this very
specific algorithm and I'm using by the
way the word set up and draw or some
things that are very specific to
processing this algorithm works where
there's kind of this moment of begin
like the big bang happens and there's
this initial population that's seated
and then there's something that happens
over and over again a new generation is
born evaluated a new generation is born
so the very first thing that okay so one
of the things I should mention is that
if you look at Darwinian natural
selection by the way I don't really know
anything about biology and evolution so
I you know and that's the nice thing
about doing this stuff in like prop you
know computer programming and just like
make it up and be I'm like in spot it's
like it's like the TV shows where they
say inspired by actual events that's
what this is it's not I'm fired
yes fired by actual science so there's
heredity selection and I would like to
write first variation so if you think
about Darwinian evolution these are
three key principles that need to be
present for evolution to happen one
thing is that we need to have variation
so we would never be able to get to be
or not to be if we just had you know one
phrase to start with and all we could
ever do is combine and recombine that
one phrase we'd only ever have that one
phrase we only ever had bad we could
never get to cat but if we have a random
if we see our initial population that's
the first thing we do with a random set
of elements then we have variation we
have the chance to evolve towards some
optimal solution so to speak so the one
of the other principles that we need is
this idea of selection so selection
often refer to as survival of the
fittest we have this idea in nature that
you know the most fit
longest the thing that can run the
fastest will you know make the most
children but really what it is if you
think about it is just survival of the
survivors anything that lives longer for
any reason whatsoever is more likely to
reproduce so for but but you know that's
nature and here what we actually
unfortunately need to do in this
particular computer simulation is we
need to calculate Fitness so this is a
mathematical formula that we're going to
apply to these members of this
population we're going to say we're
going to evaluate their fitness and this
is how we perform perform selection once
we've evaluated the fitness of all these
elements we can pick the ones that
should be selected to be parents so for
example what you know a really simple
fitness function for these would be
count the number of characters they got
correct BA D 1 C AR 2 got to h OG 0 hat
is also 2 P is 0 so you can see how this
worked out really well by the way by
accident um yeah the character choice
but its position yes so you know this is
an open interesting question in other
scenarios the actual data could matter
in could be but this the this did this
having an a the way the album is going
to work having an A in the first
character would do us no good
we're not shifting them around that that
that is it sort of discrete chunk in
that particular order so now we have
this question of what we're going to do
what we need to do is make the whole
goal of this is to make the next
generation so what is the next
generation of I don't know what to call
these creatures it's kind of silly to
call these phrase and phrases so the
members of our population are phrases
what is the next generation we have to
figure out a way to pick them now
there's a lot of different strategies
for performing selection in this type of
simulation we could just say I don't
care pick the best ones car and hat you
make all the babies so car and hat just
reproduce and make all the all the all
the members of the next generation we
could do something where we take the top
half there are different strategies of a
common sort of what the common strategy
which I think in many ways is the best
is a probabilistic approach so what we
could do is assign the Fitness values to
be
abilities and we could say unfortunately
P has a 0% chance hat has a 40% chance
0% chance 40% chance oh no I'm sorry
yes oh 40% 20% chance if we add all this
up we get 100% yes good job ok so you
can see I'm mapping these scores to
probabilities and typically speaking
you're not really going to have fitness
values that are this simple which you're
having just 0 1 &amp;amp; 2 so you're going to
have a much more of a range of
probabilities and this is really key
because in a longer phrase we don't want
we want to keep it's possible that this
this one let's say okay bad here even
though it only got one right it could
have a gem in there that isn't anywhere
else in the population and we want even
though it should be less likely than car
had to be picked it still should be
possible that it should get picked and I
think kind of jumping around here but
here so this is kind of an illustration
that you can think of it as all of the
parents being this roulette wheel or
this wheel of fortune with the where you
spin it what we're going to do is now
over and over again in our genetic
algorithm to make the next generation
we're going to spin it twice pick two
parents and we're going to make a child
element from those and if we go back to
the this algorithm it says the so the
next thing is reproduction so this so
with you variation we got from
initializing the population selection we
get from this sort of awkward thing that
I described of evaluating all the
members of the population giving them a
score then assigning the scores to
probabilities and that's how we pick the
next members now we need to reproduce
and this is where the third principle
evolution comes in which is heredity we
need a mechanism for passing the genetic
information down to the next generation
this may seem obvious to you and it is
that point in this example is that it's
simple enough that hopefully this can
seem somewhat intuitive and obvious but
if you had to combine hat and car you
know we could look at this and say aha
take the C from here take the 80 from
here put those together and we have cat
we're done but again we're not taking a
top-down approach here what we're doing
is two things one is called crossover
and
one is called mutation and I think one
of these diagrams yeah one of these
diagrams just demonstrates this idea of
crossover so crossover one so if you if
you've done any programming you know
something called an array an array is a
list of information and usually most in
my examples at least the DNA is encoded
into an array of information an array of
characters array of floating points an
array I mean a true genetic algorithm we
all just zeros and ones and that's all
it ever is because it's you know much
cooler that way or whatever but um but
here we could say what we're doing is
we're picking half of one and half of
the other we could alternate we could
sort of flip a coin for each gene so to
speak for each element of the array
heads pick from the left tails pick from
the right we could pick a random
midpoint there's a lot of other options
but that's the first step so the idea is
your main goal the genes of the parents
intuitive January correct exactly and
now we get this next we got a new we get
we get this and and in theory we're
picking parents that have performed well
and by recombining their genetic
information we're going to get a child
that will perform equally well or
hopefully bye-bye luck a little bit
better and so but we want to add one
more step here and this is kind of
important because even though we got
variation in the first step by making
this random population we might not have
enough variation right if we only have a
population of 50 elements and we need to
evolve to be or not to be there might
never know might not have been one with
T is the first character and with
crossover if there's no T as the first
character will never ever get to be or
not to be but what you tation allows us
to do is say at any point there's a
small probability that after crossover
one of the genes so to speak one of the
elements of the array of the data would
just randomly change so here we could
say you can see here in this diagram we
got fo our Y and we will change it to
foxy I guess we you know so we sort of
flip a coin again and typically a
mutation rate would be something like a
small probability one percent two
percent somewhere around there so we say
there's a one percent chance of just
changing one of those elements randomly
and
introduces just additional variation
into the system simply one asking
questions okay let's see here
so okay so let's I'm going to come back
to this but let's just look at I'm going
to run this example now so if I go into
my chapter 9 examples there is one
example called GA Shakespeare and I'm
just going to run it and this is
currently running basically this
simulation that we talked about in
processing so you can see on the right
on the right left right on the right I'm
going to do it this way all stage right
yes all of the current phrases in the
population there's 150 they don't all
fit into the window it after 764 we
started with 150 random phrases there's
a mutation rate of 1 percent and after
764 generations one of them happened to
be the exactly right to be or not to be
so some things that I would just want to
kind of quickly demonstrate here is that
again
the point of this example is not that
this this doesn't have any value right
I could I could solve this problem in
one line of code print to be or not to
be that is the question right the point
of this is if we want to sort of learn
about genetic algorithms of understand
how they work we need a kind of example
where the answer is unbelievably obvious
so that's what we're kind of
demonstrating here the other thing I
just show you is that there's various
variables that we can kind of play with
here for example if I were to suddenly
just make the population 1,500 instead
of 150 we got to be or not to be in 38
generations because we just have so much
variety to work with so the other thing
that we that I could that I wanted to
demonstrate here is if I make the
mutation rate zero and the population
only 150 this isn't enough variation for
example we can see here there clearly
was no second character ever that was an
O there was no 4th character that was a
B so we're just sort of stuck in two
keys up vabir but so this idea of
mutation is really important but of
course if we have
1,500 elements again that's probably
enough variety and boom we got it right
there so it's kind of it's sort of you
can play with some of these variables
total population nation that's a typo
somebody do a pull request to fix that
there was something else I want to show
here yeah okay so one of the other
things I think is used important to see
like even if I make the mutation rate
ten percent like that is introducing so
much randomness into the system it's too
much randomness you can think about it's
likely that we're going to be randomly
changing a character almost in every new
member of the population so and to
illustrate the point of that we need a
lot of lifetimes of the universe if I
made the mutation rate a hundred percent
right this is this is the brute-force
method we're sitting here doing you know
essentially 150 times thirty per four
second random phrases and we're I mean
there could be some kind of like amazing
moment here were reacting got it but
then we should I go buy some lottery
tickets okay um yeah okay so what it's
doing is it's just thrashing it with the
whole phrase right the whole phrase that
make some moves on well right now it's
actually running through the genetic
algorithm but we've essentially negated
the jagged either because the very last
step because I don't care what evolution
you did I'm randomly mutating everything
so it's as if we're just newly picking
random elements every time so I you know
I think there's I mean I'm sure there
are lots of applications to this to
solving different kinds of you know
standard computer science problems data
related problems the direction that I
went in with what the examples in the
book is really in the animation and
simulation direction so I want to talk
through a few elements others in racer
here I'm just using huh I want to talk
through a few elements talk to a few
other examples and I think we can you
can answer some questions and wrap up or
whatever so one thing that I kind of
glossed over here is again I don't know
anything about actual science there is
something if you read about this kind of
stuff called a genotype and a phenotype
and one day this is a really important
distinction
that's actually secretly happening
behind the scenes here genotype we can
think of as the data itself right the
actual raw encoding the the bits the DNA
itself phenotype is the expression of
that data and in this particular example
this distinction is blurred there is no
distinction here because the data is the
phrase cat the expression of that is oh
the phrase cat but when you actually go
to use a genetic algorithm in a more of
a real-world scenario if you think of
that Karl Sims video that I showed the
data might have been this kind of
network diagram data structure the
expression was this kind of visual
physics simulation we need to be able to
have a mapping towards how are we what
is our system is it something visuals
it's something is it behavioral and how
do we encode that into data and this is
you know in many ways if you look at
these examples and you want to do a
project with them you can just copy
paste the code verbatim the the two
things are probably three I'll think of
more than the things that you really
have to think about are the fitness
function you know what is that you know
the good fitness function makes a good
genetic algorithm work well and then
what is how are you encoding the data
and how are you expressing that data so
there's a project from many years ago by
Jer Thorp called smart Rockets I think I
have that somewhere here okay okay and
this is done in flash I believe it's on
the web I'm sure you can just google
smart rockets J or Thorpe and find it
it's also referenced in the book but
excuse me what's happening here and
again this is just a search problem by
the way what's happening here is there
are these rockets that launch from the
bottom and the Rockets launch from the
bottom and they have each rocket I might
botch this slightly has like five
thrusters attached to it that thrust in
random directions so they're vectors
they're forces that can thrust out in
random directions and the DNA the gene
genotype is the sequence of how those
thrusters fire the expression is the
actual physics simulation of them moving
so if you think about it here those
these Rockets their goal is to reach the
argot and their fitness function in this
case is you know how close did they make
it to the target so inversely
proportional to the distance the closer
they get to the target the higher the
fitness so the ones that do better pass
their genetic information to make new
rockets for the next generation and if
you run this over time you'll see these
these Rockets start to evolve this
really nice swooping path around that
obstacle in the middle and there's some
nice design elements here you can sort
of see this path over time so this is
this is a nice example of kind of taking
gin McGowan we could say like there's a
known solution here which is like I
could go
you know I don't want to mess up the pre
- screams I could go draw a path like we
could figure out possibly what's that
but here we could imagine this being
part of it some type of simulation a
game a museum exhibit some interactive
experience where the elements are
involving a certain behavior if you were
to move the obstacle around they would
they would have to revolve a new path
I'm going to show you some examples like
this in processing so the second example
I have in the book is essentially a
simplified so jairs has a lot of bells
and whistles for looking nice and doing
extra features there I in the in the
book I have a very simple I think it's
this one that I want to look at very
simple implementation of it it's it's
much uglier less interesting to look at
I put that eraser somewhere here this so
the thing that I just wanted to mention
here is that we're we kind of you have
we have this question we have to answer
which is that DNA as we saw we think of
as this list of information it could be
zeros and ones it could be as we saw
characters you know know what I'm
writing here in this case one of the
things that's interesting about a couple
of my examples or I like to think it's
interesting at least is that the DNA is
vectors so it's directions and
magnitudes velocity vectors force
vectors so each each one of these
rockets has a kind of sequence of
vectors that control its path and
they're evolving if you know these take
a little while to run but if we ran it
for a while it would
all sort of this path around around that
target I'm going to quickly yeah just so
like when they they die and then
everyone's evaluated yeah okay so I've
kind of a meant to get to this but I'll
just mention this for now so you may be
wondering boy this is a see very natural
it is like this absurd way of thinking
about evolution right if we were to map
what we've just done here or in the to
be or not to be the mean to the real
world it's as if we'd be saying okay
let's evolve some monkeys let's get 20
monkeys in this room let's have them run
around for a while
we'll give them have to put a score on
them and then we'll tell which monkeys
to mate and then they'll have babies
that will kill all those monkeys and let
the next monkeys run around so if the
real world is much more fluid there's no
scoring it's just so that is the the the
that is I think it's sort of important
distinction here and the next I was
going to say the last the last example
that I have to show you kind of ask that
question of could we do a more fluid
simulation where just things that live
longer somehow through whatever
arbitrary parameters have a more more
likely to then reproduce so yeah it's a
little weird but you're right that's
what's happening I'm letting the
simulation run it gets to the times out
I evaluate them make the next generation
just to just show you one more example
which is basically the same thing but a
little more interesting just in terms of
the technical implementation so this is
exactly the same thing just a lot more
rockets and I'm visually just showing
you the one that kind of doing the best
that generation and there's no obstacles
here one thing I want to show you about
this in the previous example each
objects DNA was a linear list of vectors
in this one their DNA what's in their
brain is actually a flow field so a flow
field is a two-dimensional grid of
vectors you know those you can't tell
whether which was pointing forward or
back and what I'm showing you here but
so each one of those triangles is
essentially looking at an arrow that
sits underneath itself which tells it
which way to move and in theory if we
ran this for long enough what we would
evolve hopefully is just a lot of lives
that point straight across one of the
things that I think is kind of
interesting to play with with this
example is I can kind of draw obstacles
so if I draw a little obstacle here that
blocks them and you'll see it engage
kind of in the next generation and
they'll start to evolve a path around it
but what I'll do is draw a few obstacles
here and then I'll let them know that's
going to be way too hard I didn't get
very far in the first place but anyway
so you'll see once one gets kind of far
it'll start to a few more of them will
the next generation will kind of get
there's a lot of random as a player I
actually have the mutation rate very
high in this particular scenario because
I find that this is a difficult enough
problem there needs to be a lot of
random fluctuation to get around these
kind of corners so I'll try to let this
run as I continue to show you some more
other things guys yeah so like right now
he dies and then it's not wrong no you
know what I'm just a draw highlighting
whichever one is currently the best so
it changes over time you know there were
it was that that one for a while now
it's that one so uh so I'm glad you
mention that slope so this idea of
genotype and phenotype is important the
fitness function is also really
important one thing I didn't mention is
that our Fitness function for to be or
not to be that as the question was
actually not a very good one just
counting how many characters are right
isn't very good and I'll try to explain
to you why let's say the target phrase
was 8,000 characters long and we had one
one member of the population that got
7,000 correct and one that got 7,000 and
one correct if we evaluate these if we
turn these two numbers into
probabilities the probability of picking
one or the other is going to be very
very very similar but 7001 is really a
lot better than 7,000 so you'll see in a
lot of these examples and I think I have
a like very very basic illustration of
this right that in a lot of the examples
if you go look at the code in the actual
fitness formula that we were mapping the
number of characters correct
exponentially so whether we square
artisan to power this or whatever so
that we act the more characters we get
correct the higher the score is
exponentially so a linear mapping of
number of characters correct to score
and the same thing with distance so it's
something that you'll see in a lot of
these how you tune that Fitness function
can really affect how the system behaves
and let's check on these guys because
I'm afraid it's going to quit and will
be very sad oh you know it's rich
running really slow because I'm drawing
all those lines in the background which
we need to do see how well they're doing
pretty good
so you'll see they'll make it there
eventually I also not giving them very
long amount of time to get there it cuts
off before it so I probably should have
tweaked those variables as well but okay
so yeah it in this case I'm also the
other thing I should mention yes if you
feel like really attached to these
little creatures and maybe just that's
just me
so the other thing I wanted to mention
here is that one thing I'm also doing is
they haven't reached the end yet when
they reach the end I keep track of the
order of them so who is first to a
second who was third and if you were
first boy your fitness is much higher
that way they in theory you know they
would optimize words the fastest path as
well okay so yeah no I'll let it run
we'll come back you guys really want to
watch this okay just I'll let it okay so
the last thing I wanted to mention is
and for those of you who are doing stuff
on the web or web developers this is
this is probably where it might get even
more relevant if or possibly I don't
know um all of these examples I've shown
you so far have taken an algorithmic
approach to fitness it's a mathematical
function we're scoring the elements but
we could take a different approach which
is often known as interactive selection
where we say Fitness is user-driven
so in other words by that I say hey and
so here's apparently all I can use is
Karl Sims as my examples but Karl Sims
has a project an art piece or
installation for many years ago called
gallopping see how old this is by you
know there's the state of the okay so
this is called Galapagos and there are
these monitors in a kind of gallery
space there's sensors on the floor
and they're showing these images and as
anybody stands on one of those sensors
it registers a value and what it's doing
is is assigning Fitness based on how
long somebody is looking at something so
it makes it kind of open question here
which is that you know what is that
really evolving the most beautiful image
the thing people are most likely to
stand in front of who knows but it is an
interesting technique for saying Fitness
is user-generated it's evaluated and the
one thing about this is you know in to
be or not to be we could do thousands of
generations per second right frames of
animation computer of calculations this
other thing is very very slow people
have to stand in front of it over long
periods of time you know in a in a
public space over years maybe you could
get some data the place that I think
something like this could really work is
on the web where you have a distributed
way of saying hey world everybody quick
science of fitness is and we could
evolve something maybe anyway
you know it's the SETI at home kind of
approach of you know the mass audience
kind of helping in a single problem so
and also like these are what the images
look like I think they were all like
these Lisp sequences anyway so um I
wanted to show you just briefly a kind
of simple so here is the so interesting
interactive selection is really
interesting I've seen people do it with
music with images I saw a project which
was like evolving cell phone rings ring
tones but here I have what might
possibly be the lamest example of
interactive selection ever but just to
demonstrate the point these are a bunch
of designs for faces they have there's a
there's data here the data is color size
position width of the mouth and what
what this example does is it allows you
to say okay I really like green so I
really like this one I'm giving that a
much higher score when you involve the
next generation you can see you know I
did that in the very sprayed it one of
them but I could say I like this one a
lot and this one a little bit and you
can see I'm starting to mix and match
there's some mutation in there so again
there's nothing particularly exciting
visually about this or even that
creative in its thinking but it
demonstrates the process
of creating a visual based on data and
one of the things about this example is
that every the DNA this is a kind of a
nice technique every element in the in
the DNA is just a floating-point number
between zero and one one thing that's
nice about that is you can always map a
number between 0 1 to any range so I
could say this is the red value and I
map it to 0 255 this is the green value
0 to 5 this is like the eye size I map
it from 10 to 20 so you can have this
kind of generic DNA where everything is
a floating point value and then map
those values to the design of something
you know for it I would say if you're
looking to create a design you know
thinking of a node based approach or not
you know parameter based approach
there's lots of other possibilities
there ok
so I think I'm kind of nearing the end
of the end of time maybe we have that to
be or not to be that is the question by
now let's check on that's is that the
same one yeah oh yeah see right so you
know it the problem with that is we
don't I don't know which one's going to
get there so I could run it secret twice
I could zoom through it figure out which
one it is it's funny I actually just
added most did made this example most of
it this afternoon so what's so cool that
this is that the guy that ends up
winning is not occur for a lot for like
the first third of it right yeah there's
a lot of mess going on here and what's
interesting what I don't like what I
what's interesting about this is that
you know there's really only a small
number of vectors that are really at
play here all that stuff in the corner
like it's not being used it's just it's
only just random because anyone going up
there is kind of lost and off is not
going to be picked so there's it would
be nice if what I was hoping visualizing
the flow field is that eventually you
could really see the flow field the path
of the flow field it's kind of happening
more mysteriously but I think there's
probably other ways of visualizing this
that could be kind of interesting to
demonstrate the process so so node or
each guy has the entire flow field as
that's correct so it's a two-dimensional
array of vectors in the example
a lot of numbers to do with yeah yes yes
you said earlier this is a one that gets
there first gets higher priority yes not
in direct correlation with how fast you
know you're right yes I didn't actually
time them and use their time to fitness
which I could have I just quickly
ordered them and said number one higher
number two yeah so you're right if it's
sort of in the fitness function is
really here just mapped to as if they
like all finished in like perfect
lockstep timing yeah not but you
absolutely could use their time yes for
cert for sure um you know the other
thing about this is on you know most of
these are kind of pure but you have
tried it with these examples not put any
top-down thinking on to this but you
could do certain things like I could
have maybe seeded the system with all
the vectors pointing to the right start
and that might have given us at least we
you know more we might be able to see
that path more clearly than at all being
random to start so eventually all these
guys are going to figure out a better no
there's so much mutation that I think at
this point it's probably going to look
like this forever but I think we'll get
we'll get some marginal improvements
like there will be some some they'll
start to get a little bit faster you're
right if I use time that would really
help that's a great idea
yeah because right now it's just getting
there first if everybody's really slow
you know so yeah so let me just show you
this last example and then we can kind
of be finished so I think I have a
diagram that I'll just kind of use out
here it is
so I there's the last example I want to
show you just demonstrates the idea of a
kind of more I'm calling an ecosystem
simulation so more like the real world
would work so we have these creatures
called bloops and they're either big or
small or they're you have a size they
have one their DNA is one number a
single number in maps of their size and
how fast they move so the big ones move
very slowly the small ones move very
fast and they need to eat food to
survive and there's food in the system
so if I run this simulation now
I'll leave all these running I guess
sorry ah I can't it's very hard to use
your computer in this strange
configuration okay here we go um
evolution ecosystem okay so let me
around this one hopefully this will work
and what's happening here all these
creatures so this is I guess a
simulation of asexual reproduction each
creature just clones itself when it has
a baby
so at any moment in time there is a
small probability that it will clone
itself so the ones that live longer just
have a longer amount of time to have
that happen and one thing you'll notice
here if is that the system tends to
evolve towards medium-sized objects so
it's not that interesting of a result
the big ones are really good at
intersecting the food but they move too
slowly so they don't really find the
food the little ones are move super fast
but they're so tiny they don't seem to
run into the food that often so medium
tends to be about the right the right
the kind of the perfect size to
intersect the food and move about the
space and yeah it starts with a random
amount of food and then I think when
they die they leave food so what the
only thing that I find the only
unexpected result that I've noticed here
is sometimes there's a cluster of big
ones that just like a lot of them die
there's a lot of food in one area and
then there's another big one that just
keeps eating it I'm making new big ones
so a little cluster of big ones can kind
of survive for a while in one part of
the screen so this is to me what kind of
thinking through the most basic way I
mean there's so many things you could do
to a simulation like this to make it
more sophisticated for example you could
give these creatures some intelligence I
have a whole section about steering
behaviors so you could allow them to
kind of see where the food is choose to
seek the food avoid a predator you could
also add things like they only make a
child when they come together for a
certain amount of time so um so there's
a lot more that you could do with the
simulation like this but this just kind
of at least demonstrates the idea
there's no fitness function and there's
no generations it's just a system that
lives there the circles are moving
around they
or die and they reproduce and that
eventually I guess I added so many it's
kind of still has a lot of variety there
if we run this for a while you'll tend
to see that it mostly ends up with
medium sized elements if so it's it's
I'm using something called Perlin noise
in this example Perlin noise is like a
smooth randomness so there's no it is
kind of a quick way to get things look
like they're wandering around the screen
but just to now I'm kind of jumping
around here a little bit but if you're
interested in this type of ecosystem
simulation I would recommend taking a
look at Craig Reynolds steering
behaviors and I have I'll just show you
like here's an example of one this is
all from the chapter six in the book and
so this is an example of crowd path
following so here are entities that are
following a path as well as trying not
to run into each other so one thing that
I always say is a exercise for students
in the class is build a system where
autonomous agents have a wide variety of
steering behaviors and make the weights
of those behaviors their DNA so how much
they try to follow a path versus avoid a
naver versus seek food versus run away
from a predator see if you can evolve
some type of optimal behavior this the
weights for these steering forces are
just hard coded in so that they follow
the path and but so combining this kind
of intelligence of an autonomous agent
with the genetic algorithm is perhaps
you know something that could yield some
results other questions I think that's I
finished with half of the examples are
um oh that's a good question I don't
know that I really know the answer to
that I mean I think there is kind of a
state of the art in computer science
research for me I see this kind of work
in game design a lot with really
interesting results so you can think
about if you're trying to create
autonomous characters in a game that can
adapt to the way a player you can
certainly use this in like museum
exhibits as well that's sort of more
than the space that I see at ITP at
least kind of picking and choosing from
the kind of computer science research
what's kind of easy
understand and use and apply verse
rather than kind of dig deep into the
the depths of the stuff thank you so
much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>