<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Git Tutorial: Fixing Common Mistakes and Undoing Bad Commits | Coder Coacher - Coaching Coders</title><meta content="Git Tutorial: Fixing Common Mistakes and Undoing Bad Commits - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Corey-Schafer/">Corey Schafer</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Git Tutorial: Fixing Common Mistakes and Undoing Bad Commits</b></h2><h5 class="post__date">2015-10-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/FdZecVxzJbk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hey how's it going everybody in this
video we're going to be looking at a few
common scenarios and get where you can
find yourself needing to undo some
mistakes or even roll back some bad
commits now some of these commands will
change the get history and some will not
and we're going to take a look at
exactly what that means here in a second
now this will be a slightly more
advanced get walkthrough and we're going
to assume that you already know the
basic command line functionality of git
if you aren't familiar with basic git
commands or how it works I do have a
video on getting started with git in the
command line if you would like to watch
that video first but with that said
let's go ahead and get started so let's
take a look at the sample repository
that I have set up here so if I do an LS
dash L a within this directory you can
see that I have this calc py file and I
also have that calc py file pulled up in
my text editor over here and you can
also see that we have the docket
directory here which just means that we
are within a git repository so now if I
run a get status you can see that
currently our working directory is clean
if I do a git log then you can see that
we've only had one commit so far it's
just the initial commit and also if I
run a git branch you can see that we
have another branch here called subtract
feature
so both the subtract feature branch and
the master branch are currently exactly
the same they both only have that one
initial commit but for now we're not
going to bother with the subtract
feature branch we'll take a look at that
here in a little bit so let's look at
our first example of a mistake that you
might want to undo so first we're going
to say that we've made changes to a file
and after a while we realize that we
don't want any of the changes that we've
made so whatever whatever we've done it
just isn't right and we want to go back
to the way things were so for this
example I'm just going to type in a
bunch of gibberish here into the text
editor but more realistically in the
real world this would likely be a
code that for one reason or another just
isn't right and you want to go back to
the way that things were so for this
example if I go over here and do a git
status you can see that we have modified
the file if I do a git diff you can see
all the gibberish lines that we've put
in there
now the way that we can fix this is to
just use a simple git checkout so what
I'm going to do here is a get checkout
calc py and if I hit enter there now if
I do a get status you can see that our
working directory is clean and if I do a
get diff you can see that we don't have
any changes and if I go over here to the
file and this reloads over here you can
see that we are back to the way that
things were after we made our initial
commit so now let's actually make some
changes to our file that we do want to
commit to our repository so I'm going to
come in here and change the subtract
function and I'm just going to do a
return X minus y so that's what we want
so now I'm going to go back over here to
our terminal now if I run a git status
you can see that the file has been
modified in the working directory and
I'm going to add that to the staging
area and now if I do another git status
you can see that that file is ready to
be committed so now I'm going to go
ahead and commit this file but let's say
that we make a git commit and
accidentally mess up our commit message
so I'm going to say that we completed
the multiply function which is wrong
because we completed the subtract
function so I'm going to go ahead and
commit that with the bad commit message
so now if I do a git log you can see
that we've made the commit but the
message is wrong so how do we modify
this message without doing another
commit well to do that we can just do
another commit with the - - amend option
so if I do a git commit dash - amend
that I can type in - M for my message
and I'm just going to say
completed subtract function so now if I
do a get log here you can see that we
haven't added any more commits we still
just have the two commits but we have
changed this commit message on our last
commit which is what we wanted now I do
need to point out that this unique hash
here is different than it was before we
change the commit message now that's
because the commit message is part of
the commit and changing it will also
change the hash and when the hash
changes that means that it changed the
get history so we only want to ever
change the get history when we are the
only ones who have had access to the
changes that we've made so if we've
pushed our changes for other people to
see and pull from then we do not want to
change to get history because it can
cause problems with their repositories
so later in this video we're going to
look at some ways in which we can make
Corrections without changing to get
history but as long as we are the only
ones who have seen our changes then
changing the history isn't necessarily a
bad thing and it also makes for cleaner
commits so in the case of a bad commit
message this is likely something that
you'll notice right away and can fix it
right on the spot like we just did now
kind of a similar scenario is that
instead of accidentally committing the
wrong message now let's say that we
accidentally left off a file that we
meant to commit so in this example let's
say that I meant to create a git ignore
file and I wanted to add it to that last
commit so I'm going to create a dot git
ignore file here and now let me go ahead
and run a git status and also let me add
that to the staging area so I'll do the
git add git ignore so now it's in our
staging area but we don't want to make a
new commit let's so for this example
we're saying that we wanted that to be a
part of the last commit so again we're
just going to do the git commit best -
amend like we did before but this time
it's going to do it with a file so if I
hit enter here now it's going to bring
up this
interactive editor where we can change
the get commit message if we want now
notice here that this is the same get
commit message from our previous commit
now we don't want to change the message
in this case so I'm just going to save
and close out so now I'm going to do a
git log and you can see that we still
just have the two commits that we had
before now if I do a git log - - stat
this will show us the files that were
changed within the commit and you can
see here that the git ignore file is now
part of the last commit where we did the
completed the subtract function now once
again just to point out this unique hash
is now different
so we once again change to get history
so just one more time just to remind you
only do this type of thing if you
haven't pushed your changes yet to other
people so now if I do a git log and then
I do a git branch so now we see our
subtract feature branch and now just say
that it hits us all of a sudden that
we've been making all of these commits
to the master branch by accident really
we've been meaning to make these commits
to our subtract feature branch now this
is a fairly common mistake to commit to
the wrong branch because when you switch
back and forth sometimes you just forget
exactly where you are and end up
committing to the wrong branch by
accident so how do we move this commit
right here this one b8 1:8 how do we
move that commit to our feature branch
now to be clear here exactly what we
want to do is our goal is to move this
commit to our subtract feature branch
and then we want to return our master
branch back to the state of only having
the single initial commit so the way
that we're going to do this is we're
going to use git cherry-pick and
cherry-pick creates a new commit based
off of our original so in this case our
original is going to be this top commit
here now cherry-pick only creates a new
commit
based off of that committed doesn't
delete the original after a cherry picks
it so let me clear my screen here and so
the process that you go through to do a
git cherry-pick is first you want to do
a get log because we want to grab the
the hash of the commit that we want to
cherry-pick so we don't have to grab the
entire hash usually six or seven
characters is fine so I'm just going to
copy this here and now I want to do a
git checkout on my subtract feature
branch so now I'm going to switch to my
subtract feature branch and now from
that branch if I do a git log you can
see that we only have the initial commit
now I'm going to do a git cherry-pick
and I'm going to paste in the hash that
I had copied from the master branch so
now if I hit enter there and now I do a
git log now you can see that we brought
that commit for the complete subtract
function if we brought that commit over
to our subtract feature branch so now we
have that commit on our feature branch
but it still exists on our master branch
because cherry-pick doesn't delete
commits but we don't want that commit on
our master branch we never meant to
commit it there to begin with so how do
we get rid of it so to do this we're
going to use a git reset so I'm going to
do a git checkout
on master and now I'm going to do a git
log so that we can see the commits that
we have now there are three different
types of resets that we should know
about these are get reset soft get reset
mixed which is the default and get reset
hard
so first let's run through all of these
so first let's run get reset soft to try
to return to our initial commit so I'm
going to grab the hash from this initial
commit and copy that and now I'm going
to do a git reset - - soft and then I'm
going to paste in that hash of our
initial commit so now if I do a git log
you can see that we no longer have that
second commit what
is good that's what we wanted but let's
also look at our gift status now you can
see that we have some files and our
staging area so soft will reset us back
to the commit that we specified but it
will keep our changes that we've made in
the staging directory so we didn't lose
any of our work so in this case our work
refers to the addition of the dot get
ignore file and the modifications that
we made to the calc not py file so that
is a soft reset let's look at a mixed
reset which is the default so again I'm
going to grab the hash of the initial
commit and this time let's do a git
reset and I'm just going to paste in the
hash because without any additional
options it will default to mixed so
let's go ahead and run that and now
let's look at our get log we only have
the one commit which is good but now if
I do a get status you can see just like
get reset soft it kept the changes
however now these changes aren't in the
staging area now they're in the working
directory so it's very similar to get
reset soft but the files are either put
in the staging or working directory
based on which one you specify but in
this example reboot we really don't want
our changes we really just want to go
back to that initial commit and have
everything the way that they were so
again let's copy the initial commit hash
and this time we're going to try a get
reset hard so get reset hard is going to
make all of our tracked files match the
state that they were in at the hash that
we specify and you have to be careful
with get reset hard because it will get
rid of your changes but in this example
that's what we what's what we want so
I'm going to do a git reset - - hard and
paste in that hash now if I do a git log
you can see that we have the one commit
and now I'm going to run get status so
notice that the modifications that we
made to the calc py file are gone but
that the dot get ignore file
still there now if you remember I said
that the get reset hard reverts all of
the tracked files back to the state that
they were but it leaves any untracked
files alone so we can see here that we
still have some leftovers with the get
reset hard but luckily getting rid of
untracked files is extremely simple so
to get rid of untracked files we can
just use get clean so if I do a get
clean and then I'm going to specify the
D and the F option so the D option gets
rid of any untracked directories and the
F gets rid of any untracked files so if
I run that now if I do a git status you
can see that our working directory is
clean and that dot get ignore file is
gone now that clean command is a good
command to know because it actually
comes in handy more often than you think
for example one time I was accidentally
accidentally unzip the file within my
git repository and it created just a ton
of untracked files and subdirectories
and I could have gone through and tried
to pick all those out manually and
delete all of them but the easiest way
to remove all those untracked files is
just with this single get clean command
okay so we learned that the git reset
hard told it totally deletes all of our
changes but what if you accidentally ran
that and it turns out that you did need
some of those changes so let's pretend
for the sake of this walkthrough that we
don't have those changes still save to
the subtract feature branch and we
thought that the reset deleted all of
the changes that we've made so if you
did run a get reset hard on some changes
that you really needed then are you
completely out of luck well not entirely
so you could be out of luck if a lot of
time has gone by since you ran that get
reset I don't know the exact amount of
time but I think get garbage collects
those commits after 30 days or so but
get ref log is what we're going to want
to use here so get ref log shows commits
in the order of when you last reference
them so
let me run a git ref log here and you
can see that it kind of shows us exactly
walkthrough of exactly what we've been
doing so you can see here at the bottom
is where I made my initial commit and
then we committed our complete multiply
multiply function which was wrong and
then you can even see where you amended
commits so this was an amended commit
where we changed our message and another
amend that's where we added the dot
getting more file and it shows us that
we checked out and moved from master to
subtract feature and then did our
cherry-pick and our check out and then
our reset now if you'd accidentally got
rid of files that you didn't mean to get
rid of then so for this example I'm
going to grab the hash before the reset
and copy that and I'm going to do a git
checkout of that hash and now from here
I'm going to run a git log so you can
see when I run a get log from this hash
that we have our changes back this is
the commit that we reset and got rid of
all those changes now right now we are
in a detached head state now I'm not
going to go fully into what this means
but basically it means that we aren't on
a branch and where we currently are it
will be trashed at some point in the
future so to save these changes we need
to make a branch from it so from here
I'm going to do a git branch and I'm
just going to call this backup and now
if I run get branch command to look at
all my branches you can see that
currently were any attached head State
and that's we'll get garbage collected
at some point and now we have our master
branch or subtract feature branch we
also have this backup branch so now let
me check out the master branch and now
from the master branch if I do a git
branch you can see that we still have
our backup branch so those changes that
we thought that we'd lost now we have
those in this branch here so just to
confirm that we still have those changes
let's do a git checkout of that backup
branch and now from here that's doing
get log and now you can see that we have
those changes that we thought that we'd
lost so the get ref log can really be a
lifesaver if you thought that you had
lost some critical files that you really
didn't mean to delete or that if you
accidentally did a reset on something
the ref log can really help you out if
you know how to use it okay so in these
examples so far I mentioned that you
shouldn't change to get history if other
people have pulled those changes already
well what if you are in a situation
where you really need to undo some
commits but other people have already
pulled those changes so in a situation
like that you're going to want to use
get revert revert creates new commits to
reverse the effect of some earlier
commits so this way you don't rewrite
any history just to clarify that it's
not going to modify or delete our
existing commits that we've made it's
going to create new commits on top of
those that completely undo all of the
changes so that our history remains
intact so just to show an example of
this I'm going to run a git log and you
can see that we have our two commits
here so now what if this completed
subtract function
I wanted to undo that but other people
have already checked that out well I can
just copy the hash here and I'm going to
do a git revert and then paste in that
hash and now it's going to come up here
with a message and I'm just going to
save that and exit out of that and now
if I close out of there and do a git log
you can see that we now have three
commits and these two bottom commits are
completely untouched both of their
hashes are still the same as they were
before the pervert now we have this
additional commit that says that it
reverted the complete subtract function
so if I go over here to my account dot
py file and reload it you can see that
it's undid that return statement that we
typed in now one nice little trick with
the get if command is that if I do a
to get logged here and then I do a get
death of this hash and this hash here
it's going to show me the difference
between the complete subtract function
commit and then the reverted version of
that so you can see that whenever I
compare these two commits all it did was
go in here and it completely it's all
all the changes that we made in our
complete subtract function commit and
then it just redid or undid those so for
that commit we took out the pass line
and added in the return X minus y line
and in the revert it took out the return
x minus y and added in the past so it
just did the complete opposite so now
whenever you push these changes and
somebody else pulls those down their
history is not going to be corrupted
because all of this history is the same
and all they're going to get is these
are these new commits that undid those
previous commits well that about does it
for this video I hope that these get
tips on how to undo some of your
mistakes and roll back some previous
commits I hope that this was useful for
you all if you do have any questions
just ask in the comment section below
be sure to subscribe for future get
videos and thank you for watching</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>