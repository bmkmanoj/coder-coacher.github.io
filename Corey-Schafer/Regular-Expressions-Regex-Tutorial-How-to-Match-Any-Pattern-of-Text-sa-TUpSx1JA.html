<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Regular Expressions (Regex) Tutorial: How to Match Any Pattern of Text | Coder Coacher - Coaching Coders</title><meta content="Regular Expressions (Regex) Tutorial: How to Match Any Pattern of Text - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Corey-Schafer/">Corey Schafer</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Regular Expressions (Regex) Tutorial: How to Match Any Pattern of Text</b></h2><h5 class="post__date">2017-10-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/sa-TUpSx1JA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hey there how's it going everybody in
this video we're going to be learning
how to use regular expressions so we're
actually going to look at regular
expressions as a standalone topic
because they aren't specific to any one
programming language now there are some
slightly different flavors here and
there but for the most part whether
you're programming and Python or
JavaScript or Java or whatever if you
learn how to use general regular
expressions then it should mostly carry
over into your language of choice and it
will also allow you to use them in text
editors and the command line and things
like that now I am going to do a
follow-up video where I show how to use
regular expressions specifically in
Python since that's a language that I
cover most on this channel but for this
video we're going to be learning how to
use regular expressions by themselves so
that you can apply these to other areas
so with that said let's go ahead and get
started so regular expressions basically
allow us to search for specific patterns
of text and they can look extremely
complicated but that's mainly because
there's just so much that you can do
with them you can create a regular
expression for just about any pattern of
text that you can think of so let's see
what some of these look like so I have a
test file open here that we're going to
use to search for specific patterns and
I'm going to be using the regular
expression tool in the atom text editor
to write these regular expressions and
find what text matches our patterns now
in order to open up this regular
expression search tool I'm just going to
go to find and then find in buffer now
you could have also opened this up with
command F on a Mac and I believe that's
ctrl F on windows now within the options
here make sure that you have the dot
asterisk selected over here because
that's going to tell our search tool to
use regular expressions and also select
this match case option here as well
that's just going to give us behavior
that is more common to how regular
expressions usually behave okay so let's
start writing some regular expressions
and first we'll start off kind of simple
so first of all we can just search for
literal characters so if I was to search
for ABC then we can see here at the top
that it highlighted ABC because it
matched the ABC and our lower case
alphabet now it didn't match the capital
ABC here because it's case sensitive
now this search right now is looking
specifically for a B and C but if I was
to type in
something like BCA then we can see that
there were no results found because the
order does matter now if we look at this
meta character section here I have some
examples of characters that I say need
to be escaped so for example if you
wanted to search for a literal period
now if I was to just type in a period
here and hit enter for my search then we
can see that it does this weird thing
where it matches everything and that is
because the dot is a special character
and regular expressions and we'll see
more of this in just a second but for
now if we just wanted to actually search
for a period or a dot then we have to
escape it and to escape characters we
can use the backslash so if I do a
backslash and search then now we can see
that it only matches the actual literal
dot or period within our document here
and that goes for any of these meta
characters that I've listed here so for
example we can see that the backslash is
a special character also so if you
wanted to search specifically for a
backslash then you have to escape itself
so a backslash to escape and then a
backslash for the search and if I search
for that then we can see that we matched
a literal backslash so a practical
example of this might be trying to match
this URL right here so if we wanted to
match that literal URL exactly then we
could just say kori MS and then for the
dot on the dot-com we have to escape
that with a backslash and then a period
and then come and we can see that it
matches our URL okay so that's how you
match literal characters but a literal
search isn't too exciting because we're
used to that already really we want to
use regular expressions to search for
patterns and to do this we're going to
be using some of these meta characters
that we were just escaping so I have a
snippets file open here so I'm going to
switch over to this and in here I have a
list of values where we can see the
types of characters that we can match
now just for now I'm going to try to
make this into a split screen here as
we're walking down this list so the
first one I have listed here is this dot
or period and we can see that this
matches any character except a newline
now we've already seen this but let's
take a look again if we just do a
and search for that then we can see that
it matches any character except it does
not match the new lines okay so next on
the list is backslash D and that matches
any digit 0 through 9 so if I was to do
a backslash D here and searched for that
then you can see that this matches all
of our digits so anything 0 through 9 it
matches now we also have an uppercase D
here and that matches anything that is
not a digit so if I search for an
uppercase D then we can see that our
digits are not matched but everything
else is highlighted so it matched
everything except for the digit now
you'll notice that this is a common
theme here that the uppercase versions
of all of these are the ones that kind
of negate the search so moving on down
here we have backslash W that searches
for any word character and a word
character is lowercase a through Z
uppercase a through Z 0 through 9 and an
underscore so let's search for the word
character and we can see that it matches
you know all these lowercase uppercase
numbers and things like that it doesn't
match these special meta characters here
and just like with the digit the
uppercase W will match anything that is
not a word character so anything that is
not in this list here so let's go ahead
and search for that uppercase W and we
can see that you know it picks up the
spaces and these special punctuation 's
and things like that but it does not
match the word characters that we saw
before now if you're not quite getting
this just yet we are going to look at a
lot of examples to where it'll start to
sink in so moving down the list here we
have backslash s which will match any
white space and white space is a space
tab or a new line so if we search for
backslash s then we can see that it
matches our new lines here and our
spaces but it doesn't match any of these
characters and here so it's mainly white
space and just like with the others the
capital S will search for anything that
is not white space so now you can see
that we have you know all these
lowercase uppercase digits and then also
this punctuation anything that isn't a
new line or a space or anything like
that
now these bottom ones over here the
backslash B the caret and the dollar
sign these
are a little bit different so these are
called anchors and they don't actually
match any characters but rather they
match invisible positions before or
after characters so let's see what I
mean by this so for a word boundary if I
search for a word boundary here
so now let's search for where we have
this ha ha ha here let's search for a
word boundary and then ha and match that
so we can see that that matched because
there is a word boundary here at the
start of this line before this first one
here and this space here is also word
boundary so this one gets matched as
well but this last one does not get
matched because there's no word boundary
between these two cause here now just to
show with what this would look like
without the word boundary if I was to
search for that then you can see that it
highlights all three of those now just
like with the other ones if I do a an
uppercase B then that matches anything
that is not a word boundary so if I do
an uppercase B then we can see that we
match the one that it didn't match
before because there is no word boundary
between these two here so it doesn't
match these first two now if I was to
put word boundaries on both sides of
these then it should only match this
first one because this is the only one
that has a word boundary at the
beginning which we're matching here and
at the end so this one has a word
boundary at the beginning but not at the
end because it's in the middle of this
word and this one has a word boundary at
the end but not at the beginning ok so
our other two anchors here are pretty
similar so the caret matches the
position at the beginning of a string
and the dollar sign matches the position
at the end of a string so let's say for
example that we only wanted to match a
ha if it was at the beginning of a
string so for example if I was to do a
caret and then a ha and match that then
we can see that it only matched this one
because it's the only one that is at the
beginning of a line now if we wanted to
only match it if it was at the end then
we could put that dollar sign at
and what we're saying here is that we
only want to match this if the end of
the string is the is in the following
position so we can see that it not only
matches this last one because the end of
the string is the next position in line
okay so now that we've seen what we can
match with these special characters here
now let's go ahead and take a look at
some practical examples so I'm gonna
move my snippets file back here and we
will keep referencing that later on but
for now let's go ahead and say that we
wanted to match a couple of phone
numbers and let's write some regular
expressions to do this now with a phone
number we can't just type in a literal
search like we did before because all of
these are different so they have a
similar pattern but they're not all the
same digits so in this case we need to
use the meta characters instead of
literal characters so we just have a
pattern here of three digits and then a
dash or a period and then three more
digits and then a dash or a period and
then four digits at the end so we saw
before that we can match a digit with a
backslash D and that is going to match
all of the digits in our file so we want
to match this phone number here so we
want to match first three digits in a
row so we can just put in three
backslash DS and that will match any
three digits in a row so now that we're
matching those first three digits now
we're getting to where we can see that
we're either going to match a dash or a
dot in our phone number so for now let's
just match any character that's in this
position so from our snippets file we
saw that if we want to match any
character the win can use a dot so we
can see that for now our pattern is
still matching some other stuff as well
but let's just continue on so now that
we're matching this - or this dot now
let's go ahead and add in the next three
digits so we want to search for three
more digits so I'll do three backslash
DS and now we're going to want a dot to
match any character which should match
that - or that dot and now we want four
digits so we can just do four backslash
DS so now we can see that this regular
expression highlights both of our
phone numbers and matches both of those
so now we're starting to see how this
could be pretty useful so for example I
have a data file here now if I pull this
up then I have a bunch of fake names and
numbers and addresses and emails but if
I wanted to match all of the phone
numbers in this file then you can see
that the regular expression that we just
wrote matches all of the phone numbers
here so now we're starting to kind of
get a sense of how this could be more
useful than just a literal search
because now we're actually searching for
a specific pattern so now let me go back
to our simple text file here so now
let's get a little bit more specific so
let's say that we only wanted to match a
phone number if it had a dash or a dot
now right now this pattern will match
any separator because we're using the
period down here which will match any
character so if I was to put in a
another number here that doesn't have a
regular separator let's just say it's an
asterisk then we can see that it matches
this number as well even though the
asterisk isn't really a phone number
separator so to only match the dash or
the dot we're going to have to use a
character set and a character set uses
square brackets with the characters that
we want to match so to create a
character set I'm going to replace our
first dot here and this is going to be
square brackets now this is a character
set now within this character set we
want to put the characters that we want
to match so we want to match either a
dash or a dot and I will just copy that
and we'll replace this second dot here
which was matching any character and we
will put that in for that as well and
now you can see that it only matches our
phone numbers here that have a dash or a
dot separator and it does not match this
one with the weird asterisk there now
you probably also noticed that we didn't
need to escape our dot character within
our character set and that's because
character sets have some slightly
different rules
now you can escape these characters if
you'd like but it just makes it a lot
more difficult to read if you do that
now even though the character set has
multiple characters here in the set it's
still only matching one character in our
next it's matching one character that is
either a dash or a period but if I was
to put in let's say two dashes here into
one of these numbers then you can see
now it doesn't match that number because
it's only matching the first dash or a
dot and then it moves right on to
looking for a digit so it's looking for
a digit in this position so that's
something that can kind of throw people
off when they first start working with
regular expressions so even though you
know we have four characters total here
in this character set with these square
brackets and all of the characters in
this set it's still only searching for
one literal character up here which is
either a dash or a dot now to show
another example of this let's say that
we only wanted to match 800 and 900
numbers so I'm going to create two
different numbers here I'll do an 800
number and a 900 number here so if we
only wanted to match 800 and 900 numbers
then our first three digits here we have
to do something different so first we
want the first digit that we're going to
match to either be an 8 or a 9 so we can
do a character set and we can say that
we're looking to either start with an 8
or a 9 now the following two numbers are
going to be 0 0 and that's just a
literal search so now you can see that
we're finding the 800 and 900 numbers
here now within our character set the
dash is actually a special character as
well so when it's put at the beginning
or the end of the character set then it
will just match the literal - but when
it's placed between values that it can
actually specify a range of values so
for example we know that the backslash D
matches any digit but what if we only
wanted to match digits between let's say
1 and 7 so to do that we can use a
character set and we can just say
instead of typing out 1 2 3 4 5 6 7 if
we wanted to specify a range of those
values then we can just say 1 - 7 so now
we can see that we're matching all of
the digits between 1 and 7 but the 8 9
and the 0 aren't getting matched up here
now you can do this with letters as well
so if we won't only wanted to match the
lowercase letters A through Z then we
could just do a character set of A
through Z now you can see all of the
capital letters aren't getting matched
but the lowercase ones are now if we
wanted to match the uppercase and
lowercase numbers then we could just put
our ranges back-to-back so I could say a
through Z and then just add on to this
character set and say capital A through
capital Z and now we're matching all
letters regardless of whether they are
uppercase or lowercase and you could
keep adding to those ranges if you
wanted to you could do a 0 through 9
there as well to add in all digits now
another special character in our
character set is the carrot now we saw
before that outside of the character set
it matches the beginning of a string but
within the character set it negates the
set and matches everything that is not
in the set so for example if we wanted
to match every character that is not a
lowercase letter then we could say this
carrot and then a through Z so we can
see that it matches everything on our
screen that isn't a lowercase letter
it's not matching these lowercase
letters here so it's even matching these
new lines and the spaces and everything
so just to show another example of this
let's say that we had some words here
cat mat hat and bat so let's say that we
wanted to match every word that ends in
a T except bat we don't want to match
bat so to do this we can just say that
we want a character set of everything
that is not be followed by a T so now we
can see that it matches all of these
three letter words that end in 80
except for bat because our character set
here negated that B so everything that
we've looked at so far has involved
single characters so in this example
right here where you're matching any
single character that is not a B then
followed by an A and then followed by a
T but we can actually use these things
called quantifiers to match more than
one character at a time so let's go back
to our original phone number example
from earlier and we'll do
match any character like we did before
so I will do three digits and then a
period for any character and then three
digits again and a period for any
character and then four digits at the
end and I'm just going to remove what we
had there for an example and scroll
those back up so to see what quantifiers
we have available I'm going to make my
snippets half of my screen here again
and then scroll down to my quantifier
section so the asterisk will match zero
or more of what we're searching for the
plus sign will match one or more the
question mark will match zero or one and
to match exact numbers we can use these
curly braces with a number on the inside
so in this example this would match
exactly three of what it is we're
looking for and we can also specify a
range of numbers as well with the first
number being the minimum and the last
number being the max so this would
search for whatever our pattern is it
would look for three or four of those so
let's take a look at an example of this
to see how this works
so you can see that with our phone
number we are searching for one digit at
a time but we could change this if I
erase my digits here then we could say
that I'm searching for a digit and then
we could put in our quantifier for
exactly three digits and we could do
this after our separator as well so
we're searching for three digits and
then any character and then here at the
end we want to match four digits so
instead of writing out the same
character over and over we can see how
these quantifiers allow us to specify
exactly how much we want now here we're
matching exact numbers but sometimes we
don't know the exact number and we'll
need to use one of these other
quantifiers so for example here at the
bottom of this test file here we have
some lines where each starts with a
prefix of mr. or miss or misses so let's
say that we wanted to match these
prefixes as well as the names after so
just to start let's start by matching
the names that start with mr now we can
see that some of these
have a period after the prefix and some
do not some of them just have a space so
let's start our regular expression by
searching for lines that start with mr
and then we're gonna put a backslash
period to search for that literal period
and right now it isn't matching this mr.
Smith which doesn't have a period after
the prefix now to match that also we can
use this question mark quantifier which
tells our pattern that we want to match
0 or 1 of that character so if I put a
question mark after that literal period
then it's saying that there can be 0
periods there or there can be 1 so we
can see that now it's matching the ones
with 1 period there and it's also
matching the one with no period so now
to continue and match the entire line
now we want to match a space after that
and after the space we want to match any
uppercase letter and to do that we can
use our character class and we can match
any uppercase letter by doing a range of
uppercase letters there so at this point
after that first uppercase letter that
we match we've completely matched the
name for mr. t down here at the bottom
but we still need to match the rest of
our other names so we could say that we
will match any word character after that
uppercase so let's put in a backslash W
to match any word character and now we
don't know how many more characters are
going to be in our name so we'll have to
use a quantifier here now if we look
over here we could use the asterisk or
the plus sign and the plus sign will
match one or more of these word
characters and the asterisk will match
zero or more so if we used the plus sign
then we can see that it matches our two
top names here but now it's not matching
this mr. t because after our word
character it's searching for one or more
word characters after our uppercase
character so a better solution in this
case may be to use the asterisk which
matches zero or more word characters and
if we use that asterisk then we can see
that it matches
all three of our names that begin with
mister now I know that we've covered a
lot so far but we've got a couple more
concepts to go and then we'll look at
some examples that wrap everything
together so we still haven't matched our
miss or misses names here so how would
we do that so you might think that we
could use a character set that matches
either an R or an S and there are maybe
some ways that we could get that to work
but it probably would be a bit ugly
since we'd have to match either and R or
an S as the second character and then
the optional s after that so that could
get kind of ugly but I think a better
solution here would be to use a group
now we haven't looked at groups yet but
groups allow us to match several
different patterns and to create a group
we use parentheses so after the M here
instead of just searching for mr. I'm
going to create a group with open and
close parentheses here and now within
our group we can specify different
matches so I can say that we want to
match either an R and then or and we use
this character here to specify an or and
that is just the vertical bar character
to specify an or so we can say that we
want to match an R or an S and whenever
we add that in we can see that now we're
matching the miss name here but we're
still not matching this misses so to
match the misses we can put in another
or and say that we want to match an RS
okay so now we can see that we are
matching all of our names here so let's
do a quick walkthrough of this one more
time to make sure we know what's going
on so we have a capital M to start and
then that capital M is followed by
either an R and s or an RS and then we
are looking for a literal period and
this question mark says that we can have
zero or one of those so that is optional
so it's matching the ones that do have
that period and the ones that don't and
then after that we are matching a space
then after that space we the first
letter of the last name we're looking
for any capital letter
so we
a character set here that is a through Z
of capital letters and then for the rest
of the last name we are matching zero or
more word characters now these groups
can actually be used to capture sections
of your matched regular expression and
that's something that we'll look at in
just a minute but for now let's do a
quick recap of everything that we've
learned so far
and look at some examples that
incorporates all of these things
together so I have a file here and I'm
going to move my snippets back into the
group here and open up this file emails
txt so I've got a file here with three
fairly different email addresses so
let's try to write a regular expression
that will match all of these emails so
let's just match the first email address
first and see what that looks like
so the first email address we have a mix
of upper and lowercase letters here
before we hit this @ symbol so let's go
ahead and match those first so to match
any upper or lowercase letters we can do
a character set and we can do a
lowercase a through Z or an uppercase a
through uppercase Z now right now this
is only matching those single characters
so we can use the plus quantifier to say
that we want one or more of these upper
or lowercase letters so we're still
working on the first email address here
we have our upper and lowercase letters
here and now we want to match that at
symbol so I'll just put in a literal at
symbol and now for the domain name here
I'll just do a another search for any
upper or lowercase letters so I'll do
the same as we did before and then I
will do a plus sign for a quantifier to
match any upper lowercase letters after
that at symbol and then that's when we
hit the end with the dot-com so to match
the dot-com we can do a backslash period
for the dot and then we can just fill in
a literal com so now we've successfully
matched that first address now it looks
like it's not matching the second
address so let's see why and see if we
can mold this to match the second
address as well so we can see that the
second address has a dot in the first
part of the name here so
let's add a dot to our first character
set so that dots are included in that
character set so now it's still not
matching that second address and it's
because at the end here we don't have a
dot com but a dot e-d-u so in order to
search for both we can use a group like
we saw before using open and close
parentheses and we can search for either
com or edu okay so now we are building
this up a little bit at a time and we
can see that we are now matching our
second email address okay so now let's
see if we can change this to match our
third email address here so and our
third email address it looks like before
the @ symbol we also have some hyphens
and some numbers in the first part here
so let's add those to the character set
as well so back here after our capital
letters I'm also going to add in digits
by doing 0 through 9 and we also want to
add a dash in there as well so that
should match everything before the @
symbol now it looks like we also have a
dash in our domain here so we'll have to
add that in as well so after the @
symbol we're matching any characters
right now it's just lowercase and
uppercase but we can put a dash in there
as well and lastly it's still not
matching because just like the other two
instead we have a.net here instead so we
can just add in a second or at the end
and also include dotnet so we can see
that we built that up a little bit at a
time to match all three of our email
addresses now with something like email
addresses it can be pretty tough writing
your own regular expressions from
scratch but there are a lot of these
available online and once we learn how
to write regular expressions then we
should be able to read them and figure
out how they're matching as well now
I've always found that reading other
people's regular expressions to be a lot
harder than writing them but let's take
a look at one and see if we can do this
so I have an expression here that I
pulled off line that matches email
addresses and let's paste this in here
and see if we can read through and see
what this is matching so we can see that
the one that I got offline does match
all three of my email addresses here now
let's look through this so we can see
that it's somewhat similar to what we
had before but first we have a character
set here and it's a pretty large
character set and it matches lowercase
uppercase any number and underscore a
period a plus sign or a hyphen and then
the plus sign here says that we want to
match one or more of any of those
characters and we match one or more of
those characters all the way up until we
hit an @ sign and then after the @ sign
we have another character set here and
in this character set we have lowercase
letters uppercase letters any digits and
also a hyphen
now I don't know a lot about email
addresses but I'm assuming that since
they left out the underscore the period
and the plus sign that were in the first
part of the email address I'm assuming
that those aren't allowed in the domain
so then we have a plus sign after that
character set which means that we're
matching one or more of any of those
characters all the way up until we reach
this literal dot and that literal dot is
escaped with a backslash and then after
the dot we have another character set
here and this character set is any
lowercase letter any uppercase letter
any digits any - or a period and then
that is followed by a plus sign which
matches one or more of anything in that
character set so just like I did with
the phone numbers if we open up our data
file here with this regular expression
that we've typed in then we can see that
it does match all of the email addresses
in this data file as well so we've got
an expression that will match email
addresses fairly well so doing what we
just did and reading through a regular
expression written by other people is
probably the hardest part of all this
but if you walk through it bit by bit
then you should be able to break down
just about any pattern okay so the last
thing that I'd like to look at in this
video is how to capture information from
groups now we've already seen how to
match groups but we can actually use the
information and capture
from those groups so to show an example
of this I'm going to open up a file here
with some URLs okay so we can see here
that some of the URLs are HTTP some are
HTTPS also some of these have WW before
the domain name and some do not
so let's say that you had a list of a
lot of different URLs within your
document and you only wanted to grab the
domain name and the top-level domain
which is dot-com or gov so for example
out of all these domains you only wanted
to grab google.com or quarry MS calm or
youtube.com or nasa.gov and you just
wanted to ignore everything else so
let's see how we can do this so first
let's write an expression that actually
matches these URLs so let me get rid of
the one that we currently have now first
to match this we can say all of these
start with with HTTP and then the S is
optional so we can say s and then put in
a question mark to say that we want to
match 0 or 1 for the s and then after
that optional s we want a colon forward
slash forward slash so at this point
some of these domains have a
www.affordablecomm.com so now you can
see on all of our URLs we've matched up
to the domain name so now to complete
this I'm just going to say any word
character so backslash W and I will put
in a plus sign to say one or more of
those word characters and then we get
here to the top level domain so we want
to match a literal dot so we'll do a
back slash dot and then for the rest of
that top level domain I will just do any
word character one or more times so we
can do a word character with a plus sign
to do one or more okay so we can see
that this matches all of our URLs but
the point here was
to use our groups to capture some
information from our URLs so let's
capture the domain name and the
top-level domain which is the dot-com or
the dot gov and things like that so to
capture these sections we can just put
them in a group by surrounding them in
parentheses so what we want to group
here is our domain name and the domain
name is this part right here this string
of one or more word characters so I'm
just going to wrap those in parentheses
and create a group and we've seen that
before and now we also want to put the
top-level domain and a group as well
that is the dot-com or the dot gov so we
can put a parentheses around that dot
and then also around the ending there
that is the string of one or more or
characters okay so we can see that we're
still matching all of our URLs here but
now we have three different groups so
our first group is just that optional
wwr second group is the word characters
that make up our domain name and the
third group is that top-level domain now
there's also an implicit group 0 and
group 0 is everything that we captured
so in this case it's the entire URL so
now let's get to the cool part about
this so let me show you what we can do
now that we've captured these so we can
use something called a back reference to
reference our captured group so for
example here an atom we have the ability
to replace our matches we can see down
here that we can replace so let's
replace all of our matches with just the
literal text group 1 and then a colon
and then a dollar sign 1 now this dollar
sign 1 is a reference to our first group
now sometimes this is a back slash but
for some reason and atom they use a
dollar sign so if I do a replace all
here then we can see that it replaced
our matches with this literal text group
1 but then it also replaced the dollar
sign 1 with our first captured group and
the first capture group is that optional
wwww we can see that it shows up
and for ones that didn't it doesn't have
anything so let me undo this and now
let's replace our matches with the
second group and now the second group
should be the domain name so now if I do
a replace all now then we can see that
now it says group two is Google Corps
EMS YouTube and NASA and if I undo that
and replace this with the group three
then the group three should give us our
top-level domain so our group 3 is the
dot-com comm gov things like that so let
me undo this one more time
so now that we know how to use those
back references then we can actually
take our regular URLs and clean them up
like we meant to from before so we could
convert these to a cleaned up version
without the HTTP or the WW just by
replacing our matches with the domain
name which is group 2 followed by the
top-level domain which is group 3 so now
if I replace all of our selections with
those two then we can see that replaced
all of our URLs with just the domain
name and the top-level domain so you can
imagine if you had a lot of information
like this that you needed to clean up or
modify in some way then knowing how to
match these groups with regular
expressions could save you a ton of time
with doing things like this ok so I
think that's gonna do it for this video
now there's a lot of advanced features
that we could go over with regular
expressions as well so if anyone is
interested in learning more then I could
put together an advanced video covering
those topics in the near future but
hopefully now you feel comfortable with
being able to read and write these
regular expressions that we went over in
this video but if anyone does have any
questions about what we covered in this
video then feel free to ask in the
comment section below and I'll do my
best to answer those and if you enjoy
these tutorials and would like to
support them then there are several ways
you can do that the easiest ways to
simply like the video and give it a
thumbs up and also it's a huge help to
share these videos with anyone who you
think would find them useful and if you
have the means you can contribute
through patreon and there's a link to
that page in the description section
below be sure to subscribe for future
videos and thank you all for watching
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>