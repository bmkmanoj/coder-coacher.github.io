<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>0-1 Knapsack Problem (Dynamic Programming) | Coder Coacher - Coaching Coders</title><meta content="0-1 Knapsack Problem (Dynamic Programming) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/CS-Dojo/">CS Dojo</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>0-1 Knapsack Problem (Dynamic Programming)</b></h2><h5 class="post__date">2016-03-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/xOlhR_2QCXY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hey guys here's my dynamic programming
tutorial with the zero-one knapsack
problem as our example let me explain
what the knapsack problem is first we
have a certain number of items let's say
we have n items or five in this case
five items and each item has an
Associated weight and value with it so
the first item weighs one kilogram and
is five dollars and the second item
weighs two kilograms and it's worth
three dollars and the problem is we're
trying to decide which items to put in
our knapsack which can only carry a
certain amount of weight let's say 10
kilograms we can only carry 10 kilograms
and we're trying to maximize the total
amount the total amount of value that we
carry with those items so for each item
we're going to decide do we put it in
the knapsack or outside the knapsack so
let's just say yes or no or we could
write it as one if it's in knapsack or
no if it's not in the knapsack in our
first class it looks very hard because
if we make this decision for every item
the total number of solutions the total
number of potential solutions is going
to be two to the power of n or two to
the power of five in this case but
actually we can do much better than that
with dynamic programming and you see how
you can do it in a second here is a
common procedure in dynamic programming
we first come up with a recursive
solution and then we memorize or store
some of the intermediate results to make
it run faster the third optional step is
coming up with a bottom-up approach but
I'm not going to do that just for
simplicity sake for this particular case
so here's our naive recursive solution
the idea is we're going to start with
the last item and we're going to move
down the list and we ask ourselves for
where the pointer is are we going to put
this item in the knapsack or not so for
the first element of course that's yes
or no and we'll also keep
track of how many items we have left to
consider or you can see as the position
of the pointer as well so it starts with
five and will keep track of the amount
of capacity we have left that starts
with ten in our example 10 kilo grams
and the value we have so far that starts
with zero and if you said no for the
first item or the last item this item
then n becomes four we're essentially
moving this pointer to the left so that
becomes four and see capacity doesn't
change so that's ten and the value
doesn't change so that's still zero and
if we said yes and becomes 4 which we
have four items left to consider the
capacity becomes ten minus five equals
five we can still carry five kilograms
and the value becomes zero plus two
equals two and for each decision we ask
ourselves for the fourth item are we
going to put this in the knapsack or not
so that's yes or no again so we keep
repeating this process until we get to
the last item this one so that's the
idea behind our recursive solution but
it works slightly differently in the
code so let's see how that works so
here's how our recursive solution works
in our code we define this function KS
knapsack that takes two variables the
first variable is the position of the
pointer that we're looking at or the
number of items we have left to consider
and the second variable is the amount of
capacity we have left so the first call
for this example is going to be cash of
five because we have five items left to
consider and ten because we have 10
kilograms in our capacity and here's our
base case if n equals zero the
means we have no items left to consider
and if C equals zero we don't have any
capacity so we just return zero and from
this function we're returning the
optimal value that we can achieve with
this pair of variables instead of the
list of items itself so if you want to
do that you'll need to change the code a
little bit now if the current items
weight is larger than our current
capacity then we can't put it there so
we just move the pointer to the left and
we call this function again and if
that's not the case
we'll try both put in the item in the
knapsack and not putting it there so if
we don't put the item in the knapsack
then we just call the same function with
the same variables again with the
pointer moved to the left and if we put
it there
we'll count in the current items value
and we'll add it to this recursive call
where the pointer is moved to the left
and the capacity left is reduced by the
current items weight and we'll just take
the maximum one of those to get the
optimal value by the way our values are
stored in this array that starts with a
dummy variable and our actual values so
that's 5 3 5 3 2 and the reason is
because when we have say the second
element we can just call V of 2 and we
get the right element the right value
and it's the same thing with the weights
so it also starts with a dummy variable
and then actual weights so this is how
our solution works but it's very very
slow and let's see why that is if you
think about the worst case scenario we
try for the last settlement
we try yes or no and then for the second
last element we'll try put in that item
in there and not putting in there and so
on so we are basically trying every
possible case so the time
Aleksey for this algorithm will be
exponential which is very bad
dynamic programming says we can do
better than that by memorizing or
storing some intermediate results or by
noticing that there are some duplicates
in our computation so here's how we can
do it we have here a function that's
almost exactly the same as what we had
earlier except for these three lines and
the first thing to notice here with the
previous function we had is that there
are only n times C possible variable
pairs that we could have so in the
example we had earlier this would be
just 10 times 5 times 10 which is 50
possible variable pairs and what we are
doing here is we are storing the results
of this function in a two-dimensional
array with the height N and with C and
we initialize it to undefined the
outside function and then when we call
this function if the result is already
stored for that particular variable pair
then we just return that instead of
going through the whole thing and if
that's not the case we'll go through the
whole thing and before we return the
result will store it in the array so we
can reuse it later so what's the runtime
for this function the first thing to
notice to find that is that we reach
this line only at most n times C times
so we go through this whole thing at
most n times C times and every time we
go through this function the maximum
number of recursive calls we make is
just twice in this case this one on this
one so the maximum number of times we
call this function itself is about two
times and C or just an order of n C and
the time it takes to execute each car or
time per call is just a constant time
so that total amount of time it takes to
execute this whole thing is just an
order of NC which is much much better
than the exponential time complexity we
had earlier alright hopefully you liked
the video you might also like my other
video about dynamic programming with
maximum subsequence as our example and
if you want to watch more videos like
this one you can subscribe right here
and see you soon</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>