<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Indian Elections 2014 - IPython Notebook Tutorial (Exercise) | Coder Coacher - Coaching Coders</title><meta content="Indian Elections 2014 - IPython Notebook Tutorial (Exercise) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Roshan/">Roshan</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Indian Elections 2014 - IPython Notebook Tutorial (Exercise)</b></h2><h5 class="post__date">2014-09-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/NM-cjUCEMFA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone and welcome to the series
about ipython notebook this is the last
part and it's an exercise where we will
be analyzing real-world data we will be
analyzing the Indian elections of 2014
which is the endian general elections we
will start with the results but let's
take a look at the map first we have the
general elections of 2014 constituting
the 16th Lok Sabha or the house of
people we have 35 states with 543
parliamentary constituency the elections
were held from the 7th of April until
12th of May 2014
if we look at the results of seats per
party we have the BJP winning 51.9 of
the seats a solid majority we have a nc
with the eight point one percent of the
seats I understand these are the big two
parties of Indian politics and we have
overall 36 parties sharing the Lok Sabha
and here we have the results of votes
per party BJP get thirty four point nine
percent of the votes and I&amp;amp;C get twenty
one point eight how did BJP get 51 point
more than 51% of the seats and how did I
see ended up with only eight percent of
the seats with 21 percent of the votes
that's what we will understand and this
lecture this is a chart with the total
votes and on a log scale so this is 1
million this is 10 million and this is
hundred millions and here we have the
number of seats it's also a log scale so
this is one
and this is 10 and this is 100 seats so
we can see BJP with 2a 2 seats we have
I&amp;amp;C with 44 well we have SDF with the
least amount of votes with a single seat
and we have the CPI with the maximum
amounts of votes winning only one seat
so that's all dependent on which state
they're working on and their strategy
and that's what we will be mainly
analyzing the data source that I used in
here I used ECI which is the Election
Commission of India first we'll start by
loading and loading the data using
pandas so I'm importing pandas as PD
then I'm importing division from
underscore underscore future underscore
underscore what does what this does is
it makes flawed division the default not
integer division by default in Python in
Python 2 integer division is the default
if you divide two integers so 4 divided
by 2 is 2 3 divided by 2 is 1 which is
not read correct
float division 4.0 so if you have one of
the sides or both floats it will do a
float division so 4.0 divided by 2.0
equals 2.0 3.0 divided by 2.0 equals 1.5
this line makes float division the
default so after we import the vision
from future 4.2 equals 2.0 and three
divided by two equals one point five if
we want to force integer divisions we
can use double forward slash to do
so four divided divided by two equals
2/3 divided divided by 2 equals 1 after
we import division from future so we
will load this data this data is
available open source on github you can
download it and replicate the results
that we are getting in here this a comma
separated value file is loaded into a
data frame using grid CSV function from
pandas the first column is the index and
here we have state we have PC as
parliamentary constituency we have male
electors and male voters and we have
female electors and female voters and we
have total electors and total waters and
this is for all 543 parliamentary
constituencies that we have so we have
all of them in this data frame this is
the map so it can reference any
parliamentary constituency we want to
visualize on the map and this is a map
with the states of India I left those
here so you can use them as a reference
whenever you're working with this data
so we will like we will start by
calculating the turnout so me creating a
new column in here called male turnout
which is male voters divided by male
electors so the male voters who actually
voted divided by all the male electors
then I'm calculating female turnout and
total turnout in the same way so let's
execute that and let's get a quick
statistical analysis of this just to see
if it makes any sense
we have 543 parliamentary constituencies
the average male electors is eight
hundred and four thousand the minimum is
twenty five thousand male electors and
the maximum is 1.7 million male voters a
male elector sorry voters this is the
mean minimum and maximum female let's
take a look at turnout in here we have
male turnout in average they showed up
68% of electors of male electors 666
percent of female electors an average
showed up and in average 67 percent of
people showed up so quick facts a total
electors we have eight hundred and
thirty four million electors this is by
far the largest elections in history
gender ratio so we have 90% of all
electors are male we have total votes
535 million votes and total turnout of
sixty six point four percent so let's
analyze the States so in here getting
comma separated value data of state and
then I'm getting unique so it will
return only unique States so I get this
list with 35 States
and I'm storing this in a new data frame
called States
so we'll start doing some things I'm
using here function of called value
counts this will count how many times
the same value appeared in a series so
in here I'm counting each state how many
times did show up so counting how many
parliamentary constituencies in each
state and I'm storing this data and
series called seeds then sorting it to
get a an alphabetical sorted list and
storing it and seeds instead and the
data frame seats States sorry then
displaying it by sorting guess it's in a
descending order so we have the biggest
state of Uttar Pradesh with the 80 seats
and we have the smallest states with
single seats with with the single seat
and House of people we're calculating
total state electors and votes so I'm
using a function called pivot table and
this summarizes my table and any way I
want so in here counting electors per
state so my rows are states I'm passing
sorry the complete data I'm telling it
values or the total electors and the
rows or what I want to summarize by is
the states are grouped by the states
then the aggregate function is some so
get the sum of all total
electors I'm doing the same thing with
votes so I'm getting the only thing I'm
changing in here is total votes instead
of total electors
I'm using the same function of pivot
table venoms
storing the results in the same data
frame states and two new columns total
electors and total votes then I'm
sorting it by total electors so we can
see the state with the maximum number of
electors as Uttar Pradesh with 138
million electors and 18 1 million voters
and the smallest state is lakshadweep
I'm sure I've tortured this name with
the 49,000 electors and 43 thousand
voters who actually showed up I will be
calculating the state turnout so I'm
calculating a new column turnout and
states data frame by dividing the total
voters divided by total directors then
I'm sorting it by turnout so we can see
that in city of delhi get the highest
turnout with the 87% then the least
turnout was in Jammu and Kashmir with 49
percent turnout here I'm calculating the
electors per seat so we can say we can
see that in here and we have and here
the highest electors per seat in
Nagaland with with
one second yeah with 1.8 million
electors per seat and it goes down to
Lakshadweep with 49,000 electors per
seat and here I'll be reading the
results the results are also stored in a
tab separated value file but it has the
extension of CSV so in here I'm using
the separator I'm telling you the
separator is tab this is what we got we
got name of state parliamentary
constituency candidate name total votes
polled winner or not this is yes or no
party abbreviation and party name and we
can see for each parliamentary
constituency it's listing all the people
who who competed for who competed for
one of the seats basically and we have
this data we can tell that eight
thousand seven hundred ninety four
results are in this table so let's start
by analyzing the results let me change
this into something pretty so analyzing
the results I'm starting by getting all
the winners in a separate data frame
called winners to do that and filtering
my results data data frame with this
rule so this is the rule I'm using where
results of winner or not equals equals
yes so it's getting only people who has
yes in there winner or not column
and filtering only them then I'm sorting
by the state /ut so I'm sorting by the
state name so they will match my other
data frame so I can store the move the
data there later so I'll be loading this
results into my original CSV data that
the frame I'm storing a candidate name
from winners I'm storing party
abbreviation from also from winners
party variations starring party name
total votes polled all in CSV data and
now let me make this shorter so that's
easier to deal with and now I can see
that I have one two three four new
columns in here candidate name
abbreviation party a variation party
name and total votes for each
parliamentary constituency I'll be
calculating the winning margin so the
winning margin is the total votes polled
for the winning further winning
candidate divided by total votes and I'm
sorting them with the winning percentage
a descending way let me make this
shorter so it's easier to deal with
so I have the winner percentage and in
here the highest winning percentage was
75% and the guy who got that was from
the BJP party followed by 72% for Modi
this is he got three D good winning
margin and it goes down there are way
too many records to standardize them
this way so we'll be looking at more
statistics later but the lowest we have
in here was 56% we'll see that this is
not the whole story because we have only
two two eight nine rows in here and the
complete data frame has five five four
three rows so let's do some analysis of
winners or by party so I'm returning
party abbreviation and using value count
to count how many how many times that
each party abbreviation showed up in the
in our data set and hours and our
winners that is it actually then I'm
naming this column seats and I'm also
calculating how many what's the
percentage of seats that this party got
and returning the data set so I have in
here
BJP with the 282 seats 51 percent then I
see with 44 seats 8 percent and the rest
goes on on and tell the lowest parties
with one seat we have
all votes and all votes average and here
I'm using the same function of pivot
table to summarize and using party
abbreviation as our rows or it will
group the results by party abbreviation
for the first one I'm using aggregate
function equals sum so it will sum all
the votes some all total votes polled
which is how many votes did the winning
party you got and in here I'm using mean
this is this will return the average of
total votes apple I'm storing these
results and two variables all votes and
all votes average and here I'm using
tool and functions to basically return
the values of these based on the party
abbreviation so if I pass any party
abbreviation it will return I get total
votes to return total votes get average
votes that will return average votes and
I'm passing our index which is the party
a variation to this function using apply
on the series and storing it in our
results data frame and this how it looks
now so I have seeds
BJP seeds seeds percentage then I have
total votes and average votes I can tell
now that BJP got seven 171 171 million
votes with a average of forty one
thousand four four hundred and one
thousand votes in each parliamentary
Constitution constituency and then we
have a and C with 106 million votes with
an average
230 votes per parliamentary constituency
so we can see we can start to see what
happened here their votes were mostly
spread between parliamentary
constituencies BJP had a clear a more
clear strategy by concentrating on their
winning parliamentary constituencies
will be looking more at that later so
I'll be calculating votes that resulted
in winning seats using pivot table and
using the same way with lambda functions
to calculate total winning votes so how
many volts resulted in in a in a winning
seat average winning votes and then I
have average winning percentage so
what's the percentage that they want
with and I have finally the average
winning electors of that vote that I
don't think I'm using but anyway then
I'm calculating losing votes so how many
votes they got that did not result in a
winning seat and then I'm dividing
winning votes by total votes to get
their ratio so let's take a look at this
we have BJP let's take a look at our new
columns in here we have total winning
votes we have total winning average
winning votes then we have average
winning a percentage they're winning
usually an average by 49 percent average
winning electors losing votes the 303
321 no sorry yeah 31 million vote
did not result in winning seeds so
that's 81 percent of their votes
resulted in a winning seat if you look
at NC in here they're losing vote is 88
million so only 17% of their votes
resulted in a winning seat and you can
see why the strategy was different but
between BJP and I see I'm not talking
about political agendas or anything in
here I'm just talking about statistical
results so I'm not endorsing or I really
don't don't know these parties although
I watched all kinds of debates but the
issues were too deep for me to
understand for the scope of this thing
anyway I'm result I'm describing this
the data frame using describe to return
some statistical analysis we can say see
in here that winning votes ratio some
parties they all their votes resulted in
a winning ratio so 100% and minimum was
8% some parties with only 8% of their
votes going to a winning Gasset and 92
percent of their votes went to we two
seats that they did not when I will be
visualizing this results are these
results so first of all I'm plotting a
pie chart in here
my the number of seats is my value
labels are the index which are the
party abbreviations I'm using explode to
to make this effect you have to make
this effect and using a mathematical
equation in here to keep pushing
exploding each one further and further
away from the center we can't see BJ BJ
PE got 51.9 IC at eight point one of the
seats I'm doing the same thing in here
for the total votes so we can see BJP
got thirty four point nine and I think
at twenty one point eight percent of the
votes and we can see a long list of
other states and here the least state
with vol the least sorry party with the
thoughts as SDF and maximum is BJP and
here I'm using scatter to create this
chart this is a log scale and this is a
log scale this is total votes proceeds
you can see BJP up here and you can see
all the parties with one seeds with two
seats and the size of these circles is
represent how successful this strategy
was so with the least amount of votes
you get the most amount of seeds firstly
F and that wasn't the case for CPI or I
and II because JK PDP get also three
seats with not even 1 million votes with
less than 1 million votes
and ind we can tell that they got more
than ten million votes in here and they
also got three seats and you can do the
same thing for four and here we have
nine and we can see how does this chart
work to tell us how successful a
strategy was I will be just showing the
results data frame in here did not come
up but anyway this tutorial is available
open source on github and it's viewable
on MB viewer you can use this for any
purpose you want it's open source and
licensed for any usage that you for any
purpose that you want to use it for the
one more thing if you go back to the top
in mb viewer and click on ipython
tutorial you will get all other
tutorials in the series starting with
the notebooks and sales market analytics
basic Python numpy plotting charts
ipython widgets pandas sin pi and you
can't open any of them and see the
notebook inside it so you can bookmark
this and use it later as a reference you
can go to github to get the original
data files and these are the two csv
files that we used in this exercise
thank you for watching and I hope if you
like this you'll subscribe to this
channel and you might want to watch the
ipython notebook series if you did not
see any of it this is the last part of
it so you can go through the series to
understand some of the functions that we
used and some of the libraries that we
used and if you're interested in machine
learning we
have another series in here click in
here to watch a series starting with the
setting up your environment on Amazon
Web Services clustering classification
regression all in there thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>