<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>#12 Introduction To Mutations - Full-stack GraphQL with Apollo, Meteor &amp; React | Coder Coacher - Coaching Coders</title><meta content="#12 Introduction To Mutations - Full-stack GraphQL with Apollo, Meteor &amp; React - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/LevelUpTuts/">LevelUpTuts</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>#12 Introduction To Mutations - Full-stack GraphQL with Apollo, Meteor &amp; React</b></h2><h5 class="post__date">2018-01-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/f3VfLVOc72M" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so in the last video we actually
got this going where our resolutions are
coming straight out of our database
which is awesome but would be more
awesome is when we're actually getting
to interact with our app in a little bit
more of a real way submitting a form and
stuff like that so in this video we're
gonna be doing is writing what's called
mutations and well we're just gonna be
writing a single mutation but what a
mutation is is basically you can think
of it as the way which you modify your
data through graph QL I mean we have our
query which is returning data it's
grabbing data and returning it and then
we also have what's called a mutation
which is going to change or insert or
any of that stuff for our data now we
define a mutation very similarly to how
we do a query with a simple object
inside of our resolvers named mutation
now I keep my mutations in a separate
file and do a merge to get them all
together but that creates a little bit
of a headache some time and since we're
only going to have a couple queries and
mutations here combining them isn't a
huge deal at this point so we can say
mutation with a capital M mutation and
this is defined just like query now just
like queries we're going to have a name
for our mutation which is simply just
going to be a method here instead of
this object
so we could call this create resolution
okay because that makes sense you know
create update delete that sort of stuff
so we're going to create a resolution
now right now create resolution is
simply going to remain an empty empty
function definition here our reason
being is we're going to get into a
little bit of what comes through the
line here when we talk about mutations
and next thing we want to do inside of
here is realize that our mutation is
going to need to do
insert okay so I'm gonna paste in this
insert here resolutions dot insert now
one of the things that dot insert does
within MongoDB is it returns the ID of
the item you're inserting so we can say
Const resolution ID is equal to
resolutions dot insert now I'm going to
sort of leave this as is for right now
okay because what we're gonna be doing
is well writing our form then we're
going to be actually I take that back
I'm going to comment out this right now
because if I hit this mutation I don't
want it to insert test res again I'm
going to leave this comma down but what
we're gonna be doing is writing our form
and then we're going to add the mutation
to our app and then we're gonna check to
see what sort of data is coming in
through the mutation when we actually
mutate okay so we've created our
mutation create resolution and again
it's simply going to eventually just
insert something into our database now
you may be seen this already once with
query so you should know we should be
getting an error on our item here where
mutation is defined in resolvers but not
in schema okay what does that mean well
just like anything in graph QL you have
to define everything within your schema
you remember we defined our type of
resolutions here and inside of our
register API file we defined a type of
query so what this is saying is it's
saying hey we ran into a new type which
is mutation but we don't know how to
handle mutation so again let's go ahead
now this time I'm going to do it inside
of our resolutions graph QL file and I'm
going to say type mutation and type
mutation is going to be equal to well
what mutations we actually have we've
only defined one mutation which is
create resolution
so let's copy create resolution paste it
in here now create resolution is not
accepting any sort of arguments at the
moment so we're just going to have a
standard little colon here and then
we're going to say what it needs to
return now many times the mutation just
simply returns an object full of the new
updated data so what we want to say is
hey this is going to return a resolution
okay
right now obviously the mutations are
not returning anything we're gonna make
that happen in a second but so we've now
defined in our schema a new type
mutation named create resolution and
it's going to return a resolution now we
should no longer be getting that error
however if you can see that I am still
having this error and this to me is I
think it's an actual bug with how meteor
is accepting these graph QL files right
now and you may not be having this issue
you may be having it and you can see we
can't really get past this well it's
happening is I'm pretty sure the build
system isn't recognizing a change inside
of these graph QL files so if you have a
register API file where your schemas are
being merged into what I found is if I
just make a comment and save this this
all the sudden is going to recognize a
change in our graph QL file and you can
see our server's restarted this is not a
great work around here but it works so
if you're wondering why some of your
changes within your graph QL file have
not made itself obvious then that try
that try the modifying the file at which
they're imported in who knows that might
even be fixed by the time you're
watching this so not a huge deal if it's
not having a problem for you as you can
see I just leave this comment high here
for now
okay so to go over it again
we created a new object a new type
called a mutation and we have an actual
function here and we've now defined
mutation in our schema which means we
should be ready to go using mutation
on the client side which is simply just
create resolution so in the past we had
our app which had our query and we
connected it with graph QL now I'm going
to go ahead and actually create a new
form here I'm going to have a well I'm
sorry let's head to our folders here and
in the client side I'm going to create a
new file under ui new file under UI and
it's going to be resolution form dot J S
and we're going to import react from
react actually let's copy some of these
imports I'm tired of writing them and
we're also going to copy gray G QL and
graph QL react Apollo ok let's create a
new component we're going to export
default class and we're going to call
this resolution form extends component
let's import component as well from
reactor sorry before I do that component
okay
export default of resolution form
extends component we're going to have a
render function we're going to return
and right now let's just have an input
in here okay let's import this
resolution form in our app sorry if I'm
going fast here this is just some react
stuff we're gonna import resolution form
from dot forward slash resolution form
and we're then going to just throw this
into our app ok you might be wondering
why I imported graph QL and all that
stuff into this file well we're actually
gonna be using graph QL to write our
mutation in here so just to reiterate we
imported resolution form from resolution
form it's simply just output here
nothing fancy nothing going into it
resolution form itself is simply just a
div with an input and if we check our
app hopefully we're not seeing any sort
of errors
and we're just seeing an input okay I'm
gonna give this input a ref and the ref
is going to say here we have a function
okay and this dot name is going to be
equal to the input okay so this is a
standard ref syntax for sort of how you
work with refs modern and modern jazz
times I guess or modern react times now
we're no longer having string refs so
we're going to say hey the function is
taking the input from this input field
and then mapping it to this name okay if
you haven't seen this before now let's
also have a button and we're just gonna
say submit and I could wrap this whole
thing in a form - but there's just one
input here and we already assign the
value to a ref so this submit button
yeah this works for me for now I don't
need to get too crazy with this we
simply just have an input field and a
submit now what we want to do is connect
graph QL to our form now you've written
probably a lot of unclick things so
we're going to say submit form and it's
going to be equal to a errol function
like this and the submit form is going
to be called on click of submit so we
can do on click equals this dot submit
form now inside of submit form we're
just going to Council log this dot name
dot value okay let's go ahead and make
sure this works this done name that
value is going to get you the value from
the input okay
so let's head to our app let's say hi
whole bunch of times
click Submit and you should see inside
your console council whatever you want
to call it we have our high being output
I'm sorry if I'm going over fast some of
this stuff this is kind of react stuff
that I'm hoping you know at this point
we have simply a method inside of our
react component and we're somatic form
data with a button because what I really
want to get to is the juicy graph QL
stuff which is going to happen right now
what we're going to do is define a new
mutation and to do that we're going to
do so with the graph QL query language
so we're going to say Const create
resolution is going to be equal to a gql
and then backticks
now again these are just strings but
what we're going to have is a new then
keep in mind lower case mutation
now the mutation is going to take place
is going to also need a name you're
gonna get a little tired from naming
stuff here we're gonna say hey create
resolution is the name of this okay now
we also need to then actually call the
mutation keep in mind these are all just
names this create resolution is the name
of this string query this create
resolution is just the name of the
mutation inside of here is actually
going to be what doing and what are we
doing
well we're create resolution
so we're going to once again say create
resolution this seems a little verbose
but it's the way it is and inside of
here this is going to be what we need to
return from this we can just return the
ID if you'd like it doesn't really
matter at this point
because we're not going to be using the
information that returns from this query
so we're exporting a default resolution
form let's actually change how we're
doing this a little bit to actually
respond to our query we're going to not
export default down here but we're going
to come all the way down here and say
export default and you remember before
we had to use graph QL sorry all
lowercase and then we had the name of
our export right down here resolution
form so what happens in into this now
what happens in here because when we add
our query we simply just need to pass in
the name of the query and that's
actually really just what we need to do
we want to pass this in as create
resolution so if I pass this in like
this let's actually check out our react
dev tools and see what's happening
inside of here well it's going to be
happening as the mutation right the
mutation that we've defined up here is
now going to be available to us inside
of resolution form and we're gonna want
to use that inside of our submit and
instead of having to hit an API and do
all of that stuff well it's sending the
data via mutation so let's check it out
here I'm going to do some react dev
tools and I'm going to look at our form
here so let's do resolution form and
let's check out the props that now exist
in here the props that now exists is the
mutate object and well there's not a
whole lot inside of our mutate we see we
has a prototype we have the name bound
and stuff like this
sure but mutate isn't exactly great
because well don't you want to call this
thing by what it is which is why we
named it in the first place which is
create resolution not mutate so to
change that we can actually pass some
options into our graph QL and we can say
comma and then we can have brackets and
we can give this mutation a name and
this name is going to be a string that
actually gets passed into react as props
okay so create resolution by having an
object as the second parameter here of
graph QL with the name of create
resolution this is now going to give us
access to if we look for our form a new
prop named create resolution rather than
mutate because mutate adds fine but
great resolution says what it does okay
so now inside of this form you'll
remember we had this dot props dot
create resolution let's go ahead and
just simply run this phone
and you might be expecting something
interesting to happen you might not be
actually let's go ahead and in in our
resolvers actually inside of our
resolvers under our create resolution
mutation let's go ahead and just log you
know got got here okay so that way we
know when we hit this function what's
going to be happening is it's going to
actually be running our mutation on the
server so let's head back to our app i'm
going to submit and check out my council
which is apparently okay let's go ahead
and submit you can see nothing happening
here but let's check our server and we
should see that it got here both times
okay so this has been pretty long-winded
so I'm actually gonna split this up into
two videos but let's talk a little bit
about what we did here we created a new
type which is a mutation we created our
mutation which is some code that's going
to be essentially our API endpoint this
thing that's hitting on the server to
modify our data we also defined what a
mutation was inside of our schema and
defined a new mutation inside of that
named create resolution that's going to
return a resolution we created a
resolution form which acts like any
other react component the only
difference is we wrote a query we named
that query query resolution we named
that mutation create resolution and then
we said hey use the create resolution
mutation to return an ID we passed that
in to react using the graph QL
higher-order component and gave it a
name so we didn't have to use this type
props mutate next inside of our
component we called it just as a normal
function what's cool again is that we
didn't hit an API we didn't hit an
action or anything like that we called a
function from props and this actually
hit our server so it sounds like a whole
lot of stuff and I would go into the
database stuff but well one thing we
don't have solved yet is how are we
getting this town named add value in to
create resolutions into our server so in
the next video we're going to be doing
is actually passing
in data from the input we're gonna send
that data all the way to the server
we're gonna get that logging out on the
server and then we're going to insert it
into our database and this thing is
going to be working essentially as a
basic list creation without delete or
update at this point but you should
definitely see how things are working
right now whether we are using queries
to get data or queries to mutate data
it's all sort of the same which is one
of the greatest things about graph QL so
as always this is Scott with level up
tutorials if you have any questions or
comments leave a comment the video if
you would like to see more free videos
head on over to level up tutorials comm
and become a LevelUp pro and help
support this channel because I can't
create this content without the help of
all of my awesome subscribers so thank
you so much for watching and I'll see
you in the next one</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>