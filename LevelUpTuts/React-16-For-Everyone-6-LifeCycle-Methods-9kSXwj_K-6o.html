<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>React 16 For Everyone #6 - LifeCycle Methods | Coder Coacher - Coaching Coders</title><meta content="React 16 For Everyone #6 - LifeCycle Methods - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/LevelUpTuts/">LevelUpTuts</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>React 16 For Everyone #6 - LifeCycle Methods</b></h2><h5 class="post__date">2017-10-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9kSXwj_K-6o" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hey what's up this is Scott with us love
tutorials and in this video we're gonna
be covering the life cycle methods in
free AK now these again are gonna be
things you're going to be using all the
time and they're definite foundational
skills that you need to have before
being able to work on more and more
complex things and they're gonna come in
handy a little bit later once we hit our
API and bring in some data so let's get
going on that right now okay so in this
video we're gonna be talking about
another basic component of well
component and that is the life cycle
methods so in a components life cycle as
in the life of a component it goes
through a whole bunch of different
phases and many of these phases trigger
events events that you can tap into and
will tap into so things like for
instance when the component is first
created the constructor is called so up
top above here we would define something
called our constructor we could say cun
struktur and this would have two
parentheses and this would have some
brackets and then we have two because
this is a class syntax thing not a react
thing we have to have a super like this
and if we were to want to use props
within the constructor
well they're not available as this dot
props yet because technically this
doesn't exist in the same capacity yet
so you need to pass in props like this
and at this point you could log or
Council log out your props right or you
could do anything you'd want with them
and this is something that's called like
right as the component is creating
itself okay next we have a life cycle
method that is not JavaScript based but
more react specific this doesn't exist
in normal classes or something like that
and this is component will mount now
component will mount is fired before the
component renders it goes
first the constructor then the component
is going to will mount right it's about
to mount so you can do anything you'd
want just before the component mounts
and here you actually have access to
this at this point because this has been
created so you could get access to the
stat props here and we let's actually go
ahead let's do a console log here and
just say we'll mount and then I'm going
to have another one up top here that
just says construct our okay and then so
first it's the constructor and it's the
component will mount and the next thing
that happens is the component fires off
the render function so down here it's
been going to simply render like we
mentioned this is the only one of these
things that needs to happen right so
render is part of this this lifecycle
plan right so it it constructs itself it
will mount the render process is the
mounting of the component and then if
you suspect after the component finishes
rendering something else is called where
it did mount so after it has finished
rendering we get access to component did
mount now component did mount is going
to call immediately after rendering is
finished mounted okay so let's talk
about when and why you would use each of
these so maybe you have something that
needs to happen with your props before
the whole thing has loaded and maybe you
want to do something with your props
before it even touches it then then you
do that in your constructor and well if
you're thinking about that well why
wouldn't you just use component well
mount or constructor
well according to reacts own
documentation they typically recommend
using the constructor instead of
component will mount for most situations
however you can use this to set your
state and things like that without
triggering a second render because the
render hasn't happened yet so if you
make any changes in component will mount
to your state it's not going to trigger
a second render which is often something
you
want to avoid so just like reacts
documentation states I actually don't
use component will mount very often
however there are certain instances
where it will become beneficial let's
actually just check out our counsel log
right now you can see that in the exact
order we described constructor will
mount and then you remember that true
came about actually from the render
function of our our components that
we're seeing true that is proof that the
render is rendered next and then mounted
ran because it is finished rendering
okay so that order is definitely seen
here of this basic council logging now
why would you use component did mount
well there's all sorts of reasons let's
say you wanted to actually do some
interacting with some stuff in your
component but that stuff needed to exist
before you interacted with it well you
would do that in component did mount
because well the components mounted and
now you can do that stuff with these
things that now exist and in addition in
later videos when we hit our API we're
actually going to be calling that fetch
statement from component did mount that
way it won't block the whole rendering
of the component while we go get the
data and obviously we're going to go
over more about that then
however component did mount is certainly
something that you'll use quite
frequently but you should keep in mind
that like I mentioned before up top here
we're component will mount any state
that you set in component will mount
won't trigger a rerender well component
did mount will trigger Ori render if you
think about it because the component has
rendered State has changed and then once
never state changes react knows to
re-render the component so therefore
will cause a second render or third or
fourth or whatever many times you're
changing the state here that said it's
not something you typically need to
worry about so as you can see we have
some basic life cycle methods here for
getting started now these aren't the
only life cycle methods that exist in
react in fact we have some others but
they become less important when we're
mounting a component initially and
sometimes these are maybe a little bit
more higher level than
what we're going to be getting into in
this series but we have something called
component will receive props and for
that reason I'm going to leave them out
of this code here but what we have is
one call two component will receive
props and this is invoked before a
mounted component receives a new prop so
if the prop is changing right before
that render happens then component will
receive props will run next we have
should component update now should
component update is not something you
should often use however in some
instances where you're actually have
more control over whether a component is
rendering or not oh this is definitely
more advanced and not something we'll be
getting into here but should component
update takes next props and next state
and allows you to compare them to the
current props in state and potentially
decide whether or not you want to update
the component at all like I said that's
definitely an advanced thing and not
something you typically need to worry
about unless you're getting into
pretty heavy performance optimization
stuff next we have component will update
which is definitely one of these that
you will use more often where it's
basically invoked anytime a component is
a bout to update in any sort of way if
the components going to re-render then
component will update is run we also
have component did update too and kkona
did update will invoke immediately after
an update or a rerender takes place and
some of these like I said are used more
than others component did and will
update are definitely used and then we
have component will unmount which is
something that's used basically right
before a component is essentially being
destroyed or removed from the react
hierarchy and there's a new life cycle
component called component did catch
which is for handling errors and this is
brand new to react 16 so we might be
touching on this a little bit but again
it is pretty higher level than what we
will be getting into in this course so
there you have it
mounting we have constructor component
will mount render component did mount we
have for updating component will receive
props should component update component
will update component did update and
component will unmount front mounting
and component did catch for error
caching like I said some of these are
used more than others the updating and
initial constructing component did mount
are certainly used however the main
reason to use a constructor in the past
was to set your state you would do it
with inside of state here and since
we're setting our state with state is
equal to you might see constructor not
used very much at all in fact I'm not
going to be using it in this series
really because anything that we need to
do in that regard is done within this
state initialization right here so these
are life cycle methods in react if you
can think about some other ways that you
could use this stuff for instance if
you're maybe using a third-party plugin
like maybe something that needs to wait
for the Dom to exist before it can
insert maybe a map or something into
that Dom element then you could wait
till component did mount and then run
that JavaScript code that will insert
that I used a lot of you're working with
API such as the Braintree API that
allows you to have hosted fields that
are secured iframe fields into your code
it waits for the dump to be loaded and
then you can run your code on the
component did mount you can also use
these to do animations if you think
about it you could have a class that's
set initially and then remove that class
upon component did mount and have a CSS
animation take place because of that now
there's libraries to help with that kind
of thing but there are certainly ways
that you can think about using these
lifecycle methods and you will use them
all the time so make sure you head to
reiax Docs and look at the lifecycle
methods and get those things memorized
because they're definitely something
that you want to spend a little bit of
time at least have inside of your brain
and know when to use them so these are
the life cycle methods in react we're
going to be using these in different
capacities over the course of these
video so have them in your mind and
sort of know when I type component did
mount that it runs after the render and
whatever make sure you study up that a
little bit and know exactly when and why
we're using these so as always this is
Scott with level up tutorials have you
have any questions come in soon to come
in this video hit me up at Twitter or
Facebook and the next part of this
series we're going to be talking about
something that is used to maybe access
values and react or basically just
interact with the Dom element in some
sort of way and it's called a ref and
refs have sort of changed over the years
how you use them so we're gonna be going
over the latest way to use refs in your
project to actually get access to the
Dom element that you can manipulate
further with JavaScript this is often
used for submitting forums and stuff
like that
so as always thanks so much for watching
and I'll see you next one</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>