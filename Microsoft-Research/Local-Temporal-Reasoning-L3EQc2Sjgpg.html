<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Local Temporal Reasoning | Coder Coacher - Coaching Coders</title><meta content="Local Temporal Reasoning - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Local Temporal Reasoning</b></h2><h5 class="post__date">2016-06-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/L3EQc2Sjgpg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
okay so it's my great pleasure to
introduce Eric koskinen who I'm sure is
known to pretty much everyone in the
room because it is PhD in Cambridge and
was working heavily with Byron so was in
the old building a lot he is now at NYU
in New York and he's going to tell us
wonderful stuff about local temporal
reasoning and he said it's only a 45
minute talk so we can ask tons of
questions so get ready sadhna Thanks
that's you always a pleasure to to give
talks for you guys so this work that
we've been doing recently is on
techniques for verifying temporal
properties of higher order programs and
just to immediately set the stage with
an example here's a simple program and
ml style syntax it has a couple of
recursive procedures there's this first
procedure called halt which takes a
single argument and then calls itself
it's kind of a funny name because even
though it's called halt that just
continues to call itself forever and it
doesn't fall and then there's a
recursive procedure called shrink which
takes a single argument f and what it
does is it applies after two unit and if
it gets back 0 then it calls halt
alternatively what it does is it calls
itself with a new partially defined
function argument which is a lambda
expression that takes the results of
applying after unit and subtract one
from that then finally there's the main
procedure which binds T to a
nondeterministic but positive integer
that's what star plus means and then
calls shrink with a lambda expression
that returns the value of T okay so a
fairly simple program now let's say
you're interested in proving this
temporal property here main X shrink
until halt
so if you've seen any temporal operators
before then some of that should be
familiar the ex parte means that first
the left thing happens and then the next
thing that happens is the right thing
and then for the you what does it mean
to say I'll tell you in a moment and
then the weather you just as a refresher
what that means is that it's left thing
happens repeatedly until it's right
things happen and moreover it's right
thing must happen at some point now it
may be a little bit of us if you've seen
temporal logic before the atomic
propositions might seem a little
different here you might be used to sort
of predicates or something along those
lines and verifying higher-order
temporal properties for programs the
atomic propositions are typically chosen
to be events so we define an alphabet of
events or go through it formally in a
moment but for practical purposes for
most examples that we'll look at here
and also in in practice it's convenient
to create an event for every procedure
and think of it as the moment that the
procedure is called it generates that
event that corresponding event so what
we'll kind of do is add a little bit of
syntax here that says the event the
argument is generated so for example the
moment halt is invoked it generates the
halt event and the moment that shrink is
invoke it generates the shrink event and
similar for main so now that we have
this notion of events we can think again
of this unit your functions here
procedures are uncoded are what concert
hall took 20 units right a halt Stoker's
would be simple are you know it would
have the kind of kind unit 2 unit to
something so I'm especially time the
elements you have to give it before the
event happens oh it has to be a full
application before the event happens
it's called barbary it's yes yeah but
even called ah yes
it's what a choice is the way ok so to
sing but there is a choice here yet ok
ok then you seeing a fixed order of
evaluation yes everyone starts an
evaluation it's all specified that you
what happens but why this couldn't wait
that's right ok nothing happens I will
get back to that in a moment thank you
that's good ok so those are that's our
notion of events and now we might wonder
ok well what does this property hold
this program well we can think about it
sort of intuitively by trying to
consider the different traces of this
program so one for example is where
let's say that T is initially bound to
the value to and so in that trace what
will happen is the main event will occur
and then the shrink event will occur
where f is is a function that returns to
and then shrink will call itself with a
function that effectively returns one
and I'll sort of continue to recur until
shrink calls itself with what is
effectively a function returning zero
and then it will call halt and if we
look at this trace we say you can say
that that satisfies main X shrink it to
a halt because there's some first main
happens and then some finite occurrences
of shrink will happen before a halt of
it yes like this one I'm just told no so
for you could also do it just have it
Beverly sub yeah that's fine we do man
hold for peking there's no there's no
reason why i had to do it this way i
just chose to ok so another trace is as
this one we're obviously t it can be
bound to something other than to let's
say one right so i think we're all
getting the picture here that if you
consider any trace that it's going to
satisfy this temporal property may next
drink until halt ok so if we want to
come up with a technique for being able
to prove that this property holds of the
program there's a number of challenges
we have to address so first of all those
issues like non determinism there's
issues like reach ability termination is
involved in the strong until operator
there is an infinite state space here
dealing with integers and functions and
of course their higher order features so
given all of that there are no existing
techniques that are able to prove that
this property holds the program there
have been a number of works in this
direction so I just want to highlight a
couple of them for example the work of
kobayashi and on in licks 2009 was able
to prove very expressive logics mute
calculus properties but they are
restricted to finite data some have
worked at higher order programs but only
safety or termination aspects of them
and then some work that barn and I did
in the past is able to prove temporal
properties but for first-order programs
so ya know integers no no data
structures obviously and what just yeah
basically I think ya should be it has
the semantics you could say to me that
this sorry the program has a semantics I
could prove semantically so one thing
you could do is effectively take the the
program and treat it as a transition
system is that what you mean and you
know give it a symmetric and then and
then sort of compare the transition
system to the temporal property and see
whether it holds is that what you're
proposing yeah that is an approach and
actually what we've chosen is to do
something that is intentionally
different from that strategy and I can
come back to why why that is okay so
well what's the key issue here well if
we have something like a function
application like here when we're playing
shrink to lambda T and we want to check
whether or no whether shrink strong
until halt happens
the problem is there's a couple things
that might happen when we look at the
reduction of e1 we don't know if it's
going to terminate or diverge same thing
for the reduction of e2 and then of
course there's also what happens when
you apply the reduced one to the reduced
eat ooh so again we don't know the whole
thing in egv diverge doesn't yes if I
shrink until vote if which damages if
either of them by abilities then they
need to be that term it depends on what
events are generated yeah well it
depends on what events are generated
it's it's okay for the the program to
diverge as it diverges however soils
I'll say a show in a moment it's
impossible for the the program to
diverge without generating events which
goes back to it was your question but
I'll come to this in a moment oh I see
so so he to evaluating e2 itself
generates that it wouldn't satisfy this
this property in other words that hope
you say exactly all of the things that
occur nothing else going to go yes
evaluate e1 to a whole lot of work we
finally got the shrimp function that
wouldn't be good enough to satisfy this
property not quite sure what you're
saying you're saying that if evaluating
e1 did a whole bunch of things but
didn't and then diverge there never was
ID applying to shrink okay well I DS the
identity function uh-huh then the event
sequence you get be something that ID
followed by shrink right that's right
yeah I'm not satisfy this book even know
you probably would need a slightly
weaker property that said like you know
ID happens and
I'm not sure does and they don't
generate events viborg I promise I
promise I'll ready to come back to that
point when I show you the semantics so
so you know it was hide your names I
mean that's right you can't hide about
sounds pretty fine grained you're going
to be but Ricky to write down the
property that you want you can't say
something like you know this program
never you know keeps this battle open
until it shuts that what you might other
properties on getting that like you've
got other temporal operators yeah I just
some chosen trip choosing to do this all
these other things might get away right
so that and I am going to come back to
this but there are other events will
happen and so I think part of this of
this area of research is to understand
how you can come up with specification
languages that that take that into
account and you know match what your
intention is and sort of oil and down to
something that accounts for all these
other events that might get generated
okay so but so the issue here is back
slide right again we don't know whether
or not e one or you two are going to
terminate diverge and moreover the
application of you want to you to
whether it's going to terminate or
diverge and so the way that we address
this problem has kind of to
decompositions to it and the first one
is is super obvious it should be no
surprise to anyone here is to divide a
program in two expressions right this is
the standard type systems approach and
think of this in terms of three separate
specifications first by one which talks
about the temporal behavior as e1 is
reduced and then Phi 2 that talks about
temporal behavior as e 2 is reduced and
then 53 that talks about the layton
behavior when e 1 is applied to e2 and
given those specifications we can say
that the overall behavior is going to be
some kind of composition of those three
those three specifications again really
taking into account here that there's a
particular evaluation
okay so that was sort of the first part
now and then and then once we do that we
can kind of fairly straightforwardly
create a type of effect system where
will say that for example for a function
application it will have some type we
found it useful to work with dependent
refinement types and a temporal effect
on the right hand side of the ampersand
now the other thing we found was that in
order to to get things to work we had to
separately track the behavior of the
finite traces of an expression from the
infinite traces of that expression so
what we had to do is rather than having
these specifications by 15 243 we had to
split them into pairs so we separately
talk about what are the finite traces of
e1 call that Phi 1 fin and the infinite
traces of e1 call that Phi 1 in so then
we end up with all these different cases
right there's the finite races and the
infinite races of e1 the finite and the
infinite of e2 and the finite are the
infinite behaviors that occur when you
apply the reduced v12 e2 so that you
could so yeah I guess for I guess the
answer would be precision so that
otherwise you may have to end up like a
over approximating and you kind of lose
a bit of the behaviors but once you when
you break it down into these different
categories then we can come up with sort
of compositions that consider all of
these different cases and I'll come back
to that in a moment but so the syntax
will use here is now a type in effect
system we're on the right hand side the
ampersand we have two components first
the finite specification the finite
component and then the infinite
component on the right hand side so all
in the subsequent slides all kind of
have this finite infinite sort of
arrangement to keep in mind so now going
back to this example here ultimately we
want to prove may next rink until halt
which is
not a super straightforward temporal
property but actually what our type of
defect system will allow you to do is to
break this proof apart and first have a
part of the proof that's concerned with
only the safety component or the safety
aspects of shrink until halt that is
what is the layton behavior that occurs
when shrink is applied whenever we take
shrink and apply it to a function what
happens and our type in FX this will
allow us to write down judgments of this
form that say that well shrink when it's
applied to a function is going to have
this behavior shrink week until halt so
week until halt is like you except that
it has no guarantee that halt will
eventually occur so it's it's but it's
perfectly acceptable as week until hall
for a shrink to happen infinitely and
never to get to that second argument so
this is really kind of more just about
these safety aspects of shrink until
Hall like what is it that what is it
that what kind of events can be
generated yeah so I'm abbreviating a bit
here with some of that yes so so also as
I drink you it is true right why do you
say W because it actually and the
derivation i'm gonna show in a moment
it's convenient to separate out sort of
the safety ish parts of it from the
liveness parts of it so we could
separately for example have a live-in
estrangement here that says that well if
you have a function that returns an
integer that is greater than zero then
shrink applied to f is going to have
this behavior in the for the infinite
traces sorry for the finite traces i'll
just say top because in this judgment we
don't know anything about what the
finite traces do but for the infinite
races will say that eventually it's
going to not call shrink it would not
generate the shrink arising generate
something other than a shrink event and
this is kind of a termination or a
liveness thing we've really sort of
boiled away a lot of the other
temporal aspects of it into a judgment
that's just about termination so now we
can do is take these two judgments the
one that has these safety bits to it and
the other part that has the termination
business to it and in the type system
combined them together to obtain the
overall temporal property or interest
improving which is the strong until
property visits arguments another
function maybe maybe maybe took hold as
its argument and he with the reason you
can say eventually not trade is because
you know you're gonna call Holt
eventually like yes assertively yeah
supposing you eventually don't call it
all eventually call one of your other
arguments which might of course turn out
to be shrink right then in order to get
this kind of property you'd have to have
in your assumptions about your argument
something about what time you get make I
should ask under this for this like this
thing further the second judgment and
unlike the liveness it sure took another
argument which wisdom which could
generate the reading should end it's in
strictly look at shrink all by itself
you can't see that the argument you
don't know whether that second argument
is going to turn out to be shook itself
or something else that's right aren't
you get a property like this that's
right so but dumb is it very effectively
unit all right yes yeah what one
functioning testified lots and lots of
types which are not covered yes yeah
enjoyment ready would have this and
another type where where they stay had
an effective something I do it so
sometimes ever feeling this in the
beginning of builders big strong and
saying that or no one can deal with LGL
but this and people can do it saves you
some people can
with termination even for this highway
programs and for infinite belly and okay
that's all fine but they actually know
and then you said ok service at your
property I appreciate on with them but
i'm not going to actually composed a
basically the compliment bachata metal
and go for fair termination probably too
simple there are some reasons
compositional and i'm not going to use
the type in effect system just say okay
it's very termination probably
introduced over again reduced previously
but now it looks like steel so you are
is interesting okay this is one part
that this essentially safety and this is
another part of probably going to go
down with a termination what's the
reason ah so the reason is and i think
my next slide will sort of give you the
answer the goal that we're trying to do
here is to be able to come up with a
technique that was composable so that
you could have separate in in different
parts of type system you can work on
different aspects of it and then combine
this information together so so freely
sorry this is very very useful
composition right yeah so the thing with
it with like the sort of fair
termination approach and and you know
there's no question as to whether
whether that ultimately is is better in
practice i'm not convinced but you do
have to do some sort of global reasoning
about the entire transition system you
have to take the whole the whole thing
and the negated otamatone and do kind of
global reasoning and in fact i think you
also with that thread you'd have to
convert your program at the cps form
first as well and and I I guess
personally is my belief that that
ultimately is not going to lead to tools
that will be as effective as to be able
to sort of separately talk about
different things you know you have like
your termination tool that is able to
prove that all these different loops
terminate and then you can just use that
kind of once and do that once and then
separately do like you know sort of
safety proofs that are more about taking
like fixed points and so forth and then
kind of combine them whereas the other
way you have to every time you make a
change to the program or you have to do
some sort
Global reasoning so I'm going to wave my
hands and say things about compositional
reasoning as the motivation there so one
thing that as we were putting this
together was a little bit surprising is
that there's like these liveness
properties that show up in the type
system and I guess I hadn't I always had
this sort of feeling that you couldn't
put lives in the types of it seems like
people are now realizing that's
perfectly fine all the big that's true
okay so there's sort of a kind of
trivial type of liveness which is to say
that they terminate they reduced to a
value but but what you can do here is
you can carry around even more elaborate
temporal specifications that have like
real rich liveness properties and it's
okay for that the type system itself
can't on its own generate that generate
non-trivial limas information at least I
don't know of any technique that's able
to do that so far but what it can do is
carry it around and you know in this
sort of in the in the effect and then
combine it with other information like
here for example when you have some
their aliveness information about the
termination of a particular loop or
eventualities and then combine it with
safety information so this is kind of a
way of taking Oracle's and combining
them together so what I haven't
mentioned really so far is where do
these pieces come from the safety
component live this component so the
safety a lot of times you can get it
directly from the type system it
effectively arises as a fixed point
solution to the typing context in the
judgments over the body of shrink so
first let's do the shrink example so
first let's assume we've already typed
halt and we know that halt when you call
it when the so it has this late in the
fact that it's just going to generate
the halt event repeatedly then if we
look at the body of shrink and it has
this if else branch right we know that
shrink is going to generate the event
shrink and then
they're a whole event is going to occur
next or a shrink event is going to occur
next and given that fact we could think
of one valve typing which is to say
either shrink or halt is going to occur
but we could come up something we could
look for a fixed point in fact to this
equation says that alpha equals shrink
and in the next step either alpha or g
halt and when we look at it for a fixed
point that one of them would be shrink
week until g halt so these kinds of
judgments can come from the type system
itself so then there's the liveness
piece well for the liveness piece what
we can do is well in this case we kind
of wanted to know what were the
conditions under which shrink terminates
when i showed that a moment ago and
actually we can if we look at this
example we know that well the conditions
are f has to be a function that will you
know it also means going to hold to an
effort turns ero so the conditions has
to be that f is a function that returns
something above zero because each time
it calls itself it'll be it'll create a
new function that returns one less than
the previous time so we can get a
judgment like this using some prior work
on higher order termination so we can
kind of use those termination provers
some higher order termination provers as
one of the sort of building blocks or
one of the sources of information into
the type system of course that's a
separate proof right that's a whole
separate iterative process so in our
type system will have an Oracle rule
which lets you take that information
from the outside and bake it into the
type system with obviously some
important conditions okay so overall
then you can take the safety components
from a type system and liveness
components from Oracle's and combine
them together into the overall property
that you're trying to prove yeah so in
particular is
the external Oracle's you end up not
doing things like okay I mean you have
you have a recursive definition of Holt
there and when you want to say incur or
have typing judgments about lightness
you're not going to make a hypotheses
about the recursive calls that I've
likeness in them and then make inductive
arguments that's right yeah you just
don't have that's the part of the type
system that doesn't get along that's
right that's absolutely right yep yep
and that's why I think it was important
for us to sort of separate out the
safety and liveness because we don't
want the type system to try and do that
these words no they don't have to so in
this case we can do is is do some
reasoning on just the shrink function
for example without taking the entire
function and or the entire program and
you can and that's why it's really
useful to do to use a dependent type
system because you could say under these
conditions if I examine this procedure
in isolation on this kind of input I can
say that it terminates yes so it's not
completely in isolation that's right now
okay so I've kind of been through the
sort of mentioned all these things but
we try to do here is designed a type of
defect system that you could instantiate
to a wide variety of specification
logics so the only real restrictions
I've used ltl as an example really i've
been using it as abbreviation for bookie
automata but the there are only a couple
conditions on the specification logic
that i'll get to in a moment and
obviously instantiation different kinds
of Oracle's and so forth the goal as I
mentioned it was a sort of this
compositional thing and not to require
it being ncps there are also some things
that we notice here that we're kind of
an interesting information interesting
things about that we could apply to
first order interprocedural programs so
i'll go through a little bit of the
formal details without without going to
deepen into them so here's what the the
language that we used which
just has a number of recursive functions
and there's an alphabet of events Sigma
here on again using this bold font to
indicate an event expressions have you
know all the sort of normal stuff that
you guys are well used to and it's been
cluding this event expression that we
saw earlier we assume there's no
connection now between functions and
debase no we assume that the program is
simply typed so that are some base types
in this case we've worked with integers
pools and unit and then there are arrow
types so what we had to do is first
write down the inductive big step
semantics for the terminating runs all
right these are these are judgments that
say 'i will reduce to a value V and when
it does it will generate a vent sequence
VAR pi + VAR pi is from sigma star so
these are only finite sequences because
obviously if E is going to terminate can
only generate finite sequences we also
had to write down Co inductive big step
semantics for the non terminating runs
and these are judgments that say that II
will just diverge and never return value
however it will generate an event an
event sequence pie when pi is from sigma
omega so then once we had that i'll just
show you a couple of the sort of fairly
obvious ones obviously there's only one
problem with the contacting semantics
with a see is that so you help
conductive semantics where you have the
then suppose you have the same
expression here in some two different
sub trees of the coen graphic trace the
same sub expression the same sub
expression for somehow because it's
duplicated by someone okay it appears in
two different steps in two different sub
trees in the in the in the infinite
irrigation
the contacts mountains haha in principle
it's possible to keep these two traces
completely different specifications well
because the conduct relation so actually
is this true or is it not true it made
methods through only for expressions
that are not kind of productive a lot of
reducing eventual the time so if you're
not mean so basically it is corriendo
strange the holding at your coherence
between the specification keep the same
self-expression it's diverging is that I
say I don't think it's a problem okay
yeah let's talk about it after okay so
here's so here's some examples from the
the inductive semantics so the event
expression obviously is going to just
generate a singleton event of that name
so the function application basically
says that well okay if you can take e
and substitute be 4x and reduces the
value V prime generating event stream
far pi then that means that this lambda
expression applied to V will reduce to V
Prime and it'll generate a step event
followed by VAR pie so a step event is a
special event that we require to be part
of your event alphabet going back to
your question and it ensures that it's
impossible for there to be any sort of
hidden computation and you know this is
also actually an issue that applies to
the first order world so imagine the
first order world you're trying to prove
this temporal property that eventually x
is less than zero for this program where
it sets x to be one it does some
increment X routine and then sets x to
be minus one so obviously we you know we
think that this property would hold
except well what if there's a case where
this increment thing actually goes off
and you know diverges and never actually
returns so those kinds of situations are
cases where the
some hidden computation and we didn't do
a proper job of capturing the semantics
of the language to make sure that we
took care of it so one thing we can say
here is that the language we've written
down we can prove that the semantics has
no infinite invisible computations which
was a concern that a couple people
raised earlier you're simply placed as
well yeah yes that would do it yeah well
let typing a role for let just does the
e1 Gettys next function can I come back
to that one I sort of the sim forward
and back well I guess I will
oops
left so what was your question so did
you see me your language allowed
recursion yosemite types oh yes it does
allow recursion so I'm going to come
back to that this is like a very slow
clicker ok so right we talked about the
infinite the hidden computation issue ok
and then so there's a you know so
similar application for the diverging
for the conductive semantics so the type
of defect system has again these finite
and infinite specifications with the two
components in the there's same base
types and then we use dependent
refinement types which you guys are
familiar with with the but the important
thing is that the late and effect is
that is one of these specifications of
temporal behaviors so then in the typing
rules where we need to be able to do is
perform some operations on these tray
sets so things like union union is not
surprising when you Union these two
pairs of specifications it basically is
just distribute the Union over pairing
to Union together the finite component
separately from the infinite components
and similar for intersection the one
that comes up more here is the
concatenation operation which basically
results so if you compact catenate to
specifications a finite infant component
for each one of them you end up with a
couple different cases well first
there's the finite component which is
going to be the finite traces of Phi 1
followed by the finite traces of Phi 2
then there's the infinite one well there
are two possibilities either it could
diverge in the Phi 1 inch piece of it or
it could do some finite thing from phi 1
fin followed by some infinite thing in
by 2 inch so when you sort of
go down into those cases that you get
the composition operator and then subset
is straightforward as well so so these
are we require that if you use any
specification language that it be closed
under these three operations so you need
to be able to say if you we need to be
able to for example compute a
composition so things like bookie
automata are are closed under these
properties this is this is this is
Theresa yes yes no because we sort of
assumed this your otherwise you or your
exes make up the X you have in your
anything that wasn't so it's a point
point well taken so first of all I feel
like the X operator often doesn't make a
lot of sense anyway and secondly I I
mean yeah one that's an interesting
point to consider you know some way of
like sort of hiding the step events in
in it but I'm assuming for now that
you've taken your specification and
you've sort of carefully made sure that
you've accommodated for step events
occurring in them and I realize that's
like an event yeah for example yeah yeah
yeah
so in order to to sort of set up the
Oracle or appropriately and prove
soundness what we had to do is write
down a semantics of type in effect which
basically is this definition here and
says that an expression E is in the
semantics of type towel and effect of
that pair and it's not surprising it's
it's basically well if you take the
finite traces of the reduction of E or
sorry yeah finite ones generating VAR
pie that bar pie is going to be in Phi
in a fin and then for the divergent
traces pie those pies that are
generating the diversion ones are going
to be in Phi in so that should be too
surprising so then we can write down
what's required to the Oracle obviously
the Oracle if it tells you there's a
judgment that E is going to have typed
ow and effect by then obviously that
expression E has to be within the
meaning of of that type in effect the
finite traces be included in the
infinite ones so we found that that
didn't work out so well and that the way
that all of these like sort of
compositions go together is by keeping
them separate and that allows us to make
those composition operations where we
take we searched a split on all the
finite infinite so yes that's for sure
yeah so if you have an infinite
specification if you look at any sort of
finite prefix of it then yeah what
actually goes wrong if you do
you've been saying work out better and
we kind of believe you its hands on your
wife well you don't get that ability to
when you compose things together to then
keep the you have to sort of an
approximate everything and so an example
where you say if you put them together
then you get the following less good
dessert yeah well maybe maybe that'd be
a good thing to put on a slide later
yeah sure yeah it'll be totally
convincing like it was the moment we
just rustic we just trust you yeah so
the kind of example that that I'd be
looking for something where your your
reasoning about some program that does
some some kind of good stuff on its
terminating runs and also some kind of
good stuff on its non terminating runs
that are require sort of separate
information and if you sort of combine
it all into one but i'll put a he'll put
a slide together they're all other
systems which was something yeah I can
oh I can put an example together right
so a couple typing rules the Oracle one
we've seen before the combined role is
really useful lets you take different
derivations and put them together
as expected some kind of a more logical
relation work then just missing our
ecological relation for well certificate
when you get good argument yeah so the
thing sort of it if this is a narrow
type but when I feat something in then I
will get the insularity partners it's in
the rise to arose finance function thing
in terms of the memories okay so right
the combined rule lets you sort of take
these two specifications and do the
intersection over them that's kind of
how we came to a conclusion of getting a
strong until earlier on there's a
subtyping rule which is fairly standard
except now there's also a sub affecting
component to it there's a construe which
is right not too surprising there's a
recursive function rule and so something
we had to be careful with in the
recursive function rule is that we
didn't make any unsound conclusions
about what the infinite races will be
once you apply your your recursive
function and so what we in order to
solve that we do this little erasure
this er which basically remove some of
the conclusions about the infinite
behaviors in the latent effects sorry
you can't make recursive functions can
have infinite traces but you can't have
specifications over them let me show the
erasure slide so if you have a in the in
the point where you have a recursive
function application you we don't know
whether it will actually what its
infinite behaviors will be so we have to
approximate and this is how we chose to
do it and
in our type system by basically to
whatever we have this these latent
behaviors and we basically just replace
them with okay anything can happen to
maintain soundness this is something
that I'd like to improve yes exactly so
in our examples it wasn't it wasn't too
bad for precisely that reason that we
then in the end use the combined rule
and if we lost information while we may
have this termination information that
we can then boil back together that's
right he was need some good problem you
need some good prep yeah you need some
well you don't yeah you don't have too
much information about you know any
information really about the infinite
traces of the recursive function
definitions from the type system so you
get that from like Oracle information
that you then bring in with a combined
rule purely within the type system and
yeah I haven't identified what those
classes are moving system use a sigma
star empty as a specification right
right yep that's true that's true but
then it becomes fair less interesting
from a temporal verification point of
view your data functions which you
expect to terminate like the minus
celebration right so you do have some of
that information on those functions yeah
that's true yeah that's an example I
guess I've been Oracle effectively yeah
okay so then the sound of theorem
basically just again it uses the
semantics of type in effect fairly
straight forward from there okay so a
couple other examples so here is an
example where we had to
and we get sort of separate out the
safety aliveness I'm just going to skip
through these pretty quickly here's an
example where we kind of it shows that
we can have one judgment about the
behavior of this Rumble function and
then reuse it since rumble is called
again but you know the sort of standard
type system stuff shouldn't be too
surprising just nice to see that it
works as well with the affective
component so here we need the
termination Oracle to show that Rumble
terminates and then could reuse it this
is a more elaborate example where it has
a nested temporal operator so G with
inside inside an F here we needed a
termination Oracle for bar we needed to
use the dependent type system to show
that bar X returns a non positive
actually we needed a non termination
Oracle to show that foo X does not
terminate and then the type of effect
system their type system could show that
foo ex has this behavior here where
again you see the sort of step events
starting to appear in the specification
and then this another example that has
some strong until operators nested
inside of a G operator and yeah thank
you be happy to take questions that
takes terms right
it's not just expressed in terms of
tricky to establish kind of inclusions
between sets of languages are right
trickier to establish sets of language
as I open you know it's like in order me
more logic or something right you know
if there's a right Oracle's with
deciding it talent between first order
for belief or are for some more sexy
logical so i might expect that this was
set up in such a way that that you
required a you know you didn't give
complete rules for establishing
endowments between properties oh yes
respect language that would be one sort
of things would be okay but it's like
it's like slightly more nasty if you
actually ship out terms and you say you
know do many completely separate
programs MC system yeah good question so
yeah they're kind of there are two
pieces there's shipping out like
entailment checks between bookie
otamatone or LTL or something like that
and then and then sort of shipping out
questions of termination for example the
question to be expressible in terms of
your languages right yes so you should
you should have turned you to something
we've done.we doesn't have any relative
the original sin tax by the time you
should attach to something clever i see
no okay right i guess i've been assuming
that it's that the termination oracle
agrees on the semantics as the type
system and actually that's a requirement
you to pre-process the question the
right I serious who you're saying boiled
down to just the smallest piece of
information list this is statement about
steps yeah that's true or two people
yeah yeah you can imagine some sort of
rule that maybe filters that out yeah
this is strictly pull my Nana call by
value right yeah yeah you haven't talked
about delays evaluation at all well I
think it's thanks for the interesting
yeah no I think should so I know you
some of you guys have a paper on
termination of Pascal I think it is
maybe Demetrius and Simon but whatever
is not a termination from it's a
education termination just a tool well
there is another example of using of
using some what of using lightness start
for termination stuff yeah the procedure
yeah and it's also using and then our
final types yes through temptation yes I
had that in common yeah it says yeah
specification is not that mean it was
nothing yeah it is he still above safe
but you kind of have that termination
expected yeah you give everything simple
time is it don't need anything more alia
on your own or was just yesterday for
the examples we had for it to be first
simple type check to happen and then to
use dependent types and the type system
was like let us proof these examples but
I don't might be helpful to use other
other type systems we tried to at least
prove the soundness irrespective of some
of that stuff but obviously there are
some of it does appear like in the sound
of this proof I mean not the details of
what the refinements are but
yeah it is yeah for sure for sure okay
that's interesting have you considered
mutating state no no not at all no</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>