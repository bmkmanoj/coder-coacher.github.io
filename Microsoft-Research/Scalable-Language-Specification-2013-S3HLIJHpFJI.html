<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Scalable Language Specification 2013 | Coder Coacher - Coaching Coders</title><meta content="Scalable Language Specification 2013 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Scalable Language Specification 2013</b></h2><h5 class="post__date">2016-08-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/S3HLIJHpFJI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
so I'm glad the Grigori gave this stop
this morning because you know he and I
and many other people some of whom are
listed here and some appear actually in
the reference great was giving giving
have been working since 2003 in what we
call the reading logic semantics project
where so they the main goal is to see
how well and how completely we can use
rewriting logic and a number of tools
formal tools for execution and model
checking and verification to define and
analyze running language definitions and
programs in those in the definitions and
so um and today I want to focus on just
one particular strain of line of work in
that which is work on definitions of
real time premier languages and the
specific issues that appear there so the
generality of course is that given a
language there is a substantial gap
between our formal semantics for the
language implementations and analysis
tools and and one of the important goals
of the retina logic semantics project is
to narrow that gap and again we go to
the part of the of the web for me this
morning spending the idea that we want
everything to be semantics based so so
that the implementations and the
analysis should directly be be based on
the semantics of the language and I will
focus on the scalability issues for
real-time priming languages and also
modern languages because we have been
giving semantics not only two primary
languages but auto suit also do software
modern languages and two hardware
definition languages so so the approach
is that you know the formal semantics of
the language is given as an executable
reread theory and then is use as the
basis for language implementations and
for purim on Alice's and as I said we
can also do the same thing for
supermodel languages and for Hardware
description languages and in particular
we also have been given semantics in
this way to a number of real-time
priming languages and also modeled
languages for embedded systems and in
general this approach has been you know
proof to be expressive you seen the mod
implementation of writing logic and also
tools bill on top of that like like the
k tool and quad efficient and scalable
but real-time languages post particular
particular challenging issues which are
the ones I will be focusing on after
giving a little bit of an overview so
just in a nutshell in just a single
slide with regret in logic is is logic
where to specify concurrent systems and
the concurrent systems are specified as
a tool in a Riblet theory a con carta
system is specify as as the model
defined by reread theory where Sigma is
a signature defining syntax and types
then e is a set of a question of Sigma
ani therefore it's just an equation of
theory and then r is so that describes
what i call the statics defines for you
what are the states of your system and
then the dynamics are described by River
rules that define local concurrent
transitions that can happen in the
system and of course the rewriting
happens modulo the questions because you
know the states are elements of this
algebraic data type defined by the
signature and the quest
mod is a rear-engine capable of
executing these specifications but also
provides formal analysis techniques with
several tools including through our
model checkers nor is just a language
executing these these specifications has
execution for we're called functional
modules which are equational theories
which are assumed to become fluent and
terminating equations e modular axioms
like acitivity commutativity identity
and so on so the reading up is modular
these axioms and then reread theories
add a visual component which are the
river rules that describe the local
transitions and under you know certain
simple executable conditions like
confluence a termination for the
equations and what is called coherence
between the rules and equations which is
a commutativity property then all these
things can be efficiently and completely
executed completely this is that the
execution is complete covers all the
behaviors and then there there's a whole
formal environment with several model
checkers including a linear temporal
logic model checker several tools to
analyze confluence termination coherence
energy theorem prover a tool to exactly
prove invariants and so on in which you
can reason about these specifications
and then so given a language L the in
semantics is a is a reader theory so
where the syntax and also the state you
know components of your configuration as
are the finals and algebraic data type
then the deterministic features are
defined by equation so you have a
language of these sequential then you
probably can do everything just with the
questions because there is a
deterministic thing so either the
perimeter manase with a value or loops
forever but for concurrent features then
reread rules are the thing to do because
you know the support currency and can be
highly non deterministic and then both
more than the formal analysis tools can
be used to define a language and then
also they came out too and the gay
definitions can can also then use mod as
a google voice planning as the ending in
which then these definitions are
translating into a reread theory and
this you know it scales up to realistic
languages so we curry and asada for Sun
and fainting and I years ago did java
and the JVM the scheme see very log you
know large language is coming down this
way another important thing is that you
know both rear æthyric has both an
operational semantics by rewriting but
also denotational semantics and initial
model semantics and you know both
coincide in the sense that you know
under these confluence and you know
coherence conditions and so on there is
a perfect identity between the
operational and day and the annotation
of semantics and so the additional
semantics can be used as a basis for
inductive reasoning principles and for
correctness of of reasoning on
specification there is also the
distinction between rules an equation is
very useful and very important because
it provides a language specifier with
what you might call an instruction dial
so you can you have always the option of
make everything into rules so then you
know sort of the most concrete possible
specification of your of your of your
language but you can also identify what
aspects of your language are
deterministic and then use those with
equations of course the key point is
that equation should be confident and
also of course the shoals
the coherent with the rules and so this
gives you a more abstract semantics this
is enormously useful for model checking
because for model checking concurrent
programs you don't care really very much
of what is happening in San
deterministic sub computation inside a
threat you care about happens what
happens in the interactions between such
threads and so then you have much fewer
stays for for model checking this gives
you tremendous state space reduction
just by you know the possibility within
the logic of choosing between the
terminus t aspects done and done with
the questions and concurring and
possibly non deterministic aspects done
with rules as also Grigori was want to
give also a struct semantics is just a
special case in which your values
instead of being concrete values they
may be asked our values like types and
so on but essentially the same approach
gives you also a gnostic semantics and
mark heels and years ago developed a
whole sea pluggable policy framework for
our systematics like these people that
think that you need university of
valencia have using our semantics of
java based on the jealous much that we
develop to reason about security of java
programs and non-interference and chucky
ellison also develop techniques to
define type systems in K so I struck
semantics in some way becomes a special
case of concrete semantics so written
logic is is a logical framework so it
doesn't really take sides in the
particular definitional style so in some
sense is kind of an ecumenical framework
in which many different styles are
possible smallest type of big Astapor or
modular structure operational semantics
as peter most proposed or chemical astor
machine orchid division based semantics
all these styles can be faithfully
represented this is work that sir bonita
Gregory and I published a little while
ago in a one you know a step-by-step so
so so there's a lot of flexibility for
our community in different styles
or defining with stars and the logic as
such doesn't take sides although you
know of course certain particular
choices may be more efficient we have
certain advantages and we are certainly
interested in modularity so you know the
gay framework MSOs and so have you no
good mobility features so the general
philosophy is to define a primary
language as a reread theory then to use
tools like modder or k to execute these
definitions test them to you know
experiment with new extensions of a
language and so on and then use the
attack semantics to do a static analysis
and then use generic and the key point
is generic formal tools like you know a
model checker for the writing logic or
or you know other such tools to analyze
your your programs and then use much in
logic and reach ability logic as you
girlie was again as a generic approach
to do the ducting verification so since
this is a worship on scalability I I
included a slide with my view of Sun
aspects of scalability that I think are
coming up in the discussions and I want
to kind of also bring so one that Peter
Moses actually was talking about in his
talk this morning was in some way
related to the idea of modularity and
reduce ability so for large languages do
you like these definitions and you know
Aaron Berger also was talking about that
in a different way so you want this
these things to be understandable and
reusable and there are several
approaches msos approach the peter
during christian Obregon i show how
within the right that logic msos could
also be naturally be expressed and then
k framework of a Grigori using the idea
that you're regretting modulo
associativity and commutativity with
these notions of cells and so on has
also achieved highly modular definitions
highly modular not reducible definitions
and there's another aspect there is a
scalable executable definition
so when when Gregory was looking he
showed this comparison of different
semantics one of them use a functional
language but you know factorial 06
wouldn't terminate so that's not very
scalable and so do you want to be able
to have large languages and have you
know this 99.2 percent of cases being
tested because the things can actually
run so that's certainly an a dimensional
scalability that you care about to be
able to validate the definitions but
another part that is of importance
scalability of forum analysis so model
checking if you're improving static
analysis tools you know can we also make
them as scalable as possible and
generally speaking in these three
dimensions of scalability the experience
has been quite positive but as I am
about to tell you in the case of
real-time languages it's a little more
challenging and there are some more
specific issues that I want to get to so
let me just move on to yes shall I go
back preserves the old semantics so
suppose you specify a theory and then
you extended in the new aspects a timing
or whatever yeah Monday old semantics
remain intact has there been any work on
SE k or mold in general well um so to
begin with just having modular modular
of definitions already is a big step in
that direction because you know then
when you are adding new things you don't
have to change any of the previews so
the question you know the most
interesting we're going up seeing on
that direction is by Peter Moses in the
in the form of meta theorems so meta
theorems where you want to prove the
well if I use this feature say one
example i think the peter has done is so
consequential composition is going to be
associative and you want that to be
irrespective of what other things you
are adding
so so so first of all you want to be
modular and second you want to have as
much as possible meta theorems of that
kind that ensure the good properties
will not be lost because you will have
this conservative extension can't just
point out Jose that that was together
with Muhammad okay so then you know I'm
preaching to the choir right i mean i'm
telling you about your own work right
sorry about that yeah maybe I was set up
to you know to advertising a little bit
well mode is a language so you know mod
itself now would be in the writing logic
right so I don't think we have looked as
you know deeply into these directioners
as you have but but I think you know it
would be very natural and an appropriate
to do so yes so going back to to you
know semantics of real-time of real-time
languages so the question is how do you
deal with real time with integrated
logic and is quite simple you just need
to have a data type of time and this
data type can be discrete or can be
continuous you can have several choices
on that and then you have to describe
the state of your system now it's going
to have what you might call the normal
discreet estate of it discrete or
continuous I mean you could have timers
that have continuous time rata me so
they stayed in their normal sense of the
word together with a global clock and so
that their state really is the pair of
the state of everything in your system
together with the time right and
essentially then have the discipline is
to have two kinds of River trolls we
were rules that are 0 time so that they
happen instantaneously and then change
the time and then we were to rewrite
rules and which may be local and
rules that are global that move the
entire state of the system and describe
the passage of time just that the dest
by the simple passing of time say for
example primers are going to decrease
and things like that so so they are
described by what we call tick rules
that advance the time of the system okay
and and so therefore they're just you
know a special style of reread here is
that you know halftime as one of the
data types and describe how things
change over time or instantaneously well
so so typically typically and the good
thing will be that you know tick rules
will advance typically until the until
then the next time when something
becomes enabled you know like maybe a
timer becomes zero and then a whole
bunch of cedar time rules will happen
until nothing else can happen at that
time and then tick will sort accruals
and 0 10 rules were kind of alternate
right the advancement of time so and
then and then you know and then all
kinds of changes happen instantaneously
but but when something becomes enabled
so using this you know this this
real-time reread theories we have been
given we or other another collaborators
captain give you semantics to well one
of my former students are two key work
within the docomo labs in palo alto and
they had a language that internally they
call l2 model you know concurrent
real-time protocols and systems and the
whole semantics of this language to
design you know new systems was given in
writing logic it was just there to
dive and analyze these things and also
good model check you know these designs
and had also an a stuck semantics that
you know call also we use my former
student Camilo Rocha and face Armenia's
a researcher at NASA have for several
years work on giving semantics to a
language called Black Seal of which I
will have more to say which is heavily
used as an asset to program robots in
automatic mission you know in in
unmanned missions and so on in vehicles
and is now used heavily inside NASA as
these standards when we they found
problems with the plug seal
implementation and so on and new
extensions on the language our first
done by extending the semantics and
didn't do an analysis and swirl and I'll
come back to that because in camilla
Rocha has continued to wear on the
important new methods to achieve greater
scalability so i'll revisit black seal a
little bit later masala Turkey and I
gave semantics to ms razaw language
which is you know a real time process
calculus and develop both on SOS
semantics and a more efficient reduction
semantics for it and the model checker
and even using the semantic definition
also a distributed implementation of it
and people in Oslo have been also
working with the time creole languages
object to enter language again using
these ideas and all these programs can
be simulated a model check in mod or in
the real time mod real an extension of
it in a similar way we have been looking
at several languages for modeling
languages for embedded systems and in
particular atala me too and a which is a
modern language at University of
Berkeley developed by Edward Lee and
people in his group and heavily using
industry and also a ADL which is a an
industry standard using Airbus and
Boeing and different such companies for
embedded systems so Peter of Biscay and
my student coming by and I have been
work on have work on giving semantics to
to this length to these languages and
then using the semantics directly as an
execution environment and model checking
environment for them and similar work
has been done by other researchers in
the emotions modeling framework and the
moment-to-moment framework at the
University of leister here in the UK so
let me just tell you briefly about Tommy
Lee to told me to maybe I can show you a
picture so this is a telling me to model
of a traffic light and so there is based
on the idea of actors the send messages
to other actors and the actors
themselves are when you click these a
stochastic machines so they are the the
semantics in rewriting logic is dubbed
blue button over there which generates
the formal semantics for this model in
real time mod and then and then you can
actually give a formulas to model check
about these and in fact the fact that
the traffic light in this case was hats
how the problems that showed up in the
model checking of it so this is just one
of the river rules in the semantics
which is it grew that advances time you
know for the for the tala mean to model
in a similar way the semantics of a
subset of a ADL has been defining mod
and we have identified a synchronous
subject of which I also will have more
to say a little bit later because it's
another very useful technique to reach
greater scalability
and and so these able to has a two color
SAT a build up of eclipse you know where
you can define all these models and then
so and again again has a plug-in using
real-time mod where you can execute the
models and also you can model check them
and I'll come back to that later because
this is also a place where a new
technique to achieve scalability has
been developed this is an example of an
avian model of an automatic pilot with
two sides and the environment and the
pilot also giving commands of an active
activist and by that i will revisit
precisely later on that and again this
is a tip rule for the semantics so in
deductive logic for the advancement of
time in models of a ADL so here the
scalability here is I was you know I
said at the beginning that in the case
of real-time languages there are
particular challenges to scalability and
particular the scalability of analysis
if you want to do model checking
analysis for example there are a number
of new things that you have to go with
the first thing you have to deal with is
that the tick rules are non
deterministic so how much your advance
time is it's in general open so our
prying could be chosen to be different
values from time are to dine are prime
but more importantly what is really
challenging is the combined effect of
concurrency and the non-deterministic
termina stick interaction with an open
environment so many of the applications
you going to program our cyber physical
systems that involve sensors and
actuators and these sensors have to read
values you know give I mean the program
has to read values provided by the
sensors which from the
one of you the program are non
deterministic you don't know what the
sensor is going to give you and that
together with the fact that your system
often will have to be distributed the
combined effect of the external non
determinism from the environment plus
the concurrency makes the analysis
especially the mall check-in analysis
very challenging furthermore the
external environment the non determinism
there can be even infinite airy you know
maybe it could be you know an infinite
number of possible values that the thing
could take so how to deal with these
issues is non-trivial and thus in some
way they thing I want to kind of focus
on so but just to kind of get get a
little closer to that you could ask a
very simple question which is you know
how is the fact that this duty real-time
system is open that it interacts with
with a non-deterministic environment
model how can how is this model actually
concretely in the riveting logic
framework and the answer is very simple
is modeled by River rules where their
extra variables on the right hand side a
normal reread rule even though of course
is non-deterministic non-deterministic
in the sense that many different rules
could be applied and then depending what
depending on which one you applied you
might reach different states so these
the non determinism of that but the
typical rules however if you match the
variables X of the left hand side then
what the right hand side will be is
uniquely determined but you have extra
variables that then is not because then
any substitution to do is extra
variables is one possible outcome and so
so what is happening really with
openness in an open system is that for
example this variables Y could be values
of sensors that are being read and then
depending what they are then maybe you
would do different things so so this is
concretely how the River rose model that
the situation and of course executing
this weird rules is now more challenging
and executing normal rules because you
know how do you deal with this extra
variables y yes so what are you
convinced is about when you are now to
rule well well so thick rules are an
example of these because the Y in this
case would be the time you are advancing
but more importantly but we have ways to
deal with those so these are not so
problematic because you know one of the
things that you can do and under very
mild condition this is a completely
strategy you can advance the time like
in discrete event simulation to the next
instant when something becomes enabled
right so thick rules are you know are
non deterministic like this but easier
to handle easier to handle because you
know you can typically just tick until
something because enable and this is
when you would have to do something
right but but the rules that describe
introduction we know a domestic
environment are more challenging and if
further module system is concurrent then
you have you know huge amounts of
non-determinism one given by the
concurrency and another one given by
this kind of choice of the you know what
happens with the external environment so
there are two techniques that I want to
describe that we have been developing to
deal with this you know particularly
more challenging issues that you know
but apply particularly to to real-time
language definitions of languages that
support concurrency because you know
many of the real tan systems we have to
deal with are distributed to real-time
systems and also with interaction with
an internal environment which also
typically worry for any subversive
civica cyber-physical system is going to
be what you need to do so these
techniques are one
the technique of rewriting modular SNT
so you write x modulo desirable theories
and the other one is the technique
called pulse that reduces if a virtually
synchronous distribute this real-time
system likes a distributed control
systems are a good example of that to a
much simpler by similar synchronous one
and this achieves enormous space
reduction as I will show you a little
bit later and I'll I'll explain both
beginning with us in tea ready modulus
and tea and how this can be used and
then particularly how can be used to
deal with this you know external
environment and then i will then explain
pulse so they work on rewriting modulo
SNT is the PhD thesis work of Camilla
Rocha who is now teaching at the who has
work on this you know flexsteel
semantics at NASA and is now working at
the engineering school in Bogota
Colombia so so the ideas you have a
reread theory where a sub theory of it
is the theory of some decidable data
types like you know granule arithmetic
having a tryst press book arithmetic or
bit vectors or you know rational numbers
or things like that so this is given by
sub theory sigma 0 is 0 and then the
rest of the equations are just only
axioms for the rest of the data types
like acitivity compatibility and swamp
and this sub theory is protected in the
sense that new operators will not go
into those sorts and then the river
rules that you can define our River
rules excuse me of the form tiras to t
prime where this very was why can have
sorts in the sources 0 correspondingly
decidable types
okay so they the new values having to do
by it you know the come from the
environment will be values in these
decidable data types for which you know
you cover an sn2 solver and this can be
conditional to a condition which can be
any quantifier free formula on Sigma 0
which is the signal sub signature for
the disciple theory by doing variable
instruction you can very easily reduce
it to a canonical form in which the all
the all the sub terms in the decidable
type are variables because it just you
can start them as variables so if you
had say an arithmetic expression you
guys can put it in the constraint power
and then just reduce it to that and so
then matching now with this becomes very
easy because you know when you're
matching on the data part you know use
much with variables which are all
different so this is just a syntactic
transformation and then the key idea is
the idea of rewriting now pairs of terms
whose only variables are variables in
the desirable type and formulas which
are constraints so and conceptually what
this pair tells you is all the instances
where you stand she ate those variables
by data in the disabled type our state's
acceptable provided for those systems as
the formula Phi is satisfiable so that's
that's the set of a stage described so
now a single term a single pair like
that defines an infinite set of possible
states and then there is a rewriting you
know modular SNT relation which
essentially matches a reread rule with
you replaces by d prime where the
variables are all fresh variables for
the new wise and then essentially
conjoint sigh with the substitution
instance for the matching for for the
condition of the river
ro and there is a lifting lemma that
tells you that any concrete rewriting
that you could do with this can be
lifted is cover so that this is a
complete way of covering what in fact
would be an infinite number of computer
writing for each instance of the wise
that you could achieve so in particular
this semantic so in the plexi work as I
told you for several years this has been
heavily do at NASA but before developing
this ruddy modulus and T since they had
to deal with the interaction with the
external environment what they needed to
do was to assume that they would be
certain values in internet very violent
and then do the analysis of the
execution relative to that this is now
what has become unnecessary and a
complete execution can be achieved
because you know you can assume any
values for the external environment
using constraints and you know in this
form of writing modulation T so this
language you know has been using mass
drill in international space station in
Avatar demonstration and you know
they're all kinds of of you know big
applications within NASA that are used
in this this language which is a
distributed language in a real-time and
you know dealing with an external
environment of sensors in which tasks of
different robots solving problems in an
a in a you know NASA space mission and
can be can be programmed so black seal
is service editor monistic language but
the external environment is not so it's
deterministic once you know what the
values of the sensors are then what plug
seal does is determine but of course
those values are non deterministic and
using mod extended with you know cv c 3
and c vc Oracle to to solve smt
constraints
then a full symbolic verification of
safety properties perplexity programs
and also a symbolic execution of the
programs and you know for arbitrary
environment input has been made possible
let me just give you a very simple
example stream Lee simple but you know
this even straight the point so this is
a plexi program where you have to thread
and have a share variable x1 assigns 12
it another one assigns to to it but they
do a look up on the environment so
there's a sensor s and then if this
value of the sensor is greater or equal
than 0 then 1 do will do that and the
other one if it is less or equal than 0
that will do the other so the regretting
like semantics modulus antique has the
beauty that all the executions in mod
including the model checker the ltl
Politicker can be used exactly as before
so you can do all the analyses that you
are doing before but now on these
symbolic terms and so in particular if
you want to model check from the initial
state with the you know with the
constraint true for the you know
remember that the stage now are pairs of
a term and a formula and you want to see
whether the the program is raised free
then use you you get the answer false
because of course the value zero you
know is something where one Fred could
do one thing and the other one once I
could do the other but instead if you
want to see that from the initial state
in which is a great area code than one
then it is raised free for that case so
this is kind of again a very simple
example but gives you the idea of the
kind of analysis that you can do in
dealing with these non determinism due
to the external environment so let me
move on to two powers so many cyber
physical systems are
distributed and correspond to a
collection of components that
communicate a synchronously typically
through a network so something like an
airplane for example and they are going
to have local clocks and they have to
change the state and respond to
environment within a hard real-time
bound and typically they are distributed
and a synchronous but they have to
achieve some kind of virtual synchrony
because you know all the components have
to do something within a certain period
this is just typical of distributed
control for example so integrated model
avionics distributed control in Motor
Vehicles certain interpretations of
medical devices are examples like that
and these things are often safety
critical but they are very hard to
design and verify and implement because
they they are problems due to a
synchronous communication race
conditions message delays clock excuse
and you know divide you know brute force
development of these days is enormously
costly and furthermore at the end of the
day since many of these systems have to
be certified and their high assurance
you don't even know whether they
actually work properly or not in dealing
with the semantics of these real-time
languages and in particular way ADL we
experience huge enormous States play
explosion because of this you know
concurrency and also interaction with an
external environment so this clearly is
something beyond what you would get in a
normal priming language and which
requires techniques like the one of
pulse and the one I mean those two
techniques together are the way to do
with it so let me explain to you what
policies so it stands for physically a
synchronous logically synchronous
transformation so so where you you
reduce the very difficult issue of
designing a distributed real-time system
that should work as if it were
synchronous in which there is
you know a network and clog excuse and
so on around to the much simpler task of
this of designing a synchronous system
in which all these complexities
disappear and then is the transformation
where you produce from the synchronous
design and a synchronous one which is
correct by construction under certain
assumptions on the underlying network
the clock excuse and execution times and
we developed it with Richard rockwell
collins and colleagues at university of
illinois but then peter whiskey and i
develop a formal semantics and a proof
of correctness for this transformation
first in a conference and then last year
in theoretical computer science in a
journal paper so this is what it is you
begin with e is a synchronous design and
i will make clear what that is in a
moment and gamma our performance bounds
on what you is like a contract so
assuming that the implementation has
certain bounds then we can guarantee for
you a correct a synchronous
implementation of it correct by
construction so the performance bounds
are the maximum clock is q of the clock
synchronization algorithm the minimum
maximum time for reading input
performing transition improves in output
for each component and also the minimum
and maximum message submission delays
you know that can be guaranteed by the
underlying network and then a igama is
the corresponding a synchronous design
as a collection of objects that
communicate my message passing that is
correct by construction so a synchronous
model is very simple thing is a
collection of state machines that work
in lockstep so they the output wires are
wires from the environment the input
wires that input from the environment
the upper words about where's to to the
environment shows like sensors and
factors and then each machine can
receive inputs
from other machines including itself
from the environment with the assumption
that whatever the Machine outputs will
become input only in the next time okay
so there's a intrinsic one unit delay on
when outputs from one machine began in
push to itself or to other machines yes
so the constants so this is not this is
of course not here because this is just
a synchronous design but they they the
constants are you know the maximum clock
is Q the maximum time that it takes for
a message to arrive from one node to
another and then also the maximum time
that it takes for each component which
will correspond to one of these machines
to perform a transition really inputs
perform a transition and generate output
so those are the constants that are the
inputs to the transformation and then
the studio implementation essentially
adds a wrapper around each machine it
has an input buffer and an output buffer
okay and then it has two timers a round
timer that tells you the period and a
back of timer that tells you one is the
right moment to send the outputs to the
other components and yeah and the
behavior of each node is that you know
it reads messages from the input buffer
execute the local transition you know
his new message but doesn't send them
yet put them into the back of into the
buffer and then when the back of timer
expires then that's the moment when you
sense it to the rest of the of of the of
the components and and then you know the
cycle repeats yes
yes because that determines the period
so we have a result that the period
which is computed the period of the
synchronous system is computed you know
by taking into account you know the
maximum type for network communication
plus the x plus the clock excuse plus
the execution times of course and you
know so all those has to be taken to
determine the smallest possible period
where this can work correctly so that if
you produce a period is smaller than
that there are no guarantee that you
would be correct but a period that
achieves that the bound or more will be
correct so in order to achieve actual
synchrony when you have message passing
communication there's no free lunch you
cannot achieve that you know in cero
time right so you need some time reading
data from sensors yeah yeah all this is
is taken into account yes so the key
theorem is that you can identify as you
were saying before in your own talk not
all states are meaningful in relation to
the other one so because here you will
have a stage in the still existing where
things are piecemeal some things have
advanced other half not advance so we
identify a class of distributive states
that we call a stable that are staged
that correspond to synchronous States
and the key theorem is that you know the
system the oil more precisely the cubic
structure of the stable states and the
geeky structure of the synchronous
system are by similar and as a corollary
they satisfy exactly the same temporal
logic formulas so for purposes of
verification we can verify the much
simpler synchronous
stem and be sure that they are
synchronous much more complex syncro
system which is impossible to mala check
would be correct if the synchronous one
is correct okay so that's the advantage
and so just to illustrate let me come
back to the to this standby model you
know that I show you in atl and what
that means but this reduc you know with
what this transformation means there is
the synchronous model has only 185
states and can model check-in point 2 of
a second the synchronous model in the
simplest possible case in which there's
no delays has three million states and
if you assume that there could be either
a one-unit de later or none then you
know after hours you know you just run
out of memory so so this is a you know
huge drastic space state space reduction
and this is and this is a simple example
we have done something much more
challenging like for example the whole
airplane with the turning maneuvers and
also what we call multi rate pulse we're
different you know components can be
functioning at different rates so in
this case you know there were you know
controls in the wings and in the tail
and then a central control and a pilot
and then we specified you know the whole
control of the training maneuvers or an
airplane and using multi rate pause we
were able to model check you know the
entire you know terming maneuvers of an
airplane if we had the synchronous
personally would have been totally
impossible this is it much more you know
much bigger example than this one that
we had done more recently so to conclude
I have told you first about the
regretting logic semantics project or
to give semantic definitions and that
you know what we're trying to do is of
course as as many of you are trying to
do in in other ways is to close the gap
between theory and practice by
supporting executable semantic
definitions that scale apt to real
modeling languages from languages and
hardware languages as very loud for
example and then using tools like modern
and kmart we can you know directly use
these definitions to obtain interpreters
model checkers theorem provers static
analyzers and I have been focusing on
scalability of this to be the real-time
language diagram with definitions which
is more challenging for the reasons that
I have told you but I have presented to
you two techniques that we have found
very useful to deal with those
particular issues that appear in the
case of real-time languages namely
rewriting modulus and T and the past
transformation and we have already
experienced with these techniques you
know in the case of the plexi language
at NASA and also indicates of the ADL
we've got the synchronous aadl sub
language of atl modern language in which
we can you know apply these past
transformation to deal with us with the
much simpler synchronous models and
verify those and what we haven't done
yet is to develop a genetic
infrastructure because of course what
you want is to combine these two
techniques for example if you you go
back to this picture here there are
environment impose like the site one
fail decide to fail so you know failures
that can happen from the environment and
here we didn't use the S&amp;amp;T but the
environment was small enough that we
could just do it normal model checking
as soon as you start adding more
environment improves and Daniel just
boolean values but numbers or something
this would just blow up so so the past
affirmation along would not do it
so what you want is to do the pass
transformation together with ready
modular Asanti and they are perfectly
combined about there is no as I said
bread demolition T combines perfectly
well with normal model checking so so in
this case we were just lucky that we
have a small enough environment but you
know otherwise this wouldn't just pulse
along wouldn't do it so what we would
really want to do is to combine both
techniques there is no problem in
combining them but at the moment we are
just in the process of developing the
whole infrastructure where these things
can be you know juice not only for flex
elem for atl but for other real-time
languages and so that's in some way our
our near near-term future work thank you
very much for your attention and I'll be
happy to answer questions and discuss
things with you on these ideas
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>