<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Liquid: A Software Design Architecture and Domain-Specific Language for Quantum Computing | Coder Coacher - Coaching Coders</title><meta content="Liquid: A Software Design Architecture and Domain-Specific Language for Quantum Computing - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Liquid: A Software Design Architecture and Domain-Specific Language for Quantum Computing</b></h2><h5 class="post__date">2016-06-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/f29QQhecbMU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to the tutorial on using the
academic edition of liquid we're going
to start by going to the website on
github github /m SR - quark slash liquid
which is where all the examples all the
documentation and all the software
exists before running the tutorial you
should go to this site and go down to
the how do I get it which will give you
a getting started page on how to install
all the pieces all the prerequisites one
of the prerequisites is Microsoft Visual
Studio Community Edition which is free
and available for download but this will
let you program compile and run
applications that you build with the
language integrated quantum operation
simulator which we also call liquid
after you've installed Visual Studio the
next step would be to download the zip
file from the website the zip file will
be in your downloads folder in this case
it will be called liquid master not zip
and as part of the installation it will
tell you to take liquid master extract
all the pieces and put them into the C
colon directory which is what we'll do
the only other step you need to install
is to take the liquid - master directory
that's created and rename it to liquid
so if we take a look we will see that we
have a liquid - master directory and
we'll rename that to liquid the reason
for this is some of the software will be
looking for files specifically the latex
compiler will be looking for the file
liquid tick Z dot Tec in C colon liquid
and this saves you having to rename a
lot of other things so now that we have
this let's take a look at the file tree
there's a binary directory called bin
this contains the executable and all the
support libraries necessary to run the
system without doing anything else the
docs directory contains compiled help
information this is all of the API
documentation as well as a hundred page
user's manual which you can step through
after the tutorial and will show you all
the different capabilities of the system
the image directory is just used for
pictures used in other documentation the
samples directory contains all sorts of
things that run in the system pre-built
quantum chemistry examples web graphs
and various other things we'll spend
some time here in the tutorial and then
there's a source directory this is where
you can build your own version of liquid
with your own pieces on top of it so
what we're going to do is we're going to
start by walking down to the windows
button right click on it and select
command prompt this will give you a new
command prompt that we're going to go to
the top of the tree which is C colon
liquid as you'll see everything is there
that we were just showing
and what we're going to do is make sure
liquid is running okay so we'll go into
the binary directory and say liquid the
first time we run liquid is going to
come back and tell us that we haven't
accepted the license all you need to do
is type a capital y hit enter and it
will say thank you for accepting and
you'll never see it again so this time
if we run liquid we'll get a whole bunch
of output we get the copyright notice
and also the website to go to for
anything you need with liquid it's also
gives you a warning that you haven't
registered this copy registration really
just involves going on to the website
signing up on the listserv and just
saying you're using the software we're
only using the listserv to announce
changes things available with the
software and it lets us justify doing
the work on the system because when you
install we get credit that this many
people have installed the system and we
can continue working on it and we get
funding so I strongly suggest that you
register on the website with the
listserv but if you don't all you'll do
is just get this little message every
time you run there were a large number
of tests built into the system we'll go
through a few of them as part of the
tutorial but they're all documented in
the user's manual and then there's a
usage statement and finally liquids
complaining that we forgot to provide at
least one command line parameter so
let's do that
we'll run liquid all the built-in
examples start with two underscores so
let me say underscore underscore sure
we're going to do factorization of the
number 21 and I'm going to do it without
any optimizations you're just going to
run the circuit so we'll say go and now
we're off and running
this is a 10-bit value to do a five bit
number 10 bit excuse me 10 cubits are
needed to do five and what you'll notice
is we're getting all zeroes coming back
out this is a perfectly legal answer for
sure but it also means that we're not
actually factoring so we'll try it again
there's actually a 96% probability of a
random result giving you a factorization
but only 43% for sure these numbers get
much better of course as the numbers get
bigger and the number 21 is a fairly
small number to factor but it's a good
example and now you can see we're
actually getting some bits back from the
the quantum operations so we're running
the the example through we're taking a 5
bit number it's taking us a total of 13
qubits to actually do the circuit this
is Bo regards algorithm for solving sure
and when we get to the very end we got
one more to go you'll see that 21 is
indeed 7 times 3 that we got a quantum
result of the number 341 and when we do
the classical post-processing
that gives us the factors so we were
able to factor 21 cool now we're going
to try a little larger number so like
what we do the same thing we just did
liquid sure and now we're going to go
with the number 63
so everything looks the same except now
we're not getting that first bit back
very quickly in fact this is going to
take a long time to factor and we
probably don't want to sit around
waiting for it there's our first bit
just came in should notice that at the
very beginning of every line there's a
number in a colon this is the thread
number that the message came out on and
then the next digits represent minutes
so this is point four minutes have gone
by so far so 24 seconds and you will see
this on every line so you have an idea
of how long things are taking to run and
you get an idea of if you have multiple
threads where the messages are coming
from so we're not going to wait for all
of this we're gonna do be a little
smarter we'll take this and say I'd like
you to optimize the circuit so now what
you'll see is we started with 28,000
gates to factor the number and we
compiled this all the way down until we
only had 1200 gates or matrices that we
have to multiply and you can see the
difference in the speed we're running
all the way through of course again sure
every once in a while will return zero
for a result so let's start him again
while we're talking and there we go
we're starting to get some bits back out
but this now runs very quickly the
simulator has a large part of it devoted
to optimizations for the classical
simulation of quantum systems this makes
it very quick to operate on fairly large
circuits with fairly reasonable numbers
of qubits and sure enough 63 is nine by
seven so we've just factored a number
bigger than any of the numbers normally
published for sure and this is just the
beginning of how big you could go in the
system so that's a quick overview just
to show that the system runs you've got
everything installed let's take a little
more time looking at other options by
using another example called teleport
again we'll call the teleport function
by using two underscores and then the
word teleport case does count and two
parens and when we go to run it we're
going to get three sets of runs that
come out one after the other the first
one we're just calling all the functions
in teleport directly the teleport
function takes a qubit state that
happens to be randomly chosen and then
transmits it to another qubit quantumly
provided there's two bits of classical
information that are discerned we're
actually gonna look at the circuit after
we're done running it here and show you
what what it does but we ran it several
times with different random numbers and
we always get the the number
successfully teleported depending on
whatever bits came out on the other end
we're then going to draw the circuits
we'll take a look at what the drawings
look like because instead of a function
call we're going to pull all the data
back from the functions and create a
data structure called a circuit when we
run that data structure through the
system we get the same answers again so
everything works well and then we're
going to optimize the data structure in
this case we've reduced a very simple
circuit eight gates to five gates we run
it again and again
teleport still works so the good news is
that all of this works fairly
straightforwardly and as I said we
generated some drawings while we were
going let's take a look at the drawings
if I look at teleport and just look at
the normal circuit we have an HTML file
generated that's an SVG drawing and if
we take a look we can see we can label
the qubits we can put the various gates
down on the system everything flows from
left to right this was our source that
we started with this was the destination
we got out these are the two classical
bits that were generated and then the
gates that replied based on the
classical bits so this makes it very
easy to generate drawings on the system
we can also make it a little prettier if
we if we if you notice on here you'll
see that there's one gate per unit time
we really don't have to do that instead
we can fold this this was another output
that we generated and now you see we
line the gates up a little better it's a
little prettier drawing and it also
shows you what can be parallelized in
the system fairly quickly we can also
look at the version that we optimized
where we grew the gates together and now
all the gates at the beginning have been
combined into a single gate which is a
three qubit gate and then we have to
measure and apply the output so this
gives us some very simple drawings very
quickly we can also get much higher
quality drawings if we go back to that
CF version there was also a latex Ingenu
install miktex and anything else on top
of it that would edit in this case tech
works this is the file that was
generated by liquid and if we ask it to
compile it and render the result here's
what we get so we can get publication
quality graphics very easily and of
course the file is fairly easy to edit
if you want to add your own annotations
or changes to it the system is able to
draw everything by using a latex package
we wrote called liquid tic z which is
sitting in C colon backslash liquid and
so that's why the first line of the file
referenced that file and that's why we
put everything in the liquid directory
one of the reasons was so that latex
could find the files so now let's do
some programming first thing I'm going
to do is open up the directory and I'm
going to go into liquid source
and this directory is set up to be run
with Visual Studio Community Edition
which you should have put on your
machine and at the very top of a project
or of a application that you're going to
build is called a solution file and
here's a liquid SLN or solution file and
this solution happens to have one
project on it also called liquid which
is an f-sharp project if we open the
solution file Visual Studio will open
and it's making sure since we downloaded
this from the internet that we're sure
we want to do this and say yes we do
want to open this file we know it's ok
and what we're going to see I happen to
like a dark dark background which you
can set the backgrounds you like is in
the solution Explorer these are the
files that were in the directory and the
one that we want to work in is called
main so I'm going to double click on it
and open up main this is a nice little
prototype file you can edit add your own
applications too and work at the very
bottom of this file is a module called
app which has an entry point for the
entire application called main which
runs liquid and this is actually what
gets executed every time you say liquid
to the command line we're going to edit
a little function here a sample function
called user sample again we just put the
two underscores to flag that this was
something we were doing as an example
you don't need to use the underscores
but what we did is before we created
this function in front of it we put an
attribute and what this attribute lqd
does is says the following function
should be callable from the command line
so we're going to try and see how this
works by first building our own version
of liquid and seeing that user sample
works so I'm going to go over to liquid
which is ready to go I'm going to go up
to build and I'm going to say build the
solution and so in the output window we
can see the solution going by
and the build succeeded and if I now say
start the application
the application will start up run liquid
and for some reason we're running Shore
now why is it running Shore we have to
tell Visual Studio that we actually want
to run user sample not run Shore so I'm
going to right click on liquid and go to
properties and for one thing I'm going
to do is I'm going to say let's change
debug mode to release mode because the
code will run faster we're not actually
debugging at the moment but debug is how
it gets told how to start things so I'm
going to tell it instead of Shore run
underscore underscore user sample so
this is just what you would put on the
command line after saying liquid XE and
if I now say build and actually I'm
going to show you a shortcut you can
build the solution and then you can
debug it and run the solution it turns
out control f5 will build the app start
the app and run it so from now on we're
just going to hit control f5 which we'll
see build and run but now the
application built it runs and it says
this module is a good place to put
compiled user code which is the line we
had in user sample if you notice user
sample is using command show this is
part of the API for liquid show really
is an alias for printf and all the same
arguments for printf will work the
difference is it adds a new line at the
end automatically it also is a thread
safe so if I do shows from all over the
application on different threads they
won't write on top of each other you'll
always get clean output lines in
addition every time you run you get a
log called liquid log and everything
that you say show winds up in the log so
it's good practice to use it instead of
printf and there's really no reason not
to so now let's write some code so what
we're going to do is take this line and
remove it and I'm going to write a
little function here that's going to
gather statistics I'm gonna say stats
equals array dot create two elements and
start them both off as zero so this will
give us a place that when we have a
single qubit we're going to measure and
either get a 0 or a 1
we're going to put the statistics into
here so to hold our qubits we need a
state vector and that's created with the
ket class so I'm going to create a cat
with one qubit and the K now is a vector
that contains a single qubit for loops
and f-sharp are just like any other
language you give it a start dot dot and
end and say what you want it to do
like Python everything is indent
sensitive so to go inside the loop we
indented with the tab and since every
time we go around we're going to measure
we're going to destroy the ket vector so
I'm going to tell ket the ket vector to
reset itself back to one qubit every
time we come around the loop so this way
we have a fresh state vector every time
so what I want to do is call a quantum
function with my qubits well we don't
have a quantum function yet so let's add
it we'll go in and say let Q function of
qubits which is a list of qubits equals
and I'm going to call a measurement of
qubits every quantum function ends in a
list of qubits so just like the one
we're creating or the one we're calling
M is built in to liquid which is just do
a measurement but it does a measurement
of one qubit every function takes as
many qubits as it needs off the front of
the list and performs the operation so
however many qubits there are measure is
going to measure the first qubit in the
list that's it we now have a quantum
function after we have the function I
want to see what we measured so if we go
back to that list of qubits we pull the
first qubit off by asking for the head
of the list we ask for its bit value
which is a data type in liquid that
knows if he's a 0 or a 1 or unmeasured
and I want to convert it to an actual
integer so I want
value that'll give me a zero or one and
once we have that I'm going to store
weigh-in stats of whichever value that
was stats plus one so if we measure to
zero we'll add one to the zero entry
from edger to one we'll add one to the
one entry you'll notice the dot between
the brackets it's a little different
than other languages that's one of the
main things you have to remember and
f-sharp is when you access a list or an
array you have to put a dot between the
brackets and the variable name and we'll
just show our result at the end of the
loop so we measured zero this many times
and one this many times again same as
printf the other thing in F sharp is
arguments are just separated by spaces
you don't need parens and commas that's
it that's our entire function I'm going
to hit ctrl f5 to run it
and when we run it we got 10,000 zeroes
well it makes sense we created an empty
ket vector happens to start at zero if
you haven't said anything differently
and when we measured it we still got
zero haven't done anything quantumly
really we just created a cubit and
measured it so let's change this we'll
go back up to Q function and now let me
do a Hadamard gate of the first cubit
Hadamard will take the zero and rotate
that cubit to halfway between zero and
one so we're now at the 50/50 position
again I'm hitting ctrl f5 to build and
run so now each time we measure there's
a 50/50 probability of a zero or a one
and sure enough we measured 5,000 zeros
and 5,000 ones we have just done a
superposition the first piece of actual
quantum code so this is all good
everything works now I want to do
something more sophisticated you notice
in this file there's another function
called rot X this is a general function
that will rotate a qubit around any
arbitrary angle in the x axis again the
last argument is always the qubits list
and this looks a little different
because what we're going to do is create
a gate data structure and then call that
gate to run the gate for us and the
reason for this is this lets us do
direct function execution introspection
in getting circuit values back further
introspection to get actual matrices and
pieces so if it was just a function we
couldn't get the data information back
out so we use one extra level of
indirection to make all that work this
is the general form of how to make a
gate in liquid the gate itself has a
name you can put a help string has a
matrix that's a complex sparse matrix in
this case it's a 2 by 2 matrix where the
0 0 entry is the cosine of the angle
over to the 0 1 is the minus sign the 1
0 is the sign and the 1 1 is the cosine
so it's a general rotation or round X
and in unit Ares the angle that you're
rotating by is divided by 2
there's an interesting explanation why
but we won't go into it here and there's
a drawing line
this actually is calling our liquid tick
Z package to say draw this as a gate and
here's the name I want to put in it and
since this is late at code you can
actually put latex directives and
symbols in here and they will work so
this gives us a nice little gate and
what we're going to do is come down
where we had the Hadamard and replace
that with the rotate X and we're going
to rotate by math PI over 2 and run it
again control f5 and yes F sharp is very
careful about data types you have to put
a period after the two because it's a
floating-point number and we got the
exact same result instead of rotating it
one way we wrote it a different way but
we still got to the equator at 50% and
we got a 50% value well now let's make
it more interesting let's make this pi
over 4
when we use PI over four we'll see that
we don't get 5050 anymore now we get 85
31 and 1469 and if you look at this
number it turns out that plugging in our
angle the cosine of PI over 8 squared is
0.85 3 5 5
so 8 5 3 is exactly what we'd expect to
see out of this and the probabilities
all work right great however all we've
done so far is superposition we also
want to do entanglement so what I'm
going to do is change our quantum
function to do the gate that we're doing
already on the first qubit and then if
there's more qubits for Q in Q's tail
everybody but the first qubit I'm gonna
say do a controlled knot which is an
entanglement gate between the head qubit
and this qubit so at this point this
will now do the first qubit rotate it
and then entangle it with all the other
qubits now we actually want to measure
all the qubits and we have a built-in
operator in liquid called the bowtie
which will map a measurement onto all
the qubits we could have just done a 4 Q
in Q's do M of the qubit in the list but
this is just cleaner syntax and easy to
use and we'll start introducing some of
the operators as we go so now we have to
change our user sample the command-line
we're going to change to actually take
an integer that is how many qubits we
want will change our ket vector from 1
to n will reset it back to n qubits and
everything else will work but we also
want to prove that entanglement worked
so after we get back the result of the
function we're going to say for Q in Q's
tail again everybody but the head qubit
if
q dot bit is in equal to Q's dot head
dot bit then fail this is throwing an
exception bad so now what we have is a
test that every qubit yester we measured
the first one read the same thing
because they're all entangled in
whatever we do the one qubit will happen
to all the others so we'll run it again
and we'll see what happens now when we
run the package and actually we blow up
because the input string was not in the
correct format the problem is the
command-line doesn't match what the
function says it should be if we go back
to how we're running liquid we now have
to tell it how many qubits it's
expecting an integer argument so we're
going to put the argument in and run it
again
and this time it's running but notice it
doesn't come back right away now we
rotate the first qubit and entangle it
with nine other qubits then measure all
ten of them these are big operations and
we're doing it ten thousand times so
this is going to take a little while to
run and if we take a look at what's
going on you can see the this is on a
little surface that all four threads
were almost at a hundred percent in use
and we got the same answer we got before
but we got no error so we know the
entanglement worked and this took 18
seconds to run so this took quite a
while we'd like to move to making this
going much faster so the next thing
we're going to do is at the very top
we're going to find a circuit we're
going to call the circuit class and ask
it to compile our function and of course
the function has to know how many qubits
to run even though we're not running the
function now we're just compiling it
with liquid so we're going to tell it to
use the qubits that are in the ket
vector
so by doing this we've created a circuit
what does a circuit do for us well
instead of calling Q function now we can
say ask the circuit to run the qubits
and so this gives us a way to run
instead of calling Q func directly we
actually now have built a data structure
that represents the circuit we're
running and now we're running it again
but you'll notice it's not any faster
and the reason it's not any faster is
we're still doing just as many quantum
operations so the number of vector
matrix multiplies hasn't changed in fact
we might be slightly slower because now
we're interpreting a circuit instead of
running compiled F sharp code directly
but it took a little bit longer point
four inch data point three minutes but
we get the same answer and so this time
we now like to make this more optimal so
once we have the circuit we're going to
create a new one and I'm going to say to
grow the gates there's all sorts of
optional parameters but when we have to
provide is the ket vector so he has a
state vector to tell him what to do we
take a circuit and what grow date gates
does is collapse many of the gates
together into single ones you couldn't
do this on a quantum computer but this
makes the classical simulation better
and we're not going to change anything
else that's all we're gonna do is grow
the gates and so we changed the
optimization we run the new circuit and
the last one took 0.4 minutes to run and
then this one took something under six
seconds to run in standard point one
minutes and again we keep getting the
right answer so that's always a good
sign so these are ways to optimize the
the systems that you write let's also
get some information what are these
circuits actually look like so I'm gonna
say show test one
and into the log file I'm gonna say take
the circuit and dump it into the log
files we actually look at the circuit
see what it looks like
also while we're at it I'm gonna want it
to draw it so I'm going to say render in
HTML and lay tech test one so that'll
give us some information about the first
circuit and then let's do the same about
the second circuit call it test two
and we'll run it
so now we're running along it'll still
take the same amount of time but we've
also output some information so let's
look at what we output so we'll go into
source whoops
source and we're in the release
directory so here's everything we've
done so far and there's now a test one
that HTML HTML
Tech and a test two dot HTM in tech so
we take test one dot HTM and look at it
and gee there's our gate with the
rotation angle that we used here are the
control nots between the other gates and
here's the measurements that generated
classical bits if we take a look at test
two we'll see that all the C nots got
collapsed together into one matrix which
is why this ran so much faster and the
system will do all sorts of
optimizations for you but this is a good
feel for how it works also while we've
been running we've been getting a log
file called liquid log if we look at the
log file what we'll see is here's our
show of test one and then the dump there
was a sequence of applications of gates
where the first gate was our our X of
zero point seven nine
it's a rotate X this was our help
message we put in the gate this is the
actual unitary matrix that was generated
and the entire circuit was called on all
ten wires it's actually only operating
on the first one the next gate is to see
not here's the C not matrix and it's on
wire zero and one wire 0 and two zero
and three and so forth all the way down
and then finally a measurement which is
from the unitary point adjust an
identity matrix it's a non unitary
operation there could be more
information that this was a joint
measurement and it's on wire 0 1 2 3 4 7
8 9 so what about test 2 well test 2 the
rotation looks identical but now all the
C knots are replaced with a single gate
where the system generates a name for it
and then these are all the non zero
entries
it's a sparse matrix
and these are all the nonzero entries in
the matrix so this is a fairly big
matrix the indices are in hex just to
make it easier to output and then the
measurements look identical so that's
what the log file looks like so you put
a lot more information into the log and
you actually put things directly in the
log without putting them on the console
when you have large amounts of output so
let's switch gears a little bit let's
move over to quantum chemistry we're now
going to change directories and move
into the liquid samples directory we'll
take a look at quantum chemistry so
liquid that we're going to run is
sitting in the bin directory we're going
to say liquid of chem of H 2 so H 2 is
just 2 hydrogen atoms sitting next to
each other at a specified distance and
we'll run it so it's already done but it
goes by really fast so let's take a look
at liquid dot log and what we'll see is
we have the molecule h2 the parameters
that were handed in was that we're doing
a Trotter number of 32 with 28 bits of
phase estimation and a first-order
Trotter ization there's a bunch of other
parameters you can set but in this
molecule there are very few terms and
very few circuits generated from the
terms these are the actual constants
that are read in from the files and
where they're used in the terms and then
finally we take the 87 gates that were
implied by the input show how they break
down for each term which gates of what
type of are available and then we
collapse all of this into a single
unitary matrix once we have this one
unitary matrix we exponentiate it to get
the 32 trotter and we get the 28 bits of
phase estimation you'll also notice
along the way we notice that we've
drifted away from unitary we get
numerical errors as we exponentiate and
so we fix them and bring this back into
unitariness as we go finally we actually
apply the result
at the very bottom we're doing an arc
tangent optimization for the phase
estimation there are all sorts of things
you can choose this is from a paper by
Savoy and Hastings on optimize phase
estimation and then the other bits as we
come up we get higher and higher
confidence in them as we go up in this
case actually everything is 100 percent
confidence and we finally get a result
at the end the actual line we care about
is the CSV line here and so what I'm
going to do is run it again let's put
that away we'll run it again
so now we'll bring back the command line
we had and I'm going to add to it a find
of that CSV line
this is grep on windows and then i'm
going to sort it by where the energy
starts in column 25 so now we're running
the whole thing again but now we'll just
see sorted energies coming out and so
what you see is these are the actual
phase estimation the 28 phase estimation
bits that were read we'll see that a
couple of the outputs were completely
wrong they have no overlap with the
initial state that we prepped the system
in but all the others look really good
and the only difference really are those
bottom two bits where we're doing the
arctangent approximation to get a little
better accuracy but we get an energy
that is a total energy of minus one
point 137 and then this is the non
nuclear energy if we get rid of the
protons this is the energy of just the
electrons electronic part of the system
there's also more information here of
any information that was in the file
what trotter number what trotter order
and so forth so this is the most useful
line that you'll get from the quantum
chemistry and if we wanted to look at
what the input file that liquid used for
this we can look at h to underscore sto
3g for dot dot and if we take a look we
see a file that has a format that's very
easy for you to generate all the fields
are just a name equals so test TS t
equals starting at zero and this can be
repeated so you can have any number of
molecules in the same file and just pull
them out by test number info is a free
format string that you can use for
anything that goes into the CSV result
in this case we're saying what the bond
angle there is no bond angle for h2 and
the bond distance is this is the nuclear
repulsion this is what's used to go
between the two numbers here the
hartree-fock energy that came out of the
classical quantum chemistry package and
you'll notice this
energy is significantly bigger than what
we got because we're doing a full
configuration interaction model we're
doing a much more accurate model than
came out of the quantum chemistry and
then these are the actual orbitals and
their integrals that were generated so
you can use any number of packages
they're examples in the samples
directory for pi quante and for sy for
the examples in liquid will come
currently from sy 4 if we want to look
at a little more sophisticated molecule
we could look at h2o and it has the same
general format but now there's a lot
more integrals and a lot more
information about the molecule this has
7 orbitals or 14 spin orbitals that have
to be specified so now we have these
files that you can generate and load
into the system and the user's manual
explains how to generate your own and if
we wanted to run water it's going to
take a while so I'm not going to pipe
the output yet we'll just say run h2o
the system will read it in in this case
now we have 15,000 gates lots more terms
lots more gates of different types and
now we're taking all of these and
collapsing them down into a single
matrix so we collapse them all the way
down and then we're going to
exponentiate and get our answers
normally if we didn't do this this would
take anywhere from one to two hours to
get us one solution for water this way
we get the solute first solution out
very quickly in about half a minute and
we can get any number of solutions we
want one after the other and so there's
our answers so for example we're getting
a total energy of minus 75 point seven
to eight six and so forth so this is
pretty good we're able to do various
molecules you can actually add your own
to the system and what I'd like to do
now is to show how we can do all this
from a scripting level because then you
can write automated scripts to do a lot
of this so what I'm going to do is open
up h2 fsx I'm going to
it and let's just close everything else
and look at this file so this is an
example the fsx files in the samples
directory are good examples of how you
can write code to to automate liquid and
the main piece is there's always a
script module and the script module is
where you put your code quantum
chemistry uses a dictionary of strings
to set all its parameters so for
instance what test number how many bits
of phase estimation what trotter number
and alike all of these are documented in
the user's manual and instead of loading
a data file we're going to do it right
in line by putting data for each test
one after the other here in an array
instead of putting them out in an
outside file so this is fully
self-contained and then just like we had
when we programmed in visual studio we
put a liquid attribute in front of the
things we want to call from the command
line in this case we're defining two
functions one is called test and when
it's called Trott test sets which test
number we want to run and Trott uses a
default test number but overrides the
trotter number with whatever trotter
number we want to use so now we can run
liquid just like we did but now we're
going to say load the script for h2 fsx
so that gets it loaded into the system
it will load it compile it output a dll
and then load that library back so this
will give us a library we will run off
of and then we have to tell it what to
call so we're going to call our test
function in this case of test number 26
and again I'm going to pipe that to find
of CSV and pipe that to a sort plus 25
so now we compile the script we run the
script we go do everything we did before
and we really have the same code we had
before and sure enough we get the same
answers everything looks pretty good now
we're gonna alter it by saying you know
we already just compiled this dll why
don't we just load the DLL it's already
sitting there
why compile it again and so this time
instead of compiling the script boom we
just ran the DLL and after compiling you
don't have to do it every single time
even though it's a script to show you
the difference in numerical output I'm
going to change this to the Trotter call
and say do a Trotter of 2 which is a
very bad approximation for the system
and now you notice the energies that
come out are much bigger than the
energies we had at our Trotter of 32 and
we can go the other way we could say
let's do a Trotter of 1024 and now we
get even lower energy than we had a
Trotter 32 as we're slowly getting
closer and closer to the exact ground
state or as close as we can get with
this model so that's a good example of
the types of things you can do with some
of the built-in software for more
information I suggest going into the
docs directory and taking a look at
liquid dot PDF this is a hundred page
user's manual that contains all sorts of
information for the system if you take a
look through the table of contents
you'll find we have all sorts of
informations on basic operation how to
write code extending the simulator how
to manipulate circuits doing quantum
error correction advanced noise modeling
the Hamiltonian modes for both first and
second class second quantized
hamiltonians and then all the built-in
samples are documented as well when
you're writing code it's useful to have
an API manual and in the same directory
as a liquid dot compiled help file a
chump file
and here's all the information on what
we were using and in fact if we go into
circuit which we called a few times
there's the circuit compiled called we
used here's the grow gates call and the
various options we go to grow gates says
it takes an option of a grow parameter
is going to grow parameters this is all
MSDN style documentation there's over
700 pages of documentation of all the
various api's and that's probably enough
to get started with there's also online
API documentation on the github site and
I suggest using the github site for
interacting with other people and
putting up source code for people to see
as well as using the listserv make sure
you're registered so that you get
notification as we add things to the
system and as we do workshops and make
things available and thank you for your
time
you
each year microsoft research house hunt
of influential speakers from around the
world including leading scientists
renowned experts in technology book
authors and leading academics and makes
videos of these lectures freely
available
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>