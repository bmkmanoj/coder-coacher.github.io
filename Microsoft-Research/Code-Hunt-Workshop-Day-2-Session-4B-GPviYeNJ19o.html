<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Code Hunt Workshop - Day 2 Session 4B | Coder Coacher - Coaching Coders</title><meta content="Code Hunt Workshop - Day 2 Session 4B - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Code Hunt Workshop - Day 2 Session 4B</b></h2><h5 class="post__date">2016-06-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/GPviYeNJ19o" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
quadrant makes programming fenton begs
for fun his fourth phone twice and and
and I a close because fun is the way to
go in life and she's what I want in this
way I don't want to to give to my
students and and so funny fun is the the
world but then the other one I
completely disagree with a quadrant
makes programming fan because
programming is indeed fan I don't know
for you but for me it can be completely
a thrilling I I just stay on my computer
for four hours with this magic with
universities mindset is pure programming
mindset where you have deeply
concentrate hidden and and you are you
have indeed a whole lot of fun so so why
why on the one hand we say calm
exploring firm and on the other hand we
know that intrinsically a programming is
fun so in programming there is one kind
of fun when special califone which is a
big fixing you know there is something
going wrong your program does something
unexpectedly so you expect something and
the output is some is another thing and
now you start to make some hypotheses
you start to to add some logging
statements to understand exactly what
happens and it can take hours to find to
find the the first to have an
explanation and then to have a fix and
then to find a fix tool for this bag and
so back 16 is fun indeed and for a
couple of years I've started the meter
back fishing activity which is automatic
Reaper so designing programs that
fix bugs directly and so this year I
will be talking about today with this so
programming is fun back 16 is fun and
and and metallic fishing which is
automatic Reaper is even more fun so I
come from from France from Neil where
where is lil so this is a all Europe
France UK Belgium Germany here and so
lil is in the northern part of France
let's hear a very close to Belgium so we
used to drink belgium beer a lot and
yesterday she did ask me about the the
specialties of lead we we have a very
good carbon add and at the very end and
the last slide I will tell you about the
best shirt that you can happen lil but
this is only for the last line and so
yeah I'm an associate professor at the
University of you which is one of the of
the there is one of the biggest cover
science department in France and
researcher at inria which is a research
institute for computer science so it's
correlated with the university so I
spend most of my time in a teen am I
work in germany for three years before
coming to lil and so my main research
hysteresis authentics auto repair with
three three three kinds of things so two
matic past generation so like automating
the back 16 process as we know as we
practice it as developer but also what i
call us runtime state troopers so sleepy
at runtime where where there is instead
of having a crush you try to change the
applications the program state so that
the provender doesn't crash or or the
recruiter and crusher or something else
so it's slightly different it's still
repair but different kind of repair and
i like to i said i like it i will i
think that we can ultimately we will be
able to to to automatically with a bugs
only if we really understand the deep
nature of bugs and the deep nature of
bug fixing which is slightly different
so i'm doing a lot of empirical studies
on what works are
how you fix them and so I have three the
three activities and so on a technical
side so I I do most of my experiments on
Java because of this missing link here
so we have in my group we have a very
solid purchase in java source code
analysis and transformation so we have
the perfect tools to manipulate sts to
manipulate test cases and so what
exactly what's needed for 420 grouper
okay so what's what's the Riddler game
the typical river game so we are not in
current so in 30 we've already seen
yesterday that in current we have two
different games the first one is a
classical one we have a specification
and we try to to code the specification
and the second one is we have nothing
and we try to reverse engineering the
reverse engineer the program the typical
Reaper game is slightly different you
have a program and you have a test case
like this one is a real test case and
the test case is failing so a user
report to the bag maybe the same user or
developer road test case to highlight
the bag so this test case is failing and
the goal is to make it passing and so
this so often happens that you first
rise a test case so you first was a test
case and a new name to the new save him
ok I want to make it passing so I have
the user he told it told me that there
is an error when you have a zero entries
in a simplex alter so this is a real
back from a real library math library
from Apache and the test cases as this
one and we can see what what's a test
case we have typical code and at the end
we have the assertion so the assertion
is what what highlights a bug so the
assertion is failing here's a red one
and now we are in in in in real life so
the developer what is code left so I'm
the repair was to fix this bug and I
have to understand ok 0 and tries in
simplex over so probably this is a bug
as something to do with zero values yes
but there is one here one here one here
when here when ok there are many zeros
and really hard to know which one is the
the problematic one ok so the bag is in
seen in this the output of the of the
simplex Oliver so maybe the fix is in
the simplex of a class but well maybe
not because maybe the bag is actually
induced by something in the constraint
class or in the linear constraint class
or maybe in the linear objective
function so I don't really know so the
whole the game here the the game
consists of ok of understanding what
happens because simplex all true it's
not done it's very natural for all of us
then we're hit happens and what to do
the final solution is actually force for
this real bug the real patch this one so
we have one character change in in in a
method but as we as we saw yesterday
with Willem single carrot or change can
have a huge semantic impact and even if
the final solution so you see where we
want to go what's the path to get there
the path to get there in this case it's
and this is a main difference with
current with what you've seen so far is
that we are dealing with large things so
in this example at this point in time
when this bag was reported that it was
more than 38 k lines of code and more
than 200 classes and the specification
so the test cases is even larger than
the application so 40k of specification
and more than 180 K this K see so this
this sets up somehow with the size of
the search space so I have to understand
where is the bug here and what I should
change
so what is whipper according more
formally according to the Ripper game
we've just seen we have a specification
as a program p and so with a very
standard question in in programming
computer scientist the correctness
question does P comply with s
correctness usually binary if an if it's
not already the case we can add the
synthesis problem okay we only have a s
and find the program P that complies
with s and the repair for lamb which is
rather new in the literature for some
reason why I'm still looking for those
reasons is slightly different it's
between the two it's like this it's okay
you are a real problem p an association
s but p doesn't comply with s and you of
you are looking for change see such as
the change applied to pee comply
complies with s so we have something
like this so definitely it involves this
notion of of specification and
satisfaction and also this notion of
change so edits and the existing program
so this is a ripper game that could be
that could be played so if we are if we
want to have repair games in cod hand we
give the players p.s and we asked them
for for for change to fix the bug but so
this is a basic weeper problem as a
basic clipper game which is Fanning
yourself between Cal have much more with
your fan and the specification side
because in real life so first the
specification may be incomplete usually
we have two Suites it's only some input
points some data points and and so
having a proper input domain partial
error or domain makes makes the Reaper
problem statement even harder the
specification can also be implicit so
this kind of off specifications of poem
from oakland channel crush it's not
necessarily written
anywhere and so sometimes we try to
repair an implicit Oracle in this way in
this case which makes things more
difficult and and the specification made
self be incorrect so when we use this
with a specification what we often see
in real test which is that sometimes
there are some comets which make test
cases passing but some commits slightly
change both the test case and the
program which means that the test case
before weather was incorrect so you
cannot really take the specification as
as as the untouchable truth that you
cannot touch so this is the other kind
of a person so at the end as we said
with these p plus C today I see we / as
a local synthesis problem where we have
let's say 99 percent of the synthesis
that is already done this is the
existing program and you try to
synthesize the remaining percent of the
program and this is a fix this is a fix
you are looking for and and so let's
assume that you can perfectly identify
where is the problem then the local
synthesis consists of synthesized
synthesizing this is a part where the
problem is so for instance if you can
synthesize exist if you can identify
exactly which if statement is buggy you
can remove the existing code and you try
to synthesize only the if statement to
repress a program so we have in this
case a local synthesis where we have the
complete program we have ninety-nine
percent of the solution we have some
kind of altercation technique that tells
us that this if is faulty and then we
synthesize it and so yesterday Daniel in
this hint system told us under something
like change this line to to capture the
code it's exactly
identical to what we have here change
this line to repair the code so if we
can find the exact location we have a
synthesis problem and so this we have
explored this direction in a system
called North Pole now that we would
present no so we are focusing on
repairing bag if conditions so in
general like ten percent of comets are
of perfect comets are one liner fixes
and among those ten percent of one
liners one-third are changes in if
condition so it's a common kind of like
so we want to repair those kinds of bugs
to assume that you have such a piece of
code test cases which is failing and we
want to find the exact place where the
bag is what we do in Nepal is what we
call so we reduce a term from a Nixie
ten paper by a minute all I can and
colleagues which is a concept of angelic
value let's assume that an angel' can
come during execution change slightly
the program state and and the execution
continues afterwards so let's we have
failing test case and passing test with
a test case so the failing test case
starts execute and so on and arrives
here before executing the condition an
angel' comes down to earth and says this
if condition trigger it to true this is
true and you resume the prosecution you
come to the assertion at the end and you
see whether it fails or offices oh it
fails you start again you come again to
this if condition the same angel comes
but this time set the condition value to
false and by setting it is to force the
test case perceives so what we have here
is that we observe an angelic value we
find an angelic value which is a value
that is arbitrarily set at runtime to
enable referring test case to pass so if
you are failing test case executing I
don't know 100 + n n1 were the if
conditions you can go through each of
them one after the other asking the
answer to manipulate the execution and
and see whether you have NT whether the
test case passes afterwards if you have
an angelic value you've done fifty
percent of the repair process you know
that at this point of the diffusion if
the code is the new code a produce Izzy
and Jake value the test case assy do the
power-hungry different possibilities
trial find angelic values for each one
of them no for two different reasons
first because we assume a single point
of whipper so we are nice try them one
by one and second because we assume but
it's very close to reality that during a
test case execution an if condition is
always ability to the same value so we
single test case usually forgiven if
it's always true or false to some extent
but we have an empirical data backing of
this game
so we have this what we called angelic
fixed localization where we are this
where and so we find where we can
synthesize the code to fix to fix the
back so some properties the search space
is 2 times n whereas in n is the number
of if conditions we have an interesting
property which is if we cannot sign an
angelic value it means that the burgh
cannot be repaired by changing an if
condition it's another kind of a fix and
so if you can find an angelic value for
a given if for all failing test case you
have an input output base specification
of the Ripper problem where you are
trying to you are looking for a boolean
expression here because we are in an if
condition so we are looking for a
boolean expression such that for each
test for each failing test the boolean
expression of the power of the execution
context returns the angelic value and
for each passing test you don't want to
break the existing functionality so for
each passing test you want the
synthesized expression to return the
actual executed value so you may change
the expression disease i synthesized the
new if that you are looking for may be
different from the previous one but for
the passing test it should give the same
execution the same value after
revelation and so now we have an input
output based specification of the of the
Ripper problem we know that we may be
able to find a piece of code that
returns the good if conditions so what
so here we are the context so the
context of if which is the context of
Eve so in Nepal we collect a number of
variables in the in the program and the
repairs so of course or primitive
variables we aim at as I told you I
rocky with Java so we aim at repairing
Java program so we collect also the null
nests of all of these are variables with
a
an object is not on that because to be
able to synthesize if a is not none we
collect the values of side-effect free
methods with no parameters like list at
science for instance of course all
constants and we have a piece of secret
sauce here which is one of the famous
ripper technique is called gentog so by
rhymer forest Clara guez and colleagues
and I 2009 and and the key assumption in
gentog is that the Reaper comes from
elsewhere in the code last year we've
done a ram pickup study published that
alec see where we we we verify this
assumption based on a repository mining
we look for comets we look for comics
that are only composed of code existing
somewhere else in the code base and
depending on the way you count between
between ten and fifteen percent of
comets indeed never invent new code the
only rearrange things so here we can do
the same thing and this is also has some
empirical validity a lot of if condition
repair to just rearranged the thief
conditions or they just reuse a compound
condition from from elsewhere so what we
can do it that we can collect we can
ever rate complex expressions so by
complex i means a method called with
parameters we can ever ate them before
synthesis because we cannot we cannot
encode the the semantics of those
complex methods during this into this
process so we collect on this and we
have a bunch of values and now we have
really an input output based
specification when the
Texas input the output is the angelic
value that that I presented remember you
said it and I missed it so you said that
you looked at the actual repairs and I
trim fixes and how many of those were
only if conditions I mean do you mean
what's the evidence that you know
there's a lot of boxes are just that so
between between ten percent of bug fixes
are one-liners and if you and
approximately one-third of one liners
are if condition fixes okay so I three
percent of the fixes are ok ok so now in
opal we we we stop the pure synthesis
pot and we use a component based in
texas wonderful technique published
Alexi 10 by a team from from Berkeley
which encodes the core synthesis as an
essay smt problem I won't go into the
details but basically what so what we
are the input and put Bay specification
so we have the input which is here so
here we assume that input is only two
variables when variable index and a
constant zero we put components in the
synthesis so what can we have in to
synthesize expression so for instance
here we can have only when a negation
operator and and when in equality
operator but we can have as many as we
want and you guys the output and an
assistant exists a science one line
number so it denotes line number to each
of those inputs and outputs and and and
and the solver the SMP server is asked
to find some wiring between those
components so here it is a solver
searches for for integer values and how
those integer values are interpreted so
let's assume that the solver finds those
values I really miss the bottom of the
slide but anyway no I get them
yeah let's give it this way for now so
the condition is is connected so the the
synthesized code is connected to the
component the line 3 here so then 3 is
the negation operator the nation
operator is connected to the output of
line 54 so output of line for is the
inequality operator here and the
inequality operator is wired to line two
and line one which is which corresponds
to to the two input variables so at the
end the synthesized expression so the
SMT solvers gives us only those four
into integer values and they correspond
to this synthesized expression and we
can use exactly the same thing to extend
this to to object wanted with fixes like
here we anchored also as input the
expressions we want to have in the in
the repaired expression so for instance
is that size is not null and so on we
also ask for values to lose the solver
and at the end here we almost see it we
have the output is connected to line
five so line five is the end expression
twenty two three and four and so on and
so we are able to synthesize this object
oriented code so this fix so list is not
null and least that size is lower than
index and of course we can have many
components and some components may not
be used and in this case I just give the
answer to all questions in life so what
what is no pole so we have this angelic
fixed localization which gives us the
answer to where the bag is
where the car should be fixed we have
the runtime value collection where we
collect a large number of things we
encode this into smt as a synthesis
technique we could use another one and
it gives us based on the where what
should be wet wet which is a new code
and then we have the patch synthesis and
so this is this is what Napoles started
evaluation we take real bags so on two
or three two libraries here so apache
common mats apache commons lang which is
up to yeah 60-64 lines of code we run
the system and we observe different kind
of things so this is the kind of patches
that are that are synthesized by nopal
we see with the standard if conditions
and as a result of this revelation is
that ok so no politics is conditional
backs of large object on kids java
source code the river takes less than
two minutes the patch is often differ
from the original one which is always
surprising but it it's related to the
next point which is often exists
multiple different patches so it seems
that humans select one patch is among a
set of different patches and all of them
being valid let's say and as soon as you
play with automatic so this is one
component of the fun part of automatic
repair is that you observe that software
is much more plastic let's say that you
might imagine the first place yeah so so
your repair me is that the test cases
past right yes and how many test cases
actually go through the page resume
online might be no kind of issue with
that this kind of repairs
always that you know making the test
cases past doesn't mean that you fix the
code right you're right so when you say
that the patches are different you
manually check their semantically
equivalent yeah we have this and then we
are all for some of them they are they
are semantically equivalent for some of
them they are not semantically
equivalent that this seems correct or so
according to our understanding of the
domain because we weren't at the domain
expert and for some of them this is the
description slide after the tests which
is a nerdiness but it's not that awesome
aticle equivalent but you think they're
correct it's um it's tough to say right
with a web stuff to say any reasons web
for anyway it's so for how many of them
you can they're semantically equivalent
semantically equivalent or semantically
correct now semantically equivalent let
you semantically correct you don't have
a specification right so you cannot
really exactly exactly I don't I I will
tell you after because in the in the
paper table we have to give another coat
on which is the original patch so which
but here I only have this one it's but I
think it's one third one third and I
know you remember you know for how many
how many test cases were going through
that so it's between between four and
and csa 60 or 70 say this so we're going
through the condition that you guess
cancer and but the number of this case
is always not realize this metric
because you can have one testicle which
is very large with many many assertions
so which it's actually a very very
strong test case for the condition yeah
but that's already goodies I mean some
of the work I've seen and you had like
no one to test cases going through which
means that you can fix it yeah very
easily right you just have two patches
so that that test case that you know the
behaves expected sometimes you don't
even have an insertion so as long as
yeah i refresh it's fixed and soul and
anybody say exactly okay thanks I agree
anyway so some some discussion so what
the limitations of the system so first
is a synthesis limitation we are not
able to since we encode somehow the
semantics observer of the repair in sm t
we are not able to synthesize code
containing methods with parameters large
test cases already
problem because in large this case is a
key assumption that you only evaluate
the if to draw force per test case
doesn't old anymore and so this is an
issue for us with test cases of course
when there are no assertions or bad
assertions or too weak assertions it's
bad the angelic value Scientifics
localization technique was very well
unless you have the if something break
in loops because if you put and if
something if so when the angel comes the
angel is an angel you know is never
guilty just beautiful and perfect so the
angel puts true if true or if so if two
is ok but if force is an issue in loops
because you get into any loop and so on
so perfect see water system using other
synthesis techniques to overcome the
first limitation and so we are exploring
the automatic repair of infinite loops
which is such kind of I use the
automatic repair of kind of
preconditions method preconditions the
classical so if you are if you are in a
poor language we suspect the
precondition such as Java you have the
preconditions are written as if
something threw a new exception and so
we can repair them also we exploring the
list so yeah so this is one part of the
weather webdive claimed in a previous
paper is that in repair we have to be
very careful about what we are talking
about exactly as when we compared to
current problems whether it's it's a
capture the code so it's a reverse
engineering problem or it just
specification permits and the same so
it's not the same thing to repair by
conditions and under exceptions memory
leaks and so on and then we have to be
very careful we have to qualify the the
problem in the evolution day data set
and we come to the last line now not the
last one because the last one is about
the soda salt from lela which is really
good if you like to callate but now just
before this Reaper encode hands so
yesterday
today I've seen many many relations
between or Newton Ripper and and what
we've seen on cod hand so first of
course the hint generation system
presented by Daniel yesterday we could
use exactly the same kind of technique
as angelic value to speed up finding the
hints we could also use a
component-based synthesis instead of
dynamic synthesis it may it may fasten
the hint generation system I would be
very interested in observing the the
players repairs it's similar to what
we've done with commits the the very
last step in the current game is it easy
to adding in the same and assignment
changing a heating assignment earning a
return value and so on so we could
really understand again understand the
nature of of getting to the solution and
to understand the path from the problem
to the solution but the third thing is
this notion of repaired you else so as I
claim that the beginning bug fixing is
very fun and very addictive so maybe
referred you where where the goal is to
you have an almost correct
implementation is where to find to make
it correct this might be also very fun
and very addictive for players or this
might be just a break-in in the game
experience so sometimes you have a
specification program sometime you have
a reverse engineering program and
sometimes you have a repair duel where
you have to find the so it's it can be
breaking the game experience and so if
we go for repair duels with this key
equation which is what makes a good with
material and it's it's a hard question
yesterday I've started to play with the
system and basically there are some
small changes that
make all test case is given by packs a
failing some of them result only in one
failing test case so I tend to think
that a good report well as a good
balance between passing and failing test
gauges otherwise is kind of depressing
that you have only fitting this case you
don't want to repurchase it's not
motivating so there is something in the
game experience between the failing in
passing there is definitely something
respected William told us about
yesterday about the mother country maybe
also it's it's more fun to repair in a
ripple to repair program when which is
correct to ninety percent of the the
input space up to ninety percent date in
prophase I don't know but something has
to be explored here and the missing
point here is if we are able to qualify
those two points we may be able to
generate the report events from the
existing solutions so if I modify the
the secret code so that we have a buggy
program but which is fun with respect to
the balance between siding and passing
and the antimatter counting and so if we
can generate the matter the Reaper duels
it's it's good with respect to having a
lot of data because as far as I
understood one when issue in quadrant is
a number of problems we have so if we
can generate new fan problems with a
good game experience that would be
quitting so conclusion authentic self
repair is fun so this is a takeaway of
my tour because of well because we have
the phone of the search space which is a
huge we are the phone of dealing with
the specification what it can be
incomplete which can be incorrect so
it's it's always very very fun to
understand the nature of specifications
and the synthesis the probabilities
relief in as well and and when you have
a system when so a demo of photonic
repair is always very boring because
just
so output of the system but at the end
of the output where it's where you can
read but found there is a very good
experience so this idea of my torque and
this is a wonderful picture of Melville
you so Melvin you what's what do we have
in more videos we also have a
distributor different components like in
automatic repair is a specification
search space so in merville you have
basically three components so the mayor
you when you first look at it it's it
it's sounds it looks like fat because
there's a lot of chocolate of cream and
so on but as usual with French cuisine
it's actually very very fine so in in in
the middle there is no longer as I'm
allowing something with with the eggs
but it's it's very very very light so
that it just it just as soon as it in
the mouth it disappears threaten will
hang then and we have some cream
afterwards which is a which is excellent
and and at the top it's just it's a dark
chocolate but what's incredible with Mel
value is that even if it looks very fat
it's very fine and very light at the end
so this is a specialty of leader and so
since is since Lee is only 45 minutes
away from from controls the goal when I
were away from London whenever way from
from Brussels you are all welcome to to
to visit us in lil n to try the Melfi
you thank you very much this is the end
of metal
could you go back to the size previous
size but unlike the kind of a proposed
work on like a automatically generating
good news but I don't know whether you
already mentioned that like for what you
propose a repair deuce the code into is
naturally supported by basically instead
of giving you return 0 as a starting
point you just give them the fort
emotions night I mean this existing co
haunt you could already prepare these
kind of Dukes for training students in
terms of their debugging repairing
skills right so I mean I just what I
don't care it but I think because we
have seen almost all then just start
with return 0 return X right but the pep
form is very flexible to allow you put
whatever initial contestar with whatever
con comments as a hint for telling
students what kind of requirements you
need to satisfy butter than pure
guessing I so I think about I like the
like the last bullet in partly said
could we leverage the data like the
plane histories of all these players to
involve or produce new games or new
coding duels right maybe initial dudes
would eat up you guessing but just for
the mistakes that from the mistakes
being made by players in the past we may
just produce some specific more like
prepared rules like what you said yeah I
convicted with the thing I also hear
well what strike me yesterday is that so
in automatic repair okay automatically
press fan but actually there is a hidden
part which is not fun alone which is
finding actual bag real bags for your
next sixty paper because if she wants
you to repair real bags and so finding
real finding backs is easy but
reproducing them is horrible and it
takes you a lot of time so for a long
time I say okay but we can generate
banks it's very easy you just take
mutants and that's fine but
there is a it's not realistic anymore so
for your next sixty paper it's an issue
but here it's different we can generate
them because the goal is the game
experience and and maybe the skill skill
building so in this case it's perfectly
fine to meet at the code according to
like a game game experience metric and
and and it makes perfect sense so it's
very cool
then thank you again</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>