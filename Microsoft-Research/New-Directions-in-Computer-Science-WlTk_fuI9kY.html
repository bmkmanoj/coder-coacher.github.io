<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>New Directions in Computer Science | Coder Coacher - Coaching Coders</title><meta content="New Directions in Computer Science - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>New Directions in Computer Science</b></h2><h5 class="post__date">2016-07-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/WlTk_fuI9kY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">here today and and have the opportunity
to to talk to you about the future of
computer science
yeah so so one of the things that that
is important is that you're entering the
information age and just to set the
stage for my talk I'd like to tell you
just a brief story of my career I i
graduated in an electrical engineering
department in 1964 one of the reasons i
was in an electrical engineering
department is that there were no
computer science departments at that
time and i was hired by an electrical
engineering department at Princeton but
fortunate for me the Chairman asked me
if I would teach a course in computer
science and at the time I had no idea
what would go in such a course because
there were no textbooks but what I
didn't realize is that teaching that
course made me one of the world's first
computer scientists and so whenever our
country was looking for a senior
computer scientist I was on the short
list and one of the advantages of that
is at one time are the president asked
me if I would serve on our national
science board overseeing our national
science foundation I was in my 40s
imagine if I had been in high-energy
particle physics I would still be
waiting today for the senior faculty
ahead of me to retire so that I would
have that kind of opportunity now when I
tell this to students they say you were
fortunate because you graduated in
nineteen sixty four and today is 2012
but the message that I want to leave you
in my talk today is that there is a
fundamental change taking place and if
you position yourself for the future you
will have a fantastic career computer
science is undergoing a fundamental
change in the past 30 years we were
concerned with making computers useful
so we were interested in programming
languages compilers operating systems
algorithms databases but and the
emphasis was on making the computers
useful but in the future we're going to
be concerned with what we're going to
use those computers for and the things
that you are going to be involved in is
tracking the flow of ideas and
scientific literature the evolution of
communities and social networks
extracting information from unstructured
data sources and many other uses like
that and what I'd like to do is talk a
little bit about the drivers of that
change part of it is the merging of
computing and communications and it may
be that the communications is more
important than the computing aspect and
just the wealth of data and digital form
the fact that there are networked
devices and sensors and this is going to
have fundamental implications for
theoretical computer science we're going
to need to develop the theory that is
going to support these new directions
and we're going to have to update our
computer science education and so just
what I'm going to try and do in this
talk is give you a brief view of what
the future is going to be then I'll talk
a little bit about the science base
that's needed to support that future and
then I'm going to try to answer a
question that I'm often asked and that
is what does a science space look like
okay so one of the things that that Rick
mentioned in the talk that you just
heard is is the big data and just to
give you some sense as to what we mean
by big data we broadcast enough bits
that it's equivalent to approximately a
hundred and seventy four newspapers per
person in the world and when you stop to
think of it you know have have you read
your 174 newspapers today there is so
much data that that you can't even look
at it you're going to need computer
programs to extract from that data the
portions of it that are of interest to
you to give you another example of the
size if you look at facebook
they claim that they upload 250 million
photographs per day also one of the
things computer science is going to be
involved in every field of science
physicists have recently announced that
they found a new elementary particle but
one of the things that I like to point
out is that computer science played a
key role one of the things is they
looked at proton-proton collisions and
they looked at a thousand trillion of
them that number is so large that no
person the physicists didn't look at
them it was a computer program that
looked at them and found out which of
these collisions were of interest and
it's this kind of role that computer
science is going to play in basically
every discipline you can think of and
one of the the points I'd like to make
is that our current database tools are
simply insufficient to capture analyze
search and visualize the size of data
that we're encountering today so what we
need is we're going to have to develop
some more theory and this is what you
can do during your careers and this
theory will be concerned with large
graphs when I went to schools the graphs
could be drawn on a piece of paper they
had 10 or 15 vertices the graphs that
you're going to be concerned with are
going to have billions of vertices
you're going to be concerned with things
like spectral analysis high dimensional
data and dimension reduction and one of
the things on this list which is of
particular interest to me is sparse
vectors and one of the things that I
would like to point out to you if you
ever when you start to look for a
research area if you're listening to
various talks in different disciplines
and some idea comes up over and over
again it's probably fundamental and so
that's this this last item on the list
sparse vectors and the question is what
what is a sparse vector maybe it's a
thousand dimensional
vector but it's all zeros for just six
or seven coordinates and you might say
well why are sparse vectors of any any
interest and the answer is is become
because they come up in many different
disciplines they come up and tracking
the flow of ideas and scientific
literature in biological applications
and sync signal processing and what I'm
just going to do is take one application
just to show you in the biological area
one of the things you might be doing is
you might have an orchard where you have
apple trees and what you want to do is
try to develop some new apple trees
which have apples with some property
which is better than your current trees
so what you have is you basically have a
matrix each row in this matrix
corresponds to a tree in your orchard
the columns correspond to positions on
the genome and this the specter this
long vector here is an unknown and you
this the short vector way over at the
end is some observable phenomena that
you want to improve maybe it's how
bright red the Apple is or something
like that and you would like to know
what are the positions on the genome
that affect that give this particular
property well the way to do that is to
solve this linear system of equations
and determine what this vector is but
you immediately say well that doesn't
make any sense because you have many
more columns and rows and so there's a
whole vector space of solutions which
one do you want but it turns out that if
you ask for a sparse solution the sparse
solution is unique and this suggests
that we ought to understand why one of
the things you might like to explore is
the math what is the mathematical
properties that says that there's only
going to be a
unique sparse solution you can see
physically why this is true if there
were too sparse solutions that would say
there are two different sets of genes
which give rise to this property but
evolution is thrifty and it would not
involve evolved two different ways of
generating the same property so this is
one of the reasons why sparse vectors
are important but also because they come
up in many other disciplines I'm going
to talk a little bit about some of the
things that you are going to do some of
the the databases that you're going to
construct in the not-too-distant future
we're going to digitize medical records
and if I had a illness here in China I'd
be able to go to the doctor and the
doctor would be able to upload my entire
medical history and give me the best
possible medical care however I don't
want my insurance company looking at my
entire medical record I don't feel
that's any of their business the only
thing that the insurance company needs
to know is that they owe some doctor
some money they don't need to know why
it's irrelevant what medical treatment i
got the only thing that's relevant to
the insurance company is that they cover
this treatment and that they have a
rigorous proof that they owe this money
now also researchers would like to look
at this database and they would like to
look at statistical properties of it but
we want to design this database in such
a way that no individual information is
released and these are the kinds of
systems that you're going to have to
create and there's some relevant
research going on has to do with zero
knowledge proofs and differential
privacy and what i thought i would do
since you might not have seen a zero
knowledge proof is i thought i would
just show you one so you'd get an idea
that this can indeed be done zero
knowledge proof is simply a proof of a
statement that the statement is true
without providing any other information
and for a simple example I'm going to
assume that you all know how to play the
Sudoku so let's say I want it to prove
to you that I know how to fill in this
this board basically what you do is in
each row each column in each 3 by 3
array you put in the numbers 129 okay
and I want to prove that I know how to
do this without giving you any
information whatsoever as to how to do
it so how do I go about this proof what
I'm going to do is I'm going to write my
solution on little pieces of cardboard
and I've Illustrated here the the pieces
of cardboard for the top row and I'm
going to put them down on the board but
upside down so that you can't see them
okay and now what I'm going to do is let
you ask certain questions you can say
show me the first row and what I will do
is I'll pick up the pieces of cardboard
I'll shuffle them so you don't know
which was in which cell and show them to
you and you look and you will see that I
indeed have the numbers one to nine for
that row but I didn't give you any
information as to which number was in
which position then I'll put the pieces
of cardboard back down and you may check
a column you may check a three by three
square and pretty soon you're going to
believe that I have a solution now I
should point out that there is this is
not a rigorous proof in the sense that
i've proved absolutely to you that i
have a solution because what you may not
observe is that i may have put the
pieces of cardboard down back down in a
different order than I picked them up so
all you know is that with high
probability I have a solution and by
asking enough questions you can prove we
can reduce the probability that i don't
have a solution to 10 to the minus ninth
or something like that now you may say
well this is a trivial problem can you
do this for a more complex problem and
what I'm there's a problem of coloring
a graph with three colors in such a way
that no two adjacent vertices are the
same color and this problem is a hard
problem there's no known efficient
algorithm for coloring a large graph
okay so let me give you suppose I'm in a
business where I color graphs and I want
to do business with you but you're a
little nervous about paying me to see
the coloring before I show you the
coloring because you're not convinced
that I can do it and I'm a little
nervous about showing you the coloring
before you pay me because I'm not sure
that you're going to walk off so what we
want to do in order to do business is I
want to give you a rigorous proof that i
have a coloring without giving you any
information whatsoever about how what
the coloring actually is so what i'm
going to do is for every vertex in the
graph i'm going to take a little
envelope and i'm going to put in that
envelope a piece of cardboard of the
color for that vertex and i'm going to
seal them up and now what you can do is
you can ask me a question just like in
the Sudoku case you pick an edge and i
will give you the two vertices the
envelopes corresponding to the two
vertices you open them and make sure
that the colors are different now I've
given you absolutely no information
about the coloring because if I had a
coloring I could always permute the
colors so that those two vertices were
the color of the that are in the
envelopes but just looking at one edge
doesn't convince you that I have a
coloring you want to see the envelopes
for another edge but if I allow you to
see the envelopes for another edge then
you get some information so what I'm
going to do instead is I'm going to take
all the envelopes and I'm going to throw
them away and we're going to start over
i'm going to take a new set of envelopes
put the and i'm going to permute my
coloring and put the colors in and then
let you pick another envelope another
pair of envelopes now you get no
information because the second coloring
is a permutation of the first and you
don't know that permutation
and as long as the two vertices are
different colors you have a little bit
more evidence that i have a coloring but
you have no information as to what the
coloring is now after you ask me enough
questions you you get convinced that
indeed I do have a coloring but you
might say well this is going to take a
long time well well the way we do this
when you do something like this you're
not going to actually use envelopes what
we're going to do is we're going to
agree on an encryption system and I'm
going to encrypt the colors of the
vertices and then you're going to ask
for the encryption key for two vertices
and I will give you those two encryption
keys and since we're going to do this
electronically by means of a computer we
can do millions of edges per second okay
so so that's how these zero knowledge
proofs work now the digitization of
medical records is not the only system
where there's a privacy concern almost
every database that you're going to
construct this is going to have this
kind of situation so let me quickly talk
about another example having to do with
cars and roads quite often I Drive to a
city called Philadelphia and what I do
the route guidance system in my
automobile takes me along these red
arrows and down to where I get on this
interstate highway but since I go there
frequently I noticed that many cars
turned off a little earlier and took a
different route and in so I started to
take this other route and it was a
little faster and then I noticed there
was still shorter route and the question
is why did my route guidance system not
give me this shorter route and the
answer is is the route guidance system
always keeps me on main highways because
they don't know the condition of these
back roads but imagine if your
automobile recorded its GPS coordinates
and every time you went in for service
it downloaded the GPS coordinates and by
using all of this information the route
guidance system could see how local
drivers what
codes they took and they could do a much
better routing and imagine that if they
just reduced the amount of gas we
consumed by 1% this is tens of billions
of dollars so these things are important
but there's a problem here I don't want
to download my GPS coordinates because
that would tell you who I am from where
my car is parked at night it would tell
you where i work from where I park it
during the day and it would tell you
everywhere I go and I'm not sure I want
to give that information to you so again
you're going to have to create a system
which which preserves this information
now in the past sociologists could study
groups of people with a few thousand
individuals but today we can study
social networks that were then we see
the interaction of millions of
individuals and I'm just going to show
you some of the things that you can do
one of the important activities is how
communities form and evolve the the
early work in this area had to do with
something called min-cut they divided
the graph in half into two equal sized
pieces where there's a minimum number of
edges connecting the two pieces and
there was a number of assumptions people
made but they were thinking of small
graphs with the graphs that you're going
to deal with you don't want to take a
graph with a hundred million vertices
and divide it into two pieces of 50
million what you want to do is you want
to pull out a community with only 50
vertices and so how do we go about doing
that and one of the things the early
work on communities sort of assumed that
if there is a community the people in
that community had more links to people
in the community than to people outside
but that's not true this this is a
community the blue arrow the blue area
is theoretical computer science and I
put myself in there but notice that i
have many links outside that community
and because there are
are hundreds of millions of people
outside that community even though the
probability i'll have a link to someone
outside is lower than the probability of
a link inside just because of the
numbers of people outside i'm going to
have many more links outside than i do
inside also asking what community i'm in
doesn't make too much sense because i'm
in multiple overlapping communities and
so there's fundamental work to be done
here and i'll talk just about a little
bit about a work on finding communities
so i'm going to take an example where
this graph represents the adjacencies
among vertices and i made a very
idealized situation where in the upper
left-hand corner everybody is connected
to one another and then there's another
community where everybody is connected
to one another in another and there's no
connections between communities if you
have a situation like this you would
find something which are called the
singular vectors and that's these
vectors way over on the right and the
way you would identify the communities
is you would map those the rows of those
vectors into a three-dimensional space
now this is kind of an idealized example
so everybody in one community gets
mapped to one point but if it was not
such an idealized situation if if
everybody in the community wasn't
connected to everybody else and there
were some links between communities what
would happen is you would get mapped to
anoint which are clustered about these
these centers and then what you would do
is use use a method called k-means to
actually find the the communities now
one of the problems with this is if
communities overlap and now I here I
have two communities which overlap what
happens is you get three clusters
instead of two and in fact if you had n
overlapping communities you'd have 2 to
the n clusters so this isn't going to
work too well so instead of using the
clustering the row
what you want to do is you want to find
the singular vectors in the space
spanned by those three columns of
vectors and once again what you want to
do is you want to spine sparse vectors
in the space spanned by those three
vectors and what that will do is that
will pull out the communities so this is
another example where sparse vectors
comes up and what you want to find is
you want to find the minimum zero norm
vector and of course that would be all
zeros so you require that there be at
least one one in there so let's say you
want to find a community with me and so
you take my coordinate and say I want at
least a one in that coordinate finding
the minimum zero norm vectors is there's
no efficient algorithm for it so we use
a proxy namely the minimum 1 norm vector
and what I've described is how you would
find the global structure of a network
this is how you would divide this
network of a hundred million nodes into
pieces of maybe 30 million or something
like that but what we want to do is
modify this algorithm so we can find
communities of size 50 and to do this
I'm going to give you a physical example
of what we did suppose you had three
ponds which were connected with little
narrow isthmus and you dropped a little
bit of dye into one of the ponds if you
looked at it immediately after you drop
the dye you would know exactly where the
die was dropped a little bit later you
wouldn't know exactly where it was
dropped but you would at least know
which pond it was dropped in and
gradually that die spreads out and
eventually it gets distributed over
everybody well what I'm going to do is
there's an analogy between this finding
the singular vectors is looking at what
happens when you do a random walk and
you walk until it converges but rather
than wait until it converges what I'm
going to do is I'm only going to take a
very small number of steps I'm only
going to take about 5 steps enough steps
which is long enough to converge in a
community of size
but not long enough to spread out into
the entire network and so if I do this
then what I'm going to do is I'm going
to find the minimum 1 norm vector in in
a subspace where I took maybe only five
steps I propagated that subspace and
what this does is this is a good way of
finding communities there are some
research still needs to be done the
minimum 1 norm vector turns out not to
be an indicator vector it's not going to
be a vector of ones and zeros so you're
going to have to threshold it you're
going to get a vector something like
this and you're going to have to decide
where you're going to cut that threshold
to find the community and and actually
you don't necessarily want to find a
vector which is in that subspace but
what you at least like to do is find a
vector which is very close to that
subspace so what we did is we minimize
the the one norm of y which is the
vector we're trying to find plus some
constant times the cosine of the angle
with that subspace if you make that
constant infinite then you're finding a
vector in the subspace</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>