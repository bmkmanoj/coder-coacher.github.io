<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Hints and Principles for Computer System Design | Coder Coacher - Coaching Coders</title><meta content="Hints and Principles for Computer System Design - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Hints and Principles for Computer System Design</b></h2><h5 class="post__date">2016-06-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/TRLJ6XdmgnA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year Microsoft Research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
so our last speaker well really requires
no introduction but how many of you guys
know the story of of Apple back in the
70s know that my fans okay so there was
this thing where you know Steve Jobs and
everyone they were they were looking
around for stuff and at some point they
came about the Xerox PARC Lab and this
is I think almost one of the quotes from
Steve said that those guys had invented
the future back in the 70s they had
gooeys and WYSIWYG and the best
operating systems and programming
languages and mouse and networking even
everything was invented back in the 70s
and he was completely taken by it right
and he made that into something that
every one of us now has in our hands our
laptops our phones everything sort of
was the genesis now one of the people
who founded Xerox PARC is right here
with us
dr. Butler Lampson and he has had such a
phenomenal impact on computer science
every aspect of it that is just
mind-blowing like if I started talking
about it I need a separate slot to just
introduce all the things that he has had
an impact on but I know you won't you
guys want to hear more from him so let
me invite dr. Lampson on the stage let's
give him a standing ovation thank you
everyone
we didn't quite invent everything we
didn't invent spreadsheets and that's
actually a good lesson in that because I
think the reason we didn't invent
spreadsheets was that we didn't have any
use for them since we didn't do
accounting and quit nowadays of course
spreadsheets are used for lots of other
things but in those days they were
mainly used for accounting so 30 years
ago I wrote a paper entitled hints for
computer systems wonder why it's running
off the edge
that's distressing you suppose there's
something that can be done maybe it's
okay yeah it's okay here it's just these
screens that don't work quite right if
you have
read this paper you should read it even
though it is 30 years old I read him I
reread it myself every three or four
years after I'd written it and for about
15 years I didn't really feel much of a
need to update it but starting about 10
years ago
I started to feel that the world had
changed enough and I learned enough new
things that it was really a good idea to
write a new version so I've been working
on that for the last couple of years I
have to say not very successfully my
problem now is that I know too much 30
years ago I knew just about the right
amount to fill a paper of hints so here
I'm just going to give you a sketch of
all the things that I think I have to
say today please bear in mind these are
hints they're not guaranteed to be
consistent or reliable or always
applicable if you don't like them just
ignore the ones you don't like and press
on you're not allowed to nitpick them so
I've summarized most of what I have to
say in a way of hints under two headings
one of them has to do with what you want
the system that you're building to
accomplish and the other one has to do
with how it goes about accomplishing it
so there's a nice little slogan steady
by ade will see this i've classified the
goals under six headings simple timely
efficient adaptable dependable those are
all phrases well maybe timely you
haven't heard in your courses but you've
probably heard all those other words by
in your courses and the last one which
was suggested to me by Larry Rudolph a
few years ago is yummy I'm not gonna
have a lot to say about what it takes to
make systems yummy but if you study what
Apple does you can have a good idea of
of at least one way to go about it and
it's important to bear in mind that for
many of the kinds of systems that you
that you want to build and deploy
yumminess is extremely important if
people don't if it doesn't appeal to be
people in some fairly strong way they're
not going to accept it
and under how I've organized the
thoughts under these three headings
approximate incremental and
divide-and-conquer and we'll see how all
this goes as we go along so here are the
goals again you might want your system
to be simple it might be very important
for it to be timely that is get to
market quickly the efficiency is often
important adaptability is frequently
important some kinds of systems for
instance air systems that control
airplanes have to be dependable and I
already talked about yumminess and I'm
marked in red the half of the goals that
I think are much more important today
than they were 30 years ago when I wrote
the original paper of course all these
these are all good things
ideally the system that we build would
have lots of all of these things in fact
of course you can't have everything
that's good
Engineering is a matter of making
trade-offs so one of the values I think
of having a list like this in front of
you is you have to ask yourself very
seriously well which of these things are
them is the most important to me and
which are the ones where I can afford to
not do so well because you won't be able
to to do extremely well with all of them
and under techniques I have these three
major headings approximate do things
incrementally and divide and conquer and
we'll see a lot of detail on all of
those in the second half of the talk
before I plunge into details on each of
these things I just want to say a couple
of things that have more broad
applicability often it's very helpful to
think about the alternatives that you're
that you have in designing a system in
terms of opposition's and I actually
have a list of 10 or 15 opposition's and
I just put a couple of them on this
slide one that I think is very important
is the distinction between a approximate
and precise software but precise
software a software that has a spec
whether or not the spec is written down
and if the software doesn't satisfy the
spec pretty well the customer is going
to be very unhappy
now the slogan for that is get it right
so avionics software banking software
productivity software like Microsoft
Office these are things where it's very
important for the system to be right and
if it's not the customers are really
unhappy not that it's going to be
absolutely perfect but it has to be
pretty good approximate software on the
other hand having yeah typically doesn't
have a spec there is no spec for google
search for example one could attempt
what to formulate one but first of all
it wouldn't really be very good and
secondly it has absolutely nothing to do
with a success or failure of Google
similarly if you are a customer of the
Amazon website you may have noticed that
a lot of the information that they give
you on the web pages that pop up as you
navigate the site yeah a lot of
information on occasion is missing or
even wrong they made a deliberate
decision that although it's very
important to have the page that has the
place your order button on it
have the correct information the rest of
the pages that are trying to suck you
into buying things timeliness agility
visual appeal and things like that are
much more important than having every
detail right so the slogans for
approximate software get it soon and
make it cool and sort of old-fashioned
computer scientists don't like this
story that I just told you at all
they take the view that precise software
is the only kind of software that's any
good that is definitely not what I'm
telling you precise software is neither
better or worse than approximate
software but it's different and if you
don't understand which kind you're
building you're gonna waste a lot of
time and energy making it more precise
than it needs to be and then it won't be
ready soon enough or it won't be able to
change quickly enough on the other hand
if you are building approximate software
and it should have been precise your
customers are going to be extremely
unhappy the other opposition that I put
here is one that I like really because
it I found seven words that start with
with F that are a good way to summarize
the the steady slogan another
overarching point that I wanted to make
has to do with coordinate systems and
notation many cases success in
understanding what your system is doing
and in designing it well yeah it's made
much easier if you adopt the right
coordinate system if you remember your
study of elementary physics if you're
doing dynamics problems often it's much
easier to solve the problem in the
center of mass coordinate system well
similarly if you're doing working with
matrices it's often very much easier to
understand what's going on yeah if you
switch to a coordinate system in which
the eigenvectors of the matrix are the
coordinate axes I'll just give a couple
of examples of this there are there are
a number of them that I think are pretty
convincing the one that I like the most
is the difference between viewing state
as being and viewing state as becoming
we're accustomed to thinking of state as
being that is there's a whole bunch of
variables memory locations or variables
in a programming language or whatever
and they all have values and you can
find it out the things that are easy to
do or to find out the value of a
variable or to change the value of the
variable that's state as being state is
becoming is about how you got there what
is the sequence of operations that got
you from some previous state to this one
and if you represent the state that way
it's not so easy to perhaps to find out
what the current value of the variable X
is but it's much easier to do things
like recovering old versions of the
state because you can do that by just
replaying the sequence of actions up to
the point of where you wanted the old
version it's much easier to do error
recovery that way and there are a number
of other things
basically having all in one way or
another have now having to do with your
desire to deal with more than one
version of the system at a time which
are much easier to do if you take the
becoming point of view a second example
of a different coordinate systems is
some thinking of a function as code
versus thinking of a function as at a
table of arguments and associated values
versus thinking of a function of an as
an overlay that is you have some partial
function you try it first and if it just
has to be undefined
then you try some other function so an
example an overlay that's probably the
one it's the least familiar to you but
an example of an overlay is a memory
system with a cache where you first you
if you're the processor and you I want
the value of location 10 first you look
in the cache to see if location 10 is
there there's at a table of locations
and and values in the cache but it's not
complete if you don't find it in the
cache then you go to the main memory so
that was cache overlaid on main memory
and thinking of things in in these terms
often makes it much easier to you for
you to see what's really going on in
your system and what the design
alternatives are a related point which
I'm not going to delve into is the
importance of using a good notation
having vocabulary that's well matched to
your problem space and syntax that makes
it easy to express the things that are
important in your system and this is why
domain-specific languages are so
successful and the final overarching
thing I want to say is and this is the
most unpopular one is you should write a
spec for your system even if it's an
approximate system you should write some
sort of a spec at the very least what
you should do is write down the abstract
state of your system
so free you may not be familiar with an
idea of abstract state but I'll give you
just one example the abstract state of a
file system is a map for
pathnames that's the path name of the
file to byte arrays that's the contents
of the file and there are many many
different ways to implement this
abstraction but that's the abstract
State and if you want to go from far it
and and typically I found that just
writing down the abstract state gives
you half the value that you're gonna get
from writing a spec at all it's actually
surprisingly hard work to write down the
abstract state because if you have to
shake shake your mind loose from all the
implementation details that are probably
filling in and understand what it is
that's yours is really going on in your
system from the point of view of its of
its users then if you want to go farther
you should write down what the interface
actions what the api's are that are that
yeah that UK can use to operate on the
state and finally if you want want to go
closer to establishing confidence that
your implementation actually does what
the what the spec says it's supposed to
do you should write down the abstraction
function which gets you from the
concrete state that the code uses to the
abstract state that you did on in the
first line and then if you actually want
to do a proof there's a general purpose
way of doing that which I have sketched
out if you want to pursue these matters
in more detail you can look at the
course notes for the course I taught at
MIT for a number of years on this
subject which you can find on the web
enough about that okay so now I wanted
to talk about the goals and after we've
done that we'll talk some about them the
methods so the most important goal
typically keep your simple keep your
system simple kiss stands for keep it
simple stupid why is it so important for
the system to be simple it's for one
reason we're not that smart and we can't
do that much and if the system is not
simple well you won't be able to
understand it and all it will spiral out
of control making things simple is hard
and often it's not rewarded if you work
hard to make something simple and you
tell people about it frequently their
response will be oh that's obvious but I
assure you
if you had asked them to explain it
before you did they would they wouldn't
be able to tell you this obvious thing
at all often simplicity is not rewarded
a question that I've pondered on many
occasions and I think I know the answer
to is why was the web not invented by a
computer scientist why was invented by a
sort of ersatz physicist and I think the
answer is it's too simple if someone had
written a paper for an operating systems
conference or an information retrieval
conference or anything like that
describing Tim berners-lee is designed
for the web it would have just been
laughed out of the room every time you
click on a link we're gonna make a new
TCP connection come on that's ridiculous
but actually I think he made just about
every design decision precisely
correctly because every design decision
was made in the interest of simplicity
on the other hand we did succeed in
inventing the Internet although it was a
slow painful 10-year process how can you
tell whether your system is simple
enough well the basic criterion for
simplicity derives from the first line
on the slide it's simple enough if you
can actually understand it but the
problem with that rule is what's gonna
happen when the system evolves as it
evolves it's going to get more
complicated and then you won't be able
to understand it anymore and the only
thing that can save you in that
situation is abstraction and interfaces
and we'll talk more about that later
timely the slogan here is keep it real
good enough is good enough it doesn't
have to be perfect in fact I firmly
believe that the main reason the web is
successful is that it doesn't have to
work and very frequently it doesn't work
you push on the link and the wrong thing
happens and you have to go back and push
on it again it's ok people have a lot of
tolerance for this sort of thing and the
web page takes an enormous amount of
advantage of the fact that the basic
model says that it's a person at the
other end who can deal with a lot of a
lot
things that go wrong many errors even
aside from the web many errors in
computer systems are not fatal you can
retry things you can undo them a thing
that was done by mistake or the errors
just aren't that important as in the
story I was telling you about the Amazon
retail webpages
I'm the other important aspect of
timeliness get it out there quickly is
that you find it find out what it is the
customer is really valuable as opposed
to what you imagine they value and if
you're Steve Jobs you just know what it
is the customers are gonna value and
then you don't need to do this but if
you're any ordinary person most left
most likely your idea what the customers
really want will be pretty different
from what it is they actually want and
the only way you can convincingly find
out what they actually want is to give
them something and see what it is that
they don't like about it I used to be
very unhappy with Microsoft's habit of
putting out half-baked software as
version 1 but based on the argument I
just gave you I'm much less unhappy with
it now than I was 10 or 15 years ago ok
the the e instead e is for efficiency
yeah the slogan here is reduce waste and
the important thing to bear in mind is
the it only needs to be efficient enough
it does not have to be optimal typically
there are a few situations in computing
where the search for optimality is
worthwhile because there's so much money
at stake but most of the time it's much
more important to avoid disaster than it
is to make your system optimal the other
aspect of efficiency is you need to
understand what it is that's important
for you many people hear the word
efficient and they think oh that means
it should execute in the shortest amount
of time
but that is often not the thing that's
important
perhaps it's the people cost to
administer the system that's most
important in that case you need to
standardize things and automate most of
the administrative tasks perhaps it's
the hardware cost for providing a stable
service in that case may be very
important to write tight code perhaps
it's the non-recurring engineering cost
and the ability to get to market quickly
and
yes you should big use big components
even if they're wasteful you should burn
hardware and you should settle for
something that's good enough adaptable
this is one of the things that was not
so important 30 years ago 30 years ago
typically we built systems to really run
on a given set of hardware that they had
a pretty well-defined cast to perform
you constructed them to perform that
task you had a pretty good idea of what
the user community was and things more
or less stay put
nowadays there are many ways in which
systems need to be able to evolve if
they're successful of course if the
system fails it doesn't matter so you
want to plan for success
systems need to adapt to size successful
systems live for a long time machines
get faster load increases features get
added the canonical example is the web
which grew from a hundred or so users to
the 10 to the ninth users that we have
today so that's seven orders of
magnitude which is a lot the big amount
of scaling systems need to be able to
adapt to change and to update be updated
incrementally so big things typically
change only a little bit at a time and
there there's technology and databases
and web indexes for complex and dynamic
arrays for routing on the internet many
many examples of techniques that allow
you to me make changes a little bit at a
time
and finally systems need to adapt to
failure they need to be many kinds of
systems need to be fault taller because
crashes errors and bugs are just
unavoidable you have to plan for them
and be able to adapt to them as opposed
to trying to stamp them out
dependability dependability is not
having to say I'm sorry and it comes in
three parts many of you have probably
already seen this you want your system
to be reliable that is you want it to
give the right answer you want it to be
available which means you want it to
give that answer promptly and you want
it to be secure which means that it does
those things in spite of bad guys that
are trying to mess it up the the the big
issue with dependability is to make a
judgment about how much dependability
you really need
that depends very much on the customer
and often these decisions are not made
sensibly for example about five years
ago that British rail system had a
couple of fatal accidents and as a
result of that there was a big panic and
they spent a huge amount of money on
various sorts of safety related upgrades
and it was calculated that the cost per
life saved of all these upgrades was
about a billion dollars per life which
means it's not a good way to spend the
money because you could save a lot more
lives for that billion dollars than the
one life that you spend by saving it our
improved railroad safety another good
example is the phone system the u.s.
phone system today is quite a bit less
reliable than it was in 1980 quite a bit
less dependable than it was in 1980 but
on the other hand it does a lot of
wonderful things like allowing you to
carry around your phone connectivity in
your pocket that it was unable to do in
1980 okay that was the summary of
techniques I didn't talk about yumminess
because I don't really understand much
about yumminess it's not what I do but
it's important to bear in mind and to
think you're carefully about what
whether an important part of your system
is that your customers will will really
really bond to it okay the rest of the
talk I want to spend discussing
techniques for for achieving these goals
and I've classified the ones I'm going
to talk about under three major headings
and which are summed up as aid
so there's approximate there's two
things incrementally and most important
there's divide and conquer I look very
hard for an acronym that would start
with divide and conquer with D since
it's the most important but I couldn't
find one I did find aid so divide and
conquer has a lot of aspects and here's
the most important one you want to
divide things up by difference which
means you want to divide your system up
into abstractions with clean interfaces
why is that important because it limits
the amount of complexity that any
individual needs to deal with the
overall system architect has to
understand all the
abstractions and how they fit together
using the interfaces that are being
defined but the overall system architect
doesn't need don't be able to understand
the details of what's going on inside
each one of those abstractions in fact
the whole point of the abstraction game
is that different people can work on
separate abstractions independently and
the only thing they have to worry worry
about is satisfying the specification so
satisfying interface specification so we
have all kinds of exempts examples of
how this is paid off big-time
in computing tcp/ip is perhaps the most
outstanding exam exam 'pl where because
that's a very simple very clean very
stable interface it's been possible to
do an enormous number of different kinds
of things on top of it the web email FTP
videoconferencing all kinds of different
things and it's also been possible to do
all kinds of different things down below
that interface many different kinds of
networks physical and logical networks
that can sit underneath the tcp/ip
interface another illustration and there
hasn't been a spectacularly successful
this tcp/ip but it's been pretty
successful is file systems where there's
a so called virtual some file system
interface on top of which you can build
all kinds of applications that operate
on files and then down below that
interface you can have all kinds of
different implementations on many
different kinds of physical devices over
networks copy-on-write file systems lots
and lots of different things a special
form of abstraction is the thing that
people call platforms or layers and here
the idea is you don't just divide the
whole system up neatly into pieces but
you structure it in into into big
collections of pieces that have some
amount of coherence to them so for
example the operating system provides a
platform it has a lot of different
pieces of functionality there are a lot
of different modules a lot of different
abstractions in an operating system with
a lot of different interfaces but the
operating system
as a whole is something where you can
say this is Windows 8.1 and people can
program to that and and Microsoft can
ship it as a single entity and that
makes the evolution of a big thing like
that much more much easier and more in
fact more without that it wouldn't be
practical at all if you ship the
individual components of the operating
system separately no one would be able
to keep track of all the resulting
complexity the browser is another
example of a platform the the x86
processor is another example the
Internet is another example sometimes
the role of a platform is a little bit
more abstract you might for example say
that a platform provides transactions
that allow you to do complicated things
atomically or a platform might provide
garbage collection which take it takes
care of most of the complexity of memory
management and then that can drastically
simplify the life of the clients of the
platform I think we'll skip over the
synthesis thing even though it's dear to
my heart so that was dividing by
difference abstraction here are other
kinds of divide and conquer that can pay
off a big time recursion is important
here you divide by structures you try to
take advantage of the fact they that you
can view the pump the part essentially
in the same way that you view the whole
so many of you have probably encountered
quicksort an interesting example of an
algorithm which is essentially state of
the art for a single machine sorting but
it's also 45 years old and can be taught
in an elementary algorithms course and
the basic idea of quicksort is to
recursively subdivide the via an entire
pile of stuff that you have to sort in
two halves and keep doing that until
you're down to something that's so small
that you can sort it in some other way
efficiently just distributed hash tables
are another example of recursion
where you um you take the a single hash
table leukemia implement it on on one
machine and subdivide it with Chris
recursively into a whole bunch of sort
of sub hash tables that use spread out
according to some hash function around
the ring or tree structure of the
distributed hash table path names that
you're familiar with certainly from file
systems and perhaps from ipv6 is another
example of recursive structure where you
know that a single file system directly
directory you can have can look like a
whole file system by itself and then
each one of this of the sub directors of
that guy can also look like a whole file
system by itself and so on and so on all
the way down replication is dividing for
redundancy you can do that either in
time or in space doing it in time yeah
it's usually called retry the canonical
example of that is a TCP protocol which
is an example of the idea of an
end-to-end check where you do some more
or less complicated thing you have some
way of checking whether it worked
and if it didn't work you can go back
and retry the whole thing for for
reliability the other way to do
reliability the other way to deploy when
we're done than see in order to get a
fault-tolerant system is to do it in
space make several different copies of
the thing that you're trying to
accomplish and find some scheme that
guarantees you that each of those
individual copies well to first
approximation each of those individual
copies either is going to stop work stop
working entirely or it's going to do the
same thing as all the other copies
finally divide and conquer if you want
to divide for performance the name for
that is concurrency and that's becoming
increasingly important in the modern
world since we don't get the individual
processors to be faster and faster but
we do get more and more of them
so if we want our entire system to run
faster we have to figure out a way to
make it run concurrently on all the
different processes that we get so you
know today you know and a high-end well
even in a low-end system you get eight
cores and then if you really want to do
a lot of computing you get yourself a
cluster with a thousand machines in it
each one of which has eight cores or
maybe even more so you need to have in
many cases you need to have concurrency
that works at the level of hundreds or
thousands or tens of thousands of items
my slogan for concurrency is a simple
one your choices for a concurrent system
are stripe stream or struggle striping
is something that works when you have a
lot of pieces of the Commish computation
that are very similar and completely
independent of each other and then you
you dole them out one to each processing
unit streaming is something that
Jeannette referred to earlier but under
the name of pipelining will you string
things together in such a way that each
element feeds the next one and if you
can't figure out how to make your
concurrent system either striped or
streaming then you're gonna have to
struggle it's gonna be hard work so I
highly recommend trying to make it so
that it's either striped or streamed
BitTorrent is a good example of striping
MapReduce is a good example of both
striping and streaming if you're
familiar with those systems okay that
was a divide-and-conquer that was the
most important thing the other two are
also pretty important though
here's incremental so the idea here is
to do things a bit at a time and somehow
put all those bits together to achieve
the total of what you want to accomplish
and the most important idea for a
mentality is composition if you have two
instances of something and you can
somehow put them together to make a
bigger thing that allows you to work a
little bit at a time so for example you
composing relations that usually goes
under the name of join and if you're
familiar with relational database
systems at all you'll know that that's
pretty critical
similarly composing processes is done
with fork inter-process communication
and join the most important example of
comfort of composing in most systems it
goes by the name of indirection and I'm
very fond of David wheelers saying that
any problem in computing can be solved
with another level of indirection so the
basic idea indirection is that you have
some control over the mapping from names
to values one example of this very
common is virtualization virtual
machines within the most familiar
example of this where the original ideal
was you've got a piece of hardware you
have a memory and some instructions and
the instructions operate directly on the
memory what virtualization does is it
puts in a well a la la' layer in between
there so that you can in to intervene in
the instructs occasion of every single
instruction that when that's necessary
and you can interview being on every
single memory access if that's necessary
and then there's a bunch of clever
implementation tricks that make it so
that although it's oh it's possible to
intervene on every single instruction
and every single memory reference almost
all the time it's not necessary so
almost all the time
you can run at full speed but virtual
machines have pretty much revolutionized
the practice of of deploying
applications on large numbers of servers
another example of virtualization is is
so-called network address translation
which is the trick that's used to make
it so that even though we only have 10
to the 9th IP addresses for 12 4 times
10 to the 9th IP addresses nonetheless
we can handle a lot more than four times
ten to the ninth internet connected
devices and the way that's done is by
interposing on the putting in group
virtualizing the IP addresses
essentially a third example is USB now
the standard interconnect for plugging
relatively low bandwidth i/o devices
into computers and if you look closely
at USB and you ask for example how does
the USB actually connect a keyboard to
the to the computer the answer is
there's a hoary old 30 year old standard
that was used on the IBM PC in 1981 for
connecting a keyboard to a computer and
all USB does is to wrap that standard in
the USB protocol thus virtualizing it
transmit the bit the bit of the old ps2
keyboard standard over the wire using
USB and then unwrap it at the other end
that's another example of indirection in
the network you can have an IP address
okay you can have something that's less
direct which is a DNS name or you can
have something it's even less direct
than that which is some service symbolic
links virtual methods in object-oriented
programming copy-on-write file systems
you may not know about all these things
but these are all examples of the
application of indirection and again Oh
the basic idea always is somehow you're
going to interpose on the direct name to
value math mapping to make it give
yourself more flexibility other aspects
of incremental besides composition
there's iteration you can iterate you
the design process you can iterate
actions in a loop or recursion you can
iterate components the most striking
example of this that I've called out
here is the idea of redo where you take
the sequence of actions that you've done
and you put them into it you record the
sequence of actions in a log so that if
something goes wrong or you need to do
it replicate the same computation
another place you can just replay those
actions a third an example of
incrementality is the ability to extend
things
so you start out with a basic design for
example for basic HTML but but it's been
an essential part of the strength of
HTML from the beginning that they have a
rule that says oh you can have an
arbitrary number of tags on HTML nodes
and if someone who's reading a piece of
HTML doesn't understand a tag they can
just ignore it and the result of it of
that may be that you don't get the full
functionality that you would have gotten
if the tag had been understood but you
get some functionality and it doesn't
break the receiver Ethernet is another
example of extension yeah Ethernet
started out in 1980 with a protocol that
ran over ten megabytes shared media and
today it runs over 40 gigabit dedicated
media still using exactly that say same
basic protocol packet formats and things
like that so that all all these
different physical media can
interoperate because they give careful
thought to how you were going to make it
extensible okay so we did
divide and conquer we did incremental
now we're going to do approximate so the
most important idea for approximation of
course is one a lot I've already touched
on in the context of goals which is
settle for something that's good enough
don't try to make it perfect so for the
web and for search engines yeah you're
sort of stuck with this idea because
there's not the idea of making it prove
perfect is not even meaningful IP
packets are another example of good
enough where the rule is in the
networking world it's called best
efforts and the rule is I put a packet
into the IP network and the network is
gonna try to get it delivered to the
other end but but if things get too
tough you're gonna drop the packet on
the floor and the client is gonna have
to be able to deal with that by some
higher-level mechanism usually by TCP
you might not know that in the original
ARPANET they didn't have best efforts
they know there are original ARPANET
design said that if the network accepted
a packet it would
bust its gut trying to get the packet to
the other end and in the course of about
five years there they discovered that
this was a really bad idea and and they
had to have an extremely painful
I um switchover sort of a d-day at which
they abandoned this guarantee in favor
of best efforts um other examples of
doing things approximately the
philosophy of loose coupling for which
my slogan is springy flaky parts you
want your parts to you want to recognize
that the parts are not are gonna be
flaky they're not gonna be perfect but
you want them to be springy so that they
can absorb the jar is caused by the
flakiness and still deliver an
acceptable amount of service so email
and the Fedwire for transferring money
around between us banks are examples of
that approximating in terms of resources
that you need here the ideas if at all
possible use brute force brute force is
simple and often it's not often it's a
lot cheaper than spending the brainpower
to figure out how to do the things more
economically over-provision your
hardware broadcast your packets if
something if it looks as though
something's going wrong crash quickly
and reboot quickly and that's much
better than trying to fix things up
relaxation is often a good strategy take
small steps that are going to converge
to the desired result
so the exponential back-off that
Ethernet and TCP use the idea of
eventual consistency for updates where
you trade trade trade perfect
consistency of the store for the ability
to operate even when some parts of it
are not working or are partitioned off
the idea that you should do daily
billets builds of the system that you're
trying to build all those things are
examples of applying the idea of
relaxation so to sum up I've given you
some hints and a few principles the
difference is the hints just are just
suggestions the principles are sort of
demands
you know if I were your boss I would be
mad at you if you didn't follow the
principles and the slogan is steady by
ade you make things simple timely
efficient adaptable dependable and yummy
and you have a whole raft of techniques
for doing that about 3/4 3/4 of which
fit under the rubric of approximate
incremental and divide-and-conquer well
that was a lot of stuff to hear most of
its probably went in one ear and out the
other if you just remember three things
here they are keep it simple abstract
things and have clear interfaces to the
abstractions and write a spec at least
write down the abstract state and one
final hint which is not very actionable
but it's very important get it right if
you're doing the wrong thing it doesn't
make any difference whether you followed
all these hints or not and on that note
I'm gonna stop</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>