<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Guide to Applications of Homomorphic Encryption | Coder Coacher - Coaching Coders</title><meta content="Guide to Applications of Homomorphic Encryption - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Guide to Applications of Homomorphic Encryption</b></h2><h5 class="post__date">2016-08-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/PeE4C7Opcsw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year Microsoft Research hosts
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
okay so welcome everyone today we're
very pleased to have Maren Kim visiting
us from Seoul National University in
Korea Seoul National University is
widely acknowledged to be one of the
best universities in Korea meirin will
be speaking to us on a guide to
applications of home morphic encryption
Marin has done important work on
maintaining and extending various
libraries for home Orphic encryption and
has won the Edit distance contest in the
I - secure genome analysis competition
last year thank you Mary thank you for
introducing me and giving the
opportunity to talk about our my Wars
today I'd like to talk about the title
guide to applications of homomorphic
encryption I briefly explained the
homomorphic encryption and then I
described our basic arithmetic under her
movie encryption such as spinal circuits
and arithmetic circuits over the
integers and finally I'll show you how
to apply our primitive circuits to the
real-world problems such as private data
private database reprocessing and secure
DNA sequence analysis yeah on Murphy
encryption is an encryption function
which permits computation of encrypted
data without decryption more precisely
it is algebra structure preserving map
between message space and typed plenty
of space and ciphertext space for
example we use the cipher text a we you
as a method space as a polynomial ring
more modular integer P and cycle to a
polynomial but we usually use small but
we usually use a small
suffering this subkey which is a
integral from 0 to P minus 1 from this
definition it allows us to evaluate any
arithmetic circuit homer ethically and
many many homomorphic encryption
critical system have been suggested such
that Gentry's original scheme and as
follows of words such that DGH beat DJ
to be 10 and B to be 12 + b ln 13 and so
on and in this talk i focus on
minimizing the number of sequence or
multiplication gates for a circuit which
is called depth and the number of
homomorphic multiplication can be
considered as the computational
complexity this is because the error in
the message grows exponentially or
linearly with a multiplicative depth and
if the noise is if the error is too
large then we cannot come we cannot
support we cannot compute anymore so the
multiplicative daft is very important in
home Orphic encryption and now I
explained our basic arithmetics under
homomorphic encryption yeah suppose that
we are given mu bit integers and the we
can can consider this for primitive
circuits
equality comparison minimum and addition
equality circuit determines the equality
of two inputs and compares the circuit
is has 1 if X is strictly less than Y
and minimum circuit is the minimum of 2
inputs and the last addition circuit is
just to add two numbers over thee all
the binary circuits are expressed as
polynomials of degree mu so they can be
evaluated with a Himura fee encryption
of death log mu and for the complexity
the equality requires mute
multiplication
and the other support the other circuit
they required they are their complexity
are quadratic in the bit length mu and
however they require many cipher texts
for example for only one for only one mu
bit integer we need new cipher texts
now consider this print consider these
circuits over the integers
suppose that we take a large massive
space then the addition can be performed
with only degree 1 circuits but we have
to choose P so as to perform these
operations without overflowing in this
message space and we can revise the
previous circuits using this fact that
plus XOR and cup + + + - start our
arithmetic operations over integers then
for one it's a and B then we can we know
that this this property satisfy so using
this very simple observation the
primitive circuits can be computed
efficiently with the same depth and same
complexity but however there are still
many cipher texts because for equality
and comparison circuit
we use the bitwise encoding and each bit
is considered as an element of lars
method space on the other hand we can
consider we can revise the circuits
using pheromones little theorem let's
recall Fermat's little theorem for a
prime p x2 to the P minus 1 is 0 if and
only if x is 0 so we can consider two
important two important functions the
first one is the function kinds of K
which is a characteristic function of K
and it can be expressed using various
little theorem and then it calls the
circuit
can be seen as a just Chi sub 0 and Chi
sub K is a degree as a polynomial of
degree P minus 1 so the daffs
is log P minus 1 look about log P and
the complexity is also log P and the
another function is a step function
which has 1 if an if and only if X is
from 0 to P minus 1 over 2 then this
step function can be expressed as a sum
of Chi sub K from 0 to P minus 1 over 2
so the comparison circuit and minimum
circuit are expressed using the step
function and as you see this step
function also polynomial of degree P
minus 1 so the depth is about log P and
the complexity is for computing Chi sub
K we need log P multiplication and they
are we have K minus 1 over 2 kinds of
case so the total complexity is Big O P
Times log P so the compare the
comparison and minimum circuit the they
have the same complexity as follows this
range is like a range this range does it
change you mean if we if you change the
range then it'll be changed
yeah yeah maybe it'll work yeah yeah yes
yes in the next slide I will talk about
if we changed the range and we have a
very nice advantage by using
in CODIS such that such that they are
not so many ciphertext
so for one mu bit integers we just have
one type text and yeah the next slide is
if we Fe the if the domain is restricted
to the in Traverse such that for example
such access from 0 to L 2 or from P
minus 1 P minus L to P minus P minus 1
then the characteristic function and the
staff function can be expressed using
Lagrange interpolation formula so if we
pre compute M soft case as constant
values then these are polynomials of
degree 2 times L so the total depth is
about log log 2 times L so if the
difference between two inputs is less
than L then equality comparison minimum
circuit can be represented using this
dysfunction and they can be evaluated
with a homomorphic encryption of deaths
log L and the complexity is as follows
yeah
in short I we have the following results
given to me with integers if you use
bitwise encoding then the older circuit
has that slow commute but the number of
site X is very large and in case of
integer encoding we first take key about
2 to 2 to the MU so that addition can be
performed as just the mode of addition
in the message space and first if we use
pyramus little theorem then the dab C's
mu which is bigger than the one of
bitwise encoding but the number of the
number of site X is very large it's very
small and if if the difference between
two inputs is very small then the tafs
can be reduced to log L and it has also
the small number of size text so you can
choose bit wise encoding or integer
encoding by the function that you want
to evaluate and we have another
optimization such that single
instruction multiple data technique
called theme technique mmm assured we
pack its messages into a single cypher
text so we can perform an operation
simultaneously for all the messages more
precisely
suppose that the cyclotomic polynomials
mod p and into a product polynomial
which are irreducible of the irreducible
and this has the same degree then the
method space is isomorphic to isomorphic
to a product of polynomial ring mod p
and irreducible factors so this is
coches this is called plenty slots and
we first embed our messages
and to plaintiff laws and in code to the
plantiffs polynomial using Chinese
remainder theorem and the encryption
encrypt to the ciphertext and we can
also make extensive use of same
techniques to move data across
plaintiffs lot now I'll show how to
apply our circuit primitive circuits to
the prop to the real problems on 2011
there was a massive attack attempt to
access the user account on Sony the
PlayStation from this attacks we've
learned that we should increase
sensitive information and store this
data to protect the environment such
kind of data theft and here is the curry
that we consider in our work suppose
that we have a code for Department and
database table then we can consider that
this private search and compute curry
yeah we first we first search the Tipu
who are who are in the research
department and then aggregate their
salaries you know there are several
options the first thing is the first
thing we can think about a searchable
encryption but they only support search
operation and it is very weak it is
weakly secure because that it that means
like data distribution between context
and ciphertext domains and the other
option is using crypto systems with
layers of different critics encryption
schemes such that crypt to decrypt DB
and monomi but they cannot support
multiplication so if you want to
multiply then the values the result
value should encrypt
in advance or decrypt encrypted or
decrypt encrypted attributes so we
thought that morph encryption schemes
appear too perfect who we perform such a
database career with a single encryption
scheme the following picture illustrates
our approach before us suppose that a
supper holes are encrypted DB data
consisting of tuples and attributes then
let us denote T sub I bracket a J is the
value value of a sub J in a tuple T sub
I then for the preparation step the DVD
user prepares public key and secret key
of homomorphic encryption and then
publishes public key to us to our server
and then encrypt their data and store in
that encrypted database for the
submission of curry step a DVD user
first encrypts all the messages in a
curry queue under plan under public key
say Q Bar and the methods can be a
keyword and database a server composed
cube R into Q Bar stars using processor
by applying our techniques finally
divisive are evaluated over encrypted
data and returns the encrypted result to
DV user let's think of our search and
compute curries we first we first check
the Equality of keyword type attribute
and keyword if they are the same then it
outputs 1 and otherwise it up with 0 and
then multiply in numeric type attribute
by this result and then aggregate over
new maritime atributes
every but if we encrypt all the messages
in a bit by bit manner then addition
operation over encrypt data are very
expensive despite our of our
optimization because edition includes
very expensive carry operation and carry
operation has has many recorded many
multiplications so our solution is as
follows first we use integer message
space more precisely keyword keyword
attributes for keyword attributes we use
bitwise encoding because they are just
used for search operation and numeric
type attributes' are included by integer
so because they are used for compute
operation so using this using this
encoding we can reduce the depth of
search and compute carries by log by big
ol doc new form Ubud keyword type
attributes this is just for the deaths
of death of search operations yeah and
we also use the same technique in our in
our experiment we usually embed about
600 messages in one type of text and
perform the courage Montana flee or the
for all the messages and for the
performance improvement we represent
each of numeric type of tributes in the
red X 2 T 2 T 2 D Omega and the equation
we have the following equation from this
equation we know that a suffices to
compute just these red functions over
the integers so we choose a large plant
X mode with key
so - in order to perform this operations
without overflowing in the method space
and after evaluate this function and
after the decryption of this result the
user only has to shift and add here is
our experiment result you reuse the bgv
scheme and each library by IBM and we
suppose the keyword type of tree with 10
bits and numeric type attributes 30
beads for the Equality search and the
some curry with 100 tuples we took
message space to the juice of 2 to D 15
and we packed 600 600 messages in one
ciphertext and the running time is about
4 seconds and a comparison circuit and
some curry will tend to pull 100 tuple
then it took about 13 seconds now I want
to talk about the security Nome analysis
okay so how much difference is there
between the search part and the Sun part
so you just play again how do you do the
search us yeah so for for the search
operation we use a college circuit and
comparison circuit as I described above
and the sum is just add because we we
chose to a large message space so it is
free free a free operation but so for
the search operation it require it
requires some yeah yeah yeah so it is
very important to accelerate the tiny
and your cattle and was the number of
reference oh yeah yeah
yes you may assume that they are 100
people yeah and it's the number of
people in the database yeah
many manage you know product displays
you know type information in a public
database so we have to so that you know
genomic data has become public
accessible and one can recover physical
characteristics from genomic data so we
want to use the potential of homomorphic
encryption for secure genome data
analysis in our model the data but the
data owner wants to store large amounts
of data in the cloud and many user may
interact with the same data over time in
our solution cloud handle cloud can
handle all the interactions through a
competition on encrypt data so it
doesn't require further in further
interaction from data owner this could
be more interesting in the situation of
this picture the data owner can be
hospital or clinic and the third party
is patient then suppose that data
suppose the hospital would like to use
the cloud services for analyzing a lot
of patients data then first January
public key and secret key and then
patients can upload their data directly
to with using public key and then
Hospital recast Janome carries to the
cloud and cloud evaluate with public key
and the return the encrypted results to
the hospital then it can be availed it
can be decrypted by a secret key of
hospital
now I'll explain the added distance
which is a measure to codify this the
smaller the the smeltery of two strings
in more detail this this can be the
minimum number of arrests supported
operations such that minute mismatch
insertion and deletion which is needed
to transfer one string to the other
stream for example suppose that we have
two string alpha and beta and then we
can embed we can make another strings by
insertion insertion of bar then the
first the first same column is called
match and the last cut that's different
color is called mismatch and for the
fourth column alpha prime is needed to
insertion insertion of a in order to
transfer into beta prime so it is called
insertion and the first color of the
flower alpha prime is needed to be
deleted in order to transfer to beta
prime so it is called deletion just
called deletion so in this case the
added operation is to mismatch and one
insertion and one deletion so it's for
the total is four and it can be the
candidate of at a distance because our
distance is the minimum of this at it
operation and here is the concrete
Wagner feature at a distance algorithm
from one to six it just for it just an
initializing initialization step and
number law and line 9 and 10 is the real
competition step we first check to check
the character of inputs
they are the same or there or not and
then doing addition and then computing
minimum then we can we can create a
matrix T IJ and by updating this entries
so the added distance is the last last
result the last tell you get this sub m
and another aspect if we go and if we
consider the diagonal path then we can
have to we have to check the quality of
the character of the input and if you
move one unit down it it is it is can be
it can be a deletion and if you move one
unit right then it can beat insertion so
we in this case we have to add one to
the previous values so I'd like to
explain our encrypted at a distance
algorithm suppose that we are given two
inputs alpha and beta over Omega beat
alphabet that means that the character
are the character are omega bits then
for for s4 line nine we have to check
the equality you and it is expressed
using a college circuit as its as
described above and we could and we can
add one in the we can add 1 by M steps
in the x-axis and add one at 1 by M
stand steps in the expo in the y-axis so
so the element of matrix is always less
than M plus and minus one so
we can so it is suffices to assume that
these sub IJ T sub IJ s are log M plus n
minus 1 bleach so for the one for the
for this one round we see that the two
we sit up AFA us bitwise encoding then
tone then the total deaths is desktop
called circuit over mu over Omega plus
deaths of AD and circuit over mu beat
plus F sub minimum circuit of over move
it so the total that is about two times
dog dog mu and in case of integer
encoding the depth of addition is as
small as zero but the depth of minimum
circuit over mu bits is about mu so we
thought we can conclude that bitwise
encoding is better than industry
encoding in our encrypted at a distance
algorithm ensured given encryption of
these kind of values then one kind of
one can apply the above operations to
compute the encryption encryption of dij
with devs two times folk new which is
approximately Big O log log n plus M and
it is possible to be sub IJ
simultaneously when alpha by alpha plus
J is a fixed value so continuing this
way then we obtain the encryption of at
a distance with morphing morph
encryption of deaths these numbers the
first term is depth of one round the
second term is the number of rounds
however the SDS requires two large depth
for example if we compute at a distance
whether with a second DNA sequence of
length 8 then we need a homework
encryption of deft 120 so it's
impossible to evaluate yeah maybe it
took it took several days or yes every
month it's impossible yeah so so we so
we want to optimize our optimize the
algorithm using block competition first
divide every distance Patrick's into sub
blocks of size tau plus 1 and solve the
at a distance problem in each block and
compute each of them diagonally and
compete and update the entries then we
happy with we know that at a distance
can be evaluated with only this at this
value the first term is depth up one
block and the second term is the number
of rounds here is the result
and if tau is Omega log log n plus M
then the depth of one row one diagonal
round can be Big O tau so the total
depth can be reduced Big O and plus M
here is our experiment results with the
same scheme and the same library for for
DNA sequences with length 8 we packed
682 messages into a 1 ciphertext and so
the total time is 5 hours but and the
other multi time is about 26 27 seconds
yeah
and now I'd like to introduce the
security nerve analysis competition on
last year which was sponsored by
National Institutes of Health element
and genome web and nature report on this
competition and the teams were from
Microsoft and IBM Stanford and MIT and
so on and I also participate with a
principal researcher Kristy and we want
tasks of at a distance for a task of DNA
sequence comparison suppose suppose that
two individual genomes were random
randomly selected from Personal Genome
Project and we want to compare two sick
of this with reference genome which were
which was known publicly and the
information of two genomes were provided
as a very as the variant call format
file yes so everything was so strange
file they have some concept first snip
with it is a single nucleotide
polymorphism and it is a GCT as you know
and the RAF is the reference basis here
it is reference faces and alt is
alternative non reference tree which
means the usual data
alternative genome and there is a suite
there is a as we type which is a type of
structure variant relative to the
reference for example if non-reference
doesn't have any sniffs than it is than
the SP tag is deletion and if the non
reference string has
sniffs but while the reference doesn't
have then the SV type is insertion
before we begin we have something to do
the first thing is to create the data
using the positions in the vcv files of
two integers that is several arranges
the information and makes the worst list
and we define and we have to define two
we can define two encoding E and F the
first the first encoding e tells us
whether the genotype is missing or not
in the list and the second second
encoding F specifies the variant with
respect to the reference so if as we
type is insertion or delete deletion
then it is just 0 and otherwise it is 1
and the users string can be encoded as a
binary string of length 15 as this rules
the first rule is each snip is
represented by new bit PI two bits as a
is to 1 1 a 0 0 and G is real one see
it's 1 0 and T is 1 1 and then
concatenate with each other and pad one
at the end of string because all the a
string are 0 3 so we have to we have to
distinguish them and pads arrows to make
a 15 bit string this is because we
assume that it is enough to compare 7
strings between tooth to users so they
are up to 14 bits by the first rule and
then we pad 1 so it's up to 15 bits so M
is Oh
the strings other strings yeah all the
user stream can be seen as 15 binary
Bunny's stream say Si and in case of
missing genotype that is e e sub I is 0
then it is encoded just as 0 string so
this flags 15 that actually came from
the data right that was there could have
been like up to 15 yeah yeah entries
yeah because in the in their file some
genotype has length 100 170 so if we so
but it's too large to compute over
encrypt data so we just cut yeah so
sometimes it it outputs the different
values but but if yeah it's correct it's
correct in our experiments result 170
length yeah oh no yeah yeah oh oh string
yeah in the in this exam it just one
yeah has one characteristic but
sometimes it has 100 100 80 80 sniffs so
large yeah so for yeah yeah yeah yeah
for for promise of our experiment yeah I
cut
and here is the Hamming distance
algorithm suppose that Alice and Bob
have genotypes over many sniffs say X I
and X I Prime and for a fixed genotype
define the Hamming distance at the locus
as follows first as we type is insertion
or deletion then the Hamming d then we
can we can think of think that they are
different they are perfect to perfectly
different so the Hamming distance is
zero and if one of them are missing one
of them is missing then or yeah one of
them are missing or the there's you know
genotype artists are different than the
Hamming distance is 1 and otherwise it
is 0
and then aggregate the Hamming distance
at the locus and here is our strategy
the first Alice and Bob packed their
data into planted slots respectively and
encrypt using public key and then
evaluate the circuit for computing the
Hamming distance at the locus in
parallel so if you if we want to bitwise
encoding then we evaluate the first
circuit and if we encode if it used if
you want to encode integer encoding then
we use the second circuit and after the
Crick after evaluation of H I and
decryption then aggregate H highs
and here is a task that we want tongue
at all divides our approximate algorithm
to compute at a distance based from the
reference sequences but it was it was
exact with 9% and but it has some
advantage that such that calculate it
calculates based on the set difference
metric so it it enables to enables two
parallel computation and note that the
full wagon officially at a distance
algorithm as described above is computed
in a recursive way so it adapts is too
large that's it in the encryption the
depth is the chicken so multiplicate
will tickle multiplicative gains the
number of multiplications so but and it
is very important to the and here is the
a bit approximate at a distance for a
fixed genotype defined as genotype
length and added at a distance as
follows
there for the genotype length if the SP
type is the deletion that means there is
there is no snips and the usual Gino
then take the lengths of reference and
otherwise they have it they otherwise
she or her have the snips so take the
lengths of the old yeah say D sub I and
the added distance is of e sub I is 0 if
and only if they are
they are the same genotype and otherwise
take the maximum of the lengths and
aggregate is sub eyes and here is the
cert evaluation circuit for a bitwise
encoding if for bitwise encoding we use
the first evaluation circuit and for the
integer scheme we to use the second
circuit's and here is the implementation
results with G with DT skin and AC
library by IBM and PLL and scheme with
earth library by Microsoft with we are
given two DNA sequences with 5000
genotypes then Jesus came took about 15
seconds for Hamming distance and took
about 44 40 seconds for a distance and
BL PLL and scheme took sixty eight
seconds for a Hamming distance and 110
seconds for a Hamming distance for a
distance and the as I told the it took
it took 27 seconds for evaluating just
for eight sequences the the total the
results are improved improving than the
previous result language is about
thousand eight so that's a huge oh yes
yes five to five 85,000 and we also
provide a very comparison between GHS
skin and B
lol and scheme they use the same plant X
space and ciphertext and but the main
difference between two schemes is to
encryption of messages gh a scheme put
the messages in the least significant
bits of the cipher text but PLO and
scheme put those messages in the higher
higher bits of ciphertext and GH a
scheme use old cyclotomic polynomials oh
there is no security reduction but b ll
and scheme is the cycle atomic
polynomial of degree powers of 2 so
there is a security reduction to
shortest vector problem so PLL and
scheme is more secure yeah then e th F
and we know that this two fact the first
thing is if M here M is multiplicative
level multiplicative does yeah if M is
large then the size of size vertex mode
was Q of be NL n scheme is larger than
the one of GH s but the thought but the
bit size of ciphertext is less than gh s
and finally I want to introduce my my
ongoing work which is a floating-point
homework encryption and it was motivated
by a project with Samsung they want to
they want to they want to compute the
recommend system over encrypt data
recommend system is recommend to the
users that they want to see the movies
or yeah these kinds of thing yeah
and so we thought that we first need
approximate approximate approximate
arithmetic so we construct a a concept
of floating-point homework encryption it
outputs the encryption of some most
significant bits of addition and
multiplication of messages while the
magnitude of significant has reduced
significant is the part of
floating-point number that contains a
significant digit and our scheme
supports more efficient encrypted
floating-point arithmetic
than previous 80 encrypted schemes which
only supporting modulus operation and we
thought that our scheme can be applied
to a large integer computation and
multiplicative inverse for example with
a TBS security parameter our
implementations show that are fully our
floating point home or encryption takes
one point attack 1.8 seconds to compute
an encryption of 15 bits the precision
of multiplicative inverse given 20 bit
precision of a number yeah this is the
end thank you for your attention
I have is there any way to convert
between these representations like the
bit to the inner juror may be looking
for what are they like different domains
oh yeah
for big twice encoding we use we use we
use just the sub two as a message space
yeah but for large masses for integer
encoding then we can use the sister peak
for sufficiently large P yeah they have
the different different plan text
message our plan text spaces if there
would be some way to do that using like
food serving ah I think you would do
good stuff people have changed it from
parameters oh yeah yeah yeah very
distracting requires many computation
and and as far as no the purchase
wrapping for for integer scheme requires
fixed levels yeah so it's not that it is
not cheap operation yeah but you know in
my works I don't use bootstrapping hmm I
was I just want to use there is the
encryption just support small number of
operations so after with my with my
parameters after evaluating I we can ask
we cannot compute anymore but we have
the correct answer you can travel with
only six levels
parameter sizes well 18 secret parameter
yeah it was not 80 and 80 security
parameter about what size for like Q and
if
it's tip I don't know the exact
parameter it was just for the for the
integer morph encryption scheme not ring
LW scheme yeah yeah yeah one of my
friend are it's very interesting is
researching about purchase wrapping and
yeah he has the yeah it's the his work
yeah he said is recalled six levels for
bootstrapping in integer scheme but I
don't know the do using the floating
point
it like the mullet is B inverse oh yeah
yeah what's the Khedive inverse and and
we want to apply to aprox to approximate
Taylor series yeah yeah in our scheme
Franklin speak in our in our skin we
cannot compute the exact value but we
can compute approximately to the hour
with our desired results so how many
levels does that take to do so for
example the debate television for the
division
hmm I prefer that how many how many I
mean is it like 10th and degree n nor I
don't remember the country appearances I
just hoped I'll talk with you later yeah
I'll show our results in terms of you
implementation you report the run times
seconds how much will benefit from
paralyzation so you got a poor or the
cost to boost approach can be drive it
down to milliseconds so you mean what is
the advantage for identified their
parallel computing yeah how far can be
optimized this was the potential yeah as
far as I know yeah we can yeah the total
time is the same but but before we
encryption being code several data in
one plant X lot yeah one messages yeah I
show my my slide depends on how many we
we embed in slot yeah so the total time
is just divided by the number of the
number of the number of the number of
this lot yeah this is the Oberland time
we can compute the same operations with
same operations over the many messages
your relation is not simply based Oh
yeah they still device yeah sodon't
mercy report or a singular yeah yeah
there was already a fair bit of
vectorization happen I heard that I
heard that this it is more correct that
we call this batching technique yeah
yeah I mean it's a form of beta
parallelism
yes it's okay so this isn't just a
provider I mean to realize yeah it since
you seen this like this realization like
happening you sign the algorithm I mean
like we work at least inside our group
and you know that there are ways to push
this beyond being like you starting to
seem deep and then you can assess where
your cards well well I think there's
additional levels of parallelization
that are not happening yet here so one
is but if you look even at the lower
level of f of t multiplications
parallelization is really not being used
there yet there's another level on top
of this that could be implemented which
is kind of expanding your capability by
doing multiple CRT on essentially on the
plaintext and you can do that in
parallel so there's like at least three
levels of different types of
parallelization
it sounds like this eventually yes there
really is just a quick question so I
mean at a high level a lot of what
you're doing for the different
applications and different tasks is
examining these trade-offs between
really the doubt and the ciphertext size
in many ways because with the integer
encoding you have you know reduced the
cipher text size so dramatically but for
multiplication like for comparison
equality checking you're increasing the
doubt and so there's this you know kind
of balancing act that you're doing for
different applications and which also
affects the parallelization
possibilities as well but it's still an
open question kind of optimizing you
know for any given task
they don't mean here's a task you know
optimizing this encoding choice you know
and these trade-offs so I just wonder
what you think about that but do you
have any ideas for kind of a general
optimization in case of me in case of me
if I need except I need a banning
addition then I usually take the integer
encoding because the addition is free
and but if I want to if I if I don't
need to operate the addition addition
operation then I usually choose the
bitwise encoding so I think there is a
yeah yeah it depends on what you
evaluate yeah but sometimes some day we
can we can do that and we can consider
the more the better
circuits for equality and comparison
yeah the techniques you use be like
automated then like you show several
techniques for how to
prove these assorted algorithms you
think like that logic that you obviously
did by hand to be but in fact a compiler
option is it general doctor yeah yeah
partially yeah p.m. become sort of
action compiler specifics there's some
of these threads of the recipes called
chemical in trade imagines before the
time which is compilers that encourage
those making this process even as long
as you can discover their strategies
any other questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>