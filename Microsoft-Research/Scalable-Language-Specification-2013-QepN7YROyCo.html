<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Scalable Language Specification 2013 | Coder Coacher - Coaching Coders</title><meta content="Scalable Language Specification 2013 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Scalable Language Specification 2013</b></h2><h5 class="post__date">2016-08-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/QepN7YROyCo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
okay thank you very much so um thank you
very much to Peter and to Andrew
particularly for inviting me let's give
a talk here I was planning to spend a
few days springing out what on earth
scalable language specification Ward's
before I came here unfortunately EU has
had other plans so I've been learning on
on the fly so hope y'all I'm going to
tell you is going to be relevant to you
and I'll give my statement of what I
think scalable language specification is
and why this talk is relevant at the
very end and hope you agree with me I'm
very pleased to see so many talks
mentioning Haskell I egan didn't mention
that i Maun the Haskell design committee
and monadic i/o amongst other things is
partially my fault so if you hate minute
monads then I'm afraid that I'm partly
to blame but it was the best solution at
the time guys and if you've got any
better ideas please do let us know we're
very open to other suggestions I'm going
to tell you about some work we've been
doing our with a group of people from
various universities this is just a
small part of the team so people from
Porto the university of porto in
portugal from Ludwig's Maximilian's
university in germany heriot-watt in the
UK are various other institutions all in
all told about 20 or 30 people fall too
many to list here but these are people
have been primarily involved in the
topic of the talk which is which I'm
going to tell you about compositional
resource analysis in Hulme if you have
any questions during the talk please
don't hesitate to ask them it helps me
know that you're still awake which is
always good for the speaker and if you
don't ask me questions but I'm liable to
ask you questions and on the whole your
questions are probably easier than mine
these for you to answer ok so don't be
shy and do tell do show me if you're
awake it's actually after yesterday's
very fine dinner so what is he more
about well as I'm sure you're aware the
embedded systems dabane is incredibly
important today ninety-eight percent of
all presses in existence are used in
embedded systems every year the number
of letters
using doubling and sadly the world that
we think we live in of 32-bit or 64-bit
microprocessors hasn't yet reached the
masses so ninety-eight percent of the
presser designs that we use today are
still 8-bit or 16-bit designs this has
huge implications in terms of issues
like pounding memory usage enforcing
real time deadlines and estimating power
consumption so in some sense our
computer science lives in a fool's
paradise looking two percent of machines
there's not ones that are really being
used in the real world and that's its
domain that I'm looking at so I'm
looking at the ninety-eight percent
rather than 2% but also the implications
to the two percent we think that
bounding our resources is incredibly
important here's a comment that I picked
up from Greg more on set over coffee at
some conference so it's clearly
attributable and what Greg says is that
in the future we will regard software
without formal resource bounds in the
same way as we regard on tight programs
today in other words why do you use
University yes and buggy there's always
one this is a bit this is of course a
bit tongue-in-cheek this is a bit
tongue-in-cheek but the point the point
is that resource bounds they're an
important tool are for are removing and
correcting errors and I hope that all
striving for software that works so what
again chamber is a new direction are the
road sign from Australia somewhere a
language called Hume the language is
named after David Hume who was a
Scottish enlightenment a philosopher and
particularly skeptic we think that if I
presented the results i'm going to show
you today to david hume he was said to
me i really don't believe that what
we've told me is actually possible and
that's the right attitude one of deep
and unfair and founded skepticism what
are we trying to do well a number of
different
first of all what I'm trying to do is to
construct a virtual test bed for pushing
back the frontiers of space time and
power costs modeling so what I'm trying
to do is to build myself a pure virtual
laboratory in which I can say okay I
want to get rid of all these awkward and
possibly important to real-world issues
in order to focus on how far can I
actually push back the boundaries of
cost modeling having done that you can
take the techniques and adapt them and
hopefully apply them in settings that
some people might use like C Python
other other fine languages with or
without types the second thing
retargeting is real-time bounded space
our programming using a high-level
notation I'll take a bit more about this
later on but essentially the idea is to
combine the virtues of functional
programming with the virtues of fine Oh
finite or otherwise automata so to use
are the strong connects properties
functional programming embedded within
automata to allow us to deal with real
world interactions so this is the idea
of two level language and that's going
to come back later egon said that I've
done a lot of work in our parallel
programming well of course Hume has to
be concurrent I'm multi-threaded not
just because of my background in fact
but also because concurrency is
incredibly important if you're dealing
with real real time systems with
embedded systems real well real time
systems are existed or framework where
there is interaction with the real world
where you have to deal with this where
you have to deal with this in particular
time frames if you don't have
concurrency naturally built into your
language you cannot deal with this show
you this later on unlike a lot of signs
however are what we have is mechanism
which lasts asynchronous threading
asynchronous message passing and which
allows a great deal of flexibility in
terms of the triggering of computations
so essentially some sort of very fine
grained triggering technique not fully
synchronous as you see most language
designs
so a synchronicity at language level is
an important property to allow certain
types program to be written and the
final point which has run to you is that
what we've got here is a language first
design and moreover as I'll tell you
throughout the talk its language where
we've thought about the semantics so in
designing the language we have thought
are what what does the language mean are
what are these static semantics what are
the dynamic semantics how is it possible
to implement such and such a feature
having implemented such and such a
feature how is it possible to produce
the cost analysis for that feature so
unlike most language designs where
people think okay here's here's a nice
set of problems that i would like to
deal with one of the overriding
principles in the Hume design is that
whatever we put into the language has to
have known and in at least in theory
analyzable costs go ahead baby writing
down formal semantics as we use having
your language yes good way we have I i'm
going to show you some of that as i go
through the tall unfortunately in the
nature of all formal semantics there are
a series of documents there are about
ten documents in total each of these
documents contains about 30 pages of
mathematical texts there's a lot of it
okay it has all been written down i'll
show you sometimes we go through that's
one things i want to show you in this
talk and while the luxuries I'm
permitting myself because normally when
I give a talk on Hume and I don't get
the chance to go through all the
semantics and to show all the
definitions but I'll at least give you
some appreciation Sharon language first
means I supposed to watch first is maybe
from prom problem first so watch them
what I mean is what I raylene here's
that it's semantics first so we're we're
thinking we're thinking strongly about
semantics with a lot lounge designs keep
come along and they they have a
particular problem solved javascript
I've got I've got to have a language
which will deal with web browsing okay
quickly hack it together go and talk to
people in mathematics oh I need to write
some mathematics like I all right
programming language
what what do other programming let's
have it well we will just grab stuff and
put it in oh my god it's a horrible mess
okay here the language design is
intended to be coherent consistent and
if you're in coming from functional
community of course you're we tend to do
this but all the programming language
designs don't always do that we thought
of dip bad relations for not wanting to
ride down for smelting to him listening
instead of digression Peter which you
can have in the in the coffee break but
in 1990 i started working with young
fairburn on writing down the formal
semantics of haskell okay so very first
language first definition I came out in
1988 the I started work on haskell in
1989 Jana the time was looking at formal
semantics I I said some time working
with your all of formal semantics it's
actually reason he gave up wasn't
because we didn't think it was a good
thing it was more or less because you
ran out of time and there are more
urgent things to like actual getting
compiler the work and the rest is
history as you as you know so what we're
trying to do in him well we're trying to
achieve a number of interesting but
mutually contradictory objectives so we
want reliability and predictability so
we want software which ideally is
correct by construction with a high
degree of determinacy in terms of things
like the show showing the communication
functionality and the behavior so unlike
a lot of language designs behavior is
very important in this domain we cannot
ignore the issues to do with things like
interrupts timing memory usage etc these
are things most language designs just
sweep under the carpet in Hulme we don't
do that all these things are there
they've been fault out they've been
thought about their apparent in the
language design and controllable some
extent we want express ability and
controllability so we want ideally to
have a very high level of accessibility
while we're with functional programmers
so we want to give you thing
like automatic memory management we want
to give you a recursion we want to give
you the power of higher order functions
these are things which essentially have
never been seen in the embedded systems
domain for reasons that people working
in the domain think are very good ones
essentially lack of knowledge about the
space and time properties of these
constructs this one of the key things
that we're trying to achieve the same
time we do want to allow we do want to
deal in fact we have to deal with lower
level issues we have to deal with issues
of interrupt changeling fifo ports
memory match I owe all these dirty
low-level things they have to be there
because if you don't have these things
we can't actually interact with the real
world and this is the dilemma we need a
high level we want a high level but we
have to deal with its low level at the
same time and finally we want Const
ability you want to be able to achieve
accurate cost predictions for space-time
power concurrency blah blah blah this is
what we're trying to achieve we don't
have any cash be theorists in the
audience good so they'll say this is not
this is not Coast ability fostered
amazon yes how much parallelism does the
system expose so how many concurrent how
many concurrent agents could be working
at a particular time and in some systems
this is an interesting metric there's
just another metric that we might be
interesting yes but it's something you
might want to to say for example on this
doesn't happen at the moment typically
but we might want to have a multi core
implementation of an embedded system so
we we might want to know that our system
has adequate parallel of them to keep
this multi core system occupied okay if
we design the system without taking that
into account it won't scale and in the
future maybe in some future hardware
then it will become unusable we will
have to throw the design away and start
from scratch
so this could be an important parameter
I'm only throwing that in there I think
that in there essentially not because
we've looked at it yet but because it's
something which is a bit unusual and
people don't normally think about okay
but it is another metric you might want
to deal with and I said everything with
a strong semantic foundation so this is
what Hume looks like essentially boxes
structure processes so we have a system
which comprises a static network of
linked boxes the boxes are our link
choosing an asynchronous communication
mechanism though this means that this
the box to doesn't necessarily have to
wait for all of the results box one
before proceeding maybe it only needs
the first one or the second one big its
emerging box something of this kind it
could even be an immature box that
doesn't need any inputs at all that's
fine or think that doesn't produce any
output also fine as part of the design
it's all these designs permitted box to
our takes our producer some result based
on some of the box one inputs are passed
on to box three with some other are
input from box 1 and then produces an
output this how the system communicates
with the real world so we take input
from the real world we produce the
output to the real world and in a real
embedded system there might be multiple
input sources there might be multiple
output sources the inputs and the
outputs can come anywhere in this
diagram they don't have to come at the
end they don't have to come at the
beginning we could have box to taking
some input from some external input
producing some external help but for
example all under strong timing control
it's implicit so time is in the time
taken to process the box so to execute
code in the box time is attached
associated with time between receiving
an input and pressing it and the time
between taking the original input system
and producing at the end that's what we
want to produce what we need to produce
our reactivity twins
should the individual boxes and overall
system reactivity times that when you
hand in an input you get an output
within a certain amount of time well we
have to take into account it has to be
built into the model so we have to
consider what are the possible
interactions I'm talking about
asynchrony at the language level rather
than asynchrony exactly at the
communication level so what I mean by
asynchrony is this box for example may
only require one of these two inputs
then we have to reason about that okay
but not that we have asynchronous
hardware with no timing properties
there's a time in copper you yes with
uncertainty role in future we control as
much as we can of the network the
communication is internal this is not
going across it's not going across a
precedent network what I'm talking about
here there's a program design if I have
a physical Network involved then that
has to be a network that has real time
properties so absolutely everything I
has to have known cost the language has
to have known cost the contracts have
known cost the hardware has known cost
this is essential in in this framework
okay so most of these costs are in
typical implementations will simply be
memory costs so these think costs are
basically memory costs which are almost
instantaneous that still takes some time
and then we have to worry about what the
press can do in terms of scheduling etc
so we have to play that up that's all
dealt with these arrows coming from I'm
going to outside and the inside ones and
they are distinguished only by the
endpoints yes no those are all they're
all the same they're all the same thing
this is a youth that's the uniform model
it's communication how its implemented
potentially is different so here for
example this could be a communication to
fifo buffer in hue we treat a bite a
fine coat buffer as a pseudo box so it
looks like box it has inputs it has
outputs it does stop it's triggered it
does stuff okay so it's all part of the
same model and these connections these
are all wires time step yes absolutely
there is time everywhere in here okay I
thought you're going to ask you about
this arrow here this is a feedback arrow
but it's a feedback from one iteration
of a box to the next the idea that boxes
are working lockstep they do something
they take some inputs are based on the
inputs at some snapshot time they will
do some computation this is the
functional programming part and having
produced results they then feed them out
now the way that we insisted the systems
entirely stateless wavy model state is
by taking an explicit output and passing
it back in and this has some advantages
in terms of making time very explicit
but also in terms of making space usage
very controllable very explicit I'll
show you later perhaps but we
effectively get a kind of for free our
copy and compact garbage collector just
from doing this okay and moreover one
which has real time properties so
everything is controlled all the time is
known all the spaces name quite nice
properties
so from tony's talk essentially the most
that i've got is one of concurrency all
the boxes are in principle acting
together and exactly when they stop when
they synchronize it's party down to the
system ok I'm going to move on a bit
because I want to get to the semantics
which people want to see this is what a
box is you probably ought to ensure to
like jr. so basically this is for a
simple hand gauge this is something
which is synchronous of course so for
example we take a and B which boolean we
produce a result which is a boolean the
way we do this is by matchings as
functional like mashing syntax and for
example what we're doing here is say if
you've got to false input series false
input if you've got to true inputs you
pretty please true this is a very very
simple example of a box okay and
typically they're much more complicated
and typically there will be computation
here this is a much more complex model
i'm just showing no no absolutely i
don't i consider all the time that it's
taken to produce the result i'm
interested in the time from the
consumption of the inputs to the
production of the arm one step of the
box yes the North zero time absolutely
not serio time one step to the box so
boxes in Hulme repeat indefinitely so
the idea is the boss just sits there it
consumes input produce outputs until
there's no more input so termination
condition is there is nothing else to do
okay people they often talk about
termination analysis if you have a
real-time system if you have a system
controlling an aircraft engine you do
not want termination of the system this
is a bad property in fact I won't be
opposite I want liveness I do however
want to be able to demonstrate that
the code within the box terminates
within some known time this is the
essential fundamental fundamental
building block I'm going to use in my
language design the impression that you
can't detain for the boxes but the
propagation with zero kind is that
correct no propagations have time two
times as well they have time that's what
you said one you just said the phrase
something like one unit or 11 iteration
1 iteration but that doesn't mean you
assign it it's not an abstract all boxes
are not one right you know compute out
but based on the costs of things and
you're done at eight years and some
boxes may be thousands some may be one
what one is impossible pretty well
impossible in fact it's everything takes
some time which is more than one the
exact unit I will see later but
typically are what I think of is in
terms of clock cycles for time and
typical what I think of for memory are
small units bytes or words of memory
that's been allocated or used basically
this is behind thinking of with my unit
termination is not your issue but but
that think will end if there is no
import or if it is positive that there
is no input then the in should go not
into a ball that ball plus and live it
has very much than the box will simply
suspect there's no wonder there's no
there is no input no there it can never
be on deaf to reactive system right guys
never spire so as I either produced in
this situation either has inputs I
produced now push or doesn't does
nothing it's not undefined it's nothing
it's mentally nothing
and that would take zero time that would
take Sarah time okay here's Al it is
more complex example just to illustrate
some of the more powerful features of
Hume so here what I've got is simple
vending machine essentially what we have
we have a cash holder we put coins here
nickels or dimes into the machine are we
have a keypad to say i want to tea or a
coffee or whatever a hot drink is my
favorite type of drink there's a vending
unit that actually gives me a tea or a
coffee and the interesting bit is this
red box the control box which is the
logic of the system central logical
system so what's doing is taking button
presses it's recording coins that have
been input it has some internal value of
the coins that has so far and then what
you can do is either instruct the
vending unit to dispense the drink or it
can instruct the cash holder to return
coins if you said you want to cancel
your transaction and get back the money
you've put in so very simple reactive
system here's the complete definition of
that system in Hulme I show this to
Hardware designers that are usually
quite impressed by this so we have our
haskell aight certification of some
enumeration types that coin nickels or
dimes the drinks teasel coffees are the
buttons i can press coffees teas cancel
give me the money back here is the BOK
definition of the box so what I'm doing
is taking in coin checking in a button
taking in the initial value the results
the box is either is to dispense a drink
to produce an updated value internally
or to instruct the return unit
about money we use it will be by you
here's the complete definition if I get
a nickel what I do is to increment the
value by fine if I get join by 10 oh
that's right sure good
it's easier in the UK we have five pm-10
synthesis or I have a coffee or a tea or
cancel if I have a coffee or tea what I
do is I call the vend function this is
essentially an ology use the function so
we can pull functions we're goin balls
what I do is bend a coffee costing 10
with the current volume or a tea might
cost five and if i press the cancel box
well the new value of the coin of
internally 80 and I return the current
phone be and you can prove properties of
this Court's for easy to take this and
prove that you always get out money you
put in the two ways you never dispensed
more than the amount of money you've put
in you never dispensed if there's no
money and so on you can do this fairly
easily no no there should be another
input your your this this is a reactive
real-time system in ER in social system
everything which you need to consider
should be part of the state in a real
coffee machine if there is no coffee
there should be a sensor that tells me
that there must be a sensor okay I
haven't included that sensor here you
could you could extend model findings it
doesn't really make much difference to
the model but we have indeed looked at
similar systems with sensors allow
another input sensor coffee there is
coffee there is an incall me and if
there's no coffee wait until sensor has
coughing or the users or something
different if you don't include sensor
there are some people don't for reasons
of course or you just don't get the
coffee out
I've experienced these machines myself
it's a commercial design we don't have
Microsoft ah there's an interested so
you may have noticed these stars here
what stars mean is that what is
irrelevant do not consider that input
okay so this is an explicit this is
where the ace interest he comes in this
is saying this rule will fire even if no
button has been pressed this rule is
saying if you press the coffee button
even if the user isn't simultaneously
putting in a coin even their coffee this
is what you expect likewise on the
output where we have a star a star means
nothing don't produce anything zero cost
for that entity this way of saying don't
do anything still having a triple of
results okay how much is tragic really
good question they doing beat the answer
the answer is yes and the reason it's
yes is because I've use match keyword in
Hulme you'll to have the opportunity
fair matching and with fair mashing are
then the order is is a fair one I don't
go into the precise semantics that it
turns out to be pretty complicated and
not everybody agrees exactly what
fairness is but we have a model of
fairness if you want fairness you can
have it you don't want fairness its
design so simply by changing this
matched there you go to the fair design
but here we're going to take priority
over the coins coming in with all the
bottom presses from the model it doesn't
really matter too much except that I'm
having the coins coming in before we
before you try to dispense the coffee
probably results in less frustration if
there's a choice but that's a design
choice sometimes you want one sometimes
the other we have both
okay and then the vend function base
court said is check the cost and if you
have enough money in the system dispense
a drink take the cost away and don't
return any money user until they pass
the council you could if you wanted
return the change some machines do this
it's just a matter of logic you've got
here otherwise if there isn't enough
money don't give a drink keep the value
of it saying don't return any money to
the user and you could if you wanted a
sizable complex system here have a
flashing red light that said stupid user
you haven't got enough money or words
that in fact this is just a small
refinement to this basic model to the
basic design Sharon I don't understand
you're actually being stars and types
given frog is a source of time alpha it
can be anytime by the time for an
exception wait it's nothing something
it's getting a drink in what it's gotten
is a star what does it actually have
nothing so everything's kind of
implicitly lift it's not even a lifting
semantics no this is not even this is
extra not bad isn't it there there is no
value okay okay there is no value there
is no value in the domain there is
nothing that would not fire if you're a
boss or not fun watch isn't far what
does introducing out but it's nothing
hopefully nothing okay so now in the
implementation there is actually
something trip represent nothing that's
all part of the trike water pipes as
wires and box and star is being no
signal was sent on this one yes yes so
it's sort of it's a little more stuff on
the input I think more the input if it
was sent yes Yeah Yeah right right back
so if I make a mistake and put a star
somewhere I could sort of deadlock
things it's but it is it's possible to
do that it's actually it is possible to
deadlock him but it's actually fairly
hard because of the reactivity are you
usually if you have a deadlock it will
lock almost instantly and
normally what you see is that you've
consumed an input an opportune output so
just by looking at the input and output
traces you see instantly yes that's dead
long a subtle Vicky fingers today the
star going would say well you you know
this next guy is not gonna fire so I
would injure yeah being stuck yes its
stock it's not really a deadlock you
might be watching intent yeah sure sure
but yes no no no output ok I'm going to
move on because I need to go into
semantics and I go I've got about half
the time I think so um so we have a
mechanism for exception handling the
point about this is that the exceptions
have known cost the language designed in
such a way that exceptions have known
costs we also have a mechanism for
dealing with time exists in the language
here's another little example is taken
from villain glee it's digital watch
like what I've got on my wrist basically
number buttons and I respond the watch
it and the key thing here is that I've
got a check and here in streaming this
room I'm taking input from an external
stream if I don't get some input within
one second what I'm doing is basically
to trigger a chick so this is every
second does it take this feeds in using
the exception mechanism into the box and
box then press that updates the time so
you have a heartbeat going here in your
digital watch it's the triangles
built-in and these constructs can be
built into expressions as well as the as
well as the triggers the existence of a
within construct in into it sorry
initiates an analysis and the narcissus
will checked with the condition that's
been specified is met if not there will
be some exception so you have the choice
yes I can verify this if I can't verify
it then the implementation will ensure
that the condition you
his met by forcing some kind of
well-known runtime exception which can
then be handled within known time limit
space this is how we deal with real-time
exception handling within the system
okay what we're trying to do is to use
mattox approach what I've got is our an
abstract machine the human stract
machine what I want to do is to expose
the cost for abstraction instructions
correlated with real hardware costs and
time costs you use an abstract
interpretation tool this is absence AIT
tool from this is a small step semantics
from the low-level semantics what I do
is to construct a language level
cymatics that are big step semantics for
the language the basically tells me what
the execution machine is across multiple
steps of machine and this is correlated
with the abstract machine and there's a
full translation from the language to
the abstract machine level which has
been shown to produce the correct
results with respect to denotational
semantics of the language so we know
that the translation is correct it does
the right thing it has specific behavior
we can prove what the behavior is from
this we can then construct an analysis
are an automatic analysis that tells us
a priori what are the execution costs of
the human program get done fully
formally and proven to be correct
against the semantics okay so here's
what the abstraction is all about
essentially it's simple stack and heap
designs 40 all the things we need the
main purpose machine is not be
incredibly fast but to be predictable to
have known behavior you can all you can
always make it faster later but if it's
not predictable it will never be useful
for our purposes so that's the point of
the machine this is showing you the
internals the Machine essentially have
an instruction space here's the box with
some stack and heat plus some internal
memory all of these are bounded it has
some input and some wires these are
bounded the wires connected to other
boxes these that help us all of these
are buffers there is only one buffer
for each input in childhood so these are
fixed space so big space fixed time
trafficked Isis in a system it is really
in relation to a specific platform that
everything is going to work on the harsh
a harsh I there's an additional
information I don't want to dwell too
much on this they show you that there's
some sort of register model internally
with program counters things to handle
rules which deal with fairness and some
pointers to deal with matches example
plus a rather unusual ink pointer which
they're two handled stack frames and
Heatley's bounded our wire structure
very simple essentially just a fixed
size tell you where the input comes from
where the output goes to and some point
it into some memory where the actual
data is held it's very simple structure
fixed signs snap frames were using a
static link pointer approach so the idea
here is to link frames according to the
static scope the main of wash this is to
avoid lambda lifting at the top level
and this makes the cost of closures much
easier to predict in our system next
clue the cost of stack frames much
easier to predict we pay the cost of one
pointer in each frame but each of them
then is fixed signs if we have lambda
lifting then we may have variable sized
frames which are harder to deal with let
me show you about the machine
instructions this is coming on to what
you're asking about so here's a simple
description of the machine instruction
in a sort of pseudo see and I apologize
for those people who do this these
things more formally but this is the
approach that like then at orgasm have
also taken for defining their semantics
it's you can easily translate this into
something more formal if you need to we
have done this so if example if I'm
creating an integer a 32-bit integer
what I need to do is to set up a tag
time bring by you into the heat pointer
which is the tag these are boxed values
you can have on Watson's as well the box
something more interesting because he is
e the stack pointer is set point that
are there should be yes input to I so
I'm having the object in the heap here
the heap pointer is incremented by some
constant which is the amount of space
this takes on my implementation okay and
then I on to the next instruction and so
on for all the other things I this is
how we deal with chime handling so we
set up handless to do this are these
known units known primitives are there
are a lot more instructions in total or
about 70 instructions in machines it's
not completely trivial but all of them
have this kind of semantics as you can
see very low level with costs that are
easily derived at least some memory or
we need to do is translate our program
human thoughts down into that so here's
a compilation scheme formal compilation
scheme and for example you can say well
if you're compiling a integer what you
do is you omit the making instruction
integer and we can prove that has the
correct effect against the denotational
semantics and using the operational
semantics but I've defined functions are
a little more complicated I won't show
you those here at the rules dealing with
exceptions just show you that all these
things are dealt with it's part of the
language I'm quite proud of the
exception handling it was very tricky to
get right just show this isn't
completely stupid here some statistics
compared with an old version of Java and
ADA so source code r is 867 lines in
Java have a java implementation 234
those lines are real code wrestle type
definitions function definitions class
definitions
in Hulme 251 lines 51 of which are
coefficients wire languages in ada are
well we couldn't get the complete
program but the cores about 206 lines so
clearly we have something the object
code is about two thousand bytes for
Hume seven thousand bytes for the JVM
which was supposed to be quite efficient
compared and 12 k bytes for the ADA
compiled code so quite compact memory
requirements the code excursions code
took nine megabytes for the JVM using
our pressure i coom implementations it
took four hundred kilobytes on Mac OS X
it took 60 kilobytes on a bear grunt
real-time Linux system it's a very
comparable and it's about 12 times
faster than the JVM there's something
about weird going on with the JVM that's
not my problem I leave it to the
Microsoft people to improve it we prob
the problem it's just it's one example
which is it's from burns and Wellings
book it i think it's mine pump
controller and they only give the core
code after gosh controller because the
rest was just too complex in Java I
guess so there's just the core code for
us to compare with that's why I can't do
the complete comparison I'd have to
write another 600 lines or seven hundred
lines of Asia and I wasn't that excited
by it it wouldn't be a fair comparison
anyway but they're in the key the key
figures showed the root the approximate
it's just an approximate measure for
something simple example so what we say
with function programming approach
approaches is that the code is much
shorter typically we aim for something
like a factor of 10 shorter this isn't
point of factor of 10 smaller mass
because for having to deal with these
low-level constructs because there's a
lot of stuff in Hulme to do with a box
structure to do with wiring as the boxes
are as you have more boxes so of course
you have more overhead so there's a
design decision about how many boxes do
you have versus how big boxes get it's
some interesting questions about
compactness of representation versus
structure of a code numbers for a
natural ability shamash well in this
case on the back in this case on an x86
spots wrong real-time linux i took this
implementation and it's not quite
relevant to the talk but I took this
implementation and I ran it for 72 hours
over one weekend it's running on bare
metal with my predict with my memory
predictions and but there were no
incorrect memory accesses there were no
memory faults and every real time
deadline was met during those 72 hours
so it really is quite quite decent but
not not that fast okay predictable not
that fast bad 3 equals you can handle ah
I had boy um really mesh that we have
done some real time video we've got some
exams to deal with real-time video okay
so we can deal with real time video with
the right predecessor it's a lot its
antimatter matching the processor to the
application but saying absolute
performance isn't really what we've been
aiming at just at the stage this happens
to be a statistic hey there are obvious
parallels from what you have here in
some hardware description language got
any plans to do direct hardware since
it's just off the back of this because a
lot of the hardware folk would be very
pleased to
systems which were guaranteeing Harper
of time constraints and then performance
problems go away because it's just
running on an FPGA yeah yes yes actually
the target or is it it's a it's a
possible target and so we I don't really
have time to go into it but we have done
some work on basically cuts down
versions language that we call HW Hume
hardware Hume which is a good language
for describing these circuits and you
can indeed prove properties about the
timing and about these circuits there
are also other similar languages things
like lava are that satnam singh Mary
Sharon had been working on for example
that and hydrant that Charlie O'Donnell
has been working on and these have a
kind of similar feel when you cut it
down what you have to throw out of the
semantics you can you can basically cut
you can best piece you can still have
the heap the question is what what
appears in the hard way so you need to
translate the memory operations into
something which happens on the hardware
okay and this can be in terms of fpga
operations if you if you've got vhdl it
could be a netlist so it costs an
examples of that we haven't fully worked
that out all right so i can show you a
paper from a few years back where I did
it basically what you're asking but let
me go on to the semantics so humor
operational semantics and at the high
level basically what we've got is a
semantics where we have a stack and heap
FIFA stack age for heap way we're
dealing with an expression some form so
I'm looking talking here about the
expression semantics rockbox semantics
what this does is freeze me our label in
some new heap and this is whatever has
been allocated so for example in my
integer example what I'm doing is
allocating new object put it in the heat
and to update the stack location that's
what happens here so that the thing this
represents the top of the stack l is the
top stack after the execution of this
instruction of these instructions N and
n prime are the associated costs before
and after the step so what this task is
to help me build up costs semantics at
the language level so what I'm doing is
say I need this amount of stack heap
whatever before executing this
expression afterwards what I have is n
prime amount of stack heap whatever
simple example here's my rule for an
integer making an integer what I have is
I have a stack initial stack initial
heap I'm constructing an integer and
this is going to be like a label with a
label points to the integer N and then
what have to be sure of is that before
executing that instruction I have
whatever the cost of making an int is se
que ma Kent and you've leave that an
abstract here but for example if I'm
talking about stag this could be one I'm
pushing one thing on stand the heat
that's going to be whatever the cost of
the heat creation is and we have rules
for all of these this is an interesting
rule because what it's saying is you
have to thread the cost from q1 finish
cost is q1 we get back having executed
e1 some cost q2 this is fed through the
executioner of e2 and we get back q
prime the microcast k let 1k led to
these are costs that some machines might
introduce at each of these points some
of the compilation schemes might
introduce in terms of actual machine
instructions so all of these have to be
costed if you're just dealing with stack
maybe a lot of these costs are 0 but
we're trying to make this generic how do
you get the costs well we measure them
so here is a complete table you probably
can't read all of this from the back
but for example what we're saying is the
resource usage of muck int in some
context so engine busy protection
information to do something you ate the
instruction is whatever H is which is
costs I had earlier on in my semantics
my abstract machine semantics you can
prove correspondence of this with
machine semantics likewise this is a bit
bit big we can do the same for stack and
we can see the cost of the stag for the
Mackendrick is one these relatively
trivial costs some of the costs down
here are a little more complicated you
see this ensign conditions they say well
depending on context tell me what
instruction exactly or executing what
the parameters are these are more
complicated these have begun or lesser
cost but there is a complete cost model
for all the instructions that's fine the
train costs we've changed from the
actual instruction implementation and
let's say we use absence AIT tool to
derive these from the machine code
implementation to each instruction so it
is not for a program but on an
instruction by instruction basis so that
we can reuse the effort in doing the
costing we do the costing once and then
you can reuse it for any program and any
abstract machine implementation will let
you do this we have to do this each ham
instruction on every architecture that
we're interested in mostly it's tedious
sometimes it's very hard as having in
certain someone where I explained where
we had an architecture and we wanted to
know what the cost was of a floating
point assign operation and to do this we
have to prove one of the internal loops
in the library which was unbounded
actually had a finite cost and what the
limits were on that cost sound I've into
the instructions in the library integer
instructions in the library and
basically demonstrate what the cost was
of those instructions that was pretty
hard and very tedious it not a week or
two just one instruction ok so this is
not easy it takes a lot of effort a lot
of time but you only have to do it once
for each architecture and we verified
these times experimental e on some
actual machine architectures are
Renaissance n 32 c are a PowerPC 603 and
an FPGA architecture that we should
here's an example of the instruction
timings for one of these architectures
Renaissance m32 see so it's a real time
microcontroller it's a kiss machine why
you use so what you can see it's because
complete table are more or less complete
table for all things have instructions
and cost of our merchant turns out to be
84 84 clock cycles this will scale
according to the processor speed of the
particular machine that you're dealing
with and then from this what we do is
construct an automated analysis using an
amortization technique the idea of the
amortization is basically to balance out
the costs and so that I can prepay some
costs that I'm late against utes so i
won't go into the details hopefully
people roughly know what amortization is
anyway if not there are plenty of papers
about it what we do is we turn this into
a tight system so here's what my
analysis rules look like I have a source
expression which I'm analyzing I have
the type contacts gamma I have some type
a i'm durrani and what i'm going to do
is to work out the potential cost before
and after execution from my operational
semantics so basically analysis follows
the rules the operational semantics and
at the same time producing annotated
types within which there are constraints
on the types to tell me about the
execution costs from my from my
semantics ok and as you've seen this all
times down from the fiscal hardware all
the way up to this analysis sure you'll
be
now this is this like bankers method is
built in or how flexible are you about
the kinds of amortization you can do it
in particular it's a particular style of
analysis I'm not sure if Ricky based on
the bankers model you need to talk to
Stefan about that but you have that you
have only some types of amortized
analysis are analyzable okay so you have
to you have to do exactly what we've
done what if you help them basically
there's an hour waiting behind a type
system and dissatisfied you have to be
asleep this is the time system
underlying it there's an inference
algorithm the inference algorithm is
derived formally we have shown we have
Chen sounds that algorithm against the
time system so again this is awfully
full so here rules this basic is saying
that all the possible valuations satisfy
the constraints that I'm arriving don't
worry about the detail here this just
show you tights look like the key things
are that we're annotating function x
with potentials this analysis deal with
higher order functions in us pass costs
through different function calls and
we're also annotating costs constructors
so we can get potential costs relative
number constructors in the program
example of a rule here this very simple
one for the Mackenna for the inch case
what i'm doing is to derive the cost of
camo hint and there's nothing that hard
words I don't need to return anything
after that that slightly simpler version
of the operational semantics rule the
rule that binding again basically
threads costs through so in this case it
drives pretty well closely from the
operational semantics it's easy to show
the correspondence between the semantics
and this function rules are more
complicated I won't go into the details
here this took quite a lot of time to
sort out and one of the interesting
points is to do with some structural
rules which allow us to weaken the cost
in arbitrary situations so relax allows
us to
increase costs when we need to do this
for analysis purposes and sharing allows
us to capture sharing information so we
can split the cost between different
uses of the function for example or
different uses of a particular data
structure so these are two critical
rules that we have to use very carefully
get cost information out a simple
example reverse append what we do is to
run this through our analysis what it
does this goes back a type of giant says
here is the cost is too strict zero what
this means is that every and the common
for each cons and the input are we have
to pay for so what this is basic telling
us is that the heat consumption is
linear in the input size 44 times length
the input plus 2 okay and that is in
human words of memory here's a similar
example control box I'll just skip over
this for time reasons that just show
control box is perfectly analyzable this
one's interesting because it has some
alternatives are here so it says one if
the second wire is live zero wire is
void and x2 is one if the third wire is
life otherwise void so there's some
conditional costing going on in this
case just want to quickly show you the
results so this is for one example some
squares simple arithmetic calculation
here are the number of calls are this is
showing the heap usage the this is the
predicted narsus result this is what we
actually measured in some execution of
the human machine what you can see is
this is pretty accurate this is
something with unfold map and fold so
this is a higher order definition the
stack cost again is very accurate within
false and the chime is slightly less
accurate but still within
it's worth pointing out that the measure
cost is not necessarily the worst case
it's just the worse to be observed when
running the program a few times but that
is not a guarantee blast case it's just
measured worth takes over a few
executions doesn't mean the analysis is
wrong it simply means that it's allowing
some things that might not actually
haven't in practice this is again change
some results for higher-order functions
I'll just skip over that if you want to
be more about what we've done there's a
pople paper from a couple of years ago
this is talking about higher
determination of resource usage for
higher order functions it deals with the
stack the heat and the time together
with a companion paper from FM from the
same year it's also possible to extend
this to lazy evaluation it's quite fun
but I really didn't have the time to
show you that in this talk essentially
what it involves is fiddling around with
the idea of potential so we prepay some
of the costs of allocating a thunk and
then we share this according to the
semantic rules let's pay from sfp last
year about this or plank shoes to build
up a more in depth version of that that
has examples on the stack and the time
information in there as well oh just to
show you that Hume is quite good a
really does do real time staff I some
giving you an example here's one of our
little experiment that our colleagues in
France did this is an inverted pendulum
which is being controlled by this our
computer here this box in fact so this
is without whom it sort of flops about
uncontrolled and the version over here
is with whom and what you notice is that
Hume correctly maintains the stability
of the pendulum in the vertical
direction basically I'm by moving the
motor around it's only controlling two
degrees of freedom the third degree of
freedom as you can see is unconstrained
by this particular model that the entity
of some warm
bet we weren't trying to control that we
could keep the pension vertical in real
time well it's very good happy I'm not
sure the model I'm not some model
accounts at that age you need you
probably need a more complicated model
if you can recover from it then it will
probably recover from it you'll see the
deviation and it will attempt to recover
but I'm guessing there's thinking be
some sort of feedback loop a stat
stabilizers maybe you can never get it
back depends on models that you're using
this is a PID controller model so
conclusions and what I've done is to
show you a cymatics based language
definition of Hume the bounded time
space are we have semantics all levels
so we have a static semantics are we
have generational semantics we have an
operational semantics abstract machine
semantics a formal compilation scheme
all of this is proved correct at all
levels and there's some sort of Isabel
model of this city needs to reasoning to
reason about our resource consumption as
well so lot stuff lots Maddie's down
there very good formal cost models
dealing with our dynamic memory
allocation exceptions recursion
higher-order functions lazy evaluation
and these are extensible so we've dealt
with stack time and heap allocations are
but they can be extended to deal with
power for example and they are in
principle applicable to other languages
too so it's not just Hume this applies
to of course you probably need a
similarly strong semantic model for all
these other languages to make them work
effectively that's not the story here
are things that we're interested in
doing are firstly couple of relation
piece of work nonlinear balanced been
looked at by hoffman Eric and Hoffman
last year to proper 2012 I we straight
forward to incorporate those into the
cost model nothing intrinsic about this
restricts it to linearity in terms of
the cost bounds Brian Campbell is in the
audience has an interesting mechanism
fifth step who can improve the cost for
stag we haven't incorporated that yet
interesting to do that possibly in this
mega paper but we plan to write in the
near future I've shown you allocation
not reclamation in fact i mentioned
start that he match has quite clever
scheme because when we ask you to box
what happens is we consume input we
process it we produce output on wires
the input wires and the output wires are
fixed signs having produced the output
we can throw away all the heap and stand
usage within a box essentially what
happens is the heap within the box is
copied it the values that our life are
copied from the heat within the box to
the wires if we have state we feed them
back so you get an automatic as I said
copying compacting garbage collection
with inbox iterations which we can also
cost in real time it's a quite quite
neat mechanism you might still want
garbage collection because within the
box you might be writing recursive code
ok so then you might want some garbage
collection within the box Martin Hoffman
has looked this recently using a
region-based mecca's and I dropped some
work on region-based allocation it looks
entirely plausible to put that in if you
want we're also looking interested in
multi-core many-core so what a shame is
highly concurrent easily applicable to
easy scalable easily applied to
multi-core many core architectures and
the lazy evaluation work of course
obviously we want to target Haskell
eventually to show that hassle is
costabile some more papers if you're
interested reading them here's why I
think that's irrelevant to scalable
language specification well humans
scalable so it's a scalable language
that has been specified sorry patient
but also are a lot of things we've done
ought to do with semantics there to do
compositionality scaling these issues
are all critical to scaling so I think
that's why what I've done is relevant to
this workshop so thank you to our
sponsors
and thank you for</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>