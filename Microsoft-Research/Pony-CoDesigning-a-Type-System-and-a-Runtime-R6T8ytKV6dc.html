<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Pony: Co-Designing a Type System and a Runtime | Coder Coacher - Coaching Coders</title><meta content="Pony: Co-Designing a Type System and a Runtime - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Pony: Co-Designing a Type System and a Runtime</b></h2><h5 class="post__date">2016-08-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/R6T8ytKV6dc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year Microsoft Research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
okay so let's start so it's my pleasure
to introduce Savannah Savannah Claire
who is where certain effects industry
experience about distributed programming
and we is also completing it as a PhD at
in Carroll College and is going to tell
us all about the Pawnee farming oh great
thank you first of all thank you
everyone for coming I really appreciate
it
um whoa sorry so I'm gonna talk a little
bit about pony today my background is
I've been industry programmer for too
long and worked on too many things most
recently has been in the finance
industry which is as strange and wild
industry and all of these things that
I've worked on for my career have some
things in common first of all is their
performance critical when they benefit
from concurrency which is pretty
straightforward the other is that most
of them are actually distributed systems
even if I didn't know that when I was
writing them which is sometimes
problematic in hindsight so my current
work is on pony which is an actor/model
language native language and it's
designed to scratch my own age basically
this is a language that I wish I'd been
programming in for the last 24 years so
I'm going to dive right in I'm going to
cover mostly type system stuff and
garbage collector stuff stuff that's
interesting
towards the distributed computing work
on Pony that I'm doing now some of you
might get a little bored there are
people in this audience where their work
is foundational to Pony so I hope you
don't get to boredom so right so let's
start with this this is about the
simplest program you're gonna write in
Pony it's the straightforward program
let's talk first a little about the
goals statically data race free but with
mutability no stop the world garbage
collection is really important that's a
performance bottleneck for a lot of
systems these days formally specified
that's not the same thing as formally
verified of course I'd love to get into
verification work but
not where Pony is yet single node
performance needs to be competitive or
beat C and C++ we've done that's
actually in the bag that's something
we've nailed distributed computing is
really our next step is being able to
scale this across clusters with a single
program so people often ask me what are
some types of programs you'd like to
write and pony and the answer is
gigantic list right some of these are
things that I would that I've written
that I wish I'd written in Pony video
games particularly other is stuff that I
have actually already written in pony
there are financial systems written in
pony stream processing systems in Pony
sum quite a bit of low power device
software written in Pony interestingly
so as I said before there's a lot in
pony it's actually in production it's
not just an academic language so that
means there's a lot of things I'm not
going to talk about today but hopefully
this is all stuff that most of you would
take for granted anyway generics
intersection types various types of
subtyping pattern matching but some of
the stuff in the runtime that I won't
touch on unfortunately is things like
scheduling work stealing things like
that but I will touch on the garbage
collector so we're gonna walk through
quick some of the things in that example
so the first is we'll see that when we
created the main actor to start the
program we passed it in passed in an
environment and that's because pony is a
capability secure language we have no
global state and the possession of an
address the possession of a reference to
an object is the authority to use that
object right and that means to avoid
ambient Authority where that Authority
permeates a program it means everything
has to be explicitly passed to the user
so standardout is part of the
environment and if we want to print the
standard out we're gonna have to have an
environment to print deal so capability
security is an operating system concept
that comes from the 60s minaton as much
press as it deserves Mark Miller has
probably been the most prolific author
on object capabilities lately but it
really expanded to languages with E and
ambient talk and kaha now SES on
JavaScript is implementing optic
capabilities in Java
which should be pretty interesting God
did that as well but in a much more
restricted way so Pony is a no cap
language and and is a no cap for the
initial environment really
straightforward but what Pony does it's
very different from these languages as
reference capabilities object
capabilities are about security and
authority but they're not about data
race freedom or any of these other
interesting properties so for example
the immutability of the environment is a
reference capability in Pony I'll expand
on this as I go so the actor model and
Vout is an actor it encapsulates
standard now so we're gonna instead of
locking or anything like that we're
gonna send a message we're gonna print
by send sending the message print and
sending the string hello Cambridge
straightforward stuff simple message
passing so this all comes from a long
history of actor model research Carl
Hewitt said Jake is sitting right there
and the other languages that our actor
model are yeah sure Erlang he ambient
talk javascript javascript is an actor
model language as well as lots of actor
model libraries so oh I'm actually
stopped here for a second one of the big
things you'll see is that we don't see a
lot of typesafe native languages on this
list which is interesting that's not
been something that's been explored very
much so why is it safe to send a string
because it's immutable right
it's a globally immutable string load or
literal in this case that's Val the type
of it is string Val and it's safe to
send those because they're no data races
on immutable data that's great but we
want to be able to send mutable data so
here's an example this is examples from
the standard library mostly so this is a
TCP connection then a TCP connection
needs a notifier and that may actually
contain mutable state because you're
doing put a stateful protocol decoding
for example so we need to be able to
pass in something that's isolated it
needs to be mutable but we need to be
certain that no other actors can be able
to read from it or write to it or else
it wouldn't be safe for us to write to
it so that's good
isolation for data race-free mutability
straightforward be
we can send it in a message because of
the guarantee that there are no other
aliases to this that allow reading and
writing and aliasing is the real key
behind reference capabilities there's
another thing that we could send in a
message we could send a tag we can send
the identity of an object without the
capability to either read from it or
write to it and a classic example of
this is an operating systems set of
hierarchical timing wheels right where
you need oh one cancel on timers it's
critical for performance so I'm going to
send in an isolated timer that needs to
have the possibility of having mutable
State it may not need it but it needs to
have the possibility of having mutable
state that it can mutate one at time or
fires but you want to be able to do oh
one cancel you want to be able to refer
to that timer by identity later and ask
for a cancel this is safe to write to
send a tag in a message because we're
not allowing read and write and a tag is
a is compatible with an AI cell you can
have an alias of an I so as a tag it's
because it doesn't allow reading or
writing to the object so an opaque
reference isn't gonna be the source of a
data race so that's good we can also
type actors using tag so sending an
asynchronous message to something is not
reading from it and isn't writing to it
so it's safe to do that with identity
only that's quite interesting because it
means that the actors themselves your
units of execution are actually part of
your reference capabilities type system
so here we see an example of a behavior
which is an asynchronous method B and it
executes but something interesting here
is when you receive that message now
your typed as rath immutable type sort
of a standard object-oriented language
style mutable type except with the
guarantee that you know that no other
actor is going to be able to read from a
write to that instance and so the actor
can go ahead and mutate its state and do
everything it needs to do very typical
actor model programming safely so the
golden rule of data race freedom right
if I can write to nobody else can read
from it in the corollary if I can read
from it nobody else can write to it
that's good there's a lot of existing
data arrays freedom work this is a
lovely field with lots of good stuff
happening pony is not invalidating any
of this work right it's building on all
of this probably the papers that have
been most important are the three at the
top the others are much more restrictive
in the way that they treat isolated
state in the sense of requiring a
certain shape to the to the data so one
of the big differences is that pony's
reference capabilities are built on the
concept of denying rather than allowing
so instead of saying this is a
capability you know lets you do this set
of things it says the existence of this
alias means that there are other aliases
that we know can't possibly exist and it
appears to be that maybe this is more
fundamental than permissions so here's
the nitrix this is great fun so here
we've got the things that we're gonna
deny globally and the things that were
going to deny locally and you'll see
that some of these are empty because we
can't deny locally what we allow
globally local execution is a part of
global execution and there's some
properties before I actually talk about
the reference capability I want to talk
about the emergent properties because
they're pretty interesting if you can
deny global read and write aliases then
your mutable right it's safe for you to
mutate because you know no other unit of
execution no other actor is going to be
reading from that so you will still
maintain data consistency right not just
a Therese freedom but complete
consistency similarly if you know that
you deny global write aliases then you
have a form of immutability it may be
global immutability in which case that's
great this is an actual proper immutable
object or may simply be local
immutability meaning i can't mutate
through this alias but i can't guarantee
you that there isn't some other alias
held by the same actor that could mutate
the object i can guarantee you there
isn't one held by a different actor so
that's sort of like a c++ constant style
behavior where you're saying I'm not
gonna change it here but God knows
what's gonna happen elsewhere alright
and then the last one is opaque if I
can't make any guarantees then this is
just a capability token the other one is
these ones in italic
the diagonal here so in that little
intro on some different message types
that are sent there everything that's
sent is on us on the diagonal and it
turns out when you deny locally the same
that you deny globally then you can send
that alias that that reference in a
message yeah yeah absolutely
you know you do exactly so every every
every reference that's why it's called
raffle capability it's an excellent
question so that's why it's referenced
capabilities every reference has one of
these annotations so a data structure
does not inherently have a capability on
the outside of it so a class doesn't
inherently have a capability I could
have an isolated instance of it or an
immutable instance of it but it's fields
yes absolutely yes
so the field has one and this leads into
something that I'll talk about in a
little bit which is a viewpoint
adaptation that's a fantastic question
because this is very important for the
idea of saying how do I see something
that's inside some other data structure
because that the reference capability
that I'm looking through is critical to
that right that's gonna modify it all
the way through absolutely thank you all
right so right so and then it turns out
that we end up with a set of six
reference capabilities as far as I can
tell these are fundamental it'll be fun
and interesting to find out over time
whether that's really true or not
so isolation immutability and opaqueness
are pretty straightforward
refa straight forward to a mutable
object and box while relatively horribly
named is still pretty straightforward
it's a black box you can read from it
but that's all you know about it you
can't make any other guarantees about it
and I'll show you why I'm the next slide
transition is appears to be a new form
of uniqueness which is write unique as
opposed to read and write unique at
first I thought that this was
essentially a useless capability and
I've since been shown by other
programmers that it's quite useful
indeed to have something that's right
unique but not reading eek which is very
interesting so talking about box for a
second um a dream Coulier writes a great
blog called the morning paper he does a
review of an academic paper every single
day it's pretty astounding and he did a
few reviews on some Pony papers and he
covered the reference capability type
system and he drew this himself and I
asked him very nicely if I could use it
in my future talks and he agreed what he
did was pull out something that I'd
failed to put in the paper that had been
in my initial work but hadn't been in
the paper which is the concept of
compatibility given some alias what what
aliases are compatible with it and this
is fairly straightforward if you have
something isolated you're not going to
be compatible with anything except the
tag right that's not that complicated if
you have something that's globally
immutable there's going to be no way to
write to it the really fun bit is box
but it's certainly compatible with local
retail this isn't certainly compatible
with tag aliases yeah yeah so compatible
I'm sorry thank you
compatibility meaning it is possible for
these aliases to exist in your program
simultaneously yeah so for box but they
could absolutely yes at a particular
moment in time because I might have
something isolated and then give up some
of those deny properties and make it
globally immutable make it a make it
make it a valid type so they may at
different points of time exist but in a
given point of time you can be
statically sure that only compatible
aliases to the same object exist without
introducing reasoning by time so right
so box is either compatible with
something that's globally immutable or
compatible with something that's locally
mutable but never both simultaneously
and it turns out a lot of the code you
write wants to deal with with references
in exactly that way so viewpoint
adaptation
coming to the question so viewpoint
adaptation is just a question of as was
said that you need to be able to look
through an object and see something and
here we have a sort of an interesting
type this is another example from the
standard library which is how you pull
something out of a hash map where the
key here is how some readable type sees
the key and not only that it's an alias
of the type that a readable type when it
would see when it sees the key and that
ability to specify aliasing and
unalienable in terms of writing complex
standard libraries and similarly it
returns a value that's modified by the
receiver now in this case because we
haven't specified a type capability for
the receiver you can put one right in
between the the keyword fun in the name
of the of them method they defaults to
box so we're going to say this is
something that we can do on any readable
type and it's going to return us
something that as its modified by the
receiver just an annotation note this is
a partial function because there might
not be something in the range for the
ailment in the domain and that's how
Pony deals with exceptions is to
consider them partial functions so if
you can do a liasing you also want to be
able to talk about unalienable for the
unique types read and write unique
isolation and write unique transition
types because it lets you say not only
is this object isolated but I've
consumed the isolated reference that I
had so I'm passing the one that if you
assignment to something it remains
isolated which is a big distinction to
saying I'm simply passing you a
reference to something that's isolated
but if you assign it to anything and
aeleus it you're gonna get a tag you're
gonna get an opaque reference so for
example when we update a map when we get
the old value we get an ephemeral with
the little hat of the value in the in
the map or possibly none if there was
nothing in there it's a outbreak data
type system under the hood I often tell
people that pony is object-oriented
because it makes them comfortable it's
essentially a functional language
so here's an example of a femur a Latino
what I mean by saying something what you
can assign so here we have some ant and
a hashmap of aardvarks and we're gonna
look up Bob and we're gonna give Bob an
ant to eat that's fine
because even though it's as a collection
of isolated aardvarks we're not making
an alias to Bob here right this is okay
the reason it's okay is that we're
passing only sin double types into this
method if we wanted to pass something
that wasn't sent above we want to pass a
mutable object into that method to Bob
then we would be violating that in
isolation boundary there's an isolation
bubble there that we would be violating
but it's okay to do it here because ant
is about global you made a ball but the
next one the next one is bad right we
can't look up Bob in that map and keep
an isolated reference now we would have
two isolated references to Bob so that's
illegal the next one's fine we can have
a tag alias to Bob as a little that's
compatible with the isolated alias in
the map and the really important part is
the last one also being fine here where
we remove Bob from the map the type
signature on remove tells us that we're
getting an ephemeral V so in this case V
is aardvark I so so we're getting an
aardvark I so ephemeral and when we
alias it we know that we still get an
aardvark izo and this gives us static
alias tracking which lets us enforce our
to my guarantees and lets us do it with
local reasoning only right we don't need
a big global static analysis pass
through the program we can do it all
through local type checking
so Pony is formalism at the root there's
been a tight feedback between research
and development on it I say here that
the formalism has improved the
implementation that's absolutely true
the implementation has improved the
formalism more truth and I thought it
would be actually in the beginning there
have been several places where we've
found that a performance optimization
turned out to be a fundamental change
the formalism and I'll talk about a
little bit about that and talking about
the garbage collector so that this does
mean that pony has an actual operational
semantics this is the operational
semantics modulo pattern
so the pattern-matching hasn't been
formally specified yet and they formally
specified type system we have a hand
proof not a mechanical proof that the
reference capability system is sound
hopefully we'll get a chance to do a
mechanical proof on that as well so
leveraging the type system in the
runtime so for me as a software engineer
I've come kind of late in life to
computer science to be honest but as a
software engineer I'm I've been very
performance focused and it turns out
that type system is far from being a
matter of correctness in my mind are a
matter of performance that not just the
guarantees that you can make at the
program level but the Taran T's that you
can make it the language level the
changes you can make in the actual
language runtime because you have
enforced certain type system properties
and for pony the interesting one is data
race freedom and so in the run time what
can we make faster due to data race
freedom and it turns out basically
everything right this is a catalogue of
the runtime there's a few things that
aren't in there but nearly everything
the actual underlying runtime
implementation is directly influenced by
the type system which is fun I'm going
to mostly talk about garbage collection
that's what we've been publishing papers
about there's some very interesting
stuff in the other elements but I'm
gonna concentrate on this so we're gonna
start with per actor heaps like Erlang
that's good we can use a mark and don't
sweet collector that's super efficient
right we're not going to ever touch
unreachable memory when we do a sweet
sweet face cuz we don't have a sweet
face that's great not incremental non
generational non copying that's a lot of
overhead that we don't need because
we're collecting individual actor heaps
which means we have a in a system that
typically you can run million ten
million 100 million actors in a single
program you get incremental in
generational collection essentially for
free by having per actor heaps but now
we get into the really fast stuff no
read barriers no write barrier is no
card table marking the pointer fix ups
this is a lot of overhead that
traditional garbage collection systems
have and as long as we can deal with the
fragmentation problem which we do in the
underlying pool allocator saving on this
is a huge win
performance but if we have data race
freedom we want to be able to pass
references between actors by pointer we
don't want to copy them if we copy them
essentially we've given up all the
performance benefits that we get out of
per actor Eve's so how are we going to
prevent premature collection when we do
that and how are we going to do it
without synchronization and that means
also no round-trip messaging right as
soon as you have a round-trip message
you have a form of synchronization we
don't want that we don't want that level
of coordination so we have is a protocol
called Orca which is object reference
counting for actors it's a variant of
deferred distributed rate distributed
weighted reference counting but every
time I say reference counting I feel
like I really have to clarify that this
has nothing to do with the shape of the
heap so if you do assignments in the
heap or her or mutate an actor's heap
and change the shape in any way that
doesn't change reference counting
reference counts only change when you
send and receive messages okay how it
works so when an actor sends a reference
to an object that it has allocated it
increments its local reference count for
that object it knows that somewhere out
there somebody might have a reference to
it it doesn't know who and that's
important that you don't have to keep
track of who but it knows that it's been
done similarly if you get one back that
you allocated you decrement the local
reference count right and those work
exactly in Reverse if it was allocated
on someone else's heap so if it's
allocated on someone else's heap and you
receive it in a message you say yeah I'm
the receiver of that incremented
reference count I'll pop it up by one
and when I send it away I'll lower by
one I've given up a reference okay so
the court sure yeah to one of its own
objects yes yes okay
many decrement its own reference count
right and there was a third bit remote
actor gives up the reference in the
sending back work once it came you can't
let go of it it doesn't actually does it
just lets go of it sorry that I was
misleading there apologize
I ever get to hear that it's been
decrement fantastic that's this slide
that's exactly the the perfect question
because it's actually there's two core
problems in there not only how do you
get to know that it's been decremented
but what do I do if I want to send a
reference to a remote object and I've
run out of references if I receive it
once and I want to send it twice or if I
want to send it once and keep a
reference in my own heap what do I do
because I need to be able to invent a
weighted a new weighted reference count
to it I need to be able to do that
without a round-trip Coordination step
so what Orca does is it says we're gonna
leverage the fact that on a single node
messaging is causal right in other words
if a sends a message to B and then a
sends a message to see if in response to
the second message C sends a message to
B it's guaranteed to arrive after the
first message and that's trivially done
on a single node for free it actually
has no runtime cost in a distributed
system we'll see that this is would be a
very bad idea to rely on and there's an
exception to the protocol Anna
distributes system relying on causality
leads just tree structured networks and
ole log n latency which isn't the worst
thing in the world but it isn't great so
we can do this without causality in the
distributed setting so we're gonna we're
gonna leverage that and so what we're
gonna do is when we want to send out a
reference to an object and we've run out
of local reference count for it we're
just gonna invent some and we're gonna
send a message to the owner saying we've
invented this many references and we're
gonna send it before we send the
follow-on message the actual message
that we intended to send in the first
place
and what that means is if the the
destination actor of our message sends a
decrement message to the owning actor it
is guaranteed to arrive after our
increment message okay
so that gets to the second part of that
question what do you do when you no
longer reference an object that's fine
you detect that during garbage
collection of your local heat you say oh
look I have some reference count for
stuff that never appeared in my heat
I never marked it so I'm gonna straight
decorative messages to the owner sure
what missing she's probably gonna see ya
see ya
yes yes yeah which it turns out is its
again this is about this confluence of
the type system in the runtime is
actually free to implement on the run
talk it's literally zero runtime cost to
implement that guarantee and I'll cover
the changes for distributed garbage
collection in a little bit because
that's a very good point all right so
this is these are the invariants local
reference count and the orca message
count which is to say the collection of
increment and decrement messages for
some object are always balanced by the
foreign reference count right the local
reference count being the object the act
of that allocated the object and foreign
reference count being all other actors
and the application message count which
is to say how many messages happen to be
out in the wild that contain a reference
to this object and that always holds and
it means that in the presence of a data
array story type system and only in that
in the presence of a data race tree type
system we get this cross actor cross
heap garbage collection with very cheap
amortized messaging with no coordination
phase which is fun
what a great question so I'm going to
cover that when I talk about collecting
actors but I'll talk about it a little
bit here for collecting passive objects
the objects don't act because of the
shape of the heap doesn't influence
reference counts objects don't have
reference counts for other objects only
actors have reference counts for objects
because just because I've assigned
something to the field of the object
doesn't change its reference count it
only changes if it's sent or received in
a message that's an excellent point
because having a cycle problem with
reference counts would of course make
this incredibly slow and basically
useless but because we don't have any
cycles on reference counts we don't need
any kind of cycle breaking or cycle
detector or anything for collecting
passive objects but you're absolutely
right that there is a problem and the
problem is going to come on this slide
just one more forward so yes so this
gives us these this no stop the world GC
step GC for passive objects unless now
cover for why it works for actors in a
minute so the combination is we get rid
of all of those GC overheads and we have
no stop the world phase and when you do
benchmarking boy getting rid of that
stopped the world face and getting rid
of those hard old generation collections
and getting rid of card table marking
pointer fix ups this makes a huge
difference for performance but let's get
back to this super important point if
we're gonna collect objects like that
how we're gonna collect the actors
because we don't want a system that says
you have to manually manage actors
admittedly and other actor languages you
do have to many other men and manage
actor lifetime you have to send them
poison pills you have to keep track of
when you might black hole messages it
can get very complex but we want a
system that can determine when an actor
not only has no work to perform but will
never have work to perform in the future
and automatically garbage collectors
actors who want ice safe semantics so to
do that we need a cycle detector and the
reason is exactly your point about as
soon as you have this reference counting
situation between actors now as a
reference to BB as reference to a what
are we going to do we can determine that
they've blocked but they're never their
reference count
never going to drop to zero so we need
to introduce a cycle detector and in
Ponyville the cycle detector is itself
an actor and it detects isolated graphs
with blocked actors the problem is that
topology is always out of date and it's
not just out of date it's really extra
out of date because when an actor blocks
it reports its own view of the top of
its topology to the cycle detector right
so the cycle detectors if you will be
out of date compared to the actors view
but the actors view is quite likely out
of date with reality because it's not
gonna actually examine any message
queues or any other actors it's just
gonna look at its own own topology as it
sees it in order a reporter to the
second detector no because obviously
that would be a problem
so when an actor's message queue is
empty and it gets rescheduled and it's
still empty and it can successfully mark
its message queue is empty by setting a
little bit in the queue which means that
no one else is marked as no one else is
posting a message in the meantime only
then will it report to the cycle
detective that it's black block yeah
yeah - to scheduling turns out to be an
OK heuristic I think it actually needs a
little bit of improvement there are
cases where you get too many block
messages it's very artificial benchmarks
that do it but I think those artificial
benchmarks might have some real-world
use cases so what we want to do is
verify that the topology that the cycle
detectors received was correct at the
time that it's sent so what we're gonna
do is we're going to have this
confirmation and acknowledgment protocol
that we build on top of the cycle
detector it's very simple when the cycle
detector perceives an isolated graph it
sends a confirmation message to every
actor in that isolated graph with a
token that it's just a number that
happens to indicate that received cycle
so it does it on the basis of the basis
of the out-of-date topology that the
actor reports when it blocks it says
here's what I think my reference count
is and here's what I here the reference
counts I believe I hold for other actors
which turns out to be a nice
pack data structure it's inevitably
mostly a wrong data structure so we need
to do is once we have an isolated graph
determine whether or not they were
correct at the time they were sent
without reasoning by time or going doing
any kind of rewinding or anything like
that so what we do is we send out this
confirmation message and it says I want
you to confirm number nine just some
number that it uniquely identifies the
token it's actually just a monotonically
increasing number when inactive when an
actor gets a confirmation message it
just that goes back an acknowledgment
miss a message with the token nothing
else no logic and importantly it does
not consider itself unblocked if it
receives a confirmation message right
any other message unbox the actor but a
confirmation message doesn't the fun
part here is that when a cycle detector
receives acknowledgment message from an
actor without having received an
unblocked message in between then we can
prove that not only is the cycle
detectors view of that actors topology
correct but it was correct at the time
that it was sent which is pretty fun so
we not not only have we done queue
clearing effectively in a software
engineering sense but in a proof since
we know that this topology was correct
at the time it was sent so once we get
an acknowledgement message back from
every actor in the isolated graph we
know that the the topology for the
entire graph was collected was correct
at the time it was reported and
therefore it's a true cycle and we can
collect it okay so why is this efficient
the number one reason is the messages
are cheap so a sending a message in
ponies a single atomic operation which
means you're talking about depending on
your platform 5 to 15 nanoseconds of
overhead for sending a message the
second is block and unblock messages are
processed in a deferred manner by the
cycle detector that's really important
if you do too much work on every block
and unblock message you receive and you
try and detect cycles every time you get
a change in topology then you weigh down
the system but if you treat it is as
exactly what it is which is a garbage
collector and say that it's not
important that it runs now
just important that it runs then you can
do this in a deferred way and there's a
core problem you may spot there which is
what if no more messages are generated
and you've deferred and the answer is
that it turns out the scheduler threads
are actors - in podium and when all of
your scheduler threads are blocked they
send each other messages and the same
contact protocol to do quiescence
detection so that your scheduler threads
can quiesce before the cycle detector
has it has collected all actors so it's
truly just garbage collection not
termination that we're doing with a
cycle detector in termination can be
done by my scheduler quiescence and
happens nice and fast yeah yes it is
exactly so that's a very very important
point in pony actors are non-pipeline so
every actor behavior behavior every time
it handles a message that's a logically
atomic operation it can't witness any
mutation during that behavior that it's
not itself performed and it won't start
processing handling a new message until
it's finished that logically atomic
behavior and so it turns out all the
overhead from manually managing actors
is generally speaking more expensive
than doing this automatically
compared to you know main limit actor
man a management in Erlang or akka or
other languages so development status
everything so far that's all real right
this is in use this is in production we
run on lots of machines raspberry PI's
4,000 core SGI's mostly to be honest 64
cores Aeons is the usual deployment
platform Windows OS X Linux FreeBSD
mostly developing on Windows and OS X
and deploying online ik seems to be the
pattern in real world use performance is
competitive with scene C++ on a single
core and often significantly better as
core counts go up and we have nice actor
model algorithms that scale scale well
one of the big advantages of having a
native languages that we actually can
exceed
see performance for most sequential
algorithms and the reason is entirely
down to register allocation to some
degree it's a question in lighting and
other compiler optimizations but
register allocation turns out to be a
huge one being able to do register
coloring across a much larger set of
code so let's talk about the distributed
work this is what I'm actually working
on now this is the stuff that's not done
one of the most important things in the
design of Pony is making sure that the
distributed semantics are the same as
far as the programmer is concerned as
single node semantics we don't want the
programmer to write a program and then
say okay now I want a distributed
version I have to write a new program
essentially you want to say I wrote a
program I'm gonna run around a single
core I'm gonna run it on 4000 cores I'm
gonna run it on 4,000 nodes and do it
all with the same program source code
wise so what changes when we go from one
node to many nodes okay one of those is
a type system for machine specific data
it's absolutely fine for me to send a
32-bit integer to some other actor right
that's an immutable value no problem
what if it's a file descriptor now we
have a problem so we need to extend the
type system with the concept of machine
specific data we also need a concept of
node failure right on average in a
distributed system you have failed nodes
what's the chance of a fail now one
distributed GC there are some
modifications for collecting actors in
this image is setting it turns out we
can collect objects in a distributed
setting without modification which is
interesting and then there's distributed
work-stealing how do we migrate actors
how do we know it's a good idea to
migrate an actor to another node so the
Machine specific data stuff is pretty
straightforward a type system annotation
can mark an individual reference as
machine specific data you say okay this
is a file descriptor that's fun and what
that does is pollute any type that has
that as a field that's then becomes a
machine specific data type and you can
only send machine specific data types in
messages to local actors actors that you
can prove not
we are on your node but we'll stay on
your node because it's no good setting a
file descriptor to an actor that then
gets migrated onto another note right or
an OpenGL handle or anything else it's
machine specific so those two types
those two annotations work together
pretty well the file descriptor in one
actor can send messages to the actor
absolutely yes funny you see you soon as
you go to actors with the same file
descriptor or the same OpenGL there's a
whole lot of pain about the voice
hazards and so forth on you absolutely
and do that because how can you prove
that you're not doing it as you take any
bit pattern right so it what I want to
do is prove statically ahead of time and
be able to show the the programmer that
they can't do this that idea so you're
gonna prevent people doing that abbis on
okay I thought you were gonna send these
things from one to the other well it
turns out you can under some
circumstances in some cases perhaps
someone's gonna get some use out of that
but the primary purpose of this type
system is prevent you from doing exactly
that yeah yeah it turns out there's some
right so proving that you can do that
turns out to be yeah okay there are
cases where you can prove that that
would be acceptable just really bad
programming practice but won't cause a
problem but the the purpose of the type
system is prove that I haven't
accidentally done that in the
distributed setting yeah so yeah so
showing locality this is about permanent
locality right and this means you can do
things like have a an actor that manages
IO and it's permanently resident on a
given node and then we have some
interesting concepts about I want to be
able to log to that actor okay well what
sorts of things can you log to the
logging actor if you're running on
another node well you can't log machine
specific data because it's running on
another node but you could log machine
specific data if you were running on the
same node but again why would you do
that the point is to make sure that you
don't accidentally do it
node failure so your nodes are down
right by definition so there's been tons
of research on approaches to this
there's really great work out there
there's stuff on our
persistence and it turns out we're just
gonna copy Erlang it's a little bit
different from erling because Erlang
actors fail for all kinds of reasons
because it's dynamically typed and pony
actors only fail when the node explodes
right I was talking to Joe Armstrong at
a conference in November at code
national London and he says your type
system is really fun and it's really
interesting but how does it protect
against a lightning strike it was a
great way to talk about node failure and
the answer of course is that it doesn't
and you need monitoring and you need
supervision the fun part is is when you
can expand that to a type safe language
it means that if you get if you've
registered to be notified when some
actor disappears you know it's only
disappeared because there's been some
kind of hardware failure whether that's
a network partition or an actual node
failure and that means that how you
carry on from that point is really an
application-level decision which is
pretty neat it means that if you have a
network partition the application can
decide whether it wants to carry on
given that it can no longer reach this
set of actors or in what manner it's
going to carry on and in some ways
that's punting and putting the problem
on the programmer but actually hopefully
what that really is is is a much more
flexible approach that says you can
design recovery strategy that's specific
to your application so distributed
object GC turns out because of a data
race free type system you get this
almost for free every node can collect
passive garbage locally on that node in
the same way it would if it were a
single node program because if I send
some isolated data to some other node
well it has the one and only copy of it
right so it's fun it can it can it can
manage collection and on its own if I
send immutable data around if some node
collects its copy of the immutable data
that's fine I've still got mine and if I
send it in the future
that's fine it'll just get a new copy so
that's pretty neat but what it doesn't
do is preserve global identity in the
timers example if I were to send some
time into the timer's actor and then I
want to keep a tag and I want to send it
again wait a minute who's responsible
for managing that identity and making
sure if it's collected on one node that
we still have an idea that it's the same
identity later and it turns out that
not that bad it's just a question of
keeping monotonic global identities when
you when you send objects and keeping a
map in your distribution actor of real
addresses to global identities so
distributed actor GC this is where the
real extension is needed it's not as bad
as you'd think it when I was first
putting this together I thought we
needed to maintain causality and
distributed setting that would be bad we
put a lot of work into that we came up
with a system that is kind of neat and
that it has a log n latency with no
extra space complexity so that's pretty
good but it's much better just to be
able to get rid of it entirely and it
turns out the only thing you need to do
is introduce one new message and one new
mapping and it's a mapping of node to an
actor reference count and it boils down
to when some node sends a reference to a
remote actor to a third party node
before it sends that it sends a shift
message to the owning no the allocating
node that shifts 1rc
from the sending node to the receiving
node now as part of that I might also
invent some new reference counts or any
of the stuff that we've talked about
previously in the protocol and the key
is that there's a new invariant which is
that all of those know Darcys have to
balance as well in order to collect an
actor and this means we can do it
without any causality guarantee now you
still need FIFO ordering between nodes
but that's ok we can have pairwise 500
ordering is okay that's cheap so
distribute an actor cycle detection
because we're running a cycle detector
on each node right so how are we going
to subject detect a cycle of actors that
spreads across a cluster and it turns
out this is another contact problem and
it's an eventual consistency algorithm
effectively in fact all of the contract
protocols are a form of eventual
consistent for them which is if we
detect an isolated cycle modulo cross
node references then what we can do is
inform any other nodes that we reference
from that isolated graph we don't need
to know who comes into it only what
comes out of it we can inform them that
this
portion of that cycle has blocked here's
a perceived cycle I have detected and
not only detected but have confirmed
locally because you don't want to
generate that network traffic unless you
really need to
so once you've confirmed it locally you
can start spreading it around and it
turns out that is a very simple way to
eventually propagate the information of
all the separate local blocks blocked
isolated graphs to each member of the
cluster and they don't even need to do
it pairwise you can just in any order
and eventually collect them no there's
one on every node right exactly because
if there was just one it's a huge
bottleneck and it's a failure problem
yeah but by having it be yes sorry I'm
on the right side good but having it be
per node and having this eventual
consistency algorithm that collects that
cycle information you get rid of the
bottleneck and if a node fails you can
simply say well those actors on that
note have implicitly permanently blocked
they won't be generating new traffic as
far as I'm concerned so those nodes can
be considered blocks so we can actually
carry on and collect actors that would
otherwise be in a cycle with unreachable
actors so each of the Asarco detectors
on each of the nodes so to compute some
they all do the same thing know they're
each only doing cycle detection for the
actor that's an excellent question
they're only doing cycle detection for
the actors that are resident on that
node right but what they'll do is
they'll only do cycle detection for the
portion of the graph that's present on
the local node and if it if that portion
of the graph is blocked and confirmed
that it's blocked that's when it starts
informing other nodes that that graph
references that that isolated graph has
blocked and here's the set of blocked
things that I've discovered exactly yes
that sounds complicated by you already
yes strangely it's not seriously tricky
distributed algorithm yeah it's perhaps
so far
but so far so good is my answer to that
one which is that not only does it seem
to be pretty easy to reason about what
it seems to be to be pretty easy to
implement because the the key is that
the other nodes that a graph references
are immediately available from the
topology of the graph because you have
some dangling references out of the
graph so if you had to keep track of any
reference into that graph it would be a
horrendous distributed computing problem
but because all the information is
available locally it turns out to be
pretty straightforward so far but yeah
yeah I think skepticism is well
warranted well I hope it's got a
distributed algorithm to do distributed
cycle detection yes not yet that's not
formalized yet so that's one of the
things that we're working on right now
at Imperial yeah right distributed
work-stealing so this is actually the
hardest part all of the other parts are
pretty straightforward in that well
straightforward and then once you have
an approach to it and you've formalized
it and you know that it works then you
can implement and implement it and
everything's fine but distributed
work-stealing
there isn't an optimal approach there's
no way to know for example so this
example is my favorite example if an
actor has a large working set right it
references let's say it references 10
gigabytes of memory you know obviously
you don't want to my grant that to
another host right because you're gonna
have to serialize 10 gigabytes of memory
to migrate that actor to another host
except one of the reasons you have a
large cluster is to spread memory load
across machines and maybe exactly what
you need to do is get that 10 gigabytes
over on some other machine to free up
memory locally and that's a hard
decision that's a harder istic so in the
first version what we're doing is
allowing programmers to manually place
and migrate actors and I don't think
that's ever going to go away because I
think there's an amount of domain
knowledge for the application writer
that isn't going to go away where they
may be able to just know better than the
heuristic is ever going to know but I
really hope that we get some heuristics
and and there's some work in
particularly
plus plus which is a supercomputing
framework in C++ on some heuristic
estimates that seem pretty interesting
and it has to do with a combination of
statically and dynamically figuring out
sets of communicating actors that it's
communication probably more than CPU
load and memory usages that should drive
the migration heuristic so right future
of phony the future of phony is
distributing computing whether that's
small-scale IOT devices talking to each
other or large-scale supercomputing
clusters or what it's really going to be
more likely than anything is things like
is your and ec2
so formal work in progress obviously
continued formalization work with Sofia
just so blue at Imperial the Orca
protocol that that there's that's
actually finished formalizing now
formalizing the are cap interaction with
algebraic and parameterised types his
work that's ongoing by master student at
Imperial simple value dependent types
currently Pony does not have a dependent
type system but we're gonna have a very
simple value dependent type system more
similar to C++ templates than a real
dependent type system at first and see
where we can go from there
the other is formalizing capability
secure reflection which becomes quite
interesting machine specific data the
distributed object identity and the GC
extensions the implementation work the
distributed runtime obviously dominates
this but other stuff that's really
interesting in there is things like hot
code loading Erlang has this great
system it has its flaws but it's very
powerful of being able to update the
code in a running cluster incrementally
across the cluster we want to be able to
do that doing that in a type safe ahead
of time compiled language is interesting
it turns out it's probably the same
problem as the rebel so that's
interesting Auto formatting self-hosted
compiler all the usual goodness that you
eventually want currently the compiler
is written in C for bootstrapping
reasons and so you have a community it's
growing it's still very small but we do
have sort of
about 50 different people can
contributing to the compiled in in the
runtime and we have a collection of
companies that are implementing things
in Pony most of them are in the
financial industry interestingly ranging
from financial startups FinTech startups
in New York to Tier one investment banks
who have rolled out global products
that's been a exciting way to validate
that something works is to deal with ten
billion dollars of flow a day great
thank you very much everybody for coming
and any questions I'll be happy to try
and answer yeah you have to think about
it in these things when you've got the
ability to either
I guess serialize the structure and send
it in the message to another actor which
case he takes a copy right or you could
sort of send the pointer to it somehow
right and the program has specifies that
today somehow know the language handles
it so if you're communicating on the
local note it will always be by pointer
and it'll only ever serialize if you're
sending across to another node okay
because you never want to serialize
locally if you I guess that was the
whole point you won't I wouldn't send
your efforts well then sending your
gigabyte object to another
right Silver Ferns so maybe so can send
it back I don't know yes exactly so it
turns out that's an excellent question
because what you can do is you can use
the tag capability because the tag
capability says this is identity only
I'm not interested in the contents
you're not going to be able to read or
write the contents so you don't need
them so when I serialize it I can
serialize it nearly as global identity
it might represent ten gigabytes of data
but I'm going to serialize it to you as
64 bits and you can refer to it send it
back to me in a message between what the
system decides charity decides well the
program that decides all of these are
defined so let me back up there the
programmer decides that by the
type that they indicate as being sent in
the message if they send something
that's readable or writable then that
data must be available to the receiving
sentences receiving actor but if they
indicate something that is neither
writable nor readable then that data
need not be available so we can skip see
realizing they have a back door where
they did unsafe stuff recently yeah do
you end up needing that us or or as I
mean I'm gonna go with so far so good
so far we haven't I'm not gonna
guarantee that that's gonna hold if it
doesn't hold I'll be very sad so one of
the use cases they have where they
needed it was when you have some
disputes conversation where you're
trying to find a minimum solution mm-hmm
and if you go above it if you go above
that count on your particular search
yeah and you want to kind of say well I
don't carry on and then you want to
inform other people when you find a
something better you know so like I
guess finding the shortest path if
you've got multiple actors going out
front find it right you want them all to
come know the best so far you want them
to be able to incremental e-report a
best case and if they find something
better than the last best case that
they've received they want to be able to
broadcast that yeah but then the
broadcast is going to be expensive in
comparison to using mutable states right
so if you use if you go with immutable
state Pro approach then what happens is
is you can possibly get a performance
improvement depending on how you build
the algorithm or what you can end up
with is a big problem once you go
distributed because that mutable state
now needs to be tracked in distributed
way so the pony approach to that
specific problem because it's
essentially one of the stream processing
problems and there's a fin tech company
in New York that's building a stream
processing system on top of this and it
turns out their approach is to say to
treat it much more as a data flow
problem everyone says reactive now so
I'll say reactive
so to say that when you find a solution
what you're gonna do is yeah maybe you
have a last known solution but maybe you
don't maybe you don't even keep track of
a last known solution what you do is you
flow it through a local actor that keeps
track of last nuts and less known
solutions and then it makes the
reporting decision and the because we
have that free send to a local actor
right you're just passing a pointer to
it and it can mutate this and now you
have constrained your broadcast problem
quite a bit we have one message per node
instead of one message per working actor
so so far what we've seen is changing
the algorithm has been better than
violating the isolation but I definitely
that's so far all right anyone else okay
thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>