<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Context-aware programming languages | Coder Coacher - Coaching Coders</title><meta content="Context-aware programming languages - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Context-aware programming languages</b></h2><h5 class="post__date">2016-06-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/aX_-Kq96-eY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
ah ok that's my great pleasure to
introduce Thomas Patrick I think at
least half the room one will have met
Thomas before I'm all done so it doesn't
need much introduction it's been a
Thomas first accosted me as an
undergraduate student and they're
working with him ever since it's been
one of the real highlights for me over
the last seven years too so to see
Thomas progress from undergrad and the
Czech Republic through his PhD but also
at the same time developing a really
high profile presence in the world of
programming languages and yeah so over
to you Thomas thanks thank you come um
yes so I as Don mentioned i have
actually recently submitted my PhD
thesis but aside from that i was working
over the last few years on quite a few
things in the f-sharp community partly
using type providers and developing some
some new type providers and applying
that idea and so i was trying to find
the common theme for all the different
things i've been working for what's in
my PhD thesis and what I did outside of
that and I think the term that talks
about that describes this pretty well is
context-aware programming languages so
why does this matter well if we look at
what kind of software we're rewriting
today there's two important aspects and
one of those is that the execution
environments where programs run are
getting a lot richer so if your software
runs on any device it has access to the
Internet and there's lots of information
on the internet if it runs on your
smartphone there's GPS sensors if your
software runs on the coffee machine it
has some other sensors available that
you wouldn't have on the phone so
there's more things but equally that
there's lots of different environments
where your program needs to run and
ideally I want to be able to write
software that I just write once and then
it runs on all these different things
like I write a mobile applique write an
application runs on my phone runs on the
web runs on the desktop and has access
to all these different things so I think
the problem of how do we actually use
this context that's available but do it
in a safe way and don't sort of do it in
a safe way where we don't get into the
troubles when one device has different
capabilities than another that's really
an important problem for programming
languages today so I'll start with a
couple of specific examples here one
example is when we are writing today
some software that should run on
multiple different platforms say if you
want to write something that will run on
Android and Windows Phone there it's
actually really hard because there's
even not a common environment but even
if I'm writing something for multiple
different versions of dotnet I have to
use some hash if to say well if the
environment has this capability then I'm
going to run one part of code and this
is the the preprocessor conditions
aren't checked in any way so that's one
thing where we are using really
primitive technologies another case is
when I'm writing some database access
code using things like link where I
write my queries in c-sharp or F sharp
and then it gets translated to SQL
there's still lots of problems when I'm
using some function or method that
doesn't have corresponding translation
in SQL so
that's again where I'll get runtime
error because that's something our
current systems don't check when I'm
accessing external data I'll just say
call this URL and assume that there is
that the response has some format and
contains some fields which is again
something that we can't really don't
really check today and that's really
hard to check because we're relying on
external sources another kind of context
property is when we're tracking some
provenance or confidentiality this is
actually where there's lots of
interesting and good static static
analyzers for this but we treat it as a
special case as one specific property
and I think what I'm trying to say here
is that all of these examples that I was
talking about are some sort of
contextual properties and we should
think about them in the same way so
ideal a programming languages should
have some notion of context and all of
these should just be an instance for for
that context and once the programmers
understand how how they work with
contexts then they should just be able
to use all these different sort of fit
all these different specific problems
into the general theme so that's the the
big picture of what I want to talk about
and i'll talk about two aspects
specifically and this is sort of i'll
describe the two two aspects in terms of
programming language theory so this is
borrowing borrowing Don's idea that
initially if you look at a programming
language theory we start with the
assumption that the context is empty so
when type checking and expression we are
assuming that there's nothing in the
context and this is this is wrong
because actually if you look at
programming today it looks more like
this where in the context that there's
all of this world you can access and the
pie here is supposed to represent some
sort of projection so the idea is we
have this universe and we're projecting
bits of it in the in the context that
the application can access so I'll talk
a bit about this later when talking
about the type provider work I did and
that's implementing a couple of these
projections and figuring out how to fit
the context into the programming
language so that's one thing the other
thing is we actually don't really just
care about projecting this into the
environment but the other important part
here is the is basically tracking how
exactly are we using the context so if I
have if I'm writing some program I also
need to know which parts of the context
my program actually uses how is how how
does it use it so the idea here and
that's what I did in my PhD thesis is to
add some sort of annotation to the
context that describes how the program
accesses the context and tells us more
about what we are actually doing so if
you're if you're looking confused at
this point that's okay this is just to
give you the sort of general theme of
there's two different things one is
adding more stuff to the context and the
other is understanding the context and
i'll talk about both of these things a
bit more and i'll be more precise about
what I'm actually saying so the first
part I wanted to talk about is the green
stuff and that's tracking how exactly
are we using the context and this is
what I did in my PhD thesis and there's
two papers about this and its joint work
with dominic orchard
and our supervisor Alan minecraft so the
idea here is we want to talk about
properties of computations and there's
lots of well-known work on effect
systems so I'll use the analogy to
explain what I mean now in sx systems we
have some programs some expression and
we're adding annotation that says what
the expression does as a side effect
aside from evaluating so this is
tricking effects on the environment or
its striking some sort of output
impurity of the expression what it does
aside from actually just evaluating and
what color facts are doing is we are
trying to track so to speak input
impurity or what other things the
expression requires from the environment
and just like effect systems can be
modeled formally using monads there is
actually a nice formalization here using
the duel so using using common ads so
there is some formal link between the
two but i'll talk about talk more about
that later so what would be an example
of co effect there's basically two
categories one is co effects that talk
about how we are using variables so if i
have a variable I can track whether i'm
using it or not and that's a contextual
property if i have an expression that
doesn't use very doesn't use variables
that are available in the context that's
some sort of annotation i can put on the
context to say this variable is not used
i can track how many times our variables
used or if i have some sort of
programming dataflow programming
language where i can say give
me the previous value of an expression
so I could say X plus previous value of
x divided by 2 to get some floating
average I could track how many past
values my expressions are accessing so
these are all talking about variables
the other kind is talking about
environments so if my environment has
some sort of resources in it say in
distributing competing in distributed
computing I can access resources that
are available on different nodes I can
track which of the nodes the expression
is using so I'll show this using
something that everyone understands
lambda calculus but it's basically
simple programming language and idea
here is this is writing a function that
takes X and returns X plus X plus some
why that comes from the Declaration site
of the function and the first example is
tracking how many times we are using
which variable and this is added as
these green annotations so what the
annotations are saying in this one is
that the the expression creates a
function that takes intense returns int
and it uses the input input variable two
times because it does X plus X but it
also we are also tracking information
about all the variables that we have in
the variable context so in the variable
context there's why and I'm using why
just once yes invocations of this return
closure does each invocation count is
one use of Y or not if I have multiple
invocations of disclosure then I'm going
to then each invocation
going to count as two uses of the art
well if I say if this was F and I had f
of X plus f of X then that would count
as for uses of X ought to use this of
why yes see that in net rule become so
because um well we'll see that yeah so
it's not should be enough calculus i
suppose but if you will not call this
function but simply to seek it then it
don't value 8x at all no sorry i
actually i got it wrong so what I was
saying here is that the way to read this
is when i'm defining the function when
i'm actually declaring the function and
creating it it counts as using why so
the idea here is when I'm creating the
function I'm capturing somehow capturing
the dependence on the context so when I
create the function i'm using why and
then when i use the function i'm not
using why again so i can call the
function in a context where where why
isn't available because why is available
on the declaration side and then when i
call it it uses the captured sort of
value of y so I guess this example this
example so the calculus here is based on
bounded linear logic and we're actually
doing the same thing that Gerard is
doing in in bounded linear logic so
there's there's that as the sort of
formal background for it and I'm using
it because it lets me demonstrate the
different rules in the reasonably simple
setting but I'll
have another example which is maybe more
intuitive later on so the idea is and
this is really the sort of important
idea about co effects is when I'm
creating a function I'm not capturing
all the impurities and delaying them
when I'm creating a function I can
require something from the context and
that requirement sort of happens when
I'm creating the function and then that
makes some part of the context available
for the function later on I'll show the
lambda abstraction rule I think on the
next slide which will hopefully explain
things better so the idea here is so in
this example we're tracking some notion
of variable usage and it's equivalent to
the bounded linear logic to important
things about the structure of this is
that we are actually annotating we're
annotating functions with just a single
value because function takes just a
single input but we are annotating the
context with a vector of annotations
because the context has multiple
variables in it and so we need one piece
of information for every variable so in
this sense that's one one case where
it's not equivalent to well-known effect
systems because we are actually tracking
vectors and scalars rather than just a
single sort of set and there's also a
richer structure on this on these
annotations because we are composing
them in multiple different ways and so
we can't get away with just using one
operations like set Union we here we
actually need a multiplication + + + so
how does this look actually in the
calculus when we erect accessing a
variable we just mark the variable as
used once
and here's the interesting bit with
abstraction where if I have an
expression that well I have some
expression and that expression is
defined in a context where I have
variables gamma and variable X there's
corresponding vector of annotations for
these variables where r corresponds to
the whole gonna and single annotation s
corresponds to the single variable and
when I do lambda abstraction I'm
splitting this into two but I know
exactly what part of the annotation
belongs to the function because on
that's the part that that belongs to the
variable X and I take that out put it on
the function but there's there are still
other requirements that are on the on
the context use s times no all times
this times um because of truly unique
all the function it uses its argument s
times right so the cross here is
supposed to mean vector concatenation
yeah nice to the edge Thanks thanks for
the question yet so the idea is the
gamma is used our x which is a vector
corresponding to the variables and x is
used as x which is what goes on the
function now thanks for pointing that
out so to actually make this work we
need to add structural rules with all
that will propagate the annotations
carefully when we do something with
variable context so this is showing the
the structural contraction rule where
the idea is I have an expression E which
can use variables x and y and i'm
replacing x and y with zet so now i have
variable now i have an expression e e
and there's that in places of all the
X's and Y's so
joining the two variables and here again
I'll split the context and find the R&amp;amp;S
annotations that corresponds to x and y
and because i'm now using the variable
well in the pre in the in the assumption
i'm using the variable X are x and y s
times when i replace both of them with
the with one variable i'll be using the
new variable r plus s times so I'm
adding the two adding the two contexts
requirements together and turning that
into a single element of the vector
there's a couple of other rules that I
need to add for weakening when I'm
introducing a variable that's not used
and for exchange when I'm just
reordering variables because I need two
equally reorder the things in my in my
annotation vector so that's one that's
one case of the co effect system where
I'm talking about variables right yes so
I didn't put all of that all of the
rules here there's they're all in the
paper and they're all on my back up
slide issue so you multiply numbers
exactly yes so I don't even need the
application rule because you already
know how it would look but yes there's
um there's multiplication in the in the
application rule where if I have
argument that uses variable twice call
and I pass it as a argument to function
that uses the argument three times I'm
modeling a call by name evaluation here
where that argument will sort of be
copied over into every single use and so
i need to multiply the number of times
the argument
disused times the number number of times
the things in the argument are used like
your kind of arguing is it there's an
underlying operational intuition about
what this use think means right so I'll
do what you'd expect at a theorem that
says if you know if I have this
particular typing annotation and some
operational property holds is that right
what is the operation property do you
did you you know do you have such a good
so I didn't have such a proof in in
general because um what I'm trying to do
here is to talk about the sort of
general structure like I guess I'll use
the analogy with effect systems where if
I'm talking about effect systems in
general there's some there is some
intuition behind effects in general for
all the different effect systems but
when I want to actually talk about
concrete operational meaning i have to
pick one effect system by writing to
memory and talk about the operational
meaning in that case so there's so what
um I have to basically validate that
this is a reasonable system is that the
beta reduction for the system preserves
preserves typing so if I so the way I
think about it is there's the general
system which is which has 22 formal
properties that I think tell you why
it's correct one is that there's a
there's a formal there's a semantics for
this in terms of common odds and that's
explaining how the system works and
because the annotations in the in the
pipes match the annotation on the common
odd structure which is well defined that
does me that it makes sense and the
other part is purely syntactic
properties for this
we're a beta reduction preserves typing
and that's telling me that the system
has some good properties does that make
sense in general but I can't talk when I
when I'm focusing on the general system
I can't talk about specific operational
meaning because that would require
focusing on one specific notion of co
effects like I could do that for the
bounded variable use here or for other
examples so I'll say just a few things
about another example which is tracking
how many times well so the idea here is
we have a language where we have this
pref keyword and the per ft word lets me
access previous value of an expression
so i can say pref of x plus x divided by
2 and here I'm again going to be
annotating the context and the functions
with a number but this time the number
represents how many past values are we
using and the interesting thing here is
that this is using different algebraic
structure so when I'm contracting and I
have a variable that is used where I
require at most five past values for the
variable and i'm also using it in
another context where i require at most
three past values then i can see this
history as sort of list of previous
values and i'm only requiring the
maximum here because i'm sharing the
values and i only need last pass the
last five values because that also
includes last three values so this is
just to motivate the structure and
the interesting point here is that
there's a couple of different formal
systems that other people have done or
that we added where the same structure
keeps appearing now the other the other
aspect of co effects is when we are
talking not about specific variables but
about environment as a whole so this is
actually this is actually going to be a
hostile example so in Haskell there's
this thing called implicit parameters
where the idea is I can write an
expression that accesses some implicit
parameters and those have to be provided
from the environment but they're partly
dynamically partly lexically scoped so
if you're so they either have to come
from the call site when I'm calling the
function I have to have a value for
these or they can come from the
declaration side when I'm declaring the
function and these are in the context I
can access them so there's actually
multiple ways to type check this or
annotate this and one is to say split
the two requirements so if I'm declaring
the function so the idea here would be
on declaring the function on some server
where I know the time zone I can capture
the parameter and this is again where I
have this notion of capturing when
declaring a function so I can capture
the value of time zone and I'll end up
with a function that requires just the
current time and when i call it i give
it the current time and it runs or i can
treat this as a function that captures
everything in the declaration side so it
treats the two variables as ordinary to
implicit parameters as ordinary
variables and i'll end up with a
function that doesn't require any
implicit parameters
and I'll actually skip this part because
I want to talk about another part of the
of the story so I guess the main
technical contribution here is that all
these examples that I try to describe in
a bit of informal way with some rules
they actually fit in the same scheme so
that's what i call co effect calculus
and there's more details in the papers
given that given the given the time i'll
probably refer you to that but the idea
is we can find some unified algebraic
structure and the algebraic structure
needs to be a bit richer than what
people have been using with effect
systems because you have the idea of
context sharing which is one thing and
you have the idea of basically
application or sequencing where the same
context is propagated through the
program so there's a richer structure
based on semi ring and there's also a
way to sort of unify the two different
ideas where we are talking about
variables and talking about context
using structure that's similar to
containers where I can say that the
context is some sort of container and I
either have things for every single
variable or I have one annotation for
the whole context and the sort of one of
the theoretical foundations for why this
makes sense is that there's a nice
common addict semantics so if we are
modeling effect systems using monads
what we would do is that we say well
expression is interpreted as some
function from the context to a value
that has some melodic structure around
it and the melodic structure lets me
sequentially compose computations and
provides basically the plumbing we can
do the same things same thing here using
common arts and say if I have some
expression that requires some context
I'll wrap additional structure around
the whole the whole context the variable
context and then the result will be just
a pure function yeah are you are you
sort of reformulating what had
previously done using one as using
components or are you doing something
completely fresh they couldn't be done
using my eyes ah so I'm doing something
that can't be done using monads and
there's a couple of previous works that
have been done that talk about context
in some ways that can fit into this
framework that we have to do the fence
systems so what and so FN system is a
pretty rich you know you can put stuff
on the types and yeah you know rod midi
the whole the whole gamma the
information of the type that what's or
specific things can you do in your NASA
team for you say yeah you could do that
that's yeah so the key differences are
well there's two different ways but
that's probably for longer longer
discussion two different ways of
annotating things like with with monads
I can make the monads sort of first
class thing in the language and then I
can wrap every single value in a melodic
construct but that's doing something
else then using Mona's just to define
semantics of a programming language
where if I'm doing that then on I don't
have the melodic structure as a
first-class value in the in the language
but I guess the main the best way to
illustrate the difference is what I
can't do with Mona's is I can't split
the requirements in lambda abstraction
when I have lambda abstraction in inman
Eric world that always says delay all
the effects and put all the
on the function arrow so Moniz will
always sort of delay the whole effect
and put it on the arrow here we actually
the common odd structure is bit
different and it provides a way to say
some part of the context comes from here
some part of the context has to come
from there so I think that's the key
difference that's that's the key
difference between sort of scho effects
and effects is this ability to capture
the delay is the ability to capture
something from the current context and
combine it with what comes from the
execution and wire from the caller and
this is also by you can't model
Haskell's implicit parameters in terms
of the reader Monette because the reader
monad lets you only capture things from
the call side but not from the
Declaration side so that the common
addict semantics is interesting for a
couple of reasons and it's not really
simple duality between the two because
in the common addict semantics we're
actually putting the structure around
the whole context and the context is a
vector of variables in the melodic world
we're putting the additional structure
only around the single result and that's
just a single value so because of this a
symmetry in in lambda calculus where we
are mapping multiple variables to a
single value this is actually
interesting and there's a richer
structure that's needed then in the
monadic effect system world so I think
if if you have any questions about this
part of the world and now it's probably
a good time to ask or we can talk more
about it later there's probably lots of
questions that I haven't really answered
here and maybe it's better to answer
them with a whiteboard
hey you said here's a unifying structure
well also was it helpful to have a
unifying structure apart from you know
maybe a sort of theoretically sense yeah
but did it lead you to any new insights
yeah so the question is did this
actually defining the unified structure
did it lead me to discovering something
and I think the answer is that it did
because I sort of started with a couple
of systems where they all looked
different and then by trying to find the
unified structure i actually discovered
that some of my systems were initially
wrong because they I only had good
intuitive understanding of one one
aspect of the system but not of
something else and in other systems i
had intuitive understanding of other
parts but not the first part your
systems evolved do you hope we do so
does anybody else's systems will all ah
so it's no I didn't I didn't I didn't
discover any other systems were wrong I
think I have a few cases where I think
using this would give you better way to
understand other people's system on
where I think people very often tend to
use monads for tracking things just
because small ads are generally
understood way of tracking things and
then they keep adding more structure to
them while they start with the monett
and they have the monett structure but
then they add lots of other things to
the Monad and it's not a mullet anymore
or it's a monad with other structure
examples where you think this would be
better way to understand so there was
there was actually some piece of work on
Thraki on doing data flow with Mona's
and it sort of works but
more headaches structure isn't really
interesting there and the all the
interesting things happen in the other
operations that you have to add to the
monett and if you do it in the common
addict style then the the common add
structure captures the more important
more essential part of the problem so I
think that's one example of where this
actually helps to design better better
languages okay so i think i have
probably ten minutes left so i'll just
say one or two things about the other
direction or the other area where where
I worked and that note about tracking
how we use the context but it's more
about adding other making other things
available in the context and I think the
nice way to intuitively understand this
is that think most search engines do
this these days I probably Bing probably
didn't do this when I was taking the
screenshot but when you start searching
some accessing some data on the internet
you get this nice completion where you
sort of immediately see what the
internet knows about population and
sometimes it even gives you the value
immediately and that's sort of the end
user experience but I kind of want to
have the same experience when
programming with context in programming
languages and so if I'm accessing data
from some data source I want to have the
same sort of experience when I start
looking for the data and it immediately
tells me what's available so this is
building on the top of the work that
don't it in a sharp with Thai providers
and I'll show a couple of type provider
related pieces of work that I did based
on this so one is the the World Bank
type provider which many of you have
seen before
but it's implementing the idea that was
there on the slide where what I can do
here is to say world bank note countries
and then it comes with a list of
countries and the list is generated life
so when I'm accessing the data it
actually connects to the World Bank and
extract the some metadata from the from
the World Bank data source and map this
into the programming language world so I
can have a look at czech republic and
indicators and then again here i get
access to lots of different indicators
kind of in the same way as when
searching for data on the internet so i
can look at some indicator and actually
run it to get the value you did ask what
type of others do isn't it so the World
Bank type provider is what I did the
framework where where it runs is not
what I did so I didn't do thi providers
although I sort of have been
contributing to parts of it and i've
written or created many of the type
providers that people actually use these
days so this is about f sharp data which
is library I designed it's probably the
most downloaded F sharp library on
nougat so the work I'm talking about
here or my work here is designing the
library not creating tie providers and
the library I wanted to mention this on
the intro slide I forgot about it but it
was actually I submitted a paper about
this to the ICF be student research
competition last year and it won the
first place there so if I didn't if I
wasn't doing interview I would be
working on my I CFP submission this year
so what I did was the sort of design of
the type of this
specific type providers not the
mechanism itself but there's lots of
quite interesting questions even if you
sort of just look at the design of the
type providers so so to speak that's the
the pie in the initial picture in the
initial equation how do we project from
the external world to the to the
programming language type system and one
thing that was interesting in the World
Bank case was what is actually data and
what's kima so the World Bank is a
massive data source but the question is
which parts of the of the structure do
we want to see in the type system do we
want to make countries pipes which will
make the system break when some country
disappears or do we want to make years
turn the years in two types and so on so
how do we actually map from the sort of
one blob of data into the two-layer
environment of programming languages
where we have some types and some values
and the World Bank type provider is kind
of interesting in that it's really
trying to put lot of things into the
types that you wouldn't normally see in
the types so country name is actually a
type and that makes it really easy for
sort of scripting kind of work but you
probably wouldn't put that in your
application that's supposed to be
running for the next ten years yes you
can actually iterate across the
countries I mean that yeah typical data
analysis scatterplot across countries
that would seem like a natural
generation no that's where those are
their types that's a good question so in
the World Bank it's actually doing two
things it lets see it turns every
country into a name thing but it also
gives you the more value oriented view
where you can just take all countries
and they will be all instances of the
same type
that's that's like one of the
interesting design questions here and
how do we design the type provider so
that they let you do all these different
uses of the data another part which is
and this is what was in the ICF be
student research competition paper is if
we have some external data source how do
we and many external data sources these
days don't come with explicit schema
when you're calling say Jason based
service it doesn't have schema the
website might give you a couple of
examples and say well if you call it
like this this is what you'll get back
which isn't very strong statement but
that's what people have to live with so
this is sort of one interesting specific
contribution that I think is sort of
interesting not just from the practical
perspective but also from the
theoretical perspective and this is
doing type inference for structured data
formats like Jason so I'll run this
piece of code what this does is that
it's just getting data from a service
that returns weather and it gives me
back this Jason which is some sort of
structured format with records and
collections in it and if you want it to
read something from there you would have
to look at the sample find where the
actual temperature is which is under
main temp and read the read the value
there and do some dynamic look up based
on the names of the of the records so
what I can do with the chase and type
provider here is to say use the Jason
type provider and this will look at the
sample document and it will infer some
type for the document and map this type
into a sharp ah or
into the f-sharp type system so when I
have a value of this type I can actually
see here all the top-level properties of
the record that the service returns so
this is looking at the sample data set
inferring some structure from the sample
and mapping that into the f-sharp type
system and then I can just say W dot
main dot 10 and this gives me the
temperature particular place to us for
the weather for i'm going to turn to
analyze this function over which put
date in place so there's one returns
might be different the truth yeah you
know so yes well solving kim possible
questions is the most interesting thing
so what this does is that there's two
things one is the sample structure which
is what I'm passing to the Jason
provider and then I can hear you slowed
and give it a different URL and so the
idea is I can I have to give it some
sample for the type inference and then I
can load different load different make
different requests slow different data
and this will only work if there's some
relationship between the sample and the
actual response so it relies on the fact
that your sample has to be
representative in some way and this
turns out to work actually really well
in practice there's sort of formal
formal statement for when exactly this
work using some sort of subtyping and
there's also sort of practical methods
for dealing with this like when I find
some other data source where it doesn't
work
then I have to catch the runtime
exception and deal with it but I can
then take that as another sample edit to
my to my samples so you can pass in
multiple samples and then you'll see
where you have to change your program to
deal with this new observation yes
someone hands you a tree and you create
a tree yeah so is their nose or i mean
are these do they differ do you need to
do some kind of generalization from
those samples over yes yeah so the
technical difficulties here are someone
gives me a sample and the sample
generally could be a record but it could
be also a collection of things so
there's that the interesting part is
inferring the the single type for the
whole sample from one or multiple
different samples and how to infer type
that's actually usable from the
programming environment so if I have
multiple records for example in my
sample and one is person with name the
others person with name and age how do i
turn that into one type I could just
create a some type with one or the other
but that would be hard to use so what
we're doing instead here is that we
actually turn that into a single record
where the age becomes optional in this
case or if you have collections if you
have one sample where you get collection
with numbers while collection with
records and collection with records of
different types which you wouldn't
believe what kind of things people put
in collections in the real world we the
interesting thing is finding the single
unified type that captures all the
different samples we have
well one sample can also include
collections in there so if I have one
sample that includes collection and
there's multiple sort of sub-samples in
the collection then i have the same
problem so it's actually at actually if
you like a record all the tweets for an
hour then you get a collection of tweets
and that's one file but it includes
collections of samples so the
unification of samples has to be done
not just when you have multiple samples
at the top level but also within the
same within a single document yep this
you talk about kind of this is technical
concerns on how to make the inference go
through but there's also you often talk
about usability components as well and
for instance is noticeable that as a
type system gets more expressive like if
you can have a type for a specific
number yeah the number seven point eight
one or so yeah then you then then the
system becomes unusable yeah because
you're giving to how what do you do
about usability is I mean yeah how do
you get a measure on like what's usable
or not yeah it's just situation at this
point well I think that's actually one
problem and kind of interested about
because there's there's not much we can
say about it formally I guess what we
what I was doing here with with the F
share data library is just to create it
and give it to users and wait for the
complains and see it's only you must be
finding some laudanum aware yeah the way
there the cost of running type related
yeah manipulations is low but the
benefit is high or something there's
there's actually like one formal thing I
can say about the inference here which
is that the idea is we have to find the
commons super type of all the samples
and in this system in f-sharp it's much
easier to program with records because
you can just do dot and see the things
there and I have a four
prove further for the system here that
if there is a common supertype that's
not that is not a union then it will
find it so there's one sort of criteria
which is using records whenever possible
and the system has that property which
is sort of formal proprietary that I can
say about it based on informal intuition
okay I think I should probably wrap up
so there's a lot more that I was working
on in the sort of applied area including
some other data science libraries and so
on so once you have the context what you
can actually do with it and I think in
sort of summary the idea is there the
context is really a lot more important
than we can then we usually think lots
of academic work has been done on the e
part like building creature programming
languages and on the towel part building
creature type systems but I think the
really interesting thing that I was
working on is all on the left so it's
some work on projecting from the
external world and how can we make that
available in programming languages and
that's the F sharp data work and how do
we actually check how the context is
used and I have one slide on sort of
talking about the future plans but I'll
just say one thing which is that one
area I was becoming interested we in
recently is data journalism and I think
that's really sort of a way where you
can put together multiple different of
these of these areas of how do we access
data and present it as a sort of
newspaper article or some interactive
visualization
but it also shows the importance of the
of the tracking because you want to have
some credibility or track provenance
information and when you have an article
you need to know where what the data
sources are and where that comes from so
that's one thing we can talk about later
on Thanks time for one more question
almost nothing stuff into the camera
that stuff can include the magnetic
stuff into the common attic stuff well I
think there's like two parts of it one
is the syntactic structure and the other
is the semantic structure so I can't do
it on the semantic side when I have sort
of monadic model that can't be captured
by common ad and when I have common
attic model I can turn that into a monad
syntactically I could unify the two
systems by the if you look at it just
syntactically then the common attic one
has more structure and I could sort of
restrict it in some ways so that it
would track set based effect systems so
I could do that but I guess it's more
interesting to look at the actual
semantic structure where this wouldn't
work and that really shows the
differences between the two</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>