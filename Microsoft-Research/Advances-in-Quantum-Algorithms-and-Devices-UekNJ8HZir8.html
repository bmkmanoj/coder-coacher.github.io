<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Advances in Quantum Algorithms and Devices | Coder Coacher - Coaching Coders</title><meta content="Advances in Quantum Algorithms and Devices - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Advances in Quantum Algorithms and Devices</b></h2><h5 class="post__date">2016-07-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/UekNJ8HZir8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
okay welcome back everyone uh we're at
our last session and after the last
session we will make our way to Dave's
right there will be lots of food and
beverages so that will be a reward um
well actually maybe a reward as Sean and
winds talk so sean sean is going to tell
us now about a quantum algorithm for
computing the unit group as I'll turn it
over Sean thanks yes this is a quantum
algorithm for including the unit group
of an arbitrary degree number field is
joint work with Kirsten eisentrager
lex-lex ikitai oven Thanks song so the
topic is exponential speedups trying to
find problems where quantum algorithm is
exponentially faster than the best known
classical algorithm for the problem for
the problem and number theoretic
problems have been a good place to look
for these starting with Shor's algorithm
for factoring and discrete log and then
number of fields provided some more
problems so this started with real
quadratic number fields and when you're
given a number field there are three
main hard problems hard classically you
might want to solve one is the unit
group and the special case of the
quadratic number fields its tells
equation it's related to tells equation
the class group is another problem you
can solve it tells you how close the
ring is to a unique factorization domain
and the last one is the principle ideal
problem this can be used in crypto and
in the real quadratic case bookman and
Williams had a key exchange system that
they designed that they hoped would be
harder to break than factory in case
factoring was polynomial time
classically and so since we have once we
had a quantum algorithm to solve the
principle ideal problem we could break
that crypto system also so after after
that case that's a degree to number
field then we went up to constant degree
number fields and solved those three
problems and then we've been stuck for a
long time and in the meantime we worked
on some field extensions we looked at
similar problems in function fields and
so that the topic of this talk is going
to be number of fields of arbitrary
degrees so they're going to be two
parameters
number fields that i'll tell you about
and now it's going to be polynomial time
in both parameters and said of just the
one okay so there are different
applications of number fields I'll just
mention one thing i find interesting has
been happening lately which is in
lattice base crypto so a lot of space
crypto is you know one of the main
proposals for systems that are quantum
resistant but i do want to point out
that whether these are secure against
quantum computers is actually an open
question it's not them it's not been
decided yet and a special case just
recently a special case appears to be
broken so this is used in a few
different cryptosystems so it's not it's
not like the majority of the lattice
pace cryptosystems but there are some
cases the first one is swill acquis
which is a cryptosystem that GCHQ was
developing the second one is multilinear
maps and the third one is a homomorphic
system by smarten for cotton and they
all use the same assumption so they're
all broken you and so I can't tell you
how it works in this talk but Chris Pike
it has a really nice write-up on his
webpage so you look on his web page and
you see I explained here it's a link and
you can click it and if you follow that
link it's really nice but I'll tell you
that the ingredients for breaking this
or the work I'm going to talk about
today and then Biasi and song added the
principal ideal problem on top of this
and the approach the approach they
breaking this uses something that dan
bernstein had like talked about a year
ago one thing that was missing was
solving bounded distance decoding in the
unit lattice and in this GCHQ paper they
mentioned that BDD in the unit lattice
can be solved classically efficiently
and so the crypto people from the crypto
community went and improved that it's
actually possible so when you put that
all together than the assumptions from
these systems can be broken okay but I
want to talk about the setup for
computing the unit group of a number
field and as with a lot of exponential
speedups it goes through the hidden
subgroup problems I want to tell you
what that is or remind you what that is
okay so this is just an abstract problem
you can define and you can try and solve
it and so if the problem is you're given
a function f from a group to a set and
it's constant and distinct on Co sets of
some unknown subgroup H okay so you can
imagine you know here you have all your
group elements you have a function that
you evaluate there's this unknown
subgroup H and when you evaluate it on H
you get the same value a different co
set you get a different value and in
this case there are different colors if
you can see them and you know you should
think of G is exponentially large so you
can't just query the function everywhere
you want to run in something like time
log group size polynomial log the group
size now depending what the group is we
we sort of you know determines how hard
the problem is to solve by a quantum
algorithm so some examples when G is
abelian we have fun and algorithms for
all our most cases and this is the way
these these these quantum algorithms
work so for example factoring an integer
n reduces to solving a hidden subgroup
problem over the integers when the group
is the integers discrete log reduces to
the case where you have this finite
group CP minus 1 Cross CP minus 1 pals
equation moved to the reals and now for
this general degree unit group we're
going to solve it for R to the N so
that's that that's where we're going to
go and now you know just mention there
are still these important open questions
for the hidden subgroup problem about
non abelian groups if you could solve
this for the symmetric group then you
could solve graph isomorphism and if you
could solve the hidden subgroup problem
for the dihedral group using the usual
method that we try and do then you could
solve the unique shortest vector problem
so those questions are still open
okay so here's an overview of the way
the algorithm is going to work and the
talk is going to work so the input is
going to be a number field I'll tell you
about what that is and there's a
reduction to a hidden subgroup problem
in the middle and then we give a quantum
algorithm to solve that hidden subgroup
problem so this is the order I'll go
through the main thing I'll do in the
talk is I'll talk about how you set up a
hidden subgroup problem from this from
the number field I won't have a lot of
time to say much about the solution to
the hidden subgroup problem over R to
the N but let me just mention that you
know in terms of trying to generalize
the previous algorithms that solve the
constant degree case there are two main
road blocks for going to arbitrary
degree so the first roadblock was a
night of three trying to reduce the
problem of computing units to a hidden
subgroup problem the you know previously
that reduction if you try to use the
same approach would take exponential
time and one of the ways we you know one
of the things we have in our solution
now to fix that problem is we have a new
definition of the hidden subgroup
problem that's over continuous groups
and once we have that then we actually
end up with a quantum reduction instead
of a classical reduction and we're
worried excuse me we're able to get that
to work and then the second roadblock
was solving the hidden subgroup problem
over R to the N the problem is once the
dimension grows and you see you're over
the reels and so you're rounding stuff
off everywhere and then you're getting
too high dimensions and you try and do
Fourier analysis on that and the errors
are just really hard to understand so
now that we have this continuous version
of the HSP we were able to set it up and
analyze it okay so I'll start with the
first one which is describing what the
input looks like to the problem ok so
I'll give you two examples of number
fields to try and give you an idea what
the parameters look like and what the
fields look like so here's the first
example we have Q a joint square root
so this is the set of numbers a plus b
square root d where a and b irrational
numbers d is a positive non-square
integer okay so this is the field so you
have addition subtraction multiplication
division for all these numbers and the
input to this problem so i can describe
to you that i want to work in q a joint
square root d by giving you d so you can
think of d as being the input when you
generalize at other fields you talk
about the discriminant and so here the
discriminant is something like d so
that's the input size and well and then
the degree is 2 for this number field so
these are the two parameters the
discriminant and the degree the degree
is 2 because if you look at it it's a
degree 2 vector space over q a and b are
the two parameters to degrees of freedom
so the goal when I give you this number
field to be polynomial time you want to
be polynomial time and log D the degree
doesn't play a role because it's a
constant okay now here in this talk
we're interested in higher degree number
field so here's an example of one it's
the cichlid omix so you take Q and you
join n through to unity so here Omega n
is e to the 2 PI over N and so for
example then is prime then we can say
something that the discriminants about n
to the N and the degree in this case is
n minus 1 if you see you have a 0 a 1 up
to a n minus 1 oh is that right okay
maybe that's not right that looks like
degree n I think that should be n minus
2 yeah should be a n minus 2 as a typo
but anyway so to be polynomial time in
these two parameters be polynomial and
logged as discriminant and the degree
you want to be polynomial ian polynomial
in n so that's the goal okay so here's
some running times for unique group
algorithms now factoring is not an
example of this but just to compare the
running time it's that's it the best
factoring algorithm is something like e
to the end of the one third you can also
reduce it to computing the unit group in
Cuba joint square root d if you won't
have a slower algorithm but the best
classical algorithm for
q a joint square root T is something
like e to the end of the one half for
general number fields its exponential
and NM or with heuristics maybe it's
solve exponential but it still is
exponential the previous quantum
algorithm most polynomial time in log
discriminant which I written as n there
but exponential time in the degree and
so here we're going to have polynomial
time and n NM please ask questions as we
go anybody wants asking anything yeah
yeah
I know maybe it's also bit too early was
the output of yes allegories I'm going
to talk about like was it precise output
he I'll talk about the output the next
slide okay so here so i'll give you okay
so that was the input number field now
we want to talk about the output which
is the unit group so let's talk a little
bit about the unit group at least okay
so in general you're given a field q
joint square root d inside that is a
special ring called the ring advantages
and so if you look at the multiplicative
group there and you ask for the
invertible elements that's called Oh
star and that's the unit group of stars
it's the invertible elements of this
ring so i'll just give you two examples
so I not so exciting examples if you
just take Q and then the ring advantages
in that case is just the integers and
the invertible integer is under
multiplication or just one in minus one
ok so that's not so exciting so we can
move on to say Q joint square root T so
here we're looking at these numbers a
plus b square root d now no no this is a
pointer or not maybe not yeah there we
go now the ring advantages doesn't
always have this form but sometimes it
has this form so i'm just going to write
it like this because it's nice to look
at so you can think of a lot of the
cases the ring advantages as being
numbers of the form a plus b square root
d where a and B are now restricted to be
integers okay now we're looking at
what's the multiplicative subgroup of
that that is invertible okay multiple
you in a subgroup and so at least the
infinite part I've left out some some
finite thing here but you can think
about the infinite part is being
generated in this case by 11 element by
Diehr shalise unit theorem you this is
called a fundamental unit and to get the
whole unit group you just take powers of
this element positive and negative
powers and so the goal would be to find
you if you have the fundamental unit
then you would know the unit
okay so here I'll give you an example of
a unit okay so here's a here's a number
field let's take D is 109 so we're
looking at Q join square root 109 and
here's a here's an element from the ring
advantages so we have an integer
coefficient here an integer coefficient
here and for this thing to be invertible
we need something the same form we have
integers and when you multiply them you
get one and so here's the inverse it's
same thing actually with the sign
flipped so it's easy to easy to see here
and if you multiply them you get the
first number squared minus the second
number squared x 109 and that's one okay
so it's a concrete example now you may
notice something here if you used to
thinking about running times which is
the input as three digits and the output
has whatever lots of digits and one of
the reasons i'm showing you this
examples because that's actually a
problem so in general if you just wrote
down the units in this representation
they can have ee exponential size so
it'd be impossible to have a polynomial
time algorithm you can't even write down
the output so we do we make one more
change and what we do is you just take
the log of 0 star so we take the log
embedding in general so 0 star was a
multiplicative group you to the K if we
take log of everything it's going to
change it to an additive group and now
you're looking at a lattice in general
when you move to higher dimensions so
this is a one dimensional lattice you're
trying to find log you and in general
are going to be finding a basis of a
lattice and we don't even need log you
to a good precision we just need it to
some precision you can round off
everything's fine so does that answer
your question in terms of what is it get
closer to answer your question
I guess yeah but I just don't go to get
details how it's actually why it's
efficient to have just you know just to
know log to some precision but I might
just take it offline yeah I can't answer
that easily but there are algorithms
that deal with approximations and let
you test for units and things like that
especially in in in the quadrat real
quadratic case it's harder and higher
dimension that okay so that's the input
in the output any other there any other
questions before I move on to a hidden
sup your problem yeah is it the case
that you know the group of unions but
might not know the exact expression for
any unit in that group the exact
expression like here you said yes the
approximation gives you the group
structure but but not necessarily the
knowledge of they actually unit in this
representation yet you have
approximations of the units there are
other representations you can try and
compute that our exact that are like
factored in certain ways but this this
representation is is rounded off yeah
yes yeah I'll predict the output is the
basis of the group of units yes actual
question that I want to ask is different
one I wanted to say go back to your
earlier slide so are you still are you
going to tell us how this is related
like through the hunt HSP back to the
hard problem for the crypto systems or
did you already are you not covering
that any I know I can't cover I'll just
mention in the last slide I'll just
mention what their assumption was okay
yeah anything else okay okay so we want
to reduce this problem to a hidden
subgroup problem and it's going to be
over the art of the end so we have to
talk about this issue like how do you
even define hidden subgroup problem over
art idea what happens when you try and
do it okay so if you're familiar with
the integer case say periodic functions
we can think about periodic functions as
a special case of what we're doing here
in one dimension then the function the
hidden subgroup problem a function
satisfies the hidden subgroup property
would be periodic so this would be the
subgroup it would be less a multiples of
are here 1 r 2 r 3 r if you evaluate the
function you get these different colors
and it would be one to one on the period
so it take different values in here okay
that's the basic property for the hidden
subgroup problem over z now once you go
to our you could say same thing but the
problem is the period could be
irrational or transcendental you may not
even be able to write the period down
right so if you can't write the period
down how could you compute with it like
you can't even nobody can give it to you
and if you had it you couldn't verify it
so so we have to do something with the
function in order to make the
information accessible to us and what we
did in the in the constant degree case
what we did is basically the very first
thing we did was round everything off
and we dealt with rounded things right
from the beginning and that gets into
trouble when you try and go to high
degree and so here what we're going to
do is define
a new hidden subgroup problem it's a
continuous one so now it's going to go
from R to the N to quantum states not
just to any sit any any set usually we
might go to basis state standard basis
States but now because the quantum state
so X gets mapped to some quantum state f
of X and it's going to have three
properties now so the first one will be
periodic this is just rewriting periodic
with inner product now as far as being
distinct on cosets we can't make it
distinct on cosets otherwise you're
going to have this problem of you know
you have to evaluate it directly at the
at the point so what we'll say instead
is will let the inner product drop off
exponentially as you get farther from
the lattice in one dimension to one
dimensional lattice so so here I've
graphed the inner product for example of
F of 0 vs F of T and so the inner
product between those two states is
going to fall off and then you know
you'll be back to inner product one at
the period ok so this is how we we
handle that now we still might have a
problem if it falls off too fast we
still wouldn't be able to create near
are so the last condition will be
lipschutz so Lipschitz limits how fast
the function can change right so f of X
minus F of Y is at most X minus y times
a now what this does for us is it makes
f of are almost the same state as f of r
plus epsilon so we can just set down a
grid on here relative to what the
Lipschitz constant is and we're free to
evaluate it at these other points like
so these two points would be close to f
of are almost the same state and we can
do it we can get access to the
information that way ok so that's the
continuous HSP definition so one thing
we're going to need now is some
continuous functions which I'll show you
a place where we can get a continuous
function
okay so you know we're going to be
dealing with lattices and real valued
lattices and we're going to round points
off and this creates a problem in
quantum computing because you can't just
write down approximate numbers that are
closed because these two states are just
completely other orthogonal but what
we'd like is that for have them to have
them be closed and so we have a way to
encode real numbers that's going to take
care of this called the straddle
encoding and this is an example of a
continuous function so a real number X
can be mapped the straddle of X which is
it's basically sitting on X and X plus 1
so i'll show you an example down here so
it's the cosine part of the fraction
here in the sign part here so I have a
little thing here so here's basis state
one two three four and if I let this go
it'll show you the straddle encoding of
different values
okay so that's a straddle encoding it's
a continuous function and it has some
nice properties so one property is that
if two values are closed closed we're
looking at X and X plus epsilon these
are real numbers they're straddling
coatings will have very high inner
product because if X is black here it's
the higher one and the lower one here
and if you move over a little bit it
just changes this a little bit so they
still have high inter product on the
other hand if you take another value Y
that's farther away then the inner
product this is just zero so that's
something we need in our analysis later
on we initially were you trying to use
narrow gaussians for things and we
didn't have this inner product 0 and it
made it hard to do stuff so this solves
that problem okay and as a lemma we can
can show that the hidden subgroup
problem over the integers are basically
you know all the known cases reduce to
the hidden subgroup problem over the
reals or high cotton high number of
copies of the reels and we can use the
straddle and coding to do that so we can
take the integer value one and make it
continuous and then so our algorithm
subsumes the previous ones okay so
that's the continuous student subgroup
problem so now I'm going to tell you
where we get this hidden subgroup
instance from the number field okay how
do we take this and define one of these
functions that we can compute
efficiently satisfies the properties
okay so i've been saying lattice in case
people you know in case you're not
familiar with lattices let me tell you
what the definition is now so a lattice
and n dimensions you're given n vectors
be one through BN in our to the end
they're linearly independent and the
lattice is the set of all integer linear
combinations of the basis vectors so
here's an example in two dimensions so
b1 and b2 or say a basis and you take in
all integer linear combinations and you
get this infinite grid there an infinite
number of basis for a lattice so you
know there are infinite number of basis
for this lattice or for example here's a
different basis for that lattice and
if you hear people talking about hard
lattice problems if you're not familiar
with it one hard problem is given a
basis for a lattice find the shortest
vector so when you look at this picture
you may say oh I can see the shortest
factor it's right there and it's right
near that one basis vector but in
general the basis you're given can be
very skewed very long and it's unknown
how to compute a short vector and there
are a few other problems too that are
hard but that's one of the man's you may
hear of now the basis I mentioned before
that we're computing the log embedding
of the unit group and that it's a
lattice so this is the type of object
we're looking for we're trying to find
it a basis for the unit group a basis
for the lattice ok so I'll try and give
you the idea of where the hidden
subgroup problem comes from i'm going to
use QR joint square root d so this is
only this constant dimension but i'm
going to show you that because i can
actually draw pictures with that but i'm
going to just remind you that the reason
we're doing this setting it up this way
so we can handle high dimensions ok so
the basic idea is you take your function
and you take your your real number here
t in this case it's going to be just our
and you map the two principal ideals so
a principle ideal of is an ideal and oh
that's of the form alpha times oh ok and
the way the definition works is I'll say
that T gets mapped to e to the T times 0
so e to the T is supposed to represent
the D generator for the for the ideal
and but the actual definition looks like
this so if you're given a vector XY this
is what e to the T is it's e to the T e
to the minus T and it does an
exponential stretch in the X direction
and an exponential shrink in the Y
direction ok and if you think about this
it's it's periodic on the units you know
epsilon 0 equals 0 if and only if
epsilon is a unit and that's also true
for any ideal so that gives you
periodicity and it's also one of the one
on the period for the same reason so
it's going to satisfy those two basic to
the
properties we need the main issue is
going to be how to represent either the
tee times oh you know we need to now
come up with a quantum state that
represents this real valued lattice and
you know how do we compute it it's
really important that we have a unique
representation to get periodicity and
they look so that's the type of thing
we're dealing with so to try to I'll try
and make this I'll show you a picture of
what this looks like what what type of
ideal you get out over here so in this
case it's going to be well think of it
as a two dimensional lattice so you can
always take these ideals and embed them
so here's an example with Q a joint
square root 102 okay and the ring
advantages in that case has generator
square root 1 over 2 and when you do
this embedding I'm not going to define
what the embeddings are but this is the
way the embedding works in this case
it's generated by 11 and square root 1
over 2 minus square root 102 so these
two green dots are the generators for
the ring of integers you take all
integer linear combinations that gives
you the that gives you the ring of
integers so this is the lattice you
start with and then you want to multiply
this times e to the T that's the output
of the function e to the T times this
lattice okay now these lines I've drawn
here are the algebraic norm lines so the
algebraic norm is defined as the x
coordinate x the y coordinate in this
lattice and when you do that stretch map
you know if you if you multiply x times
e to the t and y times e to the minus T
you're going to stay on the same norm
line so when you when you start
multiplying by e to the T a point is
going to move along this algebraic
normal I so they're all going to move
like that that's how the last gets
deformed or stretched okay so here's an
example I'll show you a little animation
here of what happens when you evaluate
this hidden subgroup function on
different values okay so here's the
domain it's our so this is going to move
across here and over here we're going to
output e to the T times 0 which is going
to be the stretched lattice
okay well it stopped well if you keep
going and you go back to here then
you'll end up with the the first picture
that I showed you oh okay questions okay
so that's the function so so the idea so
I guess I'm still telling with the ideas
so the ideas you want to take F map it
to some sort of unique representation of
e to the T times oh so now for each of
those lattices on the previous page we
need a unique way to represent them and
if it was an integer lattice that would
be ok because the permeate normal form
is unique representation of a lattice
that's over the integers but over the
reals there's no unique way to represent
a lattice you know it's this infinite
object so you have to specify it by a
basis but there's no canonical basis you
can pick for a real-valued lattice so
that's one of the things we have to deal
with so there are two new self-contained
parts here the first is a polynomial
time classical algorithm for computing a
basis for e to the T times 0 1 of the
issue here is that e to the T is doubly
exponentially large because T is going
to be exponentially large and so you're
dealing with rounding errors and you
know it's something we have to deal with
you and the other way is how to
represent the lattices so what we do is
we first compute a basis classically and
then we create a superposition over the
lattice points of that louse so this is
what it looks like we use the straddle
encoding so you can think of so G is
like a Gaussian so we have a like a
Gaussian weighted lattice we're around
each point we have the straddle encoding
so this picture has narrow gaussians
that's originally what we were using but
now it should be like you know these
spikes that go up for the straddle on
coding so the straddle encoding handles
the rounding of the lattice points and
as a result the state acts basis
independent it can't actually be basis
independent or wouldn't be a reversible
operation to create it but you know acts
basis independent that's what we have to
prove
the spikes are supported on an
exponential number of points yes oh you
mean straddle just straddle at one point
yeah yeah it's on an exponential number
of points in high dimension yeah you
have to ensure
okay yeah so then we have to prove that
this is a hidden subgroup function and
we can you can compute it I'll just say
one thing about computing so the first
step is computing a basis of e to the T
times L and you know so basically you
want to use repeated squaring because if
we're dealing just with principal ideals
here so we can take you the key x 0
multiplied times e to the last times 0
we get you the T plus s times 0 so
that's good but we have to make sure the
representations aren't getting too big
and the rounding is working because the
C to the T is going to be doubly
exponentially large so we what we do is
we alternate two steps so the first one
is we you know think of these as ideals
and we multiply them like a do here you
know we have them written down as
vectors even though their ideals but
given two vectors the way you multiply
it once you embed them in these
embeddings I mentioned this just point
wise multiplication so we can do that
keeping track of the errors and so given
to you just compute all these all these
products so that that's the first step
and then the second step is we need to
reduce the representation size so it
doesn't grow too big and for that we
compute and then we think about these
ideals as lattices and we compute an LLL
reduced basis for them and then we just
alternate these steps so at LLL reduce
basis is going to keep the basest
polynomial size and the determinant
doesn't change as you as you do these
stretches if you pick everything right
so that's going to maintain the size of
the lattice because the determinant snot
growing and the other tricky slightly
tricky thing is when you're doing LLL on
rounded basis vectors you can't just run
it because it'll you know the rounding
messes up it doesn't know when to stop
reducing but since we're if you have a
lower bound on the shortest vector
length in your lattice then there is a
way to do it and since we're in ideal
lattices we do have a lower bound on the
on the shortest vector length so we can
make that work
it didn't oh and one question so is like
ll here runs on a quantum computer on
the classical computer this would be on
a quantum computer on the quantum
computer okay you mean are you doing are
you asking if we're doing in
superposition or somehow yeah I mean I'm
not it's not a it's not a pre-processing
yeah yeah so I'm just processing stuff
okay Simon I'm just kind of curious
wanted to implement you know LOL inside
your quantum computer or is just pre
processing Merson let me think for a
second yeah yeah yeah it's in the konica
because you're you know I mean at least
intuitively you would want to be in a
superposition of T values and then
evaluate F of T okay so you're
evaluating that in superposition but all
this is happening it's okay cool yeah
yes thanks I don't have any gate counts
so I'm a little confused of what things
are simplified because we're we're
describing the lower dimensions versus
what what's required for the general
degree case so it was t always a number
or is t some kind of a more general
transformation could you do this
hyperboloid before and am just kind of
telling you where you were on that but
now you have some higher dimensional
thing right so it's T matrix or
something or yeah oh this is the general
thing well it's you you have a diagonal
matrix e to the T 1 through Yoshi yeah
okay and there's some is 0 they're going
to make sure you preserve the
determinant of the lattices you go
through chachi Thanks
okay and so then we have to prove the
HSP property so here I'll just give you
an idea of what we have to do you know
so for example we want to know how much
overlap there is because we would need
to prove that there's overlap when
you're off by a unit and a small overlap
when you're not and so you would contain
pair like 0 and e to the T times 0 so
this is these are these two
superpositions of lattice points for
different values of T so if T is not
close to a unit you want to have small
overlap so okay this picture isn't
accurate because there's no one
dimensional case but if I draw it in one
dimension then it's easy to look at
right so you can imagine here's a here's
a superposition over lattice points in
another super position over lattice
points and since the values aren't close
you know it's a small small inner
product and when it's close to a unit
you want high overlap and that's going
to be something like this you can just
imagine shifting your lattice tiny bit
and the straddle and coatings are still
overlapping a lot so you have high inner
product and then we have to prove some
number theoretic properties about you
know when these transitions occur to
make sure that they aren't the lattice
points aren't too close and ideal
lattices and so on as we as we stretch
them and we prove the HSP property okay
so that's that's that part that's how
you set it up so maybe I'll just say a
few things about the high degree HSP
case so that's the last step so here's
here's the problem we want to solve now
again just to remind you so this
continuous HSP it's on r to the n takes
values of quantum states and has these
three property so it's periodic distinct
on cosets and it's Lipschitz we're
trying to figure out what the this
hidden lattice is now the intuition is
sort of something we've understood for
you know ever for a long time if you
want to solve this type of thing you
would compute you evaluate the function
in superposition you measure say you
measure your function value you end up
on a random co set of the lattice you're
trying to find V Plus L so because you
have this this random thing in here
messing it up
so you can't just measure this you
compute the Fourier transform then
you're sitting on the dual lattice and
now if you measure you get a random
point is a dual lattice so you would
repeat this polynomial many times where
you get a point the dual lattice once
you have a set of generators you can
compute the lattice from the dual
lattice and that's the way the algorithm
should work right so the problem now
though is like you know there's there's
more going on because we're in a real
value we have real valued points so
these guys are all getting rounded all
over the place and you know Fourier
transform over which group lattices are
infinite objects and you have to cut
things off somewhere and it's in high
dimensions and so if you start just
trying to grind through it like with the
constant degree case you can see that
like maybe you find some points
somewhere and some points might be
missing and places you just can't even
analyze it and so you know the way the
reason the constant degree case worked
is because we could analyze it in a
point around the region around the
origin sorry that that in like some
region around the origin you would get
good points and because it was constant
degree at a high probability of
measuring those points but now in high
degree of an exponentially small
probability of measuring in that
location so that's the problem
okay yeah so what we did differently
this time since now we have this
continuous functions basically we just
kept everything continuous for as long
as possible and only round it off at the
very end of everything so first we
analyze everything in the continuous
world we could use generalized functions
and we could think about the super
positions like this you know like this
is evaluating the function in
superposition we compute the Fourier
transform over R to the N and now
there's a these round off errors aren't
aren't hurting us yet and so we end up
getting some some communities of diagram
where this is the what I drew in the
previous slide if you had started here
and you get over to hear you want to try
and analyze that there you want to try
and show that you're concentrated that
this thing is concentrated on L star and
then you want to discretize stuff so you
actually only want to evaluate your
function on a grid so you can think of
restricting this down to Z to the N
instead of r to the n down to Z to the N
so now you're on a grid and compute the
function or Fourier transform over Z to
the N and then if you discourse eyes if
you get discrete samples out of this
thing in the end and that's finally with
the algorithm is so so that's what we do
we analyze these things like this you
know this and the whole diagram we show
the diagram works and what happens when
you discretize ok so i could think
that's all I'll say about that for now
ok so recap so show you show you how to
set up an algorithm to compute the units
of an arbitrary degree number field
biasa t and song was extended this to
the class group and the principal ideal
problem so the assumption in the crypto
system that I mentioned in the beginning
I just mentioned what it is it's
something called you in short generator
principle ideal problem it was used in
these three these three cryptosystems so
if you think about the sequence of
assumptions you can make in lattices you
start you might start with lattices say
over the integers and then you could
make the assumption that you take a
special case of ideals from number
fields which is what they do to make
things more efficient
and then you could say well instead of
using ideal to use principle ideals and
then you could make another assumption
and say not just principle ideals but
principal ideals with short generators
okay so that's the assumption that was
made in here so these types of lattices
and that was the one that was broken so
in their case it's for a power of two
select cichlid omix you can use quantum
algorithms to get some generator for the
principal ideal and then the classical
algorithm that I mentioned can you can
compute a short one by solving BDD in
the unit lattice okay so open questions
are still more number theoretic problems
towers of number fields hilber class
fields I think that this result with the
lattices is pretty exciting I mean I
don't know what will happen next but you
know I think it's still good to know if
the shortest vector problems are hard in
these bigger classes and there are other
homomorphic scheme circular security and
lots of questions there so I'll stop
there thanks
anyone have any questions so you
mentioned I'm on one of your first
slides that quite a bit earlier you had
worked on the unit problem for a
constant degree and so it wasn't totally
clear to me like obviously you talked in
this context about that how it grows as
the degree you know goes to infinity but
we are you saying that for any fixed
degree which is true for crypto like you
just take some instance of soliloquy and
it's for let's say degree you know n
equals 256 or whatever it is that you
actually had algorithms that would have
worked before that first for that
constant degree and if so like how do
they compare because usually you hide
all the constants terms and things like
this how do these algorithms compared to
what what you had before their quantum
oh well didn't on one of your first
slides didn't you say that in 05 you
already had algorithms for finding water
malraux quantum algorithms yeah how do
they compare like the degree is actually
fixed for crypto that's something that
people usually ignore right well so for
a fixed degree how do they compare these
are asymptotic results though I mean I'm
not even thinking about I don't even
know how you would compare it are you
talking about like running it yeah
mm-hmm quantum computer for that though
well do you estimate it right the crowd
have they oh I don't know yeah I guess
yeah maybe somebody somebody could do
that yeah yeah that's the question I was
going to ask is what kind of costs do
you think you know if you this is
asymptotic with Constance with numbers
of qubits numbers of gauges how hard do
you think this would be on a quantum
computer hard any other questions okay
well on that note we'll we'll invite
whim come on let's think Sean again</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>