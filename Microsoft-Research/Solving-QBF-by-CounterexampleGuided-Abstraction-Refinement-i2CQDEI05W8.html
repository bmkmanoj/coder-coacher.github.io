<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Solving QBF by Counterexample-Guided Abstraction Refinement | Coder Coacher - Coaching Coders</title><meta content="Solving QBF by Counterexample-Guided Abstraction Refinement - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Solving QBF by Counterexample-Guided Abstraction Refinement</b></h2><h5 class="post__date">2016-06-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/i2CQDEI05W8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
hello welcome everybody so it's my great
pleasure to introduce Michael hacia
notice so he's going to present some
very advanced techniques for solving
quantified boolean formally so and
please welcome to his postdoc interview
talk okay so hello everybody so today
I'll be talking about quantified boolean
formulas and before I do that let me go
back a little bit in time so there's
this famous quote by by lightness that
many of you probably know where he said
let us calculate and it was this
brilliant idea that if we encounter some
some problem in philosophy or ethics or
whatever we we start calculating in some
well-established calculus and we resolve
this problem so of course an amazing
idea because it mean that we could use
calculations not only due to reason
about taxes and and groceries but we
could actually really answer some things
about the real world of course as some
some horrible things happen in the
meantime so it was shown that logics are
incomplete and and Turing machines are
undecidable and and then we have
complexity theory that shows that even
even some very small problems are really
hard to compete and now the good news is
I think is that people kept going so
they still kept working on these
problems even though we know their heart
and the result of this that now we have
machines or we have tools that really
can reason automatically or
semi-automatically about some real
practical problems and what I think it's
been really fruitful is to look at
certain fragments of logic and build
tools for these fragments and like this
get some really nice result and today
I'll be talking about one such fragment
which is q BF quantified boolean formula
and of course I need to say something
about sat before I say something about
QBs so sad is this little innocuous
problem that we have a propositional
formula and we're supposed to find an
assignment that makes it true so you can
have something like like this X or Y and
X or not why and you can set X to true
and y2 anything and that makes it true
so so this is this is a really nice and
simple problem now qvf is almost the
same you can just write some additional
quantifiers so we can say something like
this for all X there exists Y that X is
equal to Y now because we're still in
the boolean domain we can rewrite any q
BF into a into a propositional form at
their facility and everything is
bullying finite decidable so so the
universal quantifier is actually a
conjunction and the existential
quantifier is actually a disjunction
it's really you can imagine this as a
shorthand so if we take this this
example and I start inside out and I
start rewriting the inner quantifier i
plug in 0 I mean false and one into the
formula and build a disjunction and I
had the same for the conjunction and I
get something that doesn't contain any
variables and I conclude that the
original formula was actually true but I
just purely bullying some
simplifications here of course everybody
can already see the problem with this I
cannot do this in general because the
formula blows up exponentially right so
this is obvious not the way how to
calculate if a q BF is true or not now
there is a really nice correspondence
between sat q BF and complexity theory
for those who like complexity theory so
SAT is np-complete and as well q BF with
only one quantifier is in the at the
first level of polynomial hierarchy and
as you start writing more and more
quantifiers you're going up in the
polynomial hierarchy until q BF in
general is pspace complete
okay so in in q BF we are moving from NP
complete problem to AB pspace complete
problem okay so this is a kind of a
theoretical classification now there is
also a very nice relation between q BF
and two player games and this is maybe a
little bit less known for this we
consider qbs in in so called pre next
form which just means that we have
always a bunch of quantifiers at the
beginning and just the propositional
part so it will always look look like
this for all some variables exist some
variables potentially some more
quantifiers and then only the
propositional part okay so this is what
we call pre next form and I'll stick to
this for the rest of the talk now if we
want to formulate this as a game we say
that there's a game between two players
one is the universal player and the
other is the existential player okay and
the universal player tries to make the
matrix the propositional part false and
the existential player tries to make the
matrix true and a formula is false if
and only if there is a winning strategy
for the universal player and formula is
true if there is a winning strategy for
the existential player okay the matrix
is just a propositional part oh it's
just called that way it's just a name I
mean well I mean the whole thing is the
formula and and I mean it's tabula rasa
every yes I mean do you have the formula
and the quantifiers it's called the pre
necks and sorry prefix all right I'm
also got prefix and the the inner part
is called the matrix it's it's just just
the terminology that's been used in the
community yes so this I mean of course
in general you don't need to consider
these cases but for this talk which is
consider
in front no okay it can be anywhere and
the prefix can be as long as you want
okay okay if we go back to the example
we've seen again we have only just these
two quantifiers so we know this formula
is true so there must be a winning
strategy for the existential player and
here it's really simple the winning
strategy is play the same thing as the
universal player did okay so so the
existential player will wait if you is
true or false and place the safe same
thing and that makes the matrix true yes
yes so so actually if you do not like
formulas you can think about qvf as a
two-player game okay now so we have
these relations of course we should
really ask why are we interested in
these formulas in solving these formulas
so again let's go back to sat so there's
this huge success story which is I think
quite amazing that has happened with sat
in the last two decades so many of you
I'm sure know that in the mid-90s SAT
solvers became really powerful and there
have been used for hardware model
checking reasoning about circuits more
recently by informatics at many other
other things and I think even even more
interestingly they gave rise to new
tools for more powerful logics so smt
really derives from from sat there's mac
SAT solvers and sassette programming and
today I will also show you that you can
build a QB of silver using a SAT solver
as a kind of a black box machine now
okay so we have this huge success of sad
now the question is can we replicate at
least a part or some portion of this
says with q BF right so one thing to
observe is that we're really solving a
fundamental problem which i think is
positive right so SAT is np-complete now
we're solving a problem that is pspace
complete and also there's this relation
to two player games so this is this is I
think a good sign that we're really
solving a problem that is somehow
fundamental and so any pspace complete
problem can off can be expressed as q BF
right of course there there are direct
applications of q BF to two parts of
model checking circuit synthesis other
things like non-monotonic reasoning and
conformant playing planning sorry and of
course now we similarly as in set we
would like to ask can we build other
tools on top of queue BF right so can we
in today in integrate q BF into S&amp;amp;T
solvers for instance for quantified bit
vectors you know can we do optimizations
with q BF and actually we already did
that partially and of course who knows
so i think really the interesting part
for me is to build solvers for problems
that we don't know yet right but but so
this is kind of the motivation we want
to look at q BF and and solve eq BF
formulas okay so let me get a little bit
more technical here so we have seen this
parallel ism between gains and q BF now
i will introduce this very simple term
that will help me later on which I call
the winning move and this is really very
intuitive I will define it recursively
so if you have just one quantifier what
is the winning move okay so if the weird
the existential player the winning move
is something that makes the matrix true
just no no it's all sorry whenever I
write capital letter
I mean multiple variables guys this is a
bunch of excess that's a bunch of extra
support you couldn't face this with a
single verbal at the time you could but
it it's actually nicer to to your not
yeah yeah little technical I mean you
could but because actually if we are the
existential quantifier this is really
just a sad problem right we're asking is
there an assignment all right so there
is a direct mapping between one
quantifier and a third problem is it a
QB F so the person is an assignment
makes by true position yes so in this
particle cage this is just the last one
so yes so this is so there's a kind of a
recursive definition so for the for the
base case 125 okay so the winning move
here is an assignment that makes the the
matrix true if we're the existential
player and conversely it's it's an
assignment that makes the matrix fault
if we are the universal player okay so
this this is the contradicting objective
of the two players right so this is a
very clear for the one for the general
case well I make it very simple I say
that it's such an assignment that when i
plug this in there is no winning move
for the opponent ok so imagine you're
playing chess right so a winning move is
such a move that the opponent cannot
find them a move to win the rest of the
game no proposition because the move oh
yeah so this is this is far for it does
the rest of the can be a cowboy yeah
capital Phi yeah there's a bunch of
conventions that are a little tacit here
um okay of course in the opposite case
if I play some move and the opponent is
still able to win the rest of the make
the game he had played a countermove
right so that this is another term that
i'll be using now all right so I can't
remove is something that the player was
was able to play and win the rest of the
game right so this means that my my move
was not a winning move because there is
a comfortable is everything okay okay so
this actually this is really nice
because we don't really need to worry
about qvf this is really this still
works with the analogy of two player
games we had actually whip if we have
this definition we can immediately build
a very simple q BF solver really make
sense if you say i can't remove full the
assignment town yeah yes yes yes okay so
to say something is a countermove
doesn't make sense yeah yeah exactly yes
very good point yes thank you okay so
now we actually can build a very simple
qvf solver using a Sat solver based on
these definitions right because for the
base case well we know how to how to
solve how to compute a winning move well
if we're the existential player just run
it SAT solvent right and the SAT solvers
are very efficient so this so this is
excellent right if we're the universal
player in well it's it's also not too
much more difficult with just negate the
formula right we just want to make it
fall so we find a satisfying assignment
due to the negation so this this this is
really a simple now the problem is what
do we do in the general case well let's
just start with this naive algorithm
that will just try us Paul possible
moves okay so we start with the pool of
all possible candidates for moves there
are exponentially many of them right
because if we have many variables
there's exponentially many assignments
and we always pick one assignment we
plug it into into the formula and we run
recursively this out
for them to test whether there is a
winning move for the opponent if there
is a winning move for the opponent while
we have to keep on going if there is no
winning move for the opponent we have to
we can stop because we have a winning
move okay so i mean this this is a kind
of a stupid way to play chess so you
play a move you lose you go back and you
play another move and you lose and you
go back and so this is essentially a
backtracking process I just formulated
in this in this fashion because we will
try to refine this this approach Hugh
Cuba duality showing up here somehow to
see something getting inverted in these
successes so what happens here you you
plug in the candidate yeah and that will
remove the first qualifier yeah so now
you have did the opposing quantifier at
the beginning he was used in this sound
gud isten like you're taking from the
model which is negative having found
something so um so I actually what
happens is it's used at the very end
right yeah because and in the base case
so this is the so this that we have we
are assuming that we have these
definitions right in the for this
procedure and so essentially you plug in
a bunch of assignments and you test
whether it's satisfiable or not at the
end right right so I mean yes this is
again so so when you plug in the value
for the first quantifier you remove it
and then you move on to the opponent
okay so so this is we all agree this is
a horrible algorithm we don't want to
use that now we can make an observation
here that this naive algorithm is not
making use of the counter move right so
played and we the opponent beat us with
something we don't know I mean we don't
do anything with that right we just try
different moves and we're not learning
from from the from this experience so
here's an idea how we can learn from
from this mistake or from this counter
move and we will build another smaller q
BF which I call the abstraction and each
time we are hit by a new counter move we
strengthen this abstraction so that we
are not beaten by the same counter move
again okay so and this this
strengthening we will call refinement so
here is a pictorial representation what
is going to be happening we have
initially abstraction is all possible
moves and each time we we are beaten so
we try some candidate move we're beatin
we strengthen the abstraction and so on
until we somehow approximate very well
the set of actual winning moves for the
actual game for the initial game right
and hopefully our next candidate will be
from the set of winning moves okay for a
single qualifier so it's the logical to
us yes it's a recursion so this will be
done in every and every level of the
recursion yeah so I mean you can of
course you can think about this
algorithm in different ways I like
recursion but but of course you cannot
but eventually the levels will go in
there but it will be as many levels as
there are quantifiers of the recursion
okay now how do we do refinement in q BF
so this is little technical so that so
imagine you have accessed bunch of
variables for all a bunch of variables
and the rest of the q BF okay and now we
played cow
all so we played our candidate move and
the opponent played mu which is that the
counter move right so if we plug these
two in we're losing so what we want to
win and then somehow we discovered
exhaustively yeah somehow we discuss
them how we discovered that the thing
was false yes yes exactly yeah so it's
the recursion that discovers that so so
what we will do is for the next
candidates we will make sure that the
candidate move will be a winning move
for the following game we plug in the
counter move ok so we consider a
simplified game where the opponent is
kind of stupid he plays always the same
move and we make sure we win this game
ok so this means that next time he
cannot beat us with the same move
because we made sure that we are we're
sort of proof that we're robust with
respect to this particular move of
course we need to somehow be robust with
respect to multiple counter moves so we
will be iterating this process we find a
bunch of counter moves so this is again
a little bit of algebra or boolean logic
if we have multiple counter moves where
the existential quantifier we plug in
these into the games we have a bunch of
smaller games and we compute a
conjunction of these games so actually
if you look at this from the definition
of q BF what is happening is that here
the universe quantifier is being
expanded but what is interesting is that
it's not being expanded exponentially
but only as many times as we have
iterated our process okay so this is
much smaller than the actual expansion
that we would have built according to
the definition so this is obviously a
weaker constrained right
recursion yeah oh no you have to forget
all this work when you move to the next
level yes I mean there you can this is
this this little technical I mean
there's ways how to how to keep this
some information but then it grows in
memory and yeah but essentially let's
say we forget yes ok now ok just a
technical note when we are the universal
player instead of conjunction there's a
disjunction which again goes with the
according to the definition we are
essentially expanding the existing show
quantifier here this is this is really
just a do already think it's not not
that interesting ok yeah really you
would think that when you're playing as
a universal quantifier then the
existential quantifier might make a
choice of a function of what you doing
it's it's really there is no it's
completely dual there's this is getting
nice about this game perspective because
the existential tries to make it true
and the universal might try to make it
falls right and let's say I real able
false to 22 true and I real able true to
false I mean it's it's just a label I
mean it actually doesn't matter that we
call it true or false I'm not sure if I
answered it but I mean you can have a
strategy for for either of the players
so the next candidate is a winning move
for blah life is to a danger that you
might have eliminated too many
candidates no no this is always now if
you said make sure the next candidate is
not a losing move for blah then I'll be
with you yeah it might be somewhere in
the middle minded no no it's it's it's
essentially what you're saying if I
understand correctly where what we're
trying to do is that we're not beaten
but this is my terminology that I like
to use that we're not beaten by the same
counter move that we've seen so far so
right
and we know the opponent can beat us
with fool and so we make sure next time
we try a new candidate that we're not
beaten by foo it's really this really
simple idea constant is not it is a
constant it seconds use max up to me
actually generalize well up you could
try to generalize at this point I this
is of course very interesting but at
this point I don't know of a nice way of
doing it I have some ideas but it's not
it's not that easy I mean yes so yeah
finally is a proposition that here in
sorcery sorcerer ah no this is a QB
effing wolf is a little fight is a
proposition but this capital Phi is as a
cobija then you when you do the
conjunction you're no longer be nice yes
that's true okay I was hoping nobody
spots that 1536 I yeah I mean so again I
there is there some technicalities
hitting hidden I have to do the pre
nixing afterwards these all the
qualifiers yeah yeah yeah I'm really
happy that you asked these questions so
actually actually that's something that
I so what we managed to do so I don't
know this is not shown in the talk but
we managed to do that we duplicate only
the next quantifier okay I mean we maybe
we can take this offline but it's a bit
of a technicality I wanted to but this
is a very good point we need to pre next
two to get rid of this problem and there
is a way how to not duplicate everything
and is actually I think important but
very point so okay so let me get
so if we combine everything together we
get this the Sun simple algorithm for
solving q BF so in the base case it's
all the same we just run a Sat solver to
solve the problem that's that we've seen
is easy and we know that SAT solvers are
fast so that's amazing now we build the
abstraction at the beginning of the
iteration so it's either a conjunction
or a disjunction of these smaller games
now we solve the apna here is the hidden
think that you pre next so you solve the
the abstraction and now if we cannot win
the abstraction we're done right if we
cannot even win this smaller game well
we cannot win the big one right so we
stop however if we won the obstruction
we need to test that this candidate is
really a good candidate right so we move
on and test if it's a good candidate by
another recursive call so it's two
recursive calls here and if we with the
opponent is able to find a countermove
we stop a sorry if the opponent is able
to find a countermove we added to the
set of counter moves we are considering
if the opponent is not able to find a
countermove we know that we have a
winning move ok let me stop okay so this
is this really nice algorithm there is a
modification that everything is not
duplicated in the pre neck sink I will
not show that I have implemented this in
a solver called verax actually last year
there was a QB of competition so the
solver won the the application track and
it's a cactus pot here so actually the
solver really there's a big difference
between the current solvers and what my
solar can do so this is the number of
instances and this is the number this is
a times in milliseconds so if there is a
point here it means that there were 500
instances solved in 400 second
alright so there were hunter instances
solved very quickly to honor incentives
still very quickly and eventually to
solve more and more instances that the
time using these are united ordering
them by how long they took to take yeah
I took two so okay yeah so school to the
White is better yes yes okay exactly is
you yes yes so this is thank you were
better yes excellent yeah yeah yeah just
there's always somebody who essentially
that's the conclusion and yes this is so
in the time out here is 900 second okay
I should point out this is an
application track I it dissolver also
worked well in other trucks but I was
not the first in those tracks but I also
this because this was part of the the
 olympic games i got a curt cattle
medal for this okay so this is a sort of
like empirical evidence for for this
solver being good or we're definitely
interesting to look at right and now I'd
like to put shows a little bit of
evidence that it's also interesting from
the theoretical point of view so now we
have a bunch of techniques for solving q
BF and mainly we can divide them into
expansion based and DP ll base so
expansion is basically what i showed you
now you take the quantifiers and you
expand them according to their
definition d PLL is that you take a SAT
solver and you make it work for 4q BF
okay so we have these two worlds d PLL
expansion now the question is are they
different really right and there is this
popular approach how to decide whether
some solving method is is different or
better than another one is to look at
some corresponding proof systems so
instead of looking at the solvers
directly we define some proof systems
that correspond to these solvers because
we
compare proof systems and then we can
conclude something about solvers what do
I mean by a proof system essentially you
can think of it as a certificate right
when the solver stops it not only gives
us yes or no the form is two or four but
also gives us some proof that it is true
it is false that we can check in
polynomial time with respect to the size
of the proof so it no it would be for
existentialist below for universal no
yeah okay so you should go yeah now of
course I should mention proofs are also
interesting as certificates right for
the correct and so we don't have to
trust the solver we can just check the
certificate so that's a practical
component here but also we're interested
in proof systems for for comparing
solvers right now how would a proof
system look for for expansion well I
will again I will made many many details
and I'll just consider this very simple
type of formula where we have accessed
bunch of quanta variables one single
Universal variable axis and bunch of
variables and a propositional part okay
so let's just look for the time being
let's just look at this formula or this
set of class of formulas how do we prove
its false so let's prove its false well
we took our definition of universal
quantifier and we expanded into a
conjunction now there is this technical
issue that has been rightly posed before
that now d the third variables are
duplicated here it's no longer pre next
well we can get rid of it we will name
them and push them forward its operation
is called Prine axing and and this is a
quite standard so now actually we have a
sad problem right we are saying is there
a set of is there an assignment to these
variables that makes this propositional
form your true it has more variables but
it's
preposition okay and we know how to
refute propositional formulas we have
normal resolution right propositional
resolution okay so let's say this is our
proof because and it is a proof in the
sense that we can check this in
polynomial time you check that the
expansion was done correctly and you
check that the propositional proof was
correct and all these steps I can check
in polynomial time we have a more proper
proof system defined in our papers if
you're interested but yeah let's just
think about a proof system for this type
of formula look like this so we have a
proof that shows that the formula is
false okay now so this is for expansion
now what about DP ll well we're not in
luck here because Hans klein abune inc
and sorry dbl dbl so so there's this
other family of solvers that are based
on the DP ll procedure essentially on
sat solvers right that they extend SAT
solvers and we're asking is there a
proof system that corresponds to this
family of solvers and there is a proof
system actually defined in 95 by Hans
kleiner building and colleagues which is
called Q resolution and again I will not
go into the technicalities it's almost
the same as normal resolution so we have
a we assume that the matrix is in CNF
here is a small example we can resolve
as as in normal resolution we can
resolve on existential variables and
then there is an additional rule out to
get rid of universal variables that
under certain condition we can remove a
universal variable and eventually we get
to a bottom to a empty clause okay so so
sorry but I had to skip the formal
definition here it's just for you to
have an idea about what is Q resolution
now we would like to build a formula
that is hard for Q resolution but easy
for expansion okay I'd like to give some
ingredients some idea of
of the of this construction here so what
are the ingredients of the proof because
we would like to show that our expansion
based approach is somehow fundamentally
different from this DPL approach right
so I mean because these proof systems
are somehow corresponding to these
solvers right and so if we can show that
there are formulas that are hard for one
proof system but easy for the other
system it means that it must also be the
case necessarily for the solvers right
accident to the implementation of the
soul yes exactly we want to kind of
abstract firm from implementation
features we know that for any run of the
solver we can produce a proof in this
proof system in linear time right so so
whenever we have some information about
proof system then we can conclude
something about this there's a solar can
possibly cover the prove quickly yes
exactly exactly yes thank you okay so
i'll just give some highlights of this
construction so we try to build a
formula that's hard for 4d PLL meaning q
resolution but it easy for expansion
okay so this a is really just highlight
hopefully it will be it will give you
some idea what what the proof looks like
so we know that the formula is false so
we want to find some false formula that
is hard for the proof system and we know
that for any false formula there must be
a winning strategy for the universal
player okay and not only that we know
that from any cure resolution proof it's
possible to extract at this strategy
efficiently from the proof okay in
polynomial time and moreover it is
possible to express this strategy as a
circuit with bounded depth okay so
whenever I have a queue resolution prove
I can derive a search
for that represents strategy for the
universal player as a circuit with
bounded depth and we know from circuit
complexity that the priority function
cannot be expressed as a circuit with
bounded depth okay so I mean the bounded
depth circuits this class is called AC 0
in circuit complexity if you if you like
that kind of stuff but it by AC 0 I mean
function that can be computed with
bounded depth and now the last important
ingredient in this construction is that
we can build formulas that force a
certain strategy for the universal
player and it's really simple so we
consider this this form that we had
before accessed X 1 single Universal
variable some existential variables and
the matrix is constructed from some
function f and we say that it must not
be equal to Z okay now there's only
single way how the universal player can
win this game and that is by playing f
yeah because whenever have axis has been
assigned a value the universal player
just computes what what is f and that
makes this this part false right so that
is is equal to F so this becomes false
okay so there we have a formula that is
a single strategy for the universe
player and which is which is playing
exactly f right we put all these
ingredients together and we have a hard
hard problem for Q resolution so we say
we pick F to be the parity function so
we say okay we have this this formula
where this strategy for the universal
player is the priority function we build
a cure resolution proof any Q resolution
proof and we know that in polynomial
time I can construct a strategy in that
that will be a bounded depth circuit
representing the parity function and
from circuit complexity we know that
this must be exponential okay and of
course this means that everything is
exponential the proof is must be also
exponential because the strategy is
exponential and the strategies
polynomial which is expected approve now
I should also mention that this problem
is easy for expansion and it's a again
this little technical but so you have to
trust me a little bit essentially what
happens is that you you encode encode
this into let's say CNF right and you
expand the universal quantifier and you
just get a formula that says parity must
be true party must be false at the same
time and then you need to refute it by
resolution that turns out to be quite
easy okay so I hope I convinced you that
there this new algorithm for solving q
BF is somehow interesting from both
theoretical and practical perspective so
we have some some benchmarks where this
performs well and we have some
theoretical understanding that this is
fundamentally different from the
existing solvers it is fundamentally
better in a few cases that never show up
in practice and fundamentally worse in
lots of cases oh yes yes yes you
hazarding that it might be better in
many common cases well actually let me
say a few words about this okay the
answer to that yeah it's going up anyway
um so actually no I again I've hidden a
lot of details who can check the papers
so what we did in our last few papers we
define a bunch of lie for expansion
based solving and there are some other
calculi 44 DPL solving and we built this
graph comparing all these different
calculi so now we we have these two
worlds of lied that somehow derive
from from this idea of expansion solving
in DPL base and really what it boils
down to the the information that that
that we can conclude here is that
they're incomparable essentially right
in the meaning that there is always a
class of formulas when the cut where one
calculus performs fast and the other one
fails and but also the other way around
that for the same pairs of calculi there
is another cause of formula where where
it's reversed okay so essentially what
we really want of course I think it is a
great motivation for for people who
develop solvers of like myself I hope to
to come up with some solvers that will
somehow encompass all these approaches
so I think this is this bin for me was
tremendously beneficial to do this
theoretical analysis because we can
really say that the solvers are not
optimal in some sense we know no better
way than to run the two in power yeah
and see what yeah yes and RC it's a
little bit worse there are some cult fly
here that have no solvers that
correspond to it if somehow generalize
these ideas but they're so I mean so
even even for these calculi we're still
missing solvers I mean I think I hope
I'm not too far from coming up with with
somebody I have some ideas for this but
it's too early to say anything okay so I
mean we just check which side is green
on so this is the the expansion base
solving you yes you mean to Hima yeah
and then there's the DPL by solving the
key resolution yeah yeah there's there's
been uh actually recently there's been a
kind of a surge of of calculi and
analyses for q BF okay so we have this
theoretical and empirical analysis of
course now i think that the hard
question now is who cares outside of the
q BF community all right so i'm happy to
say that many excellent people
have picked up some of these ideas and
implemented in other settings so namely
there's been some work in circuit
synthesis there's a paper from SSRI
which actually takes this approach and
lifts it makes them generalize it for a
fragment of first-order logic which i
think is amazing then there is there's
some papers for four games so
verification of these did so there's
this correspondence between games so
this is what we expect recently I
learned about this paper that use using
directly my solver to solve some
verification problems in multiple clock
domain I still haven't quite understood
this this domain so as something I'm
learning about so I think this this is
really nice so we have we have seen some
some fruits of these ideas that really
people are picking them up and using
another setting your algorithms
beautifully six different teams to do
these to do those things yeah yeah but
what happens there I think you know my
disappointment here and this is what I
would like to get on and to now is
they're not really using the solver
right they're kind of using the idea but
not the solver and this is is this one
question for for us right who write the
solvers how do we how do we improve the
solvers so people can really use them
kind of odd a box right so I know
somehow do drew an implementation yeah
not taking your cold yeah yeah sorry you
know the idea would be that they take
their problem encoded into q BF and run
my solver but apparently too much
information is probably lost in the
translation to q BF
so so I think so I was thinking about
this you know what is my vision for 4q
BF how do we go on from from now so I
think there this is maybe rather trivial
but I think it we're lacking in this in
the q BF community now there's these
three pillars that the solvers and the
ideas behind them the people use the
solver so we won't like them to use the
solvers and the theory right and we
would really like to have tight
interaction between three pillars so we
build a solver we give it to the users
they're not happy with it we build a
better solver and similarly we build a
solver we analyze it theoretically and
improved solvers so I think this so this
is what I've been trying to do but it's
it's it's of course hard so I'm actually
happy to always to show people like here
that I know that you're using
quantification in your work so so
hopefully we can I could also learn from
from your applications and maybe we can
generate benchmarks and so on api these
days yes in a little input language yes
so it's very easy to plug in you on it
yeah it's the same truth to keep you
there is but actually it's it's more of
a downside then so actually what has
happened is that people just build on
sat solvers right so sat solvers use CNF
so Q bf's were built on CNF and now what
has turned out is that it's very bad so
actually going to CNF from let's say a
circuit is detrimental to Cuba okay so
actually standardized in Berlin use it
that one yes you're gonna change the
standardized yes so I mean there's been
some recent work to come up with a
language that would be non pre necks and
non CNF so of course and now that's the
issue it's no longer easy right now I
mean that's it easy but it's it's it's I
mean compared to to die max to CNF is
all of a sudden we are talking about
some circuits graphs and and
some in the implementation of parsing
let's say is all of a sudden much harder
standardized interface this this
interplay between users and souls it's
just not going to happen yes yes yeah
yeah I mean there is one one version
already out so okay to concretize some
of these ideas so one thing that we
already came up so we have new calc lies
in calculi for q BF but no soldiers that
correspond to these calculi so we should
look into that we should understand
better why is it that that the solvers
fail to apply in these scenarios so
people use the idea but not the solver
right so that is really that should be
somehow something that we should be able
to overcome and what what this might
also entail is to generalize what seems
to be really a high priority now is its
quantified bit vectors so actually one
of the papers that I shown is is using
yikes in in a instead of a Sat solver
right I mean you take my algorithm and
you replace it with yikes and so then
then then the solver already knows how
to deal with bit vectors okay so okay
this this kind of concludes this
presentation about what I've been doing
on q BF in past few years so so I hope I
convinced you that we have some nice
algorithm for solving q BF and that is
both interesting both empirically and
theoretically i would also put some
advertisement here so i've been if
anybody is interesting interested I've
worked on other tools in the past years
so like package management systems I've
also built a Mac SAT solver and and as
there are some other smaller tools that
you can see my
website okay so this concludes my talk
and I'm happy to take questions thank
you I have a question so it looks like
if you if you consider the algorithm
actually did this sigur loop it's not
that tight we connected to the boolean
case and so that's what we also hinted
that you can plug in yikes instead of
sat yeah so work have you considered
going sort of two other so the theory is
beyond bully instead of so if you have
the Q &amp;amp; F but free / take out to be and
so to replace integers what Simon gloves
so much yeah I mean I was thinking about
this a little bit i actually I talked to
Nikolai burner this summer about this
and it's it's so I mean I am it's too
early for me to say some definite answer
of course it's not easy because we're
considering we know that in this case
the set of moves and countermoves is
finite so this will we know that it will
terminate so we need some way for
integers let's say we need some way of
actually grouping the counter moves and
moves into some some sets that that make
the whole set finite right and it I we
gotta hope that well maybe it should be
possible so I mean of course you know
very well there's these decision
procedures for for for linear arithmetic
sore where you actually are able to
split the space into some finite set of
polyhedral or so maybe this could be
applied in these settings but it's it's
still yeah I'm not not sure at this
point but it's something that I've been
also considering kiss okay think
more questions the counterexample guided
thing that you describe this there was
two calls to solve oh yeah and the first
one of them was to do with sort of
avoiding choices to kind of get was a
kind of you could think of it as a
heuristic like you say try to avoid
choosing am you with that choosing at
our crime that has her losing moon so
doesn't have to you don't have to have
guaranteed answers there could you
imagine having some approximation to
solve you know some some much quicker
decision procedure it would say well it
looks as if it's likely that this this I
we would have to consistently Oh on one
side of the other did you see I mean you
don't have to have completely precise
answers yeah II for the guiding part
deux yeah well I mean you you you want
to guarantee completeness right so you
need some guarantees actually I mean I
think they're I mean they're I let me
give two answers someone one is that you
can actually try to look you actually go
the other way that you want to have a
heuristic for searching for the
candidate right so you want to find it
not only a winning move for the
approximation but a good winning move
for the other action so this is like
going making it actually harder than it
any easier then what I what I saw
actually recently so Nina nordiska what
she did in her work for solving these
these games what she did was that
instead of considering this this smaller
game so if I'm I understand is correct
from the paper is that she would say
that we're not solving this this this
abstraction as a smaller game but we're
assuming that the the opponent is
collaborating with us actually we're
assuming we had a stupid opponent right
so this this may be answers partially of
course I mean that i could imagine there
could be some some more heuristic
approach may be based on local search or
or yeah
but of course they're the problem is how
to ensure completeness if your insist on
that right I mean if maybe you don't
well I always try to build things that
are complete escribe only limited
intelligence to the opponent they assume
that the opponent is operating a
strategy and that strategy is somehow
bounded by notations or complexity and
we the good guys only have to protect
ourselves against that degree of
intelligence and making strategy is
explicit with which you do in your
theoretical construction might be a way
of guiding the search or solution yeah
this is an excellent point so them so
actually it took me some time to realize
exactly this and I I have some ideas for
for this so actually what habit is
happening here there is an implicit
strategy as you're saying so actually
the strategy is will will be we're
building a strategy that is getting
stronger right we're thinking the
opponent initially we try an opponent
that always plays the same move and then
we build a strategy where he tries these
two moves right and then we try a
strategy that try and so on and so on
but of course it actually and this was
also you you you ask that at the
beginning this might all together be
really bad because these are constants
it might be much better to consider a
function that looks at what what what
the opponent played and and calculate
the answers I mean now we have
essentially it's an if-then-else
strategy right so essentially you're
considering a strategy that is just oh
let me try that let me try that let me
try that yeah yeah table lookup so so of
course the hard part is you know how do
you the problem is that you need some
good search in in this in this space or
strategies so that's hard I mean so in
constants it's a it's a nice search
because we just go one rector one
victory at a time but for those
strategies as a set of functions all of
a sudden it it gets more complex let's
say we take the last question into you
you raise your hand before okay let's
think because you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>