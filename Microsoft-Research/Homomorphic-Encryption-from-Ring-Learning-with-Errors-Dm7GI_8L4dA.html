<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Homomorphic Encryption from Ring Learning with Errors | Coder Coacher - Coaching Coders</title><meta content="Homomorphic Encryption from Ring Learning with Errors - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Homomorphic Encryption from Ring Learning with Errors</b></h2><h5 class="post__date">2016-08-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Dm7GI_8L4dA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
thank you to them and thanks for
inviting me to Cambridge yeah so I will
talk about homomorphic encryption from
ring learning with arrows I'm going to
explain what all these words mean and I
stated here that this is joint work with
Christian and V naught which we did when
we all were working at MSR redmond in
the crypto group I stayed I will be
talking about joint work but probably I
won't get there in the time I have so
the main thing I want to do today is
just introduce the scheme that we
implemented which is basically a scheme
that V naught and one of his co-authors
submitted to crypto 2011 last year so
too in explain the first words
homomorphic oh sorry just me maybe a
first example for what you might have
seen already which is the RSA
cryptosystem which is widely used and
yeah it's based more or less on the
difficulty of factoring so the public
parameter here n is a product of two
primes two different primes and you have
a public key which is this number and
some public exponent e with certain
properties and the secret key is the
inverse of this module of some number
the most important thing i want to show
you here is just how encryption works
which you might have seen before at some
time so if you take a message which is a
number modulo n and you encrypt it you
then can encrypt it by just raising it
to the public exponent modulo n and
decryption is the same operation just
using the private key the secret key now
if you take two such ciphertext and you
multiply them together modulo n you get
a multiplicatively homomorphic property
you can see here you can ride it like
the product of the messages raised to
the eath power so the product of two
ciphertext gives you a ciphertext of the
product of the messages so that's
multiplicative I'm a morphism now a
second example also fairly well-known
protocols the el-gamal public key
encryption you can state that for a
general group a cyclic group g so here
the secret key is an exponent as well
and the public key is just this public
generator of the group raised to that
exponent of course you're the security
relies on that you cannot find out the
exponent X from knowing the number H or
the group element age so encryption goes
as follows you choose a random exponent
r which is a number modulo the group
order and you kind of encode that
randomness in the first part of the
ciphertext and then you encrypt a
message by multiplying with a power of
the public key so now this more or less
has the same outcome here if you
multiply component wise to such cipher
texts like this then in the first
component you can write the product here
as a G to the power of the sum of those
random numbers and then again the same
thing happens the product of the
messages appears there and this looks
exactly like a ciphertext yeah like this
one you can replace our by the sum of r1
and r2 and then if this is a cipher text
of the product of the messages now for
this also is a multiplicative
homomorphism I could imagine other
crypto systems where for example you put
the message in the exponent then a
multiplication will give you the son of
them messages in the exponent yeah so
there are crypto systems that have
multiplicative homomorphic properties
and others have additive formal morphic
properties so there are a lot of these
properties usually you want to avoid
these properties for example in RSA you
would never use the version I showed you
in the beginning that's just the school
book version having this structure is
dangerous having more structure
dangerous you want to avoid this by some
padding schemes for example nevertheless
these properties can be used as well I
mean you can do computations under the
encryption if you think of a additive
for mom or fake encryption scheme you
could use that for evaluating elections
you know where the votes are zeros and
ones you can add them up under the
encryption voters could encrypt their
votes and then you can add up and in the
end count see what the sum is then you
have counted the number of ones you can
evaluate elections with that so this
might be useful although sometimes it's
dangerous on the other hand it might be
useful but now most of these schemes
only provide additive or multiplicative
functionality and yeah if you have both
of them you could more or less do
arbitrary computations at least
polynomial computations so there was a
system that was introduced in 2005 by
bonito and museum that achieved a first
step into that direction of achieving
arbitrary computations namely that
scheme could do many editions and a
single multiplication the problem was
once you did that multiplication you
couldn't go back to that state so you
could do more multiplication so once you
did a multiplication you were done you
had two different kinds of ciphertext
and you would move from one set to the
other by applying this multiplication
procedure and now there's this notion of
fully homomorphic encryption which
allows you to do really arbitrary
computations so if you can do bit
editions and bits multiplications you
can build up any computation you like
and if a scheme satisfies this property
is called fully homomorphic
Oh
I think if you can do and and or gates X
or you can you can do it everything
right so that that's meant by I mean if
you have bit edition a bit
multiplication you can build up anything
okay so just very general scenario what
would you want to do that's not a
particular application it's just the
general picture so you would a user
would encrypt all its data before
sending it somewhere so if you think of
the server as being in the cloud you
encrypt your data whatever it is and
send it to the to the cloud and then you
could ask the server to do operations or
the server could do operations on the on
the data without ever knowing the data
you could do encrypted search for
example ask for something get back an
encrypted result yeah of your search you
could evaluate statistics compute means
and stuff like that and then you get
back encrypted results yes
hmm good question I saw your wife
i also i mean you could not encrypt it
and use it in the computations as well
or your good encrypted and you'll it
depends on if you want to hide it or not
no okay so yeah the server never seize
the day whatever applications one might
have in mind the question that rises is
that such a scheme exists i told you
there are many morphic properties but
only an additive or multiplicative and
so they and if it exists is it efficient
actually so the answer to this was this
question was giving in given in 2009
when Craig Gentry introduced the first
fully homomorphic encryption scheme and
this is based on something called ideal
lattices so the general construction is
as follows so at the core of this
encryption scheme there's a somewhat
homomorphic encryption scheme that's
something that can do a bit more than
the scheme that should have talked about
before it can do some additions and some
multiplications so it can evaluate
certain low degree polynomials and and
then from this somewhat homomorphic
encryption scheme he builds up the fully
homomorphic scheme so the general
principle is that cipher text usually
are noisy so they either the encryption
is done by adding some noise to certain
structures so cipher text is a noisy
thing and if you do those operations
addition and multiplication then the
noise grows so what basically happens
which we will see in the scheme in a few
moments is when you add something the
noise adds up if you multiply something
the noise multiplies so of course then
in the end you end up somewhere sinking
in the in the noise in the waist so you
have to pull yourself up out of the the
match here and that's done by something
called a bootstrapping step where such
cipher text can be refreshed that is you
can remove the noise and this is
yeah and in his suggestion done by
homomorphic Lee decrypting a cipher text
so you could think of this as you you
encrypt it again and you get an
encryption of the secret key and then
inside the new encryption you will
unload decrypt the old encryption remove
by that decryption process of course the
noise that's in the ciphertext so you
get a new cipher text with a new small
noise from from that new encryption so
that's basically the main idea the
problem is the decryption circuit is
usually too difficult for the scheme to
evaluate and there are some ways of yeah
making it work so you have to add some
more assumptions you have to squash the
decryption circuit Jana for example by
distributing the secret key somehow well
yeah so so far this is quite inefficient
nigel has some news probably that he
didn't want to tell me before but so
maybe there is some progress but in
general it's very inefficient also this
is kind of very old numbers in the sense
of yeah the fast moving target here
fully homomorphic encryption so last
year there was a paper by Gentry and
he'll AV where they implemented more or
less the original scheme and you can see
it takes some time yeah so for crypto
this is amazingly slow this is very slow
yeah so for example if you look here
that's just a toy setting that doesn't
guarantee any security and it already
takes six seconds to clean up a
ciphertext that encrypts one bit and the
public key is kind of large and then
this large setting it takes half an hour
to it took half an hour at that time to
clean up such a ciphertext and even I
mean if you look at the large setting I
think they have in some results that
stay that this is not even an
intermediate level of secure
t right now so there's not even 128 bits
of security probably these parameters
that are in the large setting so there's
a long way to go from there to really
using homomorphic encryption so there
are there have been a few new variants
that mostly follow the scheme there has
been some alteration lately so things
people might get rid of this
bootstrapping step I'll do it in a
different way or just use it for ya
improving properties later on and there
are some variants that are based on
these kind of new assumptions for
cryptography that the learning with
arrows problem and the ring learning
with arrows pro and also there's a point
that you might not even need fully
homomorphic encryption if you have a
specific application in mind you
probably have a specific set of
functions you want to compute or just
maybe just one function or so you
certainly have an upper bound on there
on the degree of polynomials you want a
value age so there you don't really have
to do fully homomorphic encryption would
be okay to have a somewhat to a morphic
scheme or an almost fully homomorphic
scheme somehow that can do what you want
to do now and here I just want to focus
on that one scheme by broker ski and
bike want an earthen from last year's
crypto and just want to show you how
that works okay so low
yeah you have to care nevertheless you
still at a care about the noise but it
works without the refreshing step so the
noise never gets too large yeah it does
still but not in the way that you have
to do there it of course it affects the
computations in the sense that they get
slower we'll see later so this is the
learning with arrows problem so if you
plug in Q equals 2 some people might not
know this as the learning parity with
noise problem so for it's just a
generalization so if you take Q equals 2
and this probability distribution just a
probability for getting 0 or 1 then this
is exactly the learning parity with
noise problem so this is a bit more
general you have some dimension you have
a modulus q and some probability
distribution usually something centered
at 0 and the problem is to distinguish
the following two distributions of pairs
so a pair is a vector of dimension n and
a number so here a modular cute now so
the first distribution you have is the
uniform distribution which you get by
just simply selecting uniformly at
random n plus 1 coefficients and you put
in the vector here and the number there
the second distribution is the l w e've
learning with arrows distribution which
works as follows you draw a vector
uniformly at random which is kind of
your secret yeah so this is a fixed
vector and then to produce samples you
sample uniformly at random vector a I
and also you sample a small error
according to the to this distribution
here I mean it doesn't say it's small
here but in the end it will be some kind
of small noise and then what you
put out as a sample is the pair AI comma
B I wear bi is this noisy in a product
now so you're computed in a product of a
I with ass and add this noise so the
task in this problem is to distinguish
between the uniform and the lwe
distribution so this problem has been
introduced to cryptography in 2005 and I
are a gift and this penis paper shows
some yeah reductions of certain George's
vector problems closest vector problems
to the lwe problem now so short this
vector problems on lattices are
considered hard the point here is you
have some approximate version you're not
looking for the really for the shortest
vector it suffices to have some vector
that is within some constant times the
shortest vector and the interesting
thing is that first reduction algorithm
was a quantum reduction so the algorithm
that does the reduction is a quantum
algorithm that has been yeah hi Kurt in
2009 gave a classical algorithm and they
a very essential thing that goes into
these proofs to show security hours to
show that this problem helps to solve
shortest vector problems is that you
choose these distributions as discrete
Gaussian distributions now so I put two
pictures here that's a two-dimensional
11 dimensional that's just a standard
Gaussian round it for example now and
take a modulo the modulus q
and now for the ring learning with
arrows problem it looks very similar
it's it's a slight variation and the
point in doing the ring learning with
arrows is just efficiency you get like a
factor of n for the size of elements and
there's a very efficient arithmetic to
do computations here so that's the
setting of the scheme I want to describe
so here in this special case we take and
a power of two and we have a polynomial
which is X to the n plus 1 this is the
2n cyclotomic polynomial in the end we
want to compute modulo days so we have a
ring we take integer polynomials in X
modulo this F so we replace any power X
to the N minus 1 and if you take this
setting here you have very efficient
arithmetic you can use discrete Fourier
transforms because you have the roots of
unity inside here I mean inside here you
know so you have to choose the prime Q +
1 modulo 2 n and then you can do
everything you know from complex Fourier
transforms you can do in that structure
as well ok so this ring RQ that's the
ring we are going to work with so
elements from here will replace the
vectors in the lwe problem as we've seen
before so these are just polynomials of
degree at most n minus 1 and the
coefficients are taking modulo Q so now
we can formulate the ring learning there
is problem it looks more or less the
same we just replace a few things here
so the pairs we look at are now two
elements from that ring so two
polynomials not a vector and number
anymore two polynomials here and then
the uniform distribution so we again we
have to distinguish between two
distributions and the uniform
distribution is just taking 2n
coefficients uniformly at random that
gives you two polynomials
and the the ring learning with arrows
distribution looks exactly the same we
just replace the vector by a polynomial
the same here for the uniformly at
random the chosen polynomial and then
the arrow of it yeah the error which was
a number before now is the polynomial as
well and then the second entry here bi
you get by taking the ring product so
that's that's just multiplication of
polynomials and then reducing modulo Q
the coefficients and reducing modulo X
to the n plus 1 the degree to get a
polynomial which has degree less than n
again now we'll see an example soon so
now we have noisy ring products of
random elements with this secret s so
what that really does is it gives you n
of these samples at once like we had
before in the standard learning with
arrows except that now you have more
structure than those are not n
independent samples kind of you get
these n samples by rotating one of the
vectors in some way no so here's an
example so let's fall for this torque
let's take K equals 3 so this is
extremely toy it doesn't even work and
it's definitely not secure but for the
purpose of seeing what the operations
look like that's that's great so k
equals 3 then we have X to the eighth
plus 1 and we take q the primes 97 so
how does a typical element look like
looks like this yeah so it has degree at
most 7 and it has coefficients modular
97 which I wrote in a symmetric
representation between minus few half
and 2q a plus q have and then we'll take
as the arrow distribution some some
discrete Gaussian which we also sample
coefficient wise so these arrow
polynomials are somewhat small they have
small coefficients around 0 now some of
them are 0
here they are at most two so this is a
small element yes yeah so if you have
something which has a degree so in that
in that case this division can be
simplified by just replacing X to the
8th x minus 1 yes well yeah yeah of
course but if you have a more general
polynomial you can also replace X to the
8th x minus the rest of the point on so
now you can add these polynomials of
course as you know how to add
polynomials you just add them
coefficient wines yeah so if we take a
plus e here so we get the 27 there's no
X to the seven here and then the minus
11-2 gets you the minus 13 so you add
fish advice the polynomials so if you do
twice a a plus a you get 54 which is the
same modulo 97 as minus 43 so I always
write it in symmetric representation and
so on you can check that this is the son
of a with itself and if you do
multiplication now here I only do as an
example multiplication with X so if you
take that a multiply it with X you get
this every monomial raises its power by
1 and then you replace the X to the
eighth by minus 1 so the 27 goes here
minus 27 so this is the result of
multiplying by X so that's a yeah that's
a shift and where you put a minus at the
things that go out on the left and come
back and write
exactly yeah oh so the other way would
be to represent numbers modulo Q between
0 and Q minus 1 but it's important to do
it in that symmetric way here yeah we'll
see on there in one of the next slides
okay so that's how we compute yeah so if
you have a more complicated polynomial
here that goes the same you can split it
off into the multiplications by these
monomials shift them around and so on
okay so it when people started using
this this problem was believed to be as
hard as the general lwe problem of
course that there must be some problem
here because there's a lot of a lot more
structure as I said you don't just get
an independent lwe samples you get some
that depend on each other so there is
some structure there has been a paper
recently that claims some Lina and speed
up so we have to be careful here it is
more efficient but on the other hand
it's probably less it's less secure than
using the standard learning with arrows
problem
but I mean it is more efficient so for
now let's look at this okay and we have
smaller keys here so now let's look at
the scheme oh no not yet yeah maybe I'll
go a bit quicker here these are just two
points to say we can replace remember
that secret s we can replace that by a
small element as well you don't need to
have it uniformly random because this
computation shows that you can basically
if you have a general sample with an
invertible a zero you can transform any
other coming sample into one that looks
like a sample where it has a small error
at this place where the s was before so
that means there's no point you don't
have to take all the randomness into
that s it's it's okay to have a small
element here and also you can what's
also okay is to have small multiples of
errors before you add at this noise yeah
so you could think of taking only even
coefficients here okay so talking about
even coefficients modulo Q is a bit
strange and that's the reason we need to
have that symmetric representation I'll
come to that in a minute so now how does
the scheme look like so the point is the
problem if you cannot solve the problem
then to you these samples from the
learning with arrows distribution look
basically the same as random so they are
indistinguishable from random you can
use these to hide something so what you
do here is for the key generation so you
have this small secret and you basically
sample one of these lwe samples which is
your public yeah put a minus here that's
just for technical reasons so you have
this uniform random element and then
this thing looks exactly like the second
part of the learning with arrows samples
so the public is just one of these
which means it's just a set is it yeah
it's a sequence of two polynomials now
so in our setting this could look like
this we sample these two small elements
as an e we sample a uniform random
element a1 and then we compute this a 1
times s with a polynomial multiplication
modulo Q modulo X to the eighth plus 1
and this gives us an element a 0 here so
the public key now looks like this it's
two elements from that ring
so now if you want to encrypt something
we need to yeah put a message somewhere
now we need to encode a message in terms
of of these ring elements and that's how
we do it for example so you could so the
message space will be something like
that construction with Q we had so the
ring we are working in but now we take
that modular tea instead of modular Q so
for example if we take T equals 2 we
would choose messages which are
polynomials of degree at most 7 in our
case and which have just zeros or ones
as coefficients and then we can encode n
bits at once so for example this message
goes into this porno and the homomorphic
operations we will see you later on our
homomorphic with respect to the
operations in this so that's a bit weird
for mathematicians we just view this as
a sub set of the ring RQ or as a sub
ring and then the homomorphic operations
are the multiplication and addition
inside of this oh yes you can just put
the bit in the light last coefficient
for example
computation of doing bitwise or it was
added on pairs of encrypted bits then
anyone who's observing that stream of
data even those encrypted can easily
further this what can easily not do the
decryption from observing the
computation even though it's all
encrypted
it's like the sort of like the old
riddle of reduced to people want to be
more than one can always tell the truth
I've got if I can observe if AB it's
always encrypted to keep the same value
isn't using the safety I can and I know
all the computations being formed is
whether it's all or am I can build up
the truth table and work out what the
original bits must have been
right even though the same result
randomized okay yes that's a different
from the support me to be sort of
getting the
cambridge
yeah that's retardance deterministic
items that took a bit compares it do
comparison of two numbers right but you
have to be composed bitwise and two
bitwise operations but it's yeah
yes
yeah so that's been talking what our
Oh
Thanks okay and then the encryption and
here you can see it's randomized because
for each encryption you will sample new
elements from the arrow distribution so
take the public key and the message in
the form of a polynomial and then you
yeah produce more of these lwe sample
like elements now you take the a 0
multiplied with with a new secret
element here you and then add some
multiple of an error and here you hide
the message you hide the message in
there by adding it adding this
polynomial to to this lwe sample element
and you transport the the randomness in
that second element now so example again
so these are three new small elements so
for each message you get to you will
generate three of those you take the
public key we had if you take the
elements we had before you will end up
with this polynomial here and this looks
like a random polynomial and the second
one see one is here so your cipher text
is of that size so if you want to put a
single bit for example which some
applications might need you to do have
just a single bit in a ciphertext you
will blow up one bit to something that
looks like this and the numbers we are
talking here for real applications are
much much larger so that gets huge so
now how do you decrypt you'll get a
cipher texts which has two such
polynomials and you have the secret key
s which is also such a polynomial what
you do to decrypt is you compute this
polynomial here now you multiply see one
with s you add it to c 0 and then you do
a modulo t of
and here it is essential that you had it
in symmetric representation modulo Q if
you don't do that you will end up with
the wrong message here doing
computations modulo 2 for example yeah
what happens if you add two numbers
modulo Q and they so if you take two
numbers at them and they are larger than
Q what you do is you reduce it by
subtracting q1's so if the sum was even
before it gets odd afterwards so you
flip bits by these reductions so you
have to be careful with that if you put
it to the minus so if you put it in the
symmetric representation it keeps its
parity so that's very important here so
why does this work look at this I mean
we plug in the formulas for their
polynomial c0 c1 and then you see the
minus a 1 s times u cancels out here
with this one and what remains is the
message plus T times some combination of
small polynomials now so the point now
is if you if this is small enough and
you don't get these reductions modulo Q
then taking something model modulo t
will give you back there the message
here so taking modulo tea and assuming
that this error is small and nothing
weird happened by reducing modulo Q you
can get back the message by reducing
modulo t
no so in the example okay yeah take the
ciphertext and do these computations and
then you can see here that networks i'm
a bit cheating here not all of thee so
if you really do random elements with
these parameters it doesn't work all the
time yeah so I chose something that
works because the arrow is the
parameters are not chosen correctly the
Arrowwood would have to choose the arrow
so small that all of the coefficients
would be 0 here to get the correct
result all the time so you have to make
Q much much larger ok so we haven't seen
any homomorphic operations yet so we
want to add messages inside the
encryption and that's just simply done
by adding the polynomials in the
ciphertext so we have to cipher texts
encrypting messages m and M Prime and if
you add them coefficient wise what
happens is that these small elements add
up here and the errors add up here the
messages add up so this looks exactly
like a ciphertext that encrypts the sum
of the messages no multiplication is a
bit more complicated so you remember if
you compute c0 plus c1 times as you get
this message plus T times the small
things now we want to preserve this so
we want to have a polynomial which where
we plug in s we get back message + T
times small error terms and this is done
in this way if you just multiply these
polynomials if you plug in s here for X
you get back M plus T times something it
sits down here and here you get M prime
time plus T times something and if you
multiply that out you get M times M
prime plus T times a bunch of things
we're the largest error term is the
product of those now so messages are
also very small elements so these M
times
these things are not as large as the
product of the two error terms here and
here you can see what happens so a bit
the operations are directly reflected in
the arrow operations and so I arrows add
up here arrows multiplying down here
otherwise these operations are kind of
simple huh it's just addition here a few
multiplications okay but you might have
noticed that now the new cipher text
here has three elements it isn't of the
same form as before so we get a we have
to generalize the notion of ciphertext
we have to take longer ciphertext as
well so now we have three elements now
just summarizing what I already said and
you can if we generalize that our cipher
text to longer sequences of polynomials
then encryption works as before you have
this polynomial given by these and you
plug in s here and you get back
something M tilde multi so when we do
operations the ciphertext increase then
of course it gets more complicated to do
more operations because now adding
involves more coefficients and
multiplication involves more
coefficients so it might be good to
reduce this back to smaller ciphertext
again and that's a way of doing it doing
this that's similar to this
bootstrapping things somehow what you do
is you encrypt you somehow encrypts
parts of your power of your secret p you
encrypt this s squared here with with
the power of tea in front that's not
really an encryption because it's not in
that RT it's not a proper message here
but it looks like an encryption of
powers of T times s squared and what you
can do now is you build up your you
build up this c2 times s squared this
thing you want to get rid of this you
want to move that inside here to get to
element
in the cipher text again so you can
build up this element homomorphic lee by
using these public homomorphism keys
that's a computation we're kind of
running out of time so it works you can
what you do is you homomorphic lee
subtract that c 2 s squared thing from
the from the ciphertext and you get back
to a new cipher text that only has two
polynomials but you pay of course by a
higher arrow that's contained in these
things you know so the arrows here some
up again so that makes it worse if you
want to do that operation you have to
cut down on other operations because
that increases the arrow as well okay so
just to to wrap up if you want to do
that in practice if you want to yeah get
someone to use the scheme you have to
make an convincing argument that this is
secure which is I think not possible for
these kind of things right now but ok
how do you do that you have to assess
the security of the scheme against
attacks against your schema so you look
at certain you look at the best known
attacks you have and you try to estimate
the running time of an algorithm that
carries out the attack so if you so we
have certain restrictions on our
parameters now as you might have guessed
by now that the queue must be large
enough compared in comparison to t so
the error terms don't overflow don't get
reduced modulo Q now also if you do more
additions and more multiplications
you'll have to allow for more arrows so
Q has to have a certain size depending
on the number of operations you want to
do this is for the scheme to work
correctly otherwise you don't get back
the results of x decrypting and then for
security reasons you have to look at
these attacks so we just picked one
aluratek and yeah estimated the
parameters based on this paper by a
linear and pie cart which does include a
certain number of assumptions which
might not even be fully true so there's
still a lot of work that needs to be
done to really assess security here but
for the state of the affairs right now
what comes out of this is the following
size of parameters so if you look at
this column here that gives you the run
time of the algorithm so that's security
in bits so on algorithm against these
parameters here for example would take
two to the 134 steps so right now in
crypto people usually go for at least
128 bits of security so that's what we
roughly aimed at getting something in
that area this is the number so that's
the degree of the polynomials you want
to evaluate so d minus 1 is the number
of multiplications we want to do so here
if you have one then you're doing no
multiplications at all for two you have
you are allowed to do one multiplication
then you have a certain number of
additions which are not in the table
here and this is the degree of the
polynomials now it must be a power of 2
so this is pretty large here huge
polynomials then this is the bit size of
the prime Q so it's not 97 but if you
want to do two multiplications you will
have to work with 64-bit prime so every
coefficient in your polynomial has 64
bits so this is the size in thousand
bits of elements from the ring r cube
and this is the size of the homomorphism
key that you use you would have to use
to do this degree reduction step for the
ciphertext to get back to two elements
so just a few words on message encoding
imagine you want to do integer
operations you want to compute the mean
of integers or something you want to add
into integers how do you map them into
the polynomials now you can put bits
into the coefficients and then what you
want to achieve is if you add if you do
these homomorphic addition operations of
course you want to have the addition the
sum of the integers in the end so you
would have to carry take carries in the
it's not the same as addition modulo 2
so this is kind of some these are kind
of some ugly tricks to to get that to
work so you don't take T equals to you
take a larger t you put in your integers
as bits and then you can add so you
always add ones and zeros but you don't
do reduction so you keep building them
up and in the end you can plug in 2 into
that polynomial you haven't get and get
back the integer but you have to make
sure that you don't get reductions
modulo T because that's what happens
when you do the homo morphic operations
so you choose t large which makes your
parameters larger and the same works for
a multiplication integer multiplication
is not the same as putting bits into
your polynomials and then using
polynomial multiplication it's only the
same if you don't do weed actions modulo
X to the eighth plus one in our example
so you have to take smaller degree
polynomials for encoding your message so
yeah so more or less the statement in
our paper was we have this reference
implementation that does a few things
and it's not really optimized it's just
a computer algebra system we used for
the polynomial arithmetic there's a lot
of potential to improve that by using
the Fourier transform tricks I refer to
India in the beginning so discrete
Fourier transform we are not using that
just taking the built-in polynomial
arithmetic which is not that bad
actually
and the main costs as you might have
seen is just polynomial multiplication
you know that's the most expensive with
you so the result is you can see here so
if you take for example you want to do
two multiplications you take this set of
parameters that's sampling from the
arrow distribution in milliseconds
that's an encryption with
pre-computation you can see that doesn't
include any samplings here so you can
pre sample all these small elements and
then use them once you do the actual
encryption so we have like twenty nine
milliseconds for an encryption of course
decryption depends on the degree if you
have a degree to you have to do more
computation so that's more expensive
here and a multiplication operation
takes fifty six milliseconds and now the
last column you can see that's the price
for degree reduction of ciphertext if
you go back from three elements to two
and this in seconds not a millisecond
Sam so you want to avoid that actually
so you can live with increasing
ciphertext up to a certain size maybe
it's a trade-off what do you want to
achieve I mean these numbers
milliseconds already look much better in
terms of cryptography than seconds
minutes yeah and here's a few examples
if you want to compute them the mean of
100 numbers of size 128 using the first
set of parameters because we don't want
to do multiplications here that takes
less than 20 milliseconds and some and
some of queers squares to compute mean
and variance something like that that
requires you already have 100 ciphertext
sitting there and then you compute these
operations okay thank you that's</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>