<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Ziria: Wireless Programming for Hardware Dummies - Part 4 | Coder Coacher - Coaching Coders</title><meta content="Ziria: Wireless Programming for Hardware Dummies - Part 4 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Ziria: Wireless Programming for Hardware Dummies - Part 4</b></h2><h5 class="post__date">2016-07-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fdDyoL8ea50" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so um I have a little bit longer so
we are back to designing OFDM so how do
we do Wi-Fi design and so so far okay i
think the what we heard is basically
that what Wi-Fi is doing is taking your
you're signaling time and converts it in
frequency so as if you know your symbols
in frequency would be so if you watch if
you see this signal you're sending in
the spectrum analyzer you will see in
different frequencies the symbols you're
sending so for example if you decide to
put zeros here right the spectrum
analyzer you will not see any peak in
this area that's why when I sit when in
this in this particular example in a
code when I was actually running this
example where I send only one everything
is zero except for this one I just saw
this sign right so that's the idea of
aya 50 I mean I guess you most of you
are probably aware but the reason why we
do I 50 there is we want to make it to
shape it in frequency right
okay now better yeah sorry so that's
what you do and now I'll try to explain
why we do that right so basically so the
thing this is just a high level thing
you have to do with any of them symbol
beat with any of them communication
being Wi-Fi or LTE or they all have
these things they have pilots and they
have cyclic prefix right so now I'll try
to explain why they have these right ok
so i guess most of you know what the
channel impulse response is i'll just
run simple example saying basically i'm
just going to create one simple impulse
ok so here is a simple code basically
what i do i send 31 zeros to x 1 31
zeros ok and then I just plot that as
simple as that almost not see if it runs
so oh I haven't you want me
too many pictures this is my symbol okay
used to yesterday it used to plot all on
the same one okay so
so this is kind of obvious but basically
what what I just created a symbol right
so I just do like 30 10 it's 21 and 30
10 right so that was the basic thing
nothing special here now what I'm going
to add into it I'm going to do the same
code is here right I'm just going to add
the channel so channel is something I
kind of artificially created which is
kind of similar to what you would see in
nature no not fully but so let me show
you what the channel is so the channel
is basically doing the following so it's
taking so I'm creating some some
arbitrary channel here but basically
what channel has it stopped so what
happens in that you know in nature is
you send this signal right and basically
fine we'll go all the way in there in
the corner there will be a direct line
of sight there and there'll be
reflections of different places right so
you'll see a copy of a signal attenuated
and shifted in frequency in sorry in
shift in your face coming there right
because of it transfers different
strands with different parts so again
this is there's lots of nice theory
behind it but so what happens here is
I'm just taking my signal and I'm taking
delayed copies of my signal and i'm
multiplying in time so basically one
copy will reach you directly the other
copy will be delayed by one symbol and
cummed it later with some kind of random
phase or amplitude change there'll be
another copy coming later another copy
coming later so this is just a mock-up
code for this signal so basically what I
do have this kind of sliding window okay
so what I do it 0 I always keep the last
received bit okay and then the other
bits I just shift around it just copy 11
out of 12 bits always kind of shift out
like a sliding shift register and then I
multiply these with tops so basically
saying the previous copy that i sent
before is coming and hurt me now with
multiply with different up so that's
basically a very simple model of
multipath Channel and so this is another
kind of bit to illustrate the coding so
we have this vector library
which is just the fast way of doing
multiplication right so I have vector Y
which is the output so y equals this x
depth and this is just the shift so we
normalize for precision so you can
ignore that so basically I have all
these delayed copy of my signal
including the fresh copy which I
multiply with my with my top vector
which again defines me what is the
effect of each part in typically it's
going to be decaying and in this case I
kind of get some weird so it doesn't
matter and basically I some i multiply
these two vectors and I sum them all up
that's my multi pan channel and that
really what multiple channel is so the
only and difference is that what are
these numbers in the channel here I just
create some random things in the channel
okay so when I when I now when I now go
here and so now what I'm doing so this
was the thing we just ran before right
this is the thing when I just send when
I just send a symbol here right so let's
see what this thing is going to what's
going to happen when i run this drew a
multipath channel right so now this code
is exactly the same except that i have
here test channel right so this is
running my channel on the problem so
let's see
why is creating new ones every time
this one
no this is still deal
just try to restart
okay sorry for this I'm hoping this is
going to work better now i can assure us
that night in my room it worked
perfectly so it's always right so is my
second try my new line i just need the f
compiling the wrong one
I suppose this is the one yeah it should
be the one
right so basically what happens is so
this is a funny multipath channel but
you see that that what what I send is a
symbol you kind of get some air how it
gets repeated a little bit and so
typically it should be decaying in my
case I guess I just pick the funny one
but it should be kind of going down and
so what happens it depends really what
is the distance of your communication
how many of you if you go very nearby
for example if I just talked to run the
thing that reflects of the wall and
coming back is probably going to be much
more attenuated compared to what I
actually sent him but if I go very far
away some of these parts are going to be
comparable right there is this two-way
reflection model meaning that if I talk
to someone all the way maybe hundreds
meter back the part that reflects over
the floor and the part that goes direct
line of sight are going to beat of the
similar power so it's ready to predict
this thing happens and you'll have some
kind of talent puffs response which is
unknown unpredictable and we have to
deal with it so that's the kind of the
effect it has on it so basically now
what it does to my what it does to my
symbol so next thing I'm just going to
uh huh
yes yes it won't even react so we did it
previously validated with dumb f50 right
so we did the inverse and we collect
with this from the f50 you didn't do it
yeah it wouldn't work because as precise
as you said you won't have enough time
to wrap up the all the amplifiers and
analog parts yes yes yes yes yes yeah so
this will just illustrate there but I
agree so basically I guess the better
way to do that is you can just send an
arbitrary known sign well I love dem
symbol and in equalizing frequency that
would be better way right yeah yeah
depends on your bed width I guess yeah
so alright so the effect on the waveform
so basically what am I doing here now so
now I'm back so this was a fun example
where I'm sending my let me run it while
while explaining because it does take
some time now so basically what I'm
sending here is I'm just sending i'm
doing the qpsk symbol so basically i
take i'm doing my mock transmitter so i
take some bits i forget about scrambling
into leaving because that's not
essential to its essential for the
receiver but not for the demonstrating
the waveforms I'm just creating some
qpsk symbol out of it and I'm sending
these to I 50 and I'm plotting the
output right so this is the same i-15
we've seen before and then hopefully the
output should now be there right so this
is my F of T and this f50 is kind of
having 64 bits output so again what I do
I have 64 inputs right this is my om
symbol and then I do a 50 of it so my 60
my
ifft of 64 inputs going to be in 64
things I'm sending out it's going to be
this funny face waveform which you can
really interpret in time because it's
just some of these signs and then it's
going to be zero afterwards now when I
when I now add this is without Channel
right so now if i add channel this is
basically what i did again this is the
same code right i just added this
channel so channel is simulating this
multi-part thing we were doing before
right and so now we see that before it
used to stop here and now it's going
even further right and so this is just
the effect and I think I have distant
slides right so this is just the effect
this was the first case right and this
is the second case so essentially I mean
kind of obvious we had this pulse which
was kind of repeating time now this
whole thing is being repeated in time
but keep in mind so we have this one and
then we have a delayed copy of this one
shifted by one superpose with that one
so now not only this end is kind of
interfere with everything is interfered
with right so you see that doesn't
really look the same this is completely
kind of different right so the worry is
okay how do we deal with this right now
all right so we kind of screwed up
everything ok are we are able now to
recover this waveform now because it
doesn't look at all the same ok well
that's the beauty of a DM that we are
able to do this very simply and we'll
see on the next slides because of this
thing that we're doing in frequency and
so I guess so let me just give you a
brief idea again i said i thought i'm
not going to all the details of the of
the of the duration of this but the idea
why we can deal with this multi-part in
frequencies that if i have a sign right
so think of a sign lasting forever right
take this sign I shift it in time by
something and I shift it is in phase
right I sum it up with the other side
they both have the same frequency The
Sun will have the same frequency right
so what happens
is I'm changing the amplitude and the
frequency of this index are another
frequency and amplitude and the phase of
design but I'm not changing the
frequency of a sign right so that's the
key observation for ofdm so that's why
we do ifft to encode our symbols inside
so when we look at the symbols after the
FFT at the receiver all this mess up
happened but I know the effect of this
mess up is going to come only from my
own sign right because of the math of
this saying that these signs are
eigenfunctions in this space whatever so
basically if you do this linear
transformation and this channel impulse
response is a linear transformation just
doing the late shift and some right then
what happens is I'm going to interfere
only with myself on the same sign all
other signs are will stay completely
orthogonal tree and there is a very nice
might behind it but again I'm not going
to do that there's intuition why we want
to do a 50 ifft before so make sure
every symbol isn't good in a sign and
when different signs interferes I mean
that when the multi-part happens my
symbol interference only with itself
right not with other symbols so if you
look in time obviously that's not the
case that's y cdma has to do all the
equalization to look at the has to have
low cross correlation in cells collation
all this stuff here it comes for free
right but there are certain things you
need to do and that's what i want to
show you like why do we add cyclic
prefix and all these things so basically
again in time it looks completely
different so now what are the effects of
our dim symbol in frequency uh let's
look what are we going to do next so now
what happens in frequency so what I'm
going to do now I'm going to now look at
a bit of a receiver right so this is
again a very simple receiver where I
don't worry about any time
synchronization frequency everything is
great so it's the same as before i'm
sending taking some random bits I'm
modulating the let me run it while we
discuss turns out to work fine so I'm
sending some random bits right I'm
modulating the random bits getting qpsk
then I'm doing ifft okay now I don't
have any channel so I do just say 50 and
then I plot that so basically
what I should get is this one cancel
this one I just get modulated qpsk okay
so let's see yeah that's it right so
these are the symbols I'm sending their
qpsk symbols and here I'm just plotting
the real part so maybe there'll be some
change in the complex part but this is
enough for the very thing so essentially
if there is no channel my receiver which
consists of I are 50 and f50 will cancel
each other and I get my symbols back
which is what i want so the question is
why do we do all that I don't we just
send symbols right so now what happens
if I what happens if i if i add channel
so once again right so this thing here
what I'm doing I'm not doing anything
special I'm just saying okay I'm reading
bits the same thing the same thing here
modulating ifft and I have the channel
again right seems I'm missing the f50
here
so the same time thing your head up
there maybe I just deleted it ok we can
add this easily
okay so you can believe me it's easy to
modify the code here again I'll invite
you to do this in Sora in five seconds
ah ok so it should be right so basically
everything is messed up so I'm doing
right now right i'm doing the the thing
so basically what i do i put the channel
in between right so the fact that i did
so the fact that i did my they put this
thing inside so my modulated symbols
even though i even though I kind of did
the FFT right they didn't do what I just
explained it should do right and so what
is the reason the reason is the
following what happens is because if you
look at each of these signs that we saw
initially right so the sign get some
with various copies of itself right so
even though I don't interfere with other
symbols i interfere with myself right so
my face gets moved and so on the gate
gets moved in a very predictable way I
gets moved so we can't just do this
right to test channel and test I 50 what
we need to do is channel estimation so
what channel estimations does it says
what kind of summing of these things
will happen right so I'm going to have a
delayed sign with different phase and so
on so there's there'll be a transform of
this my face and so on of the initial
symbol so what I have to do I have to
figure out what it is and then remove it
from the rest of my data points right so
there so that that party clothes
equalization and it's essentially
removing the effects of multipath
Channel right so so that that's the next
next demo so basically what i do now is
let me run it again i will discuss so
now it's the same kind of code except
that i do this invert channel right so
okay so what this simpler channel is
doing this is the channel estimation so
now what I'm saying is like let's see
knowing what I send so that's why we
send this pilot for probing okay so what
I say now is general is doing something
for my symbols
so it's quite easy I'll send a known
symbol right the channel will do
something to my complex symbols I remove
the channel by dividing by this complex
number so i sent a complex number which
is qpsk maybe 1 plus i1 or whatever
minus 1 minus i1 i send this it gets
multiplied by some unknown channel
effect and when i receive it I / the
what I send because I know it's my pilot
and I get the channel channel thing
right so so this is what I do and ok so
now this is all 257 ok that the scale is
weird so why is it all 257 with a little
bit of thing here so it's basically
because it's just the precision issue
it's constant so why is it constant I
didn't put any channel right it was just
a straight thing so I inverted the
non-existing channel so there is no
transformation on my my thing so if I
now add the channel right so now again
ok let's run it so now again I have this
I 50 the same thing is before I just add
that channel so what I do I say test
there are 50 texts channel f50 and then
invert channel so this is just taking
the next symbol and inverting with an on
one so I get something funny right and
these are not now large numbers 500
right it goes minus 1 plus n so this is
over 64 subcarriers so each subcarrier
has a different effect and this is just
this should be complex numbers and was
just plotting the real ones right so
each subcarrier the phase that I was
sending you know this nice qpsk symbol
and initially gets multiplied by this
unknown effect of a channel and then we
get this weird things right and unless
we know what this thing is we can't
really recover it right so let me just
quickly show you what this channel
preamble let me just quickly show you
what this channel estimation does just
invert channel this is the code we used
invert channel just to give you an idea
i mean the promise is to explain you how
to build a full Wi-Fi receiver so you
should understand most of the things and
it's actually in soda so what this thing
is doing its really dividing it's really
dividing me known so i sent a symbol one
qpsk symbol in each subcarrier so i have
1064 qpsk symbols i received them they
have this weird transformation I know
what I send because it's mine on
preamble and i divide what I received
with them with with what i sent right
and so that's going to be my output of
this now the trick here is that if you
do this in MATLAB you can do it like
that right you can do a complex division
floating point but that's really slow so
you need to do an inversion in a fixed
point right and that's something you
know that this this language I mean you
have to do other tricks to actually map
there and that's the different difficult
problem but it's a little bit of
designing issue to to do this kind of
inversion in floating point so you don't
really want to do a full division and
you want to make make sure when you
divide you're not doing you don't lose
the precision there's a little bit of
code actually all the operations are
quite simple so conjugate multiply so
you take this guy you multiply with
itself conjugate and to get the and to
get the norm of this guy so it's just a
multiplication with the conjugate you
get and this thing is 32-bit so there is
a little bit of issue with precision
that something we cannot take away right
any kind of fixed point implantation you
have to worry about that that's the comp
this compiler will not take it away and
there you know so then the next and but
this is a token out their language is
the credulity so you know we can hope to
integrate something else which will go
through all these calculations and we'll
figure out what are the actual
Precision's and and remove the precision
issue however you know if you want to do
division and complex things it's quite
difficult to do it to do arbitrary
expression in to move from floating
point to fix my name into quite a
difficult
to automatize this so this is something
you as potential designers will have to
think about right so that's just the the
key point but essentially it's not too
much basically go and you calculate
again the conjugate multiplication you
have to normalize with the with the with
the way the things so you don't lose
your precision so it's a little bit of
manipulation over the vector right and
the only thing you need to worry about
this basically for each one if the norm
is too high whether how you normalize
and so on so this is all about this
normalization code for each of the
subcarriers right you need to do that
and here we do that on using vector
instructions so because it's running
automatically assigned d so it's really
fast right so going back to this guy
okay so now we plotted the channel and
now we want to equalize the channel
right so now I say okay I ok so now I
said ok I did my channel equalization so
now I'm able to learn what channel does
to my signal so the idea is the
following I take the preamble ok as we
said I look at what preamble does to my
signal I learned the channel vector and
then if i divide every subsequent om
symbol by this channel vector i get my
symbols impact right so as simple as
that so that's what Wi-Fi is doing about
every single receiver is doing that you
do some gel estimation you know ATM
right and that's called equalization
right and equalization you have to do
basically removing the channel effects
you have to do in every physical air and
it really depends what is the complexity
of this thing so here it's nice because
it's just a set of complex
multiplications right in other receivers
it could be much more difficult so let's
see what this guy is doing now right so
we just say ok so we're doing the same
thing this is our mock sorry this is our
mock transmitter we send we modulate we
do I FFT ok this is there is no channel
here again I just want to test it test
FFT I get the channel inverter I get the
channel right so what it means i have to
send multiple symbols the first one is
my is my preamble so this guy is going
to be executed in
that guy so first I'm taking the first
64 symbols and doing channel inversion
and then with the rest of it I use this
channel to equalize and get the nice
symbols out okay so it's kind of simple
now first you do that on the first
symbol and then afterwards you keep on
for all the symbols doing the next bit
just equalize equalize ich weiß right
and I get nice simple back again but why
do I get my symbol because I have any
channel I was cheating right I just
wanted to say that since my channel was
flat ok I did my version so at least the
I didn't do any stupid mistake in how I
take my bits but there's nothing special
here there is no channel in between this
is the code that look like ok so now I'm
saying ok let's then put the channel in
like we did before ok so now it's really
the same I still do that this is the
part that's a transmitter I do the
modulator I have 50 then I put a test
channel and I do the inversion ok so we
are hoping it's all working fine now but
not really still get the big mess right
ok so why do we get a big mess so ok
this was the thing we we saw before if I
just do the if I do the if I don't
equalize I'll get a big mess as well now
this was the estimated channel but now
the problem is that if I have a channel
and do this equalization I still get a
big mess so why do I get a big mess so
here is what really happens I'm sending
one symbol ok I'm sending the next
symbol now this symbol is doing this
delay delayed multipath right so this is
my multi-party fact that as we saw
before right it spreads out right if you
remember the figure right so this is the
original symbol but it spreads out this
is the bit that hangs out because of the
multi part because of the delay so
that's the bit in blue there right so
that's their right so it actually
interferes with my own symbol right so
I'm still getting this bits out and you
know they're messing up my nice so in
fact I'm addressing my own multi-part
inside but I'm having a problem from
multi-part from the previous single okay
so what I want to do is I want to add
cyclic prefix right so to add a little
bit of gap between so to make sure sorry
I want to add the gap not yets
activities I have to explain that yet
but i want to add the gap which is kind
of proportional to the size of multipop
right so to make sure that this guy
doesn't affect mine receiver ok but then
keep in mind that I still have the
interference from myself right but that
is nicely taken care of by ofdm and FFT
right because I have these things again
right so now I'm hoping if I do this I'm
done right so now I'm gonna do this
right and i'm going to add cyclic prefix
and okay so what I did here I basically
run this guy so everything else is the
same I'm just running this guy and I'm
also changing the receiver because I
need to be aware i have to skip this gap
so there's nothing much there and i can
show you the code for I 50 with zero
cyclic prefix right there it is right so
basically I'm taking your your I'm
taking some input and my output is 80
right so I'm leaving the gap at the
beginning as we wanted I just copy the
data that I that I created their 15 into
the ok it's the first but then then you
know that the gap will be at the end of
the previous single right so I'm
inserting gap especially I'm leaving the
last bits empty so I don't overlap with
multi-part ok so we're hoping it's going
to work but it's not okay and okay I
guess that many of you that might know
why it's not working yet anyone what did
I still what am I still missing
right right right so that's what it's
called cyclic prefix it's not enough to
put zero you actually need to put a copy
of the block on the other side so so
basically what i need to do is I need to
take this part and put it there so it
sounds quite random but essentially what
i'm doing is i'm making the signal
periodic right so my own signal is
periodic the problem is right if you
think of the multi-part so this guy's
multi-plug is getting is kind of fading
out right the problem is my signal
starts here right my signal starts here
and it starts abruptly right if I put my
FFT around here I'm not seeing this
abrupt start I'm seeing exactly the
thing i want to see except there is
multiplied which delays the abrupt start
of this guy and I actually see it as a
delayed copy in my own signal right so
that string me up right so I can't
really I mean that's what messes up the
whole thing and I still don't get mine
Ashley equalizing right I still get a
bigger mess because I haven't really
taken care of self interference for
myself at the beginning okay so what I
do I take this bit here and I put it
there now if you remember what we
created they're all signed forms right
so basically so fft is a big sum of
science right i have these two signs I
sum them up add more science more signs
so really if I copy that here it is
equivalent as having these signs just
extend it right so if i take this copy
here you wouldn't even notice right it's
just a sign i take this hoping here it
wouldn't even notice just a sign right
but if i do an f 50 here right then you
know I'm seeing it would this thing
won't affect me but what is nice here is
that the multipath if I take this guy
here then all the multiples I'm seeing
are still a sign right so they all
adhere to the same a 50 rules they are
done all to themselves now if I don't
have a sign here this function is not
really a sign it's a it's a kind of
Heaviside function with the step
function we decide right so if i do an
fft of it it's not anymore adhering to
the rules that i have had an eye
so again function out there so
essentially what we need to kind of them
what we need to add here is really the
the cyclic prefix and nonzero cyclic
prefix I mean not just a gap but with
cyclic prefix right so while I'm doing
it so okay so what's the difference here
the main difference from before it's
just I don't have the zero CP but I have
CP right and here I I don't care here I
basically just at the receiver I remove
the sacral previous completely I don't
care about the symbols they were cyclic
prefix I care about their delayed copies
that come in bother me right so I drop
them out I do the same thing so again if
you look at the transmitter so the
transmitter part is that I have 50 with
tackling prefix so so I 50 with cyclic
prefix this is the one here so it's
really the same I'm just doing me now
this is FFT sorry I mean I f50 so these
are 50 to attack the previous let's pick
like this so basically I do the same
thing here right so this was the one
without sacrifice I was writing into the
first 64 parts and I left because the
output vector is 80 the other 80 were
just zeroed out here right so I create
an empty vector of 80 and I do the F of
T only writing in first and they left
the rest go empty now here I'm actually
writing the air 50 ok in the last part
they just I should have done it the same
way anyway but it won't make a
difference so I'm writing their 50 in
the last part my usual useful FFT I'm
just taking the last 16 bits and copying
in the sorry they're not pitch this
complex numbers I taking the last 16
common example and copying them in the
first 16 comment that's it right and
then I'm sending that so now
where is mine i signal let's see what
happened
probably have a new form now as well
this one
ok I think this is it so
right so that's my signal back right
nice as I sent it so these okay you see
that it's a little bit ragged here
because we did the inversion of the
channel there's some precision issues
but it's pretty clean right a little bit
probably by around one percent of our so
you can have a very good clearance now
of course the precision of inverting it
depends on the way you the precision of
your see Brady conversion and so on but
this is quite a good one 16-bit right
it's more than you'll ever seen in most
of the commercial things right so it's
really simple right if you look at it
this is our entire Wi-Fi receiver right
ok they're synchronization issues I'll
talk about it in a moment but basically
we're we're having like okay modulate do
the channel inside and the receiver what
you do you first do a 50 right with
cyclic prefix so you need to put a
psycho divx and transmitter and the
receiver you need to just get rid of
cyclic prefix you just needed to make
sure that what you get from the
multi-part inside is removed and then
you do inversion to get the channel
vector so the first symbol or whatever
you start has to be your channel
estimation and then you equalize every
next symbol you equalize and you pass it
on and that's it you now pass it in the
decoder the modulator all that you're
done pretty much that's why p.m. right
so Wi-Fi LTE wimax is all that right and
you know it's no more okay there's some
code in there but it's not much to
showed you every piece of the code right
the only complexity I mean vector
multiplication is the library right it's
like an SMD it's not rocket science the
only thing hidden was a 50 right an f15
is really the Soraa efficient
implantation that's you know it's really
standard their fifties yeah so that's
that's about it really and so there is
one more thing in so I have to go back
there is one more thing to mention here
is that so this would so you have to do
this right and so this we think with
missing and with the correct cyclic
prefix okay so scrambler so the
interesting thing about scrambler so YW
scramblers view scramblers to get to
avoid large peak to average power issues
so essentially here is the problem let
me
ok so here
hear what I'm doing I'm taking input
modulating the same thing as before I'm
doing ifft right so but this input now
is different you don't see it it's just
the sequence of zeros right just
sequence of zero bits right so now I
have to get this guy out to see anything
so you can see already it's just the 80
so just one pic here right one peak and
all zeros right so why is that so
basically I'm sending all zeros
everywhere hmm and so when it all sums
up right I have a this is the F of T of
it it's just a pulse right so if you
think of it right if you do what is the
spectrum of a pulse has an infinite
spectrum I'm not infinite but whatever
your bandwidth is so if you send the
same Z the same symbol so all so when I
say send all the same symbol it's
actually let's say one complex number 11
so I have a full spectrum right of same
symbols when I sum it up I get a peek
right so this peak is definitely not
good and why is this pic not good that's
one of the problems with the odm because
of peak to average variation so you have
to normalize your you have to put your
digital to analog converter after this
and your doc is going to saturate here
if it saturate non-linearity is going to
clip it and going to destroy things out
there so basically what you do you
basically have to just up just add the
scrambler so scrambler is this pseudo
random sequence that we were looking at
for most of the talk right and so I just
basically edited here so it's just going
to randomize the thing right and when it
randomizes thing then you're going to
get something which is much nicer so the
peak was 6k right now everything is kind
of biased and in the same range so a DC
so duck is going to behave much better
now of course you can say well you know
i can send something that when i
scramble it comes becomes all zeros
right so scrambling is just one to one
transformation i go from a set of codes
or possible words i can end up in zeros
as well but it turns out that if you
look at lots of things you're sending
like Heather
we'll have lots of zeros you know
packets you're sending will have lots of
zeros so having those zeros is much more
likely to show up than having some
random things so this Grambling helps
reveal a lot and so that's the
explanation from scrambler right so
these are the things there and so the
this is the fool this is the full
receiver so we need this remove DC for
the detection and I'll kind of briefly
describe that next and then we have
parameter estimation this is what we've
seen right we do challenge summation and
then remove cyclic prefix we do F of T
we do FFT we do channel equalization and
then we do pilot rack remove ballots and
receive bit so the receive bits really
is is that the digital part so you do
better be decoding and that's kind of
I'm not touching it it's kind of
standard so and I don't have time much
talked about it but you should kind of
understand except for this this guy i'm
going to talk about in a bit you should
understand most of this and this guy i'm
going to mention this now right so this
is really the receiver and it should
kind of all be familiar to you can this
is enough to run the proper Wi-Fi
transmission in the air over i mean
about tens of meters i guess depends on
your radio and all this stuff but
there's nothing much to it so you know
if you understand this code you can take
it and play with it and do research on
need to add you know it's really simple
i think okay so now just pilots and in
detection so pilots really pilots are
that's difficult to demo because pilots
are used in ideal system you don't need
pilots you just use this channel
estimation and go on the reason pilots
are used is if you do channel estimation
beginning of your Wi-Fi packet and then
as you keep going right your channel
might change so because your channel
might change right it will change a
little bit not too much right and the
other issue you will have a frequency
offset potentially or you know my clock
is different than yours and all these
kind of strange things will happen but
they're small dead epsilon changes right
so the way you monitor reserve some
changes you look at the pilots and
pilots really like a small preambles
which you know of so you do the same
kind of algorithm it's really the same
thing in version over the pilots but
then you interpolate over all the data
points so it's kind of a small
additive improvement but it's quite
important it's you know fundamental to
actually make it work there is no extra
logic it's really the same thing you
just have to think of it having you know
you did this basic estimation initially
of the whole thing and now you keep
track just devoting a little bit of
parts in frequency just to keep on
estimating it's the same idea the same
code I mean though so I'll put all this
code online so if you want to and there
is the whole Wi-Fi transmitter and
receiver already and repository so you
can kind of go back to these examples
random yourselves and all that so right
so so carrier sensing in synchronization
so basically the point of carrier
sensing is to find where the packet
starts right so all this was fine
because I was sending from transmitted
directly in receiver but usually you'll
be out in the open you have a signal
coming and you want to know where does
it start right so how do you find what
it starts that's something you heard in
the previous talk as well there's energy
detection and all that but so carrier
sensing is for that and also is used for
for actually sorry this detection is
also used for carrier sensing so as we
saw the carrier sensing can be done with
energy tection and can also be done with
preamble detection and it's actually
down to the designers the Wi-Fi
different cards can do it differently
and they do mix of the two right and
also used to estimate carrier frequency
offset and I'll skip that for now but
basically you need the accurate timing
because if you shift your timing then
all the things we're talking about you
know you you'll catch the multipath you
you need to start these things in the
right times so this is a kind of an
important block okay so let me see i'll
skip the rounded em on the second one
because i'm getting short of time which
so what what is a so this is yet another
preamble if you remember transmitter we
were sending two preambles the second
preamble was the one that used for
estimating channel that you saw this is
the first pmo which really tells us
where the channel starts so this is this
preamble in frequency as you can see and
this is the actual Wi-Fi preamble I just
copied it and these are the real number
so again the preamble will d be complex
there the queue which I don't show this
is the i one so the interesting thing is
that there are lots of zeroes right
there a few ones I mean so basically all
these are the nonzero symbols and in
between their zeros
okay so what does it mean so if you work
out the math you'll figure out that if
you put these gaps in between this will
define the periodicity of your of your
signal in time if you look at a symbol a
signal it's not really very visible but
you can see that this guy is periodic
with this guy goes down look at this and
this guy goes the same and this guy goes
the same and this guy go the same so
there are four blocks which are
repeating right the exactly the same and
I just I mean I was going to do the demo
but it turns out I'm short on time but
basically if you if you run this you
will see that this is the outcome signal
and the gap between this is exactly four
so one two three four so the periodicity
so does the gap between the time the
signal frequency will give you the
period east in time which okay so why do
we need this periodicity so we need is
periodicity to simplify detection okay
so I'm sure you how you do detection but
just keep in mind that really this thing
is periodic okay so how do we do how do
we detect preamble so the easiest ways
to do correlation and that's something
you heard about in the morning but
basically what happens is you start
moving around so you single is coming
your matching this pml matching matching
you're doing this match filtering or
correlation whatever you want to call it
and at some point here you have a hit
right so did this question say this is
my starting packet conceptually very
easy the problem is that this
correlation is very demanding right so
if you think about it so this guy here
let's say this is a preamble of 64 64
complex number so I'm doing the first
one and I have to correlate 64 complex
number this times this plus this time
this plus this time this conjugate and
so on right so I do 60 for
multiplication at this point right but
then as I move the next symbol do 60 for
multiplication and that's a 20 megahertz
20 mega sample second so it's a lot of
calculations right and it's very
difficult to do that if you have if you
don't and that's the most demanding part
of the actual circuit right so i have to
do either cross right so now the
observation is because there is
periodicity right we don't need to do it
as often right because we have this so
if you think of it right so if I'm
correlating here once i move and call it
here I know that these guys are the same
I only have two
we correlate this next night right so
I'm going to put this in my algorithm
I'm not going to rerun these because I'm
I ran it already right so and i'm doing
a trade-off in accuracy and i'm going to
show it to you now so this is I think
that last demo okay so
what is NC so
so what I'm doing here basically just
sending the preamble in time okay so
what you will see is now this is the
preamble I'm sending this is a kind of
messy I know it should now I haven't put
it in yet in to close those guys so I'm
doing CCI right so I'm basically doing
scale right so this is my preamble and
this is some random signal ascending
right and i want to see how will that
correlate right so what I'm going to do
I'm going to run my correlator and I'm
actually correlating 16 of this this is
the repetition by 16 on this then I move
for the next 16 right so i can use this
this this thing and so now i'm just
going to run the correlation
you
so what am I doing here it's the same
code accepted here I add correlate right
and so what I do here basically this
block here is just taking and sending
random 64 symbols so that I have a
little bit of noise otherwise my
collection is cheating right if I have
zeros and I see so this is sending some
data from the receiver I put the
preamble in it and I put the date out
which you saw before right now I did a
correlation so here is my correlation
right and so you see that that's the
thing so as I move towards my preamble
this thing increases right and as I go
beyond as I pass it it goes down so you
know I can clearly see a peak right so
that's the kind of simple detection and
you know you would do that with the same
detection now the reason what do we lose
by doing this repetition right you can
see that this peak is not very sharp
right and the reason it's not very sharp
is precisely this this repetitions
because the guy who is next to me right
he's going to be very similar in the
level of and the level of the peak and
so how do I detect pic I basically say
well okay the simplest algorithm will be
I store the three previous one so I'm
looking for the pattern which goes up
and down right so here I don't see up
and down you go up they'll go down this
guy goes up and up but if I have some
channel problems here's general issues
some you know interfere and so on my
bump my other here here here so I lose
some precision in my timing right I can
do this earlier later but as a trade-off
I actually get the the easier the better
correlator and so I'm just going to
actually show you how this color works
it's not super difficult but it's um
it's actually instructive for that so
one thing so one thing I do basically is
this correlated pattern right so again
this is sort of design so the credits
goes for them for the design we just
kind of implemented here in a simpler
way so what you have to do is a first
thing you how do you correlate right you
can do she shifts and correlate as we
had in an example here you know move
around now the problem is we do it in
vectorized code you're in intel SSE
instructions your vector has to start
TV 16-bit aligned so you cannot
arbitrarily move the move vector so you
can actually move only by for complex
numbers so the trick they do and it's a
quite neat trick basically create all
the rotations of the preamble right so
when they take this for bit because the
preamble is already six cyclic they just
correlate with all the correlations and
these are our patterns which are just
the original preamble just shifted by
one just shift by one by one line so you
have all the circular shift or agreeable
priest computing right so when we go and
actually do the correlation so for each
of these right we do 16 correlations
right we do 16 Croatians with different
circular shifts right so any of these
circular shift could be a hit but then
we don't move by one by the Mumbai 16
right so it's really the same but the
only thing the only difference is
because of the nature of the computer
architecture under need we can move by
one because our RSS see buffer is
defined by four so it's a trick and this
is something a compiler as far as I know
won't be able to at least not ours so
it's quite difficult optimization so
there's still some human thinking
involved right but these kind of things
are you know you can make this as a kind
of a function which is kind of standard
so you can you can kind of use it but
you know the point is that there is some
thinking you cannot completely you know
forget about kunder lying architecture
but it's still kind of quite quite and
actually this is the entire correlation
code it's one page right so the other
thing the other trick and this actually
comes from the Wi-Fi design because of
these are repeatedly repeating preambles
you don't really need to call it again
but you just store the previous Croatian
so you have this window of Croatian
history that just shifts right and
you're reusing are this information from
the window and you're kind of just
running it running in there so as a
final demo okay so you might ask what
about performance so I've tried to let
me just understand if I put everything
ya know
okay so i should be so I should be
running the same thing within a test
mode so okay so now what I'm doing here
and I'm hoping it's going to finish
nicely so I can hope it's not going to
be an embarrassing number ah sorry I
forgot one more thing
so what i'm doing here is basically i'm
running the i'm compiling the same code
when I just have the correlator and I'm
running with all these options with
vectorize everything to have a very high
throughput output right and so it's kind
of doing something all behind your back
so you saw the code that was the code
the same code so the other thing I just
should correlate to read and write ok so
then what happens and it's kind of
simple profiling by the compiler shows
you what you can do with kind of the
flexibility you have now I run this ok
so this is the command line there around
I just say input is dummy I send zeros
ok and the output is dummy I don't know
I don't have any input on please just
send a the same buffer 0 buffer again
again and I do 800 million times right
so it send a lot of it and it allows me
to profile entire my my block right so
the key question i have here is
basically when i when i do this right
what is it true pawtucket i need to be
able to do this at 20 mega sampled a
second otherwise my solar design is not
working right it's too slow right and
because i'm designing it from cpus right
I don't have any guarantee this works
fast enough right I need to test it
myself if you design fpga you know the
clock right you might have too much
space but you know it's going to work
fine here we TP use the key trick is
actually need to make sure it works for
us now so this is a great way to measure
it right you just run this and he
usually takes takes 2.4 seconds right to
run 100 million samples so it's roughly
about 40 mega samples a second right and
we need 20 so we are good right so i can
say say and it's double the limit so i
can say safely then i can run this in
any design and if you think about it
this is the CCA block which doesn't link
into anything else right once you detect
then you go into everything else right
so you can text CC a block in isolation
and the nice thing it then that's the
kind of the separation of data and
console flaw you don't really care
whether you have all zeros or you have
whatever you have is a data because it's
just a detector it's just doing
correlation so there is no control pad
inside and you actually do accurate
measurement of performance with this you
don't have to worry about whether your
tax all parts of the code and so on so
essentially we know now safely that this
can be put in any other architecture as
long as its standalone and we can do the
same and that's what we do with this
profiling
profile different parts of a chain which
have different control parts to make
sure they're all fast enough right and
this is a kind of a as good as it gets
in Sora to tell that actually your your
design is good enough and you want that
you know you're not breaching the timing
so basically the bottom line is this
disco'd here is relatively simple
supposingly quite easy to read write and
okay there's a little bit about this
move but it's really not much the
algorithm is out there right and it runs
fast enough to run the real time thing
right so that's that's the kind of
outline and so we basically went through
the entire are going back to it we
basically went to in through this entire
guy right we now understand this we
understand pirates this bit is kind of a
standard thing so this is it right this
is the whole Wi-Fi receiver and the
transmitter is really the signal
processing part it's just I 50 with
adding second terrific so you know I
think if you understood these bits in
about an hour right I think you are safe
to go and play with it yourself right
and that's my hope that after this you
know you'll be really excited to try it
right ok so that's the last bit so right
so conclusions are so basically a
wireless innovations happen and will
still happen in this into our
intersection being fine my players you
have white spaces or other types of
spectrum in my use you want to do
sensing their you need blocks to do that
you go to 60 gig ahead you have
different issues there so you want to do
these interactions new and new standards
coming new challenges and so that's why
you can do it in software radios where
you can do this innovations and we need
prototypes and test path to better
evaluate these ideas you can do
simulation can do only so much you
really want to do the interaction with
the rest of the system the real wireless
channel the real challenges and so on
and so physical I programming i think is
still in its infancy in terms of
programming tools and I mean whoever
used it i I don't I haven't found anyone
who is really satisfied with lots of
things so this is our so basically
difficulties it's difficult to use to
learn there's lots of things that you
have to do and there's limited
portability and scalability in a sense
that you know you have to it's difficult
to learn
and everyone I talked it took some time
to learn it difficult to compare with
other people if you write another
platform you can't run your code and
extend previous work so basically the
bottom line with this is that we have
our so this was our goal to make our
take on trying to make the wireless
physical programming easy and hopefully
I appreciate you do it's easy and you
it's fun so you can go ahead and play
and lots of these three things are here
so you can just download them get them
and and play with it so that's about it
so thank you and any questions if I
still have some time you showed the
example of running at 100,000 times 100
million times and and then we are able
to meet the requirement but in that
example I gave the same input all the
time would it have mattered if the
inputs are different because this is
running in CPU and then if you have
different later loading data and doing
some lookups which means that could be
some kind of roads kind of stuff so what
is your thought on performance on from
that one right so I think so yeah it's a
good point I think so one thing we're
trying to do with the vectorization is
to schedule in larger chunks 01 blocks
runs over multiple larger chunks so that
will avoid lots of look lots of locality
issues right the other issue is also if
the code is more complex you have
different ifs and so on so actually the
correlator is mine I mean I brought it
from scratch it's not the sort of code
and there is more difficult because lots
of ifs lots of states but this one is
simple and it also works fast enough so
we kept this one because the code is
simple you can rely on it so there are
diseases but so here because that's the
best thing you can say the hope the
whole argument here is like we're double
the rate requirement so hopefully I mean
I haven't seen that then so of course
the next test that this test we're doing
is actually sending real signals
you receive hundred percent of your
packets you're good right how about the
simulating a network like you have
multiple transmitters and receivers and
in you simulated kind of almost
real-time this thing so we haven't tried
this is a good point i mean it will
still be fast right so yeah maybe so you
have to integrate it in we had them
another take on previously on a
simulator where we kind of virtualize
the physical air but we never did more
really integrated this so if there's
interest I think it's a good idea yes
maybe you know can speed up I don't know
how fast it will be but but I think the
point is that you could actually instead
of a simulation run this on multiple
computers and actually see for real
right yeah better than a simulation yeah
any more questions we can take probably
the last one ok so I think we should
tank Posey there so you guys must have
written all this up in MATLAB right you
must have sort of done this channel
whatever he showed right send sine waves
run a channel some channel on it and all
this kind of stuff now he did similar
stuff but the difference is that you can
actually make it go on the air and you
can actually see what is happening for
yourself in reality so this is as easy
as matlab if not easier with them is
rightly but you can also make it run and
you'll be able to hear this code and do
it yourself you need to have sort of
boats but then you you know you can just
run it on there and the real time yet
right okay so let's tank the speaker now
and we have this token of appreciation
for you it's a tribal painting and
thanks thank you thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>