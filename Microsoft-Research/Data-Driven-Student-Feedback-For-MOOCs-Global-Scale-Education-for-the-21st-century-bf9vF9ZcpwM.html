<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Data Driven Student Feedback For MOOCs: Global Scale Education for the 21st century | Coder Coacher - Coaching Coders</title><meta content="Data Driven Student Feedback For MOOCs: Global Scale Education for the 21st century - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Data Driven Student Feedback For MOOCs: Global Scale Education for the 21st century</b></h2><h5 class="post__date">2016-06-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/bf9vF9ZcpwM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
okay great we can start great pleasure
to have Jonathan wanna hear Jonathan did
his PhD with Carlos gastrin at CMU about
distributions over permutations and
similar structures and is now doing a
postdoc at Stanford working on some very
exciting topics around machine learning
and online education please I'm Mike
okay can you all hear me good so I get I
was here a few years ago and this is
going to be slightly different from that
talk so I like to I'd like to begin with
a quote from from Steve Jobs I actually
graduated from Stanford as an undergrad
in 2005 and Steve Jobs was my
commencement address speaker that year
and you may have seen sorry you may have
seen his talk on YouTube and he has a
number of interesting little stories but
one one that sticks out in my mind is
this he says that all of all of my
working-class parents savings were being
spent on my college tuition and the
minute I dropped out of college I could
stop taking the you know the required
courses that didn't interest me and
begin dropping in on the ones that
looked interesting and for for those of
you who don't know the backstory here
the classes that he was talking about
the class that he was talking about was
was a calligraphy class that he found at
a local college and ended up playing it
you know somewhat of the big role in his
life later on when he went on to design
typography interfaces at Apple Computer
I like to bring up this code not to you
know tell people that they wasted their
time in college I don't think that Steve
Jobs met this but you know the the point
of his talk is to get students to pursue
their passions or in a more immediate
sense of this quote to to learn what
they're interested in learning which is
very good it's very you know very
inspiring but it does bring up a few
questions and for
me you know one thing that I think about
is what if I don't have a good
calligraphy class in my in my area or
what if I don't have a good machine
learning course a good computer graphics
course what do I do and so that's why
I'm very interested very excited about
the the the rise of free open online
education nowadays I can go online and I
can take really anything under the Sun
including these two courses from EDX and
Udacity on computer graphics which would
have delighted sixteen-year-old me who
wanted to make computer games but
couldn't find good textbooks or could
classes nearby has anyone here taking a
mook by the way not that many okay well
so MOOC stands for a massive open online
course and now you can go online that
you can take machine learning you could
take you can learn how to program in a
ton in this vehicle or you can build
your own search engine and completely
for free or at least for very low costs
in a number of different websites this
is really exciting for a number of
reasons and you know i should say that
online online education has been around
for decades now but but it's really
become a big thing in the last two years
with people from all over the world
turning to things like MOOCs but online
education in general and so that's been
very exciting and and to take things a
little bit beyond you know pursuing our
passions or Steve Jobs let's look a
little bit at computer science and these
numbers i apologize are for the US
computer science right now in the u.s.
is the top paying college degree there's
so many job opportunities available and
you know and and not enough students to
fill those job opportunities which is
good for people like you and me but it
does point to this big kind of gap here
this huge put room for potential and you
know one of the reasons for this gap is
that a lot of still a lot of formal
education outlets don't don't recognize
computer science and in some respects
nine out of ten high schools in the US
don't teach don't offer computer science
courses and most states don't
recognized computer science is something
that would satisfy a requirement for
math or science and you might think well
okay I'm just going to wait for for
college into computer science in college
but I have to warn you that college is
also getting more expensive and you know
the conclusion of this is that there's a
you know huge room for improvements room
for growth but and and so if only we
could offer good quality computer
science education at low cost and many
more people then we can make a big
impact in this world and so just to give
you an idea of how much impact how much
how much reach online education can have
I'm going to borrow a slide from Andrew
and Daphne Koller from Coursera Andrew
teaches a machine learning course at
Stanford and when he teaches it at
Stanford roughly 400 students enroll
that number is a little bit outdated now
when he put it online a hundred thousand
students showed up okay and so typically
if you asked after and Andrew they'll
say that if that definitely sorry if
Andrew were to wanted to cover as many
students as Stanford as he did in one
offering of this online course he'd have
to teach his class for 250 years which
is a lot right but they are sleeping in
something under the rug in saying that
number and and here's the way I like to
say it andrew has a staff of ten ta is
when he teaches this course at Stanford
and when and if he were to keep the same
staff to student ratio in his online
course he'd have to actually have 2,500
poor graduate student TAS which is you
know not exactly the vision of you know
being education to everyone that we
imagined one of the one of the problems
with not having a big enough staff is
that it really limits the types of
assignments that you can give to
students you know this is not always a
hard thing so if your assignments are
always multiple choice questions for
example then this is fine you can grade
everyone with the computer but it's
really at the other
end of this spectrum when you're talking
about mathematical proofs essay
questions poems even that it gets really
hard for computer to too great or give
feedback to those students there's a lot
of work on this end some including some
of my own work on crowdsourcing for for
grading and MOOCs but today I'm going to
talk about the middle of this spectrum
which where I think programming
assignments lie it's middle for for many
reasons what one reason is that it's
actually easy in some sense to degrade a
computer science submission because you
can actually just run the programs right
so here's a linear regression assignment
for engineering someshit learning course
students had to implement gradient
descent okay so this is a this is a real
submission and to test these the the TA
setup unit tests okay example unit tests
and they run every submission that came
in on these unit tests and they check to
see if the outputs were correct or not
very simple approach it's fast at least
in this case it's you know it's simple
but is it enough and you know i think as
programmers many of us would agree that
that's probably not always enough
feedback for student write programs that
programs are a little bit closer to
essays in some respects they take a long
time they can drive you crazy when
you're trying to debug them and you know
it when you're done it's something that
you might even want to share with your
friends in a way that you can't share
your multiple choice answers with your
friends unless you're cheating right and
so it really does seem like this kind of
beyond binary feedback is necessary for
for students and here's here's an
example here's a real submission to the
same problem it's you know gradient
descent for linear regression and uh and
it works actually if you if you run this
so in the eyes of Coursera this would
have gotten a perfect score all right
but if I were human grading this I might
want to tell the student a few things
first you know these 15 lines inside the
for loop could perhaps have been better
written as
online there's some problems with the
variable naming right trans one trends
one chance to somewhere temp 1 10 2 and
so on which is you know suboptimal right
and it's unclear what what the point of
these two lines at the end mean alright
this is a real submission and that's
what I'd like to give that's the kind of
feedback that I'd like to give students
but I have to give it to a hundred
thousand students in a course preferably
in real time okay sighs I've shown that
you know this kind of real-time feedback
is actually really really good rather
than waiting a week you know waiting
after the students have completely
forgotten about what they did right and
to make things worse there's now this
really big ecosystem of MOOCs and so we
can't expect teachers to have to do too
much work for a new programming problem
a new programming language or even to
apply it in general to a new course and
you know if you go on Coursera right now
i count about a hundred courses that
require students to do some form of
programming okay and each of these
courses have multiple problems so
machine learning for example has
students working through 42 you know sub
problems in some sense and you know this
is starting to sound really hard and in
fact you know these systems haven't
really been built before and so the
question is what what's changed what
what would make us audacious enough to
to think that we could do better than
before and I think what's changed is
that now we have a lot of data available
to us and just to give you an idea the
largest on campus CS courses at Stanford
run about a thousand students large
these are for the intro CS courses if
you go online you're automatically an
order of magnitude larger and so Cody
chess is among the smaller of these
outlets and there you have tens of
thousands of students code.org has now
20 million students at my last count and
that's growing and what this means is
that every time we're looking at one of
these assignments for these courses
we're looking at tens of thousands of
different approaches at that assignment
all the ways of being right all the ways
of being wrong and so on
and here's here's a way to put it
visually here here's a kind of
visualization of 40,000 implementations
of the same linear regression assignment
that I showed you here every node in the
graph is a single submission and every
edge represents some measure of
syntactic similarity between two
submissions and you know don't worry too
much about how I made this you can ask
me offline if you want the point is
there's a lot of data and if you look
carefully you can you might even see
some structure in this you'll see
clusters of students kind of approaching
the problem in the same way and so you
might start asking whether we can
discover this kind of structure within
these submissions and whether that
structure can be then used to give
students better feedback on their
assignments okay and so this is the
question kind of question that I've been
thinking about a lot in the last two
years and today I'm going to try to tell
you about my code webs projects and code
webs takes data from a lot of students
for coding coding assignment and we'll
give a student feedback about that
assignment and so if all works well this
demo is going to happen you can ask Tori
about my friend who deleted back slash
user on my server yesterday ok so anyway
sorry hold on so imagine you're doing
the ml class and this is the this is the
statement for the gradient descent
problem again and you're given a sample
data set and you're asked to fit a line
to it using gradient descent one thing
that Coursera will do right now is it'll
tell you if you have a if there's
something wrong with your code via unit
tests right and so here you've coded up
something that this will be a correct
submission but maybe you've made a
mistake by taking the derivative
incorrectly so you have two times M
instead of em ok oops and so when I find
bugs here what's going to happen is it's
going to the code web server is going to
split this code up into little bit
and it's going to compare each of these
bits all historical submissions and
it'll start checking to see which bits
are kind of more likely to be buggy than
other bits I'll go into more detail
later but this is what happens what it
does is it will find ok your tune times
n is buggy or likely to be buggy there's
a little confidence score here about how
likely that is and not only that it'll
excise it'll take away that two times m
from your code and I'll start trying to
fit in other people's code into that
little missing hole and seeing what
what's the best way that it could make
your program run correctly again alright
and so the solution that it comes up
with here is the end you can also use
this idea for it too yeah sure a corpus
of programs those who alleged to solve
exactly the same problem so there's no
good just saying here's a lot of code no
no no they're all they're all trying to
felt the same problem specific yes yes
and I'm definitely leveraging that kind
of structure here yeah so I can't at
least this this kind of approach
wouldn't I evilly applied to github for
example right okay so here's here's an
application that code webs does where
students coded something up and maybe
they've got tune all the bugs out but
they want to find a better
implementation of something okay so here
first I'm going to parse it and what
this does is lets me select out parts to
to analyze okay and so here maybe I'm
not so happy with the way that I wrote
the gradients for linear regression out
and so I'm going to select that I'm
going to find alternatives and ignore
this option right now when I click that
what what's going to happen is it's
again going to take that code out and
start fitting other people's code in and
seeing what are other ways that people
did this and not only that is going to
tally how popular those ways were and by
the way it's looking through forty
thousand submissions right now and so
here what happens is I found you know a
bunch of alternatives and it's ranked by
how popular they were it says that this
is the
better way of writing the gradient or at
least a more popular way of writing the
gradient then then this way no one in
the data set wrote it this way in fact
but ever you know over 100 people wrote
it this way if you go down the list
you'll find over 200 alternatives and
I'm not going to report them all we can
use this to label different parts of
people's code to so now that I can
recognize all the ways of writing the
Great and I can label that as the
gradient and and I can recognize it in
other people's code and so now again I'm
going to give you a solution and I click
understand and it'll tell me for example
that's where where you wrote this x
times theta you're referring to the
hypothesis wear whatever you wrote for
hypothesis minus y you're referring to
the residual and so on and so those are
hand labels I I picked out a few kind of
parts that I recognized in code and what
I'm going to show you so it so
recognizes that too one example program
and kind of hand annotated I hand
annotated it I'll go a little bit more
into detail later on how I do that and
but what's cool is I can you know I can
come back here and i can write it some
other way so I can you know maybe I
wrote theta prime if I can find the
prime times x prime prime I think that's
what I need to do right and and so right
here it'll find that theta prime times
whatever I wrote for the X transpose
prime is going to be the hypothesis
again all right anyway so that's a tour
of of code webs and I'm going to tell
you how how we do some of these things
yeah
difference how does it help the student
uh if you want to so later on what I'm
going to tell you about is how is how a
teacher goes in and annotates different
parts of code and so they might say you
know the way you wrote this gradients
was suboptimal or something and then it
can highlight the gradients it's just
for it's mostly the names are for our
interpretation but they don't they could
be named one or two right it does that
make sense yeah but it's important to
recognize different parts of the code so
so this is the part where students are
merging their two lists from merge sort
that's a useful for down the road yeah
as an end goal I don't know that that's
not the end goal certainly a student
likes using a lot of function to compute
the gradient so bugzilla we function is
curve looks happy to understand that no
so so right now we don't recognize those
and a few students do do that kind of
thing for for the Coursera course but
yeah so we sort of assumed that
everyone's writing one function right
now though he's movie on that since
since this demo was developed yeah I
didn't see any comments anywhere ah we
remove comments so I'll tell you more
about that too yeah okay good so this is
a kind of a tour of what I'll tell you
about I'll tell you about so cope webs
can be thought of as a search engine in
some sense for code and tell you about
how we do the indexing for that and then
how we use the index to discover when
bits of code mean the same thing which
is important for reasoning about certain
code and and then given these two things
will will tackle a few applications such
as the bug finding application which is
somewhat less important the more
important thing that we've been trying
to do is giving students feedback at
large scales and the best thing is it
does work and so I'll show you some
examples of that okay let's
talk about representation there's a
number of ways to represent code we use
abstract syntax trees to represent our
code and they're nice because we it lets
us ignore things like comments and white
space even though you know for the
purposes of Education maybe comments are
important at some part of it s these are
the you know these things that you get
internally after you parse your code and
for example the st corresponding to a
equals I of five would be at least a
part of the ast would look something
like this ok code web is a search engine
for asds it's a it's an index for a sts
and you know if you if you go and think
about what it means to index a set of
documents you might build a list a table
like this where you're keeping you know
a row for every term or phrase that
appears in your in your corpus you might
remember that the the word submarine
appears in documents two three and four
okay and then you know later a query
time you might want to look up blue sky
so you go to the you know you go to the
the rose that correspond to blue and the
rose that course went to sky and then
you you might combine those documents in
some way alright so this is you know
this is very nice it's it's a common
thing to do the question is if we were
to do this for code what what would be
the analogues of terms and phrases and
we use what we call code phrases and
code phrases are there first of all sub
forests and sub trees of an AST so if
this is your kind of bigger AST then a
sub tree might be the sub expression x
times theta okay sub forest could be
consecutive sequences of statements that
you might want to reason about such as x
+ + followed by y + + right in addition
to the sub trees and sub for some in AST
we think about the the context in which
the sub trees and sub forest appear
because we want to reason about the
context in which code is written and
context we defined as the deletion of a
sub tree or sub for is from a larger st
and so in this case the context of x
times theta within the larger
mathematical expression looks something
like this and we'll we'll remember
where the smaller sub tree was deleted
out and put a little kind of a special
replacement site node there to remember
okay yeah yeah we do search for contacts
the surprising things parts about
ordinary search engines is how much
mileage they get out of very simple
things I just search for words like no
context stuff yes you're really doing
something noticeably more sophisticated
here we are yes and and you know the
rules that we were forced to I'll show
you how we use context you know the the
the behavior of your code met the
context of your code very much much
matters for the behavior of know the
thing that that it that's inside the
context right this is a true statement
okay so cobwebs is index for AST so just
like we index documents by terms or
phrases in which they appear we can
index the AST s in our in our data set
by the code phrases that that are
contained in the AST s and we implement
that using a hash table so here what i
have is a hash code for every code
phrase that could possibly appear in any
of my submitted a STS followed by a list
of the AST s that that contained that
code phrase okay so so you know at the
back end it looks something like this
and this is conceptually easy to build
what we do is we just go through all the
ast s in our data set we we go through
every code phrase that's contained in
every AST you know we hash and then we
insert into the table very easy hard
thing is getting this to be to be very
fast okay first of all we have a lot of
a STS the ASCs themselves can be quite
big so they can be you know several
hundreds of nodes on average for the
problems that we're looking at you know
these are usually just one function each
ranging to 2000 or even more nodes for
some asds and so if you think of how
many code faces there are that this can
be quite unwieldy the way we do it is is
using exploiting some structure in the
hash functions that we use and I'll tell
you a little bit about how we do this
the way we hash
AST is this we take a tape a tree and
they write all the nodes in posts order
like this the hash function of this list
we use a list wise hash function okay so
it looks something like this where
you're doing a kind of a weighted sum of
powers of a prime number P by node wise
hashes so H hash of the first node plus
sorry in this example would be P to the
fifth plus P to the four times hash to
the first node plus P to the third times
hash of the second node and so on okay
so you know it's very simple thing this
is the kind of hash function that you
might use in Java for example and it's
efficient it's over N right in where n
is the number of nodes in your ast but
it's also somewhat wasteful if we're if
we're hashing every code phrase within
an ast and and so just to be a little
bit more concrete here if we're looking
at this sub tree of an AST then that's
going to correspond to a sub list of the
postorder consecutive a contiguous sub
list of the post order which corresponds
to a contiguous sub some of this hash
function right and so when you see this
kind of structure it motivates a dynamic
programming approach and that's what we
do what we do is we precompute all the
prime powers of of p and then we
precompute all these prefix sums of this
hash function okay this is something
that we do once per AST it's 0 of n in
the AST and and thereafter if we want to
access the hash of any code phrase
that's something that we can do in
constant time there's a very simple
thing to do which is just this computer
hash up from the leaves while you take
the hash of a node is that some
combination of the hashes of its own
trees it's possible that there are other
ways to do this and it be terribly
simple what does it not work I mean that
seems much simpler than what you're
describing no no this is very simple
actually it's not hard and it's very
fast yes even if her station as fast as
the number of hashes you said some trees
or sub forest is still exponentially the
size of the tree you ain't it because I
could think no as I exponential it's
it's square so so the sub where we there
so the subtrees for example there are 0
of n sub trees we don't consider all
possible we make sure that the sub tree
goes all the way to the leaves whenever
we were talking about a sub tree I
should have been careful to define that
yeah so this forest we we only consider
i wasn't i was a little bit you know way
might answer but the the sub forests are
consecutive statements of sequences of
statements okay so they can be squared
in the number of statements that you
have and that can that can still be
really large by the way but but it's not
going to be exponential yesterday how do
you abstract I would name identify
errors a good question so all the
results of today we do the following we
take the starter code that was provided
and usually the starter code is a
function definition where you know you
know the names of the arguments that are
passed in and then we anonymize
everything else and that works
surprisingly well and I have some plots
that can show you you know why that's a
good thing but we are moving for it i
mean we're moving past that now and
we're trying to associate identifies two
to each other we do that after we create
the tree yeah
okay so it runs faster practice too so
too this is for linear regression again
and here the running time for indexing
25,000 a sts goes about 15 seconds okay
on a on our server back at home this is
a plot for how much time will it take to
index a thousand a sts for each of the
42 problems in the machine learning
course and what you're seeing here is
you know typically oh by the way and
we're putting it against the the average
sizes of the AST s that are submitted
for that problem and so there's some
problems where it's really easy so you
know only a few lines are only one line
or so and some problems require a lot so
at this end you're talking about
implementing back propagation and for a
neural network and so these are some
these are some pretty long functions and
and even here we're taking about three
seconds to index a thousand a sts and
you know on the order of minutes to
index an entire data set okay storage
wise we require tens of gigabytes per
problem that we index which is big but
it's not horrible and for the linear
regression problem we ended up with 1
million code phrases if you plot them
kind of in descending order a frequency
you'll notice that not all code phrases
are born equal there's some code phrases
that are very very popular and then some
code phrases that are not so popular and
this plot you know will follow something
something like as if flaw that you're
familiar with if you do this kind of
thing for text search engines you'll
notice text search engines it's just
words was with this stuff big trees
almost very unlikely to be repeated yeah
different going on here the normal texts
something a little bit different that's
true but but zips law also i mean is
it's also paid for for longer faces but
i agree it's not exactly comparable we
do see a little bit of a starter code
what we call a starter code elbow
because because of the starter code
sometimes you'll have one or two extra
lines that are that are provided to
students and
and so every student in the data set
will will have you know if we'll share a
few code phrases and so that's why we
see this elbow tree right just an
expression nothing they're always know
the Holy sts are included included in
the spot too so I mean the whole EST is
a subtree of a nasty yeah we keep
loading here is just expressions or no
their entire thing sits every everything
you could think of embarrassed
expression so the first one is like x or
something right all right yeah i dint
times i dint that's right yeah and if
you were telling that x equals 3y plus 4
and x equals 4 y plus 3 those would just
hash two completely different things
they were so they'd be kind of unrelated
even though they were all closely
related that's right I'll talk about
that too yeah cushman sort of related so
there is a component which is repeated
in a different program so linear
regression might appear somewhere else
as a small chunk in a bigger program so
how would the index is not deal with
that yeah so that's a good question
we're currently not relating these
submissions across different assignments
though actually for this class it would
make a lot of sense to do so because you
reuse code and so you might call the
linear regression implementation from a
later thing or another example would
have been the neural network problems
where people have to implement back
propagation then they had to implement a
regular eyes version of back propagation
and so on but we we completely ignore
that okay so let's talk about bug
finding I told you that Coursera will
take your thing and I'll run your unit
tests they'll tell you whether your code
is right or wrong what we'd like to do
what code waves would like to do is find
out where the bug is right so so here
one one common mistake was to put a sum
here there's no some in the correct
implementation as common mistake because
there's a lot of implicit sums running
around these matrix operations here so a
lot of students got confused what we'd
like to do is figure out where the bug
is and what the solution is and I'm not
trying to tell you that this is what we
should tell all students right
we shouldn't tell students to ask what
the correct solution is but it's
important to understand what their what
their bug is in order to give them a
good feedback so it's just it's an
intermediate step along the way okay
this is you know obviously a very hard
problem in general but data gives us a
way to look at this in a different kind
of different matter right so so we
approach this kind of more from a
machine learning perspective and here's
how we do it let's look at whether the
some expression is a bug here the sub
expression is going to be this red sub
tree with this wood texture that I got
first we query the index and that's
going to tell us which AST is contained
that that summed expression okay then we
then one simple thing we can do is look
at you know whether they pass the unit
test or not this gives us a number we
can say that okay eighty-three percent
of asds containing this code phrase
we're buggy okay so that's this is
somewhat of a cartoon the problem gets a
little bit harder than this and you know
the reasons why it's harder is first of
all we have to do this for every single
subtree and sub forest in the AST so so
first i mean we have to do a lot of
queries per AST and then kind of going
further than that we don't what it
really tells us is that that's the
probability of an AST or sub tree
containing about not whether the sub
tree was a bug and and so we care about
is finding the smallest subtree ennis in
some sense that was responsible for a
bug okay and then on top of that what we
can do is we can remove the sub tree and
query the context for for things that
could potentially fit inside that
context I won't go it too much into
detail about how we do that but but I
will it will talk more about contacts
queries later on this is our performance
on F score and so the the task here is
to predict whether a piece of code has a
bug or not okay we don't have ground
should we found where the bug is and
here we're computer comparing code webs
performance to a baseline which is five
nearest neighbors using tree edit
distance between a sts
you'll notice that's typically for most
problems code Webster's better but
you'll also notice kind of a range in F
scores and the the circles the the
circle areas are representative of how
many nodes / AST where there were four
for each assignments and so what you'll
notice is that for the larger
assignments we typically don't do that
well right now in bug finding okay one
of the things that one of the things
that makes bug finding hard is that
there's many ways to skin a cat as i
like to say there's many ways to write
code that does the same thing I might
write x times y plus Z Danny my right y
plus 3 times X and and if we're doing
this hashing kind of matching we're
never going to be able to generalize the
things that we learn about the students
who write it this way to the students
who write it this other way right we
might need one yes make a good way
somebody might like one yes and then
you'd like that too too yes 10 p equals
y plus dead x times 10 that's right well
so so what huh that sounds pretty
difficult it does sound very difficult
let's go on ago I'll go more into
details on how we do this 11 common
approaches canonicalization for this you
you come up with a bunch of rules to put
your ast into canonical form okay and so
one one rule might might be whenever I
see a multiplication by two scalar
values I'll I'll rotate the st so that
the heavier end of the that of the
multiplication appears on the left hand
side okay and so if I do this every time
that I'm going to increase the chances
that students match to each other when
they write code okay that's pretty
common approach but it's also not very
effective in many cases right you can
imagine that there's many ways to write
that same thing I can try to encode
associativity distributivity community
and that's going to give me already six
possibilities but I can imagine more
right I can think about putting a little
one here or I can vectorize the sum
or I can think about using built-in
matlab expressions which you know many
people do and I guarantee you in a class
of 40,000 students every one of these
possibilities will have been hit and so
so it's getting really difficult right
the sounding card and to make things
worse we don't want to just write out a
list of rules for matlab right we want
to have something that also works well
for for Python for haskell for Ruby and
so on and and so the cobwebs approach
takes is data-driven what we're trying
to do is we're going to use data to find
what these rules really are and you know
some of the benefits is that this will
let us apply our approach to two
different problems the different
assignments to different languages and
so on and i will say that we're not
building a compiler so some of the rules
that you'll see me learn are not going
to be technically correct but i'll argue
that they're going to be good enough for
educational purposes okay here's how we
do it here's kind of a cartoon of how we
do it anyway let's suppose two people
submit these two submissions they're
identical except for two parts one
person writes x times theta the other
person writes theta prime times x prime
prime okay so kind of in terms of a STS
it might look like this where they look
identical except for these two subtrees
or sub force theta prime is the
transpose oh sorry I'm sorry that's it
that's the matlab see what these
diplomas down no no soso prime is an
operator it's a it's the transpose of a
matrix in matlab and so this is a what
I'm capturing here is a mathematical
identity that when I write a times B
where a and B are matrices and that's
the same as writing be prime times a
prime prime okay the point is though I
can run these two pieces of code and
they'll run identically under unit tests
all right and so by observing that that
gives me a little bit of evidence that
the you know that this blue thing is
interchangeable for this red thing right
not proof it's a little bit of evidence
and and here's the counter example for
why that's not proof can anyone spot the
the to the difference between these two
yes so so I seem to have switched from
MATLAB to python but um but but this guy
wrote print solution and this other rope
this other guy real print not solution
and so if we're trying to if we're
running unit tests on this and using the
same logic from the last slide I will
have concluded that solution equals not
solution okay which is used to know
that's right yeah there's many reasons
why this is you know not not great logic
to follow okay so the point here is that
agreement the agreement on unit test
anyway can can be context-dependent
thing it's not just that it's not just
the fact that your unit tests weren't
perfect it's you know it's it's a
context-dependent thing and so and so
let's look a little bit about maybe more
of a compilers happy version of what it
means for two code phrases to be similar
semantically similar we might say that
to code phrases are equivalent if
interchanging one for the other nasd
always yields it's guaranteed to your
the program that runs identically right
and you know this might be something
that would work for unrolling a for loop
so you have a for loop and a nun world
version and I can always prove that's
you know interchanging one for the other
will will always preserve behavior right
so that's a good kind of good kind of
definition for for compiler but it's
it's really too rager for the type of
data analysis that we wanted to do and
so what we did was we looked at a
probabilistic version of that definition
we're going to say that to code phrases
are our probabilistically equivalent if
interchanging one for the for one for
the other in an AST that's drawn from
the course distribution and so what I
mean is I'm going to ask my results to
hold for functions that are likely to
have been submitted to Coursera's
machine learning course not the Linux
kernel
okay so I care about 99% of students who
submit to the Coursera course is pushing
these you then depends on the
distribution of the unit disk right so
the parameter that you use immunities
yeah yeah so actually what I'm going to
say here is a and are just
indistinguishable via unit tests so i am
going to make the assumption that units
has our are good enough for the problem
okay I better the other in a particular
way SD when in any ASD in any asta any
AST that so john from the distribution
yeah so I better hurry actually there's
a way to write this out as a probability
and what's cool is that we can estimate
this probability from data and the
cartoon looks something like this so
here I'm ask i'm giving you two code
phrases the red and the blue one and to
estimate that probability we query our
index that's going to give us a bunch of
sorry that's going to give us a bunch of
asds i contain the red and a bunch of a
SCSI can contain the blue we further do
a joint on the context that that these
sts have for the red and the blue and
that gives us a pairing of a sts okay
and each pair looks identical to each
other except for the red and the blue
subtree all right and then what we do is
we look at the unit test outcomes and in
this particular case every time I
interchange a blue for a red it doesn't
change the unit test outcome so what I
would say here is that there's one
hundred percent probability of
equivalents for the red and the blue is
two subtrees okay it's a little bit
messier than that because you have to
account for sample size if I just saw
this 442 a sts and my data set I
probably wouldn't be so quick to
conclude that the red it equaled the
blue but if I started seeing this for
many many many contexts that red and
blue were equivalent in many many
contexts then I can start building a
statistical case alright and this so
that's exactly what we do I'm going to
skip our workflow and go to some results
here I'm so you'll notice that I skip
one thing we actually learn these
equivalence classes of code in a
hierarchical way so what we've learned
is that when we can learn that bits of
code are equivalent to each other but
once we learn that it makes it easier to
learn that other bits of code are
equivalent to each other and so for
example here we learn that when students
wrote length of why why was the output
vector they met the same thing as length
of X where X was the kind of the input
data matrix for linear regression but
once we learn em we could start learning
the Alpha over m equivalence class and
so we learn that when students were
alpha divided by something for M then
that was the same as 1 times alpha /
something for em you'll notice that some
of these equivalences are mathematical
truths in some sense so so for example x
times theta is always equal to x theta
prime times x prime prime but some
things are not in particular you see
that alpha times inva them is equal to
alpha x is declared to be equal to alpha
times p into them which is not true p.m.
by the way the pseudo inverse which is
not true in general but because you know
99 percent of students assume that the M
was a scalar value this was able to
learn this equivalence okay and and I do
argue that being able to identify the
fact that alpha times in them is the
same as alpha times P mm it's a valuable
thing here canonicalization helps us
with bug findings so here's our F scores
as we go from the more frequent AST s to
the less frequent ast submitted when you
throw in canonicalization and improves
the F score not so much at the very
frequent a STS but as you kind of go out
to the less frequently submitted STS it
does help by some factor what's really
cool though it increases our ability to
give feedback to students and so here
you can imagine that engineering will
sit down to grade 25 to give heartfelt
messages to 25 students in his class
okay and because of the redundancy in
this course if he chooses the 25 most
frequently submitted STS you'll actually
be able to cover 5,000 students
if he has the students were through the
night to his TAS were through the night
to grade 200 a sts then they'll be able
to cover 10,000 if we use our
equivalence classes 19 equivalence
classes in particular then if Andrew
just gives feedback to 25 students he
can cover 25 sorry 20,000 students in
his Coursera course and again if he has
his ta is worth through the night to
give feedback to 200 students then he
can cover 25,000 students in total ok I
I'll skip this no I'll do it ok so so
this is again the Sun bug from before
and this is an example of a message that
we might attach to the Sun bug where
Andrews not telling you know poor Lisa
Simpson why she got what you know what
the right answer is but it's it's a it's
an actual hint ok we could do a grep for
everyone who has exactly Lisa's code and
that'll that will actually cover 99
people so the moment Andrew attaches
this this message she can hit 99 other
people in the course we can look at unit
test output so everyone who agreed with
Lisa on unit has outputs and that will
cover a thousand 91 other submissions in
the course and or we can use code webs
and code webs what it's doing is well
Andrew will highlight this it will go
into the code and find all the
equivalent ways in which that expression
was equivalently expressed and attach a
message to all those students and that
will cover a thousand and eight students
but what's cool is that there's a that
these two populations aren't they're not
exactly you know one's one's not a
subset of the other and so you can
actually combine the two approaches and
if you do that you can cover 1,600
students all right
so these are some of the things that we
need to apply code webs a new
programming problem to new programming
language it is some work but it's much
less work than a lot of the systems that
existed before code webs came one we do
need a parser we do assume a language
that has things like identifiers
constants and and statements which is
actually not true of all languages we
assume good unit tests and I didn't talk
about this but we do assume that the
instructor takes some time to mark out
the important parts of the code such as
the gradients or the you know or the for
loop that that does the gradient descent
right and finally we assume the
existence of the big data set and
fortunately nowadays that's not the the
limiting assumption ok so that's that's
a summary of code webs how much time do
I have left five mins five minutes ok
that's a summary of code website or
talked about how to index code how we
use this data to to find semantic
equivalences between bits of code and
how we use these ideas again to to give
students feedback a scale let me step
back a little bit and talk more
generally about about myself I'm
interested in a lot of different kind of
data science problems I thought to to
you about education if you come to my
talk three years ago at MSR Cambridge
you you can hear about my multi object
tracking work in computer vision as well
as ranking ranking work in preference
analysis and in general a lot of the
problems that I'm interested in dealing
with are the ones where you have to
reason with noise and uncertainty and
that makes it difficult because a lot of
these problems also have this
combinatorial explosion and
possibilities and so what I'm very
interested in is finding that special
bit of structure in these problems that
make that makes these algorithms
tractable or makes the models more
generalizable to to unseen data the st's
work can you know can sort of be thought
of as a way of analyzing to
two trees where the structure is this
kind of structure of equivalence classes
that lets you factor the space and you
know allows you to give feedback at
scale I won't go into detail but you
know feel free to ask me offline if you
want to hear about the the group theory
work on on analyzing distributions over
permutations or the riffle independence
work for analyzing distributions over
rankings very happy to talk about that
too just tool it just to talk a little
bit about where I'm going next I do
think that computer science is
algorithms are going to play a big role
in education down the line and what I'm
very interested in dealing with are the
problems with sustainability and
scalability and education I talked a
little bit about the scalability
problems that we run into for for online
education these days some of you may
have heard so some of you may have heard
of sustainable agriculture and I like to
think about what it means for education
to be sustainable and you know we are
sustainable in some ways in kind of
brick-and-mortar classrooms right we a
subset of the of the students from today
are going to become the teachers of
tomorrow right and so if we keep on
going we'll be able to teach students
forever but that's things are changing a
little bit in the online world and the
thing is the the boundary between
students and teachers is dissolving it's
more fluid online and so sustainability
in online education has more to do with
students who who can be teachers
themselves and one of the ways that
we're seeing this already in MOOCs is
through peer assessment peer grading
your grading if you haven't heard of it
is you know suppose you're trying to
grade someone's sa one way to do it is
to just pass it to the kid next to you
or if you're online pass it to five
random people in the course they grade
your essay and you get the the average
or the median over there what they say
about you it's shown some promise on
MOOCs such as Coursera and EDX but but
there's still a lot of open questions
and first of all one of the things is
that students might not always be
accurate graders we looked at HD is the
Corsairs HDI course and we showed that
over twenty percent of students get a
grade of over ten percent of what they
deserved in that course from peer
grading okay which is quite a few
students in this case it translated 2500
students approximately and and so you
can start thinking about what are you
know how do you improve that and one
thing that we did was we we formulated a
vision model to try to estimate greater
biases and greater reliabilities in a
peer grading setting and by doing that
we were able to reduce the twenty
percent two or three percent which is
really good but there's still a lot of
open questions and i hope to focus on
that going forward one problem is that
assignment of graders to Grady's is
still a random thing completely I random
and you can imagine that if you're
intelligent about assignments that could
make a big difference and this could
fold in a lot of side information as
well things like cultural background
linguistic background what a greater is
good at doing in the class what a Grady
is good at doing right another problem
is incentives incentive design currently
students don't get any extra credit for
doing a good job at grading just like I
don't get any extra credit in you know
doing a good job peer reviewing
literature right these are similar
problems and designing the the right
incentives is a problem that is likely
to have a lot of impact in the setting
and is also likely likely to lead to a
lot of interesting work in game theory
sustainability is also about about
processing growth so you know education
is not the number that we not just the
number that we get at the end of
learning right it's how you get there
matters this is a picture of a seedling
but it's going to get bigger it's going
to get more complicated right and but
maybe not it might get stuck under a
rock and if it does we'd like to know
how to get it out from under that rock
and so if this were a student submission
for an assignment then similarly we'd
like to know how to get that student on
stock based on data from other students
I showed you this plot before to show
off to brag a little bit about how much
data we have but but the truth is we
have even more data and than this and
the reason why is because not only do
you have the final submissions of all
these students for a certain problem we
have trajectories snapshots in time as
they're working on their assignments and
and so you can kind of see the growth of
a student's emission from from just a
seedling to the the final working
submission Oh sometimes working
submission right and so these are these
problems of process and growth are
things that we can actually start
studying from a data perspective which
is exciting you can go beyond computer
science and talk about you know how we
would do this for math proofs for four
essays for poems but you can even leave
the kind of the formal education setting
right and go outside of the classroom if
you have hobbies such as such as
painting or in my case it's photography
you might think of how we use data from
other people doing the same creative
process and giving other people feedback
okay and you know nowadays I get
feedback on how to buy a plane ticket or
something on Google now or Google glass
but but in the future and there is a by
the way I heard about a new microsoft
thing that's like Google now I don't
remember the name anyway so it's
exciting to think of how how these
things might give us guidance on
creative processes in the future finally
sustainability is is about lifelong
learning it's not the case that we learn
for a fixed an arbitrary amount of time
when we're little kids and then we stop
learning thereafter you know education
is about taking us to where we want to
go in some sense right and so on in the
online education setting this is about
guiding students not just within the
confines of a single course but guiding
students throughout multiple courses or
even outside the bounds of formal
education and so to be a little bit more
concrete if we're doing peer grading
today we tend to trade assignments
essays with students in the same courses
us but you can imagine a future in which
the the peer grading model is more like
I get to grade students in courses that
I've already mastered okay and and in
return
that maybe I get credits for for getting
good feedback from students in courses
that I have yet to take right that might
be a better model for various reasons
and speaking of what courses to take in
the future what courses should you take
in the future there's roughly 600
courses now combined top by EDX Coursera
and Udacity that number is growing and
you know those are not the only
companies out there right now and you
know a year from now I don't know how
many courses there are going to be but
it's going to be really hard one day to
to choose between all the different
things that you can take and this is a
problem that goes beyond the typical
kind of netflix movie recommendation
setting because not only do we want to
tell students what course that takes
take next we we really want to chart out
a curriculum for for these students to
follow to kind of guide them along their
educational journeys in some sense right
and so and so you know setting back this
is this problem of guiding students in
their educational journeys is it's going
to be super important and difficult from
a data science perspective difficult
from an algorithmic perspective
ultimately worth it if we can help
people like you know the unknown Steve
Jobs or the unknown Steve Wozniak's out
there really pursue their passions and
you know and even if your name isn't
steve wright so so thank you very much
these are this is a list of my
collaborators and i'm highlighting three
names in particular chris peach ND Noah
and Bo who who worked very hard on the
code web project with me thank you
okay I think we have time for maybe one
or two short questions and are there any
one difference between the various ways
of writing these expressions was that
somewhere slower you know a transpose V
transpose all transposed um one thing
matlab might do is give you a squiggly
underline it sometimes does this when
you do inefficient stuff so you can
imagine leading the programmers to write
canonical programs buying by helping
them yeah I agree I mean I think that
would be really cool and I think and
it's interesting because we actually can
figure out when when a vectorized bit of
code is the same as an underdone
vectorized bit of code and what's
interesting one thing that we figured
out was in some of the problems there
and ruing at signs he wanted students to
do it say logistic regression and then
in a later problem he wanted them to do
a vectorized version of that same thing
and they didn't actually check for this
because the unit test can't check for
that in any easy way and so-and-so code
webs is actually able to you know
identify when students are doing one
over the other when you talk about EJ I
mean the actual mechanics is very
impressive and the world what you have
achieved it just is more of a
philosophical question when you think
about knowledge and you think about
teaching the way a knowledge is encoded
here is in the nonparametric sort of way
right you have these 40,000 sort of set
of programs and they encode what we know
about a programming right now when you
think about more sophisticated sort of
education scenarios maybe teaching
somebody to do probabilistic model eight
right then there might not be a many a
sort of concrete representation of
knowledge and also you might need two
ways some sort of code fragments more
importantly than others right so have
you sort of thought about how does how
does
how do these approach approaches go from
the simple end of the spectrum teaching
somebody something very simple to a more
sophisticated end of the spectrum when
you are basically really thinking about
teaching somebody how to do probability
programming we haven't so we haven't
gotten to it's true I think I think
there's some limitations to the way
we're doing things here and it would be
would be very interesting to look at
kind of the more complex things that you
could do currently one thing that we're
looking at is looking at a data set
where students got to decompose their
code in different ways just as a you
know next step forward and like right
now for all these assignments it's just
one function you get the wrapper and you
have to fill it in but what if you have
to analyze code in which students can
decompose in any which way that's that's
itself a very hard problem is we've been
finding outfit but it's interesting with
all right I think we're out of time
let's thank the speaker again</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>