<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Tierless Programming and Reasoning for Software-Defined Networks | Coder Coacher - Coaching Coders</title><meta content="Tierless Programming and Reasoning for Software-Defined Networks - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Tierless Programming and Reasoning for Software-Defined Networks</b></h2><h5 class="post__date">2016-06-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/3tx2tKTGV1E" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
okay great so interrupt me whenever this
is this is all very relaxed good okay so
you know networks for the past few
decades have been configured this way
right you've got various internal
configurations you've got the web
whatnot but most importantly you've got
these boxes that sit there that perform
various pieces of functionality and you
know for example a nap right you all
know what a NAT is everyone has a net
now right everyone's house now has a net
where what is an app to someone what is
an app to at that no not you man I be
quiet one of you net what does a nap do
yeah translates addresses why do you
need one so that you can have lots of
people inside when share an address
multiplex and address okay and then you
have you know firewalls that do various
sort of requests and things like that
and so you can get these kinds of in
factors there's whole websites dedicated
to you know drawings that people make
sketches systems make of their networks
right so they can share the network
configurations at each other and of
course now and then these network
configurations don't work so you go to
these wonderful sites like your network
forum com you know think you know Cisco
think again hey then people will post
these questions and they all start with
some sort of frowny face which means
help me right I've been trying to make
this work I've been trying to make that
work and of course this is the internet
so as usual you know there's like a
thread after thread after thread after
thread and there's all these discussions
right now these boxes have traditionally
been so I put up a cisco thing because
this goes one of the behemoths in this
field these boxes are traditionally
configured in a language called iOS has
nothing of course do with your cell
phone to your mobile phone it's Cisco's
operating system for this kind of stuff
right and so codon in iOS looks like
this and it looks all very homogeneous
but it's actually not because it's doing
several different things so for example
we're setting up various interfaces here
this part is setting up a static route
this part is setting up an at and this
part is setting up a tackle and so
there's all these sub languages that are
somehow combined there is one language
okay now what does the box actually do
well you have to understand exactly what
iOS does
yeah so we work for several years on
static analysis tools for being able to
analyze iOS policies and usually when I
give talks when I used to give talks
about this networking fora usually first
thing was wait you mean you can parse
iOS it turns out like even parsing this
thing is you know like a bit of a
headache right and those of you who
actually worked with iOS notice just all
of this is completely painful it's
locked away inside Cisco the specs are
all you know kind of what it's like one
of the ways we engineered the semantics
is we went on ebay bought a cheap Cisco
box and like sent enough packets I did
try to figure out what it does because
you that's as good as like reading the
cisco documentation okay so first of all
it relies on these proprietary languages
and the second thing is if you want to
change something like this is not the
functionality you wanted you want to
implement a different system of some
sort in your network well good luck
right because if cisco agrees they'll
put it inside the iOS language they
don't agree you're out of luck hey so
those are two problems there's another
more subtle problem which is there some
goal those of you over anyone hears
administrator network at some point and
other than your home network if your
turn administer a larger network you
have some goal as a network
administrator is something you're trying
to achieve but the way you achieve goals
is you have to write some configuration
on this box some configuration on this
box all these configurations that
somehow collectively have to achieve the
goal you're trying to achieve right so
basically like this is distributed
programming without the benefits of Rama
helping you right that's that's that's
one way to think about it so all these
configurations have to somehow conspire
to achieve what you want so in the past
about five years there's been a growing
trend in networking to say this is not
an okay way to build our systems amongst
other things this also dissuade people
from innovating right you come up with a
new protocol well how are you actually
going to implement this you can't so
there's a new trend that says instead of
having these very powerful boxes will
instead have very weak boxes and what
they will do instead is when they get a
packet they'll forward the packet off to
a central controller now this is why
should be emphasized very strictly a
logical model right the implementation
the first this but the logical model is
you send things off to the controller so
you have these switches that are really
dumb okay they don't have a big
complicated language of course that's
version
one in version 2 they always do end up
getting more and more complicated but at
least the idea is that you have these
dumb switches all the decision-making
happens on the controller and all that
the switch does is instead of having
this big iOS program it simply gets
instructions to the controller remembers
and execute those instructions okay so
this is the way networks are
increasingly being built you know for
example there's some famous success
stories coming out of companies like
Google where their back-end systems now
use this kind of configuration instead
okay and this is called software-defined
networking and if you talk to networking
folks they like to say look this is
great right finally we get the power of
software in your network right this is
like an actual slogan that people use
and it's great because it means that
central controller can now be you know
it can be distributed you can use Paxos
if you can use you know dramas ideas for
like how to build these things and how
to get them to be reliable and robust
and scalable and all that stuff and it's
wonderful right compared to the bad old
days now of course there's a software
person I saw this and they said ah great
okay all of the problems of software and
now in your network right if you used to
be that we had these nice compact
languages it almost makes you
sentimental for things like Cisco IOS
because there you had a language that at
some manageable complexity and now all
the problems that can attend software
now happen in the network as well okay
so um to refine this picture a little
bit there's really a very important
distinction to understand between what's
happening at the controller and what's
happening at the switches so this is
typically called a control plane because
it's the thing that's making decisions
about the behavior of the network this
is the data plane which is the thing
that's actually implementing those
decisions it's the thing that's actually
implementing what happens to each
individual packet or each flow inside
the network okay but it's actually kind
of a third plane here which is this sort
of program state as well right because
this program is going to remember things
like even take a nap right now so
remember then that state and propagate
the net state so there's also probably
some program state and to make these
things you know reliable and robust and
performant you actually these things are
actually quite complicated you know all
the usual sort of distributed system
stuff comes in
so really what you have is three tiers
you have a data store you have control
logic and you have forwarding rules and
now this picture starts to look a little
bit familiar right because we're used to
three tier architecture as we've seen
these before um one difference is
there's actually sort of two key
differences what is that these folding
rules are sort of much lower level right
if you think about the web the thread
the third tier is you know JavaScript
which is you know fairly fairly
high-level language and you know yeah I
know we've all been there but you know
it's still a real programming language
this thing is not a programming language
right it's just a bunch of dumb rules
about how to handle individual packets
and flows and also there's no UI here
thankfully right this thing has to do
with you know CSS and JavaScript and
like things flashing in jQuery and what
not there's none of that here right the
forwarding rules are really dumb there
so this is still nevertheless a
three-tier architecture it's just
important to understand that the third
tier is really quite different the other
two tiers are fairly similar so now when
I say problems of software new network
what kinds of problems might you have
well it's a whole bunch right so one
thing is you've got multiple tiers that
are making decisions about packets
there's this tier which is implementing
enforcing the decisions but as this year
which is kind of like actually
determining what should happen and these
things could end up inconsistent right
you might have a switch that forgets to
notify the controller because it got the
wrong kind of policy downloaded to it
and fails to notify the controller when
a state update for example is needed of
course for performance reasons you also
don't want to notify the controller more
than necessary because then you know
like this switch is you know trying to
do switch packets right and bill you're
trying to watch a netflix stream and of
every netflix packet game you went over
to central controller you're completely
hosed you're not going to be able to
watch any movies and and the other thing
is this code is now you know
general-purpose programming and we know
that that's that can be a bit of an
entertaining activity right so any bug
that you might make in your Python or
Haskell or Java or JavaScript because
people rate controllers and all of these
things now you have to deal with all of
those problems there's actually one more
very subtle problem
okay which is remember let us think
about the web by analogy for a moment
this tier generates code for the other
to tears right think about sequel
injection attacks right what a sequel
injection attacks come from they come
about because people didn't do that
quotations properly but in the first
place they were generating sequel that's
the key thing whether they did safely or
real unsafely they were generating
sequel you have a program written Mencia
I'm sorry around here Stacy sharp rather
than Java but you know a program written
in C sharp right and it's generating
sequel code it's generating JavaScript
code the same thing is happening here
right these are program generating
programs that are generating code in
florals in the language of flow rules so
if you want to now apply all this
wonderful verification methodology that
we have for programs in these languages
well that's not enough because most of
the interesting action is actually
happening one tier below so whereas you
might in many cases you can think of the
web as sort of this cosmetic tier right
you're just generating some JavaScript
that maybe does some UI stuff but all
the core logic is on the server that's
no longer true here at all I mean it's
not true in many web applications either
but to really understand the bugs that
I'm talking about you have to be able to
talk about the generated code from this
central controller okay and verification
methodology is nowhere near there right
i mean most of these assume that these
are black you know whole programs and
we're not going to worry about generated
code and so on so it's actually quite
challenging to think about this okay so
we have these three tiers and now i want
to tell you about a new programming
language we've been working on called
flow log and the first key thing about
flow log is it's what we call a tearless
language so this is an idea that people
have tried in some other domains it's
been tried in the web and it's usually a
complete failure and it's a failure
because nobody knows how to generate you
know user interface code from a tearless
programming language we don't have that
problem as I just explained we don't
have to worry about generating you I
what happens on the switches is really
dumb and it's completely within the
logic of the program there's no UI and
weird complications like that there's no
jquery and things like that to worry
about
so it's a tearless programming language
which means you program you write a
program as if it's running on the
central controller and the other parts
are generated for you by compilers okay
so in particular there's a sophisticated
compiler that's going to generate code
for you and the more important things I
could spend a lot of time talking about
the compiler which is interesting in its
own right there's some good partial
evaluation going on underneath but the
more interesting thing is that we have
crossed to your reasoning support so I'm
going to give you a little bit of a
sense in the rest of this talk about how
flow log works I'm going to show you a
small program so just to give you a
flavor feel for the flavor of the
language but then I want to talk more
about program reasoning because I think
that's the really cool thing here okay
good so again remember you can interrupt
me questions you're all nodding which is
a bad sign okay too much not good
somebody not nodding for a change so if
you are verifying the generated so
suppose you have to verify a property
for the generated code God there will be
an equivalent property in the program
generating yeah yeah yeah so the thing
is um where's the nearest white board I
can use yeah can somebody throw toss me
a marker please oh great thank you so
let's just say that we've got you know
we've got some C sharp program over here
that's running on the server okay and
there's a switch here and floor rules
are going to be generated to the switch
okay so the structure of this so you're
right certainly I can look at a set of
flow rules and use a flow rules verifier
for that there aren't very many yet but
that's because the stay is in its
infancy but you can assume that there
will be pretty sophisticated verifiers
at this level okay but the problem is
this thing is generating new floor rules
sometimes every second okay so which
floor rules are you're going to look at
I mean it's constantly updating because
it gets new packets and it says in
response to this packet Oh
somebody just started watching a movie
Oh somebody just left the room oh this
thing happened oh that thing happened
right this constant traffic are they're
under attack where a new attack just
started up right so it's constant
traffic on the network in response to
which new sets of flow rules are
constantly being generated so you can't
really talk about it is actually an
interesting contrast again with this
sort of JavaScript world where the code
do you generate tends to be somewhat
static right i mean you import a bunch
of jquery libraries you generate some
code there might be some small changes
but by and large the code you're
generating is pretty static here it's
very very dynamic so it's not very
effective to look at the flow rules and
try to do the verification at that level
you want to do it at this level but now
this thing is no longer just c sharp
code right it's c-sharp code that you
know Anna in a very naive sense is
probably doing this right it's got a
bunch of printf statements effectively
morally the coal and a bunch of printf
statements that are generating floor
rules right then it might even be you
know you know dynamically generated
strings that it's generating right and
that is what you have to somehow make
sense set up that's the part that's
tricky so make sense that's a really
good question but hopefully that answers
the question okay good yes of course the
docket so us to develop takes over as
well great question great question so um
we are actively designing the language
so that it can it we don't want to
assume it will take over the network
okay we don't yet have a good interface
specification for the problem is we want
we have we want to be modular but to be
marginally we need interfaces and the
networking world is not there yet to
talk about what those interfaces might
look like but we're very careful to as
much as possible not assume we know the
whole world okay but it's a subtle
question right because but but yeah we
don't want to assume that where there
will only be flow log in the world and
no other traffic and we'll get to see
everything that that would be on
unreasonable the thing to do is if
there's independent traffic of course it
doesn't matter right it's when there's
somewhat dependent traffic then you need
interface specifications to talk about
what things you will touch on what
things you won't touch and which
programs like if your program that's
counting
every packet in the network well that
programs not going to work anymore right
but a program that's doing something
that can assume that some traffic it
doesn't see well that's that's okay
right so I think that's a very
interesting language design question
we're not quite there yet because the
whole community is sort of slowly
getting to that point okay all these
small these modularity questions are
very pressing and not yet yeah good
other questions great okay so let me
show you a little bit of flow lock code
let's do a net okay let's write some
code for a net so I'm going to walk
through this code line by line thing to
understand is you you can think of flow
log if you've ever seen a language like
prologue or data log or something like
that before the name is meant to be
suggestive use your intuition okay so
the idea is we have relational programs
so here is a table it's an at table and
it's recording what is being nakid to
what right what what's the incoming
traffic and what's the new name for the
outgoing traffic that's basically what
that means I have a variable that tells
me what the next freeport is and now
when a packet comes in I look to see
whether the packet is already in the nat
table whether that that source address
is already in the net table if it
matches that means it's a it's a floor
I've already established if not write
the negation of that that means it's a
new floor and I need to create a new nat
for it okay so if it's an existing flow
what am I going to do I'm going to
forward the new new new packet I'm going
to forward the packet to the net port
I've already recorded in the table if
it's a new flow i'm going to do the same
thing except i'm also going to add the
next port to the net table and i'm going
to increment next point okay so well
more or less the definition of an act
okay one direction of a net and that's
the whole thing this is actually live
running code it is actually implements
on that and implements a fairly
efficient nap because when it goes
through the compiler it make sure
there's no extra packets being sent and
that the every packet that it needs to
see it'll see and no extra packets get
seen okay so that's a whole working
program so of course there's a whole
system behind it it's implemented a
target on top of a bunch of libraries
this is this product of compiler that I
said that generates packets before
they're essentially generates rules
before they needed which means we can
run
the speed of hardware right whatever the
hardware can do is the speed when we
measure when we benchmark we're as fast
as competing systems because we because
of this product of compilation and it
produces flow tables that are not too
large which is another thing that people
usually care about okay so that's a view
short introduction to the language now I
want to talk about the interesting part
to me which is the reasoning side of it
okay so let's go back to these problems
I talked about before right so the thing
to note is many of these problems just
disappear but if we get inconsistent
packet handling it means there's a bug
in the compiler right it's no longer the
programmers problem to deal with that
just as they currently don't deal with
compiler bugs they report compiler bugs
and compiler bugs get addressed right
failure to notify the compiler affiliate
notified switches too much traffic all
of these things automatically go away
the program generating program goes away
because as I just showed you the code is
tearless it's just written from the
point of view of the controller
generating the code to the backing store
and generating the code that goes down
to the switches is done automatically so
you just don't even write that code
right there are no printf statements and
the code that I just showed you him and
now this part is interesting because we
still have a full-blown programming
language the experiment we're doing is
which we are limiting flow log to be non
recursive data log so this is a weaker
sub turing-complete language it gives us
some very interesting useful properties
in terms of decidability and we're
trying to see it's really when I say
experiment I really mean the word
experiment we are trying to see how far
we can push it how many different
networking protocols and how many
different networking applications we can
write in this weaker language now maybe
three years from now we'll say yeah this
is the limitation and we can't get past
this so we have to fix the language or
maybe not I don't know okay so with
these kinds of stupid errors out of the
way now we can talk about course we're
still going to make errors but now we
get to system specific errors right for
a particular application what kinds of
errors can I make and there's all sorts
of one's right well I have a network
configuration well the web requests get
through can I ever route back to the
loop right this is something that
working people always care about I don't
want to end up sending packages infant
Lou will not be performing all packets
can package etc etc you can you can
imagine a whole bunch of properties like
this yes don't engage in part one
abstention how have you flow up so okay
you have tables yeah so you have a table
okay that is a specification of what
you're backing store looks like
additions to the backing store like over
here on I insert a new row into the
table I insert into net okay that
insertion is stated by the programmer
the actual implementation of that in
terms of sequel statements or whatever
else happens by the compiler but more
importantly the way you write your
program is as if you see every packet
right on TCP packet p right where it
came from this position and you know so
basically like if the packet came over
here I have this cause it says on TCP
packet p so some of some of these are
predefined types like TCP packet but
then you can define your own relations
on top of that okay so you can write new
relations that basically implement
higher levels of functionality so for
example one here's a nice little example
right a i have slides sitting around if
you need to get there but imagine an
application where you register your
laptops with the system but with the
with the campus police or your you know
corporate police right corporate
security and when your laptop is stolen
let's let's just assume you live in a
world where you remember your mac
addresses okay so you call the security
and say this mac address just got stolen
ok so the security staff have a program
that's basically pretending it can read
every TCP packet okay if a TCP packet
that comes in that matches a packet
that's in this table then now it has to
activate it will call the police and say
hey we just located in fact it came from
this base station so maybe it's in that
geographic location of the building or
something like that okay that's the idea
now the thing is we don't want to see
every packet
if we see every packet will never get
anything done right because you want
packets to be handled locally not all of
them coming to the server so in fact
what happens is this code essentially
gets compiled down to work on the
switches meaning the switches see every
packet but in this particular case if
the nat table is not going to be
affected right so the first time you get
a new packet that's not been added
before you have to notify the server it
has to do something with the persistent
state and so on so that's in the new
flow case in the existing flow case
there's no reason the server needs to
see this at all the controller doesn't
need to see this at all ok so what
happens is this code essentially gets
compiled down to the switch and says if
I'm one of these nap things that I've
already seen forward it along in the
following way rewrite the headers and
this way and forward it along and it
simply never even comes to the
controller so the programmer sitting at
the controller has programmed the
starless abstraction which pretends they
see every single packet the compiler
makes sure that the controller sees as
few packets as possible so that's what
we're calling the essence of the
tearless abstraction did that make sense
yeah so the killer's perfect sense ok
you can do it bitch haha so I guess you
have a what yes that part is pics
language so that essentially has gene
you Stephen oh yes yes yes yes yes yes
that is fixed that's fixed and that's
given to us by the sort of SD and
protocols right that's the part we don't
nobody wants to reinvent ok so that part
is fixed in there are the assumption is
there's a stream of packets and every
packet contains some metadata with which
I could make various decisions right ok
and then you program as if you see every
packet good yes one will win this it may
not be that problem but in this whole
pls language it's almost lost what
information gets through the control and
what informations is handled by the
um let's be careful there it's not true
what information the information that's
in the controller is this okay all the
tables that I declare are the
information what packets is lost that's
right that's right that's that's exactly
what you're giving up his knowledge of
which packet comes to the controller
okay now i could imagine that so okay
why is that a problem for example I my
network isn't going as fast as I would
like well one good place to look is
maybe too many packets are coming to the
to the controller okay that's something
that the runtime system can give you so
our runtime system so it's easy to
maintain counters so runtime system can
maintain a counter and give you for
debugging purposes a this is how many
packets came through and you there
that's relative to the total number of
packets that's an absurdly high ratio
what's going on and then we we are we
have some technology with the stuff that
we did for iOS where we could do
something called rule blaming so you can
ask like why is this thing happening
tell me which rules seem to be
responsible for this behavior so the
same technology we have we haven't
applied it here or you could say I'm
getting too many packets and it is like
that rule over there is the thing that's
causing all these packets to happen and
then you can say what is it about the
way I've written this rule that's
causing you know all this good causing
excess traffic so you are you're right
the language does not let you see which
packet came to the controller because it
pretends every single packet did but of
course in practice you don't want that
and that we think of that as a debugging
metadata activity instead so make sense
good of course it's not it's a relation
that's defined in yeah yeah so the thing
was that so how I see this is like
similar aha yeah yeah yeah yeah your
idea of non non recursive data log is
that packet filters are journalism
you don't need full during a freaking
Buddhist right ah so yes yes go on go on
this DCP and everything is these
small obstructions you create me me me
me require cool solo so this is great
yes you're right you can think of this
at a very high level as packet filter is
a perfectly good way to think about it
so I have two responses to that so
recursion is actually interesting so if
you think about like one of the things
that a network needs to do is it needs
to figure out like what all of the
routes are that are available inside a
network and periodically they will send
out like new ARP requests to figure that
out right well so that's well that's
transitive closure transfer closures
recursion right so how do we reconcile
that so it turns out we can actually use
the network to provide us with recursion
I send a packet out right that packets
going to come back to me as a new packet
well that new packet just gave me a loop
that I didn't have to express directly
in the program so it's a little bit of a
fake but it turns out it gets you pretty
far because this kind of transitive
closure is an important part of
networking but the other answer to that
is flow log is so typically when you
have a deal a DSL of some sort you have
some great big in our turing-complete
language and then in the middle of it
you're allowed to put like my sub
turing-complete pieces right this is I
don't know sequel and this is you know
some selector language or something like
that you have these little raisins of
sub Turing completeness inside we're
looking at flow log differently we're
saying look Flo log is this big is this
language that is not your incomplete but
we have an explicitly defined call out
mechanism ok with it with typed
interfaces for call outs so you can call
it you could say look I've already got
some Java code that implements some
routing package from a routing algorithm
it would make no sense for me to
re-implement that inflow log so you can
call out to these things the interfaces
you expose a table to them they populate
the table and give you back the table
and then there's some work about what
table means for these programs and so
we're doing essentially inverting the
standard picture right so when you need
to get to those big computations that
our algorithms that have probably you
know probably this is not the right
language for you call out you have to
provide a speck of what that's doing so
that the verifier can use it that's the
trade-off
that make sense great these are like
user different functions in it yeah yeah
yeah exactly that's exactly the
intuition well it depends on what you
need a spec as much as the verification
you're trying to do needs right so you
know that's that's that's the usual
trade-off yeah yeah but it's very much
you would sequel is a good intuition for
what we're trying to do and those are
those are stored procedures in sequel
right like that yeah okay good all right
questions answered great okay so um so
we were talking about some kinds of
properties right and what I want to note
is that I've actually written I've
written for properties on the screen but
there are two sets of two very different
kinds of properties the first two are
about my network which means you can't
reason about this without knowing the
actual layout of the network right so
this is topology dependent reasoning its
network dependent reasoning right and I
mean the thing is when you start doing
network to parent reasoning well a you
need a statement about the network and
this is where things like you know state
explosion tend to become a bit of a
problem and so we don't have an
interesting story here we have we've
been using spin for model checking these
kinds of properties you give it the
state the topology as an input and then
you go off and do sort of usual model
checking this is an interesting question
it's not where we've put our emphasis in
so I will leave this as sort of an open
question for people who want to think
about this and think they have some good
tools for doing this kind of reasoning
because we're trying to do the other
kind of reasoning which is when you get
to these kinds of properties they don't
say anything about the network so if
they notice statement about the network
what are they estate and about but the
program they're just program reasoning
right so there's a whole bunch of
network agnostic reasoning that says I
have a controller program and no matter
how many nodes come and go and no matter
what the shape of the topology is I want
to know that this program has the
following behavior right and that's just
back to good old program reasoning and
there are many properties that fall into
this kind of category right so this is
where our emphasis has been so we will
take out that first property here and
observe something interesting about it
so what do I say i've got some
controller
and it replies to our request for
addresses that it's cash so if you don't
know what ARP is don't don't worry about
the details the point is that this is
the kind of property you might want to
verify about an art right and I'm going
to color code it and you notice that the
the caching is a statement about the
database the requests are a statement
about what the forwarding rules are
doing and the controller will reply is a
statement about what the control logic
is going to do right so because i have
this tearless abstraction i can steep
these kinds of properties very naturally
even though they cut across all the
three tiers if I did not have a tearless
I can still state a property right I
mean anyone can state a property but to
verify this property when I've got some
of the some of the property is a
statement about what that component
string is going to be doing good luck
with that right so this is where this
idea that will write the program as if
we're just sitting and seeing every
packet gives us a huge amount of power
right because this kinds of properties
are much easier to discharge over this
sort of packet filtering model and many
properties have this kinds of
characteristic where they have they
really talk about two or even three
tiers at a time ok so the way we do our
verification is actually pretty
straightforward these are you know this
is this is basically a subset language
of first-order logic so you can compile
it down into multi sorted first-order
logic there's a tool called alloy which
takes first order logic and turns into
sap problems but there's one key problem
with alloy which is you because first
order logic is undecidable well most of
the things you care about are not
decidable you have to specify domain
bound sizes but most of the things we
care about inflow log have a particular
quantifier structure that's a sub
language of first-order logic called
effectively propositional first-order
logic and there's a beautiful theorem
from the linking 20s actually that will
basically construct a domain bound for
you that's a sufficient domain bound so
you can get sound and complete
verification even though you're using
sub force or logic because you're using
the sub language okay and we have an
extension to this sub language that
basically deals with multi sordidness
and so we can get sort of even more
bounce for even more kinds of
grams okay yeah yeah so once you start
adding more yeah so so there's now some
results we're finding that it not
general recursion but if you're a
transitive closure you can get back some
bounds and things like that but yeah if
you want that's one of the reasons why
we keep the language week to see how far
we can go right so you know the
verification times are actually quite
small because we you know these these
times are pretty robust because they are
statements about the program they are
not statements about the system that's
running right adding more nodes is not
going to make any difference to this
whatsoever so examples counter eggsy
know either verifying are finding
counter examples and nice thing about
using alloy is it also gives you these
little pictures that show you like
counter examples the reason we're able
to get small pictures like this is we
have we've done a bunch of independent
work on minimizing scenarios so taking
first order logic solutions minimizing
them and giving you a principled way of
stepping through them showing you in
terms of entailments even though the
provenance of individual facts like why
is this fact in this model and we can
give you a provenance for why that fact
is there so this is work that we're
being able to slap on to this so we can
actually give people like nice counter
examples okay um I want to talk about
two particular kinds of properties that
show up in practice that are really that
we can do a lot of good stuff with one
is what we call inductive properties so
take the NAT again right remember
there's this NAT table and the nav table
was basically an injective partial
function right that's the state of that
table and what you want to know is if
started off being a well-formed table
after a packet arrives it's still going
to be a well-formed table because one of
two things happens right either the
packet arrives and it's known so the pad
table doesn't change all the packet
arrives we add something new and you
want to make sure that this injector
partial function property is maintained
right so you want this property you want
this to be a statement about the program
what we do is we use flow log to verify
the stepwise property right using the
verification technology I just told you
the initial state is pretty easy to
verify and essentially we do the
inductive step outside the tools so
there's no tool that does the induction
for us but that just follows because
we've got the base case
the inductive case and just by you know
the laws of induction we get the
inductive property for the program which
is actually a nice way to split the
problem apart because it means we don't
need a prove or that's strong enough
prove induction because then you have to
go into theorem prover land and things
start to get more complicated another
kind of pair of properties that I found
very interesting is the following so
here's a statement if the table is
consistent so consistent meaning roughly
inject a partial function before the
packet arrives it will be afterward
right that's the statement about the
preservation of the state of that table
the other one is if you have a
consistent table either it'll forward or
it's going to signal an out of you know
basically I've run out of ports right
that's always the possible runtime
exception otherwise it's going to
forward so that's the statement that if
you have a consistent property then you
are going to make progress the program
is going to actually do something good
well this progress preservation we
already know this is a classic structure
right types on these theorems have been
doing this kind of thing for a long time
so essentially this progress and
preservation each of which we can prove
using our alloy infrastructure basically
gives us a kind of soundness theorem for
an act so this is something we've
started to explore because people don't
usually think of network protocols as
having some nice things in the sense
that a type system does and we're
starting to explore this question about
how many of these protocols can be
broken up in this way and we can
actually verify some sort of notion of
soundness for them ok one last thing I
want to talk about is property free
reasoning right we're all sitting here
you know either PhDs or soon-to-be PhDs
or long time PhDs or whatever and so you
know you want logic statements you go to
Cedric and you'll throw more logic at
you that you can possibly count average
developers aren't trained in logic don't
care about logic right what they want to
know is they want some they want to know
something about the working pneus or
non-working pneus of that program
without having to go through the
rigmarole of formal properties
statements and in particular verifiers
are kind of useless because without a
property they just sit there they don't
actually do anything right even Cedric's
verifiers just kind of sit there with
our property statements so there's a
very useful kind of property free
reasoning that developers care about
just simply comparing the behavior of
multiple versions of a program right
this is in fact what we all actually do
in the writing code we have a program
that works right for some definition of
works and then either we change do a bug
fix or we get some new feature and now
we have a new program and what we want
to know is we want to transfer the feet
we had in the old program into some
sense of security about the new program
right it's about transference of
knowledge which means you can think of
this as a comparison between those two
programs what changed between the two
but of course what we care about is
semantic difference not syntactic
different it's intact differences that's
get will give you that right we care
about the semantic difference and once
you have this you can do a bunch of
things like you'd say look I've got two
possible configurations for my system
which one should i use or i've made an
upgrade is the upgrade doing exactly
what I thought meaning it's doing the
things i wanted but also it's not doing
the things i didn't want this is the
thing that humans are really bad at
thinking about right think about when
you write code you add a new feature you
write tests for that feature you don't
write tests for all the things that
you're expected to not happen as well
we're really bad about this kind of
reasoning you might want to know about
hot spots right we talked about blaming
particular rules like I made a small
change I expected to see a small
semantic difference I got a large
semantic difference what changed that's
causing a large semantic difference
sometimes you refactor the code you just
clean up the program well the behavioral
difference between those two versions
had better be zero the syntactic
difference might be large but the
behavioral difference had better be zero
and so there are all these kinds of what
if questions you want to ask and we did
this in the previous version also for
iOS policies and somebody found another
use for it that we had not anticipated
which is mutation testing because when
you do mutation testing remember what
you do is you mutate the program and you
want to make sure that you have a true
mutant a true mutant is one that is
semantically different because you might
make a mutation and it action actually
change the behavior so if you have a
quick procedure for checking that
something is semantically different well
now you can actually do mutation testing
that's the Oracle you need for mutation
testing okay so this is the other thing
we've been building for flow log on so
you can take two programs and again
use this alloy procedure basically what
it will spit out for you is in what
scenarios right remember it's
constructing first-order models so
basically it's giving concrete scenarios
in which the two programs will divergent
behavior so on this kind of input packet
it's going to do this on this kind of
seem kind of input packet it's good the
other versions going to do that you can
also ask in what scenarios will the
program transition to different states
and again this also works very quickly
this is another thing that gets to
exploit that varnish on Finkle theorem
because all of these property statements
in this change impact all fall into that
class again okay so last thing I want to
talk there for just about one minute is
talk about this transition from mere
from just SD ends to Internet of Things
and so one of the things as you all know
it's happening is we have these switches
but we also now start having smart
devices and I think one thing that's
becoming especially interesting is this
until recently configuring these
networks was these networks of Internet
of Things was just as nightmare right
you go to run cable you've gotta like
you know serial port and then set this
up and install a driver and maybe it
works and maybe it doesn't and now
there's a whole new generation of
Internet of Things devices that are
being that are coming out that are
basically web addressable I don't know
is anyone here played with these by the
way wherever addressable which which
systems have you tried haha ok these are
all
Wi-Fi yeah yeah right exactly so give
you like a restful interface that sort
of thing yeah yeah okay okay yeah so
this is something we're noticing in the
US as well as bunch of these startups
that are not producing basically restful
api s for being able to talk to these
devices right so now the whole
configuration nightmare is mostly gone
right I mean it's it's kind of ironic
right i I'm sitting here on my laptop
the device is over here the way I
communicate with it does go over to
california and back but you know that's
that's the nature of the world i guess
so you know you read all these lights
and cameras whatnot and now you can you
can have an SDN style controller here
which basically again gives you a
tearless abstraction for programming on
these devices right so we've been taking
flow log and translating it to also work
over these kinds of device networks so
you can do things like this right when I
detect a motion so now this is a domain
specific type right so if I have a
motion sensor it provides motion
detection tuples and I might have camera
on tuples and so on right for each kind
of device and so when I detect a motion
maybe I'll turn the camera on and i'll
either reset the timer all started with
a camera ID at some time or of say five
seconds and when the timer expires i'm
going to turn the camera off right so
every time I see a motion I'll run the
camera for at least five more seconds
right that sort of program so we've been
starting to play with flow log this is
again actual live code that runs right
now using a system called spark iOS our
back-end there's a lot of interesting
new challenges here first of all these
things are now hydrogenous devices right
it's actually the case even in the SDN
world people don't like academics don't
really like to talk about it but the SDN
networks are also heterogeneous because
you have wrought you have these dumb
switches but you also have various kinds
of middleboxes but here you really
cannot ignore the heterogeneity a light
is not the same as a camera is not the
same as a motion sensor at all the other
thing is in the SDN world the idea is
that you won't have much computation
running on the switches right they're
going to be very dumb they're just going
to have some routing circuitry and
that's about it like small fast but here
these are all basically all Arduino
chips now so you can take some
computation that used to run on the
server and
truly honestly offloaded onto the client
and which means there is now interesting
policy questions right how do I decide
what computation should run where
basically there's trade-offs based on
power of the amount of communication
bandwidth maybe the physical location
maybe the robustness of storage of that
location and so on we would like to
think of this as an opportunity to again
program in a careless way and have even
smarter compilers that can take these
kinds of policy issues and use the
policies as a way of figuring out how to
generate code for each of these switches
which are now IOT devices and I think
one of the things we're also going to
see is a convergence between sort of
this sdn style programming and IOT
programming because you're going to want
you know it well letÃ­s some people I
guess they're going to want situations
where you know if I start if I sit down
on my couch I want the lights to go down
and I want netflix to come on or if i
start up netflix i automatically want
the room's ambient temperature to change
i want the lights to change and so the
network traffic and the IOT traffic are
going to be talking to each other
because each one is going to be telling
the other thing something about the
decisions that are being made in a
physical space right so I think this
were partly what we're trying to do is
to position flow log is a language where
we can have all of these converging of
course you know I don't expect any one's
going to program their house using data
log variant we're also exploring some
block-based interesting syntactic design
questions for how to design using some
HCI research how to design an
interesting interface to program these
but ultimately at the bottom of course
they'll be flow log we just won't
present it the user that way so you
could also have many different
applications
that's right that's exactly right that's
exactly right this is star I mean we've
talked about this a little bit in the in
the network space it's not quite
happened yet but it's very clear that
just as the cloud you know you have a
cloud box that's running all these
different applications right multiple
tenants the same thing is also going to
be happening on sdn controllers and
you're going to have lots of different
protocols and you know like I described
the stolen laptop device manager right
that's a program that you want running
on your controller that's independent of
the fact you also want not running on
your controller neither one should be
knocking out the other so what is the
right what are the forms of composition
so need foster &amp;amp; Company been thinking
quite a bit about like composition
operators but I would claim at a lower
level I'm more interested in the
application level compositions because
you know the issue here is not going to
be at these two sequentially composed or
parallel decomposed it's going to be
more what is the interface that this
thing wants or I did want certain kinds
of packets what end it'sit's iio
specifications once these kinds of
packets on is going to impact those
kinds of devices this thing once these
kinds of packets going to import import
impact those kinds of devices and how do
these interfaces match up against each
other are they in conflict or are they
in harmony right and if they are in
conflict even how do I get them to
override which one gets to override the
other I think those are the high level
in the composition questions that are
absolutely about to happen and the same
thing is going to happen here too right
once you know throw IOT devices I've got
you know my home router is at one I've
got this box maybe right little server
running in my house that is both my
intrusion detection server to make sure
that my house network is not under track
but at the same time is also controlling
all the lights and sensors in my house
and how do these things work together
well that's and it's going to be a
really fun set of questions to think
about you know many years ago people we
and some other people spend a lot of
time thing about this feature oriented
software composition it software as a
collection of features and how do these
interact with each other I think all
these questions are just going to come
right back now so so I think this out of
me this this idea of thinking of this as
a tearless abstraction Nick otherwise I
just don't even know how to begin to
have a handle on the amount of
complexity that's going to be in these
systems but at least that
me I don't maybe other people are
smarter than deal it's kind of
complexity other questions so if you're
going to try the system so in develop
you add the new bugs or you jump on of
you have to visit Stan do you expect the
plan to children to believe I no no no
so it simply reacts it simply react so
they are the new netbooks what so I
sorry should be a little careful with
that right it depends on how much the
program refers to particular devices but
the point is the protea yeah yeah so so
your position developers yeah yeah so I
mean it's still the case that in some
sense the program doesn't get recompile
the program is a fixed entity and may be
you know it has a rule that says if this
particular mac address comes online and
I happen to know that that mac address
corresponds to you know Rama's laptop
right so if that mac address comes
online behave in the following way the
program is still fixed right the policy
that's a statement of policy and the
policy is fixed but now the behavior of
that policy changes because of the
dynamics and the network right the
laptop comes online it registers itself
it you know contacts the base station
base station falls is back in and says
oh oh i just got a packet from this MAC
address that means Rama's laptop is now
there right now I have to behave in this
completely different way so it's a
static policy with dynamic consequences
right so the program if you think of the
program is a policy it doesn't change
its the consequences of the policy that
change based on the dynamic state of the
network yeah yeah yeah yeah yeah yeahs
know if you choose to change the policy
well of course you're free to do that
right now you want to add another rules
as subjects laptop well now that's a
change in the program but otherwise your
program can even refer to very specific
devices but there's no reason for any
recompilation or anything else right it
just detects the event and says ah new
for new things online yeah okay good all
right thank you very much thank you for
coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>