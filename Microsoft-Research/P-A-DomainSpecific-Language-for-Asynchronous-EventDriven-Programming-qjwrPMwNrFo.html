<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>P: A Domain-Specific Language for Asynchronous Event-Driven Programming | Coder Coacher - Coaching Coders</title><meta content="P: A Domain-Specific Language for Asynchronous Event-Driven Programming - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>P: A Domain-Specific Language for Asynchronous Event-Driven Programming</b></h2><h5 class="post__date">2016-06-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/qjwrPMwNrFo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
so it's likely to be here the first time
in the new building fantastic digs you
got over here so I'm going to tell you
about the project this project it's on a
domain-specific language called P and
the word p is for protocols so when we
build a synchronous event-driven
programs then protocols usually end up
being part of the programming because of
all these components that are
interacting asynchronously with each
other this kind of programming is very
important these days because in the
world in the world of devices and
services so when you have devices and
services talking to each other can
everybody hear me at the back also
usually you can't do synchronous
invocation so what is the classic
example of synchronous invocation is a
procedure call in an imperative language
like C so where the caller eights until
the call returns and then the results
are available to it so if for example
device is talking to a service across
the wire usually it can't afford to wait
for it so for performance reasons you
have to do overlapped execution so the
standard model of communication is VI
events so these components and events to
each other and the responses come back
VI events also so it is well known that
this kind of programming is much harder
than ordinary sequential programming so
when you have overlap computation
overlapped concurrent asynchronous
computation you get bugs because of
timing and these bugs are very very hard
to reproduce and fix the standard
debugging experience that we have come
to expect when we are debugging a
sequential application and say visual
studio where you can set breakpoints and
you can have a full repro if you have
established the input that causes a
failure that kind of debugging
experience you just don't get anymore
because we don't really
have control in the live execution over
all the sources of and non determinism
and concurrency that can happen so as a
result all these the kind of bugs that
happen they're very very difficult to to
fix so these problems are not really new
problems we have been aware of these
problems for decades and even inside MSR
backbench shriram was in was working in
redmond many years ago we started a
project called zing so the goal of the
zing project is basically I have lifted
it verbatim from the web page of the
design project this is what we were
trying to do ten years ago and if you
read it it looks like a very modern
project also these are all problems that
exist today and we build this kind of
infrastructure for exploring the states
of these asynchronous model so the idea
was that there's all these protocols
sitting in applications so we will
provide people with a zing modeling
language where they write down the the
model in the in the modern language and
we will explore all the executions and
we'll give them bugs they fix those bugs
ultimately the model becomes correct and
then they'll go and implement it in code
so we build all this and we were
expecting you know lots of accolades and
bonus and promotions and those kinds of
things but nothing like that happened we
didn't get a single user and we I mean I
guess you know this was not in used to
it was news to me at that time but I
guess this is like also another age-old
problem this is the problem the modeling
conundrum so when you when you go and
ask a programmer hey why don't you use
zing you say what what do I have to do I
have to go write a model in zing why
would I do that I'm going to go ship go
that's what I'm hate to do why would I
go and write this model in yours
modern language why don't you just use
my code instead that's the model yeah
that should work and 11 actually you
know these things are kind of bogus but
this is the real argument I think this
is the main reason why programmers hate
to a separate modeling exercise that is
not connected to do code which is that
these models get out of sync with code
it almost never happens that all the
design decisions get taken inside the
model usually these things get refined
later and the requirements change and so
on and so forth so the model gets out of
sync and at some point this this model
is basically obsolete and loses all
connection with code so in the P project
we are trying to remove this fundamental
blockage to adoption of high-level
modeling and testing that we believe can
dramatically improve programmer
productivity and we are going to
accomplish that by blurring the
distinction between modeling and
programming the way we do that is that
we provide people a domain-specific
language and we give them both modeling
and testing at the level of that
language and also cogeneration so that
what gets executed in the in a live
execution rate is exactly what they're
modeling so this problem of two
different representations of your
behavior that the just vanishes so we
have had more success with this story
now so in fact there are two shipping
products that that have been developed
using using P the USB device driver that
runs on this Windows 8 machine and that
has been recently unified after we
became one Microsoft we decided to unify
the the USB device driver stack across
phone and desktop and both of them are
implemented in p
okay so first I want to give some credit
so this project is actually is about
three years old and it has been done in
collaboration with many people both here
in in banglore so Shri Ram has been
involved in the project and in redmond
Ethan Jackson my colleague and Rhys is
involved in it and then there's people
in in the in product group so these two
engineers this is Randy all and vivek
gupta they were the early adopters and
in fact the co.design the very first
version of p and also you might some of
you might remember ankush this I he was
a researcher here young researcher here
and since then he's he has moved to
Berkeley to do a PhD so these guys are
proudly standing in front of their state
diagram so the relevance of these state
diagrams I will explain later what does
we have to do with the state diagrams so
some stats from from the old effort of
the developing the USB device driver
stack in Windows 8 I don't have any
stats for the Windows Phone i stopped
keeping track of all that once the value
became abundantly clear so what you're
seeing here is some idea of the size of
the design that was implemented in in P
so P as I will explain later it is a
it's a language in which you can have
macro States and transitions together
with code annotating states and
transitions and so on so some idea of
the size of the design can be obtained
by looking at the number of states and
number of transitions you can think of
this as the semicolon count of
traditional programming language like
how much sequencing there is but unlike
traditional languages you know like so
if you have like 500 lines of code or
two thousand lines of code that my you
might think of as a small program but
remember that this is a DSL for only
protocols and if you have two thousand
lines of protocol that's a very big
design because there's a lot of you can
pack a lot of complexity into into a
very short description
okay so these are all significant
designs the the hub driver was built out
of interacting state machines for
different kinds so these are the four
rows and on this side tells you the the
bugs that were discovered so a total of
more than 300 bugs were discovered
during the during the exercise but you
can't really I mean the thing is that
they were keeping the programmers were
keeping track of this because this was
something like a skunk works project
ultimately they knew they had to justify
this to their do their managers that's
why they were keeping track of it but
for example this the experience that you
get is that is the case same kind of
experience when you build a program in
in visual studio right a bit like that
you don't keep climbing you finding bugs
and fixing them all the time that's the
beauty right when you when you when this
thing is rolled into programming it
doesn't look like a one bug you know I
spent like an entire day trying to fix a
bug these bugs are found and fixed
pretty rapidly okay so another
interesting thing is that these bugs
were found before they had code running
on the on the machine which is also very
nice yes no they would there they are
pretty much related to interaction
between various state machines years but
actually essentially just a missing yes
sir so the thing is that this is the
thing you can't tell right because this
is we're programming right now right
nothing is running so I was the
definition yeah so the bug would either
be so what is it what the way the way it
works is that you write down the
protocol definition and then you write a
whole bunch of specifications on it and
then there's a whole bunch of implicit
specifications that get just from
programming in P like the the analog
would be you know like if you're
programming in C sharp you get now the
reference exception or a
classcastexception so there's a bunch of
default specifications like that and
then there's a whole bunch of
specifications you right on top so each
one of these bugs is a violation of some
such specification now it could mean
that there's a bug in the code but it
can also mean that your understanding
was wrong and you wrote the wrong
specification that's also counted as a
bug no not yet so so the issue is that
as I'll explain later there's a bunch of
static analysis that happens but that's
kind of simple-minded all the fancy
concurrency related stuff we only do
testing right now it's very expensive
because of the combinatorial nature of
the behaviors we are doing systematic
enumeration of the behaviors and we we
put in a lot of effort into prioritizing
the enumeration in such a way that you
don't have to wait too long to find bugs
right and there's many things you can do
we have invent and then investigated
lots of heuristics for doing prioritized
search but ultimately you don't get the
kind of instantaneous compiler that kind
of thing that you that you got I mean
you can fix a little bit of that by
having different modes I mean basically
we can test as much as you want so we
can have you can impose bounds right you
know we test only for sat 30 seconds
before we stop and you can start I mean
and then you you do longer runs when you
when you're doing overnight and things
like that but we haven't engineered it
to that extent yet was wrong
yeah at that point people don't care so
much my feeling is that if you are doing
it like this you just getting the spec
wrong you would take it as seriously as
getting the code wrong because what
happens is that you when you're coding
you're right you are doing that coding
and there's an expectation of what the
environment is supposed to do what the
code is supposed to do and if you get an
expectation of all that you consider
that very seriously also no I mean we'll
have to go and look back at all those
those things yeah okay all right so so
getting into the programming model a
little bit so this is very classical
communicating state machines state
machines interpreted very loosely these
are not finite state machines and these
queues are not necessarily finite so
this is essentially a Turing complete
model but at a high level it looks like
state machines that are sending events
to each other and all the state machines
are running concurrently okay
ok so this details of course you know
that was just the computation model from
there to a programming language you have
to decide a whole bunch of things you
know like concrete syntax semantics how
do you write specifications how do you
test in verify programs how do you
compile these programs for efficient
execution and so on so I'll try to touch
upon all of those things now so at a top
level a P program is a collection of
event declarations these are going to be
the parameters that will be used for
communicating among machines so each
event declaration has a type associated
with it so when you when an event E is
sent from one machine to another a
payload can accompany it so the event he
has a type T associated with it then you
can attach a payload of type T do it ok
and then there's a collection of machine
types so these are templates and to
create an instance of a machine you do
the equivalent of new in NC sharp and
fresh machine with its own state and its
own input queue comes up and starts
execution inside a machine at a macro
level you have these states and these
transitions but inside each state there
is a lot of control flow happening and
basically we have variables and you can
write computation inside the state that
manipulates those variables and can you
can also send events and you can you
have a stack so you can do the
equivalent of push pushing something on
a stack like a function call so we have
a lot of mechanisms for trying to write
down these what what essentially amount
to large go to programs in a compact way
yes that's the semantics and this one
event at a time that's right so the
execution models that one event is DQ'd
according to some DQ logic from the
input queue and then the handler for it
execute that handler is going to
potentially update the local variables
and send other events out and then
eventually go and again try to DQ
something from from a machine for me
from the input queue each machine is one
queue so the there's like in PI calculus
you have explicit channels right so here
we don't have that the channel ID the
input channel of a machine it has the
same ideas the machine idea so you send
an event to that machine and it just
gets include in there so it's more like
the actor model yes so we don't have a
notion of priority in a very very early
version like- version- one of p the
vacant Randy had introduced some motion
of priority but things were from a
semantic standpoint they were getting so
complicated that at some point it was
dropped and we have something simpler
more general in fact which surprises for
for the for these designs and I'll
explain that in a minute oh okay so
actually I can I can go over that right
now so we have the notion of deferred
events in a state so supposing you
wanted to give higher priority higher
priority to event a as opposed to event
B meaning that if a and B are both in
the queue you would rather handle a then
B then you differ be
inside that state you can you can write
that annotation there so the logic the
DQ logic is that started looking from
the front of the queue for the first non
deferred event and then u DQ it and if
UD u you can write in the state differ e
but if you want to qualify that
expression no it's a static constant oh
so you are saying that can you you can
yeah so that the fur thing is not an
expression it has to be a static
constant but in general we have you can
store event IDs in variables you can do
that except that today we don't allow
deferred annotation to be non constant
so this is this is useful because
sometimes you don't want to start a new
transaction you're waiting for an event
that is going to complete whatever
activity you had started earlier so you
temporarily block the starting of new
activity and that simplifies your
control logic and that might be okay the
activity this other activity that you
are is that the thing that you're
waiting for right it's going to arrive
soon so so sometimes you you make that
trade-off and sometimes if you don't
wanna make that trade-off you want to be
really responsive then you choose not to
differ but then yeah you have to be
prepared to handle both things and then
you get into this kind of explosion in
your state and so on yeah
not at the level of implementation but
at the level of lightness checking we
also have lightness monitor in the
language I can explain that later so we
do it we check likeness properties under
fair scheduling of all the machines and
we also have ok so for modeling purposes
when we are writing test harnesses or
models of what the environment of a
particular component can do then for
modeling purposes we provide this non
deterministic choose operator so for
example you can say hey if star e then
you can send event e one else you can
send event e 2 right so this creates a
non-deterministic test harness so in
addition to this non deterministic
choice we also have a fair non
deterministic choice actually this is
called dollar and this is called double
dollar so this non deterministic choice
means that you can create an infinite
execution with which this always
evaluates to true or always evaluates to
false if you use instead double dollar
then that means it's going to be fair so
you will not have infinitely all the
time true or all the time forms and so
sometimes you know these kinds of things
might be useful and coming but this is
relevant only when you're doing
lightness checking otherwise it doesn't
matter ok so for control flow inside a
state well so what I what i'm doing here
is i'm trying to give you an idea that
when i use the word state it's a little
bit of a misnomer because these are
macro states it's not that a state is
just one counter right this control for
even inside the state so and so on each
macro state gets broken up into these
little control locations so when you
enter a state you're right here and then
you execute the entry statement
which is a piece of code that you write
in the state and that does all the
standard stuff you know computing on the
variables sending events and so on and
so forth and then there's this event
driven loop so you can install actions
insight on an event and if that event is
be cute from the from the input queue
then you execute the action which will
be some code like this and then you come
back and wait again what control doesn't
leave the state and at some point maybe
u DQ an event for which there is an
outgoing transition from the macro state
in with in which case you execute the
exit statement and then you go to the
next state which will again look like
this in the next state okay this is a
visual representation of a controller
for an elevator door for an elevator we
have textual syntax but we also have a
tool to visualize that that shows syntax
has this kind of a state transition
diagram and programmers seem to want
this and not surprising because I mean
these are large go to program so you
probably can get some insight by looking
at the controls were of the of the of
the events and what is on which it was
that's right what they use that's right
so earlier in the very in version 0 of
the language drawing a diagram like this
in Visio was the primary means of
creating a P program and the translation
into both for testing purposes into zing
and into C code for execution used to
happen from the metadata of that diagram
but since then we have changed the story
we and create a P program just by
textual editing because it's a very
simple thing we understand how to do it
all the textual different tools work
well source Depot works well everything
is based on
text we still want to provide the
visualization service but that's a pure
visualization service you the current
snapshot of the program is visualized
into this kind of diagram and you can do
whatever you want with it okay so a few
more things here well I can skip over
all that these are more details about
various sorts of features of the of the
language if you are curious i can i can
i can talk with you separately about it
so let's go to specification and
validation the key when you know this is
one of the key reasons why somebody
would want to write part of their
application in p rather than just
writing in c code or C sharp code okay
so so what are the specification
mechanisms first of all we have this
default safety specification that if air
event has been DQ'd in a state then it
must be handled one way or another
either they must be an installed action
to handle it or they must be a
transition that that handles it if not
then an exception of throne and that is
considered a problem okay yeah
I so it's a safety property because it's
are they so there because if we did not
have that differed language feature then
we can never have a lioness problem in
the language because of the semantics
but because we have differed it is not
possible to just block and event and not
have even DQ it because if an event is
deferred right then it's not removed
from the cube if it's not removed it
from the queue then that exception won't
be thrown so because of differed we have
reintroduced the possibility of
lightness figures but the interesting
thing is that by default nothing is
deferred this is extremely important so
if you just forget your handle something
the testing will catch it and then you
either try to handle it or if you choose
to defer it and potentially introduce a
lightness problem and it's right there
in the code okay in addition we have
bounds on queue sizes and on maximum
number of instances on an upper event
basis also so a lot of these systems I
mean the abstraction provided by the
programming model is that of unbounded
cues but that's not realistic right we
cannot do unbounded resource consumption
so programmers typically try to budget
for how much memory is going to be
consumed based on certain estimates of
how fast work is going to flow flow into
the system yeah route
so handled means that either there is an
installed action on the event or there
is an outgoing transition for it it has
a I mean basically to do that very
precisely i would have to tell you more
details about the language features but
yes it is very well defined there's a
formal operational semantics yeah well i
mean there is no shared memory here so
we don't have to worry about all this
Adam icity business the semantics is
that only I mean if you want to think in
terms of threads right then you can
imagine that there is one thread that is
running for a machine it has access to
the local state of the machine and to
the queue so the only shared memory in
the system are the cues so what we
guarantee is that and Q and DQ are sort
of safe operations ok we guarantee that
but once you have DQ'd something right
then there are normal races after that
wait yeah
what events can be dq'd so it's based on
the what is the what is the deferred
annotation in the state so if the event
supposing the in the state it says
deferred jonnie2 then that means that
ignoring state hierarchy and call stacks
and so on it means that we start from
the front of the queue and we look for
the first event that is neither even or
e2 and we DQ it just make sense you will
if you find if you walk through the
queue the first event that is not
deferred you will DQ it and if UD cure
then you have to handle it did I answer
your question couple okay sorry okay so
bounds providing bounds either on a per
cube basis or on a per event basis is
another way of injecting specifications
into the into the code then you can
write custom assertions on the state I
mean you can use we don't have
preconditions and postconditions on
these increased statements exit
statements and so on but you can write
assertions to get the effect of those
things and then we these assertions can
be used to essentially right local
specifications of what's going on inside
a machine but sometimes you may want to
monitor events that happen across
machines so for that we provide monitors
so monitors are these entities that are
sitting sort of like at the top level
they are all the events that are
happening in the system they get
funneled into the monitor and the
monitor can make transitions just like
another state machine based on what it
sees and at some point it can say arrays
of that red flag okay and we have two
kinds of monitors we have safety
monitors and we have likeness
monitors also so you can you can do
lightness checking also so here's some
discussion about environment modeling
which is a thief yes stacia what even if
it's at across the audit users can I
have a
condition deferred kind of same do one
of the series one of the machines I did
not follow the question repeat please so
what are these if you find out money
saying that see a count of event and
even that's what I wanted to see I'm
making across which needs one of the
machines once you initiate based on this
cone no so the monitors the state of the
monitor is not available it's a pure
specification construct when we generate
code for execution monitors are erased
okay so this a dodgy
if you want to have like a shared
counter or something you have to
implement that as a machine so I mean
basically does this say analogy between
shared memory and message passing what
would happen is that if you want
implement a shared counter the value of
the counter is going to be stored inside
a local variable of a machine and the
increment operation would become a
message a decrement operation would
become another message read operation
will become yet another message we have
to do stuff like that yeah as well I
apologize because I know yes yes so
there are this is actually a very long
in this can potentially get into a long
discussion but the short answer is that
consider the special kind of monitor
which is monitoring only events that are
coming from one machine I think it is
dead simple to do exactly what you are
saying which is compile that into core
so you can monitor it but supposing that
there's a monitor that's trying to
monitor events across multiple machines
then there are some that the semantics
of the monitor calls is a little bit
funky it has this Adam icity thing going
on over there so it would be a little
bit hard to implement that I'm not
saying it's impossible but it's not that
straightforward but in politics yeah
that's right that's right yeah okay
alright so environment modeling so I
showed you some code for the elevator
controller okay well i mean this
controller that this code just doesn't
just run by itself it's an open system
it is receiving events from the
environment and it is sending events to
the environment so it is not expected to
work in a completely arbitrary
environment that can supply any event at
any point in time right and what does
this environment look like well I mean
it's probably going to run on some kind
of an art toss right and usually most of
these things depend on timeouts so we
will need an OS timer so this is a
service that is provided by the
operating system so we need some some
abstraction of them of an OS timer
there's a door control of the thing that
is physically moving the door this is
going to be some software running for it
and that's interacting with this guy
I've enpi events so we need a model for
that door okay and then finally there's
the user who's pressing buttons in the
elevator now this is actually unlike
this and this this is a non software
component this is modeling a human being
well in order to really test controller
we need to specify the behavior of this
this and this this is just as important
as writing properties or assertions of
the controller well then p the nice
thing is that the syntax that we use for
specifying code that gets compiled for
execution is exactly the same that is
getting that's used for specifying the
OS timer the user and the door all the
syntactic features that are available
for writing down code for execution
they're also available for modeling what
we do is we provide these little very
simple things like the model keyword
which you attach to the core describe
the environment so that compiler knows
that it needs to be stripped away when
you're generating code for execution but
when we are generating code for a
systematic testing due to zing that
keyword doesn't make a difference for
that it's all is the same thing there's
the point I was just making here's
here's for example a model of a user it
just makes a non-deterministic choice
and sends either the open door event or
the closed door event to the elevator
controller so this shows you an example
of how star gets used and of course the
type checker checks that star can only
be used in model machines and model
functions it's not getting used in real
machines because we can't compile it
okay so okay so we have in addition to
model machines we also have model
functions and the programmer has to
supply a model for it for validation and
an implementation in C for execution so
when we generate code for Percy we make
a step call and the step call has to be
the step function has to be implemented
separately okay so a few words about
validation so I I was earlier saying
that you know this these the be
programmed the Turing complete so
validation of P is undecidable yeah this
problem was the model and thank you very
much so these two can still I was
correct yes it can they can't average
yeah and that's an issue
we we don't have an answer to do this
thing right now one thing is that it can
diverge but I feel like it's a little
bit easier problem to deal with because
a lot of the protocol has already been
lifted out so this divergence is kind of
like the divergence between a sequential
C code and it's sequential spec which is
still a problem but maybe not as severe
as protocol issues it may be possible to
to cross validate the implementation
with respect to the model by injecting
runtime assertions but I don't know yet
how to do that okay so we can't I mean
in the worst case we can't verify p
programs I mean lots of but the things
that you know that what I'm saying here
is just an excuse I mean there's a lot
of undecidable problems right we can't
verify see programs also but they're
still in a lot of tight checking that
flushes I have lots of errors and we do
a little bit of that but I guess I don't
really know what a good egg system would
be that can catch all these concurrency
and asynchrony errors so we just do the
next best thing which is we do
systematic testing of the non-domestic
operational semantics and there are two
sources of non-determinism the explicit
choice that I was showing you there and
the implicit scheduling choice between
that concurrently executing machines and
we systematically enumerate both those
choices so this creates a very large
search space and I mean you have to do a
lot of work but the nice thing is that
we get to reuse a lot of the
infrastructure that was developed
earlier in the same project and we just
had this compiler that compiles down to
zing so there's a trade-off here I mean
the problem we get to reusing we have to
write to compilers we have to maintain
both those codes it would be nice if you
know somehow I can do
zing style systematic testing on the
generated C code itself but that's not
how it is architected today so searching
efficiently we have implemented some
tricks there are simple things like
exploiting commutativity so I'd
mentioned that after an event is DQ'd
there could be a lot of computation on
the variables local to a machine and
then sends to other machines while we in
the theoretically in the operational
semantics there's a scheduling point
after each instruction but we don't
inject scheduling points after a local
computation so only at receives at DQ's
and adsense do we inject scheduling
points and in fact we can based on the
operational semantics of zing we can
even argue that the DQ commutes forward
in time so we don't even have to
introduce a scheduling point after a DQ
then another shreeram how am i doing on
time right now I'm 15 minutes ok all
right then it is well known that if you
are doing systematic search then both
depth-first search and breadth first
search have have problems so depth-first
search the nice thing about depth first
search is very space efficient ok
because the the stack which is you know
the pending work pending search that you
have to do you can maintain it very
compactly using this state Delta
representation so as you make a
transition from on the stack you can
just store what changed ok if you on the
other hand you know breadth-first search
is not very Street State efficient on
the other hand depth-first search has
this problem that for large state spaces
your search and go and get stuck in one
part of the of the state space and then
you know by the time you backtrack maybe
you know years have elapsed and then you
never go over there
first so it gives you good coverage
right so so we try to work around these
kinds of problems by implementing
essentially iterative deepening so
iterative deepening the another
iterative deepening that comes from
classic AI literature is iterative
deepening with the execution depth so
you do depth-first search with a certain
bound on the execution depth and when
that finishes then you increment it and
then when that finishes and you
increment it and so on and so forth so
this way we get the space efficiency of
DFS but we get incremental coverage but
the price we of course pay is that of
redundancy so when we go from say k to k
plus 1 all the work that was done in k
gets repeated or or or we have to either
we do that or we pay the space cost of
maintaining a frontier which is going
again a little bit towards you know the
breadth first search okay so there are
all those kinds of trade-offs so another
thing that we have done is a iterative
deepening with respect to depth is good
for finding shallow box okay bugs that
are hit with a small depth but deeper
bugs it's very hard to hit them i mean
the bug could be conceptually very
shallow you just follow some default
scheduling strategy and then boom
there's an assertion failure right there
but if that happens very deep in the
execution just not going to hit it so
what we have also done here is provided
a general framework for doing iterative
deepening with respect to delaying
schedulers so in the next couple of
slides I want to explain a little bit
about what what that what that is so
this is the standard view of state
transition graphs on which all these
search algorithms are defined so this is
the initial state and then you have a
bunch of a transitions coming out of it
and then you know they lead to stage and
they have a bunch of transitions coming
out and so on and so forth then you can
do dfsdfsdf in the in classic search
algorithm there is no ordering
between these transitions doesn't matter
what order you explore those transitions
in okay so here's an alternative view of
state transition graphs let's try them
to give weights to outgoing transitions
such that the lowest weight is always
zero and weights get incremented by one
okay so we have 0 1 2 up to n minus 1
where n is the number of outgoing
transitions and let's have a strategy a
prioritization strategy where we
prioritize not the depth of the
execution but we prioritize the cost of
the execution so we we say that hey I
want to first generate all schedules
with cos 0 and I want to say all
schedules with costs 1 then all
schedules would cost 2 and so on right
now this is very interesting because
imagine that when we we are say that we
want a generator all scheduled with cots
cost zero well the schedule that goes
along the left branch will will be that
schedule and notice that you can go
arbitrarily deep it doesn't get stopped
anywhere okay so this is the interesting
thing about doing prioritization in this
way you don't artificially block the
execution from making progress okay so
now the question is how do we define
this 0-1 two how do we know which one is
zero which one is one which one is two
so but that our answer is we we have a
deployed deterministic scheduler so
imagine that you take the concurrent
program and you attach a deterministic
scheduler to it so the deterministic
scheduler completely eliminates the
scheduling non determinism so it's going
to take a particular path through the
transition graph and we will call that
path the zero path so the deterministic
scheduler is what the 0 transition is
going to be okay and then what we can do
is we can equip that deterministic
scheduler with a delay operation
he says hey change your default
scheduling strategy so every time you
call that it changes a little bit so now
by mixing up calls to give me the next
task to schedule and calls to delay we
can now systematically generate all
possible schedules and we can come up
with the numbering 012 by saying how
many delay operations are needed to
generate this particular transition okay
so we have implemented a whole bunch of
delaying schedulers and we have
evaluated them on lots of examples from
different sources turns out that of
course you know the ability to find bugs
quickly depends on which particular
deterministic scheduler you are using to
seed the search not surprisingly so this
is well I mean what would be very nice
if there was one scheduler that
uniformly works across the board but
that is very unlikely but still it's not
that bad because what this means is that
we we provide the tester or the
programmer with a way to build custom
search right so the programmer wants to
search in this part of the state where
you just has to write a scheduler we
have a generic scheduling framework it
just plugs that in and then the search
gets orchestrated in that way so we we
actually in this way we have provided a
testing platform that programmers can
use to do to do search in a custom way
if for example they feel that the the
schedule is that we provide is not
giving them good coverage oh and by the
way you know all the stuff that I'm
talking about works both for safety and
lightness and it can be paralyzed on a
multi-core so you get a lot of stuff
okay so now I'm going to conclude that
we're moving to the final part of the
talk I'm going to tell you a little bit
about compiler and runtime okay so
compiler is actually very simple so it
converts the program into a collection
of index tables they are essentially see
data structures
that are erased giant arrays that are
pointing to each other so this is all
the metadata of the of the program all
the events and then the machines and the
state's inside them and transitions and
actions and functions and so on so
that's one part of the cogent and the
second part is all the entry statements
action bodies they get compiled into see
functions okay and then we have written
this runtime which captures essentially
the operational semantics of the P
language that accesses all this metadata
and basically execute the operational
semantics of the of the program so this
is run written once and for all by us
the P developers this is generated by an
automated automated code generation tool
on a per program basis the two together
are linked together with the foreign
code to create the application okay we
can skip all this okay so this is what
application development looks like this
is in the context of driver development
without p so the rewrite the entire
driver in C ok and that's interacting
with the OS and hardware now with when
you have p there's a pee runtime written
once and for all you don't have to write
it again and again there is the P code
and then there is a foreign code or the
C code the P code is going to be
compiled to generate it C code then
these three things linked together are
compile and linked together to create
the driver executable so now we are
trying to also use P to implement fault
tolerant distributed services because
protocols are really important in those
applications also and as far as I can
tell that the debug test challenges for
those protocols are on par perhaps even
worse than what we're facing in the
low-level OS world so I think we can
provide some some value there yeah so we
have made some progress and
we can I can tell you more about it
offline so that concludes my might talk
for like a question you see how easier
difficult of us with them to write
co-sleeper come in today miss having
shared memory do they miss other aspects
so I think that this this business about
missing shared memory in my mind that's
probably the biggest blocker because you
have to really it sort of like
straitjackets you but once you cross
that I think that the separation between
the protocol code and the non protocol
code is very treated in the programmers
head already and writing it in peace in
tax versus C syntax it imposes a little
bit of overhead because now you have to
all the interfaces for the foreign
function and so on have to become
explicit so that's the negative side but
and you know so the positive side is all
the testing that you get so i would say
that from a conceptual standpoint it's
not hard once you have crossed the
shared memory barrier but it's kind of
annoying that you have to do all this
modeling you receive any way
you might want to send events out to
other machines yeah but you still have
your ass back with you and in the
meanwhile you might wanna process other
events yeah so there is parallelism in
the sense that all the machines are
running at the same time so I didn't
talk about it let me just go back to
that slide in the runtime ok so imagine
that there's like three machines that
are running ok so if the environment
outside these three machines it could
happen that one entity in cuse an event
in this machine at the same time as
another entity and Q's an event in this
machine well they're going to say
they're going to start running
concurrently and and doing their
processing so there's parallel ISM there
and yeah I might have an event that NZ
and I have some sleep on which it
operates on then as part of processing
activities and events of poverty yes CD
yes yes when we might like to get other
events yes well operate on the same
state or even on that yes so that that
that is you can around yeah very weird
that's right yes that's right that yeah
so I agree with you I think that it
doesn't you would shared state the
problem of shared state doesn't go away
and that's actually kind of obvious
because if the problem of shared state
went away then all the problems related
to concurrency in asynchrony all those
race condition that would go away that
is the real problem what we don't have
is all those low-level shared memory
issues I mean the way you don't have
locks for example here you don't let you
don't have to worry about weak memory
model issues right you don't have to
worry about all this compiler you all
ringing all that stuff would you have
work yes you have to worry about event
reordering you have to worry about you
know this guy is doing a sent this guys
doing SN both are going to the same
machine okay well maybe this send got
DQ'd there first before this or maybe in
another situation this sin garden queued
there before this one and so on and so
forth you have to worry about those
kinds of things so you still have to
yeah
discussion about time I wonder I mean
classics of the USB specification depend
on time in life you have to do this
within so many milliseconds or you drop
it and you allow the inside inside a
machine to call the timing function yeah
yeah so the timer is modeled as a
separate machine I mean in reality the
the OS time a timer mechanism is is
invoked but because they are raised
conditions there we model that as a
machine and then we get to explore all
that any other know so the operational
semantics is completely untimed what
that means is that from the point of
view of the tests that are generated at
the same level a timer with a time out
of one millisecond can expire later than
a timer with a time out of 1 million
seconds you guys that's properties that
you check no it was the overlap or
partial overlap between the the actual
bug reports in the USB stack ignited
this isn't a complete guarantee did it
in open it directly so timing is one
thing which is a scope for their other
properties that are outside school I
mean okay so I think that for example I
think it's kind of related to timing but
performance is outside the show yeah yes
so for example memory safety issues that
are happening in the foreign code they
are outside for that computation that's
happening in p we provide basically safe
you know the exception semantics right
we fail safe kind of deal but you know
once you are in foreign code which is
implemented and see anything can happen
yeah
I think that they might be a little bit
but was not a big deal at all in fact I
remember an electrode where they were
able to write more fine-grained even
processing question where I think I
remember wait what what he was doing was
that without fee he was actually had to
do more cause land transactions when I
went once it is even event he had to do
a lot of fussing oh you could actually
break it up into more fine-grain things
and he would have been able to do it if
he didn't have that she rose at the
model checker because a the things that
if he was doing it using like actually
fine-grained locking then there will be
more chances of bugs and so on I was
able to do more fun thing that's not
because of using p not because of these
my express away notice that he's just
that you can get the testing for free
give him more confidence I otherwise you
these experiences that it would get
mobile okay what what we try to provide
is we we try to get your code to a
certain level of crappiness as quickly
as possible the default ones that
becomes work so i think that there were
a lot of them especially in the first
one because in the first one they went
they took a really extreme thing they
wanted they were so concerned about
coverage that they would try to check
each machine separately and so they had
to write a lot of do had to do a lot of
environment modeling to constrain the
environment of that machine so all that
stuff is really extra stuff you know
like modern code so i think that there
was a lot more modeling that in the
first one in the phone drivers there was
less
you know I think that the may I think
that it was significantly less I think
that for the phone drivers they were
mostly relying on mostly relying on
unhandled events the default specs they
did use even bounce though and cue
bounds yeah okay but for example like
the prototypes that so for this summer
ankush was an intern with me so he built
he was trying to build the entire
service for say distributed key value
store so he wrote a lot of models and he
used a lot of monitors for for doing the
verification so he in that in that case
he wrote a lot of stuff that was outside
the default specifications</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>