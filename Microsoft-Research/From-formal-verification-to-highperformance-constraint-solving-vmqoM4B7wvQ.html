<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>From formal verification to high-performance constraint solving | Coder Coacher - Coaching Coders</title><meta content="From formal verification to high-performance constraint solving - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>From formal verification to high-performance constraint solving</b></h2><h5 class="post__date">2016-06-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/vmqoM4B7wvQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year Microsoft Research hosts
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
it's my great pleasure to introduce
robert's new in-house roberts who works
in automated reasoning by modulation to
improvers he's one of the authors of the
very informational GPL out sea paper
he's seen implemented the bass illogic
seem to sober that was a breakthrough at
that time since then Roberts in his
group they open a company biologic and
they are working optimization now today
he's going to talk about how he made the
transition for for modification to high
performance constraint solving the the
things neonatal just mentioned involve a
group right it's not me it's many people
among among others Albert Olivares who
is here okay so this is about how we how
we move from tools that are mainly used
for formal verification to optimization
so first I will speak a little bit about
what barceló jig is and then there's
going to be a technical part and
depending on the interest of the
audience we can skip a part or we can go
through it and there is an application
part so the technical part many of you
know it close learning set solvers why
do they work so well what is SMT why
does it work so well maybe there's a new
view for some of the people in the
audience maybe ILP so integer linear
programming as an SMT problem and also
hybrids so SMT plus what I call encoding
bottlenecks then going beyond so instead
of learning only sat closest as you do
with SMT you can also learn new
constraints and then we go into insert
and some evaluation of insert then some
words about the focus of our syllabic
and examples of our customers problems
and tools used there okay so this is
versa logic
let's suspend off of our University this
is ownership this is the core team and
well where did where did we come from
originally from this areas here so
automated adduction which has many
applications work on the implementation
of logics rewriting termination proving
CPE and insights CP well weighted CP
probabilistic graphical models and
there's a lot of collaborations with
other places they're going on and then
the focus today nowadays in sidebar
Sailaja kis mostly on sat and SMT and
many applications of this for instance
what we did was define this DPL t
standard that well it's the kind of
framework that SMT solvers nowadays any
of them use and what we did as Leonardo
said before we did some tools and well
this also have many applications have
many of you know here and we also work
on many other camana toriel optimization
problems using many other techniques and
solvers aha this works so in this talk
in the technical part I'm going to work
I'm going to explain about this so a
lots at SMT insert and other techniques
and applications so this is sat most of
you know so here we have closes and what
you do is you decide you propagate etc
each time the blue clause is the one
that acts then you have this so the red
the red numbers denote variables that
have been decided and the black ones
denote propagations
and then you have this false clause it's
a conflict so you have to backtrack and
the typical backtrack would be this and
then you have a solution but you can do
much better you can also do back jump
instead of backtrack so back jump let's
briefly remember so in fact it notices
that for instance in in the example we
saw before that this decision level
irrelevant for the conflict so we could
directly back jump to here because the
conflict comes from decision one and its
consequence two and decision five and
its consequence not six
so having here not five is is enough to
is needed to solve to solve the conflict
so conflict analysis is this you have to
find a back jump clause in this case is
this one that's the logical consequence
of all the clauses you had and that
reveals the unit propagation at an
earlier decision level so where the Part
C is false and then back jumping is well
after that you return to the decision
level D and do the propagation so here
is another example you have this current
assignment last decision is nine and
then with these clauses here you
successively you propagate not eight
with this Clause then not five with this
Clause etc until you reach this conflict
here and so then you are going to
analyze where the conflict comes from
and you say well what was the last
literal involved in this conflict where
did it come from
oh it came from this clause here so then
we do a resolution and we get a new
false clause that is false in a prefix
of the stack so you can repeat this
until you reach a clause that has only
one literal of the last decision level
this is cause the first the first uip
and you can use this close to bad jump
always in this case you would back jump
to after not seven so independently of
how many decisions you have here in
between you can back jump directly to
this point this is simple I guess most
people know it now a view about why it
works so well so in my opinion so first
thing is that you learn the back jump
Clause as a lemma
this makes uni propagation more powerful
and it prevents exponential amount of
repeated work in future similar
conflicts so these similar conflicts
tend to
come up when you have structure in your
problems not in random problems
typically where this thing doesn't do
anything also the decision heuristic so
did you decide on variables that have
many occurrences in recent conflicts
this is called the dynamic activity
based heuristics and the ID from my
point of view is that you work off
clusters of tightly related variables so
if you apply this algorithm you you put
together two subproblems that share no
variables two completely independent
problems you will see that the typical
set solver will work only on one of them
thanks to this heuristic which is of
course a good thing and after finishing
with this one we'll work on the other
one and the third point is to forget
from time to time the low activity
lemmas this is crucial to make unit
propagate fast and memory affordable and
the idea is this so after you have work
touch of such a cluster the one site I
was mentioning here then these lemmas
are no longer needed you have stronger
lemmas talking about that part of the
search base I guess if you would learn
this then the back jump itself would not
that be that important by fast replay
restart ms restart their first few
stores yeah yes exactly we assign
exactly which should yeah yeah good
point so why is this working so well
what is good what is bad you know this I
think I think we all know so this is a
slide I used to have in in my talks
already some years ago and I was saying
what is bad well the language is
low-level it's difficult to come up with
good and codings especially for
arithmetic so we did a lot of work on
encodings and many people have worked on
this you know good and gorings 4:01
cardinality constraints absolutely
boolean constraints encoding for the
integer
and also this part here so usually you
get it you get an answer unset or you
get a model but optimization was not as
well studied in this context so how can
we solve this part bad things that's
what the rest of the presentation is is
about sat modulo theories again most of
you know so this is this comes from
software hardware hardware verification
application so reasoning about theories
here are a couple of examples this is a
Guf essentially this is the theory of
congruence and here you have several
combined theories so there is read and
write in a race there is arithmetic and
there are some of these uninterpreted
functions so this is typical in
verification applications so this is the
first the first approach I think it's
it's the the appearance of SMT in the in
this sense the lazy the lazy thing right
it's also known as lemmas on demand by
de Moura and ruse and well the idea is
simply to forget about the meaning of
the literals just consider them as
propositional literals and send the
clause set to the Sat solver then the
Sat solver returns a model and then you
have another piece of software that's
the theory solver and it can check it
can reason about conjunctions of of
these theory literals and it says no
this is T inconsistent you cannot have
together this and this and this that's
contradictory with the theory so then
you can add a clause forbidding this at
it and send it again to the Sat solver
returns another model it's again theory
inconsistent then you said it again to
the Sat solver with the closed blocking
it and then it becomes unsatisfiable
so eventually either you get
unsatisfiable or you get a theory
consistent model in this way
but then you can do some improvements
which are quite easy to come up with so
since your solver is DP ll or CD CL
based you can do better for instance you
can instead of checking the consistency
of full propositional models you can
check the partial ones while they are
being built and instead of adding not M
as a clause when you get this thing
consistent model M you try to come up
with a small t inconsistent subset this
is called an explanation
usually explanations are very small and
instead of adding the clause and
restarting you could do conflict
analysis of the explanation and back
jump and then we came up with this deep
ll approach and we where you also have
what is called theory propagation which
is what people in constraint programming
call propagation so you simply you can
propagate literals that are Theory
consequences so you do not only guide
the search but sorry you not only
validate the search but you also guide
it a little bit more anyway go for it
for it
yeah yeah what most people don't think
about Google as being a company okay
this is an example I think it's quite
interesting for the rest of the talk
this may be newer for you so consider a
theory you do integer linear programming
so the theory is just the conjunction of
linear constraints and you decide and
you do unit propagation on bounds so you
have these bounds and theory propagation
is then just bound propagation for
instance from these two bounds and this
constraint you can infer this our new
bounds and an explanation Clause for
this propagation would be this clause
here so either this bound is false so
this one is false or this one is true
but of course from one constraint you
can have many explanations many
different explanations depending on
which propagation you have done with the
constraint and if there is a conflict
well you generate the explanation
clauses and demand during the analysis
during the conflict analysis and you do
everything as insert and termination and
completeness follow from just the
standard SMT completeness result the
interesting thing here is that you know
this is doing SMT pure SMT in this
context is a little bit cowardice you
know so you only learn new clauses S
doesn't change everything is simple and
this was later on also developed by
Peter Stuckey and others and I called it
lazy gloss generation and they use it in
the CP world the constraint programming
world and it works very well on on many
CP problems really well okay now why
does SMT work so well because most
constraints are not bottlenecks so they
only generate a few different
explanation clauses in practice and SMT
will generate exactly these few clauses
on demand but sometimes you do have
bottleneck constraint
and they typically they can generate an
exponential number of explanation
clauses like for instance if you have
something some part of the input that
implies that at least k of a set of a
set of literals has to be true and you
have such a constraint saying at most K
minus 1 can be true then it will
generate all subsets as explanation
clauses so this exponential number this
happens okay so what you can do is
detect and encode such bottleneck
constraints under fly so while running
when you detect that a certain
constraint is generating a lot of
explanations you stop and you encode
that one and instead of doing this naive
Sat encoding which is the this
exponential number of explanations you
have a compact encoding with auxiliary
variables only for that constraint and
it's even helpful because you can also
split on these auxiliary variables and
this appears to be helpful in some cases
so this is some work we have done
together with Stuckey this was for
cardinality and for pseudo boolean as
well but they they in this first paper
so a bo is a PhD student of ours who
went to work with him in the first paper
they they tried to not not encode a full
constraint but partial only those parts
that appeared to be active and this made
it really difficult to implement and
then we did a lot of experiments and we
discovered that you can in most cases
you can just encode the full constraints
and everything works well and then of
course you do not need specialized
algorithms to be able to extract part of
a constraint which is what they were
doing in the cardinality constraints for
instance and in the end up to the
boolean ones and this works very well
again this is a significant additional
improvement
on just smt so you start with SMT and
when you see that something is a
bottleneck you encode under fly only
these parts okay but then there is this
challenge so in the slide before the
slides before you were only learning new
clauses but it can be much more powerful
to learn also new constraints so this
would if you look at it from the SMT
point of view you would be strengthening
your theory well not not the theory but
the representation of the theory so you
you add new cuts that are consequences
new constraints so you have this table
here closest constraints when it had six
first rights did it know when was that
great minds think alike this this is
from my CP talk last fall I think so
this is you know if you want to
eliminate a variable from from two
constraints you can always find the
multipliers in order to do it right so
this is this would be your cut inference
and well this is this is an example just
to to motivate indeed that learned cuts
are stronger than then SMT closes so for
instance here this is a zero one example
so here I could have as well have
written oh sorry this is just X is true
why is through Z is through you is true
and the stack grows like this so you
take these two decisions you propagate
with C 1 at Z is true and then you have
a conflict I know you propagate with C 2
that this is that U is true and then you
have a conflict so if you do the normal
conflict analysis SMT like style then
you get well essentially you get that
not XY and Z at the same time can be
true
so one of the three has to have to be
false but you can express with this
linear constraint but if you do the cut
you can directly infer that Z has to be
false this is just an example but this
in practice it happens a lot that you
know doing cuts you get much stronger
results and now well this is a well
known problem even in the zero one case
that you know what you would like to do
you know if you really if you really do
everything you would do in cdcl with
this you start doing with it with
integer linear programming with this
then you run into trouble and this is an
example of the trouble so you say again
this is a zero one example so X is
through Y is true then with c1 Z has to
be true and then c2 is a conflict but
this propagation you have done it by
rounding so if X is true and Y is true
then to Z has to be at least one so this
means that Z has to be at least one
because because of rounding and this
rounding is what kills you so if you do
the corresponding conflict analysis cut
you get something that is a useless
still tautology in the zero one case and
indeed according to the intuition if you
translate Sat 2 to this then conflict
analysis is finished because indeed for
this constraint only one bound in the
stack of the current decision level is
relevant but but this thing here is too
weak to force a back jump so you're
stuck this is a typical example well
known it was already well known in the
zero one case etcetera so if you try to
solve this problem in a zero one case
there is a lot of work on this into the
boolean solvers so one solution is you
go the pure SMT way so you can just
solve the problem as
the SMT case right and indeed if you
look at it some sooo the boolean solvers
they only learn closest so these are
just SMT solvers in this sense but you
can be smarter so you can fall back on
SMT only in the case of the rounding
problem and then since any clause on
zero one bounds is expressible as a
constraint so you can imagine this is
because of convexity in the zero one
case this junction of bounds is
expressible as a single constraint
because it's it works so then you can
simply express your thing as as a
constraint and do the cut with these
constraints so this is a particular case
of you know doing the cut only with the
variable that you eliminate having
coefficient 1 or minus 1 so this is this
is what happens here so then there is no
rounding so you can always if you do all
your cuts like this you can always back
jump but in the in depth of the boolean
world there are there are better
solutions even so you can also use
cardinality explanations instead of
always closes so it is a way of dealing
it's a form of SMT where the basic
language is cardinality constraints and
not closes and there are a lot of people
that have worked on this ok now solving
the rounding problem in the Z case so
this is very nice work and the authors
managed to to solve the rounding problem
they they can during conflict analysis
for each propagated variable always
compute a tight reason what they call a
tight reason which is again that the
coefficient of the propagated variable
has coefficient 1 or minus 1 and the
process of computing this tight reason
is done undermanned during conflict
analysis and this process uses a number
of non variable eliminating cuts and
this works because it is required that
decision decisions are always made
making a variable equal equal to its
current upper or lower bound and as
before if you only do conflict analysis
with tight reasons then there is no
rounding problem you can always back
jump and this learning scheme is similar
because because they really need to
compute these tight reasons during
conflict analysis they must use this
learning scheme at least the way they
solve it maybe it's not necessary but
the way they do it they need to have to
use this learning scheme which is
similar to the old decisions sat.1 so
this means that the tight reasons you
compute in the end what you get is is
kind of as if you had done conflict
analysis in sat until you have only
decisions and unfortunately this doesn't
work much it just doesn't work well in
in sat and apparently it also doesn't
work well in initial linear programming
that's the first yeah and that's no it's
bad because what you learn is less
useful so this is the clause this agrees
with what we were saying before right so
the back jump itself I don't think it's
very important why you bad jump to so
what is important is the quality of what
you learn in sat it works because inside
if you if you you can do it right you
can do conflict analysis and until you
reach something that's built from
decisions only and if you are a little
bit more clever you would continue until
you have one literal of each decision
literal this is called the all uib which
you can also do and you you get really
small lemmas so many people have tried
this right because it looks it looks
very good
because you get small MS and apparently
smaller lemmas should behave better and
it's not true so it doesn't work at all
so it's not the overhead of computing
these lemmas it's because later on
search is much worse so even if it were
cheap it's not worth it
just like other learning schemes based
on min-cut of the conflict graph it's
the same thing so you get really small
Emma's so even if it were cheap to
compute it it doesn't search well okay
so so what I try to do to overcome this
is quite pragmatic it's much less
elegant but it works much better so the
idea is to fall back on SMT only in
those cases where you need it and this
is similar to what is done in the
episode the boolean case by others but
you are in trouble here because you
cannot convert any clause on bounced
into a constraint so you have to be
careful how you do it okay so here you
can have arbitrary new bounds as
decisions and you always get a back jump
constraint but you get it you get you
learn a new constraint and you do a back
jump and not always the back jump is
based on the constraint you learn but
the search is guided as in the first two
IP learning scheme in CDCl and the idea
is well you always do the cuts and if
there is a rounding problem you rely on
SMT for completeness but you learn the
closest on bounds only if they can be
turned into constraints because you
cannot have in your language at the same
time clauses and constraints so they do
you cannot do any inferences combining
them in an easy way at least okay well
essentially if we look at an example you
can imagine this is a symbolic way of
expressing it right well you in the
stack you keep a bound and for each
propagated bounds you have the reason
constraint but you also have the recent
set which is the subset of bounds below
it in the stack that have cost the
propagation so for instance this thing
has
the reason this bound and this bound
sorry this bound has this reason this
bound and another one below which is not
not drawn so this is the reason set and
then if you have a conflict you have any
initial conflicting set well you do the
SMT like conflict analysis but you also
do the cuts and then it's it frequently
happens that at some point before
reaching the first uip you already have
a cut that causes a bad jump and then of
course you do the back jump according to
the cut otherwise you may reach the
first UIP
based on the SMT conflict analysis and
you do the back jump according to the
SMT that's the main idea Bobby I'm not
going to go through the whole example
but it's in the slides okay this is the
accent of the example and of course here
optimization is trivial you just you
know you run it the first time and then
after that you try to you add a
constraint saying well now I only want
better solutions and you rerun so that's
just branch and bound orgrim cut cut and
bound or whatever
sorry okay
and there are these these results you
mean binary search or something or again
the the dual thing okay okay well the
interesting thing is that this can be
implemented in a very light way so you
do not since since you do not rely on
the undercuts for completeness for
instance you can you can prevent
overflow by just throwing away those
cuts you don't like so what I do is I
cuts giving coefficients that are too
big are simply discarded and then if
intermediate computations are done in
big integers then it's guaranteed not to
not to give overflow in the intermediate
computations and there are some tricks
about how to implement it like counter
based bound propagation and counter
based bound propagation well you could
depending on how your constraints look
you could have different different ways
of doing efficient propagation for the
moment I've only implemented this it
also has it advantages because you can
more easily parallel eyes for instance
okay so this is what we are comparing
with with the commercial solvers right
so they're expensive they are based on
law and combining lots of techniques and
well indeed they have seen in men's
improvements in the last years and we
also compare with their four core
versions instead of one core which is
this thing okay so this is the first
completely different technique that
shows some competitiveness on integer
linear programming with the commercial
servers as far as I know even on these
may blip problems which are their
standard tests it
and even with this small toy
implementation and there is a lot of
room for improvement so I tried you can
see it in this paper I tried some random
problems and also the may blip ones so
all my bleep problems
where variables are bounded because
currently I cannot handle unbound it
including some heart and open ones and
the some of them are really big so let
me try to give you a demo on some of
them inside so here there are a couple
of problems this is one of the Mabley
problems this is lecture scheduling this
is not a very big problem there's
something like then then about 10,000
variables and I think 15,000 constraints
or something well this is this is
SEAPLEX running for a moment it has no
solution and the problem is open so the
optimal is unknown and well if you let
it run for an hour or so or so it gets
solutions let's so here the lower bound
is 38 I don't know how long it takes to
find the first solution
no no no this is something else this is
this is the lower bound now this this
look at this so this this it depends
this depend on a node that it's
exploring you see it goes up and down no
no it has no solution yet there's no
solution let's yeah exactly this is this
is the lower bound that comes from the
LP relaxation so us now in this column
here we're supposed to be getting
integer solutions and as soon as the gap
between the two is small enough it stops
let's say it's optimal so you can set
this gap to some value if you say I
don't care about the last two percent
and it will stop after the last two
percent no well we don't get any
solutions
let's interrupt okay after what is it
hundred something now I ran inside with
the same
so it finds solutions very quickly got
some work to go down so after a minute
here you get the solution which is I
think 84 or something which is it takes
hours to get it with and it's fat in
fact it's close to the to what is known
as optimal so the best the best solution
found so far I think we are getting
there maybe we can let it run for a
while what you are we almost everything
yeah so this is this is already close to
the best known solution of this problem
here I have another one which I'm not
even going to run SEAPLEX because it
dies so it takes a very long time to get
a first solution with Z place so this is
a big one you see it has a 135 thousand
variables in hundred fifty thousand
constraints this is a huge problem it's
well it finished parsing so it starts
working and there we have some solutions
I'm doing some no not here here I do
nothing I don't know in the Z row once
over I do a little bit of probing but
it's not very useful so I'm sure a lot
more can be done in all this and here
again so if you after after a minute or
so it gives you a solution that's again
close to the best known anyway it's
boring to watch it I think some point
that you get a jump to a much much
better solution
so you get quite some pruning from the
you know when you add the new
constraints saying only fine from the
upper bounding sorry I had a version
from the CP paper online but I recently
removed it because since then there have
been a lot of improvements but I haven't
made made public the new one so if you
if you send me email I can I can when
when the new release comes out I can I
can let you know yeah I see so this is
this is already close to the best
we went down from 1 million something or
from yeah from 1 million something to
300,000 ok let's stop it I can also show
you yeah so this is this is this isn't a
demo of the zero once over with an
application - can you read yeah anything
more or less see it's ok so this is this
is work for scheduling for a car rental
company so I'm using Prolog as a
modeling language and well this is a
little bit toy example so you can you
can have lots of constraints describing
for instance this is so the car rental
company accentual e what the guys do is
pick up cars you know so people pick up
cars and they attend them so this says
that each worker can handle 5.5 cars per
hour and there are lots of constraints
about the contracts those guys have and
you know how many people you have of
each kind of contract what what
temporary workers cost how many hours
they can work etc so you can complicate
it as much as you want and then there is
let's see yeah so here you have all
these numbers
this is in this in the timeslot from 7
a.m. to 9 a.m. each day of the year how
many cars they have to handle ok so we
have this data for the whole year this
is a forecast and you can also do things
like you know this worker is absent this
moment etc etc well this is a simplified
version of it this is for a customer of
barceló Jake ok so now what are we doing
here let's first do it
so this is a car rental company at an
airport in Spain but they are in fact I
have many airports so in January they
don't have much work so now let's just
schedule what's going on
because this can't even read it the
press s this
yeah okay so I and my screen it's much
much smaller
even with glasses I cannot see so this
is just prologue so now we are going to
schedule the month of January mmm where
is this here so this this prologue
program is going to invoke SEAPLEX
so it generates the LP program zero one
linear programming and it invokes LP it
invokes SEAPLEX we didn't even see it
fighting with it anyway then you get its
really big error and this is not what I
expected
as a result anyway January
let's see what happens here
yeah yeah that looks really suspicious
you were using in February usually ah
that's why that's why yes January is its
cost zero you're right you're thank you
alert
yeah now it was February was easy
January was really easy that's why it's
scheduling for everywhere yes
yeah okay 700
so now you it's too late we can see the
solution here that explains also why why
the cost is 700 you know because it had
to hire two temporary workers and well
there are different costs involved in
the contract so no I lost the cursor
where is it like ah that's why I lost
the cursor because I'm not watching
I'm not seeing on one screen what's on
the other a little crucial to this is
here
cursor is gone
sorry
here it's incredible yes okay so now I
can do here so you can watch this linear
program there is a huge function to be
optimized and you have lots of these
constraints to observe the boolean
optimization problem okay it's huge so
this is the same problem with inside
proofs optimality okay now we can so you
said that you had a separate code in
case yeah yeah yeah and so the boolean
you can do many more dirty tricks yeah I
saw you so it's like like in the cut-set
procedure you have to do a lot of work
to get a tight tight reason in the to
the boolean case there are many tricks
to get these tight reasons just locally
without doing any inferences so you can
extract from the constraint you can
extract sometimes you can extract a
cardinality constrained instead of a
clause and you can also sometimes
extract up to the boolean constraint
instead of a clause you can you can do
stronger things locally yeah like chai
and Dickson so this is me in May things
are much more difficult in this company
so again we see first SEAPLEX running it
has it has a timeout of 60 seconds I
think that your integers over salts for
bounded integers each variable is
bounded haha to do better you mean and
what's rightfully the 0 1 variables
about the dresser yeah what do you mean
just like
concrete policies yeah so it still still
sometimes Leonardo can surely build such
an example right so you can have that
what you what you would need to express
the conflict is something that's not
convex so you cannot express it with a
single single constraint which is what
you would need let's let's do the lid so
it timed out after 60 seconds with a
cost of I don't remember so here we see
the timetable again and of
13300 we run inside on the same problem
you see
so I don't know whether it proves
optimality quickly but I think this is
the optimal here okay so this is at
least in a real-world problem which we
run into where but you can do much
better than the commercial solvers with
with this kind of techniques let me
return to the talk where are we here
okay so here are some statistics about
the talked about the pure insight now we
return to Barcelona so we get now the
application part of the of the talk so
what's the logic what we have been doing
first is this what I call focus one so
we hide this marketing guy expert in
business and he did quite he did quite a
good job so he got all these paying
customers and so we did employee
scheduling for logical center and also
this car rental car company car rental
company we did cross docking later you
will see some more we did a lot of
sparkling planning the Paralympic Games
as well route planning for terms of
transportation companies so but all this
it involves doing consulting with these
customers so you have to be you have to
learn their sector you know their
industry so it does not really scale but
it provides us the financial resources
for the real mission what we want to do
right which is this you know what we
want to do is to to create value and and
good solvers and tools so what we have
been doing is working with third-party
companies so this software providers ERP
and human resources to to make these
modules modules so employees scheduling
and production scheduling using SMT and
extensions and for this now we are ready
for for them to
sell it to customers so we have
prototypes and api's and modeling
modeling languages for this and we have
a patent pending on INSAT and well we
are doing many more things with the zero
one IOPS over and we also have this
which is a little bit different
application area which is Mac's SMT
based companies compositional safety
verification tool and our plan is to do
to do like this so grow in Barcelona
where we have this nice atmosphere okay
so now let's speak a little bit about a
few of these problems to finish the
talks so for instance in this call
centre we had forecasts so they are
there they get different types of calls
which have to be answered by persons
with the right skill and some of these
people are multi skill and then there is
this forecast so for each skill you have
for each 30 minutes lot of the year they
know how many or how many calls they
expect and they want to have this
quality of service like so on this
percentage of course answered in this
amount of seconds by a person of the
right skill and of course many many
regulations are there like rest periods
and so on so by law and by agreement
with unions and with the workers and so
on
so in the end we saved 31 percent of
their summer temporary of the employees
the first year and well this got us
since we were charging them were saved a
full-time equivalent it was it was quite
ok so this is the demo we have seen
already although we applied it to two
car rental companies this is an other
completely different problem this is
cross docking this is a logistics
problem so we do it for a mango
you know the clothing company mango
one of the largest so after H&amp;amp;M and Zara
I think it goes to the biggest and it's
located in Barcelona and well they have
this forecast each shop is going to sell
so and so many items of the of each size
and then they tell the Chinese to to
produce it and the Chinese of course
they make boxes per size and then you go
to a logistic center and you have to
pick items to make the boxes for the
shops and what we do is we design
standard cross docking boxes so each
cross docking box has an assortment of
sizes so the Chinese are not willing to
make the boxes for the shops because
that's not their job they just produce
but they are willing to make this let's
say three different types of cross
docking boxes so whether is each box has
an assortment of sizes so and of course
cross docking boxes that need not be
opened at your logistics center so most
of the shops are served just by using
these standard boxes when we came they
they had a 30% of picking and now they
have a 10% of picking so this is this is
very large savings and we also served we
also soft other problems for them and
some extensions and we provided them
software and maintenance and consulting
this we did just with ad-hoc programs
local search so we not married with sat
and SMT and you know for each this is
professional sports leagues this I I
have been doing for many years and it's
a real hard problem oh let me see
whether I can get a demo on this
so again I'm using here prologue as a
modern in language and this is the Dutch
first division professional soccer and
well it's full of constraint let me show
you just let me see where is it this so
for each team there is this matrix which
says for each other team and each
playing day of the whole season under
which circumstances they are willing to
receive this other team
so the ab12 x blah blah blah they are
code saying well not on sunday or not at
this time or depending on the police
blah blah blah so some of these teams
they have really full matrixes you know
so each entry which is not a - these are
constraints so this is already a lot of
constraints but they're also so these
are many constraints that involve
individual matches so you say well match
cambiar against asset on day three has
no constraints okay match blah blah blah
so each entry is a match but there are
also lots of constraints involving
combinations of matches like well all
these in fact so these guys they cannot
play at home at the same round so when
this guy plays home you cannot have this
match on the same play day there are
same rounds and same days and well so
many many of these constraints come from
TV optimization maximization TV income
others are public order order others are
sportive so it depends a lot and there
are many many constraints also about you
know certain matches for sportive
reasons they have to be placed they have
to be distributed along the season again
for TV reasons so these there are other
constraints that are even more
complicated to express anyway this we
solve with a kind of tailored Sat solver
that also optimized so it is two sets
over that has some
special encodings for this problem and
also that has a special heuristics for
this problem so this is one of the few
examples I know of where a tailored
decision Urist ik works better to
understand that one and it's necessary
this is pure set you're sad but tailored
towards the problem so now what you're
going to see is this parcel logic sets
over tailored towards the scheduling
application how was it tailored for
instance by having so it's optimizing
it's not just that it's also optimizing
in cost function
so it's a kind of max out in that sense
certain certain constraints you they
have a weight associated with it and but
it's also tailored in the decision
heuristic so certain types of variables
are it's this it's deciding before on it
and it's also tailored for the in order
to minimize the cost function
so the typical heuristic where you want
to lower the cost so that the polarity
is done you know to lower the cost then
it sounds like you could produce a
benchmark in the format of weighted sure
no no but we could in fact the
Australians so we're we're Ignacio BOS
with peter stocky they have used this
spot scheduling instances for many
applications they they have them yeah
but there's this evaluation of Max and
solvers yeah so now from Barcelona qui
could be generating lots of real-world
examples many many things so it's very
easy to modify some of the constraints
and run again
another instance and so on so it's
taking some time in finding the first
solution but then you will see it's
again optimizing it will go down don't
know if it's necessary to wait so this
is pure SAP the ER start restarts maybe
we can go back to the talk and where is
the talk here and see what it produced
ok and this we also do for Portugal but
there they they like to have this random
draw on TV you know with girls
extracting balls and so we generate
10,000 different schedules for them and
they select one that we can also do so
they can publish in advance the database
of hundreds of 10,000 calendars so it's
everybody can check that they are
completely different they all satisfy
exactly the constraints that they
publicly say that they have to satisfy
and I can see that the girls extractor
number so that's that's the best of both
worlds ok and we also do crickets that's
also nice so it's completely different
you have to learn a lot about cricket
and then you can do it and there in fact
we have six leagues simultaneous that
are being scheduled this is another
application where we use an ad hoc
greedy algorithm so in the Paralympic
Paralympic Games everything is scheduled
until the last minute you know
everything has to fit in perfectly there
are lots of constraints for TV and for
what's the language of these constraints
is its I don't know
so it's I don't know how Xavier handled
it right internally
I think he got a bunch a spreadsheet or
something and yeah so we we did this for
them once and now we are negotiating
developing a software where they can and
then then we all have to agree about
yeah yeah so we did it once and they
paid us once for a moment and we are
negotiating about doing it more times
it's quite it's quite nice to see the
kind of constraints they have this is
this is an interesting problem so there
is this third-party company who has the
geographic info like like Google Maps
you know and they provide software
servers for transportation companies so
those those guys the transportation
companies they upload information about
their fleet of vehicles capacity weight
size drivers constraints and also every
day which packages they have to deliver
where and which size and which weight
and in which time window etc and then
what we do is we generate planning for
each vehicle and this is kind of you
know strongly constraints combination of
n traveling salesman's problems so and
one one perfect achill in a sense
and here again we use something
completely different so we use g code I
don't know if you know it it's an
open-source constraint programming
package for implementing large
neighborhood search so it's it's kind of
local search where you the notion of
neighborhood is you know you take a
random subset of variables which you are
allowed to flip and these variables well
to flip or to change because it can be
depends if I read 0 0 1 or not and and
so the optimal flipping of the subsets
of variables you do it with a complete
method in this case G code
so you you do this local search and you
can put any local search control on top
of this of course you can do n times
until and so you cannot detect whether
whether you are in a local optimum
that's too expensive but you can iterate
say so in so many times each time you
start with a with a greedy solution for
instance this is focus 1 okay focus
where we you know we want to learn about
customers and their problems and and use
the income to survive to do focus tool
right which was this you know it had two
modules plus plus having good tools
right the modules where 0 1 interpret
integer programming and this let's go
back there so and produce scheduling
using this and production scheduling
which later I will show you using SMT
and some extensions ok so this is this
is the other the other module so this
you can make as complicated as you want
so for the moment we start to already a
quite complicated setting okay so you
have resources their machines vehicles
room and Human Resources with different
skills etc and tasks are subject to
constraint so how many resources of each
kind you use the time window the
duration precedence between tasks
transportation intermediate storage
capacity
you know like in chemical industries for
instance some some things you can't even
store so then you have what we call an
immediate precedence so immediately
after the producing task finishes you
have to do that the follow-up task
because you cannot store the product
availability of raw materials this also
makes it nice transition times setup
times between tasks so when you when you
stop using one machine for some
thing and you have to use it for
something else maybe you have to clean
you have to change some pieces which
cost time this is called transition time
setup times and also the the duration
and energy consumption of each task may
vary depending on the time slot or the
type of resource you use so you may have
fast machines slow machines so we could
we could as you know we could put an
optimization on top of it for the moment
what we do is minimizing the makespan
but we also do try to fit all tasks at
least and after that we optimize
something objectives by discussing this
with with the software company you know
what do you exactly want for the moment
so we can do both as you know so here
here we have this language which you can
easily so the API is it's a kind of text
language but problems max set with SMT
or is it optimization with integers yes
yep you can express it in in both I
think because to back-settlers so what
we what we do is we actually solve it
with SMT annexed and an extensions to
hold on how to handle all this stuff
right asking in different way the
objective functions are they over 0 1
variables or unboundedness none of of
bounded integers
founded in - yes I think so but but not
0 1
don't be formal a because you come
before again the house waiting max
answer okay look what is that they don't
even know what they really want to be
nice so that the correct okay in the
curtains problem combination like that
that produces true so you are talking
with non experts and all this right so I
mean our customers so it's difficult
sometimes to to come to so it in fact
nowadays we consider that we should have
made it much simpler and starts and then
and then make it more complicated on the
fly anyway well and then there are a
couple of last applications benchmarks
you know it's a pain sometimes you know
we made some benchmarks for SMT at a
time and you know people start asking
can you produce more or can you try to
do it in different characteristics and
so it's it's sometimes it's it's quite a
lot of work of course we could the
customers would allow for a moment I am
worried about our work
I think cycle spent so much time yeah
yeah I think for the customers at this
point we could if it's sophisticated
it would be no no problem okay here are
a couple of other examples course
timetabling in fact we also did course
timetabling with sat and with max at
they have some paper about this but
latest version which we did for a real
customer was with g code and this is
another thing plastic extrusion so
there's a lot of car industry close to
barcelona and we did this again with an
ad hoc algorithm okay this is all so if
there is some conclusion and it's this
one so
need a large toolbox of techniques and
even just integer linear programming
leads combinations of tools and inside
these combinations of those inside may
become one of them that's it thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>