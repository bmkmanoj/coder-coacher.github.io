<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Group Communication, Atomic broadcast, Gossip Protocols Part 2 (B) | Coder Coacher - Coaching Coders</title><meta content="Group Communication, Atomic broadcast, Gossip Protocols Part 2 (B) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Group Communication, Atomic broadcast, Gossip Protocols Part 2 (B)</b></h2><h5 class="post__date">2016-08-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/x32l_0tYq1k" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year Microsoft Research hosts
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
okay well I'm gonna get started so skip
case study too because I won't have time
for that
so I talked this morning about the kind
of the mechanisms of gossip as as as the
you know the the epidemic is concerned
how the gossip spreads but one thing
that I was pretty vague about was this
merge function and I'm gonna actually
look a lot more at the merge function in
the in the next hour so in 2008 so the
case that I am looking at is Amazon
Amazon uses gossip in a lot of different
places they originally I got involved
because they took this system that I
built something called Esther wait and
started deploying it within Amazon and
it's a it's a DHT like system it's a it
uses gossip dough internally in order to
maintain its its structure but it's a
scalable structure with you know similar
logarithmic type of scalability
guarantees and they started using it for
from monitoring configuration for it's
not an improvement but it's different
and it's hopefully it's going somewhere
good and they start using it also for
for routing messages finding services
within Amazon you know there were a lot
of machines there even in the 2006 when
I worked with them the next day they
deployed Esther Lape on you know tens of
thousand machines in various continents
and all into this this this structure
that is very exciting for me they a
place where that they also applied
gossiping is a system called dynamo
which is basically a key-value
store also there's more more structured
like Peter described this morning
although well it's a similar ring based
structure uses gossip as well and and it
has this as these eventual consistency
guarantees meaning that you know when
you put something in your shopping cart
eventually all replicas will see that
they also started building around the
time a big storage service that now is
very well known as three it's a storage
system that for its failure detection
actually uses gossip in a manner quite
similar to what I showed this morning
then in 2008 Amazon when of line for for
I think it was something like six hours
initially and and there were all these
these headlines
you know like basically people fear at
the end of cloud computing had come
because you know there were a lot of
places that that tried that relied on
Amazon and somebody was just gone for
six hours this is a huge problem and why
was this all they posted this thing and
you know it's kind of amused to read it
it was the gossip system that so what
does it say on some day we saw large
number of servers that were spending
almost all of their time gossiping and
this proportionate amount of service
that had failed wild gossiping with a
large number of servers gossiping and
failing while gossiping Amazon s3 wasn't
able to successfully process many
customer requests
this was the mikasa system what I
introduced to Amazon so that was great I
you know in my defense I I did develop
some technology that they actually ended
up editing to avoid this particular
situation we'll talk a little bit about
that so what is what aren't some of the
problems to come up with gossip well
it's a gossip is a communication channel
that has a limited amount of capacity
like we're trying to get a certain
amount of data through the system in a
certain amount of time and so it's not a
Cygnus like we talked about before it's
really a singing this communication
channel and within a certain amount of
time there's only so much information
you get gossip about and so if you try
to gossip too much stuff trying to put
too much information into this gossip
bus I think they're gonna back up and so
it's a problem and so you need the tuna
system you have to set the gossip rate
you have to set the message size that
you're going to use and depending on
these parameters the capacity of the
channel is affected so I'm going to talk
about a few different I daresay I'm
gonna as I said before I'm gonna look at
merch what are good strategies to to
merge I'm gonna look at a particular
strategy that that I design called
scuttlebutt looking at then we're going
to look at some of these performance
problems that that s3 was dealing with
and how one might address those using a
flow control mechanism so run of
information to cover stuff to cover
sorry I'll go fairly quickly but if I go
too quickly please stop it okay so let's
look a little more carefully at the
state that the gossiper might maintain
in a typical system like at at Amazon so
Amazon used gossip for monitoring their
systems for example so you might get a
table with a row for every machine in
this case there's just three of them but
you know it would could be very many of
them and a column for each attribute so
example the rate of packets through the
system number I don't know it's this
this is information about about
communication and these value
inside these cells are some value like
10 here and there's 10 ports on Jupiter
and this is a version number version
number 25 for here package rate is point
2 packets per second and that was
surgeon number 12 and that version
number it's very much has a similar
function like the heartbeat that we saw
before and so process so but it's being
gossiped are these values and only the
highest version is the one that that
process want to know about so here for
example are two two of these tables and
they have you know slightly different
information and what you want to do is
merge these tables and come up with a
new table so for example well let's see
Venus and Mars so this this table
doesn't know anything about Jupiter this
one doesn't know anything about Mars
when you merge them you get a table
which is Venus Mars and Jupiter in it
and then you'll see some some things
that get updated what's the good ones
the Phoenix for example here's version
13 is 2400 version 12 is 2300 so in the
merged version you end up with version
13 so again these tables might be very
large but typically if gossip is working
there will be similar to one another the
number of values in the in the various
tables it will be only some small
differences and so but the merge
protocol the two processes are gossiping
tries to do is to to be efficient and
that means not sending the entire table
from between processes but trying to
figure out what the differences are okay
so a bunch of different techniques are
being developed these are called state
reconciliation techniques they actually
applicable not just in gossip but for
example of EF say two databases that are
replicas and you know there's has been
some maybe it was a temporary quotation
you want to merge these databases you
know how do you figure out what the
difference is between these databases
are so gonna first going to look at at
protocols that do so precisely that
given so actually the the we're going to
look at a slightly different data
structure is set it's a little simpler
so we're going to take two sets and
we're gonna merge together what take
they take the union of and we're going
to precise so at the end we will have an
exact union of the two sets and some
people have worked on that they're not
terribly efficient they'll say a little
bit more about them so so for example we
have here host a and B they each have a
set so host a has a set of objects a1 a2
b is the set of box b1 b2 most of which
are the same so how do you figure out
what the differences are because those
are the things you want to exchange and
sending the entire set is still too
inefficient so one way of doing it is
with this thing called the
characteristic polynomial so for host a
would maintain a polynomial FA of X
which is the product of X minus each of
the the the elements as X minus a 1
times X minus a2 etc same for house B
and then if you take the dividers two
functions you end up with a rational
function in which all the common
elements have been eliminated so the end
up with something that's that's much
smaller and the degree of the numerator
is the number of elements in a that are
not in B and the degree of the
denominator and a number of elements
that are B that are not in a C and if
these functions if most of the elements
in the both in both sets are descent are
the same the rational function is a much
simpler function
and what you do then is you're going to
sample this rational function if you
know how many differences there are it's
in this case na plus and B if you know
that there n elements in a that are not
in B and elements in B that are not in a
you simple it in na plus and B plus 1
points then you can in fact find the
roots of the numerator and the
denominator and that way we can find the
elements so that's what the basic idea
is I didn't have some more information
person general you don't know exactly
how many points there are how many
elements there there are that are
different and so you typically find it
with binary search you try a number
ILECs well let's say a hundred if you
can solve it was not enough try 200 and
actually you know until you find
something so you can solve solve this
rational polynomial and it's actually
pretty efficient I've used it there's a
thing you can download from Boston
University there's some papers on it and
if that's what you're trying to do we
can sell two sets it's it's it's a great
protocol but of course it doesn't deal
with version numbers and it it is I know
it's it's not an easy scheme but you
know you can download it another one
that's it's it's Amazon was pretty
Palmer was as the use of bloom filters
and people actually asked me about bloom
filters yesterday so what is a bloom
filter bloom filter is is a relatively
efficient representation of a set
although it's it's probabilistic as
we'll see so again you got some set s
with n elements we're going to pick some
some set of K hash functions collision
resistant hash functions but but that
are different
that have a range of M and bits so then
for each element in the set we're gonna
and and for each it's hash function
we're gonna set a bit a bit in a big
factor with the MBA so I was make sure
of that I believe there it is so for
example you set XY and Z and there's you
know in what is blue purple and red hash
function so you apply the hash it's hash
function to each element in the set and
you set the corresponding elements and
that's fairly easy to test if some
element is in the set
so for example when you do W you
calculate those three hash functions and
in this case one of them evaluates to
zero so it could not have been in the
set of course you could be unlucky you
could accidentally have a case in which
should take an element which happens to
hash into the one the bits that that are
one even though W was not in the set and
so that's what it's why it's
probabilistic in order to minimize those
false positives the number of hash
functions K right yes the number of hash
functions you have to choose has to be
log n time it's our luck two times the
number of bits in the bit vector divided
by the number of elements so you can you
know if you know how many elements there
on the set you can actually for
particular size bit factor minimize the
probability so so for example if you are
willing to spend four bits per element
in the set and you have three hash
functions then the the accuracy of or
the the probability of not having a
collision is eighty five point three
percent I think it's then what it means
yes but eight bits and five hash
functions it gets better but still it's
linear as you can see it's it's linear
in the size of the set
okay so what you now do in order to
reconcile two sets is when to process
their gossiping they exchange their
bloom filters and then they check each
element in the set that they have
against the bloom filter of the of the
pair and if they find elements that are
not according to the bloom filter not in
the other set the exchange those
elements they send it to the other side
now if you're lucky at the end of that
the sets will be identical but you may
not be lucky because you may have some
of these false positives so what you do
is at the end if you such a round of
exchange you actually compare the sets
by calculating a hash over the entire
set and you exchange the the hash value
and if they're not the same you do it
again with a different set of hash
functions you keep doing that until the
sets are the same so that was a you know
X based on a fairly old paper in the 70s
there are other approaches bits and
mocker has a very nice approach that
combines various of these things but as
you sort of can see that you know none
of these are particularly easy to
compute the higher fair amount of work
and they also the amount of data that
you're exchanging is pretty you know can
grow arbitrarily depending on how many
differences there are so we're going to
look at at some some options to do
something about that so if you have
limited bandwidth like your network you
can only send so much information you
cannot exchange all all differences then
you have to decide with which
differences you are going to reconcile
so for example you might use a rule and
say well if I have a large set of
differences maybe the only ones that I'm
going to send are
once that are most out-of-date which
seems fair but you may exchange updates
that are already obsolete because
they're newer updates all the exam are
okay let's try the other other option
which is the other extreme option which
is send the most recent updates first
and they can get a starvation problem
where old out-of-date updates Nick never
make it through the system even though
they you know there would be for other
kinds of elements so so the idea that
we're gonna look at then we applied in
in an Amazon is something called that we
called Scavo button which actually takes
advantage of these version numbers so
it's not set reconciliation per se it's
it actually looks at these version
numbers it's much simpler it's a
protocol that's not precise as we'll see
and that's the unintuitive part about
this whole thing so typically you gossip
you call a merge function you trying to
come up with the best possible state as
a result this doesn't even try and yet
it is eventually consistent and it's
sexually you know we're not gonna use
anything complicated here and no hashes
no polynomials pleasantly surprised by
its by its simplicity okay so the first
trick that involves is that we're not
going to pick version numbers the way
you're used to we're gonna do this
slightly differently so here is this is
not one of these tables by the way so
this is this would be a row in a table
so for example we had a number of
packets per second overflows a number of
ports and the valiant version number
this might be you know the information
for a particular node in the system so
say that this is the initial state so we
got first in its seven seven packets
sorry version haven't been half of
packets per second that version number
seven eight and nine and notice that
they're all the
are different now if the number of
packets per second changes to 0.7 the
version number sign is not 8 this is
what you would think the 10 which is the
maximum plus 1 maximum of the version
numbers plus 1 and so now it changes
again to 0.6 I take the maximum plus 1
10 becomes 11 then the number of flows
changes goes from 23 to 126 I sign a new
version number which is the maximum
version number plus 1 and so as a result
of the of this scheme all the attributes
have a different version number it's not
possible for two different attributes
that the same version number that's
that's part one of it yes well so these
are attributes of one single machine and
so the machine if they're concurrent
updates would serialize them yes
so if I may I think maybe this is the
same question if if two of these these
attributes are updated at the same time
we're just gonna sterilize them in an
arbitrary order I mean these these are
attributes of one machine and so that
machine can serialize them so if you've
updated you know so both of these you
might have signed this 111 and then 112
or this 111 in that 112 either either
one would be okay but that's that's
that's one part of the scheme
now we're gonna gossip so for example
okay so the what we now have is Venus
and Jupiter two of these machines that
are going to gossip the first thing
they're gonna gossip was one another is
not the attributes in two versions but
they're gonna gossip with one another
than their maximum version number so
Venus has a maximum version number six
on the for Venus and Jupiter only knows
of the mixin verse number four in this
case
and so they exchanged a table which has
only as a row in it for every machine
and only one number the maximum version
number that's round one and then Venus
in this case notice that while it has
two updates that the Jupiter doesn't
have four for the row Venus and so it
sends those attributes over Mars
you know actually Jupiter has a more
current version than Venus for the row
Mars and so it sends two updates in the
other direction and the last one is
Jupiter there's one update of its own
row that Venus doesn't have and so it
sends want to update in the other
direction
all right so actually let's go for a
second back to let's further back that I
so this you know would be something like
here the this is not the same example
but you know you take the maximum
version number 25 and here 25 they would
exchange it
because the Mexican version not reserved
the same actually wouldn't exchange
anything okay
let's see okay so now that still doesn't
limit the number of updates that are
going to be exchanged so if there's a
large number of updates they're going to
make a rule by taking a subset of the
number of updates that need to be
exchanged and the rule is that already
I'm here no so we'll see in a second
what that rule is here's a little
notation that I'll need so the new P of
Q of K is is the pair of a valiant of
version number that's so it's the
remapping F P of cubes Q's another note
and K is the attribute so P is a machine
q is the Machine and K is a key for a
particular attribute so for example in
this case the rate that P has for the
rate attribute that he knows about for
the Machine Q is 0.5 in the version
numbers for okay so here's an example of
what that might look like so here is
time one we got three machines P Q and R
and there are three attributes a B and C
and so what we see here is the we I'm
left out all the values because it's
really all about the version numbers so
for example P knows something about our
and the attribute a and it's something
that has version number one and so in
particular so this is only shows the
information the notes have about machine
our by the way so this is in fact the
the actual value this is what our knows
about our what's this our knows
everything about our so the actual
version number is 21 for attribute a 20
to 5 to give B and 23 for attribute C
but Q and P each have a older version of
RS attributes hasn't haven't received
those gossip gieta
okay so now P and Q are gonna gossip
with one another and we get to time too
now they're only going to gossip for
this for the examples sake 1 Delta
they're only uh even though clearly
there are more differences there they
have to you know would have to exchange
for a B and C there's three differences
that they have we're going to limit it
to one and the one that they're the the
rule that they're going to use is that
they're going to exchange oh sorry
that's them I made a mistake
it's B gossips with R and Q gossips with
are they're only going to exchange the
oldest oldest attributes so after when P
and our gossip define you know the
maximum version number here is 3 the
effective maximum version number is 23
so there's you know a lot of potential
updates but they're only he only sends
the R since only its oldest attribute so
in this case a 21 2 to P now Q does the
same gossips with our and and again R
says okay my let me send you your my
attribute for a which is 21 and so at
this at this time this is the state
where P and Q have the right version of
attribute a but they still have their
old versions of attributes B and C for
our right the the version observe 22 and
23 and whereas a is a really old version
and Q has a somewhat newer but still an
obsolete version now what's what would
happen if
B&amp;amp;Q start gossiping with one another
they would exchange their maximum which
is 21 and they would compare it and as a
result they say well version numbers are
the Mexican version officer the same and
they're not going to exchange anything
they decide not to to change anything
and so this is why this is impressive a
conciliation in the normal types of
gossip protocols if if if being cute
were to gossip in the situation Q would
send to P attribute B because there's a
difference and and and P and Q has a
newer version however and scuttlebutt
that won't happen and in fact you know
the the key insight here is they already
know that it must must be obsolete they
that twelve cannot possibly be the
latest version for attribute q and we'll
see why that is so so yes so the rule is
when you exchange the subsets of the
deltas you only you start with the older
ones before the newer ones in this case
we with the one Delta we only send the
oldest one and you get this this
invariant it looks a little complicated
it's it's more it's simpler than then it
looks like so what it means is that
either for every attribute it's it's the
case that P and Q it either
Hugh has the right version number and
the right value for for that that key or
if it's not the right number the version
number of particular key is larger than
the maximum that you knows about let's
have a look at the previous example to
make that a little clearer so it's
either the case
four particular key that in this case an
a that they have the same version number
and it's the right value or if it's not
the same version number
it must be alt it must be less than the
maximum that is held and that's an
invariant that the protocol maintains by
always exchanging the oldest one and not
in the or one that invariant is
maintained and in particular it implies
that if the maximum of the the two
tables at some point are the same if let
p and r have the same variation number
in this case being q of the same version
number the entire mapping must be the
same right if this invariant actually
halts and the maximum czar the same then
this cannot be the case then it must be
the case that every entry in that net
must be the same so and that's usually
the critical point in such a gossip
protocol - or or any kind of protocol
really to identify one of these critical
invariants and making sure that every
operation that you do in this case it's
dead one maintains an environment and
variant that then eventually converges
to something desirable so in this case
when then there's nothing left of gossip
they are in fact the same so it does
converge there's eventual consistency
and I can you know I'll show you a
little bit about how performs which as
well see is still leave something to be
desired
the simulation experiment has 128
processes gossiping with one another
there's 64 attributes for each gossiper
and we're gonna randomly pick case two
to update the results are going to be
very similar for different kinds of
distributions
Kasich wants a second and we're gonna
allow a hundred Delta's to be exchanged
in every gossip experiment so we've got
time with going here on the x-axis and
and this is a measure of of consistency
on the y-axis in this case it's how old
the oldest attribute is in terms of time
and we're looking at three different
protocols two of them are fake
the precise ones is the ones that I
talked about in the beginning these do
precise reconciliation so at the end of
them gossip exchange the the table
started are intended to be the same
except that if there's a limited amount
of information that you can exchange you
either pick the newest that's the red
one or the oldest information the green
one and the blue one is the the
scuttlebutt protocol initially we start
with 128 updates per second and all the
protocols hold up pretty well with the
stillness of about five seconds then we
increase the number of updates per
second to 256 and now the protocol start
not being able to keep up some point we
bring it back 228 seconds protocol start
being able to keep up and then we turn
off all updates and eventually all all
protocols converge and you can see that
the you know the which the protocol
that's bestest in this case the precise
newest of course you know it you can't
actually implement that protocol you can
only do it in a simulation where you
have all the information the it's called
about is the only real protocol there
but you see that all these protocols
have a problem they can't keep up when
there are too many updates per second
I'm gonna skip over the same one it's
that looks at a different measure the
number still attributes you see similar
types of things so no matter how good
you make your state consider stable
conciliation protocol it may still get
behind you still need to do something
else so what do you use bloom filters or
scuttlebutt or whatever doesn't matter
you need to need to be smarter than that
and that's that's actually the the thing
that I worked on that Amazon when I was
there but they hadn't implemented yet
when they deployed is three okay so we
also need to look at flow control yes
yeah yeah oh well it you know I don't
know it does though I mean so in this
particular case I mean the the merge
that's sort of it the the processes do
they first exchange their maximum
version number so in this case when when
the queue and our gossip would want to
shut one another the exchange the
numbers 13 and 23 maximum version
numbers and then the next thing they do
is they say okay let's exchange some
updates oldest ones first and limit it
to one in this case so the oldest one in
this case was 21 21 22 23 this is you
all this one that's the one that gets
gets sent from our tip you that's that's
the whole protocol
oh no no sorry the the processes are
only allowed to update their own
attributes alright so there's there's
three so there's three attributes a B
and C and three three processes P Q and
R each process has attributes a B and C
so PS as a attribute a which is distinct
from hugh's attribute a so they all
monitor the same things like the Becca
trait the version number of this or in a
certain that would be in that example
the pack of you know things of interest
to that particular machine like
typically you know stuff that would be
sitting you know that you would have
sensors for maybe the load on the
machine the capacity of disk the the
remaining capacity of the disk those are
all attributes and there does you have
the same attributes on each machine and
but the machines only update their own
attributes if you want well I mean so it
is in some sense shared because they
produce this entire table that that you
want to share so for example in this
particular thing that is far far away
you know this this is the the shared
state it's a table with the column for
its attribute and a row for each machine
and what one does with such a table is
you know make management decisions
typically you know if you're going to
run a replica somewhere you're going to
look at the table and say well this is
the least loaded machine or you're gonna
if there's some replica that's that's
performing badly you look at the table
and see well what's load on that machine
how many what's the networking you know
load on the machine so that's the state
that's shared
the individual cells are single writer
if you like only only Mars is allowed to
update these attributes if Jupiter
wanted to to update anything up here it
would actually have to request Mars to
do it so let's see okay so we still need
to do flow control
in order to deal with these big red up
arrows so the next thing we need to try
and figure out what is the rate at which
updates can be introduced into the
system I said that sounds a little funny
I mean so it's a for example if you're
the load on the machine you might think
of every time the load changes that's an
update but what we're really doing is
we're sampling the load on the machine
like the sim simply the size of the run
queue we can you know we have control
over how often we sample these these
these attributes and so what we're going
to do is to adjust the rate at which
sampling happens and that in turn is
going to change the rate of which
updates are going to appear in the
system so we'd like it to be used all
the available bandwidth that the gossip
channel allows us to want to be optimal
we also want to be fair in that all
machines have an equal amount of of that
gossip capacity and we want it to be
adaptive that SD the network may or you
know there's background load and as more
or less bandwidth becomes available we
want the flow control protocol to death
to it much in the same way that TCP does
all these things you know you want it to
use all the available network capacity
you wanted to have every connection to
have a fair fair share of that capacity
and you want to a debt so that's what
we're going to do for gossip
so in order to make it fair we're
actually gonna use a trick I'm gonna use
gossip itself for that so it's it's note
in the system is gonna maintain the max
rate at which it's allowed to gossip and
then when two processes gossip with one
another they are gonna exchange those
rates and for example if if I were to
gossip with Peter and Peter can gossip
that a hundred updates per second and I
can gossip two hundred updates per
second I'm gonna split the difference
I'm gonna give fifty of my updates per
second to Peter so afterwards we can
both do one hundred and fifty updates
per second there's another example of X
&amp;amp; Y so X can can can send one hundred
megabytes per second Y can send five
hundred megabytes per second and they
split the difference at Oh today they're
taking a total of six hundred megabytes
per second and afterwards they end up
with it's being able to send three
hundred now if X only needs to send two
hundred updates per second because it
just doesn't have more than that then we
don't have to actually split the
difference we can actually have Y take
four hundred megabytes per second and X
and so with two hundred megabytes per
second as long as the total remains
invariant so so whenever to processing
gossip they they each take a share but
it always has to you know there's some
needs to stay the same and then in order
to so that takes care of the fairness in
order to adapt we use something similar
to what TCP does that is if if if we're
gossiping too much stuff there's you
have two more deltas then we can stick
in a gossip message or in the in the
gossip channel then we actually locally
a process when it when it can of gospel
the information that wants some gossip
reduce
the maximum rate so just take some off
and if there's too much information
if the gussev messages actually has more
room in it then you don't have enough
updates to send you increase that that
amount and you do that in a way that's
that's similar to TCP that is you're
aggressive about reducing the rate when
there's an overflow but you only slowly
incremented additively so it's
multiplicative decrease and an additive
increase so and if you then look at the
these three protocols again things get a
lot better so in this case we have we
look at the the number of deltas that a
process can exchange again time is on
the x-axis and some notion of stainless
or in this case the rate sorry that's
not true time on the excesses and the
rate at which processes can send updates
and this is the amount of room that that
processes can exchange in a gossip
exchange which depends on the amount of
bandwidth available so initially they
can exchange 100 deltas and at that
point you know we can have one this is I
think this is 128 machines we can have
about 100 100 updates sorry 1 updates
per machine per second then if we have
that size system of deaths and we can do
about half an update per or you know
what about 1 update every 2 seconds and
it's the same for the 3 different
protocols so in this case it you know
the the the choice of protocol actually
doesn't matter so much anymore they it's
it's behave the same but of course
something like scuttlebutt but it's only
exchange versions numbers is a lot more
efficient the other ones also
being fake with it so here we look at
the utter the utter measure which is the
the the staleness the maximum stillness
in seconds again going from a situation
where we have a relatively large amount
of bandwidth to having that bandwidth
that time Andy and the protocols each of
debt this one is actually has some
trouble because of the way it does
things it has to a lot of backlog
because it suffers from starvation
because you change the newest update all
the older updates have to wait and so
the the stillness increases quite a bit
but it - recovers in about 10 seconds
and things get back to normal with the
maximum still this stuff about five
seconds it takes with the gust bring one
two seconds it takes with five seconds
for gossip did to disseminate okay so
the important things that I was trying
to get across here even though the
mechanisms may not be a completely clear
right right away is that normal gossip
that's completely blind to how much
stuff is being exchanged does not give
you good predictable performance and
we've seen what happened at Amazon where
machines can completely killed by by the
the load that gossip imposes on the
network and of the machines there's too
much stuff to send around updates start
backing up so scuttlebutt tries to do
two different things
it tries to it's a very simple
reconciliation mechanisms based on these
maximum version numbers and that's
actually made it's in its way into the
Cassandra system which is a fairly
popular key value store that's used in
many places and a flow control protocol
so that these protocols are dapped to to
their surroundings
and you know the amount of men with it
that's available
I think that's let's see how much time
they have left here so there any
questions about that part
but if you want to understand the
details of the reconciliation or the
flow control it's probably best to catch
me offline sometime or there is a paper
on the subject but the important points
are the ones that are here to take home
points gossip by itself you have to be
careful with need to add flow control
and you need to be careful about how you
do reconciliation yes
so the question is if you have a
database and they're you know like it's
needs note as a database and there are
updates that come into the system can we
control the the updates and the answer
is yes we don't necessarily need to
capture every update to a cell in the
database to a record in the database we
could do for example every other update
or every third update now there's not
not the way you would do it but you was
for example only look once every second
to see what has changed once every 10
seconds to see what has changed or once
every minute to see what has changed and
that way you can can reduce the rate
particularly if you have sort of more
zip Ian types of distributions where
attributes you know the same attributes
get updated popular attributes get
updated more often than then unpopular
wants a lot of this updates then quickly
become obsolete so that way you can
control the update rate yeah that's so I
mean you know like because of the the
synchronous nature of a gossip channel
they be the finite capacity in it's not
just gossip but you know really any kind
of channel on over a physical network
there's only so many updates you can
push through through a network and so
you have to do something you cannot
necessarily you know if there's too many
updates you have to make some trade-off
and setting the sampling rate is the way
to do it and so what this this work does
is automatically finding a sampling rate
that's optimal this it's twice in as
many updates as are possible that's fair
everybody gets a fair share of it and
since the optimal fair and it adjusts
its debts to what's available so if it
changes it will go faster or slower
depending on that
any other questions don't think I'm
gonna look at the remaining slide
sexually because I think you guys got
way more information than you you need
yes Peter
so Cassandra is a fairly it's a dynamo
like key value store actually the the
the the the the the stuff that you think
is Sandra is you know it's it's it's the
monitoring subsystem of Cassandra that
keeps track of so so it does membership
which notes are there and you know in
fact does I think failure detection
innocent in this way and for each note
it keeps track of you know how much
capacity there's on the machines and
does things like replica placement
dealing with reconfiguration when
there's been a failure so it doesn't
store the key value pairs or it doesn't
reconcile that that wafer data uses in
dynamo but the management of the system
uses something like this and that's
actually often how gossip is used it's
not so much for used to to we can solve
databases for example but it's mostly
used and I think in pastry to to do in
the background do the management part of
things it's it's it's very much a
monitoring and control thing that's it's
used because it's a simple and it's so
robust you know you can have built this
very complicated protocol like fast
pastry which is very sophisticated with
you know these flexed and trees and all
the kind of stuff but then you know if
something goes wrong you need something
to to clean things up and for that some
gossip in the background there's wonders
because it can use them it's a much
simpler mechanism yes
Yeah right
yeah
that's a good question I'm actually not
entirely sure how that works in in
Cassandra I mean in the in the case of
Amazon it was actually you know like
something a system administrator would
set says gossip is allowed to use you
know 1% of the network or something like
that and then if you wanted to change
that to 2% that was actually discuss it
around the machines gossip what that
raid was and so you know again yet
another use of gossip where that the
raid was adjusted automatically but
based on a manual a manual setting
somebody who set that rate it wasn't
automatically said you could of course
imagined that you change that that
administrator by some automatic rule
that looks at what the load on the
network is and based on that decides how
much gossip is allowed to travel on the
network but in the absence of that like
an s3 gossip can take over your network
altogether very easily in fact that's
the danger yes
yeah I don't know if they sing better I
mean oops going the wrong way
let's see yeah
I'm not good with this thing which ways
forward there oh no this is not a good
way of doing it I have a buckle on
little round on my screen which this
looks like my mouse it's very confusing
so in this case here I guess there's
scuttle does do relatively well in this
particular benchmark scuttlebutt but I
mean the you have to first of all keep
in mind that the other two our base
lines they're fake you know like there's
there's no protocol that actually can do
find what the newest and the oldest
updates are in in in in these kinds of
protocols without just you can you can
do it when you're running in a
simulation because you can look at the
global state and so you can pick them
that way so these are just baselines and
compared to the baseline scuttle but in
this case happens to perform pretty well
I don't know you know like all these
produce protocols actually seem to
perform similarly in general the
difference is in how much computation
they perform and how much overhead er is
in the network so I don't know I don't
have a good answer to to your question
seems it seems to in the end not really
matter which reconciliation protocol you
use as long might as well pick an
efficient one one that doesn't do a
whole lot of work like Scala but wits
only doesn't do any hashing or
characteristic polynomials the more
important thing is doing flow control
and the others in case I think it's
actually about time for Rebecca to set
up here thank you very much I think that
was my last lecture so thank you for
your attention</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>