<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Mechanizing Exploratory Game Design with Formal Design Space Models | Coder Coacher - Coaching Coders</title><meta content="Mechanizing Exploratory Game Design with Formal Design Space Models - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Mechanizing Exploratory Game Design with Formal Design Space Models</b></h2><h5 class="post__date">2016-06-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fe05O1uor0U" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
hello everyone thanks for coming it's my
great pleasure to introduce Adam Smith
who is currently finishing his post-op
appointment at university of washington
in the center for games science working
with Zoran Popovich so before this Adam
was a PhD student at UC Santa Cruz where
he worked on at CIA I a game design and
Adam is kind of continued his interests
at u-dub as well where now he is working
on applying more formal reasoning tools
automated is includes constraint solving
to the problem of game design and he's
going to tell us more about it today
yeah oh do you think me okay let me put
this back up here so yeah this talk is
going to be about some formal methods
applied to sort of creative design tasks
so let's start by looking at a few what
i mean by creative design tasks so
suppose on the very non frontal end that
you're an artist maybe like a film
composer your your job today is to to
lay out an important melody you're
deciding where to put the notes on the
staff under certain rules of harmony
inform and making things repeat but not
too often and so on you've got a
personal style that you want to make
sure it comes through videos have
audience expectations so there's
external constraints on a more technical
end you could be a someone designing a
CPU this is a very super simplified one
here you might have a formal
specification for what it should do but
it's your job to figure out the the low
level design of things that implements
that high level specification and you're
you're considering things like cost and
timing and propagation delay and lots of
technical properties like that another
thing you might do as a designer is you
could be designing levels for a game
this happens to be from the level editor
for for portal 2 you're trying to make
sure that when the player starts in one
place they make it to the exit
encountering the content you want them
to see what will not encountering the
things you don't want them to see it
should somehow be obvious which way to
go but there should still be some
challenge so there's sort of formal
technical challenges here but as well as
aesthetic ones so in each of these three
cases whether it's the
music the digital logic or the the level
design thing you're a designer who could
benefit from some kind of some kind of
automation in your job some tools to
help you search in the space of
alternative designs so this talk is
about mechanizing design not automating
design in the sense of like fully
replacing designers this is to make the
individual designers more powerful move
them up the layers of abstraction so to
start I'm going to claim that inside of
every design task inside of every design
problem is a search task it's not like
your job as designer easy to search but
it's one of the things you were
repeatedly do it day after day you're
trying to search through the
configurations arrangements and notes on
staff as musician define and instantiate
modules and in the digital logic case or
layout and populate these virtual worlds
in the game thing each one of these
design tasks is form Eliza belen the
sense that if you spent your whole
career you could write down all the
constraints you think are of abuse there
but really you might want to just write
down the most interesting constraints
have the computer help you with those
and then use your own personal
creativity for the rest it's been a
while since I gave this version of the
talk so I remember what I was doing oh
yeah okay so despite yeah despite your
ability to to formalize these various
design tests you got to keep in mind
that the requirements on your particular
task for that day are always changing
based on the rest of your team the
expectations the audience and so on and
also because of this thing called
ill-defined us which sounds like a sort
of ill-defined word but it's big idea in
design studies this influential document
gave me this quote that I like design is
the type of problem solving in which the
problem solver views the problem or acts
as though there's some ill-defined pneus
in the goals the initial conditions or
allowable transformations so it's not
the designers job to give you exactly
what you asked for it's their job to
sort of come up with the the rest of the
specification of what you really wanted
and part of the way they do that is by
offering potential solutions along the
way this is sort of the idea that the
quote attributed to Henry Ford regarding
the events of the mass-produced
automobile if you
ask people what they had wanted they
would have said faster horses but
instead of course he gave him the
automobile so that was like some
excellent design thinking sort of going
with this mindset of able to find us
even people ask you for something you
might wanna give them something else
that they actually want more so this the
search task that comes up is
computationally complex sometimes people
when they're making things that generate
music automatically whether their
composition assistants tools are just
purely generative music things they
might phrase it as a constraint solving
task which you might feed say to a set
solve or something so you might think of
this as not that music composition is
has complexity and be complete but it's
around that that's sort of a comfortable
way of formalizing the formal I zabal
aspects of it if you have a high level
high level behavioral specification for
you what you want your say CPU designed
to do you want to say well can I just
have the computer solve for the
arrangement of pieces that for all
inputs agrees with a high level spec you
might call this circuit synthesis and
this is one of these classic Sigma 2p
complete which is the next layer above
npl polynomial hierarchy likewise if
you're working in a game design domain
depending on whether it's a multiplayer
adversarial game or not it could reduce
to one of these simpler things or it
could be much much worse and but maybe
you think this is sort of like just
something that only happens in the
abstract this doesn't apply to the
common case well there are popular games
like minecraft with mechanics rich
enough to express sort of general
purpose computation so this is
somebody's I believe this is like
they're a bit ALU that they have for a
larger complete working processor design
in Minecraft but maybe say like players
don't actually have to build working
computers in the game this is just what
some hobbyists made the game doesn't
force you to build up working processors
well there are other games particularly
ones about say teaching you programming
or other ones that sort of have the same
type of puzzles but skinned in a
different way that legitimately are
about programming building state
machines and so on and like it's not
just that this is a hot
based activity this is what the game
really asks you to do so when you're
designing puzzles for this you're
thinking over always people could build
a program that satisfies the constraints
you've set up and it's not just simple
state machines in a game like spacechem
you're dealing with like asynchronous
communicating processes and buffers and
flows installment it gets really
interesting like games aren't actually
once you strip away the surface graphics
aren't very different from a lot of the
things you would apply for modes and
software engineering to or even a
electronic design automation and so on
so the usual response to this in the
game industry is to just throw a lot
more human designers and QA testers at
the project where you have someone make
a level then you have a bunch of lesser
paid testers go around and try to break
the game in various ways write down
their notes and this is expensive as you
have to pay all their salaries but it's
also sort of unsatisfying from a design
perspective because for complex designs
no matter how many people you throw at
it there's still going to be some
education that they never checked
likewise because it is expensive this is
not helping you sort of access new areas
of a design space that you wouldn't
otherwise you're just paying a lot to
have high assurance about the thing that
you made this sort of the usual
motivation for all software verification
stuff too but I'm sort of specializing
it two games here and as we applied this
type of stuff to not just games for
entertainment but for education for
science for health is longtail things it
becomes more and more worth it to invest
in automation that is that is relevant
to these things because they do touch a
lot of areas of society now so basically
what i do is i sort of invest my time
and attention into building design
automation tools that work primarily in
games but also give us a new perspective
one week and what we can do in other
domains so i'm saying we should
mechanized design not not automated but
make these tools that assist you based
on this idea that computers are pretty
good at search and checking all these
alternatives and one of the things that
this can give us is design assurance
they can catch costly mistakes early the
usual verification thing for a little
micro design tasks like how
you arrange the blocks in a little maze
so that someone has to spend eight steps
to get of it well we can synthesize an
arrangement of that you don't need to to
make and check something yourself every
single time under the idea of synthesis
here and also if these tools give you
really fast feedback you can explore
more ambitious ideas and know that you
can see directly through to their edge
cases you can also ask the computer for
within some represent representation to
the search the space of things that
might solve that design problem and
occasionally get solutions that you
wouldn't have thought of yourself and
then you say well I like that I want to
run with that and look at other
variations on that so that yeah they can
show new solutions they can maybe
property formulations of the problem may
be like if your design task was to make
some awning to cover the balcony maybe
you see a strange glitchy solution
you're like well maybe it's not just
about covering the honor awning it's
about making it feel a certain way when
you're out there so if I have to boil
down what I do into one sentence and I
will cheat with a semicolon so it's sort
of too it's this idea here the designer
sketches a space of appropriate
artifacts using a constraint program and
I'll should tell you by the technology I
use for that later the Machine samples
an artifact from this space and upon
examining the artifact the Dove the
designer refines the sketch so it's not
that it does the whole job for you but
it does what you told it you realize
that's not what you wanted you iterate
and that's that's the flow so overall
what I'm doing this talk is telling you
about how I model design spaces in a
constraint program language called
answer set programming which how many of
you have ever heard of it before one and
a half and at point two five whatever
okay they'll all go into a more detail
later but you don't need to have
previously seen it or to make sense of
this you can actually replace a lot of
other technologies in there and still
get the same results i'm going to show
you three projects that are all tied to
a particular game just to keep things a
compact and coherent then tell you a
little bit about what other people are
doing with it and where i want to go
next so modeling design spaces don't
worry about as I said programming yet I
just want to talk about what design
spaces are in my vocabulary so a
what is in a design space are different
artifacts these are things you could
construct and you if you're thinking
about the design space of futuristic
chairs you might have our representation
of these artifacts in terms of
parameters described in the lengths of
edges the the joints and radiuses of
curves and so on and in that
representation there are lots and lots
of alternatives maybe there are ones
that I can point again they're upside
down they're different colors they're
stretched their wide they rotated a
different way so these are sort of like
all possible things you can come up with
that representation what I call a design
space is sort of the the set of
artifacts the design designer thinks are
applicable for a particular design task
just because you can represent an upside
down chair doesn't mean that the chair
is automatically appropriate for the
specifications you've gotten today so
the design space is you know fuzzy sense
that is only over in your head the set
of artifacts that you think is
appropriate and if all the artifacts
could be described by a small number of
continuous degrees of freedom you could
literally write down some like linear
constraints and say like here's the
polytope of valid chairs but of course
things are not that simple this is just
my sort of a visual metaphor for a
representation of the design space so if
you put in a new chair for example this
design of an extra tall one you can say
well is this inside or outside the
design space which constraint is
rejecting it if it's not or maybe
projected to its closest valid thing and
show me that one or you can say well
there's a lot of volume in this space
that I haven't checked myself because
I've only looked at six chairs so far
show me some other things in that space
and I'll pass judgment on those and say
like oh that one's interesting but it's
not a chair at all or by sampling things
that are in the volume of here you get
prompted to add and remove and refactor
your existing constraints and of course
I said like this idea of having with
this picture I was like three continuous
degrees of freedom it's it's not that
simple in order to express really
interesting and apply design spaces for
the projects I have coming up you got to
use a much more interesting constraint
modeling paradigm than just linear
constraints and what I use is
thing called answer set programming and
I'll spare you the history of NC State
programming coming from the AI
literature and knowledge representation
it's basically a declarative programming
language for divining defining a space
of solutions and we're going to apply it
to modeling the space of valid artifacts
or appropriate I make this really
concrete hopefully you've all seen a
graph coloring problem before yeah so
you could think of sort of a generate
and test process where we're going to
generate all possible colorings and then
we're going to test whether we
accidentally colored two adjacent nodes
the same color and reject them otherwise
and perhaps we might want to minimize
the number of colors so this is sort of
a specification for the problem and I'll
show you how to translate this into a
few lines of of ants prologue the
language of answer set programming and
so those guests reduce forbid things
translated almost one-to-one into rules
here I'll tell you about the details in
a second interesting problems usually
break down into the similar guest reduce
forbid paradigm but there might be like
a hundred lines in each one or something
like that usually these things don't
ever get very big but just so that this
strange language makes sense to you just
talking about the first thing here this
is sort of saying if n is a node it
implies that the set of colors that are
that are assigned to it has Carnell your
size one so you can think of this is
like actual logical implication area
arrow and this is sort of quantified
over all nodes and in our graph this is
not giving you a recipe for which colors
to assign it just says the what what
makes a valid assignment in terms of
things having exactly one color from
that particular assignment represented
with the assign predicate we can sort of
project out or extract the set of color
used across the whole graph which will
later down here use to define
optimization metrics say minimize the
account of those colors likewise if you
write a rule here that has no head to it
this is how you forbid configurations so
if we ever find an edge between nodes
and 1 and n 2 such that they're assigned
the same color well then this is an
invalid assignment and it should be
thrown out and of course this this
program doesn't run top to bottom
these get translated into something
historically they did get translated
directly into the input for a SAT solver
these days there are specialized answer
SAT solvers that are less indirect than
that but the simple ideas translate into
a constraint program and then someone
else's algorithm that they've spent
decades working on Saul's it more
efficiently than I ever would skip over
those things did I say enough about this
or you curious more about the code or
I'll go on okay right so the the very
last little bit of that is that these
solvers are very much like sadder SMT
solvers so when I model say a programs
at this problem in in this paradigm
using basically the same technology that
lets say sumeet might use for four
programs of assistance one yeah and
instead of reasoning about the colorings
grafts we're going to reason about the
design configuration of artifacts so
let's see this in some concrete
applications these projects I'm use it
for are all part of tied into a yeah
they're all tied into this game called
refraction and I'll give you a little
taste of the mechanics so that you know
what the examples letter mean so this is
a game about teaching the intent is to
teach kids fractions we don't know
whether it actually does that or not but
it's definitely a game that involves
fractions the idea is that you start
with the board like like this there's a
laser with Power Beam or with beam power
one coming out and you can use pieces
like these to split and combine this is
like dividing and adding fractions you
have to keep track of denominators and
so on but there's also spatial
challenges like trying to collect
secondary objectives or the beam can't
go through these fixed asteroids and one
of the other twist is that you're not
allowed to rotate the pieces so
sometimes you'll make the right power
but you'll have to find another way to
construct that same fraction from
another direction so there's lots of
cool traps you can set for the player so
when you're playing this you're picking
up pieces from what we call the tray
over there to build a network out here
you can also think of this is a little
data for program if you like but
specially embedded and your goal is to
prepare the fractions wanted by each of
these little spaceships with cute
animals you got
safe so in this particular game which
was made before i joined University of
Washington has been deployed online it's
been deployed in classrooms it's got a
bunch of awards as an educational game
millions of players so it's a very
significant project and we want to make
this game better and better over the
years and this has been my target for a
lot of automation research when you're
applying through this game or at least
the the original version of it you work
your way through these various worlds
each one has maybe eight levels and it
was about there were different versions
with different numbers of levels but
everyone plays the same levels in the
same order based on what our level
designer who happen to just be an
undergrad just making levels as to you
know to get credit or research
experience so it's not not the most
informed level progression but it's the
one we went with really we'd want to
have like the right levels for the right
student at the right time if you seem to
know something maybe we can jump you on
two levels that involve different
concepts or maybe we can give control of
these generate levels to a teacher so
they can say well I want every kid in my
class to play refraction today I want
them all to be doing two layers of
division but only things involving prime
factors up to three or something like
that but they don't need to design the
levels they just need to give us these
high-level specifications well so the
first project we talked about generating
customized levels and yeah as I said if
we sufficiently abstracted this we can
imagine giving control over this to the
teachers in the classrooms although it
actually turns out the teachers don't
really know what they want the game to
do any day so that didn't work out as we
thought most ill tell you about the the
technical end of it because it embodies
a lot of the other stuff I've been doing
so one of the things we wanted to do was
take one of our pre-existing levels from
the original game which we know works to
whatever degree it works and we want to
make lots of variations on those levels
without having any manual intervention
so for a simple level like this we might
at with this a problem of graph transfer
is extracting the graph from here
extracting the graph is not at all hard
you just parse the data structure and
then we're going to solve for different
embeddings or layout to that graph in a
new level so that when different kids
are playing everyone's say fourth level
into the game
would involve the same sort of
mathematical graph but their layout is
different you can't just recreate the
spatial configuration you see on your
friend's computer you have to talk to
them about like well how did you make a
half while I use this the the splitter
and the outer in so on or they use the
splitter into the adder into the bender
and so on as opposed to saying well you
put it in the top left corner which has
nothing to do with fractions so the way
we formulate this in excess a
programming also this this is a much
more realistic level from the game
involving like the graph is like 16
edges 47 nodes which that's sort of nice
is that the scale this problem is fixed
it's not we don't care to scale two
graphs with 10,000 nodes like kids are
playing it at on a 10 by 10 grid so we
need to handle that scale but we never
need a handle beyond that so before I
joined University of Washington a couple
grad students and some of the game
development staff were starting to make
a tool that could do this graph transfer
thing so they had this graph and they're
trying to produce one of these outputs
so they have like a little randomized
depth for search thing but that would
take some any node that was not yet
embedded put it in a random location and
then for all outbound things place
pieces a random distance along that beam
and if you get to get in you backtrack
or start over with different random
seeds and so on and for little problems
like this one oh we could solve those
you know instantly it could give you
lots of different embeddings they
wouldn't really tell you if it got all
of them but it worked but when they try
to apply it to real levels from the game
like this depending on your random seed
you might get it in five minutes
sometimes it runs for two hours with no
response it was like really unreliable
and they've been spending a couple
months on this already and it was
getting to the point where they need to
scrap this and just make use go hem made
levels forever or think of something
better there were also other
complications like they didn't support
all the original pieces and so on which
they would definitely need to do so when
I joined I thought well this is similar
to the design automation stuff I've been
doing the past let me see if I can model
this in answer type programming where
I'm not going to write an embedding
procedure i'm just going to write down
the rules of a valid embedding so in
terms of that vocabulary of guest deduce
and forbid for every piece in the
abstract graph that
the non spatial one we need to give it
an x and y coordinate we need to decide
for each little piece whether its output
ports point north south east west and so
on because that's part of the puzzle
configuration and from that information
we're going to decide the relative
configurations like if two things have
the same x coordinate and one has a why
more than other one it must be north of
the other one from the relative
positions we're going to figure out
whether there are free paths if there's
anything obstructing it will figure out
basically do the the laser flow
simulation on top of that and a couple
of other things like that and we're
gonna have constraints that say two
pieces can't have the same X insane why
at the same time we'll say they're
better never be an edge that occurs in
the mission graph that we extracted from
previous level that doesn't occur
reoccur in the embedding and a couple
more things like that and so to write
this down in something that was 100%
equivalent to the model of the game was
75 lines of code and it took about one
day to make the sort proof of concept
and another day of testing to make sure
it was exactly equivalent to the one in
the game so compared two months of
grinding and guessing random seeds and
trying to parallel eyes stuff this was
just sort of write down what you want
and you're done so this felt really good
and it also gave us a lot of flexibility
to add more constraints which is
important for this next step so a random
solution to that that reham bedding
problem might look like this this is
also a totally legal and valid thing all
the pieces are scrunched up on the Left
all these pieces for no good reason are
in a row according to all the rules that
I told it this one is valid and with
some random seeds we would get a thing
like this so when we started getting
results like that we realized that we
have additional constraints a sort of
aesthetic constraints now we can get
outputs like this one where there's like
spacing between everything the blockers
arranged symmetrically and so on or we
can decide whether we want symmetry
balance and spacing on a level by level
basis just by making a little detector
for whether things are next to each
other and saying if it has a property
it's not spaced properly and so on and
rejected so yeah we started getting into
the more aesthetic modeling after we got
all the gameplay stuff done and transfer
a grass from one level to the other was
just one of the many tools that we
needed for refraction
so instead of making a separate little
answers head program for each one which
we did for a while they were all small
pretty self-contained but they were
expressing essentially the same ideas of
like the game mechanics plus other
constraints we sort of unified all those
into one thing which was a Justin it was
twice as big as any individual ones who
replaced a lot of other ones we just
sort of wrote down the rules of this the
space of valid puzzle and solution pairs
sort of all configurations of pieces
that formed a solution under any
constraints that we put in so if we put
a constraint on what the mission should
be or put a constraint on which
mathematical sub expressions are made
depending on what we put in as
constraints we can use this one
constraint program to make new mission
graphs new embeddings of existing ones
we can have it search for alternative
solutions that do or don't practice
other concepts for a fixed puzzle we can
analyze partial solutions so that when
you're part way through solving a puzzle
we can say are you sort of on the path
to a solution or is there some piece you
have to pick up in order to make
progress and we can detect that on a
move by move basis and we've also play
around with with variations on the game
mechanics because we don't need to make
graphics for things to try them out here
we can add a new piece and see how it
affects puzzle design sort of in the
abstract so as a result of this the
refraction team no longer writes search
algorithms they just design games and
write down definitions of those game
rules again so this next project deals
with sort of coming to grips with the
actual interactive nature of game design
which was overlooked yeah did you also
measure that the difficulty of instances
in the same level but indeed the same as
view from God's perspective did not
measure that or rather if we had it
would have been sort of things like this
where I'm sure these levels have very
different difficulties even though they
technically have exactly the same graph
so we had no expectation that
transferring the graph meant
transferring difficulty we did know that
it meant transferring mathematical
expressions but it was basically from
the experience of this we knew that
there was so much variation that we had
not modeled it all yet that we weren't
interested in evaluating whether it
transferred the difficulty or not to
this day we still don't know what to do
about difficulty it's an extremely
thing there are certain proxies for it
like just how many pieces or does it use
numbers you're not familiar with yet and
I think to really evaluate that we need
some like actual player models to go
with this which I'll mention a little
bit later but at least at this stage we
knew we didn't have a handle on the
thing that would tell us anything by
difficulty on a night this addition to
measure this so you just have no do they
may be testing night you have two
different routes of people you give them
two different instances of the same
devil and you see the statistics off or
they perform that would tell us about
that one other instance or that one
alternative progression whereas like if
we went from this thing depending the
output might look like this for a might
look like that and those were all very
different things so if we did a bee test
it might say that this one is easier
than that's this one but that is not
reflecting on how we generated it at all
it like basically a beat esken can only
tell us about the instances and not the
system behind them I mean we could have
done that study I really just didn't
want to do it because I knew it would
only tell us about the effects of
whatever random see we started the
solver with the day or at least until we
started modeling these things later and
I'll talk about that's going to come up
a little bit later so I want to go on
from that right so we have this sort of
model of the game and then we just have
queries against the model to make a lot
of our design tools so this next project
deals with sort of a major oversight we
had in the previous formulation of the
problem previously we were really happy
to get levels like this like oh it's got
symmetry and balance and spacing it
involves splitting the laser and
recombining it Oh kids will learn that
if you split something in equal parts
and combine them you get the whole back
well it's not actually that simple if
you give this this puzzle to kids they
might find this other solution where you
don't split you don't come by and
there's no spacing this is no symmetry
all of the beautiful properties of our
one reference solution turned out just
to be the sort of wishful thinking mode
and controlling whether there exists
alternative solutions with certain other
properties involves changing formulation
property in a way that totally changes
the complexity their problem and to make
this more concrete and a bit more
general I'm going to introduce you two
characters you can think of is working
together on a game design team the the
first
is Elise she's going to solve sort of
problems that are quantified with an
existential quantifier her goal is to
design a level that is capable of
supporting the required gameplay this
could be you can tell at least please
make me a level where someone's splits
the laser and combines it or basically
her job might be to make this one on the
left or the intent of that one and a her
design partner here is fiona is going to
solve problems with a for all quantifier
and she's the Quality Assurance tester
given a particular puzzle she's going to
actually check whether all solutions
really do check that property so given
these two characters will sort of
formulate the problem logically so the
basic puzzle generation problem or the
setup used in a lot of procedural
content generation stuff in games is
given some predicate that will call
style could be any property you can
check in polynomial time show that there
exists some puzzle piece us that this
predicate said is true of that thing
whether it could be balanced spacing it
could be that it did or did not involve
the sub expression of the mathematical
expression did it come from a grammar or
something like that and because this
problem like exists something such that
some polynomial time checkable property
you can hand this off to a Sat solver
and sort of replace or mechanized at
least his efforts with a software that
complexity you can also say well for a
given puzzle we can tell her to act as a
as a player find a reference solution to
this puzzle not not shown the puzzle not
shown the solution beforehand such that
the reference solution solves the puzzle
and it demonstrates the concept on that
particular puzzle and again it's not
important that they're called solves in
concept they could just be any
polynomial time checkable properties for
us it was sort of like when you simulate
the mechanics does this little sub graph
of the laser graph exists you can also
combine these two say well just invent a
puzzle out of the blue where someone can
practice this this is how we formulate
it in the past so we can say now invent
the puzzle and it's a reference solution
that's basically the tools we had before
so even though this is involves making a
bigger thing not just the puzzle but its
solution the same time it's still a
problem of the same class it's still in
in NP where things get interesting is is
when you wouldn't want to involve Fiona
to check the lack of say these shortcut
properties that leave out the concepts
you want don't want we want to tell her
given a particular puzzle probably the
one that that that at least just made
proved that there does not exist in an
alternate thing that solves it but
doesn't demonstrate whatever concept
we're trying to demo and if you
rearrange the quantifiers a bit you can
express this as a for all basically want
to say given a puzzle prove that solving
the puzzle implies practicing the
concept this is what we really want for
our educational games and we didn't have
the insight to formulate in this way
until we basically made all these tools
that formulate it the wrong way and
really we want to put these together we
we don't actually we could make one
program that models Elise another one
that models Fiona and have like a
generating test pipeline and then we
actually have to make the two separate
things really we can just write down
what the team should do together and
hand it off to a solver that can handle
problems of this complexity so we want
to say there exists a puzzle and the
reference solution that we're actually
gonna look at with a guarantee that for
all of these other solutions the
reference solution is valid like it's a
good reference solution and anything
else that also solves that practice is
the concept this is basically showing us
that are that are reference solution is
representative of whether the concept
was demonstrated or not and anytime you
see a problem where you have exists some
variables such that for all some of our
variables and then some quantifier free
garbage there this is like a the two qpf
problem this is sort of like the one of
the the canonical problems at the first
sigma to be complete if you want to
think of it this way it's the the extra
difficulty of solving something in NP
compared to just some polynomial time
algorithm if they indeed are different
that same gap do that again to figure
out how a complex this thing is so it's
a very complex problem from a complexity
theory
perspective but in practice we implement
it for our new game we still get
solutions in under a second it's very
responsive and this comes from the idea
that because our design problem is
attached to a real human context the
scale is sort of fixed to what is
relevant to those humans we know we're
only dealing with the 10 by 10 world and
we never have to change that so this is
an example of one of the the outputs
that was generated from this this new
formulation and this the concept was
that every target ship draws power from
every source this sort of means that you
can't solve any piece of the puzzle in
isolation the you can't just like route
this source of power 12 that thing of
power 1 and then work on the rest there
are thousands upon thousands of ways of
solving this particular level but none
of them escape this property that
there's one entangled network and if I
gave this puzzle to you to solve like I
put the down the six pieces and let you
drag in the rest you probably spend half
an hour finding the one solution can you
imagine if your job was to be the QA
tester and promised your boss that oh
yeah I checked all the solutions and
they all require this property like it
took that was that hard to find one you
have no assurance that that this
property holds for the rest other than
that you tried hard whereas we just hand
it off to a theorem prover in it it
gives us that assurance in order to
express this and answer set programming
which technically can express things
that this level complexity is just
insanely difficult and all the manuals
even targeting AI researchers say don't
use these features unless you absolutely
need them so I basically made two new
language constructs that you use when
you're writing and answers have
programming in order to make these
actually usable by people who are not
researchers they were named with
reference to this this design test so
people know how to cast the problem in
in the same formulation with elyse in
Fiona then they can use these language
features to express what they want with
minimal additions to the language
basically I've got a little program
translator that you write the program
with my language extensions and I
transform it into one that has the right
semantics then we feed it off to the
solver oh and because this is made
formulating this type of problem easier
I've actually run into people who are
using
this library which supposedly I made for
designers to use their AR researchers
using it in their multi-robot path
finding stuff just because it's
convenient way to express Universal
quantification announces have
programming finally that's just a weird
twist so the last project looks at
putting all these things together and
putting sort of a human interface on top
of it and it definitely builds on this
idea of the concept that we want to
require it each time so in a puzzle game
where many other games this is thing
called level progression the set of
challenges you go from one to the next
throughout the game and when you're
designing these it's really important to
keep track of which concepts you
introduced when if you're trying to if
something is really difficult you might
wanna delay it until the end when until
people have mastered the prerequisites
for it earlier so keep track of which
concepts are introduced is is really
important when you even when you're
designing these things by hand which is
basically the only way people ever make
level progressions now until now so this
is a zoomed-in corner of a really cool
diagram that that me and the other
researchers found about two years ago
this is a diagram of the level
progression for the game portal 2 and
the way you read this is sort of this
axis described which mechanics so this
says grabbing using portals using the
weighted storage cube switches panels
and so on and across the right is time
sort of which level you encounter these
things so now I'm going to zoom out so
you can see the whole thing and on a
nicer projector like when we saw this
we're like oh we wish we had this for
our own thing because at a glance you
can say well on level 11 it uses I can't
even read these things to there too dark
but on a good screen you can say like oh
it definitely uses these concepts it's
continuing to use this one that was
introduced previously the little yellow
spots or the first time that thing is
used so you know that level 11 better
provide the tutorial explanation for or
at least the guidance to have them
figure out whatever the new idea is or
you can sort of slice it another way to
say like for the switches mechanic these
switches I can open doors and so on
where they use are they used on at the
beginning did we forget to bring them
back in the end of the game so certain
things like this diagram makes it clear
that whatever these concepts are sort of
just got dropped for like ten levels in
a row and then got brought
a little at the end and there are some
that are basically used once and a few
other times so like there's a really
broad perspective you get from a diagram
like this that we wish we had for our
own game we probably wish other
developers had for their own games this
chart was not made by the developers of
the game this was made by a fan of the
game about a year after the game came
out so though designers did not have
access to this visualization they
probably had scribbled wide dark
whiteboard notes that were out of date
and so on because constant requirements
are constantly changing but we wanted
this for our own game but we don't we
don't actually know who made it or we
don't know what countries into having
make it for our own game so we would
have to make it by hand and better than
that we'd like it so that whenever we
hand touched any of the levels that
maybe a little thing would pop up here
to say like oh it you've modified it and
also maybe we'd like to be able to take
one of these bars here and just drag it
over and have it sort of redesigned the
levels underneath to make that level so
that this is sort of our design fiction
like we wish we had a tool that could do
that and well if we had such a thing it
would be an instance of what's called
mix initiative design the idea is that
you want to combine a human touch to
direct manipulation of a visual notation
on the screen as well as the ability to
touch all the little details of a design
with the inspiration assurance you get
from machine via synthesis and our
automatic play testing based on the
tools already told you about so we
wanted to make this intelligent user
interface that sort of previously to use
all of our design tools you'd be adding
constraints to a file and running
command-line tools we just wanted to
make it tangible so that again our level
design honor grad could have some better
tools so I'll show you some of the
visual notation from this tool these are
screenshots of the real thing so this is
a little widget that describes the the
partial order concepts a little blue
thing here says that I think this says
that adding must be introduced after
splitting that splitting must be
introduced after bending and so on so
this sort of across all possible
progressions this is sort of sculpting
the space of progressions and there's
also pacing things like we have many
different curve editors here and you put
in your design intent in blue and then
it visualizes the current state
the design relative to that target there
and shows you where your your furthest
off from it the next step is the
progression plan this is like from these
sort of high-level sculpting of
progression this is a plant this is not
the actual set of levels this is just
sort of your your sketch of what which
concepts will be involved in which level
and we borrow that same notation of the
little yellow is the first time things
are introduced so as before like a
column here says that level 20 is going
to involve splitting bending walkers and
this will be the first one that
introduces the wasted lasers concept and
of course these are exactly the inputs
that we feed into our level generator
and at the last step each one of these
vertical slices here gets it corresponds
to an actual concrete level design so
that's when you're using this tool that
we made your sort of jumping between all
these scales at once and I'll show you a
little video this in action I think this
video just shows using some of these
high-level sculpting things like
changing the total concepts used over
time and having it sort of rearrange
this for you until we've looked at the
details they're all free to be changed
by the tool not shown in this video's
you can press the little L we're
supposed to be a lock icon to lock these
things in once you like them and have it
optimize the rest to fit the other stuff
so it's not like this is your only
control early on in the project we were
hoping that oh we could sculpt the whole
game using just these beautiful curves
here it's like no you still always want
the lowest level control if it's gonna
be played by million kids but we do like
to convenience of these things for some
of the high-level sculpting okay so in
this next one I'll just like what
happens as it goes yeah so we're going
to put in a partial order on the things
the the red thing says your current
thing actually violates those
constraints you told me about so you can
say hey fix it for me and it's like oh
that's pretty good and then that
particular plan we run our level
generate to flesh out levels that even
if they might be ugly they don't have
symmetry balance whatever they at least
have whatever design trick it is to
require that concept then if you want to
change spacing or rearrange it or rotate
or whatever you can do that and then the
tool and then the next video you'll see
someone go in and make a
from the sort of drill down into a
particular level we're going to change
this to splitter into a 3 splitter which
leaves a laser unused out on the side
this is this concept of wasted lasers
maybe we didn't mean to introduce wasted
lasers just yet we want to delay that
further in the game so the tool after
our manual edit will show a little
pop-up thing here in a second and that's
about its response time say like oh I we
did exhaustive playtesting here there's
actually a way to there's no way to
solve this level without wasting a laser
you're like well that actually was what
I wanted even though a violet of my
thing lock that in and fix the rest of
the stuff that I haven't walked in yet
to do that so it's not like you're a
slave to your own constraints you can
you can ask for conflicting things you
could say I wanted this high level thing
but no I definitely want that concrete
thing somehow negotiate between the
requirements I have so this project
definitely the flavor of the
requirements and the design process are
shifting from minute to minute as we
drag and and do other stuff so putting
these all together to go from the
partial order and this these sort of
pacing constraints to these this is a
constrained optimization task which was
I don't know 50 line answer set program
that we wrote in an afternoon not at all
anything really difficult and then to go
from a particular column of one of these
to a concrete level that's using our
pre-existing space of levels and
solutions under certain constraints
particular under the constraints that
these must be required concepts after
you make any manual changes we then lock
down the puzzle and say is there a way
to solve it that avoids any of these
things rather if not then then it is
required and then that's how we update
the display and then based on how the
display is updated it's just some
evaluating the distance from a spline
and so on to check whether these there's
no real intelligence going that
direction but the important thing is
that if you move a single piece down
here it can tell you that that single
piece cause a high level change
somewhere else and alert you to that
within a few seconds so we did deliver
on this mix initiative design idea and
importantly we didn't think of actually
building this tool until we had all the
building blocks sitting around
like when we made that tool we spent no
time writing combinatorial search code
we spent all of our time implementing
sliders and tabbed you I pains and stuff
like that it was surprisingly difficult
to make a nice responsive system that
communicated to a solver on the back end
but we would never have put in that
investment unless we knew that the
things that from a computer science
perspective are the hard parts yqy
programming is not hard from a
complexity perspective it should be the
search that's the hard part turns out
the UI pogrom is hard but yeah until we
have these building blocks around we
didn't think to to make the the
high-level tool so what I like to do is
show these sort of proofs of concepts of
what sounds like the hard parts so that
people trust those enough to actually do
what is the really hard part and I've
been showing all these examples in
refraction we've also applied this to
refraction too and the game that came
after it which have slightly different
rules for how fractions works fractions
work you can now rotate pieces and other
weird things we pled it to this another
educational game this one focused on
algebra called dragon box and one of the
fun things about dragon box is that the
the state space of the game is infinite
in the sense that if you want to you can
just bring new cards out from the bottom
of the deck and sort of create new
things on the fly it's not like just
spatial arrangement of existing pieces
so we had to come up with a sort of a
symbolic garbage collector that reasoned
about like all possible ways to play it
assuming that you can always make new
cards but that you probably never need
to use more than 20 and so on we've
applied this to word problems where
there's interesting mixture of math and
natural language constraints at the same
time and plugged it into a prototype
game that it has a new name now instead
of algebra adventure forgot the name but
the dream with that one is is that we
would write down constraints both on the
math involved in the problems the
language used to describe in the
sentences the problems like saying twice
versus double or x 2 or something like
that but also have story constraints
like this character better do something
evil and scene 3 while you are also
solving for something that is an
intermediate negative result or
something like that we're not there yet
but we have a lot of the prototypes of
the interesting parts turns out of
course there's lots of you I programming
involved in a being able to drag symbols
out of the text and put them
together and so it's interesting change
of scope in that yeah so that that's the
end of sort of the concrete projects to
tell you a little bit about the external
impact because I know let's see well
just add a couple different universities
there there are now graduate level
classes on content generation that
include the design space modeling sort
of paradigm and basic introductions to
answer set programming as their core
curriculum curriculum students coming
from those classes are getting higher to
places like Microsoft more Microsoft
Microsoft Studios than the name s are we
have a textbook chapter coming up which
will sort of solidify the inclusion of
this is like this is just how you
automate design now even though this is
relatively fresh stuff and their student
research papers coming out and I should
update this too there are now students
who have gone past their thesis proposal
like they're continuing this is their
primary research so that feels really
good even though this stuff is is new so
a tiny bit of information about future
directions of course I'm interested in
having better tools and training
currently if you want to teach yourself
answers to programming you find these
books like written by logicians for
logicians and the practical parts of
them assume you're going to be a very
logic oriented AI researcher and so on
and like I can't just hand these these
books used in grad AI classes off to
somebody say working at marks of studios
like they just are missing the
background and it's they I don't even
want them to learn it through that route
so I want to make a different sort of on
ramp into these technologies making sure
that they are also accessible there are
concrete examples related to design and
so on I'm going to continue direct
collaboration with designers and
researchers to make either games that
couldn't have existed without this or
tools that couldn't have existed without
this and have videos of them some people
in see like oh the refraction design
team had that cool tool can we have that
for our thing until they had seen that
it exists they probably could even know
what to ask for or what to try to get
permission from the rest of their team
in another dimension the one I'm going
to say bit more about is probabilistic
modeling because so far
said that artifacts either are or not in
the design space really we might want to
have to soften that and we don't want to
just go back to the idea of like there's
some generic utility metric because
that's a little bit too generic doesn't
tell us anything about design so I think
attaching the propolis text or is useful
one thing you can do here is model
statistical elements of style lots of
people doing music generation stuff have
you train a model on say market model on
the chord transitions used in Bach
Corral's or something like that and then
sample from that distribution so there's
lots of uses of statistics in in
generative modeling for more aesthetic
stuff and I'd like to do that so that we
could do that for transfer the style of
our handmade refraction levels or other
games another thing we'd like to do is
is right constraints about uncertain
outcomes the main use for this would be
in player modeling if you it's not that
players will eventually construct all
possible solutions they will tend to do
the more obvious things first or you can
say with eighty percent probability
they'll keep continuing what they're
doing with twenty percent probability
they'll pick up the piece and try a
different thing if we can write down a
model at that perspective then we can
then have not just a constraint program
that represents that the set of
solutions we can have a distribution of
our solutions and say well this level
has a shortcut but what is the chance
that someone watch to do it it would be
like if it's astronomically small oh
whatever it might as well be zero or we
can have something that's that's
solvable in two ways but we want to make
sure that the advanced way is less
likely it's only all right it's much
more likely to be found by people who
actually know the concept so this is
eventually we get back to things like
like difficulty and or inferring whether
people know things but only after we've
gone through probabilistic modeling and
the last thing would be that being able
to give positive negative examples and
from that sort of inferring some of
these conditions of appropriateness
instead of saying I'm going to write
down in formal logic what makes a puzzle
appropriate I know how to write down the
rules of the game to say what is valid
or not but I don't know how to make some
of the style things felt hokey when we
would write the symmetry constraints and
so on so doing that from data instead of
just our own guess would be useful and
then this other side is what they're
gonna say about this oh right in the
same
way that I separated the definition of
the space of artifacts from the
algorithms that search it I would love
to the second one in a machine learning
problem separate the definition of the
space of hypotheses particularly on the
under their likelihood for given said
data from the algorithms to to search
that space of hypotheses this is the
same setup used in support vector
machines where you just sort of write
down your machine learning problem as a
constraint problem hand it off to a
quadratic programming engine and it
gives you the optimal answer let's see
and I think this could also change the
way that you teach people about machine
learning if you never get into or if you
heavily downplay the particular
algorithms use and just talk about what
makes one hypothesis more likely than
another on data and so on and that could
potentially make thing a lot of machine
learning idea is more accessible to
people who aren't already thinking about
algorithms so some brief takeaways here
inside of every design problem is a
search task it's not the essence the
problem it's often the tedious part that
that task ranges from hard to insanely
hard from a computational complexity
perspective but nonetheless you can
still solve these very quickly because
they are always at least four games at a
human scale and despite this complexity
we should mechanize design because of
what it gives us an extended creative
reach just to see and ask for new tools
to see and ask for new games and the big
idea here is that by modeling the space
of artifacts when I'm calling the design
space instead of inventing algorithms
you get new design automation tools what
feels like for free just by writing down
what you want so thanks any questions
yeah so um I haven't fully thought
through this question yet but all the
games that you showed have like um
deterministic dynamics I might say so
like so in applying the approach to a
game that said may have like real time
by members like maybe you have to not
for like real-time physics or like
players involved um how would you
necessarily need to sort of Regan
sexualize the design space I think it's
it's all a matter of representation like
I'm not particularly married to answer
sir programming's representation that
works for discrete deterministic systems
really well but that's sort of the
opposites of that are stochastic systems
where there's definitely probability
like in any of these RPGs where there's
like you roll a dice to figure how much
damage you get or in a you know say a
racing game where it's all about
position and momentum and skid and it's
all vectors and continuous spaces you
would use a different constraint solving
back end but I think the same idea of
modeling the space of what's appropriate
or locking down the design and modeling
all the ways the player could interact
with it under some abstraction whatever
you don't I have a new project coming up
where I'm analyzing the actual native
binaries of things but I'm not going to
say I'm going to apply that to like some
giant racing game or something like that
you would always apply it to the
abstraction that is relevant to the type
of design thing you want to do but yeah
it the stochastic and continuous are
areas that I've not represented all yet
but I think with a change in the
constraint solving technology still fit
and it is there possibly when you get to
the the level of trying to do the the
third step like the human midst
initiative thing or maybe some of those
spaces harder to abstract with others um
well I think some of the ones like when
I showed the the progression plan of
light which concepts are involved which
level like that transfers to many other
games like zero changes at all because
progressions themselves are these
discrete I mean you could have branching
story things that are not like a stripe
but they're more interesting graph
structure the
where it gets tricky is we had this
pre-existing level editor for refraction
levels that actually took like six
months make is this horrendous like
complex thing and we just sort of
embedded that in our larger tool that
you need to have you need to have the
sort of manual authoring tools in place
plus an engine that can do simulation
for the game and if you have those
things you can bubble them together to
make the the rest of your design tools
and that's a lot to make particularly
for new genres so I'm hoping that as i
get in contact with say people the
vendors for game engines working with
them so that they're sort of like the
real game engine you deploy your game
with and then there's sort of a symbolic
replacement that you use during analysis
that abstract sout the physics I mean
that's a big thing to do abstract to the
physics there there are things you can
do you can say there are logical time
sex things move along straight lines or
move along and like parabolas and so on
for a platformer there are lots of
there's tons of work in symbolic
computation that is just like game
development people just don't even know
exists so I'm sure there's tons of
low-hanging fruit in terms of
possibilities to combine those see me
let me talk of educational games of
teaching programming uh yeah well well
so I was heavily influenced by that last
minded doctor brain game and I played a
lot of minecraft insulin and I've
actually made circuits in it and I think
oh one of the things was that when we
were playing with different variations
of refraction we realized that
refraction is sort of only about
fractions on the surface unlike the
labels that say one half and one it's
really like a dataflow programming
exercise embedded in a space so like the
splitter node doesn't have to split
things equally it's just a function has
one input and two outputs that don't
even necessarily be the same so you can
you could map other types of computation
into exactly that that same shell of a
game but I think other things where
people are building a state machine
watching watching to execute and then
there is if I go back to we wish not
moving in there are plenty of games
where there are find those things the
beginning
I might have been a faster way to get
back so in a game like spacechem you are
building basically multi-threaded
looting programs that communicate like
this is just one view and inside of one
building at a larger map and each one of
those has multiple looping tracks this
little bracket shape here sorta like a
program counter that goes by doing those
instructions so there are definitely
games that are played not by people to
learn to program butters as an
interesting puzzle game that involve
like very deep program or type reasoning
as well as debugging and one of these
tools down here which is essentially a
break point and I don't remember where
that button is but you can set it and if
the program counter ever gets there
pauses you get to inspect things and
continue a company called zakat rocks I
believe they are somewhere in the
northwest if not like some wine Seattle
it is a it's a it's an indie game it's
not as it did I'm sure it's so the
million copied is not a hundred million
or something like that and most people
don't play it all the way through but
this is another game that has fixed
levels that were designed by the small
team that made the game they do allow
the community to make new puzzles and
that those people uncover new design
possibilities and so on but nobody's
working with any sort of assistance when
they make the puzzle they don't they
can't even be nice if they could say
when I make a puzzle at least show me
one reference solution and then I will
try to find make features of that
required or forbidden and so on whereas
people might spend an hour sort of
debugging their puzzle in development
before they upload it and I don't think
you would necessarily use this in an
early programming curriculum but it's
definitely but there are games that
people already making that have these or
like I showed these ones before in
manufactory you build this thing that
basically sorts robots based on this the
contents of their internal tape and it
basically does sort of a randomized
testing like if you're a little
contraption with conveyor belts and
switches passes I think 10 or 100 test
samples then it's considered a valid
solution so like the really
aggressive way of playing this game is
making solutions that are incorrect but
will pass the test on with a certain
livelihood really it should be doing
something like giving you the test that
it knows will break your thing or it
should be doing that with that with some
probability or something like that but
the people who made this they're they're
just flash game developers who don't
have knowledge or access to the the same
type of automated testing you would have
for for more heavyweight things and I
think those people just need to know
these things exist and they need to have
them cross compiled so they can be used
in flash that's another thing it's like
a lot of these cool formal methods tools
assume like are not meant to run in the
flash vm or whatever so i got an answer
SAT solver to run in a browser only by
cross compiling it into javascript so
i've got this like five megabyte
javascript file which is the solver and
it runs 50 times slower than native
about but it works and for small demos
maybe that's fine or for small games
maybe that's fine but that's like a
requirement that doesn't normally come
up when you're not deploying things to
restricted environments any the bushes
yeah but a gospel she yeah so getting
conned a little bit more on the
scalability of SP the yeah so there's
sort of two at first when I was thinking
of if I can find one of my pictures of
people would often ask uh like when I
showed them like the the ten by ten
levels of refraction with 16 pieces and
however many other non movable pieces
that the questions well like well how
does it scale to larger things and from
the first kind of scaling to large
problems is one that because of the
human context doesn't actually come up
the the kind of scaling that's actually
more interesting is like how else are
started before going to that there were
certain representation tricks that we
learned in this one like instead of
representing the position of a piece
like with with a predicate that says it
is true that this piece had x-coordinate
six we represent that six by its binary
representation and as a result of that
change of representation now we can
handle tremendously large grids we can
say oh the
for only adding 30 2 billion variables
to we can now represent two to the 32
possible positions this is which I mean
we could have also gotten that benefit
from switching to a numerical constraint
solver instead of a William constraint
solver so there there are certain
spatial dimensions of scalability that
with the right representation totally go
away we would never care about a problem
where there are like 10,000 puzzle
pieces because no human is going to play
a puzzle that they have to first of all
just movie each piece 10 doesn't do a
minimum of 10,000 pieces just to move
them even if they knew the right
solution right away so that dimension of
scalability isn't one that we ever care
to tackle the the harder one is how do
you get people who have just taught
themselves this stuff last six months to
get them to write efficient and compact
logical and coatings because that's
something I know how to do six eight
years into this but that knowledge is
not written in any useful book because
all the books are about their improving
in the abstract not like writing compact
and efficient things so maybe in the
future languages that are more
domain-specific that it'll make it so
easy to shoot yourself in the foot would
be a response to that but usually the
thing that saves you is that if it's
attached to a human consumption context
you never have to select scale to
infinity n is always finite it might be
10 it might be a hundred or ever but
it's fixed</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>