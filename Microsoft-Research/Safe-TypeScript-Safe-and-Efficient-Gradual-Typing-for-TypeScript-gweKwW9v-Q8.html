<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Safe TypeScript: Safe and Efficient Gradual Typing for TypeScript | Coder Coacher - Coaching Coders</title><meta content="Safe TypeScript: Safe and Efficient Gradual Typing for TypeScript - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Safe TypeScript: Safe and Efficient Gradual Typing for TypeScript</b></h2><h5 class="post__date">2016-06-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/gweKwW9v-Q8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year Microsoft Research hosts
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
all right well thank you all for coming
to a scene Rastogi end of internship
talk seems been here for the last three
months and has had a super productive
summer working on safe typescript which
he's worked on pretty much for the whole
year actually since last summer and
we've also spent some time this summer
looking at a secure multi-party
computation so this guy seems had this
sort of double header sort of internship
so he's gonna tell you today about safe
types rate are type safe version of the
tightrope compiler okay thanks Nick good
morning everyone thanks for coming
my name is Asim Rastogi and I'm a PhD
student at University of Maryland
College Park where I'm advised by my
cakes so I'm going to talk about as an
excited about safe type script which is
joint work of course with Nichols for me
okay so typescript it's a language from
Microsoft and the goal is to improve the
state of the art in JavaScript
programming it's a gradually typed
superset of JavaScript and just putting
some quotes from the typeset website it
gives strong tools for large
applications such as static checking
symbol based navigation auto completion
and refactoring and so on it provides
classes modules and interfaces to help
you build robust components and it
compiles to simple JavaScript and
compared to current JavaScript
programming this is a great leap forward
so if you are still writing JavaScript
code I would strongly recommend you
using typescript okay but type in
JavaScript is in a way hard because it
has so many dynamic programming idioms
that assigning it that having a sound
type system is hard so typescript like
its counterpart start and closure
intentionally gives up on type soundness
what that means is when the company when
the code is compiled to JavaScript all
the types from the program are uniformly
erased and that leads to unsoundness
because for example town cursor and
checked at runtime this unsound type
nature has some benefits you get very
lightweight codes and
raishin so the produced JavaScript is
readable it's in one-to-one
correspondence with the source
typescript that you write since there
are no runtime checks the performance is
identical to what it would have been had
you written plain JavaScript and finally
types do not get in the way of good
programmers so if you are a good
programmer you can get around the type
system and if you know what you're doing
but this on some type editor comes at
some cost and the cost is that types of
components are not robust okay so let's
make it a bit concrete on what I mean by
typescript components are not robust
let's say I'm a service provider I have
some variable X which encapsulate a
state which is let's say an array of
numbers there is an index which is the
current index into the array and index
is a number and it has a method next
through which I expect my clients to
navigate through this array so next just
returns whatever is the current index
and increments the index and as a
service provider my expectation is that
clients will only use this variable X at
the interface of this I traitor so I
define an interface I traitor it's a
generic interface which has a method
next and I call the client with this X
variable of mine only if clients have
this expected type and then my
expectation from this robust interface
is that clients will respect my
abstraction but is it possible in
typescript well unfortunately no so
here's a client code which has a correct
type it takes an iterator to number but
in the body it just writes a dynamic
field index and assigns it to true
thereby breaking the abstraction now
this is a well type types of program
types are it is uniformly it compiles to
JavaScript and there is a type safety
violation because I expected the clients
to use only a titrated interface but
they can write dynamic properties but
not only this in fact I want a stronger
guarantee I want that client may not
should not be even able to see my index
field so even if it writes a number to
index I want even that to be prohibited
because I explicitly said that you
should only
my next method and knock and not muck
around with the index at all so as
expected from a robust interface I would
like clients to not even access my index
field and this is an abstraction
violation and in type slip it's not
possible to do so currently okay so in
this talk I present safe typescript
which is a sound inefficient gradual
type system for typescript we
demonstrate that contrary to the popular
belief sound soundness and efficiency is
achievable for idiomatic typescript the
sound typing in safe types would come
said it comes with advantages for
example it helps you find type errors
early so we compile the types of
compiler with safe typescript and found
phone 478 static type errors if we found
one functional correctness bug in
navier-stokes which is a heavily used
and heavily tested octane benchmark but
still this bug was latent and safe
typescript founded and another benefit
benefit of sound typing is that you get
provably robust components and as
opposed to what we just saw but some
typing comes with its cost and the cost
for one is the runtime performance
penalty since we have to check all the
downcast at runtime we have to
instrument the dynamically typed code
there is a runtime performance penalty
for soundness and the penalty is so we
compiled 118 thousand lines of code
using safe typescript which was spread
across eight applications and the
performance overhead ranged from 6% to
3x now more details on this will follow
later in the talk another disadvantage
of sound typing is that the programmer
needs to understand some subtle corners
of JavaScript semantics and he needs to
know how our type system works so it's a
trade-off okay so how is safe typescript
implemented so this is the usual
typescript workflow the programmer
writes an application AB dot TS
invokes the type suit compiler using TS
c ab dot TS the compiler does syntactic
checking does some type influence and
some lightweight type checking
provide some basic diagnostics and
finally omits the JavaScript code
safe type script is fully integrated
into the typescript compiler currently
in version point zero point 9.5
programmer can invoke safe typescript
using this one compiler flag - - save to
the types of compiler so programmer can
enable or disable using this compiler
flag and our type checker transpose
typescript type inference and provides
stricter static checks and moreover
embeds residual checks in the emitted
JavaScript code so the kind of static
diagnostics that our type checker does
are inconsistent subtyping implicit down
cast variable scoping unsafe uses of
this and so on okay so in next 15-20
minutes I'm going to walk you through
some highlights of our type system and
show how safe types type enforces
soundless so a safe types of type system
is object-oriented as with the title
type system but in contrast to type
script which is purely structural safe
types type distinguishes between nominal
classes and structural interfaces to
match the JavaScript semantics of
classes okay so let's take an example so
let's define a point interface which has
two fields X and y both of type number
we have point class which again has two
public members x and y again both of
type number we write a function f that
expects an argument of type point class
and inside the body it's going to assert
that the argument that it receives is
indeed of type point class by doing P
instead of point C so I didn't say it
earlier but I'm using this function
assert whose semantics is that on false
it just dies and if it's true then just
returns void okay so so let's say we
call this function f with a structural
record with fields X 0 and y 0 now as we
as we may notice with this call the
assertion inside the function is going
to fail because this is not an instance
of pointless but for typescript this is
a well type program because classes can
be converted to structure structures can
be converted to classes and therefore
types it will say it's a well type
program
it will go on but my assertion will fail
at runtime in safe typescript however
classes are treated nominally so what
that means is you cannot convert
structures to classes and therefore in
safe typescript at this point in the
code you will get a static type error
saying that X the structural type x and
y x number by number is not a subtype of
point class thereby preventing the
assertion violation at compile time on
the other hand if you called F with a
new by creating a new class instance
this will be okay with safe safe
typescript okay so now let's modify the
example a bit let's say a function f
instead of taking point class takes
point interface but we still call F with
a new point class now this is also okay
with safe type state because it allows
point classes to be converted to
structures so you cannot go the other
way you cannot convert class structures
to classes but you can always treat
class as structurally using this type
subtyping provided by safe typescript so
point class is a subtype of point
interface okay so next we are going to
see how safe typescript instruments the
dynamically typed code in order to
ensure type safety in that part of the
code so with that point interface and
point class as before let's define a
function f that takes an argument P of
type any and it just writes a property x
with string boom now there is a call it
function G that expects a point
interface it calls F and then asserts
that the type of field X must be a
number as you can probably see this code
is going to fail the assertion but for
typescript this is a well typed code and
again this code is the assertion is
going to be violated at runtime so
instead what safe typescript does as a
first step towards enforcing tight
safety in the dynamic code it tags the
values when they pass from statically
typed code to the dynamically typed code
so the composition of function G before
calling F is going to shallow
with point interface we will see how
this tags are used later on but for now
the key thing to notice is that before
calling F it instruments a call to
function shadow tag which is implemented
by a runtime library ok now this
function shadow tag it's a very simple
function it just come takes the type
whatever you give it and just combines
it with the current r TTI so the current
Artie T of P may be nothing in which
case it's just going to add point
interface to the RT TI of the object ok
so now let's see how these tags are used
so say so now we look at the combination
of function f all the writes in the
dynamically typed code are instrumented
with a rent another endtime function
called write which is also provided by
safe typescript runtime library and this
write function is going to enforce that
when you write a field you are always
going to respect the invariants of the
object so in this case what that means
is when you write we are going to look
at peas are TTI we will see in that our
TTI
what does P expect for field X and then
we will see if the value boom respects
that type so as since peas are TTI
because of this shallow tag is going to
be point interface field X of point
interface is the type number so this
will check if boom string is of type
number which it's not so it's going to
fail and we catch the type error early
ok so classes are treated a bit special
in safe typescript in that the tagging
operations on the classes are optimized
so let's modify our previous example
slightly instead of point interface
let's say the G function is point class
and it's similarly called the function f
remains same and we call F and then
assert again in this case when this code
is compiled there is no tag safe
typescript inserts no tagging operation
for P as but earlier as you saw there
was a shadow tag for point interface and
why is there no tagging because classes
have primitive tags provided by the
JavaScript semantics when classes are
compiled
javascript they have a prototype field
where the prototype field points to the
class that they are instance of and that
gives us the RTT I so mean need not add
our own art idea so class instances have
primitive art et I know tagging so you
get efficiency in if you are using more
classes okay so this was what happens
when values flow from statically typed
code a dynamically typed code now we are
going to see what happens to in values
flow the other way around when
dynamically typed code passes values to
this statically typed code and they are
used wire and wire downcast so we have a
function f which takes P which is of
type point interface and it asserts that
whatever it got is actually appointed
his act has actually a field X which is
of type number but here is a dynamic
ecology which has P of type any and then
it calls function f but performs a
downcast on P before passing it to F and
then this is a caller of G which has in
its exfil astray so in typescript it's
going to erase all the types it's going
to erase all the cars and therefore as
you can see this assertion is going to
fail at runtime because x is value boom
which is a string and it's not type
number it's type string in safe type
script however the down casts are not it
is completely but down cos are checked
at runtime so when this function G is
compiled the call to F is actually it
inserts a call check that P is of type
point I and this check function is again
a safe type type runtime library
function it's going to say that ok
you're checking for these conformance to
point I so P should have a field X of
type number it should have a field Y of
type number if it does I'll add point I
to the tag and return otherwise I will
raise a type error so thereby we catch
the assertion violation early in the
code so all the down cards are checked
in safe type script
okay um as with the tagging operations
even please feel free to ask questions
so you have you're passing in the object
literal that matches the shape of what I
had before you said when I was normally
sometimes it was roughly so tight and
then your assertion over here check
structurally instead of not only avoid
glass was wait to see I was not seen so
Point C was the class point I was the
interface so if you did not have the
cast but you still check the point I
cast
let me just sorry I can see no the cast
in one type script and in function G the
point I caused so the point I curse you
did I can have it in that case stage tip
would give you another because it won't
but we will check still I mean even if
it doesn't say your share will still
change yes yes
so if you have an assignment in the
dynamic part of the code then it's going
to be instrumented with this right it
does not necessarily mean that it's
unsafe so for example you could have
written and numbered over here in which
case or I could have succeeded the
compiler the safe that should compiler
inserts instruments the code to insert
this light every time you write a field
in the then I'm gonna take the
right-hand side of the slides is
generated by the compiler in the first
example we have the index and year and
it's client was actually updating index
directly what was the check that
prevented that from happening
oh and I didn't those examples towards
the end of the talk so in your check
function if we have check depending on
what's the target type so let's see
that's next so yeah it's a good segue so
let's say instead of point hi I was down
casting a to Point C but as happens with
the tagging even down cuts are optimized
for classes so now instead of checking
it structurally I can just do javascript
native instance of check so I don't need
to do structural checks I can just call
javascript native instance of and this
is very fast much optimized and so on
so subtypes doesn't do that I'm shocked
that default do you know why they chose
to do so we had scripts really the
philosophy there is the erasable type
system and leaving the JavaScript as
vanilla as possible like the moniker is
like the kind of JavaScript you would
have ripped my and I think the any kind
of runtime checks any kind of inserting
that and you would have to be then doing
all the work to pull them back on again
to get back to that instead we could
give the same experience for you and get
Intel a sense you can get a lot of
pretty urgent but maybe not
and again you would do this without the
cats yes right so now comes apart so so
we have seen that when going from
statically typed code to dynamically
typed code we inserted tags on the
objects but safe typed script is even
smarter it's going to add minimum amount
of tags that are needed to ensure type
safety and in addition we are going to
provide programmers a way to get around
the tagging behaviors so if the
programmer says that I am willing to use
this type system at a much stricter mode
I don't need any tagging behavior
program and has a way to say that so
that's what I'm going to talk about next
okay so let's extend our example a bit
so instead of point so we had a point I
before which was an interface with X&amp;amp;Y
fields let's write another interface
which is 3d point I which is a 3d point
and it adds a field Zeit of type over to
the interface we have these small
functions F G and H which so the
function main takes as argument the 3d
point I it calls H H takes an argument
or 3d point I called G G takes an
argument of point I calls F and F takes
any so as you can see going from bottom
to top the precision in the type is
decreasing so how is this compiled in
safetied script there will be some
tagging involved but how does the
tagging work okay so when you compile F
there is no tagging I'm sorry made yeah
thanks so when you compile means there
is no tagging and the reason is that
there is no loss in position in the
argument type I have a 3d point i the
collie expects a 3d point I so I am just
going to call the function when you
compile H there is a loss in position
because I have a 3d point i but the
other guy expects a 2d point I so
there's a loss in position of field Z
and safe type script is then just going
to add only the field C on the tag so we
call this differential tagging so you
only add parts of the type that are
being lost in position rather than the
complete type so you just add the felici
and that's it okay now when you compile
function G there's a complete loss in
position you're going from point
interface to any and so you need to act
to the tag point interface so these tags
evolve at runtime so at this point the
tag will be maybe nothing at this point
the tag will be Z called a number at
this point it's again going to become a
3d point I and again the shadow tag just
takes the existing tag combines with the
time there to give it and reset setter
so that that records even further and
what exactly are those that you're
passing so those are retain
representation of types so save type
script compiles types into the emitted
JavaScript program and types I have some
runtime representation like objects so
we have a type class you know different
instances of the ears and so for H hi
you actually emit presentation yeah
beads you see it in the demo okay um
right and function f will be compiled
like we don't care okay so but this is a
bit unfortunate I mean if you are going
to say that the compiler is always going
to emit tags no matter whatsoever then
program it has no flexibility to say
that I don't want this tagging operation
there's a performance overhead and I
want to avoid that so then safe
typescript provides programmers a way to
adhere to a stricter type discipline but
avoid tagging so we provide a new
operator called arrays types the
semantics of various types is that a
value of type arrays T is known to be a
T statically but it may not have at
runtime type tag at runtime it may not
have a type tag at runtime and if
programmer writes these arrays types in
the program he has to confirm to a more
strict discipline which we'll see in the
next slide but all the arrays types are
it is in from the output so we were
compiling these normal types into the
JavaScript output but it is steps will
be it is just
like what typescript does with all the
tapes okay so how does programmers say
that sometimes some type should be
erased
so this is our programmer says it so
let's say programmer wants the point
interface to be eligible so he says ok
extend erased it is design empty
interface provided by the safe
typescript compiler and it's just to
indicate that this interface should be
marked erased and so on ok we have the
3d point as before and now let's see how
the compilation of this looks like so
when this code is compiled there is no
tagging involved in this code
specifically in function H we were
losing precision going from 3d point I
to point I but it just compiled saz's
previously it was a shallow tag but now
no tagging despite the loss in precision
and the reason is that your target type
is a erase type so the compiler knows
that it's not going to be use
dynamically because it will be it is so
I can I did not tag it on the other hand
in function G we are passing erase type
to dynamic context and that's a static
type error so save typescript does not
allow you to program dynamically with
the erase types because recall that they
may not have an RTT at runtime we cannot
enforce the invariants therefore you
have to use them only statically so this
is a static type error and you cannot
pass it as types to dynamic context ok
so now we revisit the robust component
example so now so this was our first
example in which you can could you have
allowed that on but then there is
passing the year the 3d points I to the
point I and then just make sure that
that there was no other downcast from
from on the other side or even ask you
to that's what we did so the allowed 3d
point I to go to point I the static type
error is where this is in G part of the
code when you give a point I to any
that's a static type error but we did
allow 3d point I to go to point I and it
compiled as is there was no tagging
involved
but if you try to provide point I to the
dynamic context that's a static type
error so you also wouldn't be able to
index like inside cheat index input with
a Z exactly no you cannot read
yeah because point is any race type all
we know that it has X&amp;amp;Y we don't know
anything about it
at run time it may not have an hour TDI
so that's it you need to adhere to a
strict to type discipline and only then
we can guarantee the it is property of
race x right so revisiting our troopers
components example this was that first
example in which the client was trying
to write index to a boolean value true
which was bad but now safe typescript
provides provides robustness by type
type somnus theorem so at runtime this
is going to be a type error and safe
typescript gives you formal guarantees
for that so there are several useful
results that come out of type soundness
theorem one of which is the runtime type
tags that you add they always remain
consistent with the object so if I say
that the tag has a field F type number
then the object has a field F and it
contains number in it safe typescript
invariants always ensure that and that
the tags evolved in the subtyping
hierarchy so the tags just not are some
ad hoc tags
they always become more and more precise
in the subtyping of jerky and a full
formalization and proofs are in the
Associated technical report ok so now
this is the more interesting example
right in this case we want even this to
be disallowed now this is basically
typesafe in in the sense that the client
is writing a number to it but we don't
want even this to happen because index
is my private field I don't want to
expose index to you ok so how can
programmer achieve this so programmer
can make iterator to be an erase type so
he says hey the interface I traitor a
extends the erased interface and this is
going to ensure that this is not a well
typed code anymore so this will be a
static editor because you are trying to
take it to any and this way you can get
stronger abstraction properties from a
stipes opaque types
Hey or is there some sort of thing why
did you spray I guess you know the idea
of hiding extractions right you know
face saying that you can't do anything
inside the box we're going to run around
yeah so is it the same I guess
so it's I mean in other ways the race
types are like you'd expect types to
behave in most languages types are often
erased in language that came out let's
say and you have to respect the
invariance of the only way you can use
the values by the published interfacer
and that's what this is a long unit okay
it's just what other languages have
anyway right but the interesting thing
here is that it's a partial duration
without me but you don't
systematically erase everything you get
to decide exactly what is it raised as
well as not arranged and it's not quite
the same as opaque types because here
you know the iterator it's saying that
it has any a next field it's not
completely abstract right so you know
you're revealing that this is the
interface at publish and that's all
right so we have an abstraction theorem
for Lily's types as well it's in our
technical report again ok so this
finishes the overview of safe types you
type system there are many more features
in safe type script we have support for
generics we have support for arrays and
we support covariant subtyping of arrays
in a way by having mutability controls
we support sound overriding inheritance
and so on and all these features help us
scale our save type script to large
typescript applications ok so some
experience with types it I'm just
looking at the list and one of the other
gotchas with a lot of JavaScript
programmers is this pointer here's just
how flexible dynamic something is ha ha
yeah but you know at this point ahead
but safe typescript and forces that you
use this pointer in a sound manner and I
mean a short introduction is that it
treats methods and functions differently
so for example you will not allow you to
project a method so if you write a
method and you use this parameter in
that we won't allow you to project a
method out of the object because this
will be bind dynamically to something
else so safe typescript enforces that
you use this in a sound manner
so how big is the language manual for
six how much says it extend the tip
skirt it's only in the to tell people
all the features that you provide I'm
happy to erase this one part of it yeah
you're talking about mutability it's fun
exactly yeah so I mean there is some
learning involves buttocks immutability
is basically in typescript code it
allows arrays covariant subtyping which
is unsung but it's a useful idiom so we
provide you covariant subtyping of
arrays provided that the target is that
you read only array so you can go from
point you can go from 3d point array to
a pointer array but that point array the
target pointer they should be immutable
because otherwise it's not so so we have
these many things like that which are to
support the popular idioms like this but
no any stability technical report is a
formula is a large part of this
timestream and its border than any no
formalization of typescript so
formalizing the whole thing is just time
step and I wanna use this how many pages
of text have to read until I'm like I
understand all the things that have that
are necessary to use it it's a good
question twelve pages of a bubble
maybe you can just see the
implementation section and state the
formalization to you three properties
and indexers invariantly or Co there in
the key of G in there because with a
mutable suits and some token completely
you have a question
okay so yeah experience with save type
scripts so we used we bootstrapped the
save types of compiler it's about 90
thousand lines of code with 80 thousand
lines of typescript compiler code and
ten thousand lines of code written by us
the compiler is heavily so it's
implemented in version 0.9.5 and that
compiler code base is heavily
class-based which is good for us because
then the performance overhead will be
minimal as we saw most of the code is
carefully type annotated it's written
quite well I would say we found 478
static type errors which are classified
as follows the 98 uses of covariant and
contravariant subtyping 130 uses of
covariant method argument subtyping 128
cases of variable scoping 52 cases of
projecting a method and leading to a
potential and sound use of this and so
on
we fixed all those errors and then we
found 26 failed downcast as well when we
ran the compiler and out of which 5 but
in the code that we wrote so mean the
doubt tool support I think it's very
hard to write a sound code they were
type safety violations but like we did
not have a example that would have
yielded to some bug but these are type
safety violations where you make some
downcast that Uncas was not some but it
so happened that you didn't end up using
the variable later on in the code or you
didn't ask if it succeeded silently you
projected a few little exist but that
undefined vaporized into
some point in working in scouts so when
you say bivariate or anything
you just said that arrays were allowed
to be Co very same time so how would you
so they don't know to be covariant if
the target is immutable but intensity is
no such notion so we had to add a
mutability support for the yes yes yes
okay so uh the runtime overhead of type
safety in this experiment was only 15%
which is quite good I would say and it's
mainly attributed to the fact that most
of the code was class space so the
downcast checks were very cheap because
we could do instance of and tagging was
just no okay so we also compiled the
latest typescript code version 1.1 with
that compiler that's a much smaller code
base it's 18 thousand lines of code as
opposed to 80 thousand lines of code
previously but there is a design
paradigm shift instead of heavily
class-based the code is now heavily
interface based so this gave us a like
the other end of the spectrum and so we
found 81 total static type errors out of
which soso mainly they were variable
scoping and array subtyping but the
runtime overhead now increased to 3
times and it's because interface
checking and tagging is costly
it's a pre-release version but yeah I
mean part of it is the compiler feeding
up one whenever kept changing because
the language we kept working with the
language is changing here so it imploded
behind and then we decided ok let's
actually start from scratch in first
principles but we already know because
language isn't changing so much
and that builds up built a much lighter
way okay so as I said the high over it
is because of more structural types but
having said that I would also say that
we did this experiment in last two weeks
so we did not optimize the runtime
library for interface as much so there
may be venues for more optimization
there okay the third experiment we did
was we used obtained the standard octane
benchmarks that's a total of 10,000
lines of code we found one variable
scoping bug in navier-stokes which is a
heavily tested and heavily used
benchmark but we found this bug which
yields to functional in correctness
so for these benchmarks there was height
and time overhead if you don't have any
type annotations and the overhead range
from two point four times in splay to 72
times in crypto and average of 22 times
but once you start adding type
annotations to these benchmarks you
recover the performance and for the type
benchmarks the average overhead was a
six point five percent it's in the paper
so it starts it's yeah it starts at pure
JavaScript and then we add annotations
to it to make it type then this is what
the purpose we did seem to sing in some
sense many of these benchmarks kind of
came to obtain from languages like small
so right you know they started out life
as pipe programs they became on tightly
now okay so now let's see a small demo
so this is that safe typescript
playground so I have interphase point I
am interphase point class there's a
function H which is writing X dot X to
poo there's a function f which is
pointed to this and then G which has
three numbers just like 3d point
interface okay so this is what the first
thing happens we register types so this
comes to your question what the type
representation is so it's registering a
pointer interface and saying that it has
an X field which is of type number by
field of type number and some things
some other things this is the class
compilation and this is the
gestation of the class with the runtime
system and so on so if we see below we
see the incremental tagging here so we
have XY and Z point is just x and y so
the shadow tag in this case is just for
the z : number when you go from point I
to any you tag it with the interface
type point and finally the right the
right in the dynamically typed code is
instrumented by using right field okay
so now let's see let's try to modify
this to use a point class and just
recompile it I don't know how good the
dynamic thing works anyway so so once
you annotate it to be a class you note
that the tagging disappears so there's
no tagging anymore because tags for
classes are free so when you go from F
to H there's no tagging moreover this
guy now has to be check and tagged to
the class type so recall that structures
are not convertible to classes so we
have to insert a runtime check and
depending on how this guy originated
started its life this check is either
going to fail or succeed ok so now let's
make this a point interface but let's
make this guy arrays so we call it
virtual in our implementation so this is
how you say that an interface should be
erased and if you you know to recompile
it so once if you recompile it then you
should see that right so now at this
point the tagging disappears earlier you
were tagging with field Z but now since
point I is erased this just goes through
as it is but at this point we get a
static type error which is that you
cannot pass any argument to you cannot
pass erased arguments to context any so
this is a type error and safe types get
emits with this unsafe annotation and
you can give some semantics to unsafe
whatever you like
okay so limitations and work in progress
so we currently do not have eval and
other unsafe concepts of the language in
save type script but we know how to add
them and this is some work that we did
last summer on giving this eval and
other unsafe concepts an adversarial
type so we explode on how you can have
unsafe JavaScript and still interact
with that in a sound manner so we think
that same ideas can be used even in this
case some implementation limitations so
as I said it's implemented in version
0.9.5 but we currently do not support
external modules we only support
internal modules and that the types of
compile that has now moved on to V 1.1
and we are having ongoing discussions on
how to integrate our save touched it
with the typescript compiler version 1.1
okay so that's the end of my talk so I
talked about safe typescript
feel free to download it it's available
on this link for download we submitted a
purple paper on this without theorems
and lemmas and whatnot and the submitted
paper is here we have a full technical
report which contains our formalization
of a large core of safe typescript and
complete proofs and here is the online
playground which I just showed you
during the demo so thank you money is
just you have to do this and checks but
the other is the particular I mean
you're encoding all the type information
in JavaScript itself right that seems
like just pushing all of that type stuff
in javascript pretty expensive I was
wondering if you knew sort of a rough
breakdown of what was the cost of just
having the conditional check versus the
cost of managing all the type
information and then sort of the
follow-on is I mean would it be useful
to push that type information into the
actual JavaScript runtime you know it
might be a lot more efficient to
represent
and it might actually useful to the
runtime as far as its cojan in execution
definitely so I'll answer the second
part first so it's much more it's going
to be more efficient and in fact if you
have the option of modifying the runtime
then you can even make use of soundness
of safe typescript to for example do
away with the checks that JavaScript
virtual machine already does so if you
have X plus y in the source types we
know that X is a number of Iser numbers
so we can just add them without doing
all the case analysis in the JavaScript
virtual machine so if you have the
option you can definitely optimize much
more for your first question I think the
cost of translating types is one-time
cost
it just happens during you know like if
you're representing them as strings or
something yeah you know you're doing a
lot of stuff there whether it might so
we're trying to be careful about using a
lot of sharing so the same type is going
to be it is kind of you have many times
to program and go try to use reference
equality for them as much as possible we
try to use nominal types as much as
possible pivots cost if a type is normal
we gonna do a nominal check as opposed
to a stop your check
yeah cashing off for example if you have
an interface and you want to check if
some object complies to that interface
we go to the structure of interface and
we cache all the structural
representations also so we have tried to
optimize it but then at some point for
structural types you have to go through
each field and do these expensive checks
but I don't think we have a breakdown on
just that because checks you know we
involved traversing a type so I don't
know how can separate cost of just the
check sources trimmers in the type what
I was thinking that the traversal versus
just a different try I mean you always
have you all that said if and then
there's the other cost which is actually
you know traversing and type information
or how you give the actual resolution of
that yeah and one of those you can
always have to pay right you always have
to do here check the other one can be
optimized
I mean I guess the other thing is that
it's nice to generate code that's just a
kiss goodbye goodbye change the engine
this would be great you know but also
scope down its usability I'm so with
your instance of checks for the for the
classes how does that deal with
inheritance and base classes if I say I
have a derived I want to check instance
of base so how does that so business
inheritance is compiled by typescript
it's going to maintain the prototype so
the base is going to eventually appear
in the prototype chain of the derived
instance so the instance of check will
work and we'll use the instance of
piggyback on the javascript instance
object and my second question is you
showed kind of properties so how does
the RTT i work with signatures and i
might be reading question right so if
you have methods in the type then those
methods are also put in the RTT i and if
you call those methods dynamically we
will do dynamic type checking for call
for arguments and for return type and so
on those signatures interface
yeah but without like not methods but
lose signatures have an interface i that
is callable and various we support that
too
so so the the way for those of you not
tied to an expert's correct me if i'm
wrong on this one so the way types of
supports overloading is that you get
your right you have an implementation of
a function and then you get to supply
multiple signatures for that function
that need not be related by subtyping to
the implementation signatures
to speak I can write a function that
said number of a number function and
then claim it as type any to any also
that would be fine they do have to be
related by subtype but it's sorry but
it's your we kind of subtracting right
so so for somnus what we do is we say
okay what goes into the RTT i is the
implementation signature only and if
during type tracking you know we will
piggyback on your type inference results
to resolve to the overload that types of
choosers but at runtime we will check
against the implementation signature
which is the only true you know the only
sound signature exercise your question
yeah part of it there's also the case
where you have no implementation yes so
when you have no implementation then
what you can do is to go as when we do
this so the types of programs are all
type with respect to this library that
gives time to the JavaScript environment
it's like a fifteen thousand my
inspector so we implicitly treat every
time declaration in the TTS as an erased
type meaning that you can some external
libraries claiming that it provides to
you a function that behaves both like in
any to any function as well as a number
of number function and you're willing to
trust that you know array dot splice
behaves in this kind of ad hoc
polymorphic way and then since as he
raised
there's no runtime representation for it
and as long as you call her a lot splice
with on a value where the receiver has
type static type array we will just
resolve it the way the types of compiler
resolves it and there's more attention
so if I declared in your face in my home
yeah and then you can mark that
interface in some ways you can just use
it but you would have to then respect
the static type unison look for I for
that particular for values of that
yeah so that's how we support ya live
down did Ortiz so we mark all the
specification in the ground it appears
to be a date so that we don't add tags
to things that are not ours the
questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>