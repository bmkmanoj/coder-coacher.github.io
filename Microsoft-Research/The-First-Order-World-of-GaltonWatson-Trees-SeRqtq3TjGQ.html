<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The First Order World of Galton-Watson Trees | Coder Coacher - Coaching Coders</title><meta content="The First Order World of Galton-Watson Trees - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The First Order World of Galton-Watson Trees</b></h2><h5 class="post__date">2016-06-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/SeRqtq3TjGQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
all right good afternoon everyone I
think maybe almost people here have
studied probabilistic minute Oryx from
the wonderful book by alone in Spencer
and now we have Joel himself like to
tell us about the first order world of
gotten Watson truth okay thank you it's
a pleasure to be back in redmond I want
to talk about a well-studied subject
galten Watson trees but from a somewhat
different vantage point so let me begin
though by saying what golf and Watson
trees are so this is a a model for a
rooted tree initially it was a
demographic model for the air stock
aristocracy of England which galten and
Watson were afraid was dying out
fortunately they were correct what so
here is the but they came up with a good
mathematical model so here is the model
you start out with a single node called
the root and then the route has children
and the number of children is given at
least this is what we'll look at is
given by a Poisson distribution with
mean lambda ok you can actually look at
with other distribution but we want to
look at the Poisson distribution and
then so maybe the first one has three
children and then you go down and then
this one has maybe one child and this
one maybe has 0 children each node the
number of children independently is a
pot it has the same distribution the
place on with mean lambda so lambda will
be the critical parameter here
and maybe this one dies and well maybe
this one died so maybe the whole tree
just dies after a while but it's
possible that it can go on forever as
well in fact that's one of the key
things to look at in terms of
probability theory the way I'm going to
describe it is to have an infinite
sequence of iid plus on lambda variables
and then just to say that the root node
first note if you like has x1 children
and then the next node has x two
children and the next note has x three
children and the underlying probability
space is this infinite sequence though I
like to use the phrase fictitious
continuation here because it's quite
possible that the process will stop as
it did in this case in particular if x1
equals zero the process stops so the
underlying probability space is this
countable a sequence of iid plus on land
two random variables that determines the
tree but if the tree does stop in finite
time then the rest of them simply aren't
used but it's very handy to to look at
it that way so this is called the Gulf
and Watson a tree and now if you have a
property a of trees you would have a
probability there will be a function of
lambda which is the probability that the
property a holds as a function of lambda
and this is what we want to look at how
can things depend on land
so I want to start with two examples
that are somewhat similar but in
critical way from my point of view are
quite different the first one I'll just
write it schematically what I mean by
this is there exists a node that has
exactly one child and that child has
exactly one child okay so all right I
mean I could have given you some other
one but but this is one that will look
at okay and if we want to analyze that
very nice exercise but i'll show you how
to how to do it on we can define it by
we can analyze it by looking at three
states armed so the state of a node will
be we see one thing with rooted trees is
that H node defines a rooted tree that
note in all of its descendants and
indeed those things have the same
distribution as the original galten
Watson property so we'll call a node
green if the answer is yes that is
inside the tree generated by V there is
a note possibly V itself that has
exactly one child which has exactly one
child then we'll call we're going to
have three states will call a node blue
if it's not green
but it has precisely one child the sort
of part way toward getting this as we'll
see and we'll call a node red if else so
to analyze this will will say that a
node is green if in the tree generated
by by it there is such an anode possibly
the note itself that has one shot
exactly one child with exactly one child
it's blue if it's not green but it has
exactly one child and otherwise it's red
and then they will have probabilities on
let's call them x y and z and but
they're really only two variables
because they add up to one the
probabilities all right now the thing is
that the state of a vertex is determined
by the states of its children so how
does that work well if you have I'll
just write it sku if any of the children
are green then the parent is green
because for a note to be green it means
inside it there's this special no child
grandchild okay so then all of it set
its parent will also have this but it
can also be green
listen or suppose the node has only one
child exactly one child but that child
is blue that means that it had exactly
one child and then that means that
you're green sorry okay my colors that's
them okay that also means you agree and
on the other hand for becoming blue if
you have a node and it has exactly one
child and that child is red then you
become blue because you had exactly one
child but that child was red so it
didn't have anything inside it so you
are blue and and everything else is red
everything else is red so so the state
of a node is determined by the states of
its children okay and and these are the
rules for them now because of this we
can give some equations for X Y &amp;amp; Z so
maybe I should write them down because
of so
what is the probability that you're
green well either you have a green tilt
now that here's a the Poisson is
particularly nice beautiful thing about
a Poisson is if you have a plus on if if
if if if you're going to have plus on
lambda children and each one is a boy
with probability point for and girl with
probability point six then you're going
to have plus on point for lambda boys
and plus on point six lambda girls and
those are independent numbers this is
one of the beautiful properties of the
plus on distribution so here what we can
think of is if we take a node it's going
to have plus on lambda X green children
plus on lambda y blue children and plus
on lambda Z red children so what's the
probability that it's going to be green
well if it has any green child it's
green the chance that there's no green
child there's a to the minus lambda X so
we get 1 minus e to the minus lambda X
but we also might have a single child
which is blue and that is the one can do
the computation it's lambda e to the
minus lambda times y because you'd have
to have exactly one child which is
lambda e to the minus lambda and then
given that that child would have to be
blue which is which is why on the other
hand what is the probability that you're
going to be green you have to have
exactly one child s are blue you have to
have exactly one child which is red so
it's lambda e to the minus lambda Z and
I don't have to put in the third one
because these are distributions there
some has to add up to one well
can be solved implicitly okay it's not a
new explicit solution but yeah there's
there's a solution and here's lambda I
don't know it actually I think it goes
up I'm pretty sure he keeps going up but
that's not that it's some kind of smooth
solution okay hmm as a function of
lambda this is X yeah this is this is
but I mean I could do it for Y or Z as
well but CX is the event that we want
okay but you know equally well could be
done for sure so X is a function of
lambda is some smooth function okay well
that's nice all right now in contrast
let's look at the very basic thing that
that poor galten and watson were so
worried about which was that the
aristocratic families would disappear so
what is the let's look at the event that
the tree goes on forever that the tree
is infinite so the second property is
that T is infinite and now we can do a
similar analysis where there are just
two states yes and no
either V generates an infinite tree or
it doesn't it generates a finite tree
again there's really only one variable
because these are distributions and
again what we have is that if any of the
children are green then the node is
green if any of the children so Adam had
Cain and Abel Abel unfortunately didn't
work out too well thanks to Cain but
maybe maybe the tree is infinite we go
anyway so all you need is one child
that's infinite and then and then your
infinite okay so well this is good and
and this is very classical and then what
is the probability I always write it
down wrong so let me try and get that x
is the probability that there is at
least one so you have plus on lambda X
green points so you need at least one
green point which means that you don't
have zero green points which is one
minus e to the minus lambda X and if
you've studied galt and Watson trees
this will be familiar what to you this
is the equation for a for survival and
when you graph it two things happen that
are different
the function is not smooth well it's
continuous but it's not differentiable
when you solve the equation at lambda
equals 1 before lambda less than 1 the
solution is 0 for lambda greater than 1
there's a solution that does not have so
the right-hand derivative at land equals
1 is 2 and the left-hand derivative is 0
so it's not differentiable at the point
of lambda equals 0 so that's a big
distinction from here where this
function has all of its derivatives
equal secondly there is a spurious
solution which caused almost 19th
century English a lot of grief because
they thought to spur if there was a lot
of thought that the spurious solution
they said look at this equation answer
hmm x equals 0 0 equals one minus one
there's a solution there's a lot of
confusion about that at least according
to Peter Jagger's who studied the
history of this quite a bit so actually
the equation here for lambda less than 1
there's only the only solution is 0 but
for lambda greater than 1 there are two
solutions so you actually get two
functions the actual answer to the
problem probability of the t is infinite
is given by this curve but you if you
look at the equation you you get this
solution as well that's not the case
over here this system of equations has a
unique solution so there are two points
on which these two examples differ one
is that here you in
you get you get a system of equations in
this case one equation in one unknown
but it does the solution is not unique
here it is unique and when you look at
the solution to the original problem
here you get something that's a smooth
function all of its derivatives exist
and here you have a function that smooth
except that lambda equals one but it
lambda equals one it's not
differentiable and so the question is
what if anything is going on so I want
to I want to restrict the kind of
properties that i want to that i'll look
at so our objects are rooted trees and i
want to restrict myself in this talk to
properties that i'll call recursive in
the sense in what sense they're two
aspects of it first of all there is a
finite state space Sigma and secondly
I want an integer K fixed integer K
greater than or equal to 1 and when I
count things I'm going to stop my
counting at k everything that's k or
more is counted the same and now
something that these two things have in
common is you can describe the property
by making a finite number of states here
two states here are three states but
it's important that it be a finite
number and that the state of a node is
determined by the number of children in
each state and furthermore that that
number once it gets the K it doesn't
matter how much bigger it is so so here
um k is let's see do I want it greater
than or equal to you know I want a
greater than 2 K minus 1 no breather
yeah so here if you have one if you have
two or more children might be off by one
if you have two or more children of a
certain type then it doesn't matter it
does it does matter whether you have 10
children or one child but if you have to
green children or 50 you have two blue
children or 57 blue children it doesn't
matter okay and over here actually the
counting is either you have zero or you
have some and so i'll require for a
recursive property that the counting
stops at some fixed point let me mention
one other case just briefly on consider
the property that that inside the tree
you can start with the root node
and you can take an infinite full binary
tree that is from that root node you can
take two children maybe it has more than
two children you can take two children
and each of those have two children then
each of those four have two children and
then each of those eight have two
children and it goes on forever this
refers to something in graph theory
called the two core it's been a lot of
work on it one can again do something
like this again it's yes or no and if
you have two green so k becomes too so
if you have two or more green children
than your green and again one gets a
recursive formula and there something
very odd happens you you the solution is
discontinuous is discontinuous and some
of you you're familiar with studies of
the two core it's based on this what
happens is there's a critical value of
lambda 0 and up to lambda 0 the value
actually strictly speaking less than
lambda 0 the value is 0 and then there's
a discontinuous jump and then the
probability that you have this infinite
two core jumps to i forget what number
but it's a specific number that's bigger
than than zero so a number of odd kind
of things can happen so my interest is
recursive properties in general okay but
now I'm going to add some logic to the
mix in terms of talking about the
properties
and I want to look at what's called the
first order language in terms of
describing properties so you know I'm
being enlightened next month and then
I'll have to go very slowly over the
probability and a little quickly here
here i think i'll just give you some
idea of it if you're familiar with it
all the better so i want to look at at
statements so how am I going to allow
myself to describe statements I'll allow
the normal bullion and or not those kind
of connectives I'll have variable
symbols XYZ I'll be able to i'll be able
to talk about the route that would be a
constant symbol the route are i'll be
able to say that x equals y as nodes and
i'll be able to say that x is the parent
of why you that is a binary relation and
i'll have quantification i'll be able to
say for all nodes v or i'll be able to
say there exists a node w there's like
them that's a little redundant but so
what we're allowing is rule v where
there exists a W and we also have
equality parent arm and and the root and
the usual boolean connectors and
properties have to be fine Utley
describable by a finite sentence so if I
want to look at this sentence I'd say
there exists w x and y such that w is
the parent of X X is the parent of Y and
there does not exist the Z
such that or put it this way if and for
all Z when I say W X Y for all Z if Z if
w is the parent of Z then Z equals x
that says that it has exactly one child
and if Z is if X is the parent of Z then
Z equals y so these are the kind of
sentences you can make what can't you
say well first of all the sentences have
to be finite you can't say there exists
an infinite string x1 x2 x3 x4 x5 dot
dot dot there's no ellipses in this
language each sentences is fine and the
key thing about first order is that the
quantification is only over vertices
you're not allowed to say there exists a
subset of the vertices that has a
certain property you're only allowed to
say there exists a vertex that has
property such and such so there a number
of things you can say and a lot of
things you can't say one can prove that
there's no first order property that
says that the tree is infinite when it
doesn't look and if you try and do it
you'll fail but that's actually a
theorem that you can't do it there's any
first order property it will not be be
that the tree is infinite okay now so
this is called the first order world and
it's been quite well studied and
whenever you have a sentence a you have
the
quantify our depth so you look at the
sentence a and you look at the degree of
nesting of the quantifiers so if you say
for all X there exists a why blah blah
blah and for all Z there exists a w blah
blah blah that's the quantifier depth is
too because the Z and the w aren't
inside the x and the y so it's a notion
of nesting and we can look at what we're
going to do throughout is to fix we're
going to look at statements with a given
quantifier depth a now I priori there an
infinite number of those statements but
it's one of the deep results in it's not
that deep but it's not not immediate
that they're really only a fight
effectively they're only a finite number
of classes they're only a finite number
of classes so we can say that T is
equivalent to t prime now I'll put the
little k down as a subscript but then
i'm going to leave the k out for if so
these are both rooted trees these are so
our objects are these rooted trees for
the moment forget about the probability
they're just the root trees if they
satisfy the same a with quantifier depth
of a let's say less than or equal to k I
mean quantified depth is less than K you
can always throw in a spurious one that
doesn't good and they're only a finite
number of equivalence classes okay so
this I'm going to just take as a fact I
should mention though that the number of
equivalence classes actually goes up
like at our function of K so this is the
theory section right yeah so it's all
right so we'll let Sigma is the set of
equivalence classes and now any first
order statement a if quantifier depth k
is just determined by which subset of
Sigma you are and Sigma is a finite set
now in these cases and in many explicit
cases I can make use of a much smaller
Sigma so here I two states or three
states but in general i'm going to have
this finite state space sigma which let
me just denote it by x 1 through m the
the states and we're going to let d be
the set of distributions on Sigma so the
set of x1 through XM such that summation
of x is equal to one and all XJ are
greater than 0 so this is a nice compact
set basically an M minus 1 dimensional
space the n minus 1 dimensional hyper
space hyper plane I think of it as the
set of distributions over Sigma and now
now what we're interested in instead of
looking at the probability of a let's
look at this plus on tree which has this
lambda in it and we'll look at its
distribution in terms of what state it's
in and if we can get that whole
distribution then for any particular
property a it's just going to be a
finite sum of those things so what we
can say is that let's right solution of
lambda to be the distribution of the
state of this golf in Watson tree okay
so given lambda we have this probability
we create this random plus on lamb this
random galten Watson tree and then we
look at what state it's in it's in one
of a finite number of states so what are
the probabilities for each of them well
whatever they are that that's going to
be our goal and indeed over here here we
had only three states XYZ and we saw
that that they satisfied this equation
the system of equations well
this will now work ah almost left out a
critical point the the
state is is that's a recursive function
okay well here i define recursive
property but I can also define a
recursive functions so the value is
which state you're in same thing so I
claim that that in fact the K is the
same k of the quantifier depth so this
is a statement from logic which takes
some proof if you're familiar with the
errand boy game one can prove it using
that but I don't want to get too far
afield I just want to state that if if
if you have a tree and you have a node
and you look at its children and if you
know the state in pretty good the the
arrow foot this is called the erekoi
class
so other state as a logic fact that if
you have a node and it has a set of
children and you know the urn FOID class
for each of the children that is to say
for the tree starting with that child
then from that the aaron floyd class of
the original node is determined and
furthermore if there are K or more nodes
of a particular type it doesn't matter
how many there are it doesn't matter how
many there are so similar to the
situation over here and I said if you
familiar with the area for game this
this can be proven using the iron Floyd
game or it can be proven using some
basic logic things that I don't know how
to do that but I'm just going to take
this as a fact so just since we're
taking it as a fact let me just repeat
this that so the state of a tree is
really how it behaves with respect to
all quantifier depth case statements and
they're only a finite number of states
now I'm saying that if you have a point
and maybe it has 53 children there's no
probability here and and for each child
you know the state of its tree you know
for each first order statement of
quantifier depth up to k you know
whether it's true or not on that tree
and furthermore that if more if care
more nodes have the same state all you
need to know is that they're at least
you don't need to know how many there
are then the state of the original tree
is determined so that is to say
something like this will occur there'll
be some determination which will be a
little more complicated to describe that
goes from so here
what you have is number of green number
of blue number of yellow if the number
of green is omega know if the number of
green is one that the counting is 0-1 or
Omega Omega meaning greater than or
equal to 2 the number of green is one or
Omega then you're green if the number of
blue is one the number of green is zero
the number of red is zero then you agree
if the number of green is zero number of
blue is zero number of red is one thing
you're blue everything else is is red
there will be a similar thing for the
air in floyd class ok so that i'm not
giving the proof but it comes out of the
logic so now yeah question 3 first rotor
property just give it by some the
distance of a subtree sorry is every
first overt water properties could buy
the existence of a certain subject like
in your examples no that's not really
true I mean these are existential
statements you can make more you can say
for all X there exists a wise it's a for
all Z there existed w you can make I
mean you could say that beat that if
every time but you could say that every
time a child and a grandchild had
exactly seven children then all seven of
the Omega describe this country when
you're here well time there is a local
miss to it does depend on finite things
that's true yeah so in a certain sense
you're right yeah they're there is a
locality hear that that really is
important
so now I want to get the solution as a
fixed point and so I'm going to define a
mat sci depending on lambda from
distributions to distributions and the
solution is going to be the fixed point
of this map side so the idea for psi is
you you have a distribution over the
states armed and now you take a point V
you give it twice on lambda children and
then each child you give a state by
means of this distribution and you do
them independently now you know the
states of all the children therefore you
know you've determined in this way that
I've just stated that's determined the
state here and if everything is going to
work we're going to have a fixed point
if that's got the solution is going to
be the fixed point because or so so this
is a map from distributions to
distributions once again you're given
any distribution over the states you
take a point give it plus on lambda
children give each child iid a state
from this distribution that induces the
state of the parent is the distribution
for the parent and what happens is that
the solution is the fixed point
upside again I should write basai some
lambda but what happens here what we've
been able to show is that in the case of
first-order statements that this psy has
a nice some nice properties first of all
maybe most important the fixed point is
unique so unlike the situation that I
erased where you have two solutions
there's going to be a unique solution to
the equation sigh of x equals x secondly
if you think of psy as a map from the
distribution space to the distribution
space it's a contraction okay points are
getting closer together now if you take
a high enough Pat if you allow yourself
take a high enough power then the metric
becomes irrelevant because if it's if
it's contracting and this say the TV
metric then if you take a high enough
power it's really contracting in the TV
metric total variation metric and
therefore contracting in the l2 the most
natural which is the one we're in total
variation total variation you know
although for application we really want
the l2 mentoring yeah but but we'll see
the total variation metric is is the
natural 12 to look at so the results are
that the there'll be a unique fixed
point and even further I mean what we
actually prove is that the maps I is a
contraction map so in fact then it has
to have a unique fixed point arm and so
the solution will be given by the unique
solution to a finite system of equations
and all the equation
students just have the variables and
various land powers of lambda and e to
the minus lambda floating around so
they're they're nice functions and from
that one actually gets that the from the
contracting property that the solution
so the results are that it's contracting
I think that's sort of the main result
from which other things follow it's a
unique fixed point and and it's a smooth
function that is all of its derivatives
exist so it's not like the place where
it's not differentiable all the
derivatives are just in fact it's even
more it's real analytic like this even
more because it is the solution to these
equations it's so called an algebraic
function I guess is this the word so so
everything so these are the results that
things are very nice about it let me
give you some idea of what what's
happening here and bring up another
definition that turns out to be
important right yeah that's right well
that's right yeah yeah but these are
smooth functions
let me bring in another definition that
I like so remember that I said that we
consider the galt and Watson tree that
the underlying space is this countable
sequence of iid Hasan mean lambda
variables so let me say that a property
or for that matter function a is rapidly
determined
if I want to reintroduce a notation of
Knuth that unfortunately died away but I
think it's really a wonderful i want to
say fairly surely to introduce some
decades ago fairly surely means that the
chance that it doesn't happen drops
exponentially okay so let me just
introduce that for today it never did
catch on but i think it's a very useful
thing so something occurs there's here
they'll you'll see there's an underlying
parameter s so something occurs fairly
surely if the chance that doesn't occur
drops exponentially and s if fairly
surely x1 through XS let me emphasize it
by writing tautological e determine are
either the veracity of the property or
the maybe it's a function in fact the
actual thing is we're going to look at
the the aaron foot value let me give an
example of something that's not rapidly
determined uh whether or not the tree is
infinite so consider the property that
the tree is infinite and think of lambda
greater than one if you have x1 through
excess with a positive probability I
mean bound it away from zero at the end
of x1 through excess you're going to
have this huge number of nodes that you
know you have but you don't tautological
II know that the the tree is going to be
infinite you know it's highly likely
that the tree will be infinite starting
from there but you don't tautological II
know so so being infinite is is not
rapidly determined this one lambda is
greater than one so you're fairly sure
that you're fairly sure but you're not
fairly sure that your tautological
assure
and that's the difference and and the
claim is that Sigma depending on K is a
rapidly determined now I don't want to
give the whole argument let me give the
argument for this particular statement
so look at the statement that there's a
node that has exactly one child that has
exactly one notice that that doesn't
have limiting probabilities 0 or 1 it's
somewhere in the middle you know but I
want to claim that it's rapidly
determined okay so let's fix X 1 through
X s now what I the way I want to examine
this is I want to use fictitious
continuation so what I want to say so
we're just going to look at this
statement
in fictitious continuation I want to use
the exes to generate not just a tree but
if the tree dies i'm going to start
another tree I won't call it the route
anymore but i'll just start another one
so let's let's define a new process
based on the excise that will use all
the excise we just go along but whatever
something dies we just start with a new
node so you know maybe we start out
suppose we started out 300 3000 to the
first node would have three the next
would have zero the next would have zero
the next would have zero but then
instead of the process stopping so this
is the route I'll add a new vertex that
has two and i'll keep on going now I
claim that fairly surely in this
structure there's going to be a node
that has exactly one child that has
exactly one child so this structure is
not ever going to stop so I'm going to
take it out to s and and I claim that
there's going to be and by by that I
mean that it's already determined by
time s so that there's a node it's had
exactly one child that's had exactly one
child but furthermore the grand child's
children sorry we don't ya know that's
all in it so so why is that well in
their number of ways of proving it i
like to prove it using martingales we
let i sub i equal one
if I has exactly one child which has
exactly one child and we're going to let
Y be the sum of I sub I for I less than
or equal to epsilon s there's a little
technical part we don't want to go up to
s because if we look at the point s X 1
through X s haven't yet determined what
they've determined whether how many
children s has but if s has one child we
don't know yet whether that child has
had one child but if we stop at epsilon
s where we pick epsilon will depend on
lambda if we pick epsilon small then
fairly surely by the time when we get up
to epsilon s not only so if we only look
at the nodes up to epsilon s all of
their children and all of their children
have already been determined have
already been determined so that you can
show so I only want to go up to 2
epsilon s and I look at this and now I
say that the expected value of y is some
constant times epsilon s because each
node the probability that has exactly
one child the cap is lambda e to the
minus lambda squared has to have exactly
one child lambda minus lambda that one
has to have exactly one child land e to
the minus lambda so the expected value
of y is kappa x es and now i want a
large deviation result I really want to
say that Y is is probability that Y is
zero is exponentially small but I can
run a martingale on on why so I think
it's pretty much required that the word
martingale comes up in any of these
talks so we run a martingale on why
where we look at the expectation of Y as
we look at x1 x2 x3 etc what can be the
effect of XY sorry X I so why I is the
expected value I shouldn't use I YT is
the expected value of y given x 1
through X T and now I want to look at
how are expected value changes when we
say how many children child T the teeth
child has well that can affect whether T
has exactly one child that has exactly
one child it can also affect whether the
parent of T has exactly one child which
has exactly one shell but it can't
affect anything else and this is a
tautological thing about the knowing how
many children the teeth child has can
only affect the tea itself and the
parent of tea so what happens is you
have a martingale each additional piece
of information can affect things by at
most a constant in this case the
constant is too therefore you can apply
a Zuma's inequality so you have a large
deviation and you actually say that so
the probability that Y is zero is
exponentially small in fact actually the
probability that Y differs from this by
constant s is is exponentially small I
don't know that we actually and some
later things women might might use that
might that might be useful but I don't
think we'll get to that okay so now what
does this mean does this mean that the
probability of the event is going to one
no because this was with fictitious
continuation
so now what you say is when you look at
x1 through excess in the fictitious
continuation fairly surely this has
occurred now what's happened is either
the process has stopped by x1 through
excess but then we know whether the we
just look at the tree see whether it's
true or not so then we absolutely
tautological II know whether there was a
node that had exactly one child that had
exactly one child or the process hadn't
stopped by excess but then if it hasn't
stopped by excess then the fictional
continuation is what actually did happen
and so therefore in that case fairly
surely it did occur so we either
absolutely no it or we're fairly sure we
know the answer putting them together
we're fairly sure that we know the
answer so what happens is that I've just
done it with this statement but it turns
out it works more general that these
statements are rapidly determined and I
think somehow that this is a critical
property if we want to move away from
the logic this is the the meta property
that we want to look at for the
properties that it's at least one of
them that it's there let me just say a
couple of words about the contraction
I'll just do the the easy case where
land is less than 1 and why this is a
contracting map then but I'm not going
to give the whole argument so with land
to less than 10 which is actually I'm in
a lot of ways there you know the tree is
going to be finite anyway but still I
want to say that when lambda is less
than 1 that if you use the total
variational distance then you're
contracting
then you're contracting so the idea is
take a node and let's condition on it
having tea children and on the one hand
so you have two distributions on on the
state space x and y that have total
variational distance epsilon between
them epsilon does not have to be small
in this case epsilon between them on and
so conditioning on it having safe for
children and suppose that the total
variational distance between X and Y is
epsilon now we couple the two we we give
each node here iid X and then we couple
it with giving Y over here and what's
the chance that the state up here is
different well if in the coupling we
wound up giving exactly the same thing
to all four then they'd have to be the
same but each one because the coupling
only has probability epsilon of getting
a different thing and so even just
taking their some the chance that that
you would get a different thing for so
in this case the lesson one so office
maybe you can remark on the other pieces
oh hi yeah oh all right I'll just let me
just finish this one up there just for a
moment and then I'll remark on the other
one yeah so here it's just lambda
epsilon sorry it's for epsilon but for
has an expected value of lambda and so
it's there now what happens in the when
lambda is greater than 1 i'll remark on
the
what happens then is it it's more
complicated you you go down so instead
of sigh we're going to iterate sigh
which means the following we take a
point we go down s generations and then
at the s generation we give all the
nodes from distribution X and then we
backtrack all the way up and and and get
the original thing so I'm going to take
s to be s naught plus n first I'm going
to choose s so big that by the time we
get down to hear the chance that we're
not determined already is exponentially
small so let me just say it's less than
epsilon 1 so before I said now notice
before i was looking at nodes one at a
time here i'm going down s generations
but that's even more than one at a time
so what happens is it's only with
probability epsilon that the x is going
to have any effect at all otherwise
we're but that's not enough for
contracting because that epsilon is
fixed and you know maybe x and y are
really really close so now we say
suppose that the number of vertices down
at level s is T and we have and we're
going to we don't have anything about
what T is going to be okay ah but what
we want to say is this if if T is small
then the contracting argument is going
to work because that these T are going
to give T times lambda to the end
children so that would give an extra
factor of teal and at the end but we
have a factor of epsilon that is going
to have any effect at all and so would
be ok
would be okay the problem is what if T
is large what if T is large what happens
then well what happens then is we go
down another and levels so you can take
end to be like four to the K but that's
the technical part these are independent
trees if inside of these trees every
type occurs and every type occurs at
least K times then everything will be
determined by that by here again that
follows from that that's one of the
logic parts of the argument that is it
if every kind of tree occurs inside here
of a fixed size and occurs at least K
times then everything will be determined
and the chance that that won't happen is
exponentially small in T so the chance
that it's so call it bad if it's not
determined the probability that it's bad
is exponentially small and T what it is
bad we're getting an extra t times
lambda to the N which is hitting us on
the the contracting is becoming
expanding but it's T times lambda to the
end but times e to the minus beta T so
when T is big the e to the minus beta T
is going to cancel the tea so when T is
very large what happens is again it's
just contract so this is set an outline
of what's the most complex part of the
argument that that shows that indeed it
is contracting and you don't need the
contracting to show the unique fixed
point but you
do need it to show the that the function
is real analytic so let me mention some
other possible things to think about
here one thing is if you have a
recursive property um does the recursive
property uniquely determine or maybe
uniquely determine up to probability 0
the event so if you think of that if you
have a green child you're green okay I
use that for being infinite but there's
another model with that same rules for
green and red just call every node red
no matter what it is just call it red
then it's going to have the property
that if you have a green child your
green and yet the probability that your
green is going to be zero in fact that's
the spurious solution so what happens is
when you have the rules for the
recursive function they may not
determine uniquely the property and
indeed that's actually the case for
having a single child that has a single
child because then again do the green do
the green blue and red except now say
that if a point has an infinite tree
below it just call it green don't look
just call it green well that'll still
have the property that if it's green
it's green see if you have a fine I tree
then the the the the leaves are
determined because they have no children
so their call their state is determined
then you can backtrack so when you have
a finite tree everything's determined
but if you have an infinite ree parts
are not determined so in the case of
having a single child with a single
child there also is a second solution
but that second solution has the same
probability because you know when you do
have an infinite tree
you're going to have the property so
there's some connection here with with
what about the uniqueness or uniqueness
up to probability zero of recursive
properties there is their questions
about all right here off I started out
with this from the logic point of view
but what if you just start with
assumptions like rapidly mixing or maybe
something stronger or weaker can that by
itself tell you some things about the
probably always the goal is to say
something nice about this function is to
say something nice about or to say that
there isn't the cases where it's not
nice about it arm and let me add one one
final question that I've been puzzling
over and having done I can you as was
pointed out the this model has locality
I mean basically these first-order
statements are you're really kind of
talking about local neighborhoods in
some way so I can destroy that and and
keep a first-order language I can add a
first-order binary predicate that x is
an ancestor of Y if I add that predicate
I still have a first-order language it
still has the property that they're a
finite number of our Android classes
it's so and and so you still get
everything as before except that you
don't I certainly can't get these
results and I'm not even sure that these
results hold so one question is can you
come up with a sentence involving
ancestor where the function f of lambda
is not a nice function and I think
that's a good point to stop
comments or questions I mean one comment
you already made in Sweden was the one
that two verses in the same level as a
problematic element if you were to add
up your life the problem is that if you
put in that binary statement you can you
can actually say that the tree is
infinite because then you could say that
for all X there exists a y at the same
level that has a child so this this this
logic business is a tricky thing you
know you can thinking well let's
strengthen the language and and
sometimes very quickly you strengthen
the language and you know you just get
you know you get stuff that you don't
want ancestor I'm just not sure that's
that's why I'm pulling back a little bit
thinkin about Hansel interacting
property in the ancestor case sorry so
you're tracking property doesn't work in
there I don't know I know you know I
guess isn't certainly the proof doesn't
work because all the proofs service as
as seemed like you were your insight was
that there's there's a locality to
what's going on and and in a certain
sense that that permeates all the
arguments that you can look at if the
notion is that so just notice it if you
have a tree well there's the
neighborhood of the root captain you
have to know about I mean after all in
it you can make statements that the
route has five children there's the
roots of the constant so there's the
neighborhood of a route but otherwise if
you've got fixing the quantifier depth
okay if you've got sort of for each of a
finite number of classes you have k
copies of sort of sub trees or bushes
that that look like that then then the
air Floyd game the iron fight value is
determined that end what's happening
near the
so so in particular for infinite trees
when conditioning on the tree being
infinite you've got every possible local
configuration and so it happens is the
the theory really if you conditioned on
being infinite it collapses in a nice
way that the probability for any
statement a you only look at what's
happening locally near the root and and
how far down from the roof just depends
on the quantifier depth of a and if you
know that then you know whether it's
going to be true or false up to
probability zero okay so thank you again
each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>