<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>An Efficient Solver for string and regular expression constraints | Coder Coacher - Coaching Coders</title><meta content="An Efficient Solver for string and regular expression constraints - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>An Efficient Solver for string and regular expression constraints</b></h2><h5 class="post__date">2016-06-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/E98YJKEBDbc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
this table so photo mated deduction is
FG community so now to Treasury thank
you for the introduction and the
invitation so I'd like to tell you today
about a new solver that we have
developed to reason about strings and
regular expression character strings of
regular expressions in the context of
satisfiability modular theories so this
is joint work with a few people at Iowa
postdocs and students of minds and our
collaborators at NYU Morgan desert
dealers who sadly passed away a few
months ago and Clark Barrett who's the
co-leader of the CDC for project that we
do jointly with IO at NYU so our
motivation for to be able to reason
about strings is well mostly security
applications where strings are often
involved in operations that will expose
security vulnerabilities for instance
this code here as a vulnerability can
you see which one it is unfortunately
the vulnerability is a lot simpler well
fortunately for for us unfortunately for
for users and well so what's the idea
here that you have to enter a password
which he remember which is hard-coded
I'm calling that password and then if
what you enter is the sequence of
letters in the password strength then
you have access to some you know
protected part of the system but the way
that's declared is by C can I use a
point do it
is by using a buffer and then right
after that a character bass so if I
force the buffer overflow here i could
rewrite pass with y and then get in ok
well people do that that's a book yes
this is a bad program with itchy ayla we
kind of made it up to to make the case
here but you'd be surprised you know the
sort of vulnerabilities that you
discovered well you probably know this
that you can discover so dope I'm sorry
is that like ah well there is regular
expressions involved you're right
because you need to check that where you
enter is letters you know the surest but
poking with that too is that a little
bit of see in this program as well that
we using regular expressions or not in
this particular case but in terms of
formalizing this so that we can discover
the vulnerability automatically we do
need to reason about strings and regular
expression membership in regular
expression in regular languages so well
you probably know about satisfiability
modular theories SMT solvers are have
been you know a shown to be pretty good
at reasoning about specific domains one
thing we would like to do is convert
this problem into a logical problem that
we can give to an SMT solvers
specialized to reason about strings and
see if we can discover the vulnerability
which is essentially can we get to a
point where pass is why and well in fact
since we have implemented the
specialized string celebrated I'm going
to tell you about already in cec 464 can
actually discover this vulnerability and
give you in fact a potential exploit it
is by solving this logical problems and
finding its satisfiable it's able to
give you a security exploit yes
otherwise
and the fact that we have a huge a
sincere buffin house yes so here we have
built where is winter an input string
near that overflows so there's a why at
the end so somehow the text on the book
in the Box I'm column yes you've encoded
the fact that buff and pass or
physically adjacent yes we've encoded
that yeah well I mean I'm skipping the
steps here but this would be you know a
traditional standard encoding Christians
that you have in Boogie or Daphne you
know to talk about local systems where
you go from the code and knowing knowing
the semantics of the programming
language you convert that into a logical
problem that corresponds to the
operational semester particular one
where is it encoded in the buff and pass
are physically adjacent I'm just not
familiar enough with the language of any
more here in the fact that there are the
input is a concatenation of these two
again don't take this lid is not the
actual translation that you will get ok
so I had to manipulate this to make it a
little a little more readable but that's
the idea that you get here the fact that
I mean you translate it in such a way
that you capture the fact that these are
adjacent but don't let's not focus on
this which is about how you properly
translate a problem into into a logical
so I a I translate a security or safety
problem into a logical formula just not
the focus of the talk there are ways to
do this what I like to tell you about is
how we can solve these problems here
because until recently we were not able
to do it that is we were not able to
reason about strings in an efficient way
well mostly because people hadn't gotten
to thinking about this problem
seriously at least in the smt community
alone and in other communities people
had attempted and also because the
problem is actually fairly hard so if
you consider just word equations which
are just equality's between spring
expressions that contain characters and
concatenation and variables and they
said the problem is decidable this was
discovered after a long time it was a
surprisingly hard problem to prove but
the best algorithms that we have right
now or pspace we don't actually know the
complexity of this problem but the best
algorithms are actually quite
inefficient if you throw in length
constraints it is you also add to that
in fact linear arithmetic constraints
that involve length of the string we
don't even know that where the problem
is decidable or not and if you throw in
additional string functions like
replacement and substring and so on the
problem is actually known to be
undecidable on top of that I said we're
also interested in membership
constraints because they show up in
problems like the ones that I described
earlier so if you put it all together we
don't actually know whether they are
interesting fragments of this set that
we can reason about efficiently okay but
our focus has been that you know we know
this problem is hard can we write
efficient solvers that perhaps are not
complete but definitely we would like
them to be sound and well good most of
the time that is able to give us an
answer in the sort of cases we are
interested in now in fact there is some
work now being done in trying to
identify decidable fragments of this
large language and I'll mention a few
things later about that so again
whatever was our objective we want to
reason about we want to build a string
solver that is able to reason officially
about strings of unbounded side this is
a size this is important to stress
because if you bound the size of the
strings the problem becomes trivoli
decidable and in fact they are existing
solvers to do this that is they require
you to give an
bound and then they convert the problem
into a bit vector problem okay we do not
want to do this we would like to reason
about arbitrarily long string and
although you know we would do what I
have lent constraints okay and perhaps
including manipulating functions like as
I mentioned and do regular membership in
fact it turns out it's useful or
necessary to talk about symbolic regular
expressions which are regular
expressions where you lied allow
variables of type string and these
expressions in fact denote non regular
languages making the problem heart so to
be a bit more concrete oops it's not
time to take a break
to be a bit more concrete we want a
language that allows us to write a tamil
i'm going to call atomic terms which are
string constants gano arbitrary length
and variables and then concatenation and
length a length operator a language like
this will is going to be our core
language and then on top of that we want
to add additional stuff I will discuss
the core language here simply because
this is already hard enough to talk
about we also but we have also worked on
how to deal with regular expressions and
as I said additional functional
mentioned this briefly I'll focus on the
core language now and also because as
far as basic string manipulation
functions are concerned you can find a
way to reason about them by reduction to
the core language so string to int into
string prefix suffix we can convert it
to word equations similarly the index of
and so on perhaps using intermediate
translations and having word equations
and constraints of a bounded integers in
these conversions quantifiers are
involved so the problem reasoning about
them becomes more complex the underlying
principles here in trying to come up
with a solvent that deals with this
language for us is that of using
algebraic techniques why we want to
implement this in them to an smt solver
if you know how it's empty solvers work
although technically they you could use
any decision procedure that is
appropriate for the domain at least in
modern solvers it's important that
certain properties or did procedures
have certain properties such as
increment ality ability to backtrack and
things like that there are easier to
satisfied if you can write your
specialized solvers to essentially use
algebraic manipulation rules deduction
and algebra is your person you want to
follow but again specialized to this
domain now this contrasts with other
approaches that you found in the past to
reason about strings and regular
expressions there
for instance will reduce the problem to
an atomic anatomica problem and then use
automata techniques to do this this is
not appropriate in S&amp;amp;T solving because
of the need to backtrack and a cert
thing very quickly in a certain things
incrementally it's not easy at least we
don't know yet how to do this with
atomic data you don't need to be
constructed and then perhaps thrown away
right after this is not efficient so we
can lop with a solver for this language
that we could understand us having this
general architecture so first of all we
work in the context of SMT solvers
following the DPL LT architecture how
many people know about this ok so the
majority of you but just you know very
quickly for the others do not notice the
DPL T architecture is essentially a
general architecture from auto SMT
solvers where you have boolean reasoning
delegated to an efficient set engine and
then reasoning about simple forms of
constraints in a specific domain done by
specialized solvers and the simple
former constraints is atomic formulas or
negated atomic form the specialized
solvers and the set engines work
together to solve quantify free problems
over the language in question you can
throw in reasoning about quantifiers
using additional modules let's ignore
that for now so let's consider just 125
free constraints the DPL LT engine sorry
the DPL key architecture added so-called
EP ll X engine the SAT solver and then a
bunch of auxiliary engine so here we'll
be using a standard one for linear
arithmetic constraints this Li a solver
that are right there essentially a
standard one for constrains over
uninterpreted function symbols the EU f
solver there and then this new solver
that we have developed to reason about
strength so what is the idea essentially
well first of all if you have problems
that involve strings and
a linear ethnic constraints or length
forces there are standard ways to
separate the problems into the two
domains and then solve the original
problem by a collaboration between a
string solver and in arithmetic soul so
this is pretty standard I won't say much
about the other trick that we're using
here to build a specialized solver for
Strings is that of building that on top
of an EU F solver so the u.s. solvers
reason about equality's and congruence
in general and compute conference
closures by other side of equality on
top of this we will add additional
specialized rules additional deduction
rules specialize on strings okay so
we'll do the easy stuff using the
Congress solver then on top of that we
will add addition rules and the
additional rules are the ones that are
incorporated into the big picture that
you have been sorry the big square you
go on the right this string solve the
string solver itself essentially takes
constraints and produces new constraints
using a deductive approach but it does
that in a particular strategy and the
strategy here is illustrated by the
various boxes at a very high level in
fact the strategy is more complex in I
do need to simplify and the idea is that
you do a series of steps in sequence and
each of these steps can produce new
constraints new equations on each
equations over strings I'll focus on
equations and inequalities constraints
are fed back into the general engine
that also perhaps distributes some of
these constraints to the other solver in
particular constraints that involve
length in this case so at any stage if
any of these steps produces something is
returned back to the engine and the
process starts again you go from one
step to the next if there is nothing to
give to the engine and so the workflow
here is you start with the engine has a
set of constraints which are going to be
again atomic constraints with strings
constraints will call that set em that
is given to the string solver a bunch of
steps are taken them I produced more
stuff they're given back to the engine
this process continues to completion
where completion here is you discover an
inconsistency and the way we discover
inconsistency is by discovering
tributing consistently or you saturate
it is no more rules apply so we show
that when the process saturates you've
actually found a model of the original
quantify free good strength yeah again
we allow arbitrary quantified free
constraints but the bullying stuff is
managed in a standard way by the SMT
solver the rest of the S&amp;amp;T solver so
let's ignore that it's in Syria just
equality's and inequalities between
strings as well as atomic constraints
over little over arithmetic yes these
are just consequences as I'll show and
they are typically atomic well their
littles okay so you pass little there
are entails or if you have a situation
where you don't actually have nothing is
entailed by you have possibilities you
pass a possibility which isn't decision
say well assume this then you know the
solver will continue this theory here is
not convex in the technical sense that
we have in smt so often you need to make
guesses even with interest ring solver
these guesses are passed to the polling
engine in the standard way all right so
let's consider this problem here we have
these two word equations and then this
month constraints over x and y that are
strings oh sorry there live two
variables and AMV of characters okay
this problem satisfiable
dot means concatenation so we want to
find two strings where X is grit is
longer than Y that satisfy one of these
two constraints sorry yeah it is
satisfied right so there's a bunch of
ways to satisfy so we would like to
discover that so the first thing you do
is that we do as I said is to split the
problem into under rithmatic part and a
string part which in this case is per
view we also make guesses when we have
disjunctions about which parts of the
disjunction we want to work on and so
the problem where the supper own we
actually focusing on right now is the
conjunction of these two red things one
goes to arithmetic the other one goes to
the strength song okay notice as usual
that the two constraints sets of
constraints share variables and so
they're not this joint collaboration
between these two solar is going to be
needed in this case we don't have a
choice for the first one because it's
asserted is an atomic constraints but
you have a choice between these two
because of the disjunction right to
satisfy these two constraints you must
satisfy the first and then it's enough
to satisfy one of the disjunctive the
second so insurance law hypothesis all
in whatever to CNF yeah typically
internally they are in cns the input to
the solver is arbitrary but there is a
CIF I think you're saying you pick one
for each of the conjunctions is that one
for each of the disjunction so it was
yes but one disjunct this is an
exponential number combination to yes
but of course it's just not done eagerly
it's done as needed and using the SAT
solver and so on so again this is where
the power SMT solvers comes from or some
of the main the major factors in the
power since he saw that it can reason
about the disjunctive structure of a
problem very efficiently by having
surgery six by learning about
choices and so this is a standard S&amp;amp;T
stuff that I won't discuss that's fun
but engine it sorry it's part of that DP
ll exactly and the introduction with the
other ones because for instance when the
dll engine has to guess it does ask the
solvers if they knew something about the
guests that is about to make because
otherwise you know it's unnecessary also
wrong guesses needed to unsatisfiable ax
t and then to learning why you know you
made the wrong gasps and then trying to
avoid it later and so on okay so at this
point the first check is do we have a
conflict in our set M of constraints and
the only conflicts with we check for our
do we have a disability between two
identical terms okay that is we want to
reduce the discovery of a conflict of
this simple problem we don't have it
right now so we can see yes yes in the
book you have x concatenated be and in
series chance we have excavated with Z
is it just a typo oh yeah this is type
I'm sorry yes me or any anything you
want I mean this is just a pretext to
tell you about it's okay Jamie Bucky do
it's better to have you know slides we
know we know tacos in it but you can
reason modulo typos at this stage I mean
in this venue Tyson okay so um I do have
Z here so let's see how that works out
so let's say it's Z Z is available in
this case so a and B are the characters
okay it doesn't change the nature of the
problem okay so there are no dis
equalities we move to the next step so
what we do in that step is to propagate
from the string solver any constraints
that involve length there are interest
to the arithmetic solver and the only
constraints that we propagate are of the
form length of a variable equals length
of an RV
holes or not okay so in this case so
either that one or when we start
constraints of this form that we say
that the length of the left-hand side is
equal to the length of the right-hand
side but then in fact by using standard
algebraic rules about length we put it
into a form where the length length is
applied only two variables okay so
effectively length of X will be
considered by the arithmetic solver as
eight integer variable okay the
rithmatic solver will just see something
that it's called length of x entry to
this day so we have this constraint we
deduce this length constraint we pass it
to the DPL X engine so that communicated
to the arithmetic solver notice that
this is the constraint propagation step
that I was mentioning but there is a
opposite propagation step that is it
goes in the other direction so vs. in
this case by having this arithmetic
constraint the the theory solver can
give the series train this constraint
here is saying that the length of x and
y are different which is a constraint
that the string solver understand okay
the string solar does not understand
arithmetica does understand equality and
issaquah letís between length applied
to strength to available so this is the
sort of exchange of information between
the rithmatic solver and the string
solver that is needed and in fact enough
to make sure that the two solvers to
cooperate in a complete way so to speak
the next step when we're done with
propagation and notice again I should
stress every time we propagate something
the whole process restarts okay we
propagate any quality we give it back
then we check again we get something
into any new stuff we have a conflict
now then dunno propagations as well as
then the next step is to say well
we do have a variable string there do we
have string variables and if we do let's
guess what the length of these variables
is but we guess it and it only the basic
level we guess whether the variable is
the must be given the empty string is a
value or can be given a non empty string
so this is the only case the guess is
done one at a time but eventually a
sequence of guesses might lead to one of
these situations not necessarily all of
them you know some of them might be
immediately discovered to be
unsatisfiable and so recover but
essentially you know you will consider
these four cases at least in principle
when that is done that is when you
figure out for all variables where you
want them to be empty or not empty then
you try to normalize equations between
them so what is the idea sorry equations
between terms for every string term in
our problem we want to produce a normal
form where a normal form for us will be
a concatenation of atomic terms where an
atomic term remember is either variable
or a string constant okay so this is our
normal form just a sequence of
concatenations you know modular
sensitivity of atomic for atomic term
and to be able to do this then we
process the very various equations in in
a way that allows us to get the normal
form as I will show in a couple of
examples ok this is in a sense one of
our contribution that is to be able to
normalize using strictly algebraic
techniques what once that every term as
a normal form and we haven't failed yet
what do we have we have a set of
equivalence classes that we have been
able to deduce and for each of these
equivalence classes we have this normal
for mobility there is no that the terms
in there by equivalent to this normal
one at that point we have to worry about
cardinality we have to worry because
remember we have lent constraints do we
have enough
string constants to assign to these
equivalence classes what we do then we
partition the equivalence classes into
buckets where two equivalence classes
that are not supposed to be marked go
into the same bucket if we want them to
have a value of a given lend same length
for the two equivalence class different
values England they go into different
buckets if we want the equivalence
classes to have values of different
lengths okay this partitioning process
is partly driven but what we know we're
ready and partly driven by guesses so
again this guessing steps here then my
restart the whole thing every time once
we're done with that and well let's see
if I actually it was well once we've
done that we'll go to check
satisfiability but i'll just go i'll
describe this later so how do we do
partitioning so again the super our
example where we have this set of
equality so these are the stringy
qualities and these are the length
constraints that we have given this
problem we notice that well since these
two strings have to be the same and x
and y have to have the same length right
we can slice them off from the problem x
and y have to do the same length so the
rest of the straight that is z in this
case Y a B also have to be the same
length and then we need to figure out
you know what Z is so in this case we
also have we also know that Z has to be
different from W so the slicing in
particular is simple ok so again x and y
i have to be sliced off because i have
the same length or can be sliced off and
then we know about these constraints
that z has to have to form w SS r VW and
then continue with something else that
we call it Z Prime so we literally add
that information as a constraint where Z
prime is a
rushville okay notice that now the
slicing process will continue well to
completion eventually and when you're
done slicing then you have added new
constraints that tell you what variables
or what terms have to be equal to what
given what you know starts there yes
sorry you leave the ellen show instead
yes this is a monotonic reasoning
because we're doing this by deduction so
we never throw away constraints the only
case in which story concerns is when we
backpack right but in terms of a
calculus in fact we do describe this in
terms of the calculus in our paper you
can understand this as a pub locale in
this way in every choice using a
different branch within the branch we'd
never throw away anything of course we
might deactivate you can practice some
stuff it is some constraints I've given
us everything that they have to give us
so we will ignore which you could
understand is removing them but in fact
you remove stuff only if you replace it
by equivalence equivalent set of
constraints often however the deductions
are deductive but not in an equivalent
of preserving way so we need to maintain
the old ones ok so this slicing process
here can be done in an analogous way
home also with disa qualities let me
skip that I hope you get the gist the
difference being of course it with disa
qualities when you slice off any prefix
that has to be the same at some point
you want to discover that pieces of the
two terms on the left and the right hand
side of the disc equality are in fact
different right otherwise you have any
consistency that is my end up quitting
stuff that you should now notice how the
slicing process also sort of narrows
down the kind of guesses that you have
to make these two guys here are supposed
to be different but I know that actually
well trivially in this case X is equals
to y so the difference you can not be in
that prefix essited later ok and so you
make the guests were since
at Z and W or different and see how that
goes and again we might be the wrong
guess that you recover from your guesses
and try it there is a challenge in doing
the sort of slices with has to do with
the fact that our variables are
unbounded okay if you know bounds on
these variables then this process the
slicing process is guaranteed determined
because every time you slice you're
getting push or something smaller that's
not the case we run by the strings this
is part of the difficulty in a sense we
could say that this is the point that
makes the whole procedure forward
equations so complicated okay the
ability or the possibility of very
cycling situations like the one that you
have up there okay so you go basically
from a linear problem to a wealthy space
algebraic think that the problem is
actually and pain complete but again we
don't so first of all is this constraint
satisfiable by itself abb characters in
X available yes so this is deceiving
problem it's actually unsatisfying you
can give an inductive arguments for it
you know try the empty string definitely
doesn't work then you can show that a
longer string actually don't won't work
either finite unbounded they wear finite
the the problem we still be
unsatisfiable we would discover it okay
for you an instance of X where X is
infinitely long oh no sorry the lists
the strings all finite but the variables
have Alan baquba unbounded what could be
a sign arbitrarily the finest
mmm let's apply a process or slicing
process here see what happens excuse me
well access to start would be if you
look at that so we slice the problem by
exactly saying that the X looks like be
followed by X prime but then if you
replace X by this scene here I replace X
by its equal bx prime you get DX prime a
be be X prime so you can slice off the
be in your map having this derived
problem here with X prime which is as
exactly the same form as the original
one so we produce a variant we have not
made any progress again why because X
Franken Exxon selects rankin can have
arbitrary longplay if we kept slicing
like this we will go into the loop okay
so in fact our procedure is not complete
because of similar problems and
incompleteness shows up exactly in
situations where you have these cycling
things for unset of unsatisfiable
problems okay it is ill try if you have
multiple occurrences of the same
variable in 1 equations they might end
up keeping slicing / nor now this
particular case we know how to address
okay so we have a rule that actually
breaks the cycle here but there are
other cases that we're not addressing
but in completing it goes into a loop
sorry but incomplete you mean it goes
into incomplete I mean by a complete I
mean refutation wing complete that is
unable to discover that the input
problem is unsatisfiable okay when the
problem is satisfiable we have a
strategy that is guaranteed to find a
solution so we actually loop in the
unsatisfiable case which if you think
about it is a strange thing because this
is for serologic and by completeness
first order logic you know that in the
satisfiable case you can always find a
proof okay but notice we're not using
standard for sort of logic rules here
we're using a specialized system which
is meant to be efficient we paid the
efficiency that you know we pay for that
efficiency light beaming complete a
simple inefficient but complete
algorithm yes that will work again
complete means reputation complete so
they will work when the problem is
unsatisfiable but that algorithm will
now work when the problem is satisfied
oh ok now i have to say yes we don't
actually have well if you run them in
parallel under the right assumption so
you know i would have to give more
details here you do get a decision
procedure but again the right assumption
identify fragment that we do know it's
desirable ok so in fact our decision
procedure might also live from in
certain satisfiable case ok but if I
have time I'll tell you a bit more about
this later the point is we have a
looping situation here can we address it
I will just flash this I'm not going to
go into it you can prove that an
equation like this where S&amp;amp;T are
arbitrary string terms and again x is
available is equivalent to this problem
so essentially what we do is given this
we introduce this sort of kaneez
constrains here where y and z are fresh
variables and notice that we have some
equalities here that essentially have to
do with the fact that you know there's
some sort of reverse thing going on here
but we the important thing I want to
stress is we also introduced a regular
membership constraint which is symbolic
these two variable these two are
variables ok that's why we need to deal
with symbolic membership constraints
even if the original problem didn't have
them ok again I won't focus on
membership constraints if you're
interested in in this you know we have
to give it up and not a talk at another
time ok but again we have a way to
address these sort of simple loops
now suppose we have normalized having
applied this normalization these
normalization rules which again on and
waiting about right now I will show you
the later time for medic once you've
normalized then we have a bunch of
equivalence classes between string terms
where every equivalence class as a
normal form let's partition these of
those classes how do we partition put
them into buckets as I said we're
equivalence classes that we know are
different go into different buttons for
sure okay so for instance suppose I know
that the length of t1 and the length of
t2 are different definitely 2122 belong
to different classes one into I know
that I can't merge those equivalence
classes right because you're supposed to
have different lenses as string time so
t1 t2 and t3 in this case go into
different buckets what about say t1 and
T 4 suppose I do know that T 1 and T 4
well you want people are in different
equivalence classes okay but I know say
that their length is the same then they
go into the same bucket I will assume
this stuff they I can put in the same
bucket can have if in each equivalence
class can have a different string value
of the same length why because if you
can't it means that I have to merge the
two classes and so in fact one call is
not okay so this is the partitioning
mechanism why this helpful because
basically it allows you now have to
compute an actual model of the problem
whereby model mean a assignment of
string variables to spring constants
that satisfies their constraints okay
innocent teen t20 hd3 so the the bottom
you have that thing yeah these are the
lens the level 31 is different here so
is that too is that two inequalities we
added me your question I really meant
the three but
I wrote it it's lovely that way we've
only had two there'd be a bit harder to
if I only had two and i would need to
guess again weird to put them I mean
this is a step at this point now this is
a sailor constraint satisfaction problem
right so you know I have these many
buckets I have these lady terms I have
to put them in there right how do I do
this so some guesses are involved here
again and that goes back talking to
sorry that both obviously ever every
guess my involve backtracking yes this
is this is essentially a CSP problem
analogous to a colorable ok so again a
standard techniques apply there too and
they are implemented in our solver the
interesting aspect to consider here is
that when you put stuff in the same
bucket just say they all have the same
lens but they have different values but
now you got to be careful like do I have
enough values of that length in the
string domain right pretty sizable I
can't have if I have you know two
characters I only have two different
strings of size one right if I put three
thugs things in there I have a problem
so the next step is to generate
cardinality constraints that capture
this so we add cardinality constraints
that are meant to make sure that the
assignments that we make in the buckets
respect cardinality restrictions on
distilling okay once we do that and
everything checks in the sense that we
go through this whole process again with
nothing being produced then we have
saturated we can show we have shown that
at the end of this process we really
computed a satisfying assignment or the
original problem just just a threat
sorry Sigma is known
yes maybe I should have said this from
the beginning our alphabet is finite
okay it's known and finite now of course
the algorithm is parametrized by the
alphabet the actual implementation is
into a unique 256 characters the ASCII
characters and so on but you can easily
change it that way but it is important
that it is finite if the alphabet is
allowed to be infinite then you don't
need the cardinality shack right bucket
as many things you want because you can
always get a new camera token so at this
point we're done I mean hopefully I've
given you the general idea about this
algorithm how do we actually do this as
I said we do it by using these algebraic
rules you can understand the process or
you can describe the process
theoretically as a tableau calculus this
is how we actually do it and then you
can pre properties about this calculus
they are satisfied by any proof
procedure that has you know this
satisfies suitable restrictions since
the implementation is effectively an
implementation of a perv procedure than
the properties that we discuss about
this calculus are inherited by our
implementation logical bugs of course
and so what can we show that in this
calculus which Venus a block of this
produces the derivation tree if I close
the tree that is of every branch I get
an inconsistency then that tree indeed
tells me that the problem is
unsatisfiable ok so I have some this
reputation sentence if one of the
branches saturates as I mentioned before
we actually find a solution for the
original problem ok but the problem is
satisfied we have what you know we could
call solution
that's it we don't have termination we
don't have a reputation completeness in
the general case however fools
experimental results that i'll show you
in a bit tell us that well show us then
in many cases we actually produce an
instant asset porsche all right if
you're interested I'm just going to
flash the rules here the rules of the
calculus that formalizes this process
there is a the calculus was publishing
the CAF paper from last year and we are
submitting just this week a journal
version of it which has a lot more
details so if you're interested in this
just let me know I'll be happy to send
you the journal where's the calculus
works on a bunch of components we call
it a configurations that stores the
various constraints so there is an S
component that has just the string
constraints there's an a component as
only the arithmetic constraints plus
side of things for since we build a
normalizing function that uses something
that we call a flat form and so on so we
have several components and each of
these evolves is a well is modified by
the rules so we have some standard you
know trivial rules for since
propagations if the string component
entails that the length of x and y are
the same tell the arithmetic flower okay
and how do we know discover this
entailment by just using conference
closure okay so we have simple ways to
discover these intelligence if you're a
thematic constraints until the length of
x is equal to length of Y tell this the
string constraint how do we know that's
well we're using in a rithmatic salt
yeah what are the things to me no I mean
suppose we know that these two terms are
supposed to be the same in the
conference closure of s it is s entails
they're supposed to be the same where x
is variable in t is not available well
well x is available in t is an arbitrary
terms then tell the earth matic
sovereign to these two terms of the same
length okay
so this is the sort of stuff that goes
on I told you about splitting every
variable deciding what length it is so
if x is available then guess that it is
the empty string or it has a length
greater than zero this is a rule that
breaks the loops well this is we do have
another unsatisfiable rules you know if
your athletic solver discovers an
inconsistent definitely I stop yeah we
have additional rules i haven't
mentioned before and these are sort of
technical well the conflict rule in this
ring solver is the obvious one right if
two terms are equated and in equated at
the same time before the code but we
have the sutter spread rule that says
well if you don't know where two
variables should be the same or not then
guess yeah so again this shows you that
you know we're dealing with an empty
heart problem so we do need to make it
we also have a reset rule that says
every time you deduce in new equations
between terms all the data structs are
going to compute is so far recompute
again what are these data structures are
the ones that tell us what the normal
forms our stuff is right if you have a
new equation normal form to get here is
let me just tell you quickly about the
normalization process you know this
slicing process that I mentioned before
is well the slicing profitez proper
process proper is done by other rules
but the normalization process when
you're done slices is done this way
every term is associated to a flat form
which is again just a sequence of atomic
term constants or spoons now at the same
time every equivalence class of terms is
associated with a normal form normal
form has the same form as a flat form
the difference between the two is that
the normal form is final unless you had
more equations i know that this theorem
is it supposed to look like this whereas
a flat form is an intermediate
and how do I go from a flat form to a
normal form well I look at the
equivalence classes a class of a term T
if all the terms in the equivalence
class have the same flat form then we're
good we can make it you know promote
that platform to normal form and
associate it to the whole equivalence
class how do we compute the flat form to
start with well bottom up in a sense
suppose T is this shape bike on here i
mean the concatenation of t1 to t2 TN
and I have computed the normal form of T
on to want all the way to TN then the
flat form of T is just the sequence of
all these normal forms well you know
possibly normalized a little further but
let's let me just sweep that on the draw
okay so this is the idea essentially
these rules do the slicing and notice
that some slicing is is actually
involves no guesses if s and T at these
platforms that is have the same prefix w
okay and you know that you anatomic term
you and atomic term at the same length
then you must acquit them okay this is
how you derive new equality's in a
situation where you don't know whether u
and v have to have the same length okay
then you guess that one destroyed when
you know that they don't have the same
length then you guess that one is longer
than yet and you can tell you that one
finally these are the rules for doing
the buckets let me skip those and I
mentioned the theoretical results
reputation soundness and solution
soundness we also have solution
completeness at least a version of our
calculus or a procedure is solution
complete in the sense that it's
guaranteed to produce a solution if the
problem is satisfiable and this
guarantee is achieved by font defining
model finding techniques so essentially
we we go back to bounding now the length
of the strings and we tried for
increasing bounds of the
the bounding is done in a fair way so
that again we explore all possibilities
fairly if there is a solution obviously
it involves assigned variables to find
the strings so there is a global upper
bound at that point notice however that
you know the solution complete version
is slower than the regular one because
it's it's trying it said that it should
be pinning kind of process versus you
know a get first kind of processor we
follow in the jungle place so this is
you know solution completeness as a cost
the project approach is reputational
incomplete as I said however we have
identified a fragment well which it
happen it so happens is equivalent to a
fragment identified by others and
discuss in another calf paper that we
call a cyclic problems where our
approach is also terminating and so
reputation complete okay so in essence a
sickle problems or problems where you
don't have repeated variables or if you
have repeated variables in a problem
they are controlled there's a control
form in which you have the petitions
this is all about performance will you
because uh I think there's a solution
complete and reputation reputation it
could be algorithm which is just
enumerate although yes of a model yes
I'll sing for listen obviously there is
a trade okay look but yes as I said we
are interested in efficient solution
right so this one is definitely more
efficient than the naive oh good that's
for sure but it's slower than the
incomplete one that is experimentally
right the majority of problems that we
consider are solved by the fasting
complete ones of satisfiable problems ok
so the incomplete the the solution
complete one gives you this guarantee
which is often not really need
because the other one is fast enough is
good enough the first one is good okay
so bad I guess your hope is that your
typical cases you're going to be pretty
quickly yes it's so much asst our
implementation is done in a solver that
actually as can be run in a portfolio
virgin when you run different
configurations at the same time so you
can always run the solution in complete
one and the solution complete one in
parallel and you know knowing that you
will get the answer and fast enough
holes corpus of these straight line
problems that you able to this is a
standard purpose of these chinmaya
problems father like universe at solving
competition that is the one for these
students that you could this is all new
I mean it's really odd is it you know
fresh out of the oven so we don't have a
competition it however I happen to be
also the the one of the main
coordinators of the SMT lib initiative
who also runs smt comp and we are
devising a standard theory for the desk
so hopefully next year we'll also have a
competition next year you win the
competition yeah well we win in that we
would win it now if we had a competition
now we would win it however we also need
new problems okay so the hope is that by
that now sissy now we have solvers we're
going to get my problems from users and
in fact there is a huge need right now
we have users that get our solver as
soon as we check in you know the new the
new version and get up they'll download
it it uses and give us you know feedback
and so on so there's a you know pent-up
demand for string solvers in the
community by community I mean
verification or security community sorry
bit blasting strings is reading bit
necessarily I mean if the problem is
small enough and no but you can you can
do a lot of so there is this hempy
salary the one that doesn't being used
until now it's very useful it's still
very useful it just doesn't scale right
so that's why we're working with with
these different approaches and by the
way we're not the only ones anymore I
mean they are a couple of other well
three in fact I know
concurrent approaches they are solving
the same problem all right so our
experimental results we as I said we've
implemented this in our CBC of war smt
solver and then compared the solver
against a previous saw were called
Palooza that used some a serious of
heuristics but is not technically
innocent T solver but it was the best
that it was you know for a long time
then this you know competing solver to
speak called XIII str built by some
colleagues of Purdue and Waterloo in
fact that actually realizes in which
implements a string solver on top of
XIII you guys know about j3 so
technically is not z3 is a modification
of XIII called c3c are in fact there's a
new one that I'm not don't having the
slice called s3 which itself is built on
XIII as e3 str ok so the top solver what
I'm sorry finding there's another one
called norm but this is really new we
don't have any experimental evaluation
with the North Noren will be hopefully
presented at keV and let me just fire
quickly give you the results we consider
you know almost 50,000 benchmarks
generated by a web security application
and well it turns out colusa is not what
we you know we will consider a good
application right now in terms of
solving it has all sorts of problems is
both unsound incomplete doesn't produce
solutions so you know we have really
improved tremendously with respect to
the state of the art at that point the
comparison with z3 is more apt than GG
three str ism for serious string solvers
going to speak except that for some
reason is not able to compete
can compute complete solutions that is
often it will remember cases will return
partial solutions not all variables are
assigned about we don't know yet this we
were investigating with the developers
but you see the numbers you know in
terms of performance and I guess it's
it's easy to see that well first of all
we have no unknown answers we do have
timeouts no no no errors you check the
Solutions against you know the solvers
against each other and so on xiii scr
and cs4 produce no errors elusive
produces a lot in terms of raw
performance this picture gives you a
sense of how it goes this is cumulative
prime time okay so this is CC 3 and of
course you know the the y-axis is on a
logarithmic scale so the majority of the
problems here or trivial to see you see
three then you know it gets hard quickly
in a sense but for this version of xiii
that we just get here that we tried here
it gets hard a lot sooner although right
now they have a latest version that
flattens this a little bit Kalu's this
Oakland and I'm done well let me tell
you about right additional work we've
been working as I mentioned also regular
languages and we identified a fragment
where we actually have a decision
procedure this seems to be a no result
okay not published we're interested in
you know we're looking at more fragments
where we have refutation completeness we
are working on optimizing performance
because we have real customers that want
this thing so on any particular they
want these others string manipulating
functions like index substring and so on
and a lot of this work can in fact be
generalized to a parametric theory of
sequences where you don't actually have
strings a character but you have
sequences of anything there again you
need to ask yourself whether this
anything is this a final central
okay and I would like to say I'll take
your questions now but I you know I got
a lot so I'll take other questions now
thank you very much there is visiting be
busy until the other big source of
strange up-tempo iteration full
operations in the desert okay so all the
questions during lunch thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>