<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>How abstract should abstract types be? | Coder Coacher - Coaching Coders</title><meta content="How abstract should abstract types be? - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>How abstract should abstract types be?</b></h2><h5 class="post__date">2016-06-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/opbG1MTfXgs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
so so I'll only take you back 25 years
but before I do that will you be hearing
a lot about type systems today and
tomorrow and I wasn't absolutely sure
everyone in the room knows where the
type system is so here's my 32nd
introduction so it's better than a
cartoon by Luca himself where he depicts
three kinds of typing and his preference
is pretty clear but say you have a
language to count fruits okay so if it
is hungry tight then to a person C plus
three oranges that's an arrow let's
clean clearly cleanly detected at
compile time public or if your type
system is a little better and has
subtyping it is five pieces of fruit all
perfectly sound the language is weakly
typed into a purse press zomg that may
be five apples or maybe forty two
turrets or maybe a security whore okay
and if it isn't tight then there's no
abortion no oranges there's only bits
and when Oh plus when one is 11 because
that's what the hardware says now you
deal with it all right so if you move a
little way from just from fruits and add
things like functions are you order
functions and data types and objects and
classes and modules and all the features
of forming languages and try to put
types of all that well you get a very
interesting formal systems that have
been the topic of much study and in
particular by Luca in the 80s and 90s so
that can go in several directions
messing towards mathematical semantics
to Wells logics and connections with
pool theory to a process calculi or to a
small bright things like security types
of static analysis types of compilation
but I think one of the applications that
look I was particularly keen on is type
systems or language design and the idea
that that the type type systems gives
the structure give structure and thanks
to language designs the way a skeleton
gives structure and strength too many
anymore and if your if your language
doesn't have
a solid notion of types to begin with
then basically it is spineless okay it
looks like jellyfish and a case in point
javascript alright and so so as already
mentioned by Dave and and Gordon so so
look did a lot of work on language
design so big languages and smaller
languages so probably the bigger is
medulla 3d object oriented project he
designed and but I'm particularly fond
of his smaller languages so amber quest
and the Bleak of the three I know best
but there are other earth because where
they are clean slate designs you know
starting with a few orthogonal ideas and
trying them to completion and then
coming with meticulous implementations
and likewise when it comes to two
publications of course look a published
a lot of impeccable conference papers we
describe this activity to me when they
are engineering inference rules but but
but I am particularly fond of his
slightly less academic hiding like this
survey with Wegner and this chapter in a
handbook or the type fool programming
report which is both were lecture notes
and questions of manual and well that's
as his manifesto okay he he really
explains why he cares about type systems
and why we should all right so so moving
to well let me move go back to one of
these texts went about polymorphism and
tap abstraction so basically where we
think now that we understand them well
and as kind of your concepts so
polymorphism is just universally
quantified time variables you have a
function that reverses list and so all
type T's is going to take a list of tea
and give you back a list of tea so I
think this is all right this is very
well understood today and it's even
standard
in maine in mainstream languages like
Java or C sharp type abstraction where
of course its existence early quantified
I variable so there exists that IT that
you don't really say which one exactly
that comes with constants and operations
for instance to to have finite sets of
integers and why is this interesting
this is abstraction we are typically to
enforce invariants over data structures
maybe your integer assess will be
represented as binary balanced search
tree so not just any binary tree but
when there is a search tree that that
work and when that is balanced at this
one and and so is the operations very
abstract type and for these invariants
then they will hold for the whole
program execution then there are notions
of the presentation independence since
the eyes of the program doesn't know
about the implementation of the abstract
app you can change it preserving
functionality and and the rest of the
program will not notice and there might
be some uses for information hiding in
language based security you see a little
bit of that in the security
infrastructure for Java and C sharp but
well I think the security people believe
that it's not not quite enough and needs
to become complemented with more
classical approaches like photography or
hardware based protections all right and
then the so so so far so good but then a
a problem that was identified early is
that how does it work for a big program
where for instance you have two pieces
of code that want to exchange in values
of type integer sets okay knowing that
they are linked with one of several
possible implementations of this integer
said at start type and it's actually
quite hard to make sure that the two
clients use the same integer of set
implementation or at least compatible
ones and for that basically you need to
give an identity to the values types T
which are essentially quantified in all
three implementations okay and there's
really no consensus on how to doing that
okay so this is a partial landscape at
when end there the idea of using global
unique names like in
I'm a jeweler but there's a very steady
view of the world doesn't support like
things like on time generation of
abstractions the other hand there's
there's beauty for a formalization by
garden plot keen and John Mitchell based
on packages which is completely dynamic
purchases are for flood values but has
absolutely no notion of identity in the
middle yes Colonel ml functors that are
also based on names but not as syntactic
as those ones and support a little bit
of fun time generation of extraction for
functors and then a lot of work that
tried to either take SML and extend it
towards richer more dynamic handling of
attractions like high order funky
functors first-class modules or going
the other way starting from here and
adding some other typing machinery to to
make it more like SML basically and and
so so some of that work device to Moscow
ml for instance and opml to but then
there are also plenty of other
approaches completely different like
based on mixings and virtual classes in
Scala and probably others that I don't
know about so it's a little bit of a
mess and actually need internship i did
with look a memorable internship i did
with Luca in 89 was basically starting
from here and doing baby step to go out
there and then in the 90s are kept
working on that in the context of Jamel
and eventually moved on to other oh
these are topics and recently I'm coming
back to it from a kind of a different
angle so for the last 10 years have been
using an interactive proof interactive
lamp or so the cup of assistant
well-to-do specification and pokes of
programs like things like that Cody I
fires compiler static analyzer 06 cetera
and I'm now using cock also as a poem in
language because in the specification
language there's a pure terminating
functional language that comes with
super rich dependent types okay so in
the type system of this language you
have the full power of logic and and
it's interesting to look at how the cock
stand our library defines data type with
invariant
like finite sets so that the work of
literature and filia well they start
with some very concrete representation
of binary trees and then define
operations just like you would do in an
Aloha square and they define and the
invariant that the values of type hyper
should respect for instant that it is
binary search tree so that just allergic
or a statement or jiggle proposition and
then they prove the concrete operation
and they're well for many hypotheses
well for meneses reserved I operations
like a whole ad and if the argument is
well from then you have the expected a G
like equality over ad and mem all right
it's all so far so good and the next
step is to encapsulate all that in a
dependent type so the type of finite
sets is actually a dependent pair of a
data s of type hyper and approve term
that proves that it satisfies well from
ave s ok and then the complete operation
the whole operations can be wrapped so
that they propagate the invariant and so
you get ad which is a function from T to
T and you can specify and prove the
wrapped operations without well for
Maness hypothesis because values of type
T are kind of self-certified ok they
carry their own proof that they are well
thought so it's pretty nice and you will
notice that we are not using any kind of
type of attraction here the type T is
completely concrete and structural and
that gives a bonus point which I found
useful recently which is extensibility
apesta AI it is possible for client code
to a new operations of assets that need
access to the representation a bit in
the style of inheritance for instance I
had a need for operations like given a
set and me if it contains an element
between 20 and 25 or given a said give
me the subset of all elements between 20
and 25 and if you have accessed as a
binary binary search tree representation
then there are very efficient algorithms
that do this
okay just by cutting functions that are
clearly below or clearly above and and
and and but but if you don't have access
to this completely presentation you
don't get the good complexity all right
so do some ice in this approach there is
no obstruction to speak of but no
syntactic type abstraction at least but
it's very good at enforcing data
structures invariant it even proved them
okay and invariant can be quite complex
talk about the current state of the data
but also about Chen of the history that
led to his creation there is no
representation independence to speak of
because the client could can depend
under completely presentation but at
least if you change this completely
presentation all you change invariant
that that it holds over it the client
code will not type check are we not
proof check so at least you get our
detection there are clearly no
information hiding but you get
extensibility a past era which might be
useful sometimes so to conclude how
abstraction and abstract I be well I
still don't know but at least I can I
and all of us can look at the question
maybe from new angles coming from for
instance dependently typed languages
like AG dan card and at any item
grateful to look out for introducing me
to that question a long time ago so
thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>