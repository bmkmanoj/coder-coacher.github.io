<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Energy Debugging in Smartphones | Coder Coacher - Coaching Coders</title><meta content="Energy Debugging in Smartphones - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Energy Debugging in Smartphones</b></h2><h5 class="post__date">2016-08-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/A8P9ZC_TPdk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
hello everybody it's my pleasure to
introduce ab enough paddock he started
as an intern MSR in two thousand two
thousand nine nine and during that time
he woke on some problem about how to
split the computation job from mobile
system to the cloud and that motivates
his follow-up work about using some
models to predict energy usage on
smartphones and then he went down to
work on a bunch of stuff about how to
debug energy consumption on smartphone
how the profile energy consumption on
smartphones and that generate a lot of
press coverage recently in BBC News MIT
Technology reviews etc and he will cover
these topics during today's talk okay
thank you being thanks for the
introduction hello everyone I'm up in a
paddock I come from Purdue University
and those who don't know where / do you
is it's a located right in the middle of
nowhere it's surrounded by miles and
miles of cornfields flatlands Miravalle
you see so today I'll be talking about
some of the work that goes as my PhD
thesis and which is energy debugging in
smartphones this is already 2012 and it
is very safe to call this is the era of
smartphones who very old news
smartphones are selling more than pcs we
are seeing this from last quarter of
2010 2011 2012 the trend continues and
it's increasing but what we are seeing
is people really use their phones they
depend on their phones and it's
predicted that a number of people who
will access internet from mobile devices
from smartphones will exceed the number
of people who access internet from PCs
this talk is about one of the most
critical problem in smartphones which is
of energy consumption why is this
problem their energy is a very very
scale or sacred resource on smart phones
smartphones comes with a limited battery
life and if you look at the last 15
years of research in battery energy
density battery energy density has only
doubled whereas you see modern-day
smartphones they're getting faster CPUs
multiple cores 3g 4g raiding our
displays GPS cameras multiple cameras
and basically there's a problem between
producer of energy and the consumer of
energies since energy is getting a very
very critical problem what we have
started observing in smartphones is a
new kind of bugs which we call as energy
bucks what is this this phenomena
whenever an energy buck strikes you you
get a single symptom from that point
onwards your phone starts training
battery at a very very high rate in case
of the most notorious energy bucks you
don't see an application crash you don't
see a blue screen of death like OS crash
or something everything works fine your
Facebook runs your gmail runs we are
client everything all the applications
are running but then you just observe
that the phone is training battery at a
very high rate and normally this is very
frustrating people think the common
perception is some app has gone rogue so
let's try to kill open task manager kill
some applications in some cases it helps
in some cases it doesn't in most of the
cases it only makes the problem worse
irrespective of that fact it is very
very frustrating and we start down this
line what is this new thing that we are
observing what is this energy box where
do they come from what are we dealing
with this here you never observe this in
pcs and laptops so we did a lot of data
collection just just understand what are
these things we went to mobile internet
forums these are places where people
post what problems they are facing in
their phones we went to four really
popular mobile forums we collected about
million posts of these users we did some
data mining on this post got out what
are
image posts related to energy drain or
severe energy drain we did some
clustering on this we had 39,000 posts
related to energy we did some clustering
and once we got thousand clusters i sat
down and read all of them basically
trying to build a taxonomy of why is
this problem happening we also went to
mobile code repositories like Android
MIMO open source repositories where we
found our way we are looking for the
patches the developers put to fix energy
problems so that we get some insight why
are these problems coming in
applications and with all this
information and some information we
obtained from the tool we build which
I'm going to talk today the energy
profiler we built a energy buck taxonomy
to see where the problem comes in where
the problem comes from let's see where
does this energy bugs come from well
that's one of the most obvious places to
look for something wrong happens in
application and now your phone starts
training energy at a very very high rate
if you use android phone you make a
phone call depending on the version and
the hardware let's say irrespective of
how long you talk after you hang up the
phone put the phone in your pocket your
phone is going to drain battery about
you may go off in 12 hours even though
you're not using the phone it's just in
your pocket the problem can come from
framework like Android mmmm something is
wrong there something is wrong program
but things are not working the way you
want it to problem can come from OS and
this is very popular in news whenever a
new version of iphone or iOS comes out a
lot of people scream that new version of
iphone has a lot of energy problems for
the first time after iphone 4s comes out
Apple acknowledge that I us had a
problem I had an energy pack they fixed
it even that version had a problem the
fiction is the one even that has a
problem and finally in November and they
were able to make the problem good we
found out the problem can come from
device drivers something is wrong in
device drivers things and not working
the way you expected it to be or from
the hardware people are complaining that
your hardware could be a source of
problem something is wrong with the
battery something is wrong with your SIM
card something is wrong with your SD
card and the final thing is the prob
least kind of energy bugs come from
network operators something is wrong in
your network and applications now start
training a huge amount energy so are
these huge number of posts 39,000 post
we did this classification of which
categories these post fall into just to
give some rough numbers hardware was
twenty-three percent software is
thirty-five percent external was twelve
percent thirty percent of people didn't
realize where the problem is coming from
in hardware the problem can come from
external hardware or internal hardware
you have a doc let's say and now there's
the pins under doc are short-circuited
so whenever you place your phone on it
your phone drains battery or the problem
comes from your charger your charger is
faulty it's not just charging your phone
properly it will come from internal
hardware which could be your battery has
gone old or the interface between the
battery and the operating system is not
correct so it's not able to read how
much battery is lift off your SD card
has a problem some corrects corrupt
sectors in SD card and now your
application are going in a spin your SIM
card has a problem it's probably an old
generation SIM card or something wrong
happened with the SIM card any
application that accesses contacts on
your SIM card is going to drainage huge
amount of battery it just hangs there
and tries again in a game the problem
could come from external please for
example an external service crashed a
mail server crashed and now your mobile
is trying every five minutes to
authenticate to the server goes on or
ours and ours and ours and now you're
draining battery but without doing
anything good problem comes from network
signal strength you're not in a good
signal strength area and the recent
numbers that we have is if you move to a
bad signal interior the energy consumed
to do a certain book can increase by ten
times or it could come from virus
handovers you're moving on a road you're
shuffling between 3g to 2g or age and
for your phone is in a pocket nothing is
going on and now it just battery's gone
completely yeah calling signals
it follows the symptoms anything that
Paul is the symptoms that there is an
unexpected energy drink we term it as an
energy back you can call it an
optimization problem or you can sorry
using that one is a bug unexpected again
it is you use the phone it is still
slightly expected that the energy will
go down so everything is about that you
get most of the problems are let's say
optimization problem they're trying to
optimize energy but some of the cases we
are saying you're not even using your
phone it's been a pocket
application is one of the main source of
energy bugs and we found that there are
three kinds of butts coming out from
application which we call no sleep ugh
I'll deal with this in detail in this
talk of energy loopers something bad
happens and now your phone is looping in
a loop for no good reason training a lot
of battery or energy immortals that is
something bad happened in your
application it reached a state where it
is draining a huge amount of energy
irrespective whether you kill it and
restart it it will still spawn from the
same buggy still even if you reboot the
phone and restart the application will
spawn from the same buggy state so
basically meaning if the app enters into
that state you cannot use it ever again
just a read/write issue and have you
validate this on windows phone or iPhone
so again the study comes from which the
post let's say and which phones are
popular do you expect more posts in that
side of things here we are looking
morally at Android iPhone a little bit
of MIMO side of things but then things
are pretty common it's a across a
different possible even for the iphone
yeah
mostly bugs are classified further into
three categories and I'll talk about it
in detail in this talk this talk is
focusing on application energy bucks so
that's it you have an application it's
very popular a lot of people are using
it but certainly now people are started
complaining that your app has a huge
amount of battery drain and it's really
hurting your business you want to debug
this problem that was the first question
you want to ask when you want to start
debugging this energy problem the first
question is where is energy center spend
inside my application only if I have
this information I can maybe start
looking and how do I fix it and when we
started this research in 2009-2010 we
found out that there's hardly any tool
available which answers this kind of
question and this thesis bills a prof
are an energy profiler which answers
this question where is energy spend
inside your application which process
which thread which routine in your
application is taking how much energy
why is it taking that much an amount of
energy what can you do to fix it up and
things like that this is built on a
fine-grained power model which is
capable of predicting energy consumption
on the phone at a very very very very
accurately however this is still
semi-automatic approaches to debug
energies you have a profiler you need a
developer run it get the data fix the
bugs again and again to it in the loop
we can still build things in an
automated manner targeting each one of
these application energy box in
isolation for example we have bugs in
mostly bugs different categories energy
lupus energy immortals we can get a lot
of ideas from different areas of
computer science and will show one in
this talk one particular example where
you use a compilers approach to solve no
sleep box one of the most notorious
energy bugs an application automatically
without the use of a developer so let's
see on the first part where is energy
spend inside my application and I want
to answer this question it's very simple
I need to do three things first thing is
I need to track power activities on the
phone second thing I need to track
application activities on the form and
third thing is I need to match these two
things which application is taking how
much energy sounds pretty simple let's
see how do i track power activities on
the phone simple lame answer solution
use apartment monitor my a pretty
expensive instrument perform some
surgery on the phone and now this
equipment can get you very accurate
energy readings of the phone but the
problem is this equipment only gives the
entire phone energy consumption it
doesn't give you which application which
thread in your application which routine
in a thread and so on this kinds of
information the second thing is we need
to use a parmod a builder software power
model and when we started looking back
in 2009-2010 about what are the power
models available in servers desktops pcs
laptops mobile phones at that time we
found a lot of power models they use
something called they are something
called a utilization base model they say
we have two phases one training phase
one prediction phase in training fish
phase will actually measure the power
consumption will measure the triggers
around which we want to build the model
will do some mathematics we'll get a
model out and in the prediction face
will use those triggers again we'll use
the model and we generate the output of
a power consumption all the research and
servers laptop species like on
smartphones most of them fill into a
category of what we call is utilization
based models and they say your hardware
is using energy only when you are
actively utilizing it they come up with
a very very simple equation model energy
is equal to in last once again how much
packets I have sent over network how
much packets I have received over
network x it's some constant in last one
second how much CPU I have utilized
multiplied by some constant similarly
for disk similarly for every other
component write a simple linear
regression equation and you get the
power when we pick this model of and we
applied it to smartphones we found that
these models feel terribly why does this
model fail the first yet very very
intuitive assumption that
these model mix is only active
utilization employees energy consumption
is not true and forms your phone can be
draining energy a hardware component of
the phone can be draining energy even
though nobody is actively using that
particular hardware I'll show examples
of this the second assumption here mate
is an implicit assumption than energy
consumption is linear to the amount of
work and that is why you can multiply
how much utilization of network into
some constant basically they're saying
if I send 10 packets I can zoom X amount
of energy sending 20 packets employees
to X amount of energy that's not true as
well sending 20 packets can consume 3 X
5 X or no Connor case Ephixa more energy
have a question our radios please
proceed oh hello listening power that's
an hour receive power right though it's
a much it's really now this model bit if
you're not translating you're using it
so we observe that a few people have
started at that time looking at
individual hardware component in the
same you know power model is very very
complicated here the simple things this
like things don't work for example in
network especially 3g people started
seeing this kind of results and they're
saying we need tail we need this and
things like that I'll cover in the next
slide but we observe that this is true
not only for radio not only for make for
most of the components and smartphones I
will come to the examples here Stefan
one of the important property of a power
model that we started from is we need to
get the palm oil to sell which process
which trade which function is consuming
how much energy but it's very hard to
obtain these counters that goes into
this particular equation at these levels
so it's very hard to get predict energy
at these low levels
linear combination of its components
it's coming that or not hold it all
mm-hmm it seems that you're not going
right that's that's true as well I'm
skipping up from this light but that is
true that you can't add energy
individually some components interact in
terms of energy consumption and skipping
from this talk but we can talk about it
first example only active utilisation
implies power consumption is drunk we
took a HTC touch phone running windows
mobile 6.5 we run a simple benchmark we
connected to power monitor x-axis plots
the timeline in seconds y axis plus the
current consumed by the entire phone in
milliamps which is the same as power x
three point seven times the voltage of
the battery nothing else is running on
the phone we run a simple benchmark
which opens a file reads from the file
opens the file sleep for some time read
from the file what we observe the first
thing is the moment you do a file open
there is a power state transfer a
trigger file open takes a few
milliseconds to get completed but then
it consumes a huge amount of power when
you do the file read again you see the
same things one thing is in the
traditional power models file open is
not considered an activity lies ation of
hardware it's only read and write calls
but we observed that calls like file
open file remove file close file create
all of them are capable of doing a power
state change second example took a HTC
Titan to phone windows mobile 6.5 cents
in packets over the network even after
you're done sending this is on Wi-Fi you
see a tale or two seconds no packets are
being transferred in that particular
time still the hardware is considering
some power there
especially the first one that's fixed in
a diversion thanks for five minutes so
it comes in the tribal you don't know if
it is a bug or it's a feature and right
it's part of the device sure as we can
see and device drivers try to manipulate
the power power of the hardware
component and that's where we will try
to kiss later on in some cases it is
needed in network case for example it is
needed because we are expecting more
communication and that is why you were
staying in a high power state but
irrespective of that fact your
utilization based models cannot capture
these kinds of things and tail phenomena
is very common in 3g we have observed it
in 3g in SD card in Wi-Fi in gps extra
smart phone hardware across multiple
voices this phenomena is fairly common
second energy scales linearly with the
amount of work one simple experiment
took HTC Titan two phones windows mobile
6.5 send packets at the rate of less
than 50 packets per second second
experiment send packets in the rate of
more than 50 packets per second this is
how the power profile looks like x axis
is time line y axis is current when
you're sending packets at a rate less
than 50 packets per second you see 100
200 five milliamps power spike increase
the rate the power consumed is triple if
you actually go ahead and consume the
energy in the graph the area under the
graph their energy is not a linear right
there
what do you learn so far so far we have
learned that there is a notion of power
states you do something something
triggers and you go to a high power you
do something it comes back to the low
power what we assume is device shriver's
is doing these kinds of low-level power
manipulation behavior stepping so the
more like you you somehow changed you
said if I sent were clean when you talk
about a slide originally City bison I
can see is like watching place that we
packets I could stop Valerie here what
you do you double the rate in the
patties I didn't double the rate you
choose 49 packets per second and 51
package per second irrespective you're
sending them your rate the rate of
packets sent ya so there is something an
intuition that there is a workload based
characterization here power
characterization and that's what we see
here and the device shy with a huge
amount of experience but we'll try to
capture this in the car horn the thing
is device drivers are doing something
intelligent down there and the idea here
is we want to reverse engineer what is
the device drivers doing there what
other device I was doing there the
problem is device drivers a source close
they don't leave companies like HTC
Samsung Apple and you need to do
basically a black box reverse
engineering of the power state power
states in the inside the device drivers
ok state of art models don't work so we
went back back to the Stratford we said
ok who consumes power in smartphone very
simple hardware consumes the power
there's nobody else whose credit
training battery in the smartphone who
drives the hardware applications drives
the hardware how does application ride
the hardware there's a very very nice
interface called system calls through
which most of the applications are able
to access hardware and the idea is if we
can capture the system calls effectively
and we try to build a power model around
system calls maybe we can do a better
job in terms of accuracy and the
advantages are very simple
we captured everything that utilization
based model see just look at the
parameters of the system call we capture
power behavior of those system calls
which need not employ activity' lies
ation like file open file create file
delete file close and the most beautiful
part of this this this approach is
system calls here is a very very nice
property they can be traced back to
where they are coming from which process
which thread which routine is doing the
system call so let's see the challenge
here is we are trying to learn the
device driver the power model manner
power manipulation and we are looking at
only two things the timeout and workload
based so how do we reverse engineer this
first thing is we use a finite state
machine representation we move away from
linear regression equations there are
nodes in the in the power model the
North could be a bay state where nothing
is happening in the device a productive
state where device is actually doing
some work and a tail state where it's
waiting maybe for further communication
or waiting for further activity the
edges from one notes to other nodes are
basically transition rules they could be
system called driven start of a system
calls stop of a system call or they
could be device driver intelligence and
we are looking at two of them timeout
and workload based like 50 packets per
second feel different power levels I
think of dvfs for CP so is that itself
different states and all these
transitions are so be state for cpu
would be nothing is going on but so the
production state would would be dif it
could be multiple production states they
could be multiple tail states or a
harder but cpu we are handling it
slightly differently we are noting down
the frequency we're changing the value
of the props for everything ready for
the late
based on transient or control you will
have different notes right frightful
that is there in the model based on
signal strength based on but based on
the radius ending you need to go to a
different power statement I'll show that
insulin
the approach is pretty simple it's a
black box reverse engineering we don't
know what is the divisor I we're doing
we don't have the source code we call it
a systematic brute-force approach we are
going to try it everything possible what
we'll do all the system calls that are
going to a particular hardware will try
to build a finite state machine for each
of these system calls it and once we
have the financial machines for all the
system calls to a hardware will try to
merge the financial aid machines of
differentiation calls going to the same
hardware this requires domain knowledge
you need to know how SD card works you
need to know how GPS works what are the
calls affecting it and so on ginger is
one that you need here is a system curve
here we made a grant of was preceded it
is paid rent friend otherwise you've got
models in the system power
not really we'll try to combine things
as well the behavior founded previously
because from every state will try to do
we will try to Jarden a difference again
bluto's approach trying everything
possible I come to that in a slight
notify all permutations
so let's see how do we deal with first
single session call we have read system
call let's say which has a file
descriptor a buffer and a size we run
this particular simple application which
reads something from the disk and we get
this kind of powerful file file read
call starts by Luke Collins first step
we do is we digitize it we say you are
in Bay State when nothing is happening
on the SD card you did something you go
to a high power state called d1 you stay
there for as long as you are doing the
work which is described by the parameter
of the session go you come back to addy
to state a tail state and then you go
back to bay state and basically just
convert this into a finite state machine
representation which is seeing exactly
the same thing you are in Bay State be
filed it triggers you there you stay as
long as you are doing the work you come
back to disk tail you stay there for a
certain time out and you go to Baystate
to answer your question g2 now here will
try to do read calls from different
states just the read call will try to do
what happens if you do another you call
when you are in high-risk state what
happens when you do another recall when
you are in tail state so you're getting
one finite state machine for one system
called completely
yeah it seems like there's still
dependencies Oh miss wondering how how
complete is a subversion practice so
when we were doing this experiment
nothing else we make sure minimal things
are running so that the palm OS is
working let's say I know what only app
is running and but there could be
interferences here for example you see
some things going on on top here we are
entirely so it's harder you have right
so we assume the firmware of the device
drivers do two things they manage power
based on time out with a managed power
based on workload these are the two
things where power state change they
demand a play however a firmware could
be doing something like if it is raining
outside LG in the power I'm not looking
for it it's a black box reverse
engineering so I won't capture that or a
complicated part management I'm not
looking for that I won't capture it it's
a black box it was engineering yes
so suppose you had a i can imagine a
file system driver that would feel
something like look at it wasn't
fraction of reads and writes in some
possibility of time and cash management
that powers it took so that's what i was
asking is your system cause i just focus
on what people means in the sequence or
have you looked at all possible
obviously not using different reason
right okay so one thing you're alluding
to is what happens when caching is doing
things like that okay we'll handle that
separately but low-level things like a
device driver could do hold of the read
do it later or do some other things no
we are not getting any information out
of it we are not capturing it we do not
absorb it in phones if we observe and
influence this won't work you seem to me
to ignores a power drove by the phone
saying I am Here I am Here I hear it
dumb phones also do it just is a small
enough to be negligible I don't
understand what do you mean by I'm here
as a cell phone keeps telling the tower
where it is right right also eats power
right so that goes into 3g energy
consumption what the 3g energy conductor
a radio in a conduction so if you're
modeling for radio you need to capture
that if you're modeling for screen you
need to capture what is going on to the
screen if you're modeling for Wi-Fi or
it is capture what is going on in the
Wi-Fi
first of all quite hear when there are
workload based changes like 50 package
per second and so on what we do is
basically we change the size of the
system called exponentially to see if we
are observing any different power
characteristics then this simple model
and we build the bar model accordingly
yeah so the confusion how you capture
half minutes because we need a different
Markov model if your experiment use
let's say two consecutive reads let's
say space 52 no sex or something like
that okay so the thing is are the reefs
interfering or other reefs not
interfering let's say they're not
interfering so basically what you saying
when you're in high this trade or when
you're in this cave what happens when I
read concept well you just you model it
you take the phone in that state you do
what you'd call and then you model with
it it's pretty simple it goes to a high
density and stay safe what happens when
there are multiple system calls which
are overlap going to the same hardware
then you need to see in which order they
have started in which order they have
ended we don't have that information
Trey vegetable don't get it out what we
simply do is we combine the workload of
those to read calls at the time when
they are executing and we just stay in a
high positive for that long
second sip modeling multiple system
calls going to the same component
observation here is these kind of power
management works at a very very low
level in device drivers we don't expect
there to be a huge number of thousands
or something like States there because
programming at that low level is very
hard what we have seen in most of the
devices there are very very few states
three four five and the idea is if there
are very few states you will see these
states being repeated across system
calls the finite state machines of
different system calls and the idea is
sit down you need a human and identify
which are the common power states how do
we do it Wi-Fi Nick on HTC touch phone
since system called finest machine
looks like that you're in Bay State
Usain at the rate of less than 30
packets per second you go to loo network
state cross that I surely go to high
network state come to network to you a
time out of 12 seconds you go back to
baste it socket closed call on the same
phone will take you from tail state to
Baystate you need a human to sit down
there and identify that this one 10
milli amperes in network tail and socket
close call is same as 1 10 milli amperes
in your same system call basically and
then sit down and combined it if you're
in it work tail state either you have a
socket closed or a timeout whichever
happens first you go back to base tape
and you try combining different states
for different system calls going back to
the same component figure about the car
because when you're running an actual
system it may happen your sin call sends
you into one state and now there is
another system call now that system
called won't start from the Bay State
because your component is in a different
power state right now and you need to
know what happens if that call comes in
that power state so why don't you just
simply combine all staged at the same
power you're doing so good giving sundry
things so why draw on the human here
sorry what why do you think you need to
know which power states are same
actually and she just do that based on
the current drawn and all the
experiments we did yes but it can happen
the to pass rates are the same value so
you need to start sitting there and
seeing what are the transitions that are
coming into the state what are the
transitions that are going out of this
state using that information you realize
whether they are the same power states
or not but yes using everything that we
have seen a power value can can we can
decide this on that
big machine all a combination of all
states all power cords great so and most
of the hardware and Android let's say
different components don't interact in
terms of power so you build one finite
state machine for every hardware for
example this financial aid machine is 4
y finding in Windows Mobile yes you do
because things start interacting and no
now you don't you can't just work with a
single finite state machine of 15 way
I'm skipping that from the doc here
there
right so I'm wondering are you manually
mapping each way actually observe that
exists empower yourself there is extra
variable which this case you're seeing
is different right in the case of the
file system call they've been putting
two black brick so for every hardware
you get what in the system calls that
which is in front for example I'll Perez
Ricard it was I look when i create files
c5 raid and so on you build a finite
state machine for every system for most
of these issues also do not call it a
powerslam file seek it does not matter
in power state of a sneak up so first
date is you filtered all the system
calls manipulate that are capable of
manipulating the power state hmm yeah
it's man it's not okay it's not a unit
and then you combine start combining
things we didn't observe this but if
hardware are interacting in terms of
power then implicitly yes but the
question is how many system calls impact
hardware in our experience not more than
five six depending on what hardware you
using so it's still a small space you
can do things manually and moreover
power modeling is the one time of it
what's all right I spend some time once
I have the model I can distribute it to
everybody I don't need to do redo it
again until the hardware changes or the
device driver changes the firmware
controls value for the SD card correctly
so or for any flash based system
st when are the races have it is and
consumes much more power than just a
right all right right so that kind of
something if the firmware changes you
need to redo the model right so if the
device driver changes it is possibly it
is possible it is possible that power
model changes because you can go ahead
and fix it and there's no way around it
right now you have to actually go ahead
and do this thing we think this as you
are driving a device driver for every
you is you need to read a device driver
and then you need to build up our model
yep can you handle things that don't you
bail system function because our like a
range remembering that I think again I
said yeah most of the applications use
system goes to the primary interface to
access always but there are ways around
it you can do I uploads you can do em
map you can do things like that right
now we don't go with it but we can
extend it properly well it's just
because of the layer of fact you write
something you do right but eventually a
worker thread decides to back top 30
seconds
cashing any cash later there are civil
Kashmir's their slack cashing at GPS
they're cashing it s tika they're
cashing it in to work in things like
that the general idea is you need to log
everything above the cash and everything
below the cash so that you and you know
when is the hardware getting triggered
when is the requests coming in we did it
for gps in android because it's easy to
go with the framework level and do this
kind of stuff low level is the device i
was doing no right now it's out of hands
because we don't have this information
but the framework remains the same the
theoretical assumptions like you need to
a log above you need to log below we
limited this into oasis windows mobile
6.5 using C log and Android using a
system tap we locked Colonel events I'm
not going into details of this is a huge
amount of engineering involved here to
make sure the overhead is very less when
the applications are running so that
they don't reduce a lot of energy drain
because of login framework the results
how do they look like we run a different
application on android windows mobile 6
youtube facebook maps chase virus scan
document converter different things and
we use the finite state machine a
machine mod the arse one and the linear
regression base model the state-of-art
we plot the y axis as the error
percentage we run the application for 10
15 20 seconds we see how much energy is
being predicted consumed by our model
how much energy is actually drained by
the power using a power meter and we
plot the error bars you see financial
machine model is under four percent of
failure and linear regression models are
one to twenty percent favor but not is
that when we see what happens at
fine-grained intervals instead of
measuring energy for like 20 seconds
look at every once again how is the
prediction we found that even that is
really good at 50 milliseconds been
eighty percent of the 50 millisecond
bend has less than ten percent errors in
our model
the impact of the screen is going to
diminish your error percentage because
it's such a large and constant bag
possibly what happens when you look at
these numbers taking out the screen
content of course daily increase first
thing so in this kind of graph we have
taken the screen value to be absolutely
lowest brightness but the problem with
the doing that is when you remove the
screen off and at some point you're
predicting some energy consumption when
the phone is not actually consumed
consuming energy you're getting infinity
basically so there are periods where the
model very fine grained period let's say
50 milliseconds if you are looking at
that time interval there are periods
where a model returns one hundred
percent error sometimes that is true but
overall we are pretty good most of the
50 millisecond bins fear very low later
Seto isn't the fight night yeah what
price of power in
it depends on what pregnancy have said
what hardware yeah you said right it
ranges from 25 percent 275 person is 25
to 75 percent yeah and if our box our
phones it's thirty-five percent the
screen the brightness value which is
safe again it depends on hardware
whether the screen is only or whether
the screen is LCD LCD screens is what i
am quoting OLED screens are even less
because it depends on what color the pic
Celsius and things like that so that
water so one quick one up is the set of
system in use insect is your model for
example always over breaking
no it's all of this paper it's all over
the face sometimes we are overacting
linear regression you're under
predicting and things like that so so so
you describe this system with finite
state machines that you spent a lot of
time optimizing and getting right you
describe the problem with linear
regression you describe 24 of them any
of which one might correct for example
one might try nonlinear nominee or
parameters is how do I know that you
would if you had spent the same amount
of time trying to get a regression model
right that you would do better than you
did here given the notion of things that
our researcher who was interested in
seeing the regression model succeed
might have done to better optimize for
aggression right so there may be ways
you can optimize regression models you
can build a different models in finite
state machine and so on and what we see
once we build this model we observe that
the most important property of our model
is not the accuracy is something else
I'll go to the next flight it is you're
tracking it back to the application and
now you can do energy accounting but yes
you can increase you can make linear
regression better that's of course
that's may be possible we have not done
that but if you're working on
performance counters it's very hard to
answer the question which thread which
routine is consuming how much energy you
need
that for application usage of resources
and you can easily
if you get yeah if you get those kind of
numbers that's good which routine is
consuming how much CPU which shooting is
consuming how much disk how much a
network if you get that kind of an
application-layer you get those numbers
but we started from the fact that which
routine which thread we want that kind
of information as a scientist I'm still
really bothered here because we've got
you're doing a test is combining that
it's comparing two things but one of the
things that's different about these two
models is that weird ones finite state
based ones ones regression model another
thing that's different is you're using
different independent variables in one
you're using performance counters as you
said and did one you're using syscalls
Frank and you could have built the
finite state machine are secure you
could have built the linear regression
based on where every every one of the
independent variables in your learning
plan your regression is the number of
times the system call is called ha no
you're not shouting that that couldn't
cannot be done that can be done first
thing you can extend lean irrigation
base models you can make them more
accurate but the problem is until and
unless you don't remove those
assumptions from those model you cannot
get them right the assumption is only
active it'll ization we are targeting
that energy scales linearly if you
remove those assumptions then probably
you can do better job irrespective what
what mathematical model use it is a
linear regression better of it finally
pushing and so on
yes sorry state design just question
there are two things you change what is
you went from
all straight linear regression model
version is a bottle your intuition which
is the real key inside one of them in
return so there are two things one is
accuracy how good you are in terms of
prediction and what we know from the
power behavior that that is there is
actually financial aid based machine
power model and device drivers something
happens you change the power something
happens you bring that back the power so
we are good at capturing that the second
important thing is next slide a couple
of slides how do we track it back
application
spanish state machine is the important
part but equally important is the second
half it's based on system calls we
observed four or five states in most of
the hardware a few transitions that's
the size for each of the much of the
hardware components yeah
you know why nene regression is doing
better
I game is mostly cpu CPU consumes nearly
linear energy if you are running at a
highest frequency that is why it's
performing roughly better when you're
looking into energy consumption I've
removed a graph where it says what
happens in individual prediction there
in some places it is overestimating in
some places it is under estimating so
when you are looking into n you're
getting really good result they're
cancelling each other out
so we started with this question where
is energy spin inside my application we
did the power model second thing is we
need to track application activity and
the granularity of tracking depends on
what is your requirement do you want /
routine portrayed maybe a combination
routine and snow and we say let's try to
do / looking because that's the modular
programming language we use g prof like
mechanisms to predict how much CPU
energy is being spent in different
routines when they are running on cpu
because it's very hard to profile it's
very high overhead to profile when the
routine starts when a routine needs he
was sampling pldi 82 paper straight out
of it the third thing is you need to map
power activity to app activity and we
use the most important part of this
financial aid based machine model that
is it's based on system call and now you
can track system call all the way to
where they're coming from get PID which
process is doing it get PID which trade
is doing it back trace which stack of
routine is doing it and now you can do
energy accounting but then there is one
problem of lingering energy consumption
and we need an accounting policy for
this so what is lingering energy
consumption the first case is very
simple the tail energies let's say a
routine foo since 10 kilobytes of data
the send is done but then even then 3t
consumes a high tail energy for up to
seven seconds this food is the cause of
the stale energy but even after foo is
completed the thread is completed the
process is completed the hardware
lingers on and consumes more energy you
need to take care when your accounting
the energy back to different entities
the second case of lingering energy
consumption comes from something called
position she'd wake lots and now we are
trusted when we are going to the next
half of the talk what is this week logs
smartphones have a very very aggressive
sleeping policies the moment you start
interact that you stop interacting with
the phone within few seconds the screen
shuts down the CPU shuts down the system
is frozen and that is why your phone
last a day in your pocket this has a lot
of problem but programmers because your
program may be in middle of doing
something very important like is truck
to the server and the CPU sleeps now the
services where is the porn gone so the
pro smartphone Oasis give developers
some api's using which they can keep
components on explicitly given the user
is not interacting for example you are
talking on skype you need to the screen
to be on you don't want to touch your
phone every five seconds the screen
needs to be on till from the call
started and screen needs to go off when
the call is ended the thing is let's say
a foo routine says keep the screen on it
acquires a wakelock for the screen and
the foo is over but the screen continues
to consume energy even though who is
over it's continuing consuming energy p
on behalf of and this is another example
of lingering energy consumption so let's
say how do we deal with lingering energy
consumption this is a counting question
I do a same same takes 10 10 kilobytes
there is a tail we split the energy into
utilization based energy and tail based
energy and the first thing we say is
these two energies are different UNT
let's represent energy as a couple
rather than you plus T and in this
particular simple example is very very
easy to observe that u comma key topple
should be assigned or accounted
completely to this same system call and
whoever is calling the same system call
nobody else is responsible for it what
happens when there are multiple system
calls I do a sin one I come into tail
but before the tale is over a sin to
comes in or receive comes in there is a
utilization energy there is a tail
energy there is a utilization energy and
tail energy first thing the first tail
t1 belongs to send one because send one
started at tail now the question is how
do you split t2 among these two system
calls there are several policy there is
nothing right and wrong here let's
explore the policy space first is the
average policy split tail energy t2 in
some weighted ratio among sane one in
st. too but the problem with this is
it's not always easy to define waits for
example instead of saying one let's say
it's a file open system call and send to
it's a file read system call how do you
define wait for file open it could be a
Kinect system call it
ESN system call and the problem is the
policy gets complicated if there are
huge amount of system calls and you need
to wait until all of them are over and
then you start dividing them we take a
very simple approach we call it as a
last triggered policy we say forget
about everything else we are
representing energy differently allocate
t2 completely to the last guy who called
it sent to and go on you don't need to
define weights we don't need to the
policy is not complicated yeah punish
the guy the guy who goes first is
responsible for is responsible for
taking you to a state where you're going
to have the phone on for a while the guy
who's second if he times it right he's
just being opportunistic right so the
only the only additional cost really
incurred if if is an application decide
hate someone else's has activated the
phone I should take advantage of this is
the difference in time between when my
call ends and when the previous guy ends
mm-hmm because that's the additional
time that has to wait because I so if
you take a last trick or policy then you
aren't giving any reward to applications
that time their events opportunistically
to minimize power they're always
actually being punished they're there
they're incentivized to actually waste
power in the last trigger policy this is
an accounting policy what's typical
there's nothing right nothing wrong it
is which gives more information to
developer to debug that application
energy consumptions well that stewart
island is right mm-hmm yes it's a policy
words somali obviously their incentives
right policies are incentives you can
this is again not a runtime system
you're doing at the end of it you are
collecting the trace you're predicting
energy what we realize this is at the
end of the day whichever policy you use
you come up with a flat energy
representation how much routine X
consumers energy how much routine y
consumes energy and this is very limited
in terms of information irrespective of
what policy you choose when you go on
debug the application we come up with a
new way of representation which we call
bundles which actually take this
question completely off the table we are
not accounting tail energy at all but we
are representing the energy consumption
to the developer in such a way that it
can quickly understands what is wrong in
the application what is doing wrong and
you can optimize that because that's
hardly go so I think that's an important
feature you can add to a system is to
say i want to just if someone else is
sending i want to send then right I
don't think currently in the operating
system as far as I know you can't do
that if you could that might be a
problem but right now nobody can really
get that a peon so the incentive is to
add that a job right so once you have
such kind of API you can do much much
more things then you get the incentive
and then you can notify application what
is the opportune moment of doing things
but that is a completely then you could
actually have a system where every job
salary absolute your if you just want to
be an opportunistic app then you could
be get a lot of it and to help bring it
up at the end of the talk excellent
yeah there isn't so yeah you've been
interests right honor we can't do it yet
so we implemented the sea / of the
implementation look serve it simply
simple you do Concord instrumentation
log you run the Ithaca you have the
application um bid energy API is into it
to start they're tracing stop the
tracing install it on a mobile OS where
you have system called tracing enabled
you run the application gather it raised
run it on a server to get in-depth
energy profile give the data
presentation the bundle presentation
that i am talking about it's not in the
slides but we can talk about it the
runtime overhead of this system was to
to fifteen percent and the run energy
overhead of the system was 12 13 percent
additional energy incurred by tracing we
use this on several popular applications
like Angry Birds browser Facebook New
York Times and we had several insights
of where energy is being spain and the
first way is free absolutely in a lot of
energy doing everything you don't need
i'll come back to it in next slide a
major finding is io consumes a lot of
energy on phone cpu is not the
bottleneck in terms of energy see if you
consume place ten percent fifteen
percent of energy and what we will show
here is a prof helps detecting something
called mostly bucks first sample case
study Angry Birds one simple game 35 30
30 35 seconds shoot three buck shoot
three bugs birds we found that the user
tracking tracking where you are
uploading this information consume forty
five percent of energy fetching
advertisement consumed another twenty
eight percent of energy the core
gameplay the physics engine the
rendering engine consumed only twenty
percent of energy it is clear GPU
GP is not there on android yet before I
Ice Cream Sandwich scream is allocated
the accounting is done based on
wakelocks it is accounted to who is
holding screen wakelock which is
basically the android framework process
so Android Angry Birds doesn't get any
share of energy but somehow if we have
supposed to put that energy down into
here these numbers go down instead of 75
percent of energy going into
advertisement it goes like forty percent
energy or forty five percent energy goes
into advertisements now this was picked
up by popular press very recently and
they there's a nice story around it how
press gets very aggressive the first
said user to people tasted angry birds
and they found a lot of energy is going
75 percent energy is going in free
applications next round of press
releases all three applications drain
75% of energy in advertisements next
round of antibiotics is you should buy
paid applications we never tasted paid
application next round this study is
from Microsoft they are trying to show
Android is back you have a question
right right right we have an in-depth a
huge profile for this thousands of
routines and then we this is basically
clustering base on which traits there's
a flurry thread that comes with Android
with this do that does all this tracking
getting advertisements so we are we
evacuated I aggregated those numbers
second example we found something called
a wakelock bug in facebook application I
run the facebook application and I
observe something called a Facebook
service is consuming a five percent of
energy what is this facebook service the
facebook service basically pulls the
background to see notifications somebody
sent to your friend requests somebody
wrote on your wall and this was
surprising twenty five percent of energy
because during the time when nobody
wrote on my wall nobody added me as a
friend request I'm not that popular
anyway what we found out of the spin if
I person roughly twenty percent was
going into something called an acquire
week block routine in a position close
what it was basically doing it was
telling the CPU
keep the CPU up I am doing something
very important and it never ever told
the CPU or the SVR the CPU is free to
sleep and all the energy of the CPU low
idle state is accounted to the sky this
is an energy bar very popular in
facebook application we switch gears now
we built an energy profiler which is a
semi-automatic approach we go to an
automated approach of finding mostly
bugs but on the most notorious kinds of
energy bugs you show a compiler based
approach what is mostly bugs why are
they coming what is this new problem
here there is a philosophical shift in
power management when you move from
desktops to mobile everybody here has
written programs in Java and C C++ some
language how often in your application
source code you need it to take care
that the CPU is on how often you needed
to take care CP screen is on i meani
component is on never but when you move
this is because this the default power
management philosophy did before
thinking is everything is on it's
already there for you you move the
smartphones there's a different power
philosophy everything is off by default
and if you want something to be on you
need to explicitly asked for it
smartphone Oasis aggressively turn
things off but they provide a lot of AP
is what are these api's how do we look
like let's say I'm doing some Network
trying to sync my emails over network it
is this may take a minute or so over 3g
maybe let's say if in middle cpu sleeps
i'll have a problem because now there
are several things where is the mobile
god what is the developer do it acquires
something called a wakelock says to the
OS please keep the CP 1 i'm doing
something very important i'm done doing
important i will release the wake lock
and now you're free to sleep as per
whatever you want example from skype you
need to keep the screen on these are two
example a PS from android there seven
eight of them for different components
but what this leads to a new phenomena
which we call as power encumbered
programming
you are pushing all this management of
sleep and wake cycle all the way up to
developers and some of these develops
developers could be high school kids
trying to earn a quick buck or even the
most developed even the most
professional programmers do a huge
number of mistakes when they're using
these VP ice this results in something
called a no sleep bug which is basically
an application telling a component
please stay on I am doing something very
important and it doesn't tell the comp
power though is that I've done doing
important you can shut it up if that
component is CPU fifty to sixty percent
of patchy goes into L ours without you
using the pool if it is screen hundred
percent goes in four to six hours if it
is GPS one hundred percent goes in three
to five hours we have example so for all
these category including popular
application like Google Maps SMS
application facebook was CPU category
and so on support so we started looking
at this no sleep bucks and we say why do
these fight by programmers are making
this kind of errors what is the problem
they are facing and we categorized no
sleep bugs into four categories one is
no sleep code paths mostly fridge
conditions dilations sleep conflict i'll
go through three of them here in the
store no sleep code path the programmer
actually said in his application keep
the cpu up and somewhere he said the cpu
is free to sleep but the code took a
different path then what the programmer
anticipated i'll give you an example
let's go back to our do network example
you're trying to sync / network you
acquire and release the wake law but let
me throw some java into it your sink /
network throws exception something bad
happened in the program you try to open
a file it's not open you / 0 and things
like that and the program it will just
did try and catch across this block when
there is an error exception you just
print the information what is the error
debug it later and go ahead what happens
you have introduced an auslly bug right
there you come here inside you tell the
CPU don't go to sleep you start thinking
over network you catch the error you
print the error you need to go on who
tells the CPU that there it is free to
sleep back again
for pups go away is a wakelock at a time
out in it that's a good question and
that's a one of the question we are
looking at wakelock some of it locks are
I'm up in them but this is the question
we're looking from how do you improve
the programming languages or API to
provide better solution but the problem
is let's say even though I have a
timeout i acquire a wakelock for 60
seconds let's say let's say and then at
the end of 60 seconds I still want it to
be on so i put this way clock require 60
seconds in the while loop and i make a
bug there the problem still remains but
yeah some of it can be taken off with a
better user programming construct or
better API is no object Oh district is
not always guaranteed to be cold we have
a very nice coats embed coming from
Android wear the developer is absolutely
confused what is going on he put it in
finalized and he wrote a come into
CrossFit saying I'm not sure if this
finalists will get call because Java
doesn't guarantee the construct of the
finalists to be called but it can happen
some code doesn't release the wakelock
and I don't know what path it is and let
me just try it but it's not guaranteed
again yeah but the problem is still
again most of the smartphone
applications they don't get killed they
stay in the background so if the
application is on the garbage collector
won't get kicked in well for I mean if
the wakelock is acquired see posting so
that's one of the ways are you can solve
this problem maybe we observe this bug
in several application Facebook Google
Calendar the dialer app which I started
with mostly priest conditions very
similar let's say a process have two
threats 31 32 the wiggly shows the
execution path and that timeline goes
down the red dot shows the trade one
acquires the way o'clock he tells a
component please stay up the green dot
shows three to see is that particular
comment here free to sleep and
everything goes right it's all good but
let's say the threads are organized
differently 32 comes up says component
is a you can sleep that's the new or
basically right now and third one comes
up and says please stay up and nobody
else after that comes up and says the
company is previously the default
android client has this bar still now
it's not fixed i'm going to sleep on
flix directly and this is very
interesting problem let's say i am doing
something on the phone and the power
profile looks like this the timeline and
the power consumed what i did was
basically a started wife i transfer my
wife i transfer is done Wi-Fi goes into
a network tail and at the end of two
seconds the device driver kicks in says
two seconds have gone nobody has done
any communication put the phone to sleep
I put a nick in a low-power state so far
so good what happens when sleep 1-click
strikes you everything's you start in a
new class area network transfer is done
but when you are in tail state let's say
the CPU sleeps aggressively the problem
is now the code piece that will run in
the on behalf of device I word that will
tail the Nick to go back to a low-power
state cannot run because CPU is sleeping
yo Nick keeps your phone warm in your
pocket we have a very nice video where
we show two lines of Android code can
use a sleep conflict and a vibrator we
ask the vibrator to run for 10 seconds
but it continues to run for 10 minutes
and this kind of bugs are present in gps
make different hardware components
tracking and debugging all these energy
bugs is a very big problem very hard
problem and it requires energy from
different parts of computer science like
architecture programming languages
verification so on
sure how we use compilers one of this
very simple technique from compile is to
solve no sleep good parts and no sleep
race conditions we use this solution
from compiler 101 book that comes right
of the grad course it's called reaching
definition delivah problem and the
problem statement is pretty simple at
every point in the program statically
tale what is the definitions of
different variables reachable here and
you can do a lot of things using this
information for example let's say at
this point if Y is greater than 5 you
know what are the values of Y reachable
here in this example is just Y is equal
to live in so you can remove the branch
completely you can remove the else part
you just put the if part because always
if will be true you can do a lot of
optimizations around this reaching
definition data flow well how do you do
it is I'm not going to detail of it you
build a control flow graph of the
application you compute some gents aid
skills edges compiler 101 very simple at
the end of it you get at every block
what are the definitions reachable for
example here we say d2 can reach the
exit block d3 can reach the exit law but
not d1 will use this straightforward we
will try to find out no flee bugs due to
code paths we have wakelock acquire we
have a clock releases what we do is we
build a control flow graph which looks
like this i acquire a wakelock if there
is an exception i go to catch otherwise
i release the wakelock i come to exit i
transform this simply saying whenever
you switch on a component I'll turn that
value to 1 whenever you switch off the
component I turn that Valley 20 and i
apply reaching definitions problem
straight away here I'll say at the exit
node I get two definitions reachable d0
and d1 d0 is good because the value of
zero way clock is coming in which says
that the component was shut down this is
a good value d 1 sorry d1 is good d0 is
a problematic because it's coming from
an exception part is saying the wakelock
value is 1 you are reaching the end of
the code path but still it is holding
two o'clock
as simple as it sounds it's a lot of
there's a lot of complication here
coming coming out of even based android
applications all the applications are
even based your applications no longer
have a simple main and the call graph is
very hard to build their we handle those
kinds of stuff we handle java runtime
issues of what happens when issues comes
runtime exceptions and things like that
we handle special code code paths this
is a static technique we are trying to
be conservative the moment you try to be
conservative a huge number of false
positives kicking we apply a lot of
cases to reduce the false positives we
implemented this in suit this is a java
pre compiler we tested on 500 market
applications random application before
in 48 applications which had bugs most
of the problem was incorrect even
handling the developers did not realize
they do not understand how Android event
based model works how call transfer from
one place to other the second category
was it fails or exceptions just like the
facebook bar in six places the whatever
forgot to release you just acquired it
and there's no release throughout the
code and there were a few miscellaneous
categories to conclude and this talk
have talked about EP off the first
energy profile for smartphones which
gives in-depth information of where
energy is going inside your application
which routine which straight which
process consuming how much energy it's
built on a power model which is a very
fine grained accurate power model this
is again a semi-automatic approach and
we can build automated approach to track
energy box we showed one example from
compilers future work you can use
different areas and solve more energy
bugs in an automated way you don't need
the developer here but just to put
things in the picture we are still
looking at a very very small slice of
the problem you need to track energy
bugs in framework in kernel in firmware
in hardware is part of network and
that's a future work that we propose
I'll have just a couple of slides to
talk about what is the other work have
done during my pc life one of the work
falls in the spam category
there was a point in life we were
tracking a multi million load botnet
spewing billions of spans every day and
we were able to characterize some of the
features of how the botnet works and so
on using the data we showed that the
state of art spam detection spam
campaign direction does not work it has
a huge number of false positive when it
comes to tracking botnet spam and we
build a first complete unsupervised spam
taking spam detection system which
removes completely human from the spam
detection loop the second case of the
second set of work is data center in
intended measurement we worked for some
time with Bing team to reduce latency
between data centers between data
centers and client and we were measuring
something in routing in Internet I'll be
happy to talk it talk about them in
one-on-one meetings and with this I
conclude my talk thank you earlier when
you were talking about accounting
policies you see it doesn't really
matter any you can imagine any
accounting policy sponsor this sounds
like an accounting policy is better than
another if it leaves developers to
better understand their but Frankie do
you find that when you try one of
accounting policy versus other hmm we
use developers and studies
would fail to find their bodies or get
misled okay so if you're looking for
energy bugs then you need to allocate
energy about who is responsible for this
kind of stuff but if you're looking for
optimization for example in Angry Bird
is consuming 75% of energy in
advertisement how do I cut it down if
you're trying to look for those kind of
information then yes policy is important
and we spend a lot of time around this
that what is the best policy at the end
of the day we realize irrespective of
what policy you use as long as you're
using a flat representation of energy
it's not that information that is right
just respected right and that is why we
moved away from flat representation of
energy to something called bundle
bundles of energy which is tackling
specifically why is IO training so much
energy I have not covered this in the
talk but I can talk about it
I suppose you had like hitting point
liver than licenses suppose suppose
you've toured the user for every app
with correct accounting knowledge and
he'd used what in fact you determine on
users and developers
so there are tools currently available
running on smartphone systems that tells
user how much energy is being consumed
and there are a lot of problems with
those tools as well but then the
immediate impact we see is now user have
something in their hand and they can
complaint about you see I used my
smartphone and this says Facebook is
consuming a lot of energy and now a lot
of pressure is there on Facebook well
developers might want to handle it
developers don't want to handle it but
then online there is a lot of pressure
on them but the set of tools that we are
developing they are mostly targeted
towards developers because they don't
have right now a tool that can help them
debugging you require tools at every
layer not only for users but for
developers for Colonel people framework
people and so on so forth because at
every level e require energy khatam
ok</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>