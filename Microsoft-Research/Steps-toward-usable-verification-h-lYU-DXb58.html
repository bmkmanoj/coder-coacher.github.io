<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Steps toward usable verification | Coder Coacher - Coaching Coders</title><meta content="Steps toward usable verification - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Steps toward usable verification</b></h2><h5 class="post__date">2016-06-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/h-lYU-DXb58" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
okay so it's my great pleasure to
introduce Francesca logo so he's the
king of our interpretation over in
redmond and I've been trying to get him
to come here for a couple of years now
and for some reason you wanted to visit
this week okay thank you so thank you
for hosting me that's very nice visit
and I'm going to come work at it with my
colleagues in Microsoft Research In
Redmon and my friend rich mike barnett
tomball and she went the library and one
right now moved to google and with some
intense and I think Rory you know
somewhat damaged it was not me who gave
called them interns today they also
define themselves mine 10 so it was kind
of their good intention so I reckoned
you so okay you know what I like what
I'm passionate about but actually there
is something I'm even more passionate
about it's incredible to say it's a
sorry yeah so it's it's usable
verification is to bring verification to
the working program and make
verification part of the everyday
activity of every programmer so my dream
is to have verification as easy to use
as today is easy to use a compiler or to
use unit testing now what we what we
need in order to accomplish this dream
well first we need a protocol
specification language and language
which a programmer can use without
having a PhD in computer science or math
or and logic and then we need tools we
need tools it really helps the
programmer not that are helped by the
programmer so the tools they really
should to provide any some feedback they
should be useful for for the program so
in these tools they should have a
minimal change to the building
environment because otherwise you know
they will not be adopted they should be
a sought ematic as possible you should
do as much influence as possible and
they should scale up because programs
out there are really let are very larger
10 for thousands of classes there are
hundreds of thousands if not millions of
lines of code and the contains under job
project so distinct really should go on
a limb us on the scale now what is the
first step
for a very fine well the first step for
my Fang it's having a specification it's
writing a specification something you
know I say what's your program does and
if this question is do programs
programmers write specification holidays
and the answer it CES at least for
dotnet words you know programmers I'm
interested in programmers in.net today
they the right parameter validation
which you can think as we are as
precondition there if they do WPF derita
data contracts and then they have all
the kind of attributes used by all kind
of vocal album tools out there so yes
the right specification what we want is
to have them to write more expressive
specification particulars contracts and
context well you know I just
precondition postcondition object
imbalance now how how do we do it the
usual user ways to say okay now change
the language provide the language which
has some support for contract so example
hyphal spec sharp or G ml now this is
very nice solution because you get nice
syntax and you get many other features
you know integrating the ID it it's very
nice nice but the problem is that what
does approach you see they require too
many changes too much changes that
programmers they are not ready to go 11
changes one main changes to change the
language so it's difficult to switch
them from C sharp to paper for instance
and the other one for instance is the
change your compiler they don't trust
the academic compiler stick trusted sage
or señor CSCO Dixie so how about
solution our pragmatic solutions say ok
if you want to extend the language let's
do how they usually do in managed world
you just provide a library which you
extend the language in particular use
code in order to specify code and for
those who don't know God contacts that's
what the code contact specification
looks like so probably you saw this
example yesterday another torque it's
the maximum example we want to specify
bunch of things about this routine
one-sided yeah it computes the maximum
on an array which we know it's not null
and yes at least one element so the way
in which we do is just we we have this
library which is part of a domain die
brain dotnet in a mask or lib
which each meter code is essentially
it's a place maker its mark in marker
for preconditions post condition and
then we have also some API for
specifying a for all and exist and we
have some special method in order to
talk about the result value because the
NC sharpening mainstream languages you
don't have any syntax now to talk about
the value returned by been emitted so
use this one as a as a marker so the
nice thing about doing it is that we
don't need to change anything in c-sharp
this is just a meter call compiler knows
how to produce a mythical and and we are
happy now you may ask okay so first why
you need contact at all we already have
the bug data set that one of the
classical questions well the prom with
the cells are dead those are not visible
to the color they don't really work well
with the object-oriented programming
because those cannot be inherited you
cannot put a certain interface mittens
you cannot put a certain visual method
and I think so web solution I sorry in
abstract meters we have solution for
that but I will not talk about it today
sorry then the next thing to say oh but
you can use the attributes you have
known all you can put on I'll attributes
and this kind of stuff the problem with
attribute they are not really expressive
you don't these little things you have
to express if you want to get something
you have to serialize as a string so it
became a kind of nightmare and not not
readable and some people in University
of Washington they came out with
attributes for a specified on our nests
in Java and they come out I think it 17
or 19 different attributes in order to
specify meaningful things in Java so you
see it's kind of a burden to a program
and the tilting is why you don't use
commenters recently to jml well they
probably will comments it those are
completely ignored by the compiler so
you have no type checking we have no
syntax highlighting you don't have any
code generation from the compiler so
that's why we went with this solution or
using a code contracts of using code in
order to specify God and the ting for
the solutions that is very very
pragmatic we don't need a new language
you need a new compiler we can leverage
how the type checking or the code
generation the compiler does we have all
the nice syntax highlighting and all
like this
so beautiful people have been
downloading it to 100,000 downloads so
far 70,000 testing one year enough so
people they wrote blogs and book
chapters about it and it's used inside
outside the company so oh this is
wonderful except that what we lost
beauty it's not so beauty I I'm the
first to admit that probably distinct
it's not really very very beautiful but
its pragmatic that's that you know
that's some trade off and one once you
have a way of writing contracts you want
to do something with it well you can't
write documentation we not talk about it
today or you can do runtime shaking and
static checking and I just tell her that
one time checking we do it by doing some
bunny rewriting and again I'm not
talking about it today because I talk
about what I'm really really passionate
which is static verification so we want
we want to prove to prove our
specification want to prove our
contracts you want to grow that our
program there's no depth buffer overrun
it does not have a null pointer checker
vision x 0 other things so I've been
developing with with manual this tool is
called the clues oh I guess it's a you
know why because of the famous inspector
clouseau orem or because it's based on
ABS interpretation so it's where it's
this game and how how it works this is a
high-level view / of the tool well it
does it's it takes this input and
assembly and construction a call
photograph and then you start twisting
call photograph bottom-up and for each
meter analyze so I construct the control
flow graph then it had contacts so it
goes and finds which are the contacts
this can be out of bed contracts and be
united contracts contracts in the code
and it inserts them he also in a in
orange you see the Sarah assert so for
instance exit to the meter we wanted to
assert the post condition and the green
one and before calling some meat or do
you want to assert this precondition
green ones are the assumes that the
things that you can rely on so when you
entry and the entry Demeter to you you
rely on the precondition of the metered
and after you call something you can
rely on on the post condition at the
meter once we built this country
augmented control flow graph we do
abstract reputation so we have a bunch
of the domain and theoretically what we
do is between further each program point
and invariant in this absurd domain try
to be as precise as possible that alter
this program point and then we collected
the all the orange dots we take our
embedded within the apparent implies the
sound resum implies just the absence you
know the correctness of the session if
this is not the case then we use another
object domain more refined and we
analyze again again until we run out of
abstract domains when we are done with
your way to report this report contains
the word think so so it's which a search
in our definitive force means that no
matter what you do if you reset program
point it falls with assertion they may
be false so which one from which we
unable to prove them which insertion
they are reached so we know there is no
execution reaching this point and then
we may say which one are proven but you
shall we avoid saying this thing also
and I talk later we try for the session
which we cannot we cannot prove it we
try to say how you have to change your
program in order to fix it so how you
can repair your problem and we perform
also contract difference because when we
need we need to do same friends we want
this thing to skate up we and we also we
don't want to repeat work already done
so we use also a caching mechanism and
our caching as the esky a semantic edge
which is computed up starting from this
guy to essentially computer next day the
semantic control flow graph it is
actually semantic sub only takes into
account the things that matter for the
analysis and then we write into the
database the report and we use a next
time in there sometime and is now the
question is why we are using absolute
reputation it's not just because it's
the most beautiful things in the world
even better than cycling so why why do
you think we are using it well in
general when you do this kind of this
kind of an icc what you do you use some
form of weakest preconditions so you get
some with a few conditions and you throw
to smt solver and then you pray
eh yeah we don't want we don't want to
have the prank stuff so we want to be
want to be first of all deterministic we
want to be automatic so for instance in
a very very simple example before so if
you want and try to verify this with the
within some you should approach with smt
service and so forth we need to provide
a loop invariant you see that even for
this very accurate trivial example
because it's just a for loop with 11 in
structure inside we have to provide a
big loop invariant and this is not going
to work no one is going to write this
reprieve and because they're going to
say oh this is pretty trivial because I
already told you the array is not null I
already told you that it is at least one
even does not get modified and yeah it's
clear that the is between zero and a dot
length why should I provide it you know
it's just a for loop and then the same
you know the pre and post these other
two guys that looks a lot is the
postcondition so why should i do it and
then what people they would say say okay
the tool is dumb forget about it i'm not
going to use it so this one is influence
over of looping variants and also this
deterministic aspect and effect that we
focus on property of interest we are not
saying we are going to verify everything
we're we don't aim to fully functional
corrected that's not even clear we just
know now is still a big problem can take
it offline but they are big code base is
still a problem with a null null null
and no type system we not to do the work
for other reason I can take off line if
you if you are interested so we need to
get more information okay so this one so
the other thing is also interested the
inference so if i take exactly the same
example before and I comment the
precondition and I run the tool you see
that the tool is also able to infer the
precondition so it's going to tell me
that where they should be not because
otherwise i get an error here so infer
the first precondition indoors in first
that i should have at least one event
because again i will get too narrow so
the two can infer the precondition for
us and the second one it's also nice
that you cannot infer the post condition
for us so you know the usual tricks that
people they do for inferring this
invariance which they take the post
condition they do some renaming and they
try to verify that actually it's a loop
invariant
would not work in this case because I I
commented the postcondition however the
tool that's a formal analysis and is
able to infer that the value that we
return is larger than all the others and
that it exists in element in the array
which is like that there is no magic
this just a paper which I will not talk
about today sorry it's this paper in
which you explain how to do it its
proper 11 paper so as a matter of fact
stands out a clue so it kind of complex
analyzer we have many many abstract
domains in it so we have some basic
domains in which we have poison taking
care of things as the computation of the
ilm putting from the il-23 a dress code
and then recover expression because we
need to recover some exposure get junked
out doing a compilation not to make the
nicest more precise we have to do alias
analysis so we have some imp analysis
and actually our analysis it's with call
it optimistic you can call it and sound
we make assumption it'll sound yes it's
a real optimistic amount okay so it is
so the Dionysus essentially makes a non
ionizing assumption on the on the input
or one otherwise saying is we are doing
a form of separation logic we just say
okay things that came in input they
don't they don't tell us and the reason
for that is because we want to give
names to this thinkin it's interesting
there are people there are two students
PhD students at th e th that are doing a
PhD thesis ona falsifying the
supportassist and it pretty interesting
so I think there are also ideas for
language design in this thing seems to
work pretty winning in practice so
didn't get any bug report actually what
it is it's kind of weird anyway can take
off like a bananas and then well on the
top of this all the rest it it sounds so
we have numerical domains and we have
plenty of numerical domains because this
is very very important to really get in
very quickly relations and range is
about variables in in our program so we
design new abstract domains with papers
on there then and I think also we want
to read about the content of the array
of collections and other things so we we
design things that
take you know can you very simple forms
of quantified in variance with for all
existing which they create scale very
very well then we also take into account
strings disjunctions ND in us and so
forth so you may expect a knife stock
and i've sent invitations a lot of the
domain i'm not going to do it today i'll
be here all day until tomorrow so if you
want to talk a bit happy stock just want
to show you what was your experience
looks like so the tools are integrating
visual studio and so you enable static
analysis by just clicking this checkbox
and then there are a bunch of other
things so you can say okay i want to
cash your result what I want to try to
check and I think then I atf6 it builds
and then the setting and Isis runs in
background and puts the output in India
released in visual studio and it says
which a session are proven and so in
this case also says you know there is
something cannot prove so it just say
that there is a week a precondition
which is too weak because okay this code
is correct but its color yeah you know
what is doing is taking I requires I to
be gritty equal to 0 alocasia array so
this is not going to cause a problem but
now the array i'm passing here it can be
empty because i can pass 0 and so i can
violate this precondition and so that's
what the tool is saying saying
essentially this program point here it's
a little row with the context but yeah
little bug here the squiggle should be
actually here this should be i agree
that written n0 it's clear why because
of the white side i will get an error if
a plus 0 I get post condition violation
here a precondition relation here or
buffer ground yeah so that's that's
experienced it that you get so now
everything is wonderful isn't it I I can
be done with my talk now actually no
real life it's harder it's not enough to
give warnings it's not enough just to
say okay this thing can be can be by
your lady so this is trivial example in
which you know I've off by one I just
iterate on the array i want to set
everything to 0 and they made my upper
bound incorrect and abroad because i'm a
pascal programmer
and so the tool will say okay there may
be a buffer overrun so it's in this
program point here though it gives the
alarm now is it enough why what we try
to do is also to say how to change the
program what you should you should do it
so the tool also suggest you say okay
you can fix your code by replacing eyes
Monique when I write at length to I not
small and a decline it's kind of magic
isn't it want to repair the program for
you or actually by the way in general
there's no one only one way of fixing
the program Amy several one so another
one for instance something that should
all this that you want to their right
not to be empty because if they erase
empty you get an error immediately
because it go here zeros more equal than
0 and it's de Janeiro so this also
precondition I suggest so I want to
repair the program now what's what's the
day about the idea about the repairs in
general if you think very abstract view
of program analysis there are three calm
point in program analysis there is the
program the text I want to analyze there
is a specification which is what I want
to do what the problem is supposed to do
and then there is Dionysus of the result
that it can be a dynamic or static and I
see say it lets you some information
about what the program is doing can be
of a proxy measure if this is the
recognized under proxy measure if it is
testing now the usual verification
problem is that using the information
that between fair check that the program
it is a specification and user approach
we say okay if I cannot do it let's go
with a more refined abstraction let's
get more information about the noise of
the program now the code repair problem
is it's different you still keep these
three things but now you take you take
it's fixed the analysis and the
specification say oh the program you
really trust that you are nice is
precise they say probably the program is
incorrect so what you want to do is to
to refine the program so that it meets
its specification keeping the analysis
it's just changing the variable see it's
similar to the programs in the c-span
slightly different because you're
already up with the program and actually
they've been a lot
research or still ongoing research the
one over repairing the program starting
from testing dominoes in the audience so
in the idea is this it's you have your
program you have a test fit and then
some tests they fail and one test a the
past one test fails now what you want to
do is just to do a program
transformation so that all your tests
succeed that's what the absolute level
what they try to do which is which is
interesting but is the drawback that in
order to do this stuff you needed to run
the program and our goal is to do it
while you are writing a program or
particular so when you are developing
library so you don't really have a test
case yet all the things of the program
can even for itself cannot team and
compile because it can be incomplete so
that's one problem is that we cannot run
the program for anything and the second
one is that does not really
specifications I specific agency as good
as the test CD I think one of the first
paper published in this in this area of
research they were fixing a safety by
adding a if via 30 so essentially we're
skipping the assertive was fed and it
worked okay if they're test it wasn't
you know not depend way today they were
just happy that that we're fixing a
program so we we propose a semantics
semantics national repair so we have
supposed to its function are from
programs to programs and intuitively
what this repairs to do should reduce
the bed runs we should have less bed
runs when you run the program and she
increase the good runs a promise so we
want you no more accession satisfied but
we don't want to fortify anesthesia I
could prove before and in general we
don't want to remove any good behavior
that's our our our scope so I can put a
lot of strange Greek symbols here but
decide to put some English to explain
how how we can formalize all this thing
at essentially the idea is this is that
we take the program p and we take the
repaired program p and we take each
semantics which is a set of traces
they're all the runs there are some good
runs some bed runs and now we want to
compare the two we cannot compare it to
directly because
they can be completely arbitrary so
there will be only trivial repairs that
we can enable what you want to do is
just to compare to some level of
abstraction so we want to just to see
something about those runs and we only
want to compare that you know some
property of these this run Sarah
ourselves so the abstraction it we have
actually a for obstruction and just made
one because the composition of
obstruction is an abstraction so the
first one what it does is it takes you
on the program in the repaired program
the excessive antics and now it removes
all the states but does the container
session so we only wanted to observe
sessions only things that can be
violated so assignments that I thinks we
don't care just you want to see the
states where we have a session then we
remove all your search in the repaired
program which they don't appear in the
real problem because when I accentuate
the change my program I repeat it
automatically me add the new piece of
code spc code reasons can have new
access need not to dare to erase or two
today episode they can be new accession
we are not very interesting this
obsession so we remove this sh 0 we just
want to repair the older session so and
then we don't really care so I say that
I runs a set of over Tracy so there is
an order me I don't really care about
the or they only care about the session
so we abstract from traces to set of
states and eventually I am not really
interested about the values at this
program point in yourself but don't
interest if this the assertion it holds
or not it's a composite this for
abstraction essentially i get my
instruction that's what i want to do it
want to just say okay whenever I get
good runs in a good program and I get
all these obstructions I see only the
session I told you in the good runs
where they still they should still all
the cessation in the good runs of the
repaired problems but also wanted to
have a fewer bed runs when I see this
thing in a in the repaired program
should be explored elect not that that's
the definition so that at least gives us
a way you know to fix the problem then
why's we we can just fix the program by
just putting assume for also other
things you know the never call me or
just put skip never get an error now how
are these things works now the idea in
the king site is that actually when we
do the analysis that we have this little
boxes we saw before actually we know a
lot a lot about the program so here it's
a it's the trivial almost three weeks
and I can think over or repairs which is
not so trivial to to the program it's
kind of used to many triggers in this
statement so there is a programming this
is a problem this program so you take to
the boards you send them you write this
into a field and the you check if the
field is equal to TMP I know yeah
usually text books I don't do equality
among doubles but you here since that
you can do the quiz a bank that was it
because it's exactly the same thing
isn't it so this thing should always be
true isn't true and actually it's not
the case it's not the case in that net
and is to do with something about the
architecture / x86 machines oopsie sorry
so because this is a double so it's a
64-bit but actually it's a parameter so
it's a local so in that let's say that
you have to use the highest precision
the possible which is 80 beats on x86
machine so this is the 80 bit this is 80
beats now in 280 bit past 80 beats the
result it goes into a local so it's 80
bits and now when you have this local
you right into a field the semantic
AlertNet says that now you have to cast
to the nominal type to the procedure the
nominal type as f is defined to be a
flop 64 now you take this 80 bits and so
the runtime truncates to 64 bits so here
you are comparing two different
quantities because this is this is a cig
is 80 truncate 64 read again in the
register so it gets padded with zeros
yes running on an IP 87 the old version
of CPU which in German style of now
downgrade lecture actually the
unfortunate is true also an ARM
processor and many others I can take it
off even are even are my and other
processor itself it's ok i will won't
talk about it but yes unfortunately it
Santa has to do with performance and
design yes the new process the new
append Ian's have don't have this type
of they have two floating point
instruction sets and even take tough
line but what I'm just going to accept
these is the result I mean I thought in
most programming languages when I add
two integers together i get an integer
when I had to dance together I get a
double are you saying it's in f-sharp
when I add two doubles together I may
get a higher precision yes and that's
when they are local yes that's part of
the specification it's written a
specification I ok i went to read and
but acura is still true with bedroom
like we can take it offline i run on
this machine which is a core i7 and and
any a tap and so they didn't I know ja
ja vol so it's a strict or whatever but
that's the to.net so okay now the freaks
here it's easy actually so that that was
the mine I think because this thing is a
64-bit this one it's extended precision
so what you want to do is to compare the
same precision so what you have to do is
just to force a plus B to be a 64 in a
way in which you do it by adding a cast
to double its funny but that's the way
in which you do this is a double this is
a double but you can see double it's not
identical they waited but you know it's
a very unintuitive a fix but that's the
way in which you fix the progress so
that's what the tool would say say okay
these two things are not the same I
suggest that you put a cast or more
interesting you can do it for for our
binary search I think you know about the
film yet yeah it's absurd the manor
specific essentially the way in which it
works so each I've so domain you ask
this is the piece of code do you know
how to fix it it's the same way in which
you ask up the domain do you know if
this is smaller than that you know if
you dissolved it just another primitive
of the absurd domain so yes fixes its
actual domain now see the fixie so yes
the lift is here so and probably this
example is a little bit more interesting
so you know about binary search you know
about to the bug with binary search yes
I guess assume everyone else the bug
with a binary search which you know they
were doing computing the element in the
middle by doing a nymph plus soup so
what's happening when we did give this
example to clue so we're closer will
infer the loop invariant infer that you
know the lower bound is more eager than
a soup it's this smaller than the length
of the array which can be equal to 2 850
1-1 and by using this information it
cannot prove that this expression does
not overflow so it will emit a warning
about it and this is going to be
annoying because you are going to get a
lot of this morning so what we want to
do is not only to give the warning but I
don't say how to fix it and in fact
that's what what the tool does it just
suggest repair say instead of writing
impossibly bye-bye to write if plus
supe- seem divided by 2 and essentially
what the tool is doing this case we have
this numerical domains we say okay this
thing can overflow Kane are you able to
get me an expression which is equivalent
inside which does not overflow and in
this case it comes out with the answer
is a yes essentially it's just doing the
writing and trying to prove it works yes
although it's just buzz believable oh ok
so we have we have several where several
modalities so by default we say when we
have assumed don't overflow that that's
what you do in the next computation
assume it is synced &amp;amp; applause wear a
flag and say we want to check for the
overflows and now we give you all the
other flaws all we have the default in
which we say we only talked about
overflows when we know how to fix it
which it so I say I try to make it this
is the case you see you say ok in this
case we know this guy this guy can
overflow so but we know how to fix it so
you say replace this with that so that
you don't want to float the programmer
with your overflow because the problem
is that if you want to make it right now
you have to add a lot a lot a lot of
contacts way more they want to write so
it's a it's a trade-off so we have a
switch you can get all the warnings you
want you want to hang get it and then
there are things also because in.net
there is a difference between overflow
and then they are check the expression
which they draw if they do overflow so
and what we have at least
step 3 okay now we know how to check
things we know how to repair things at
least for sunglasses is it enough
actually a big part of what indeed in
last year's is a can we infer contacts
how we can infer contracts because
because ideally the programmer just goes
there and provides all the specification
all the boundary specification the
precondition the postcondition see does
four types that's the ideal setting but
actually turns out that no one is ever
going to do it because the feedback you
get is okay i have a metered a return a
new a its new so i know i'm returning
sunday which is not not why should i
write it that's that's the argument and
for many other things yes they say why
is not in farrand it it's just evident
or i want only to add the contracts i'm
really interesting the one only makes
sense you know the other things are
evident from the code and the definition
evident it's it's very hard but and the
problem and the problem is that you know
they have this first approach this first
thing is so detective tool they run it
the star tweaking say oh why didn't
prove it did it's a damn tool and then
you're done you screw up when they get
this thing so we need we need the tool
to help the programmer so you know so we
need to eat smart we need to infer as
many dumplings and evident things as
possible now um the following it's
important it's make clear the
distinction I think here everyone knows
logic so this should be very very easy
but distinction between sufficient and
necessary so if I formula as implies n s
is sufficient for the conditional n and
n is necessary for the condition s and
for programs essentially what it means
is that the condition s is sufficient if
we told then the program is correct
similarly if n is necessary in that if
it does not all then p is incorrect easy
now why this is important because they
want to infer contracts and the first
contacts you want to infer reasons are
preconditions usually those are some of
the most important they want these
programmers this product and after
thinking a lot and I give examples turns
out that the way we do automatic
influence the only precondition makes
sense to infer for for the user to do it
automatically is a necessary
precondition and not a sufficient and
intuitively it's because of this because
sufficient precondition they say if this
odds then my program is correct but they
can be too strong because you have loops
and other things things you don't know
any progress so what you are going to do
injuries you are going to under
proximate it now distinct you get
propagate to the color and now the
scholar it should prove something which
is a other what really in reality I see
which you guys in the concrete semantics
and people will be unhappy with it
whereas a necessary precondition isn't
they say this should otherwise you will
get an error so checking this thing here
or at the precondition on the cold side
it always makes sense it's always a
condition to Aaron so now let me show
you with a with an example it's very
simple example but actually this game
it's a real example someone posted on
our forum outside the company form and
they were an MP while this is a biscuit
what is doing it just say if X 320
return the reference essentially now the
nessus is sufficient precondition this
case is that either x.x is more than 0
so we never the reference a we go there
or if this video 0 then I should be not
so this is the one and beginning of the
time we had some some inference
algorithm was doing sufficient condition
and is tool was saying okay I'm firing
that a should be different for null
because you may say okay I don't want it
to be not now the problem comes that
programmers they can call it this
example by you know this function
example but put in minus to null and the
program is correct but I were to say oh
the precondition its faults because I
asked you n-not banana your personal
that's false and then everything scrub
and then people were an appeal it and
that I I quote the call detail wrong
precondition they were happy so in
general it's hard to infer to infer
sufficient a necessary condition the
problem it's usually it's because of the
loops and 12 sufficient we had two under
proximate with necessary we can ever
approximate so still be safe and we have
several algorithms for for doing this
influence on necessary conditions in an
inclusive and here I'm just presenting a
schematic approach for this simple piece
of code so we first one is the old paths
it's very simple and the idea is this if
I have some assertion which is checked
in all the path inside my meter and this
assertion isn't it is not modified from
from the color so it just depends on on
the state at the entry then this should
be an assertion should be a precondition
so for instance in this case no matter
what I do I I'm going to eat the loop
oops the loop ed and repent is that a
should be not null and so this is
definitely a precondition that I want to
have is necessary because I know if a is
equal to now then program would crash
but it's not sufficient because the
program can be stealing correct then we
have a more sophisticated one in which
we do essentially backward analysis
doing dual widening for people like Alex
interpretation and stinks it's kind of
exciting concept and in this particular
case you infer that the Edit length
should be greater than zero with this
analysis well actually we also infer
that the a is different from now but
just wanted to simplify things so if we
go here we get i equal to 0 and the
first iteration we get with the
reference we access a of 0 so we should
have at least one element in your right
and if you continue with iteration say
ok if the fifth element is not three
then it should i when that we have at
least two elements and if the fifth and
second payment is not we are not three
then we should have at least treatment
and the and so on and also we have a
different static and I see which is kind
of cool they have that prob I should not
say that is cool because I is it but i
find it cool so in which we can also
infer the existential one I said that ok
this program I reached this program
point if
existing value such that a of j is equal
to 3 so there are different degree of
influence of precondition we can do on
necessary condition here how it looks
this you know for for the programmer
what it looks like that so this example
is very similar to the 1i show and short
two slides ago and for op see why it
goes tick so this one is quite figure so
what is inferring is in fact that acting
is more than 0 or be different from that
okay now I have a question for you why
we use this symbol or instead of
implication why we may not have a
contract that implies it just to wake
you up to so I can drink water the
question is why why the tool in first ex
more than 0 or be different from null
instead of inferring something as
contract requires contract that implies
X molecular than 0 comma be different
for now while we may have we have
contract dot so we can just yeah what
yes yeah it's a yeah the problem cases
on the fact that in c-sharp evaluation
parameters it's it's eager whereas the
or any weights it's lazy so that's
that's the problem can game it's about
lazy evaluation ticked and yep ok so we
infer this one and then we propagated
this program point here and now we are
passing 1s so we know that one is more
than 0 so this is true was it one is 10
its fourth sorry that this goes away so
we be different from s from now but p is
s so when fair for calling phenomenal s
different from now requires as different
from null so this one and now we call it
with null and we omit requires its
faults and we give the tray
the tries to the error we say okay you
do this and then decent it yes no it's
justin it's an error in the pretty
printing guy I take all the shame for it
sorry yeah it's probably fixed since
then but yeah it's it's no it's it's a
knob and the ideas for the influence of
precondition can also be generalized for
the influence of a object invariance I
have this simple read on example so i
have a read-only field so I redone if
you didn't see shop it and feel that you
can only assign in the constructor
almost you can change with serialization
but we don't do serialization they say
all that meaningful c-sharp you can only
change in a seizure in the in the
constructor and oopsie sorry so we
assign this my field and then where this
divided we just take tea and we divide
by this my field so now there is a
problem because here we may have a
division by zero we don't know anything
this thing can be zero so but we know
this is a read-only so what the contract
the tool is doing say okay this is a
necessary object invalid because
otherwise you can constructively in this
object by passing zero and then you can
divide and then you get in trouble so
that's why the two now is adjusted
invariant that this my field should be
different from from 0 that's that's one
thing and now that he has this
precondition for this object invariant
now it turns out that also we are not
allowed to assign a my field i believe
it is equal to 0 so now we generate a
precondition say that X cannot be 0 so
essentially we are propagating it what
you are doing you are doing a fixed
point actually it's the greatest fixed
point if you like this thing so we are
doing this fixed point a greatest fixed
point or list fixed points very exciting
it and
more than cycling imaging and then we we
still get a warning now we get the
warning here so and say that we may have
a division you can have a number flow so
again for this overflow they are we
always say about this overflows because
are important the people they don't
think about it and you get an overflow
because you are dividing min value x
minus one to get you get another flow
and we are not generating anything for
it so do why we are not generating a
precondition this is one of the case you
know it's you know the to list does nice
things but it's not magic and yeah it's
this one thing and in general our our
inference it's always we will never
remove good runs whenever it is a good
run we keep it we never wanted to make
the programmer crazy because say oh you
remove the this crazy behavior that I
wanted we never do it we always are safe
we always remove things that go badly
now the problem is how we can fix this
thing now we can add a precondition but
with precondition you want to put we can
put the precondition at t is not minus
sorry the tea is not mean value why
should you you want to buy them in value
by one the problem is when both mean
value and my field a when T and my field
at this particular point yes sorry the
Grecians be relational yes yes really
exactly but that's actually I should
have put it actually the tool will find
this thing but it's not a precondition
it's any problem is because my field is
private now you cannot ask you cannot
ask to the color to set you know to grab
this precondition you cannot sign say
okay you have to have this relation
among good i think you are passing me
and this thing is private to meet it's
very unfair you
you cannot ask it so the tool will
discover this property and it does not
actually what we will suggest it to put
an assumer and just say okay believe at
this program this is what's happening
but yeah so those are three key things
when you go and start racing with
contacts and when you call the
construction when you call the public
interface the two values weren't in a
relationship but it's not obvious outer
rim encode that it's in general is very
tricky because then well actually the
tool what is going to do is going to
infer a post condition for using
whatever you pass me here it's equal to
a value on my field and then but here
does not really wait reasoning it it's
really something extrait this is a
problem with the specification language
some out there is something something
with gamma ladies so there are limits so
what I say it's we tried some beauty and
some expressiveness for being effective
so here essentially you get the warning
and now the programmer should change the
code as it wants she wants with the
precondition post condition yeah it's
the problem with the subtyping behavior
essentially we were subtyping and what
is visible and what is not that's very
different and eventually all this
machinery can be used for for the
influence of post conditions saw
something when often you get with
warnings and problems is this one it's
because you get some interface and then
you call something about this interface
and you use the value and for instance
if you want to exit load to be null and
then you are you're in trouble and what
the tool the CEO says okay look here I
expect the X to banana land this X came
from this guy and this guy it's an
interface so now it's better you put a
post condition to this interface meter
so that you are sure that all the
implementation of this interface will
satisfy it so its descent step 4 still
we have a lot of steps enter I think
it's more less is plus infinity but we
have a finite amount of time so probably
I do this one and then I all right so
that's this recent result result or
even if probably she went to talk a
little bit about it when it came here so
it's now the problem not a problem you
are you have all these nice things you
know for checking and inferring and
verifying and you know everything is
beautiful except that you go and take
your code base which has no contract you
run clue soil you get a lot of warnings
even with the inference that's another
bad thing so why the Serpent essentially
this happens because real code base is
the start referencing things that we
don't know for which we don't have
contact so the tool makes or
approximation you know just say what is
this library no idea what is doing so
you can do everything and any gives a
warning out of it and you can go
instrument it and actually we have a way
that's some other thing you are not
talking today we did with with my intern
Scott care for instrumenting this thing
so this is kind of orthogonal hits to
infer these contracts then add them
automating into the code but that's 90
and the generic solution is your
solution with all static and Isis
commercials that they can I just do it's
to baseline the result essentially they
say okay this is the only one in second
came out so here I some piece of code
which read the temperature in Celsius it
converts into Kelvin a returns the value
and now we know from basic physics that
Kelvin can never be negative so this
assertion sure was true but I think
there is no static analysis in the world
that can can prove it unless it's you
know made by physicist I don't know and
so we get this a session we say okay no
problem what you're going to do is so
that's with some synthetic basin lining
you just take the session on line three
and you just mask next time you analyze
the program you know here I change the
code know it here it yes here I change
the color to beat you say okay this is
fine just don't show not sure the
warning now the problem is that what
what happens if i enter use an error
sorry for instance if i change the
constant the absolute value of the
constant for the absolute zero absolute
absolute many absolute so the problem
now is incorrect but by masking the
thing that line three i will not show
this warning and this is bad this is a
warning i want to see because this is a
regression or similarly if i change the
code a little bit and now i say oh I
wanted to round my value let's say
having only two digital do
two digits after after the coma now as
I'm baselining at line three while I'm
not showing whatever precondition or
whatever a session over here but i'm
resurrecting this one but this is
correct I don't want to show this one
it's this Assessor is still correct if
you was correct the previous one yep
yeah yeah okay yes you are right yes
they can be inking can be with floating
point awful things canopy you're right
yeah I try to have this simple example
make sense now well it is a straw man
yes I made a simple example and the
scheme the schema for ax for the
baseline it's really trivial because it
just takes the line number and things
move shift so does not work real yes
that's a very simple example but what I
want to say is that in general synthetic
schema they are really brittle you can
break easily and they don't provide you
any semantic guarantee on the things
I'll show you and the things that don't
show you so the idea with the bmv
verification module version is a take a
base fashion or your program and extract
this correctness condition on it on on
the external world on you know on the
external input and then save somewhere
then you have your new program and when
you analyze your new program you just
take this condition you take the old
program you instrument it so you
construct the same instrumenting program
and now you analyze this problem and now
what I claim is that you have semantic
guarantees on it so how it works in this
example well they fear again it's it's
clear that this program is correct if
and only if the value returned by read
temperature it's a large or equal than
the absolute zero so we are going to say
this thing into the database will
remember that this code the previous
version was correct if an aleve that
they think that condition all done on
this external IP I which have no idea
what is doing now if I if I change my my
program instead having 50 you know 15
and our f0 by adding a century before we
are no more able to prove this exception
and now we we report a warning say
because now essentially you need a
stronger assumption you need it before
so we call it in a regression now
because you are asking more to the same
API before or on the other end up to the
rounding errors in on this problem and
where you run right yeah now when we
have the problem with round well using
this assumption now we are able to prove
this thing so we say this is not
verification its relative verification
it's with the assumption told in the
good runs before I can still prove it so
it's a weaker notional okay and yeah
that's essentially what we do in one
slide and things gets tricky because now
we have to talk about when the extra
condition again I think you understood
from this talk it's important to reason
if this sufficient are necessary so
that's very important very pissed point
then when you instrumentet actually is
where you're going to insert this
assumption this is another three key
points that gives different result in
different precision levels and third one
is without the semantic guarantees so
very sketchy if what you infer this is
sufficient then you get bug finding it
is all the warnings that are shown you
our new warning so you want better look
at it but you have you don't know
anything about what is not shown to you
and Julie if they are necessary now this
is for relative verification everything
it is proven it's either program because
it's true or proven because you're using
the assumption of the pure sprayer
program but we have a warning you don't
really know this can be an old warning
and you want so it and I think a skip
step 5 sorry I think I'm running out of
time so I'm sorry because the boss is
nice think you know these abstract or
tripods and discount example but I have
no time sorry but I really love this
idea of abstract or tripods in front of
also and well very quickly the idea I
can just give the idea of what this
video is that another prominent games is
that program that they change they get
modified they get refactoring and so
with the program we are the proof now
you change the product now you cannot
prove it anymore so we want also to have
this form of proof preserving
refactoring so that when you change the
program we also generate contracts pre
and post condition so that the proof
Steve goes on so and we have some 20
from doing something on this
so the conclusions and try just to sum
up 3 minutes left essentially your mind
my goal is to have this to bring in you
know verification to the working
programmer just make you know don't need
a PhD in order to use verification to
get all the nice things that we do in
academia all them all you know nice tool
set we have so and if we're doing it we
need it the verification to be
user-friendly we have a really when we
go and design our tools to think it the
user before that to our self so that's I
think that's very important just I
always think that what we need is that
the tool should use the programmer not
the program I should LP the two dates
it's that maybe we need it to be precise
enough not to generate stupid warnings
not to be called dumb I already add this
thing and it should scale up because
real code how dare it being is large
there is a lot one a lot of cone and
every day gets produce more and more and
more code and we need to be as automatic
as possible for inference and other
things so my little slice in this video
and I I contributed to the code
contracts project by having this library
to specify contracts and using an option
to protection order to verify things
because so we can be more automatic you
can be deterministic which is important
we can focus on properties which which
matter most so we don't aim at full
functional correct edge but still things
that make sense and in order to these
there are several steps we need to infer
contracts we need to be able to repair
program and then to get fewer warnings
still giving semantics guarantees also
app in a row factor again one minute
left okay thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>