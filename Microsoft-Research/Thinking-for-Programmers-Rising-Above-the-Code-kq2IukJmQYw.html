<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Thinking for Programmers: Rising Above the Code | Coder Coacher - Coaching Coders</title><meta content="Thinking for Programmers: Rising Above the Code - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Thinking for Programmers: Rising Above the Code</b></h2><h5 class="post__date">2016-06-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/kq2IukJmQYw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year Microsoft Research hosts
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
well from the the lull I discerned that
you're ready for action which is great
I'd like to welcome you all to this the
first in our new series of Microsoft
distinguished research lectures and I'm
delighted that for the first of those
lectures we have Leslie Lamport to come
and speak to us he began dabbling in
computers while he was still in high
school and I believe it involved vacuum
tubes at the time if you know what those
are but over the ensuing decades he's
become a legend in computing circles his
work in the theory of distributed
computing is foundational his 1978 paper
time plots and the ordering events in a
distributed system is one of the most
cited in the history of computer science
and he's contributed core principles for
the field of specification and the
verification of concurrent programs um
Bill Gates calls him a leader in
defining many of the key concepts in
distributed computing on March the 18th
in recognition of these advances the ACM
named Leslie Lamport as the latest
winner of the a.m Turing award and the
citation reads for fundamental
contributions to the theory and practice
of distributed and concurrent systems
notably the invention of concepts such
as causality and logical clocks safety
and liveness replicated state machines
and sequential consistency so many
congratulations for that
Leslie were absolutely delighted to have
you here to speak to us on thinking for
programmers looking forward to your talk
thank you Andrew I'm delighted to know
the learn that I invented causality is
someone observed the world must have
been a very confusing place / for me
okay thinking for programmers or rising
above the code that's me my fundamental
thesis is that thinking about what we're
going to do before doing it is a really
good idea and a corollary of that is we
should think before we code and a very
profound observation by the cartoonist
Guindon is that writing is nature's way
of letting you know how sloppy your
thinking is so if you think without
writing down your thoughts
you only think your thinking and the
obvious conclusion is that we should
write before we code specification as
specification is simply what we write
before we code it's a blueprint of the
code now blueprint is a useful metaphor
but remember it's just a metaphor and
shouldn't be taken too seriously a
specification should be an abstraction
of the code we already have that we will
already have the code to tell us what
the code is
but specifications should be at a level
above the code a more abstract version
than the code if we're thinking at the
code level then we're coding we're not
specifying a blueprint of a house shows
walls and windows it doesn't show bricks
and nails and all that stuff that you
use to make sure that you know the house
to build the actual house the stuff that
the house is made of it's about these
abstract things like walls you know this
piece of plaster board and stuff behind
it that is abstractly called a wall
so what's higher level well an algorithm
is something that's higher level than
code a protocol and the communication
business is something that's higher
level a
design whatever name works for you these
are just you know different names for
something that's at a higher level than
the code so what about thinking while
coding well that's a great idea I have
nothing to say about how you code use
whatever language you want whatever
programming methodology fed you no
strikes your fancy I have nothing to say
about that
so I mean computer scientists you will
probably ask well in the specification
language if I'm going to write a
specification well too many computer
scientists suffer from what I call the
whorfin syndrome which is the confusion
of language and reality look up Worf Ian
on the web when you get a chance now I
don't want to get you no philosophical
what is reality it really means the
confusion of language with what it is
that language is trying to say what it
is you're actually talking about so
let's think like scientists and thinking
like a scientist is a very successful
way of thinking what science does is it
makes mathematical models of reality for
example if you look at astronomy which
was arguably the first science the
reality in reality planets have both
mountains oceans tides weather all sorts
of interesting stuff going on but
astronomy often models a planet is
simply a point mass having a position
and momentum that's a very abstract view
of you know the earth computer science
reality consists of digital systems
things like maybe a processor chip a
game console a computer executing a
program
all sorts of things like that but above
the code level they all look pretty much
the same so I'll talk about programs
what I have to say applies to any kind
of digital digital system because they
all are very much the same when you're
thinking above the code level so the
model well what kind of model you choose
way you model something depends on the
properties you're interested in if your
modern modeling a planet and just want
to find out you know where it's going to
be when you look through the telescope
for it this point mass model is a it's a
very good model on the other hand if you
want to try to predict sandstorms on
Mars
thinking of Mars as a point mass isn't
going to get you very far
so what I'm interested in the properties
that I'm interesting are what are often
called correctness a correctness
property is one that's true or false of
an individual execution you can just
look at you know run the program
possibly for infinity in conceptually
but just looking at that single
execution you can say did that program
satisfy that property and that's what I
call a correctness property so a program
is correct
if the property is true for all possible
executions now the two most useful
models for talking about correctness are
functions and sequences of states
functions sometimes it's what you want
to do is model a program as a function
that map's inputs to outputs now in
mathematics a function
a set of ordered pairs for example the
square function is a set of pairs on
which maps natural numbers tie natural
numbers is a set of pairs of natural
numbers for example it contains the pair
2 4 which tells you that applying the
square function to the number to return
equal gives you the value 4 or in other
words square of 2 equals 4 and the
domain of square are the set of all
first elements in those pairs namely the
set of numbers of
non-negative integers which are I will
call that to define a function what we
do is first we specify its domain so we
say the domain of square is equal to net
and then we describe how to what the
value of square of X is for every
element X in its domain now beware that
there are things in programming
languages that are called functions
they're not sets of ordered pairs
functions in math there are simply very
simple things sets of ordered pairs I'm
not sure what functions and programming
languages are probably depends on the
programming language but I know there
are a lot simpler than sets of ordered
pairs I'm sorry a lot more complicated
now sometimes we need to generalize from
relations rather than functions but I'll
ignore that the function model though
has its limitations it's first of all it
specifies what a program does but it
doesn't specify how it does it so quick
sort and bubble sort compute the same
functions but they're obviously very
different programs also some programs
don't just map input to out inputs to
outputs some of them run forever or
conceptually forever
they may have complicated interactions
with their environment and they're
things that we call reactive systems and
for those we need what I call the
standard behavioral model or the
standard model in which you might
describe a program execution as a
behavior where a behavior is a sequence
of states and a state is an assignment
of values to variables conceptually very
simple and a program is modeled by a set
of behaviors those that represent all
possible executions of that program
other similar models that involve States
and sometimes actions and stuff but just
simply talking about sequence of states
is is the simplest and I always like
simplicity so let's take an example and
of course I don't have time for anything
but really trivial examples so you
please algorithm is about as simple as
they come it computes the GCD of two
numbers M&amp;amp;N by initializing X 2m and Y 2
n and then it keeps subtracting the
smaller of x and y from the larger and
it stops when x equals y and then x and
y equals the GCD so for M equals 12 and
N equals 18 you can see there's this one
behavior starts with initially x equals
12 and y equals 18 and we subtract 12
from you know X from Y to get this state
where X is 12 and Y is 6 and then
subtract Y from X to get this state and
it stops when x equals 1 which is + 6 is
the GCD of 12 and 18 if my calculations
are correct ok and properties a property
is a predicate on behaviors its true or
false of a behavior and a property is
equivalent mathematically to the set of
behaviors that satisfy it and there are
two basic types of safety prop of
properties a safety property
is one that is false if and only if it's
violated at some specific point in the
behavior it's a safety property is if
you can if it faults you can look and
say some particular spot and said here's
where it went wrong example is partial
correctness where a program B says that
a program doesn't if a program stops
then it produces the right answer and
you can tell that if it's violated by
finding a place where it has stopped and
produced the wrong answer aliveness
property is one in each system which you
need to see the complete behavior to
know whether it's to know if it's false
for example termination you can't tell
just because the program hasn't
terminated up to some point doesn't mean
it's not going to terminate you have to
see the whole behavior to tell whether
it has terminated and that behavior may
be infinite if it hasn't terminated now
there's a theorem that says any property
is the conjunction of a safety property
and aliveness property so how do we
describe a set of behaviors
well we describe them as the conjunction
of a safety property and aliveness
property so first how do we specify the
safety property we specify two things
first the set of possible initial States
and a next state relation describing all
possible successor states of any given
state so how do we specify them well
we'll do it like scientists we use meth
so the set of initial States its
described by a formula for example
Euclid's algorithm the initial state
says if a particular constants M&amp;amp;N
initial state says that x equals m and y
equals n which is expressed by very
simply by this formula okay and of
course that specifies the one possible
initial state for this algorithm
the next state relation is described by
a formula containing prime variables and
unprimed variables where the unprimed
variables represent their value in the
current state and the prime variables
represent their value in the next state
so for new clins algorithm
it's the disjunction of two formulas
there are two possibilities
what if X equals greater than Y and
wonderful if Y is greater than X so if X
is greater than Y then what do you do
will you subtract we subtract the
smaller from the larger so we subtract Y
from X which says that the new value of
x is equal to the old value of x minus
the old value of Y and we leave Y
unchanged so the new value of y equals
the old value and similarly for a case Y
is greater than X we do the symmetric
thing so new value of y is the old value
of Y minus the old value of X so let's
see how this works for Euclid's
algorithm and let's take M equals 12 and
n equals 18 and how do these formulas
determine a behavior well the initial
predicate says x equals M and y equals n
so let's substitute 18 and 12 for MN or
12 and 18 and it tells us there's only
one possible for initial state one
possible set of values the values of x
and y that satisfy this formula namely x
equals 12 and y equals 18 okay to find
the rest of the states we have to use
the next state relation so to find the
second state well we look at the formula
next and we substitute these the current
values 12 and 18 for the unprimed values
here and then we just do a little
calculation 12 greater than 18 is false
and false and anything is equal to false
so that first disjunction is false and
we can ignore it 18 greater than 12 is 2
true and it says then Y prime this is
satisfied
only for y prime equals 18 minus 12 and
X prime equals 12 so in other words the
only possible next state is y equals 18
minus 12 or 6 and x equals 12 and then
to get to the next state we do the same
thing this time using the values of 12
and 6 for X and for the unprimed value
of x and Y and again we have this second
disjunction is false and this tells us
that the new value of x is 6 and the new
value of y is 6 the only solution and
then we keep going and here we see both
disjunctions are false so the whole
formula equals false and there are no
values of x prime and y prime that make
false true and therefore there's no next
state there's no possible next state
which means that the execution has
terminated ok reasoning about safety
the key to reasoning about safety is
invariance and invariant is a state
predicate something that's an assertion
about the state which is just a formula
involving the variables that is true in
all states of all behaviors allowed by
the specification so this is the
invariant that shows that Euclid's
algorithm computes the GCD of M and M
the variant is that in all states the
GCD of x and y is equal to the GCD of M
and N and that shows it's correct
because remember its halted when x
equals y and x equals y implies that the
GCD of x and y equals x which equals y
which is show is that when it is
terminated with x equals y that value of
x and y is the GCD of M and M because of
this invariant
so proving invariance it's very simple
and it's a very simple idea based on
induction you first show that in the
invariant is true in the initial state
which means showing that the initial
predicate implies the invariant and then
you show that if the invariant is true
in any state then that implies that the
invariant is true in the next state
well that's expressed by this formula
the invariant is true for the old for
any step for the starting state that
means it's invariant is true for the
unprimed variables and the primed and
unprimed variables are related by the
formula next that implies that the
invariant has to be true for the prime
variables and we write in variant prime
simply means invariant with all the
variables primed so this formula asserts
that if the invariant is true in the
initial state and the next state initial
state and next state satisfy this
relation next then invariant is true in
the new state which and these two
properties obviously prove that the
invariant is true for every behavior of
every state I'm sorry for every state I
have every behavior so thing to notice
is this is just math we've reduced the
problem of proving invariance to just
proving two formulas simple mathematical
formulas it's what science is about
reducing things to math specifying
liveness for programs that compute a
value and stop we usually just need one
condition which I might call non lazy
which states that the behavior does not
end in a state from which the next state
relation allows it to continue for
reactive programs it turns out that we
need very
rather arbitrary fairness requirements
to specify different kinds of liveness
properties we may need and in fact we
often don't want non laziness for
example we usually don't want to require
that in a reactive system that the
environment has to do anything now
I don't have time to really get into
liveness and safety as well so I'm going
to mostly ignore liveness in this talk
so what about formal specs I mean where
I was doing just writing mathematics you
know you must you know wireless stuff
about formal specifications well we need
formal specifications if we want to
apply tools to help us check them and
applying tools requires that we write in
a formal language that some tool can
understand and the language that I use
that I even invented is called TLA plus
and i'll describe how to write Euclid's
algorithm and TLA plus here's what it
looks like this funny symbol here means
equals by definition the specification
is just those two formulas in it and
next well then you have a little bit of
boilerplate to declare X &amp;amp; Y to be
variables and M and n to be constants
and then this stuff turns out that
operators on the integers aren't built
into the language so you want to import
this module integers standard module
that defines things like greater than
and - and you all wrap them all we wrap
them in up in something called a module
and that's the TLA plus specification of
Euclid's algorithm and this is what it
looks like in ASCII it's a real language
and you can apply tools to it you can
model check them model checking or a few
of you who may not know means in
principle checking that all possible
behave
years of the specification allowed by
the specification satisfies some
property and you can also write form you
know set for example invariants in model
checker will tell you that you know
we'll check that that invariant I wrote
for Euclid's algorithm is an invariant
for Euclid's algorithm at least for
particular values of M and n you can
also write formal correctness proofs and
check them mechanically with our theorem
prover in fact you can prove that GCD of
X y equals GCD of n and n is an
invariant for all values of M and n for
Euclid's algorithm from that
specification of course these are very
trivial properties and it's very trivial
you know very easy to prove them and why
this and TLA plus what you do is you
write the specification as a single
temporal logic formula and it looks like
this init next remember are the next
state initial predicate and the next
state relations that's the safety
property it says basically the initial
predicate is true initially and next is
true on all steps in the behavior boxes
the temporal logic always prompt
operator and var is the tuples of all
variables I don't have a time to explain
why you want it here and exactly what
that means but it's essentially says
that an it is true initially and the
next state relation holds for all
successive states in the behavior and
liveness can be any temporal logic
formula but the way you writer is in
terms of fairness properties and non
lazy is written this way it means weak
fairness of the next state operator and
you know if you've dealt with fairness
and that will make sense to you if you
haven't thought about fairness it won't
but having the specification be a single
mathematical formula leads to a certain
amount of simplicity and elegance and
power for example implements that one
specification implements another is
actually a simple logical implication
but of course we all know that you know
math like this works only for toy
examples to model real systems you need
a real language types procedures objects
etc right and wrong TL A+ is used in
industry Intel it's been in use for
about a decade you now used I think by a
few groups by informants at Intel have
all left Intel so I don't know what's
going what's actually going on there now
then what they do is they write the
high-level designs of certain chip
modules in ela plus and then apply model
checking to check them amazon has been
in use for about three years now maybe a
little longer
here is what Chris Newcomb and Amazon
engineer has to say about CLA plus use
at Amazon we've used TLA plus on 10
large complex real-world systems in
every case TLA plus has added
significant value either preventing
subtle serious bugs from reaching
production or giving us enough
understanding and confidence to make
aggressive performance optimizations
without sacrificing correctness
executive management is now Pro actively
encouraging teams to write T la Plus
specs for new features and other
significant design changes so it's not
just the you know the these engineers
who are you know you know want to do
this but then you know the managers
don't understand what's going on the
managers see that it's works and in
their annual planning they allocate
engineering time to use T la plus you
know oh we never have time for formal
methods well when you see they when
management sees that it works they do
have time this is written a few months
ago I think that number 10 is probably
increased by now I think there are a
couple of other groups who are using it
I'm going to give an example of the use
of this use of specification and use of
mathematics and specification I'll take
quicksort and I've never before had the
honour of doing this in front of Tony
Hoare the inventor of quicksort I hope
he appreciates it or I hope I don't get
any tomatoes from that direction ok
quicksort as most of you must know is a
divide and conquer algorithm for sorting
an array say a an element or array for
simplicity I'll assume the that's an
array of numbers and it uses a purse a
partition procedure the procedure that
takes two element two arguments and what
low and high what these procedure does
is it chooses a pivot a low and high or
two numbers with low or less than or
equal to high and it chooses a number
pivot and what it does is it makes all
the elements from low through pivot it
permutes all the elements from low to
high in such a way that all the ones
from low to pivot are less than or equal
to all the ones from pivot plus one
through two through high and it returns
pivot for this example I don't care how
this procedure is implement and we just
assumed that is some procedure that does
this now and let's specify quicksort in
pseudocode
here's the partition procedure it picked
pivot and low to high minus one and
permute a low to a high to make what I
said and return pivot and then we have a
precursor procedure qsr of low and high
and what it does is if low is less than
high it sets
P to the cause partition returns the P
and then recursively calls itself on the
to sub interval
from low to P and P plus one too high
and if low is not less than high then it
does nothing and the main routine is
just calls Q s on the entire interval
from 0 to n minus 1 so this is a quick
sort informal no formal syntax no
declarations none of all that stuff the
programming language going it's easy to
understand and this is a you know a
reasonable specification of quicksort in
formal specification it's in pseudocode
but there are two problems with
pseudocode first its sudo you can't
check it number of had its ten years ago
already I googled quicksort there was no
big back then and tested the first ten
algorithms that I found half of them
were correct
that's the glass half full every one
that was not written in executable code
was wrong in other words the only way
reason anyone got quicksort right was
because they actually debug it they
tested it and the other problem with
serial code is its code it's hard to
think above the code level when you're
writing code so here quicksort in
pseudocode but is this really quick sort
I mean is this the real heart of
quicksort it's the way quicksort is
almost always described but recursion is
not a fundamental part of quicksort
quicksort is a divide and conquer
algorithm and recursion is just one way
of implementing the divide and conquer
and in fact it's probably not the best
way if you want to run this in you know
with parallel execution on multiple
processors so here's a little problem
that you can give to people to write an
non recursive version of quicksort I've
tried it believe me
almost no one can do it in ten minutes
what they try to do is they try to
compile the recursive version and you
know almost no one can do that on his
feet and in ten minutes here is a
solution to the problem what we do is we
maintain a set u of index ranges on
which partition seems needs to be called
initially there's just a single range
the entire range and then we could we
come describe what does in pseudocode
but let's be scientists will describe it
mathematically in initial predicate and
next state relation so what's the
initial predicate the initial predicate
said a is any array of numbers of length
N and you has this initial value it's a
set consisting of just the the pair 0
and minus 1 which represents the index
arranged from certain range from 0 and
minus 1 and before I write next I'll
make one definition of defined
partitions of B pivot low high to be the
set of all arrays arranged from B well
essentially what it is it's the set of
wool that of all arrays that that could
be produced by calling the part seizure
partition procedure with the VAT with
the arguments low and high and it in
which it returns the value pivot so it's
all the a row it's all the arrays you
can obtain from B by permuting be low to
be high such that all the B's the new
values would be from from Newell values
from load of pivot are less than or
equal to the ones from pivot less one
too high in other words it's it's
basically it's a set of arrays is that
clear ok and
now it's just going to be a relation
between the old values of a and you and
the new values a prime and new prime so
it's going to have two conjunctions the
first conjunct says U is not equal to
the empty set because when u is equal to
the empty set we're done and we want to
stop which means the next state relation
should be false so it's going to be
false if u is equal to the empty set and
then what we do is we pick any B and T
in you any any interval in the set u and
if B is not equal to T then what we do
is we take any pivot point in B to t
minus 1 and then we let a prime be any
element of this set of partitions
partitions of we get from the values we
get from calling the partition function
with a values B and T and in which it
returns the value P and u prime is the
set we get by starting with you removing
the original interval B and T and adding
the two sub intervals from B to P and
from P plus 1 to T and if B is not not
equal to T if the equals to T then we
leave a unchanged and means the interval
just has to sing it's just an interval
of one element and it's already sorted
so there's nothing to do so we just
remove that element from you and here is
the next state relation of quicksort the
real quicksort in mathematics well it's
in formal mathematics so why can almost
no one find this version of quicksort
you give them give us all your friends
you know unless maybe and they've see I
think there's one book that actually
describes quicksort this way and if they
haven't seen it it very unlikely to to
find it to come up with it it's because
their minds are stuck in the code
they can't think at a higher level they
think in terms of you know recursion and
and arrays and stuff they don't think in
terms of sets now the non recursion
cursive version of quicksort is the most
general one and the recursive version of
quicksort implements it
well implementing it means it has to be
the set u of intervals where is that set
of intervals in the recursive version
raise your hand if you know ok someone
you want to tell me
in the invariant no I didn't show you
any invariant well we have to think of
it but it's like where do I find the
value of U it's in the call stack that
set is the information I mean that
that's what that set is is all scattered
around the calls in the calling stack
and in fact you can implement it if you
write a mathematical description of the
recursive version you would be able to
define U as a function of the variables
in that version one of those variables
being the calling stack now in most
programming languages there's no way of
talking about the stack and if you're
suffering from the Worf Ian syndrome
then what you can't talk about doesn't
exist and so if you didn't know it was
in the stack you may be suffering from
the Worf Ian syndrome ok now this is
written informally an informal meth and
you know that's perfectly fine on the
other hand if you want to apply a tool
like TL a pluses tools then you should
have to write it as a formula and that's
easy to do pick an arbitrary value is
represented mathematically
by pushing this button exit as
existential quantification pick a bTW in
you you know for which this formula is
true is true you make that formula true
only if there exists a B T and U for
which that formula is true and similarly
for this pick any P here is existential
quantification sometimes it's even
easier to say to pick an A is any
element of a set where you just write a
prime is an element of that set and so
on these expressions of U prime as a
function of U are easily written with
standard set notation operators and so
here is a t la plus formula and with the
initial predicate which I didn't get
around to writing precisely it's easy
enough to do and with this next state
relation you give it the TLA plus and
you can model check for example for all
of the set for all arrays and with four
different elements and you get it
correct or if you didn't get it correct
you're the model checker will produce an
error trace that tells you why it's
wrong and you can correct it if you
prefer pseudocode there's the plus cow
algorithm language which looks like a
toy programming language and the
algorithm appears as a comment in the
TLA plus module and it looks like a toy
programming language but an expression
can be any TLA plus expression you know
like that one I wrote for the next state
relation of the well no can't be
anything it can involve primes but you
can see I'm in basically any formula of
mathematics and it also has some
constructs for non-determinism for their
how you write pick any P in here it's
written with P and element of this
but and there's also a process statement
for talking about concurrency the
algorithm gets compiled to an
easy-to-understand TLA plus spec and
that's important because users can
actually read the TLA plus translation
to understand the + cow code Chris tells
me that's what the other people that
Amazon actually do if they don't
understand something about + Cal they
read the TLA plus and you've applied the
TLA plus tools which mean the model
checker and the prover and it's
important that you be able to understand
the translation because that's what
you're actually writing a mathematical
proof about now plus pal isn't is
expressive as TLA plus because code
isn't as expressive as mathematics
mathematics is fantastic so if you're
writing comp high level designs of
complex systems you you wanted you do it
in ela plus plus Cal is actually I find
you more convenient for sequential
algorithms and it's as bad as good as
TLA plus for you know what do you think
you'd call an algorithm like something
you might publish in a journal and
that's how I publish algorithms in plus
Cal these days and most readers are much
more comfortable with something that
looks like code rather than you know
mathematics frightens most computer
scientists sad but true
and plus Cal is also a good way to begin
writing specs okay but what about
specification and daily programming I
mean most you videos you know we don't
write quicksort very often most
programming is quite straightforward and
it requires little thinking and
therefore little writing simple informal
specs are good enough the code that
computes a function specified you to
specify what it does you use a function
and the simple rule of you know how
precise your spec should be is that the
spec should say
everything someone needs to know in
order to use that code so if somebody
shouldn't have to read the code to
figure out you know what it is that it's
doing because remember in two weeks
you'll just be another user you'll have
forgotten what it does and you don't
want to have to read the code to figure
out what it does
here's an example the typical Eclipse
method well what happens is you know
specifications in the real world if you
look up its spec it says it resets the
highlighted range of this text editor
and that sounds you know it's pretty
reasonable description of the spec and
it would actually be a perfectly fine
specification except for one little
thing
when does it get reset now some of us
naive people would say oh that means
that executing this procedure resets the
highlighted range nope I have no idea
when it gets set all I know is that when
I wanted to use it it was too late and
it's not when the method is executed the
method is executed it sets a bit
somewhere and something that happens
later on that I never have managed to
figure out causes it to actually changed
so if you really wanted to specify this
method you'd have to specify the larger
context in which the method operates and
there is no spec of that larger context
which probably means that no one is
thought very hard about that context
because remember if you haven't written
it
you haven't been really thinking and
like too much of the world's code it was
the product of evolution not intelligent
design and you know evolution is great
but we may not want to rot work you know
want to wait a few million years for our
programs to for all the bugs to be
worked out of our programs for code that
computes a function - specifying how it
does it you know you've written you
should you know you've written many
thousands of lines of code
you're all probably much better coders
than I am but how many lines above the
code level have you written
if you have problems writing a piece of
code you're not going to solve them by
coding harder you need to think harder
above the code level you know I just
can't emphasize this enough you know
it's it's quite obvious that if you're
you know if you well the only sorting
method you know is bubble sort then no
matter how great a coder you are you're
not going to come up with a very fast
sorting algorithm and coding harder and
you know learning you know becoming more
of expert coder isn't going to help you
well speed is just one dimension there
are other dimensions to programs in
particular things like elegance and
simplicity
and the the simplicity of a piece of
code comes from thinking about it above
the code level coding should be easy the
hard part should be you know the
thinking that goes on above them you
know getting the high level
specification of what it does right and
if you find coding to be hard then you
should stop coding and write a spec of
how the code should work for reactive
programs you know an informal specs from
almost everything we do in formal specs
are fine you write the at the level of
formalism at the level of the tail
that's appropriate for the problem but
when you're talking about reactive
programs ones that run forever and and
usually above concurrency things like
operating systems distributed systems
there are few people who can get them
right by just thinking and writing I'm
not one of them made me once upon a time
I was smart enough but not anymore
we need tools to check what we're doing
and for two
oles means you need a formal spec now
specification at university told that
about half of you are going to be you
know members of the university community
and university shouldn't just provide
job training it should be teaching you
how to think and the best aid to
rigorous thinking is mathematics no
systems are complicated enough
and so you don't want to have
complicated mathematics or some
complicated formula zaman top of it so
the math you use should be as standard
and as simple as possible tl a+ is my
best try at a formal language that meets
this goal it's not perfect it's not you
know the greatest thing around it's not
ideal for all applications but I think
it's a decent approximation to that so
find out more about TL A+ go to my
homepage and click on the TLA webpage
thank you
thanks very much Leslie what we do have
a bit of time for questions so far away
yes a randomize you'll pick an arbitrary
element in this set that's if you want
rent no he wants something like you know
how is you know randomize with a
particular distribution well remember I
said that what I'm talking about a
correctness properties a correctness
property is something that you can
determine whether it's whether it's
satisfied by looking at a single
behavior whether the choices you made
are randomly distributed you can't
determine by looking at a single
behavior if that is a choice of you know
made over many you know different
behaviors so talking about things like
randomness means you're out of the
domain of you know what I'm you know
quote correctness and so TL A+ might or
might not help you I don't know yeah
what's your take on the writing your
software and your specification same
language liking you doing Agatha or some
other language as I said code writing in
code is not a good way of thinking above
the code level and you know the goal of
writing programming languages is to you
know allow you know get you to be able
to write at a higher and higher level of
abstraction but we've still got a hell
of a long way to go between you know
what you can do in a real program in a
real programming language and the sort
of spec TL A+ spec of quicksort that I
wrote so you know until you know for my
lifetime we're going to need we're not
going to be able to be programming in
the same languages in the language in
languages in which we want to write our
special
occations yes in your description of you
to zombie right you then for example
check that mmm are non zero right so
that's the case where if they were you
wouldn't terminator
well next function still true making
mistakes in the spec we just didn't
think of an input well if I were well
first of all if I were to write a proof
and I have and you its you'll figure out
very quickly that you need the
assumptions that M&amp;amp;N or nine zero if I
were doing model checking and if I said
that like I said this is true for all
natural numbers what I would write is a
the algorithm in such a way that instead
of you know working for a single M and n
it would work for arbitrary natural
numbers and then so the initial
condition would say x and y are elements
of some number of our arbitrary natural
numbers and then to model check it what
I would do the model checker can't check
all data for all natural numbers
so I tell it to check it on some finite
set of numbers and what I would do is
give it I would I would be smart enough
to know that if it's that and realize
that zero is sort of a special natural
number so I would probably say we'll try
it for all numbers from 0 to 50 or
something and then it would come back
and tell me you know report an error for
for the initial values of one of them is
0 but no there's no you know we check
our specifications by you know sort of
testing them running testing that they
satisfied certain properties for example
I want to check the Euclid's algorithm
by checking that it in fact when it
stops x and y are in fact equal to the
GCD but as a specification is ultimately
a definition
and there's no notion of what it means
for you know no formal notion of what it
means for a definition to be correct so
you've got to work very hard to check
your specifications or your high level
designs by making sure that you know
they satisfied the properties that you
think they should and you can screw up
their there are no guarantees as I'd
like to say thinking does not guarantee
that you're not going to make any
mistakes on the other hand not thinking
pretty much guarantees that you will
make mistakes
we don't just execute something like
that it would be wonderful and I mean
it's a question they come and I get
every time I suppose I should have a
slide to address it and I think there
probably are DeMeo domains in which in
particular application domains which you
could write at a level at this as high
level as the TL A+ and you know generate
code from it on the other hand what you
have something like that you're going to
start writing more and more complicated
things and we saw using it as a
programming language and then what
you'll need is a specification of this
specification the higher level of it
well you still made a great position
because you can check you can use our
tools to check that 1tl a+ spec
implements a higher level et la plus
spec so yeah be in great situation
there are also ideas there are also ways
of checking that an implementation
satisfies the TLA plus spec and there's
been some work done and actually Sirdar
tessarin is there somewhere he could
tell you about some stuff that was done
at deck
a dozen or so years ago about that but
that hasn't had very heavy any terribly
serious industrial use that I know of
yeah in with state changes that come
from the outside world when you model a
system it's really incorrect to say that
you modeling a system if you look more
carefully what you're doing you're
modeling a universe that contains that
system and the other part of the
universe is the system's environment so
in order to specify the system you're
going to have to specify the environment
which means you're going to have to make
a model of what the environments
behavior which means you're going to
think very hard not just about what the
system does but about what the
environment does and if you're building
this piece of this whatever it is for
somebody else then that somebody else
will need to tell you what the
environment is going to do and you need
to show you more her the specification
in of the environment to make sure that
that in fact agrees with you know with
what the system the environment that
system is really going to going to
encounter
so you're specifying the environment
along with the system yeah usually have
formal language than the metal language
that you're reasoning about it with and
typically the latter is more powerful
than the former so if you want to reason
about boolean logic you might use
first-order logic first order logic
second-order logic but you seem to be
advocating the inversion of that here if
I'm reading it correctly and I'm
wondering if you think there's something
fundamental about that or it has more to
do with just sort of human cognition in
programming well I don't understand why
I'm inverting it I'm reasoning about
things
that are written in very impoverished
languages like C in terms of mathematics
which is you know infinitely more
expressive than C so I'm seem to be
doing exactly the same thing the
complexity measure
yeah when mathematicians mathematicians
are not concerned with the complexity of
things I mean their reasoning about
boolean logic in terms of you know
first-order logic or something you know
that they don't think about you know is
this going to work if my formulas are
400 lines long usually several years ago
I was involved in the de sel for project
which was a project to formally verify a
reasonably large system about 10,000
lines of code and from that experience I
took away two points the first was that
the majority of the effort went into
taking the formal spec and showing that
the C was actually implemented at formal
spec and I had all sorts of tricks that
they went through to do that but
ultimately it took tens of man years to
do that job secondly during this process
what we found was even though you had
some kind of higher level specification
that wasn't C code ultimately once you
got to a reasonable size of system the
specification was too complicated to
understand anyway and a lot of things
came up
looked like bugs but actually were
misunderstandings with the formal
specification so I guess my my question
to you is what comments you have on
using you sorts of things at real scale
rather than a sort of toy scale where
these sorts of things don't matter
I think Amazon Web Services which deal
with something like I forget the numbers
but I think they have something like 10
to the 10th objects with 10 to the 6th
operations per second being
formed by them and their systems I would
say that that's a pretty real system and
I don't have any magic bullets for
verifying correctness at the code level
what I'm talking about is reasoning
above the code level now you get some
people to say that the well if I can
actually verify the code what's the
point of writing this high-level
specification which is precisely like
saying if I can't verify that what the
Carpenters has done is the exact thing
that's in blueprint what's the what good
is a blueprint if you think about that
for a while I think you will start
understanding why you know even though
those Amazon people you know don't even
think about any kind of automatic
generation of code why they spend a lot
of time a lot of effort writing their
TLA plus specs so yeah verifying down to
the code level you know is a you know a
serious problem and fortunately very few
people have to do it and you know be
great when you know more Pete you know
when it becomes economically feasible
for the kinds of things that you know
Amazon and Microsoft you know build but
that's you know not what I'm here to
tell you how to do you know I suspect
that it will help you you know in
simplifying your designs above the level
at which you're going to verify the your
C code but ultimately you know I can't
tell you how to verify your C code time
for one last question
pizza your take on the kind of situation
where the programmer doesn't know what
their code
it's common in startups so you have a
vague idea
you need to make various random
decisions in making your code and then
you put it in front of users and you
inner and you get an idea and you go
through iterations and only by iterating
with the users to get an idea what your
what your code should do would you
recommend that they specify early or
late well there are there are two sides
to that question one is that you're
trying to do something and you don't
know what it should do because there are
facts that you don't know and you need
to perform experiments to learn those
facts and what you should do is you'll
build one and throw it away and in fact
you know this is something I do all the
time the you know you stuff like eclipse
which is undocumented so what I have to
do is you know write a bunch of code to
see whether you know whether I can do
something before I try to do it and what
I try to do is write little bits of code
and you know make it as simple as
possible and then you know just forget
that not use that code and you know
start again when you know that one once
I know what I can do then I you know I
recode starting from the top down
starting from the specification very
recently or not somewhat recently I had
that problem of you know where I didn't
know what I could do in terms of getting
something displayed and I figured out
that the easiest way of doing it was to
write some fairly simple functionality
of the thing I was doing and and and
then using that as my mechanism to
seeing you know if I could get Eclipse
to do
and I made the mistake of saying oh I
finally got this to work so I wasn't
gonna write rewrite it I would just
enhance this code that I you know I
wrote and make it do you know what I
thought it did you know it should do
well what I found is that code was that
that particular functionality that I'd
implemented was you know even more
useful and I thought it was and I want
to enhance it and go do further but the
code that I have because it was written
in this you know evolutionary style is
impossible to deal with and I'm gonna
have to start from scratch now to redo
the whole thing in order to implement
that new functionality so the you know
there's what you should do and you know
none of us are perfect but the other
thing is that there's the other argument
that says that well there's something
you know that's a that the idea is that
you know it's hard to say what this is
supposed to do it's supposed to be
simple or it's supposed to you know have
a nice user interface and you know you
can't specify your nice user interfaces
you know what it's supposed to do it's
fuzzy so we shouldn't be specifying it
well remember specifying something is
your way of thinking about it and you
know if you don't know exactly what it's
supposed to do that's not an excuse for
not thinking that means you have to
think even harder and that means that
writing a specification is even more
important so you write the specification
to help yourself decide what what this
your fuzzy idea you try to take this
fuzzy idea you have of what it should do
and make it precise enough that you can
simply code it and work out the problems
you know in the design not in the code
and I have a wonderful example of
something I did that for the
printer 40 la plus and that's a
different lecture but yeah I mean this
is you know I'm not telling you anything
you know to do anything that I don't do
myself and and I really want to get the
idea that I'm you know don't get the
idea that I'm telling you you should be
using TL A+ in about you know 10 or so
years of what programming I've done I've
used TL a plus or plus Cal about a
half-dozen times because I encountered
problems in programming that were subtle
enough or difficult enough that I needed
to use write a formal specification to
make sure I got them right but most of
the time you know that other 95% I just
write things in English or mathematics
or whatever and it all goes in comments
so you can look at my code and you'll
see that there are more comments than
there than there is code because I
specify things before I code them well
I'd like to invite all of you in the
audience to come and express your
congratulations to Leslie on his Turing
award in liquid form outside and in the
meantime Leslie thank you so much for a
classic
each year Microsoft Research hosts
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>