<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Testing Atomicity of Composed Concurrent Operations &amp; Automatic Fine-Grain Locking | Coder Coacher - Coaching Coders</title><meta content="Testing Atomicity of Composed Concurrent Operations &amp; Automatic Fine-Grain Locking - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Testing Atomicity of Composed Concurrent Operations &amp; Automatic Fine-Grain Locking</b></h2><h5 class="post__date">2016-07-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Pm_LgfZ2KLM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
it's my pleasure today to have two
speakers we have a HOD and guy and
they're going down to slot this week to
give talks at splash at the tech- blah
the technical track of a splash and
they're giving us a little preview today
oh ha shaham is a PhD student at tel
aviv university under the supervision of
mullah Sahib who's here visiting a
neuron yehovah at the Technion his PhD
dissertation addresses questions of
checking atomicity of concurrent
collection operations in prior to his
thesis he worked at IBM Haifa research
group on Hardware verification goggle
anglo at the who's sitting in the in the
audience here is a PhD student also at
Tel Aviv University under also the
supervision of muli and Iran and he's
interested in various aspects of
concurrency in the past he was a
software architect on several software
projects and was responsible for the
design and development of many high
performance critical systems so we
welcome them here today in ohad we'll
get started and then we'll hear from God
okay all right thank you very much tom
ok so I'll present the work testing us
to my city of composed concurrent
operation it is a joint work with the
Nathan Bronson Alex I can Melissa give
more invasive and run yards ok so
writing concurrent data structure is
held therefore we were lucky that modern
programming language provide us with a
library of concurrent data structure and
we can use this library using an
interface don't is that each one of the
operation of the interface is atomic the
problem is that that in many cases this
interface is not enough and the user
need to write a new operation compose a
few operation of the interface and we
know that each one of this operation is
atomic however we don't know whether
this composed operation is atomic so the
question is how can we test atomicity of
this composed operation
so here here we have an example of about
we found in apache tomcat in tomcat
version 5 they have an attribute a map
attribute that maps from a name of an
attribute to the object of the
attributes and they allocated a
sequential ash map and also have a
function remove attributes that gets a
name and name of an attributes and what
it does it first it's hold the global
log of a of a TTR then i check whether
the attributes in inside the collection
and in case does it does it gets the
attribute object remove it from the
collection and return it and otherwise
it just returns now ok so the
environment of this function for us to
maintain is that remove attributes which
change the value which we move from the
collection or now so what they did in
Concord version 6 they say okay we have
a concurrent hashmap a concurrent
collection so let's go a location
concurrent hashmap and we know that each
one of these that each one of this
operation is the stomach so they just
went and remove this lock ok and of
course this break the invariant and
let's see an example of a sexy of an
executing the choke to the environment
environment does not hold we start
running remove attribute with any input
string a and it's a sign to Val now and
then we have some concurrent execution
by a different thread that goes and does
a put operation with the same with it
with an input key a and an object oh and
then remove at least continue running it
checks whether a is inside the
collection and of course it does because
it was added in here so it enters the
branch and it's get the object oh that
was added in here and before we have a
removal / asian we have some other
thread just comes and does the
concurrent remove operation to the same
input key a and then remove attributes
continue
running here it tries to remove a but it
fails because it was already removing
here so it contains running we choose
one and the valid returns is the Val
that it's reg in here which is oh okay
so actually this function run it didn't
remove anything and if we turn on it is
as if this is the value that was removed
nitin of course it violates d the
invariant so by atomicity in this work I
mean linearize ability and by the
usability I mean that given a concurrent
execution as the one that you can see in
here we say that this execution is
linearized able if there exists a
sequential execution built by this
operation the remove attribute put and
remove such that each operation it is in
this concurrent execution the result of
ease of operation this concurrent
execution is equivalent to its
corresponding operation in the
sequential execution and if I'm looking
at this concurrent execution then as we
said before we move attribute returns oh
you can see that put in here returns now
because this is the first operation
right in here the collection is empty
therefore it returns now and remove
returns 0 because this is the value that
was added in here so what I want to do
now i want to check whether there exists
a sequential execution such that every
operation is day concurrent execution
has the same return value as in the
sequential execution so actually we have
your three options the first one first
do a put then a remove and at the end
run remove as you wish and you can see
that put as before returns now because
this is the first operation remove
returns 0 because it runs just after
book after book after the foot however
when I'm running here remove attributes
you can see that in this point the
collection is empty because I added the
key a and then I removed it so it runs
any just returned now unlike it is in
here so this is not
the equivalent equation execution in
here we first run remove attributes and
again it returns now because this is the
first that's running in the collection
is empty so it's not the equivalence one
and in here we first one put and then
remove attribute and see you can see
that remove attributes in here returns o
as in here however the remove that we
run at the end returns now because this
remove a operation from remove
attributes already remove this a day
daqui a therefore the collection is
emptying and operation returns now okay
therefore this concurrent execution is
nothing is nonlinear I zabal okay we
didn't sign any sequential education
that equivalent to this concurrent
execution okay so what you want to do
here is testing the usability of this
composed operation previously we wanted
to check the atomicity by atomicity we
mean linearize ability so in the
previous slide sorry so when you say
sequential you really mean for spring or
leave it so here you I mean here you
still look up if I think a sequential I
think of the first two columns the third
one you actually have some concurrency
right i mean in the sense that your
interleaving the execution the full
execution but it's sequential in the
sense that you you execute the methods
completely
but but it still it's still has some
aspect of concurrency I mean in the
granularity of the operation yes yeah
around in the gonna notification I have
the operation then another one and then
another one's operations are not
preempted yeah a person of the threads
can be created okay yeah what happens to
your definition if remove doesn't tell
you whether it succeeds or whatever you
need they're terrible
operation or
okay so what you want to do with it
wanna test the ability of this composer
operation okay so look at this dress as
we saw before it's look very easy to
understand why we have a violation ow
however reconstructing this in tomcat is
extremely challenging ok tom cat is a
huge program we have a large races a
large number of traces and this
violation occurs only because we have
this remove operation that works on the
key a and occurs between this gate
operation and this remove operation that
works on the same key right we read here
the value and before we remove it
someone else came and remove it ok and
this thread into leaving this bed in the
living is very very little because we
need somehow that the program will do a
remove oppression between these two
three of them should walk on the same
key is very very hard to reconstruct
this operation so our solution has three
phases the first phase wheels modularity
we actually chop discomposed operation
out of the program and we test it in an
environment that does arbitrary
collection operation of course this is
an abstraction and it generates simple
traces it can of course it may of course
generate false alarms violation which
are not feasible in the client and it
also helped us the molality to control
the environment now we control the
environment we can do any operation that
we want in the environment and we can do
today we can direct it and do some
partial order reduction the second thing
is after we generated so many traces we
used analyze ability of the best
collection we have a guarantee from the
library that each one of operation the
operation is realizable therefore we can
execute the operation of the collection
and sequentially we do not need to
overlap them because we know that they
are linearize about so this restrict
some of the choices that we generated in
here and the last thing we use the
influence specification of the library
instance is similar to the noncom and
noncompetitive ET and we use this
information in order to further restrict
the traces that we generate a later one
I see I also what we how we use it in
what we mean okay so first module of
checking as i said we test will take
this composite resin we chop it out of
the program and we test it in an
environment the does operation on the
collection between any two operation of
the composer operation we could do any
operation of the environment that we
want to do hey this is of course it said
an obstruction it made general forum
however a we argue that the violation
that we found even though are not are
not feasible in the client fixing this
violation medical with the codon zillion
for future changes because if for
example this bug is currently not
feasible then in two different someone
can remove the lock in another part of a
program or add some remove operation and
this bub bug can pop up and later on
you'll see that this is something which
is backed up by our user experience that
some of the bugs we found were not
feasible on the client but even though
we reported we reported them to the
developer technologies and bugs and fix
them so you should have some serious
theorem at least well maybe there are
the strong but you would hope that the
sort of bugs you find here are super set
of what would happen hand okay
given.if your environment if your
modular and environment abstraction is a
separate right that that you'll that
you'll get a you'll bow in the set of
errors due to misuse you know I thought
those different lot to me
and later on I'll talk about some some
way we use it to prove but yeah
okay so first as I said we do a modular
checking so what we want to do we want
to test this arena is ability of
discomposed operation in a modular
fashion okay so actually what we can do
we just run the program in a testing
method we run to remove attributes with
some random inputs there might be an
environment operation that doesn't
influence the control to compose
operation some doesn't influence the
control of the compose operation but
then it's running and running and
running and it doesn't find any bugs
because still it's generators whoa okay
i'll link with the computer it's there
are so many tracers that we can explore
in here and at the end when it
eventually found a bug we look at the
test in or this one which one being here
we can look at this price and you can
see as I said before the reason that we
found this bug is that this remove
operation influence the result of this
remove operation because this remove
regime removed the key a before this
will move operation this human operation
failed to remove our so we are failed to
remove our and therefore we discovered
the violation so and so what we actually
do we further restricted the environment
to do operation only operation that will
influence the next to come operation of
the composed operation okay in here for
example before contain ski I can do a
put that will make contain citty to
return true in instead of false in here
remove will make this remove to fail and
so on I'm we're sticking to environment
this is a partial order reduction I'm
sort of a partial reduction okay that's
very much
is anything as in here and a 40 this
anomaly only and you have you you're not
analyzing statically right you're just
so you're doing elected by my party in
Aruba yeah no a novelty when when
the program is running between meq
operation I can have an environment up
raishin so when I get to this to this
step I know what my state and all the
state of the collection and I know the
semantics i could get the semantics of
the library to support the inference
notification of the library I have this
specification I assume that someone
provided it to me that you should use
the same key because exam exactly
because it's a map you know that you
should use the same key and if currently
in this state in this day I know that
that the collection is not empty and it
has a the key a inside so i will remove
otherwise if it would be empty i can do
a poet or so okay something which is
dynamically it's depend on the state of
the collection in each state each moment
okay so let's see a running example here
we have removed attributes as we saw
until now and we have here the execution
itself and here you can see the code the
code that were currently executing so we
start running attributes with the key a
and we assign to value now and now
before we have this content ski we ask
the environment do you want to do an
operation that will influence this
contain key it's something which happens
dynamically in this case the environment
decided he doesn't want to do and the
collection is currently empty so the
environment does a put operation it it's
insert the key a and the value 0 to the
collection and then remove attributes
continue running and now contain scheme
will return true because a was already
added to the collection in here so we
continue running we we enter the branch
and before we have this yet again we ask
the environment you want to do an
operation that will influence this
sketch and in this case the environment
decide that he doesn't want to do so we
continue running we do a get
that reads the value oh and insert 21
and now again before we move we as the
environment you want to do an operation
that will influence we move at the
environment does remove with the same
key and of course it will influence the
result of this remove and we continue
running the remove failed and at the end
which returns oh okay now as we saw
before we go and we check all the
possible executions and see whether
there exists an equivalence not one and
if no we report a violation okay so just
one thing as you can see when we got
these trace from the from the firm our
to take you can see that this race is
very very concise it's not a lot of
trace of a program the trans men is red
and it's very hard to analyze the bug
it's very very easy we have the
compulsive region we have once in a
while some small invite operation then
it's very very easy all the cases that
we got it was very easy to see why the
bug occurs and to analyze them ok so we
implemented this technique in a tool
named coat and it gets as an input
program and a library specification
which are moved to the composer / asian
extraction fixed I'm told this is a
simple static analysis that goes and
just a look for composed operation and
what after it does it moved to the user
back this candidate control operation
and the reason is that that in many
cases this compilation built inside of
function but in some cases the user
instead instead of writing a function
that implementing operation just write
this composer presence out inside of a
large metal so in some of the cases they
need to manually compose disk internal
friction and then it moved to the vital
instrumentation together with some
driver that runs the function and a
driver that does the influence
notification that your environment is
and this of course afterwards we run it
neither either getting on your
instability result over time out okay
because it's a testing tool okay so
let's see our benchmark so we as I said
we use these simple static analysis to
extract the composite present in ninety
percent of the cases the composed
operation was part of a large method so
when we manually mean needed to chop it
out and to read it hey we extracted 112
composed operation out of 55 application
all of them will compose operation and
from real application as Apache Tomcat
Cassandra a festa stranded and so on for
each one of the application we extracted
all the compost operation and we analyze
all of them and we didn't find any
additional composer operation we try to
use google code coders and other search
engines to see whether we can find
newcomb any additional preparation and
this is all we found so after we had
this 100 proof co-composer Persian you
say okay we don't know whether these are
linearize about yeah
hmm the only found to compose a bridge
for application yeah yeah another year
just because these were actually well
written and they come
compose the light which is powerful not
so that you need the atomic approach to
the library
all these are actually using some
libraries all these are concurrent hash
maps so it's the same libraries I don't
really understand how you sort of
figured out whether or not there's other
proposal versions that you missed
because you have to know the semantics
of
remember there's some things
no actually we define we you see whether
there is an operation that try to access
a few operation of the library Oh a
single the thing I method is modern
museum but if they I mean it could be
bugs network where they have composed
operations hidden because they use other
copper methods that we did this fiber
exchange with mr. we would try to we try
to find we didn't find any of these but
the might be a case with me such but we
also try to find these kinds and we
didn't most of these composer / asian
actually didn't have additional method
that the car died a call during the run
so but it might be casted yeah that's
true and okay so after finding these 112
compose operation you say okay let's see
whether it is undeniable or not so we
ran cold any terminated on each one of
and it said that 59 are nonlinear
risible and for each one of them it
terminated in like a second or so and
and if you gave a trash and everything
at 33 you just timeout after a while and
didn't say anything you say okay so we
know that 59 I really know your are not
advisable but does it really not
advisable or there are the non advisable
only due to open environment okay oh the
obstruction with so we check it out and
we saw that 17 17 are not advisable only
cute wanna environment and 42 an onion
risible in the client in themselves and
for each one of them we wrote a fix and
we reported them to the developers of
the tool and many of them were already
fixed and acknowledge is violation and
many of these acknowledges violations as
well and also were fixed yeah
you actually find the real
counterexample
look you instantly we were managed to
construct but none of them in many cases
we gotta fix back from the user and in
some of the cases that we were not sure
we look whether they're their existing
whether there exists an operation that
that can occur in and can occur and
create a violation so okay but but in in
all the case we just go ahead and
acknowledge from the user okay so okay
so afterwards we said okay we know that
first 453 we got the timer is also let's
see whether it is earning risible or not
so we checked them manually and we saw
the 27 of them only in risible we were
managed to prove them and realisable and
36 as global which means our naughty
capsulated and there are not do not have
only the collection itself as a global
they also have some other operate or
other variables and this variable
controls the value discompose operation
insert to the to the collection during
the run and if will augment the
environment that instead of doing only
operation of the collection that it will
do a only operation on the global
assembly will change the value then we
can generate traces to show that these
are non risible as well so overall the
of the 112 compose operation we actually
found it 85 or non in risible
none they either I guess that the one
that didn't respond I guess this was the
case all the one that responded was many
of them then said tanks that work
nozzles bug no in ink etc for example
they responded to say oh this bug is
currently not feasible dick because we
move can happen only when when the
program terminate and it's not probably
anymore however we'll fix it because we
we plan to do changes who technology
this as a bug this can pop up in the
future but I guess the one the deer is
gone ok so 85 of these are not inaudible
and 27 are not iron in our high school
is everything ok we found many bugs many
real evolution made real violation and
it was very easy to detect them and we
only use the enzyme specification of the
rivalry for example I mean if we have
some some branch which is depend on the
value to check if the value is equal to
40 42 then go and do some violation this
is something that we would miss but then
looking at at this composer operation we
thought that these are very generic mean
they get some input they use it inside
the collection they do not have any
branch of the input and also when they
got some return value from the
collection of Persian the only branch
that they do is whether it's some key is
inside the collection or if it doesn't
inside the collection we also do they
have some remove again so that we
checked to check if the value is equal
to null or different in our weather it
doesn't check some specific value so we
define the notion of data independent
and informally that independence means
that a compilation is that independent
if the only global is the collection
itself if the input key in the if the
input is used only as the key in the
collection operation and if the branch
is all the branches in the composer
Persian and only based on the result of
the collection and
check whether the key is inside the
collection or not and we use this notion
to show that very fine to miss a
gleaners ability of this data
independent composer present is
decidable when the local state is
bounded okay and the reason is that if I
know that a collection a composer
operation is done independent then I
know that if there exists if a bug a
violation exist for a same thinking then
a bug is it for each key okay so
actually I need to check it out only a
single input key I'm doing some
small-boned deduction around only on a
single input key and also know that this
is the single input key and I know that
it is that an independent so basically I
know that the compose operation will it
most add one value to the collection the
value can be at most dependent on this
single input key the value that is
calculated so actually the composer /
asian can insert one key with only one
volume to the collection and if I'm
looking at the inference specification I
know that if the operation that
influence an operation of the composer
operation that used the single input key
will use the same single input key and
when I want to do an influence I need to
write some different value but any
different value because that independent
it will not branch on this value so
actually these bounds the number of
elements that I can have in the map
because I either had this key in this
value or this key and the value that
added by the environment or the map
would be empty okay so we did some small
model reduction and we explore all the
possible execution we using one input
key and influence environment that uses
a single input value okay and and then
afterwards after we did that we said
okay let's go back to our composure
pressure and see how many of them of
really data independent so in here SC
m means that they are data independent
is single it's single time concurrent
map they can use be verified using
single key FCM is some some extended
class of this that they can be verified
using a fixed set of keys for example if
I have an input and at the beginning I
have if key equals now do that otherwise
do that so I can check it using an input
now or or any other input and these are
data dependence so you can see that out
of the one has 12 compose oppression a
lot of them are jetted data dependent so
it was quite and we were not quite a
happy but that then we look at these
data dependence and we saw that out of
these 60 of them has Global's they are
not encapsulated and as I said before
this global I'll control the value to
the composer operation add to the
collection Saudis are not realizable and
we also have four that are none
advisable and one which is in risible
this is the one that we missed you want
that we missed so so overall we ran the
tool and we were able to do to verify
all these data independent composer
operation and the ones that are buggy we
afterwards we manually fix them and we
were able to verify them as well it's
correct okay so this is the flow of the
tool the extended flow as before the a
user provides the program the program
and delivery specification to the
composer operation which generate a
candidate compose depression and move to
the user and then this composer Persian
can verify to beat data independent we
didn't implement this part but it's we
have a very simple syntactic rules that
most of these is composed operation
satisfied they're very very simple they
don't have any aliasing or something
like that very very simple and this is
this is in case of that they are data
independent to move to the user and we
then we it moved it is modern family
generated and we run spin and get either
your ability result another not known
where in the builders oh and in case
that it is not an independent then as
before we have this flow to just run
testing and try to find bugs okay so the
overall result of the tool is that it
finds 42 violation which are known in
risible in d in the client 17 are non li
risible only in open environment a 26
out of Global's and therefore has
Global's and therefore none in risible
and it was able to prove using the small
model reduction that I said 26 that a 26
that aren't advisable and one we missed
this was summarized a writing concurrent
data structure is hot and also we saw
that employing this atomic library a
operation is open so for what we did in
here we use modular linearize ability
checking and leverage influence
specification and that independent in
order to find violation or prove their
eligibility of this composer operation
and we see that we found some sweet spot
because we identify important bugs and
for each one of them we provide advice
that not only showing the bug but also
explaining the bug as i said before this
bug this races are very very concise
it's very very easy to understand them
and to afterwards and afterwards fix the
composer operation accordingly and
otherwise it was very hard to find these
bugs while running the program and we
also proved a certain as ability of
several compose operation and this is a
simple and efficient technique that's it
thank you
a I represent the volcano timati k
buying and locking using a shop shape
shape of this which is a joint walk with
an atan bonds on a Alex I cleaner
Melinda me Melissa give in the onion a
concurrent data structures concurrent
data structures I widely used in many
software systems and in this work we
deal with synchronization automatic
synchronization for concurrent data
structures it's simply in a simple way
to implement the synchronization for
concurrent data structures is to use the
Corsican locking the common example can
be seen the lock that protects the
entire data structure the good thing
about such a synchronization is that it
is easy to implement and understand such
looking but debated betting is that it
is provides very limited the concurrency
and usually a provides a inefficient and
conquer inefficient it is not efficient
enough in many applications another way
is to use the fang and locking a thang a
locking usually provides a degree of
concurrency but the problem with finding
locking is that it is a very out to
understand and implement such locking so
in this walk what we want to do and we
did is to automatically edifying and
looking to data structure without
synchronization and we want to be able
to end the recursive data structures
like a recursive trees and recursive
list so our goal is to take code without
any synchronization and automatically
create an equivalent code with fine girl
okay
we want to create there are many ways to
create hang and locking so in this world
what we want to do is to create finding
locking in which each type object as its
unlock so if this is the data structure
and n1 is an object we want and one to
have its own object and all the other
object F a we want them to have their
own a look we also want that a lock will
only add white necessary so if for
example 20 a old some locks we want it
to be able to release locks as soon as
possible so other threads like 30 prime
will also be able to simultaneously work
on the same data structure and by doing
that by doing this we want many threads
to work on the same and data structure
together so in this work we show we
method to add such a such fine green
lock in by using a simple asos a
translation sort of salsa translation
and the method uses the simple static
analysis and because part of the method
is dynamic and because of that the
method is able to handle cases that are
usually add for static analysis the main
idea of the method is to rely on the
shape of shared memory for to listen for
the synchronization so the metal itself
is not applicable in any case it is
applicable when the shell shape can be
seen as a dynamic forest as the force
that is dynamically changed so so if we
are given a code it may be a complicated
code the method doesn't really need to
understand the details of the code the
method relies on the fact that at the
beginning of each operation of the data
structure the shape of the data
structure is the forest because we rely
on only on the beginning of each
operation during the operation the shape
can be changed it can be arbitrary shape
it can be a cycle as long as at the
beginning of each operation the shape is
a forest this this is in this case this
is the code of a balanced sensory so
this is the tree is a false hope this is
okay so in the walk we have two parts we
first they show a new locking protocol a
we call it a domination locking which is
a locking protocol for synchronization
of a dynamic capes and it is it is a
generalization of several other non
locking protocols like the end of the
rent locking and dynamic deadlocking and
in the second part we use this protocol
we a show our method to edifying and
locking by enforcing a determination of
locking protocol and we show that the
method is able to enter changing cases
for example the metal disabled to a
defective fiying and looking to some
implementations of red black trees so I
start with the domination locking
protocol a in this protocol what we want
to do is to leverage the fact that in
well type organs like a Java programs
there is a restricted way to access a
object so if for example where a thread
and the stack only as pointers to the
root of the data structure to n1 then if
you want to act century we have to first
access n2 so we want to use this and to
do this we distinguish between two types
of objects first type is exposed object
and the first and the second type is
Eden object exposed object of the root
odds of the data structures and when in
operation begins it may only point to
expose object eating objects are the
other objects and they may be reachable
from the expose object so we want to use
this and we want to use the idea of
domination we say we say in the
definition of the protocol that 20
dominates object you if all the parts
from exposed object to object to a ever
look that is locked by 30 so in this
example we have to expose object a 1 and
E 2 and we have treated it as a lock on
h4 we know because of that the T
dominate h4 h5 because all parts from
the exposed object to this to object are
protected by this lock
we also we also know that tea does not
dominate h3 because there is a path with
without any lock that is all by 30 the
bottle itself is a three holes the first
rule is needed to protect the access to
object in size the thread can access
object only when it alters the object
look so if this is the data structure
then 30s toward the lock in order to
access a one the second would say is
that thread can lock it an object you
only when it dominates the object so in
this example the lady can can lock h2
because it dominate it dominates H to
the domination locking protocol allows
alien look so if we will if 30 it wants
to release the lock from a 1 it is able
to release the lock so other threads
will be able to access the same data
structure also the protocol can enter
cycles so if for example we have a cycle
as in this case then the 20 is able to
locate to you because it dominates h3a
also the protocol allows the above to
dynamically changed as long as the woods
are satisfied so it is ok that during
the work of total directly will change
that will change the graph create new
object and change their pointers of a
debuff a the total of the domination
locking protocol is needed for exposed
object and for this for this part we use
the simple variant of two phase locking
that a voice deadlox so if we have such
kind of data structure we use a variant
of two phase locking for the Expos
objects and for the hidden object we use
a first tools of the domination of the
protocol
what we show in the work that the
domination blocking protocol govern the
atomicity of the operation before the
poisonous a4a follow the protocol but we
also showed that it is only it is only
needed to consider sequential executions
so if we know that every sequential
execution if all the execution with a
single thread satisfy the protocol then
we know that other operations are atomic
I mean linear linear izybelle so if we
have the code it is enough to think
about the sequential execution in order
if we want to use the port o call in
order in order to use it to enforce a
atomicity so we have a protocol we know
it is enough to think about sequential
executions but still the code may be
complicated and now we want a way to an
automatically enforced at the protocol
we could do it manually of course but
the second part we show up to do it
automatically so how to do this a ok for
this we have our automatic a method and
as I said at the beginning that the
amount of these works only in some cases
it works if we know that the shape of
the data structure is a dynamic forest
and the definition is that in every
sequential execution never execution
with a single type the shape is the
force at the beginning and the end of
each operation of the data structure so
if we have a data structure that is
composed from to a list for example this
a kind of data structure it is ok this
is a forest it is located such data
structure will have an operation that
they change the Garfield for example
moves h3 foam least a 2 least a be such
a potion will violate the forest during
the operation this is not a forest but
this is a careful first base data
structure as long as at the end of each
such operation the shape will be forced
so our way the mental block the method
works in two steps in the first steps it
ed code that collects a runtime
information and in the second step a
step it could it adds locking that uses
the runtime information
folder looking so they fell in the first
steps the idea is to use to add to
evidence counters a similar to the
garbage collection a reference counters
and we had the stack reference counter
that comes number of reference from a
private memory foam stick to a object
and we add a preference counter that
comes number of incoming pointers from a
key object to a de caliente object and
we had the code that manages or lay the
relevant a things that they in the code
that manages the reference counters in
the code so if this is our state for
example h4 is a pointer formstack so it
stuck reference counter is one a h2 is
any preference counter is zero because
there is no pointer is for me eep object
and eh two is two pointers from it
objects and stack up a big because of
this tacky it's a preference counter is
too and it's that reference counting
zero because there is no pointer
formstack so i will use the reference
counters what we do is very simple thing
we lock object when we see that it's it
counter it's a counter become becomes
positive so as long as an object is
pointed by a by by thread the thread
acquires it a block of the object and we
unlock object when its stack counter
becomes 0 and 0 and a the object itself
is not part of a forest violation
because we want to enter the violations
of the forest and we can see this easily
by looking at the hip counter so and we
have another thing that in some
operations we may have an operation that
works on a few objects and at the
beginning the star counter of both of
them is is one we want to lock them
without leading to deadlock so what we
do is to lock them in a fixed order so
we can for example take the address s
and lock them according the order of the
addresses we know that we can identify
them statically
at the beginning of the operation so if
we follow these two steps then we create
a data structure with find and locking
and that follows domination looking so
in the work we we wanted to understand
when to evaluate the method by adding
Fang and locking to several data
structures and we did it for two
balanced search trees for a trip which
is a balanced search tree that uses the
randomization randomization and we added
the fang and looking to red black tree
we top down a rebalancing without any
parent pointers and we also did it for
self adjusting hip skip and for two
specialized a data structures and we did
and a in a up your application in the
bells about Santa algorithm and we
checked the you evaluate the result in
the context of the application themself
and according the runtime experiments
the results say we're quite good we show
a good scalability although we we could
use many optimizations because we used
it we used a very simple-looking we
could only we could optimize the locking
in many many ways we didn't do it we
just tested the pure metal and the end
without any optimization the results
seem to be a good in some cases we
evaluated the effect they were looking
we compared the low key to manually to
manual thing and locking here we have a
graph of the that compels the manual
thank and locking to automatic bank and
locking we have also a trip where this
is Agathe related to trip we have a
single lock and here we have manual
family lock invest our automatic locking
the results were almost equivalent a not
in all cases the result or equivalent
but in many cases we saw that manual and
then automatic is the same in one case
we haven't we even found a end over end
locking in the original application in
the app your application and we compared
the original a
and violent looking to the automatic a
two-hour automatic method and we show
when we saw that they look at the bottom
metals are equivalent but in one case
here our automatic method provides a
better way to put it was surprising but
this was the result okay a summary in
the work we show a newfangled Okung
protocol for dynamic hips and we show an
automatic way to a application for the
protocol which isn'ta matic way to a
advantage locking by relying on the
shape of a data structure and we show a
preliminary performance evaluation for
this implementation and thank you
so you do a shape analysis then of the
method assuming that you're a forest and
do some static analysis or you just do
the runtime check to see
in I could use the wine time check but I
didn't do it what what he did is to the
I the Polo male say that this is the
force base data structure and then I
applied the method so there is no shape
analysis we're going on your static
no I see so so basically i assert and
then the analysis sort of just believes
that it's going to be a forest yes
that's but you do have some dynamic
check you said you checked on my plate
a preference killed yes I kucik
dynamically that every the first time I
yes I see an object they preference
counter is la is what is one so and so I
could identify a violation of the force
but yeah I didn't I didn't do it because
I knew that the data structures are a
force base
so the instrumentation you have to add
to keep track of the
stack references and repeat preferences
is that restricted to the data structure
actually using the Sun so you don't have
to go
he sees on restricted to the death
structure it has to be restricted to
that structure because I don't want to
be affected by external pointers want to
ignore me so I mean you can check that
for example the internal nodes
orchestras don't escape into the as I
assumed if they all the objects uncap
selecting that star changes okay thank
you can</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>