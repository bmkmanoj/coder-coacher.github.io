<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Exploiting Energy-Aware Programming to Build Energy-Efficient System Software | Coder Coacher - Coaching Coders</title><meta content="Exploiting Energy-Aware Programming to Build Energy-Efficient System Software - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Exploiting Energy-Aware Programming to Build Energy-Efficient System Software</b></h2><h5 class="post__date">2016-06-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/t46IVxRID7Q" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
welcome to my talk okay I want to spend
a few words on our crew before i head
over to the tongue actually so we are a
system software crew but FAU which is
not the florida atlantic university but
the fish alexander university but that's
still a long am not able to fit on any
badge so we do two things in our group
we do operating system research and
distributed system research and in
addition to that we have a couple of
people like for PhD candidates working
also on energy efficient systems up
there and i'll go to date on our latest
research i will first have a
introduction into energy where systems
in general and then i will give a
presentation i will be giving and sunday
at trials I think andrew has also paper
on trials you don't have a backup for
that talk ok all right ok so to motivate
my talk I want to talk about to mobile
computing systems actually the first
mobile computing system on the planet
it's Osborne one it was released back in
nineteen eighty and i was wondering ok
what has changed in those 30 years since
we got the first computing system yes
our what's about level oh it was the
first mobile computing system at least
at least it was advertised at such a
clear was advertised to be the first
computer which fits beneath the front
seat in a plane so that what that's what
it made it mobile it wasn't so practical
to use we will see that in a second but
what did you think about what would have
been the first mobile system
okay right yeah probably it's the first
one which was generally available to the
public okay so if we look at the Technic
technological progress over the last
thirty years we can see that we did
pretty well regards to a few technical
things like network speed which has
increased by a factor of 3 to 3 million
or storage which has been increased by a
factor of 1.4 million memory could be
increased by a factor or 500,000 and
what you probably have not yet
recognized there's a fourth box down
here maybe someone wants to take a guess
what's that okay good yeah it's battery
life in general so actually we were only
two able to extend the battery life from
one hour for the ospin one to roughly
ten hours for the mobile computers we
are using today and that's just the
motivation for computing systems in
general who have to deal with the
resource energy today so I will not only
focus on mobile computers like that but
in general from the smallest devices
smart dust to the data center we
currently have an issue with energy yes
yeah yeah so as mentioned my
introduction will first talk a little
bit about energy proportional systems to
get an idea what they actually are and
how we can today optimize them from a
software point of view not from a point
of view and then I would go and give the
presentation of our trials paper which
is called proactive energy of our
programming with peak if you have any
question in between just crazy Aaron
asked so we go back to this author on
one computer you probably would have
something like that if you look at the
utilization compared to the to the
energy consumption of the system it's
pretty much static you didn't have any
software knobs you could use to in order
to use energy saving features at
hardware level because there haven't
been any at that time
and we look at today's systems it's
probably something like that if we are
in an aisle mode we also use pretty low
energy but that increases with the
amount of utilization we put on their
system and i was wondering ok how will
this proceed in the future so how will
this probably change over the next years
and i took a look at this chip it's an
intel clammin prototype platform which
they have presented recently that's a
very good example for an energy
proportional cpu it actually scares from
three megahertz to almost 1 gigahertz so
that's pretty good for at least simple
machine arm chips come close to
something like that but that one is
really something interesting for me
because they actually pop made appt
application with some numbers on it
which are interesting for me to look at
so this also translates into a nice
proportion of power consumption so if we
are running at three major assets down
to two mil avadh for the power
consumption of the cpu and it's only
going up to almost but for for for the
maximum speed of the processor on this
following slide which is out of that
Intel paper they show how the frequency
of the CPU is compared to the total
power consumption of the CPU and the
very interesting spot for me is the
following one we can see that if we max
if we use twenty five percent of the
maximum power consumption of the CPU we
already getting fifty percent of the
performance so that's pretty interesting
for us especially if we put those
numbers into a similar craft to the ones
I've shown previously it gives us an
idea that if we only have a idle or a
normal utilization it will also make
sure that the system is in a low energy
mode so this is very interesting for us
from a software perspective because we
can try to to keep those busy moments at
a minimum and try to shift our software
to a normal utilization
state in order to keep the system
running at the longest time sorry I
don't have numbers on that so they
didn't pop mega publications of the
actual performance you get out of this
frequency but yeah then yeah that's
right yeah yeah that's true yeah that's
and also it's only a prototype I am
really not sure whether this what they
have present yeah yeah yeah yeah it's
just for me something to reason about
how it could be in the future and what
we can do in case it goes like that but
of course you're right if it goes a
different way we definitely have
probably other measures to take two to
increase the energy efficiency so if we
like a look at today's developers what
they are doing to optimize the program
code with regards to energy efficiency
they have an backward-looking approach
so normally you you go into development
phase where you actually write software
and after you are done you probably test
that software or you are deploying it to
a customer and this is usually the
moment when you actually find a defect
that's pretty similar to a funky no
defect in the application but it's
especially true for for energy bugs
because it's usually a thing of not of a
non availability of tooling
infrastructure so that people are not
able to actually address energy
efficiency at the time of development
and we are trying to address that at
this time so with our tooling
infrastructure
I'm going to present now we are actually
trying to keep the development time the
time where we are also optimizing for
energy so we try to really integrate the
aspects of energy efficiency into the
regular programming style or integrated
development environment of a developer
so before I give the talk on peak on
productive energy or bare programming
I've added this slide just to sum up
what else we are doing in our crude with
regards to research on energy where
systems so first of all we had a
publication back in 2011 a tub power at
the workshop on how we're computing
systems and computing and systems where
we presented a system called seep which
actually analyzes program code for
energy efficiency by first executing it
was the symbolic execution extracting
run time complexity out of that and then
using energy models we obtained with the
measurement device we have built in
order to judge whether a change of the
program code is going to change anything
with regards to the energy consumption
and as we thought of that workshop paper
together with the further development of
the energy measurement device which we
actually presented as a prototype at at
that time we now came up with our work
on proactive energy web programming with
peak and this is basically a system
where we use software components and
hardware components in order to to speed
up energy profiling and in order to help
developers optimizing their program code
we also have have a couple of people
working on soft and hard energy systems
this is in correspondence to what you
know from the real time systems
community with soft and hard real-time
systems and we also adopt methods from
their research and we extended with
genetic algorithms and iPad analyzers we
will have a post on that at OC I later
next week so if you are there please
come by have a look and talk to
on that work as well so next up is my
talk on proactive energy web programming
this is joint work with with the
technical university in Braunschweig and
I will quickly go over and make a
summary what we are currently facing
with regards to what are the current
problems on energy web programming or in
general in optimizing problem program
code for energy consumption so people
are currently writing modifying and
building application code and in the
second step they're actually analyzing
what has happened whether a change of
the source code has been a good one with
regards to the energy footprint or not
and for that they actually run the
applications with defined input so in
order to verify that a change of the
source code with the same input has a
probably different footprint with a
different algorithm or another change of
the logic and you can either do that
with running for your application with
fixed parameters or just simply using a
use case which might be already
available for your program you are
trying to optimize and in the third step
which is also very resource intensive
task because it's just consuming time
it's a manual task again you have to
perform an energy analysis of what you
are currently doing and for that you
either use some hardware or software
measures so either you're using a
measurement device in order to measure
how much energy your application is
consuming on a target system or you're
using some software profiling mechanism
like energy profile us which do not
actually do any energy measurements but
they are doing some sort of an indirect
measurement by using for example
performance counters to see how many
wake up's and application has been
causing and then this is probably
related to the energy consumption
footprint or they use simple energy
models which are probably instruction
based energy models so the current
challenges to make that three step up
proach more efficient one is actually
combining those steps in a way so that
they get more automatic thing that they
are not tripping manually by the
developers so we are looking at
integrating tooling infrastructure for
energy of our programming into existing
IDEs so we don't want to have people
adapt to a completely new environment
when they are doing their suffering
software development and we are also
looking at fully automated accurate
energy measurements because those
currently where the developers actually
spent the most time because it's just a
very time-consuming task to to run
energy measurements for for each and
single application at a given you upload
and last but not least we also look at
the challenge that actually developers
often have no clue what they actually
should do in order to improve the energy
impact of program code so this is really
something where tooling infrastructure
would be a great benefit for a developer
to to receive suggestions generated by
some system in order to get an idea but
what could I change to potentially
optimize my code and we actually
addressed both free challenges with our
proactive energy or web programming kit
core peak it's a systems approach to
energy web programming we do and to
create all that at the development tunt
so we do energy analyzers right at the
time of development and we show in our
evaluation that we can increase the task
of energy analyzers by a factor of 8.4
and at the same time we were able to
show that by creating automatically
generated optimization hints we could
decrease the energy demand by twenty
five percent so I will first talk about
the design and the system architecture
of our of our system framework i would
first talk about the software aspect of
it and then i will go over to the
hardware aspects which especially
focuses on the energy energy measurement
platform we have been
developing for peak so the system is
grouped into a front end middle end and
a back end component and the front end
is basically what we currently have is
an IDE on edit odds basically the system
where the programmers writing his code
and that's basically where we get our
source codes from and where we also get
the information on how to build the
source code and how probably we are
advised to do the energy analysis at
back-end level the second component is
the middle end which is a passive
component which is simply reused from
existing and development environments so
that's not a component we provide with
peak but we reuse it and that's where we
actually simply store our data there
this includes the source code build data
information at metadata which eventually
controls the back end with regards to
what it should do for energy analyzers
and at the backend level we are actually
doing the most complicated stuff so at
that point we are running with energy
measurements this is either direct or an
indirect one so when I talk about direct
measurement it's usually using an energy
measurement device and if I talk about
indirect methods it's using a energy
profiling tool and what they all have in
common is that they provide energy
consumption values at frontal level this
is what we have chosen to do we could go
on to other abstraction levels but
currently we use that and turn out to to
work pretty good the second thing the
back-end infrastructure actually
implementing that the second
contribution of our work from software
point of view it's why we are actually
generating energy optimization hints so
those are the suggestions we are passing
through back to the developer when we
have found things in the source code
which could have been improved in order
to reduce the energy consumption and we
pass those energy optimization hands
back to the developer at the end of
source code patches or modification to
the build environment
it's very important to not only look at
the source code but also have a look at
the build system we will see in the
evaluation that especially choosing the
right compiler for a specific software
is very important in order to reduce the
energy demand so when we look at the
operations how this all works from a
developer point of view we first have
the developer to commit a snapshot of
his current work so this is the software
combined with the energy analyst
configuration and we use for that simply
get so we can reuse the whole get
infrastructure used by projects for our
purpose of energy web programming and
for that we are mapping a peak snapshot
to get branch so we're working on a lot
of not on good prawns in order to
evaluate how the different get prawns
are with regards to energy consumption
and we can also use that for multiple
snapshots so for example if you have
probably five or four different
implementations of an algorithm you
might want to just simply try out which
one is the most energy-efficient one
former source code on a given hardware
platform and for that you simply submit
a batch analyzers through a couple of
get prawns to our system so once we have
submitted the data to the through the
middle and we simply inform the backend
that we are ready to start the energy
analyzers and this usually is an anchor
on as an Cronus operation because it
might be that the energy analyst takes
hours or days even depending on the size
of the of the amount of get prawns and
the run time complexity also of the code
so this just something also where we
have decided to really split the two
systems into the front end and the back
end so that we have separate machine
running all the energy measurements and
that we don't have to do that on it on a
developer machine there's also very
important for for the aspect that we
actually do real energy measurements
this way we just have a dedicated
machine with the energy measurement
hardware and several developers
chair that one device rather than buying
20 of them so once we have advised the
backend to start the energy analyzes the
back end actually pulls the good
parentals to to a local copy on the
system of the back end and prepares the
energy analyzers and that we then
differentiate between the indirect and
the direct measurement we either deploy
the binary to a target hardware platform
and then run the energy measurement with
the energy measurement device or on the
other hand if we use indirect energy
analyzers we simply set up an execution
environment with the energy profiler and
then run the application under the
supervision of that energy profiler in
order to run the energy analyzers for
the second step on energy optimization
hands let's have a quick look at how we
actually can optimize software for
energy demand of a low energy demand so
first of all today it's the most
important thing to actually exploit the
available hardware energy-saving
features at a maximum so it's usually
that we have to find an optimal set
which depends on the structure and the
runtime behavior of the source code in
order to exploit it in the most
efficient manner and we then have to
apply software changes to use those
energy-saving features in a correct set
or we have to restructure the software
in order to make it more
energy-efficient for example by choosing
different timers yes please
okay so usually if you also have
implications like functional Express
expects like you have to meet a given
deadline which probably is caused by
some performance constraint you probably
want to check that with a with a
specific use case so in case we are
optimizing something for a low energy
which probably now runs at lower
performance takes longer probably you
would have to as a developer check that
our optimization does not interfere with
probably performance or timing
constraints you have them from from your
point of view yes but I think we will
see now I will show some evaluation
results with which pretty much sums that
up because the energy analyzers resulted
they not only give back how much energy
your application has used but also how
long it was running but again depends on
the performance you are requesting and
we can we still have the developer to
make the call whether they need an
application to finish in a specific time
like interactive application or whether
there's some sort of a batch operation
which can finish at any time but run at
lower energy footprint probably for
longer time what also is important is to
align timers for example that you don't
wake up the CPU too many times this is
probably also something you have to look
at and for our system we currently have
implemented yep
what happened so so actually yeah we
have not yet done the automatic aligning
of timers with our energy optimization
tins so there's just what we can do
today manually but you you already have
probably infrastructure and your
operating system kernel where you
actually see when threads are waking up
the CPU and you probably just can try to
align them and double check with the use
case afterwards yeah yeah I mean
eventually boils down to that because if
you if you give me two different
versions of your code where you have
changed the timer's we will tell you
what of what version has been better
with regards to the energy input what we
are yet exploring is how of course how
we could tell you what would be the
correct order of Thomas and when should
they fire
give you a hint about what problems are
so I can imagine that it might be useful
imagine it'd be useful in pink could
tell me either you know hyper selection
might be a big problem for you or no go
look somewhere else for you right yeah
yes I think this is something we have
not yet covered but at the beg and
analyzes we definitely can look at
things like that because during the
measurement we have to execute the code
and we can do such monitoring whether
you had a lot of interrupts coming
through or not so yes and yeah I think
that the thing about what we currently
explore with the energy optimization
hints is more on the side that we simply
use different palisades of our hardware
and we explore whether using one energy
saving feature is more energy efficient
or the different one we not we haven't
yet looked into so much how the dynamic
aspect we would probably also benefit
for lowering your energy consumption
also what you say it's probably
interesting too currently we only
optimizing more or less aesthetically
but it's probably also interesting to
actually implement something into
scheduler where you probably investigate
what kind of input parameters are
currently used by your application and
we've probably profiled that earlier of
peak and we then probably switch to
different energy-saving features or use
different Thomas so this is probably
where we might hang with that yet so at
the at the optimization level of the
backends we we take the original source
code and we analyze whether we find any
functions where we currently have not
here they might be running at a lower
energy demand if we switch the power
DeMar the power saving features
energy-saving features at that point and
we simply apply those changes just on
trying it out whether actually
beckford and we push bad back those
changed except shots to the git
repositories at as a private prawns and
this is where we then start another
energy analyzed for those modified
branches they might be completely bogus
and they might crash they might just be
unusable but they might also be just
running fine they might just fulfill the
functional requirements of the original
source code and they might have lower
energy demand at the same time so this
is what we are then analyzing from the
from the candidates from the private get
branches we are analyzing curing the
next step we then select the ones which
actually show a lower energy demand all
others are just being deleted afterwards
and we do not yet generate the energy
and analyze energy content optimization
hint sorry we are not yet generating
them we just store the source code back
to the repository and let the front and
then generate the energy optimization
hands so this is actually being
performed in the fourth step so we
simply have the back and commits both
the analyst energy analyzers result as
well as the potential optimization
candidates to to the storage milland and
we then proceed in the front and to
actually get those results and the
energy results are simply presented to
the developer either the used EDI de or
just by its playing a set of functions
how much energy they have been consuming
and for the optimization hence we
actually generate a diff between the
original source code and the
optimization candidate and generate
patches for the developer but still it's
up to the developer to really make sure
that this source code this application
still is usable still fulfilling the
functional requirements so it's not at a
point where we can really go ahead and
say ok with we have optimized your
program code and it's ready to grow but
it's rather than we we present
suggestion this might be better it's at
least better with regards to energy come
sumption and it might still be what you
have looking after for your
implementation and then it's up to the
developer to actually verify that to get
out the last manual step out of that
would be really to use existing use
cases for some software project where in
case the use case is strict enough to
actually check all the functionality you
want to have our application it's
certainly sufficient to check whether
the all those criterias are still met
with an optimization candidate provided
by our system so this basically
completes the software side of our stake
the second part of peak is really the
energy measurement device which we have
implemented and it's a follow-up work
from our C paper so we have really
struggled finding a good way to measure
energy consumption of different systems
so either you use an oscilloscope
multimeter on analog to digital
converter and usually you have the
device on the test and you have the
shunt resistor afterwards and you simply
measure the voltage drop across that
shunt however all the listed approaches
on that slide they have a common problem
it's they have or sampling constraints
so if we look at the limitations they
also have other limitations like
probably missing control interfaces
which makes it unusable for a systems
approach to be used by other computer
but it's really that sampling may
invalidate your manager energy
measurements and we show that by the
following slide so what we sorry
yes that's what I'm going to talk about
so for that that's basically just an
example why those approaches are
difficult or even ever error-prone for
measuring energy yeah yeah yeah okay so
if we look at the following slide we
have measured the energy or in this case
we had a constant voltage so we measured
the current of the device under test
that was an i think was an arm cortex m4
microcontroller and we did the energy
measurement with the three adc's chained
and those three chained atcs they reach
a sampling rate of 7.2 million magus 72
7.2 miles million samples a second and
that translates into a sampling time of
140 nanoseconds yes please
are as as far as I know it's it's yeah
right yeah and they are built onto the
stm32f4 microcontrollers you are simply
using those three ADCs on that
microcontroller yeah and we can see the
sampling time in between the blue lines
so everything in between goes
potentially unnoticed by your
measurement device and if you're really
looking after the area below the current
that it's basically the energy we
multiply the current with the voltage
times the time and we can see that
there's a lot happening between and if
the measurement devices are not prepared
to to somehow capture that current you
probably lose quite a bit of energy in
your energy measurements yeah okay so
this was confusing ah right oh yeah yes
that was just a bad translation I know
what you get yeah yeah yeah that's good
to know ok I will change that yeah
thanks yeah yeah it doesn't change no it
doesn't change the energy actually it
does also change the energy consumption
of video wise but yeah it's not much
it's just yeah it's that's perfectly
fine that's not much yeah so yeah yeah
so we are currently on a second hardware
paper where we are actually as exactly
looking at that how much is the
difference between using a multimeter
change ADC approach or an oscilloscope
compared to what we are doing the dollar
device this one was measured with a with
a high-end oscilloscope yeah something
like that Oh even more I don't know yeah
so this has been done in lab yeah you
kind of do it yeah you can do it for
like snapshot short time but not for
like five minutes and we can go with our
device like forever so yeah and actually
often enough you are not actually
interested in something like that you
don't need the temporal resolution but
you're interested in to in having the
entire energy consumed through run yet
probably just interested in function
level not it like instruction level you
probably don't care I think I don't have
the data with me but I think the Codex
and for we have been measuring he is
running at 160 megahertz so and it's
yeah it's pretty much impossible to make
that deterministic if I run it a second
time you will you will certainly see the
instructions but you will see everything
else too so so what we have come with up
there is a analog energy measurement
device so essentially that's the core of
it we have the device on the test over
here and we have the current trend
rather device over this over those three
transistors and that's implementing a
current mirror and that's where we
probably get back to the topic of not
of not changing the energy measurement
or having no impact on the measured
energy so what is happening here the
transistors in the current mirror they
create two separate additional currents
I am one and I M 2 which are of the same
size or same they are equal to the
original current ID so we have three
currents which are of the same size but
after that we are only analyzing ID I m1
and m2 and we don't interfere with the
original current drawn by the device on
the test and we have as a second thing
we have here flip flop which is
controlling those two capacitors to be
charged and discharged on an alternating
basis and this eventually leads to such
a square wave signal which together we
simply count how many charging and
discharging events we have been seeing
through the measurement and under the
knowledge of the size of the capacitors
we are then able to extract exact energy
values and that's just what you are
looking after so there's also the
feedback we got from our prototype but
the prototype really was something like
that and this is something you cannot
give out to anyone even or to other
researchers so today it looks like that
we have a fully integrated energy
measurement device which integrates the
current mirror at the hardware level and
provides all what you want like a USB
port to actually access the device to
control the measurements and yeah I've
got some technical data there we have
energy resolution of 10 dot 1 micro true
we're just fine for our even the
smallest devices we are dealing with
like the smallest kaulitz m 0 plus arm
microcontrollers and we have a temporal
resolution of 6 90 seconds so this is
still not enough you you
you have get back to executing stuff in
a loop and then dividing results but for
what we are currently doing it cut out
to be sufficient one yeah yeah but if
you are measuring something which is
probably shorter than six 90 seconds if
you measure something else like a device
which changes over the time more quickly
so one thing we are also in degree add
20 credits this thing here cooling part
of it so this actually the weak spot I
will talk about just for a second the
transistors here they are pretty much
maxed out by doing all that work of
carrying out the to the mirror currents
to to the current mirror and that's
currently in the works that we go
further that eventually or today at
least limits our device only to be
suitable for like embedded devices we
can I think cope with in current of
about 500 million purrs but everything
above is a problem we have a solution
for it but it's not yet ready so the
easiest solution is to have another
second device ahead of our current
mirror which simply scales down the
current to smaller one but then this has
also to be hopefully very correct and
precise rather than generated by some
sampling so this is yeah that's the
device we are currently working with we
will actually release the genetics as
open source so we will not keep it in
our lab we will give it our 21 horns
work with it we already have a couple of
groups in Europe working with it and we
I think we would look forward to what
happens after trials because then it's
probably known to enough people who
probably have suffered from exactly what
we've been through for doing energy
measurement
earlier so last i will give some
evaluation results of peak of the joint
software and hardware framework
infrastructure so i will not talk too
much about the time savings and hands-on
experiment which we have carried out i
will focus on two things are three
things so we had a couple of benchmarks
which we compared with regard to how
runtime relates to energy consumption
and today's best practices strategy of
race to sleep so you usually execute
something as quickly as possible at the
penalty of the high performance hi Paula
train but then we can sleep for a long
time and in our evaluation we show that
this actually sometimes is inverted so
sometimes it's really true that you you
it's better to keep something running
for a long time and the total energy
footprint nevertheless is smaller than
executing it very quickly and then sleep
for a long time second thing of this
energy measurements is comparing the
energy efficiency of program code
generated by GCC and clang this will
show that choosing your correct compiler
is an important thing to consider and
third we will show how we were able to
speed up the code using energy
optimization hints in our evaluation
demo application so this is our
evaluation platform again that's a very
small one it's a cot x m 0 plus MCU
which clearly shows we have already to
deal with 11 different power saving
features on that small microcontroller
and it doesn't seem to get better so
it's really something which will not go
away anytime soon at least as long as we
have energy as a resource we have to
consider on our systems and for the
first evaluation results where we look
at the power modes we have been
executing different benchmark modules we
have like 12 on the paper and I've
picked out three interesting ones for
four
today and you can see the runtime of
those benchmarks running in different
power modes and the corresponding energy
footprint and for like ten of nine at
least of the benchmark modules we pretty
much see something like for the cnte
example on the left when running in a in
a low-power mode it takes a long time to
execute it's much quicker than executing
it in a normal power mode with a higher
clock speed and at the same time it's
usually that race to sleep executing it
quickly sleeping for a long time is
actually more energy efficient but for
two examples for an insertion sort and
recursion algorithm we saw that this
actually isn't invited so for those we
still have the speed-up it executes
smoke much quicker when running a normal
power state more normal power mode but
if you like look at the energy footprint
you can see that chewing that short time
you actually consumed higher power times
time goes to the higher energy footprint
for the to benchmark modules on the
right so this is something interesting
and this is something we really have to
look into because if you experience
something like that in a task which does
not have any tight schedule or deadlines
it has to meet it's just nice to execute
it whenever you want at a low
performance but eventually you will save
energy so this is one interesting expect
a lot of our evaluation the second one
was who's going to take the win for the
best binary created by a compiler and
for like most I think nine of 10 out of
12 benchmark modules we had similar
situations like the first two one time
it's the GCC compiler we're just
generating the more energy efficient
code and the other time its clang so
it's like five times its clang five
times as GCC which all right I mean it's
already showing a different of twenty
percent which shows you you really
should pick the right compiler for your
application
yeah yeah exactly so yah yah yah yah
trick yah so actually alright yeah yeah
yeah yeah yeah yeah that's true yeah
yeah but but still if you can save like
one fifth of year energy but speeding up
your code by twenty percent without
paying anything but switching the
compiler one interesting benchmark was
the cover benchmark which actually
showed that GCC was just slashed by
clang so we see that clang was executing
the code in like fifth of the time GCC
was executing it and we looked into the
binary of that and we saw that this is
q2 some interprocedural optimizations
which were only available in klang so
this really where you see that energy
really depends on the optimizations of
the compiler
like in the first two examples usually
it's correlated that yep very closely I
think yeah pretty much the the eight
example I left out look like the first
two just sometimes it's clang sometimes
TCC okay first thing was our revelation
of the optimization of problem code by
automatic generation of energy
optimization hints so what we used for
that cheering our experimental we had a
contiguous in which consists of two
functions two tasks one is sampling the
data from SLO mater and the second task
is using this data it runs near yes
encryption and sends it out using Wi-Fi
sorry not Wi-Fi wireless I think we're
it's just some sick be module connected
to the truth to the device and in the
evaluation results we simply for the
evaluation we just took our system to
automatically switch the tasks to
different power modes and then check how
is the energy footprint for the
application and we could see that for
the original revision which we received
from the developers we're both tasks
have been executed in a load power mode
could be cut down to seven from 10-6
milli joule to send that six mudichu yep
yeah oh actually I it could be but I
don't know whether visits really was
true for that it doesn't have to
actually yeah yeah but yes I think they
were not completely independent that we
had situations where tasked to have to
wait for task one to finish something
for example yeah I mean I don't have the
exact numbers how this split up between
the two task right now but I definitely
will have a look at that it really yeah
I think it should be like you say it
must be probably a double check yeah so
we also see that it's not also not
always the case that we succeeds over
this revision for example would not have
been on the in the selection proposed to
the developer so yeah that basically
shows that revision 3 which we generated
sales one fourth of the energy of the
original source code which is pretty
good for for an automatic optimization I
would say
yeah it's everything actually it's
difficult to to on those devices I mean
you saw that thing this is everything I
mean it's impossible to measure the
memory and the CPU separately so it's ya
know that one sex only Oh actually for
this hardware platform setups sorry for
this one we measured the entire device
so we had something like this one like
which has the arm cortex-m 0 integrated
together with the sick be modules and
everything connected and at that level
of course we could look into what's the
difference between the zigbee
consumption and the cpu consumption it's
also something we are come to looking it
for future versions of peak because I
mean you're really interested in not
only the Tau a total power consumption
or energy footprint but you want to see
okay where can I save something to
reduce the memory accessory I would use
the Wi-Fi or wireless transmissions
alright so that brings me to my clone
concluding slide so I've present a peak
joint hardware and software framework
for energy web programming seamlessly
integrates into existing development
environments it doesn't change too much
it's only adding a few components and
fists developers at the task of energy
by programming as future work I've put
some points on the slide we really want
to really will we will release the core
components at least open source license
we might even look into producing the
PCBs and the measurement devices and
seldom they are like I don't know I
think we have a number in the papers
like eighty dollars or something it's
just nothing compared to any of the
other energy measurement device
which are not as easy to be used as ours
so we might look into producing them and
selling them but yeah that's just yeah
its future work other than that we
further will prove the energy
measurement device as mentioned we still
have to deal with higher currents so we
are looking into this as well and we
also want to see how we can also
integrate further energy profiling
mechanisms which are using software
components only so yeah that's pretty
much it so you have any questions please
go ahead yeah that's good all right okay
thank you much each year microsoft
research helps hundreds of influential
speakers from around the world including
leading scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>