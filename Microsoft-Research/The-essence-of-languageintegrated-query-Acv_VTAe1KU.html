<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The essence of language-integrated query | Coder Coacher - Coaching Coders</title><meta content="The essence of language-integrated query - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The essence of language-integrated query</b></h2><h5 class="post__date">2016-07-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Acv_VTAe1KU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
alright well thank you all for coming
I'm really delighted to welcome Phil
water too MSR he's visiting us for the
next couple of days most of you probably
know Phil from his work on all kinds of
stuff functional programming in Haskell
object-oriented programming at generics
for Java databases and XML and query
languages related to that stuff and I
guess he's going to talk mostly about
about query languages today and how that
fits in with general-purpose programming
languages so looking for hearing about
that also a little plug for tomorrow so
at an unspecified time tomorrow we'll
we'll talk about undermount specified
location and unspecified location still
we'll talk about relational and
parametric city and if you're interested
in hearing about that send me an email
I'll announce it on some of the rise
lists but if you're not part of rice and
you'd like to hear about this send me an
email and i can tell you where that
meeting will be at some point tomorrow
so without further ado Phil ok great
quote thank you very much it's a great
pleasure to be here and to be able to
talk to this audience particularly
pleased i know some of the people in
here are researchers and some are
developers and dr. way talk about both
those things so thank you very much for
coming just a bookkeeping thing to
mention for the more research he one of
the ones of you this talk that Nicola
mentioned so a long time ago I did
something called theorems for free and
the way the magic in it works is through
something called semantic parametric
city due to John Reynolds and the way
semantic parama tricity is normally
explained is not surprisingly with
semantics and turns out the semantic
explanation of it gets a bit weighty and
difficult so a few years ago I wrote a
paper called the jog Reynolds
isomorphism that explains the same thing
but in a much simpler way using a
translation between two systems one
representing
the programming language in one
representing a logic and there are
interesting translations in fact both
ways so if you're at all interested in
semantics parama tricity this is I think
a bit easier way of explaining what's
going on so if you know about it and you
want some extra insight or you don't
want to you don't know about it you want
to know what it is then this would be an
appropriate talk and this is work they
did many years ago that unlike most of
my other work is not very highly cited
and I think it should be so I thought
I'll go and talk to people about it
right let's see so that's the first
thing out the way the second thing other
ways Judith what are you doing here
you've seen this talk you can this is
the same talk I gave at DDF p same title
even but there's more figure more um
more data we've got more data since I
gave it a DD FP aah even better okay so
the last time I gave this talk at DDF p
and also at the Midlands graduate school
it had this title the essence of
language integrated query I'm pleased to
tell you that this paper will be
presented at ICF p but not with this
title they said oh no we're not sure
that's really the essence of language
integrated query so they said you have
to change the title so the new title is
a practical theory of language
integrated query and in many ways this
is a better title because in fact 1 i'm
going to show you is that there's a
practical side and a theoretical side to
what we're doing and i'll talk a little
bit about how those interact but in some
ways it's a worse title because this
title alludes to one of john reynolds
classic papers the essence of algal and
John Reynolds died recently so it's a
shame that that bit of tribute to him
has gone away I should mention by the
way that the work on semantic parama
tricity is also john reynolds and so on
the talk tomorrow will certainly be a
tribute to him so the tributes gone away
but his influence of course goes on
right what is the difference between
theory and practice you all know the
answer to this riddle in theory there is
no difference but in practice there is
how many people that's an old so I think
how many people have heard that joke
before yeah all of you I figured that ah
that I did not know oh okay good i will
get that citation from you afterwards so
i can add it so this is going to be the
our touchstone for the talk what is the
difference between theory and practice
and I'll stay with I'd like this to be
an attractive talk you guys all just
interacted with me good if I say
something you don't understand please do
ask there are many many many database
programming languages here are a few of
them I don't think I'm going to go
through these in any detail at all
except to point out that goes all the
way back to clys Lee which was many
years ago and done by people at Penn who
are now my colleagues at Edinboro so I
better mention them but also because
cly's Lee in fact is named that because
of the use of monads in this work so it
was somewhat influenced by some things
that I had done and then it in turn has
a deep influence i'm going to show you
today so there are many many systems
here thank you I better fix that this is
the one that I worked on and one of the
points is that all the way back to here
you will see the roots of the ideas I'm
talking about so these are very deep
ideas but i don't want to claim credit
for that well i'm going to be talking
about is how do you take one of these
data let database query languages that's
a nice database query language and
integrate it with a programming language
that's a nice programming language right
you've got the database language you've
got the programming language how do you
get them to play nicely together and
that of course is exactly what linq
is intended to address and linq was in
fact in part based on again ideas of
monads that go back to the class Lee
work and to my own work okay and we're
going to show is a way of making this go
even better and these are goals but when
Linda first is skipped to the end and
show you something I really should move
this slide to the beginning so there's
the whole talk for you I want to show
you this bit of the results so one of
the contributions of this talk is I'm
going to go through some of a small set
of examples and there are more examples
in the paper and these all cover a set
of things that I think are important to
do so we're trying to in one way this is
the essence of language integrated
queries we try to extract the essence of
what are some of the important things we
want to do so these are all sample
programs that you'll see in the talker
can read in the paper and then here's
what happens if you try to compile them
under F sharp 20 or F sharp 30 and those
little X's mean it didn't compile it
fell over waving its legs in the air and
you can see that f-sharp 20 folds over
on some things and F sharp 30 falls over
on some different things and our stuff
doesn't fall over on any of these and in
fact our stuff is guaranteed not to fall
over on any of these we will give you a
a theory so here's the theory bit of it
that says four things in this subset it
always works so that's quite nice you
can know for certain set of programs
that you might write as craze that they
will not fall over kicking their legs in
the air now the subset we deal with
right this is the difference between
theory and practice the subset is
smaller than everything you might want
to do there are other things you want to
do you will see that the key idea that
we're doing here is we're taking
programs and normalizing them this is
the amount of time it takes to normalize
the nice thing is if you're accessing a
database accessing a database is
expensive so normalization down
the noise right you can afford the time
to normalize if what you're doing is
accessing a database and that's what
these figures show you but as I say we
only deal with a subset of queries in
the theory what happens in practice so
we took every single query that's in the
F sharp 30 documentation and ran it
through our system in the normalizer and
the point is they all work okay so
that's the practice side of it in
practice this could be put in f-sharp Oh
today and more things would work and
nothing would break so that's the
takeaway lesson so let me go back and
explain how it works so I mentioned that
part of it what we want to do is
abstract extract out a set of problems
that capture the kinds of things you
want to do so here's my list to explain
the kinds of things we want to do
abstraction over values pretty much
everybody can do that abstraction over
predicates you can do higher-order
queries composition of queries
composition is always a good thing
dynamic generation of queries that's
very important and something that's
often not dealt with well and type
safety is nice to have we also want very
much the Goldilocks property right the
number of queries that you generate
should be not too few and not too many
where and and to what's just right in
this case it's very easy to characterize
just right means exactly one so one
query in your program should turn into
one SQL query sent to the database and
I'm going to be working only with SQL
but I believe that the ideas i'm showing
would extend to other things for
instance of queries written a different
query language like xquery possibly even
these ideas could extend to integrating
GPU code into a general programming
language or something like that so we
want exactly one we don't want too few
what too few means is no queries came
out it couldn't do it failure kicking
its legs in the air and not too many
you don't want to have what looks like
one query end up generating a thousand
different queries and one of the things
I showed you in that result table and
that does generate literally a thousand
queries from one query and you don't
want that to happen and then as I
mentioned the theory is not everything
you could write in linq the theory is
basically just dealing with select from
where queries and exists in Union so
what we don't deal with is group by and
what we don't deal with this sort by and
those are of course very important it
would be nice to extend the theory to
include those as I've mentioned the
practice includes those already but the
theory doesn't yet we can't give you any
guarantees about them and just as a
notational convention doing exactly what
happens in linq every time i say list I
mean babb because we're going to a
database the orderings not relevant as i
mentioned we're not dealing with sort by
okay so i will say list in bag
interchangeably is everything familiar
with bag some people prefer multi set
what do people use around here bag or
multi set fine i will continue to say
bag okay so here's an example so I've
got a database consisting of some people
and their ages and some couples and
couples here have her and a him if
you've been paying attention to what's
going on with the law in the UK very
soon I'm going to have to apply schema
update to this schema but for the time
being will we old-fashioned and have her
and him
yeah it's much easier to have a her to
him that you could have a partner one in
partner too yeah the problem is I'm you
really really have two burgers neither
one is for you per second yes
fortunately that entire question is
orthogonal to this talk so here's a
typical query written in SQL find all
the women what we're going to return is
the woman's name and the difference
between the woman's age and the man's
age and what we're going to be drawn
from is couples of see people as w
people is AB and of course that views
going to be women and it's going to be
man and the her must be the woman's name
and the him must be the man's name and
the woman's age is greater than the
man's age this is just finding all
couples where the woman is older than
the man and we're printing the woman's
name and the difference in the ages
indeed if they were symmetric could be
hard to use this example so here's our
database um well wait no here is our
database but what we want to do is look
at the data but in the programming
language we want some way viewing the
database as data in the programming
language there's an old idea about how
we do this we are going to view each
table as a bag of Records and then since
we have several tables we actually have
a record of bags of Records so here we
have a record with two fields people in
couples and people is this bag of
records in each record has a name and at
age and couples again is a bag of
Records where each record has a her and
a him everybody suitably bored right if
there's something you don't understand
please to ask a question no questions
yeah yes for you
when when you make aquarium just kind of
kills over I legs in the air what
exactly does that mean in essence does
that mean that the ferry is just invalid
or we'll see examples where it might
have trouble generating a suitable SQL
query so this is what happens in link
right you can write link things that
denote queries but then at runtime it
tries to turn that into an SQL query and
it fails and that's what I meant by
kicking its leg in their legs in the air
right to our type of a database here is
just a record of lists of records so
this is just encoding the type of the
database I'm saying here okay so DB
prime is going to be this data and I've
put a prime on it to indicate you don't
really want to do this I'll explain why
in a minute but we've the ideas we've
got a construct that says read in the
hole look at the people database read it
in converted to a data structure and
store that in memory and then we could
write out our query now in ordinary f
sharp so this is ordinary f sharp this
corresponds exactly to our crisis
iterate over the couple's table let's
see very over that let W very over
people let em very over people do a
condition just the same one we had
before the her field is the same of sees
the same as the name field of W the
hempfield to see it's the same as the
name field of em and WH is greater than
a mage and then we yield as before a
name field which is the woman's name at
a difference field which is the
difference between the woman's age and
the men's age and there we get the
answer there we're done we've now
integrated our queries into our
programming language and we're writing
them just as ordinary programs in our
programming language this is fine why
did I put a prime down there well of
course you know this is fine except for
one tiny problem right and the tiny
problem is doing it this way is insane
other than that is perfectly fine why is
this insane most of you will probably
have already figured this out here I've
got about 10 records of course in a real
database I might
have 10,000 or 10 million or 10 billion
or 10 trillion records and reading 10
trillion records into the computer's
memory might not be feasible the other
problem is if you look at this query
this is ill this is best for C ranging
over all of couples for W ranging over
all of people and for EM ranging over
all of people so these are large it
would be the size of couples time the
size of people squared because we run
over people twice so that could be huge
right this is at least cubic in the size
of the database and what you'd like is
something that runs much faster than
that of course with indexing as an
actual SQL query this would run much
faster than thou okay so apart from the
fact that this is insanely inefficient
it's perfect so what we'd like to do is
write something like this and generate
SQL and actually have the SQL execute
against the database how do we do that
so the key idea which already exists and
is used in f-sharp for exactly this
purpose is quotation so the claim is
quotation is the essence of language
integrated query so a quotation just
means a data structure that represents
an expression and the type of a data
structure representing the expression of
type a will be written expert a so here
I've got expert DB is the type of
quotations that return values of type DB
or DB is exactly what we had before and
quotations in f-sharp are written in
these brackets written angle bracket at
an angle bracket and the quoted code I
will always have written in blue so now
instead of saying actually read in
database people we say just bind db2 ape
rotation of something that stands for
access to database people
so now before remember we just had
here's an expression in f-sharp of this
type it returns a list of named
difference records now we're going to
return an expert of the same thing so we
just write the thing in quotation
brackets and other than that it's
exactly as it was before and now what we
do instead you're saying differences we
say run of differences so run is going
to be this construct in our language
that takes a quoted thing and runs it
against the database and then we get the
same answers before so what does one do
it computes the quoted expression it
simplifies the quoted expression or
normalizes in it then takes the
normalized quoted expression and
translates that to SQL we will see that
once you've done normalization it looks
almost exactly like SQL so this step is
very easy you ship it off to the
database and run it that steps very easy
you get back a table you translate that
table back to a data structure in the
host language that can be processed so
all of these steps are very easy turns
out this is rather easy as well so in
fact all these steps are pretty easy the
hard work of course is actually
executing the SQL query but we're using
existing SQL implementations to do that
and now here's the guarantee if you
stick to this subset language that I
mentioned which is just um the only
constructs we're going to use our for if
yield and also um concatenation of bags
and the exists construct which given a
bag returns true or false depending on
whether or not empty so just testing it
back for emptiness Union in bags and for
if and yield if you just write your
program using those and in addition your
answer type is what is called flat
meaning it's a bag of record of scalars
so we've seen tables are just that
they're bags of records of scalars so if
your answer is a table which it better
be if it's the answer from an SQL query
so the first requirement just the answer
has to have the author
type for a table returned from an SQL
query second thing is you only do
permitted operations so those are for if
yield as we just saw Union exists and um
right if you're doing addition or less
than or whatnot they better be
operations that the database support
check that this number is prime can't do
unless it's actually supporting your
database language which last time i
looked at SQL it did not have a is prime
primitive and in particular recursion
it's not generally supported in SQL if
you can't use recursion and finally your
uses of database must all be consistent
right if we expand this program out each
of these expands to a use of database
they all better be the same database
right you try to access to different
databases then you'll be in trouble of
course we can put as many tables in the
database as we like but it all had
better be one database so all of these
constraints I think are quite reasonable
if you want to actually translate into
SQL okay so I mentioned all these great
things we want to be able to do
abstraction composition and dynamic
generation of code how does that work so
the first thing you want to do of course
is to be able to abstract / values so
here's something range and range takes a
pair of integers and returns a list of
names it must be a table again so we
make a list of records each is
containing a name field and we're going
to find everybody whose age is greater
than or equal to the first integer and
less than the second integer so we just
is to function for each W in the
database check the age and notices this
is ranging over all people so it's a
fact women and men and then we yield the
name so we're going to find all people
whose ages yeah there are 30 some things
between greater than or equal to 30 in
less than 40 and that's Cora and drew
notice by the way that the abstraction
here is going on in the quoted code I'll
say more about that later but that if
you that's actually slightly surprising
I'll come back to that so that's fairly
straightforward right everything
supports abstracting over values that's
the obvious thing that you want to be
able to do a more sophisticated thing to
do is abstracting over predicates so now
let's take an arbitrary predicate over
integers and return a list of names so
now we take the predicate as an argument
and again iterate over everybody in
people and if the age satisfies the
predicate then we return the name so the
predicate of course could be between 30
and 40 and then it would return core
Andrew as before or the predicate might
be people whose age is even because mod
it turns out works because it's
supported in SQL again if we had prime
here it wouldn't work because prime is
not supported in SQL so now we're
invoking satisfies on an arbitrary
function again the function not
surprisingly has to be written in the
quoted language so everything here is
just inside quotes any questions about
that yet okay so now we can strap yes so
expression in schools and names but as
price is not an expression of interval
to an expression of names right so this
is exactly the point I just mentioned I
said it's slightly surprising that this
bit of the abstraction and this bit of
the abstraction is happening inside the
programming language and you just
confirm that by saying I'm surprised I
expected to be expert event in to expert
al return to that later I'm glad you
said you're surprised I was surprised
too ok and then of course we want to
compose queries so here's something get
age which is going to run over a loop of
people and if the name matches returns
the age and notice that using these
constructs the best we can get coming
out is actually a list of ages because
there's no way of converting a list to a
single value that's not one of our
supported operators so the closest we
can get to get age is return a list of
the ages and then we can compose get age
with range so given two strings we will
return every will find the age of the
first person and the age of the second
person and then we'll return everybody
whose age is between as greater than or
equal to the age of the first person and
less than the age of the second person
so these are all people that are at
least as old as Edna but younger than
Bert that turns out to be Cora drew and
Edna so now we're just in a very
straightforward way composing queries to
build a larger query right so we call
get age it's going to return list let a
be everything that list it'll actually
there's only one possibility the same
for B and then find everything in rain
we'd like to turn this just into a sink
right Simon painting Jones was kind
enough to read this paper and he said
what's hard about that executes get a
John the database execute get age again
on the database execute range on the
database three queries you've got your
answer yes indeedy but we don't want to
do it that way we want one query every
time we call run it should be a single
query and it turns out turning that into
a single SQL query is not entirely
trivial
and then finally of course we would like
dynamically generated queries this is
extremely important right you fiddle
around with your web interface but this
is almost every web program in existence
what you're really doing is through the
web interface building some data
structure turning that data structure
into a query executing that query on a
database and then displaying the answer
that's pretty much every web application
in existence so as a simple example of
that here's a data structure that
represents predicates so above will mean
greater than or equal to the given
integer below means less than the given
integer and we can take and an or of
arbitrary predicate or negation of a
predicate so not surprisingly this
structure t0 of type predicates
represents the query we had before which
are people at least 30 in less than 40
and this is something different not a
war of below 30 or above 40 which
happens to extensional ed the same
predicates not the same piece of code
but true for the same values so any
questions about that so that's how we
represent predicates how would we turn
this into a query so we use our web
interface we build up a predicate now we
want to query that against the database
so again this can be pretty
straightforward so I'll write a function
P that takes a predicate and returns an
expert from into bool so that is given
an age return true or false depending on
whether the predicate is satisfied
there's an operation that takes an
integer into an expert of integer which
is called left this % means splice into
some quoted cloak code right we've been
using that before right to splice in our
database or to splice in our call to get
age or to range people didn't ask about
that so I assume it's fairly
straightforward right so it just takes a
value of type expert and splices it in
to give the bigger value of type expert
so in this case the thing we want to
splice in is an integer so we need to
convert the integer via lift to an
expert vintage ur and then we can splice
it in and then this is the obvious thing
the function over X that if the given
integers
r equal to X similarly for below then
for an we just recursively apply p to t
in you to convert those into predicates
and apply each of those two x and and
the result similarly for or similarly
for not so you couldn't imagine a much
more straightforward piece of code than
this now remember our database doesn't
handle recursion this is of course
recursive code we recursively invoking p
but we're doing the recursion at query
generation time not query execution time
so recursion at query generation time is
fawn query execution time is not notice
also remember you said before you wanted
something as type with something goes to
X / of something here we have this the
type of this code is given the predicate
return an expert event to boo the
predicate argument can't be inside the
exper because they were taking apart the
predicate at query generation time not
query execution time so things are
inside the expert when we want them to
happen at query execution time outside
when we want them to happen at query
generation time and then not
surprisingly p of t 0 you just expand
that out using the code i gave you
before and it turns into this which is
kind of messy right because we've got
here's the above 30 here's the below 40
and then here's the end of those two
things and this is of course needlessly
complicated code but will normalize it
right and the normalizing here is very
easy we just substitute X for X in this
case and we end up getting this for the
normalized code which is fine for
executing so now i can do satisfies of p
applied to t0 and this gives of course
the same answers as before and of course
since t1 is the same predicate this gets
the same answers as before so now we've
got dynamically generated code because
we can build t0 at run
I like to notice that t0 here its type
would be predicates not expert Frederica
but it generates an expert okay any
questions about that that's the basic
technique there's one other thing we can
do which is really cool which is nesting
sometimes it's very useful to build a
non-flat data structure as part of
building your query I'll give you what I
think is a compelling example of this
and our point is going to be it's
perfectly fine to nest as long as the
answer itself is not nested but flat
again a good area for future work is
what do you do if you want the answer
itself to be nested there's some nice
work by the ferry group which I was one
of the things I mentioned at the
beginning they show that if your nesting
is d deep so if you've got a list of
lists of lists for your answer so that's
three deep they can do that with three
queries so not one query but three
queries number of queries depending on
the depth of nesting so that's work
that's been done adapting that to this
framework would be interesting future
work but let's restrict ourselves to
just the answer is flat but there's
maybe some nesting in the query why
would you want to do that so here's an
example so here's some company it's got
four departments products quality
research and sales and each department
has some employees and each employee has
tasks they can do so Alex knows how to
build stuff Berta knows how to build
stuff Cora knows how to abstract build
and design things Fred knows how to call
and so on and that makes sense because
like Fred works in sales so it makes
sense he knows how to call Corey knows
how to extract that makes sense because
she works in research Alex knows how to
build that makes sense because she works
in product so how would I represent this
organization it's I've got three tables
departments employees and tasks that
we've just seen so there's our
organization
represented in ready to do a query so
here's the query I want to do find
departments where every employee can do
a given task so here I'm asking find
departments where every employee knows
how to abstract turns out there are two
departments like that one is research
not surprisingly the other is quality
that's maybe surprising but not too
surprising because if you go back and
look you see that the Quality department
in this company has no employees so if
you ask is it true that every single
employee and quality knows how to
abstract answer is yes because there are
none of them so and here's the query
very straightforward right well let's
see we go over all the departments let D
be a department let's go over all the
employees find those employees that are
in that department and then for those
find four let's go over tasks find all
the tasks done by that employee and
check if the task is this task you that
we're interested in so use the name of
in this case abstract so now we're
forming an inner list here for each
given employee of all the tasks that
that employee can do and we're saying
right if one of the tests the employee
can do is the given one then yield an
empty record so then this list will be
non-empty if the employee can do the
given task then we take the negation of
that so this is now the list of all
employees that cannot do the given task
and if that list and will yield
something's that's true and if that list
is empty then that means there's no
employee in that department that cannot
do the given task nice straightforward
piece of code right
if you were writing SQL the exact analog
of this is the is the cleanest thing you
could write this is actually the native
code that somebody would write in SQL to
answer this query but as we've just seen
it's not really very clear can we
structure this in a way to make the
query easier to read so that involves
nesting right so here's a more logical
way of structuring the data that we have
we're going to have a bag of departments
up well bag of records and the record
has a department name and a list of all
the employees for each employee we have
the employee name and a list of all the
tasks that employee can do right Sakura
can do three tasks drew can do two tasks
and so on and quality has no employees
so now we want to build the nested data
that's easy here's a straightforward
query that takes the three flat tables
that I showed you and gives you a nested
organization structure very
straightforward then given a nested
organization structure so here's some
higher order queries that you might want
and these all actually exist in linq
with pretty much these names any which
takes a list of a's and a predicate over
a's and it returns true if some value in
that list satisfies the given predicate
so this is just the exists predicate all
is the dual of that so run over the
negation of the predicate and as long as
that's non-empty thing right this is
just the normal way of defining for all
in terms of there exists using double
negation using de Morgan's law so this
just returns true of everything in the
list satisfies to given predicate and
then contains is just checking whether
given a list of A's and a value a it
just checks that there is some value in
the list that is equal to the given you
so given a list X's and a value you
just the predicate we use with any is is
x equal to you so this return this is
check for containment check whether the
value a appears in the a list so now we
can rewrite expertise much more cleanly
remember before we had expertise
expertise prime here the prime doesn't
mean this is insanely inefficient here
the prime means this is insanely
difficult to read so here's an
equivalent query which i think is not
insanely difficult terrain which is just
for each d in the nested organization
extract from that the employees use the
predicate that the employee tasks field
of the employee contains the given task
name you and if that's true yield that
department night so again running
expertise over abstract we get quality
and research just as before because the
two predicates are equivalent ok so
that's why you might want to do nesting
and all now in just a moment I'll say
how we support all this should be
extended this nested structure
it was being so many people here right
possibly you want a bigger programming
language but i'm not going to address
that problem on they say right sequels
kind of a hard object to move but you
guys can change link if you want to and
this doesn't even require any changes to
link just a change to the link query
provider the thing that changes the link
expression tree into SQL right so this
is an easy and easy with getting all
that power without needing to change SQL
and getting it easily within linq now
I'm going to go to this point that you
were surprised by and that I think every
base ship enterprise I was surprised I
was so surprised I can still remember
exactly where I was when I realized oh
this is surprising right i was riding
through in fact well named the links in
edinburgh with the castle to my left I
suddenly went what's going on here right
so what's interesting here so the way we
wrote range right is we took a pair of
integers and returned Nate said this was
all done inside the quote and you might
well have been surprised to that because
you might have expected something that
does it outside the quotes right the
natural thing to do is say well really
take two integers but just to separate
out the prophets say take two expertise
of integers and we just want to plug
those in right in the right place and
the query wouldn't that be the best way
of doing it well no because that gets in
the way of building doing compositions
that return just one query so then when
we did compose we'd like that to give a
single query as it was that was easy
what would happen if we put the
quotations on the outside put the
quotations on the outside so right let's
make the minimum change we could so we
could also put these strings on the
outside but let's just even leave the
strings on the inside let's just assume
only this one did the expected thing and
put them on the outside what goes wrong
what goes wrong is we call
again we call get age of s and get age
of tea for a and B but a and B now are
in right range now is expecting quoted
things right so we give it a quoted and
be quoted and in fact there are type
systems for quotations where this is a
perfectly fine bit of code and everybody
is happy there's something called um
meta ml where this is a perfectly fine
thing to do f sharp supports typed
quotations but it does not support the
type system of n meta ml so what happens
if you try to do this in f-sharp it
gives you an error message I will now
give you a loose translation of the
error message the error message says
what are you crazy you've given me a
quotation for a but a isn't bound within
that quotation turns out a is bound in
an enclosing quotation but f shark
doesn't handle that so if F sharp could
handle it this would be a perfectly fine
way to do things but it can't so what
you have to do is put it on the inside
instead so that's why the surprising
thing happens
what do you mean when you say X where is
multiplicative the CU implanted across
an escalation right so you've got an
expert that's of a function mean an
expert type A to B you've got another
expert type a and then you want to apply
the two yeah right so yes here's some
white board right so the type of F is an
expert of a 2d and the type of X is an
expert of a can you apply those two easy
sort of shirt is your neck speed right
you just do % f
and that does exactly what you want
so if you read the paper I'm not going
to do it here if you read the paper
there's something that says ah well so
these are what are called open
quotations and open quotation is when
you have a value that's not bound in the
quotation those are easy to deal with as
long as you have a very sophisticated
type system that included in the type of
the expert the types of all sorry the
names and types of all the free
variables that appear inside quotes so
it's very straightforward to deal with
it's just F sharp doesn't deal with it
and we show that if you take a very
simple version of such a language in
fact instead basically we say instead of
having an open variable lambda abstract
over it that's a fairly straightforward
thing to do and that's all we've done
all the time Steph having free variables
we just abstract over them so in fact if
you had perfect if you're willing to
change your programming language you'd
be perfectly fine to add one of the many
different ways of dealing with open
quotation to it the surprising result
right the aha moment I had because I'd
been doing this for ages without
realizing it the paper was almost ready
to send off and in the week we were
sending off ice and we went wait this is
amazing right we're putting all the
quotations inside rather than outside
and the reason we're doing it is because
then we don't need open quotation and
you'd never need open quotation because
you can just land abstract instead and
that's all cheap because we're going to
normalize things before we generate the
query so the fact that we've got lots of
extra lambda abstractions that get
applied doesn't matter it all gets
normalized out so there's nothing deep
here but as I say it was surprising
enough to almost make me fall off my
bicycle yes that range actually runs
no you never run a query until you say
run Prime no no range prom was just had
had a prime because um it's experts for
the expert but by the way there's a typo
here that should be expert of names not
names but there's a lot also at the end
of it right I guess that's maybe one
minute I'm sorry I like there's the
writers right but still it but range
prime is a absolute applied function at
your time still yeah so in a system like
meth Amell where you have the nested
quotations yeah is what you're saying
would it mean to like take a mint ml
program with nice exploitations and
start applying this would be perfectly
fine with lenses this would be perfectly
fine and meta ml yes no but you can I
now take a arbitrary manual with mrs.
quotations and do this transformation
ray say oh well put all the quotations
inside and use land abstractions right
so an interesting question is he could
any program in meta NL be changed to
this other style and I don't know the
answer to that gap you don't know exact
like for this system it holds let's
don't know yet what like when would it
fails it yes I thought examined in
detail what happens with that which I
should because Haskell now implements
the FML type system for quotations yeah
as of a week ago it has that as a
feature
right since of the one saying here is in
a language that only supports closed
rotations like f sharp obviously you
better use close quotation if you can
rather than open quotation and that
works for us because of the
normalization and if you want a more
complicated way of saying it prefer
quotations of functions two functions of
quotations right which is right you want
a function they took a quotation to
quotation that we've got quotation of a
function here's there's a more
complicated example in the paper
involving changing queries over XPath
into SQL look at the paper I won't show
you that why do want to do is take just
a couple of minutes to show you how it
works so this is scheduled from till
three but people probably want to go
people I'm people want to believe it
which I finish it to 30s that would
peopled like okay let's aim for 230 so
this is a very straightforward type
system for the language of call all I
want to show you is so this is the
typing for expressions it's just what
you'd expect notice that we've got
recursion is a construct in the language
for expressions here's the typing for
quoted terms it's again exactly what
you'd expect everything in blue this
time notice that we've got access to the
database in the language of quoted
expressions but not in the language of
unquote so things outside of quotes you
can use recursion things inside you can
now in practice the way you do this is
just you run over the quotin see is
there anything unpermitted they're like
recursion so at runtime you'll need to
check that in the theory of the language
then in the theory we check for that in
the type system and the key things are
the things that move between coded
expressions and unquoted expressions Oh
notice the quoted expressions need an
extra thing in the tight so things in
gamma are free variables that appear
unquoted things in Delta are free
variables that appear
inside the quotes like fun x where x is
inside a quote and then the things that
move between just move between the two
judgments of quoting moves from one
judgment to the other anti quote goes
the other way around run takes a quoted
thing and actually runs it so something
of type T where T remember is a what was
it bad of records of scale is your table
time and lift remember take something of
base type so that's 0 and turns it into
an expert representing the same thing so
now we need to normalize the rules for
normalization are all very familiar if
you've got a function application
substitute if you have a record extract
the record field these are both called
beta reduction there's very standard
rules for foreign yield these are called
the Monad laws so if you've got four of
something that's immediately doing a
yield just substitute if you have two
fours you can rearrange them that's
called the associativity law then you've
got some other laws which are again very
straightforward if you've got a four of
an F turn it to an F of a for you have a
four over the empty record that of
course we're just the empty record if
you have a forward concatenation we
didn't even see in examples involving
this is Union but that would just turned
into a union of two fours and of course
if of true and if a false reducing the
obvious ways no sweat we're using this
variant of if then else where the else
Clause just always return to empty this
is really what's a where clause in SQL
yes to capture avoiding substitution of
course and that so these are very
standard rules they go way back and then
we need some non-standard rules just to
make sure that it's bat in SQL format so
write SQL is not completely
compositional you can use Union but only
at the top level so if you have a four
of Union turn it into a union of a for
this by the way is the only place where
we rearrange the order this is why we
have bags apart from fact that SQL
supports bags so again we'll need to if
we've got four over an empty list will
have to turn that into an empty list has
turns out SQL doesn't support thou and
these are just all straightforward
things the most interesting one is you
cannot have to where clauses in SQL so
if you have two successive where clauses
turn them into one you can't have you
can only have a we're inside of four so
if an if outside the four push it inside
so this pushes all our is to the end so
let's um and then this has all the
standard properties you'd want for both
of these relations yeah the endocrine
bubble is to the top as much as you can
right so the most efficient thing is to
bubble the its to the top but the thing
that SQL syntactically supports is all
the wares at the end write SQL forces
you to push the wares to the end so what
we'll do is we'll push the wares to the
end and then the SQL optimizer will
bubble up again
but this has all the standard properties
the reductions preserve typing they're
strongly normalizing and their
consulates you can apply them in any
order whatsoever so all of this is very
straight forward strongly normalizing
that you didn't show the reductions for
every person
ah we're reducing quoted terms but we're
only reducing the quoted stuff and the
code stuff can't include recursion
that's why it's all easy and I should
mention that you can find these rules at
least going back to the old papers on
Klaus Lee Ezra Cooper who was on the
links team working with me wrote a paper
that has essentially these rules and
these rules in it but they were all done
at once and so strong normalization was
rather hard to prove so one of the small
innovations in this paper is we break it
into two sets of rules these rules which
are very straightforward for which
strong normalization is well known these
for which you have to prove strong
normalization but it's straightforward
do you really have strong reduction can
you reduce underneath the lab door and
so on yeah but the rules look like a
beta from the outside only right in the
cycle call by name baby yeah we're going
to call my name reduction underneath in
the quoted terms doesn't matter we've
can you reduce you know even on deneva
that no suppose you just have yeah cuz
there no side effects I guess I just
don't see the rule strip don't let you
do that here so what will let you do it
this rule oh sorry it's the compatible
closure of these rules so you can reduce
anywhere okay example right remember
compose let's let me show you how all
these rules help us out so here's
compose of that number so we take the
definition of compose and expand it out
and then that involve calling age of and
range so we expand everything out and we
get this so this is in fact what happens
after you've spliced everything together
so at the point we need to normalize
this is what we're given so now we're
going to normalize this let's see what
have we got when we've got this function
applied to Edmund Bert's will substitute
in edmond bert and now we've got this
and notice that we've got some fours
with four is inside of them and with the
ifs inside of them but remember we had
rules that would percolate those out so
we go ahead and do that and we do it
here again and so now we've got just a
bunch of fours and F's but we've got ifs
alternating with fours but remember we
had these rules that would push it
to the end so we do that and we also use
the rule that combines ifs so all these
separate ifs now get combined together
into one big if and this looks exactly
like SQL right select we're sorry these
are from is this is where and this is
the Select at the front so this has to
go to the front but that's about it so
there's the corresponding SQL and we
execute that and we get the answer okay
and this is what you saw before right so
oh the nested one if you run it in
f-sharp 30 it will run but it actually
acts on the nested structure and to act
on the nested structure it issues the
query the same number of times our
departments so if you have a hundred
departments this will execute 100
queries whereas we execute one query so
it's a lot faster everything else we
either slightly faster or slightly
slower than F sharp in either variant
and they're all much of a muchness and
the point is the tables are big enough
that the normalization time doesn't
matter and is quite tiny and this this
is for moderate size tables with about
5000 entries so for really big tables
the normalization really doesn't matter
and this is by the way using a very slow
normalizer I'm sure you could write
faster ones why does it sharp 24 h 03
ball over in some cases ah because
they're not doing the normalization they
could be but they're not but what does
it mean like they see all day they
cannot generate sequel for it what you
can build up the expert that represents
the query and then you hand it over to
the query provider which is supposed to
turn it into SQL and it says well I
don't know what to do here
at changes between different releases
but so for the subset I've described we
can always guarantee that it works and
then as I mentioned if you're outside
that subset for all the queries that are
in the standard documentation it works
and again the times are the
normalization time is small so this is
something that something could just sit
down and implement today right we've
implemented it it turns out there's one
problem with F sharp 30 in hooking in
and using your own data provider your
own thing that converts linq expressions
into SQL queries so it would be very
nice at something the F sharp team would
just do that so people can start using
this new technique and can be done now
and they're all the details but please
you can download the paper from my
website there will be a an updated
version by the end of the month which
will be the camera-ready copy for I CFP
and please have a look if you'd like to
see more details right so these are our
goals and you've seen that they've all
been achieved and finally I want to
return to this old question of what is
the difference between theory and
practice so we do have two different
things right we've got the theory that
I've showed you and then we've got the
practical implementation right and the
theory doesn't apply to all programs but
the if you just do normalization over
ordinary programs it never makes things
worse not surprisingly so anything that
ran before still runs after you
normalize it and some things it didn't
run before do right in a few normalize
it one other thing what we actually got
here is a recipe right and the recipe
says what do you do if you want to take
some arbitrary domain-specific language
and integrate it into your programming
language well just write out the
domain-specific language in the same
syntax as your programming language and
quote it
actually it's not necessarily and then
normalize it and the one thing that
you're at lea what normalizations you
need boat will vary from language to
language but you certainly want beta
reduction and sometimes maybe even beta
reduction will be adequate I'm guessing
that for generating GPU code it's just
beta reduction I'm not sure we're going
to look at that as an example next some
reviewers of the paper point out we'll
wait a minute you do not need the host
language and the quoted language to be
the same in fact in our case they
weren't really the same right it's the
same syntax but the host language has
recursion the quoted language has the
database construct so in fact they
differ just slightly in fact you could
just have your quoted language be
completely different nobody does that
though in practice right in practice
people implement quotation that's for
the language that contains the quotation
right so the quotations in f-sharp r of
f sharp code the quotations in haskell
are of a haskell code and so on so what
is the difference between theory and
practice in our work well in theory
there is a difference but in practice
there isn't thank you very much then
people running into this limitation of F
sharp and complain about it we're you
know developer communities running into
this obstacle what that's a very good
question the answer is you can find
various blog posts saying oh this is so
Thomas Petra check for instance who's on
the F sharp team has done clever work in
getting things like our dynamic queries
to work has done long wall post saying
okay if you want dynamic query to work
here's how you do it right he gives this
little clever recipe he doesn't have any
theory that says it's always going to
work or anything like that so this is
actually a very good question right how
often do people bump into this in
practice we don't know there's no
systematic data there's a little bit of
anecdotal data from people doing blog
post saying well here's how I managed to
get this thing to go through in a
inq but that's in fact I would say not i
would say that we don't have convincing
knockdown evidence that this is a
problem but I mean yeah but but you know
I think just looking at this right all
of these are things you'd like to do
right Eddie and sometimes you can and
sometimes you can so so this is sort of
hard knockdown evidence saying that
there's a problem do you know about
other languages like C sharp C sharp
sting providers did you know Cajun these
queries okay ah we've not tested any of
this in c-sharp that's a good question
and c-sharp doesn't actually give you
quotation per se it's all hidden that
give you operators that build up
expression trees but they don't have
quotation per se so doing all this in
c-sharp would not be quite so easy and
one of our recommendations I think would
be put quotation into your programming
language because it gives people this is
an option yes why is that shark not
already doing that is what what is it
that it provides that
evidently more complicated algorithm
that
it's complicated enough that we've not
looked at exactly what this is doing
right and we're hoping that they will
just adopt this and use it you don't
know for example dropped on a note in
saying hey you should implement Phil
stuff right now I want it sorry right
for example at me it's not the case that
they're just missing the normalization
face or that they do you know it's just
it's exactly just that they're missing
the normalization guys you just add
normalization it'll work right because
the back end that we used for this is f
sharp 30 but the only thing we changed
as we did some normalization first
that's it so just normalizing is all you
need to do the court of language does
not support any kind of specific
functions of any sort but we have that
drop it kind of a jury
the body and the expression past not
expression for any value passed in
extended in place right I got that
correctly you're referring to the lift
operator that we convert an integer to
an expert vintage ER or string right so
in that case is it welcome is because I
but that's a value right you see use
recursion to compute the value but then
you just have the value well what a
higher function itself so sorry for
misunderstood ah lift applies to base
types not two functions right functions
you must start with quoted code you
can't take an arbitrary function and
turn it into a quoted expression tree
that describes that function
got a question ah I'll ask all right
well let's thank you doing it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>