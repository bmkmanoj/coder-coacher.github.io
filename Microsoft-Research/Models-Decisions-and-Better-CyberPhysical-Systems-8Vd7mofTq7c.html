<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Models, Decisions, and Better Cyber-Physical Systems | Coder Coacher - Coaching Coders</title><meta content="Models, Decisions, and Better Cyber-Physical Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Models, Decisions, and Better Cyber-Physical Systems</b></h2><h5 class="post__date">2016-07-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/8Vd7mofTq7c" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
is my great pleasure to introduce young
girl from CMU the Sun did many
interesting things he define an ocean of
Delta stability that's very interesting
today he's going to talk a little bit
about that but he's also now working on
cyber physical systems and i'ma get you
know to learn more about it Thank You
thing it's okay but stand here yeah okay
hi it's really an honor a great honor to
be here I want to talk about our recent
work this emerging field called cyber
physical systems a cyber-physical system
is a combination of digital computation
and and the physical environment
basically what you have I mean this is
actually part of part of every
sophisticated machinery in our daily
life you have some kind of chip you have
some computation going on and you have
the computational part interacting with
the environment it gets information from
the sensors and it has actuators that
can control the the physical environment
and all this are done in real time those
systems are really everywhere you can
see that all be big sort of companies
that are not considered as sulfur
companies they're really what we could
call several physical systems because
they need to develop those big machines
and also the software that's going on in
those machines and here are some
examples more concrete examples when is
the this one is the autonomous car being
developed as
CMU so it has a lot of sensors and as
its own actuators that it is driving
itself and this is what you've seen a
cockpit in the plane and this is a
cardiac pacemaker that people will have
you know in their body and this is the
control room of a nuclear plant okay so
all those systems they have this
characterization that it's you know
computation combined with some really
you know some really important physical
environments and some simply the control
problem so the the two most important
feature about this kind of systems one
is that it's it's very complicated right
so if you want to reason about the
system combined with the dynamics of you
know the environment it's really a
complicated thing and the second thing
the other thing is that it's very safety
critical right so if you think about
having a blank screen on your desktop
and laptop you the most you you're
losing is you know a day's work but if
you have a blank screen on the plane
which actually happens in the in the I
think it's the air france flight in 2009
which which crash and i think 200 people
died or something hundreds of people
died and that was because the the the
sensors the sensor for the speed of the
plane was frozen and the control
software on the plane was giving a blank
screen saying that you have invalid data
and it stopped to do anything and then
the pilot the pilot didn't know how to
control the plane at that point it was
just a you know a few seconds a window
of a few sec
that you know they can make the right
decision but they made the run this area
and they they they try to pull the point
up but that's the wrong thing to do and
and and the plane has crashed just crash
into the ocean so the way that we look
at it i mean we look at cyber physical
systems first from a model point of view
so you want to sort of understand the
underlying the basic theoretical model
for things first that is something well
is something that we call a hybrid
system which is that you have different
types of continuous control usually in
in control theory you will talk about a
continuous system and you talk about
this one set of dynamics but in a hybrid
system because of the integration of
digital computation it's actually
several several sets of control rules
the continuous control and between them
you have discrete mode changes if you
look at it more mathematically basically
you have different modes in each mode
you have a set of say differential
equations defining the continuous thing
and then between the modes you have
decisions right if something happens if
the sensor value gets bigger than
something you do you go through that
mold and if something else happens you
go to you know another mode so this is
what we call a hybrid system people
would say that although things are part
of what we call embedded systems right
now and the the reason that we talk
about this new sort of few of cyber
physical systems is really you want to
focus on the integration of computation
physics and you know
you have company coming occasions
networks well in the usual setting in
embedded systems the problems you are
mentally dealing with is the limited
computational resource that you have but
that's not the I mean that's do that the
important part of it of the problem that
the really the key thing now is the
integration of digital things and let's
say analog things right discrete things
and continuous things and it's really
the hybrid picture that's that's
important here and the the most
difficult task is to cope with the
complexity of those systems and ensure
the safety crypt I mean ensure the
reliability of those safety-critical
systems so what we want to have I mean s
people start to work in this field we
want to have a a guiding road map right
a methodology that you can you can
understand you can use to to know the
things that you want to do on those
systems and by that it's usually several
things that you want to have first you
want to you want to definitely have a
language thought to talk about the
things you have right you want to have a
language to to model those systems and
you want to have a language that you can
specify the properties the questions
that you want to solve and then you want
to have a systematic theoretical
understanding of what you can do what
you can solve and that's the second
thing you want to know about the at
least aesthetical computability and
complexity of the problems that you are
facing in for those kind of systems and
then you want to have a systematic way
of dealing with those questions right
those those methods that you you propose
in a systematic way they should respect
the complexity of the problems and also
there should be evidence that you can
have realistic tools that can help you
to solve those problems using the
message and then in the end you want to
have a reasonable understanding about
how you can go from Cirie from Cerreta
models from you no formal things to
actual systems to a piece of C code in
your you know plant in your nuclear
control system so this is this is the
list of things that we would look for
you know in coming up with a methodology
and there are a lot of difficulties with
this just because of the the high
complexity of the problem there that
we're looking at so first when people
try to model cyber physical systems
hybrid systems we realize that the I
mean the I will I will come back to this
later actually it's going to be the
first thing that I'll talk about it's
quite difficult to have a formal
language to to to to contain every other
features that you want to have to
describe those systems it's hard to put
in say differential equations and you
know logical decisions in the same
framework of course there are a lot of
proposals but we're going to say that we
have a simple not single but a first
author a sort of standard logic that can
can allow you to express all those
things but that's not a very easy thing
to do and then very early on in the
proposal of hybrid systems people
realize that the almost trivial
questions about hybrid systems are
undecidable for instance rich ability
for hybrid systems with constant
dynamics really simpler than that having
to
two or three variables that that's
having a dynamic dynamics of one just
just this very simple constant dynamical
dynamics give you undecidable problems
because you can call Turing machine or
and do a lot of fancy things so there's
really a pessimistic I'll look at the
other problems it looks like nothing can
be solved right and the tools because of
this the tools that are proposed are
usually focused on various input
problems you don't you don't target at
say you know real realistic systems with
nonlinear differential equations and you
know very complicated the disorient
changes that the tools are not available
to handle those systems at all and then
there's a lot of research on hybrid
systems theory and the transition from
the Cerreto results to the practical
system it's not very clear so I'm going
to talk about the language problem first
I'm going to talk about the logic that
we're going to use what we need if we
try to come up with the language we need
to have several things right so the
first thing we want to reason about
systems that are in the Euclidean space
you want to talk about the real numbers
right it's not you know the digital
controls anymore and then you want to
have your usual logical constructions
you want to have bullying connectives
and you want to have quantifiers and
then you want to have all the real
functions that are actually needed in
the engineering of those systems because
the engineer's they're building those
systems already right and they have good
series of a good control theory you know
different different things that they can
reason about them and they know
partially how to beat the system
if you want to have a a journal
methodology at the minimum you need to
be able to talk about those functions
right and that includes you know
polynomials transcendental function and
differential equations and everything
else that is very much beyond what i
would say what we already have informal
masses i mean the the logic that we have
temporal logic no different kinds of
first other series there are really not
containing those kind of actual real
functions that we would like to have to
have this is why we first studied this
first order logic over the real numbers
with what we call computable real
functions this concept comes from
computable analysis so you have a real
function the the the the formal way of
understanding a real function is really
to look at it as a mapping from an
infinite sequence approximating your
argument of the function to an infinite
sequence approximating the value of your
function right so basically what is the
sine function it's taking a sequence a
cultural sequence approximating acts and
it's should and there should be
something that's giving you this
approximation to the value of sine sine
of X and if you have such a machine you
would say that this function is
computable so this all those functions
that are computable in this sense
they're called type 2 computable
functions it's called type too because
it's talking about functions on
sequences of integers which are like
functionals of those functions right so
it's type 2 and we don't need to go into
the deep serie of computable analysis
but it's enough to know that almost
every
numerically computable function is
computable in the type to sense so you
can have all those functions
trigonometric functions exponential
functions differential equations you
know even ordinary or partial
differential equations as long as you
have a reasonable procedure to compute
the function numerically we say it's
very likely that you can prove that its
type 2 computable in theory and it's
part of this set of functions so we
talked about the first author Siri over
the real numbers with arbitrary
computable real functions so it's lr f R
is a real number you know we talked
about things over the real numbers and
this F is the set of arbitrary
computable real functions so it includes
out functions that I just mentioned and
you can write down formulas like this
right so you can say this is something
that if you give it to engineer it will
look like something's that saying you
have two signals and you're wondering if
there's some coefficients such that you
know they're they're they're they're not
exponentially far away from each other
so this is the language that you can
describe I will later show you that's
the case as well that you can describe
almost every problem in say control
engineering or yeah this kind of topics
in continuous systems but of course the
trouble is you can write down those
functions you can define your theory can
throw in all those functions but the
folders are naturally undecidable it's
just too complicated because even the
simplest trigonometric functions
combined with arithmetic is able to give
you natural numbers and that gives you
an undecidable theory but then we asked
this question those homers are so
difficult to all to to to to to handle
from our perspective
then what is it the case that people are
solving engineering problems every day
right there there's got to be a reason
for for the the the you know the routine
procedures that that engineers can use
to build those systems and to reason
about those systems and the key of the
change of perspective is actually we
need to look at the American procedures
so we need to have a way of logically
formally understanding new market
position procedures that are used for
handling those functions and this is a
notion that we defined suppose you have
an l RF formula the formula that
contains out those computable functions
and all you can put it in a normal form
like this I'm not gonna this is this is
going to be easy to see you can push all
the negations inside and you can all you
need is to have these two kinds of
religions right there's a normal form
and we define the Delta weakening of
that formula to be something that you
only make biner change on the atomic
formers you change the zeros you relax
them by minus Delta okay so you call
this fee of minus delta which is the
Delta weakening of the former you can
also define Delta strengthening of loud
reformers by just use positive Delta but
we don't need to talk about that here
we're going to mention that later then
we define this notion called Delta
decision problem which is instead of
asking whether a sentence is true or
false you allow one-sided errors okay so
you say that your procedure can return
one of the following answers either fee
is false or fee of minus Delta
which is a relaxation a weakening on the
original formula it's true ok so again
you can define that fee is true or fee
plus Delta is false something like that
it's a duo of this they're all called
the Delta the same problem and the key
theoretical result that's leading to a
part of a positive outlook if using
those those those using this language is
what we call the what we call Delta
decidability over the reels which is
that the Delta decision problem for any
of those formers there the assumptions
that they are bounded which means all
the variables are bounded in inbounded
domains in the in the formula the all
those formulas are Delta decidable this
is in sharp contrast to the fact that
very simple formulas of that kind if you
only have the trigonometric functions
they are highly undecidable and actually
you can have a complexity mirror on
those sentences which is that you know
Sigma and sentence is just in the
polynomial hierarchy raised by the
complexity of the functions that you
have and the easy way of understanding
this is that I could tell you the smt
problem the exist central formulas
containing trigonometric functions and
you know exponential functions which are
all polynomial time computable
continuous functions in the type to
sense the complexity of solving those
formulas the existence of formulas it is
np-complete ok so that is if you don't
look at the delta T same problem if you
look at the the standard the same
problem it's an undecidable problem is
actually highly undecidable but if you
look at the the Delta problem it's it's
actually NP complete it's actually not
harder than the SAT solving problem
itself that is a very positive result
for this right I mean still Delta's do
and be complete but it's really much
easier than what we expected and then we
are done with the language we can start
talking about the models so a hybrid
system I just showed some pictures that
a real definition is something like this
so you can have a set of former it's
called the flow they define the
continuous dynamics for each location
each control mode and you can have a set
of Homer's called the jump that defines
the conditions for you to switch between
the modes and you have invariants and
the emergencies are the conditions that
says you know if you want to stay in
this mode if you want to do the
continuous flow in this mode you have to
satisfy some condition and the initial
the initial conditions are the things
that you use to start the system
everything can be written in this l RF
polymers because I just said you can
have differential equations the
solutions of differential equations are
computable there in the side of this F
and you can just write down all those
dynamical system continuous system that
you're interested in so the if you if
you look at this this otamatone and if
you if you sort of if you look at the
execution of those automatons you're
going to see something like this the
trajectory of hybrid atomic ax are what
we call hybrid trajectories they're
basically piecewise continuous you know
surfaces in the in the in the state
space because in each switch I mean in
the in
disconnected points it's the switch
between different control modes that
you're doing and if you let it go
through time it's going to be like this
and on the left-hand side is the notion
of hyper time that's used in producing
this picture because you can now can see
there's a time to be a two-dimensional
structure where you keep it you keep
track of the discrete changes you have
and keep track of the time duration you
you you have in each discrete location
and they have you can define a mapping
from here to here and that's the
trajectories we're talking about this is
an example of a probably simply a most
popular simple model of the hybrid
system which is a bouncing ball so I
didn't draw the ball here but the idea
is you start with some ball about the
ground and you drop it and make it do
free falling and you can have the first
day to be going down and when you hit
the ground which is that the the height
of the ball gets to zero it's going to
be is going to bump up right and this
this to moes will will alternate for
many times this is actually something we
have in our to that I'm going to mention
later you can just write down those
formers just on a in a simple text and
this is the trajectory that also we can
produce it from our tool but it's
something we just saw its piecewise
continuous right so there's like the
ball is going to bunt back
a few times and the velocity changes
based on the different modes that you
have and this is the more serious model
this is actually a faithful
characterization of this atrial
fibrillation problem so you can consider
the be hard as a hybrid system and you
can make transitions between different
modes and in each mode you have a set of
quite complicated differential equations
nonlinear differential equations
describing the behaviors and this is the
trajectory of the system that we can
produce by our tool as well so now we're
done with the language and the models
and we can start talking about the
questions we can solve we want to solve
about those systems usually we know that
giving any system we have the questions
are mostly of course you can have very
complicated problems but the the two big
categories is safety questions and lime
is questions and in the context of
hybrid systems most likely you either
talk about reach ability which is safety
property oh we're talk about stability
which is more like a lightness probably
because you're going to say that you
know it's going to reach to some point
such that the system stabilizes the the
former here is a bit complicated it's
not really in the language that is
defined because you quantify over the
trajectories that I'm going to explain
how you actually do them using the first
author logic that we just defined ok
let's look at reach ability first the
standard way one of the standard ways of
dealing with rich ability questions is
to use bound amala checking
so usually the what we when we talk
about bonding model checking we have in
in mind something like you have a finite
state system and you unwind the system
up to some finite apps and you solve the
question of whether some you know unsafe
property is satisfied but we can do this
just using the logic that we just talked
about you can have you can unwind the
discrete changes in the hybrid system
and then each change you have a
continuous flow that's defined by the
flow predicate of the system so you
basically start with the initial states
and you have a flow that's giving you
something like this you start with let's
say X 0 you start with X 0 and you take
some time say p 0 and go to another
value and that value satisfies the flow
predicate and it's like a solution of
your differential equation absolute some
some time point and then it's possible
that you want to make a jump from you
know from the the end of your continuous
flow to a new set of states and you
switch mode so basically you want to
encode the possible transition of the
whole system using this logic former and
then you say after k unrolling you have
the you ask the question of whether it
can be an N Save state right so this is
the first author encoding and here I'm
simplifying a lot of details actually
when you you don't see anything about
the mold environment here right because
actually if you have the invariants you
have to say something like you
the variance tells you that during the
flow from xixi t you should stay in the
merit so if you use the the logic
language to say that it's like for all t
within 0-2 TI the maryland should home
right so that's actually a exists for
all sentence if you write everything
down and then if you have non
deterministic flow it's even more
difficult because your first other
language cannot choose between different
possible flows you need to have you can
read it in the paper that you need to
have another exists intially quantified
set a variable saying that not only that
you are always in the environment but
you can actually follow all the possible
points and they form a one particular
trace in the continuous flow that's
something you can encode in using exist
for all exists so actually given this
encoding you directly know that bounty
knowledge hacking problem for those
systems I mean for right for those
systems the complex is actually if you
don't have a variance it's just you know
MP to the C where C would be the
complexity that you have for the
functions in your your inner system and
when you have invariants and then
deterministic flows you will
correspondingly have you know Sigma 2
Sigma 3 problems so you can easily
obtain all those complex see results
then the Delta the Syrian that we were
talking about it's a relaxation of the
standard the same problem right see so
here you need to make sure that this
relaxation is not doing any harm to you
and this is why it doesn't do any harm
basically if you use the Delta distant
procedures you solve this former you
solve I I omitted the
essential quantifiers I mean you out of
quantifiers all the variables with the
existing surely quantified so if you
solve the satisfiability problem either
you know that there's no solution right
or you know that there's a delta set
solution a delta set answer so that car
is found two two two two different
claims either you say that the system is
safe up to the depths that you have
unrolled it you have enrolled or the
system is delta unsafe which means that
you have found a solution to the formula
which is and you will say a bug to a bug
falsifying the safety properties that
you have but it's Delta cept which means
that your actual system may not have
this buck there's possible because we
may be wrong we may be saying we say
Delta sat Sally maybe actually unset but
we know that given some perturbation
this weakening on the former this
wiccaning on the system this bug would
actually be a bug right so so if you
think about it Delta we just said Delta
can be arbitrarily chosen right so if
you're an engineer you can choose a
small enough delta such that this answer
actually tells you about the robustness
problem in your system so that is why
this relaxation is actually helping you
with this analysis ok so with a delta
perturbation the system has a bug which
means that the system is likely going to
be wrong in practice in reality if you
have some kind of error going on and if
the delta is really small you really
should be worried and then another way
of doing reach ability another category
of methods is to use inductive
environments right so you want to show
oh that the system satisfy some safety
property because you can find a set such
that the system basically never goes out
of this set and that set actually
implies your safety property so you're
like doing an an induction proof
mathematically so using the the formulas
using the l RF formers this kind of
technique can also be easily expressed
so basically the idea is that you have
this formula encoding the variant and
you just want to make sure that at first
the system's starts from that
environment and the flow of the system
doesn't bring you outside of the merit
and the jump of the system doesn't
doesn't bring you outside of the
American as well and then in the end the
American actually implies the safety
property right so one difficulty in the
standard approach to this is actually
this flow part so in discrete systems we
can say that you know you're in the
American now and in the next step you
should not go outside of the United but
in a continuous system you don't have
this notion of the next step right you
don't have the next time point to talk
about and you don't know what to write
so there there's a lot of research going
on saying that for instance you can't
consider the essentially the vector
space right and come up with something
how the differential invariant such that
you you can just look at the derivatives
of the the right hand side part the
right hand side of your differential
equations and make sure that they do not
bring you outside of the nerve
but there are many tricky problems with
that approach actually we are not going
to going to go into details there but
what I wanted to say is just using this
logic that allows you to write down
differential equations actually you can
now throw in a really small epsilon that
is good for you modulo Delta two Delta
decisions that that the Delta design
correctness guarantees that you're going
to make you can you can choose the
absolute search that you can directly
write down this this differential
equation and ask you know the next step
is actually this absolute staff so again
you can Delta decide the former's that
you just listed here here actually what
I omitted was the universally quantified
variables right all the variables should
be universally quantified and you should
ask a solver about by there the negation
of that formula is satisfiable and if
that is not set viable you will say true
you say that the American actually holds
and if the formula is satisfiable you
have found a counterexample to the proof
rules for the inactive invariant and
when you can claim using a delta the
same procedure is that the variant would
fail and there you know again delta
perturbations so this is how you could
use the death of decisions to do and
bounded rich ability checking and of
course the most difficult question is
how you can actually search for those
inductive your errand and there are
methods like template based search where
you leave out some parameters and those
questions can also be easily encoded
because you just need you know one block
11 more alternation of quantifiers and
you can show throughout the results
saying that the template based search
for invariance is like Sigma 2 to the
sea you know things like that they're
easy to their results that are easy to
get now the third the other type of
properties that we usually worry about
for you know hybrid systems is stability
right but bounded times stability is
really can be can be encoded just as
reach ability and you can define no
trains like founded Delta stability and
you can again give complexity claims
about that's why I call it a a general
methodology it's really you write down
things in this logic former which gives
you you know for free all those
complexity results for those problems
and am bound a time stability is like
it's a bit like termination as for
programs it's something in turn instead
of the ranking function that you're
looking for you will look for layout no
functions and you have conditions for
the the admin functions work to
guarantee the stability of the system
and all those who can describe that it's
logic I just won't write those formulas
anymore so I just want to add in this
part about our tool that can actually
solve the former is that I just roll
down in all those slides right this
available at the reel web page you can
find it on my homepage in and if you
just Google for d real and pretty sure
you can find that it's open source and
it can handle all those functions all
those forms that i just mentioned and
for hybrid systems we have a friend and
where you can actually put in the the
hybrid system description said I just
there
I just mentioned and you can ask about
reachability questions and different
things so the tool is actually quite
scalable I mean we proved complexity
results saying that it's not much hotter
than sat is not much hotter than this
you know NP complete problems that you
actually routinely can't handle we
actually also see this in the
performance of our resolver we have
handled formulas generated from Bonnie
model checking of some complicated
systems that I probably show on the next
slide that contains hundreds actually I
forgot 800-900 or variables and they
involve again like 200-300 nonlinear
differential equations and you can
actually solve them and there's no
serious limitation on the signature that
you can have in this tool because
basically you could recall that our
procedure or are using this numerical
algorithms and as long as you can
numerically compute something you can
put that as part of your your-your-your
design procedure and you can Delta
decide those formers so in the tool we
allow those trigonometric functions
differential equations and all so we try
to to handle models from many domains we
are working on car transmission and
flight control and we have results on
biomedical devices and cancer therapy
and we're also doing power system which
contains a large number of differential
equations with trigonometric functions
on the right hand side that are really
really big models this is just to show
you a few systems that we can handle and
I won't go into the details of them that
you can see that they're complicated
financial equations and
this graphs are showing you the the
solutions basically if you want to solve
a rich ability if you want to answer a
rebuilding reachability question we can
give you a witness for a four and for
the answer that your system can actually
tell to reach your your your your goal
so those pictures they're actually quite
than trivial I mean each line is it's
actually obtained from a trace of how
long is its and how the birds really big
so it can be like okay go up to a
gigabyte no not yet right but but it
could I mean it's yeah so it's it's
actually quite non-trivial to produce
those those graphs so now i'm going to
go more into the design or synthesis
problems into those hybrid systems and
the reason that we we can talk about
them is because we realize that and not
not that we realize that it's just them
everyone knows that it's just about
solving the same type of formulas that
asking for more the solutions for some
different variables right all you need
to do is to parameterize the dynamics
that you have in the system and you want
to say you want to ask the question that
how do I design the system such that
within a certain amount of time you can
reach a particular goal and that is
simply what you can write down with this
logic formula and you can just solve the
the decision problem of this and you
will get a
a list of solutions for those parameters
present here notice precisely speaking
when we talk about delta T Syrians Delta
weakening you are actually ensuring that
your error is on the right side right on
the knot and in the the correct side I
mean your IRA is at actually helping you
to debug the system and if you want to
solve the parameters actually you will
need Delta strengthening instead of
Delta weakening because you don't want
to say that there's this solution may
work if you have some perturbation right
you actually need to say that this
solution should work if you I mean
regardless any possible to perturbations
that you have it's the deal of the
problem and actually doing the Delta
strengthening is not an easy thing so
this is why synthesis problems in this
domain is hotter Al is harder
practically than the verification
problems it's just because to get the
Delta strengthening of formulas to solve
those you need to have under
approximations of the solution sets
instead of the old approximation of
solution sets which are actually the
assumption of all the current algorithms
in this area so the formulas that we the
algorithm that we implement in our tool
they give our approximations all the all
the audition procedures are usually
targeting at verification problems which
require you to give over approximations
and this whole direction of doing under
approximations when you solve the
former's it's it's it's just starting
and this is something you need for for
synthesis problem but for now if you I
mean we do handle those problems and we
can do a simple design verification loop
because you can sort of find a solution
and then try to verify that it actually
satisfies your property so that you you
know so that you throw away the error is
under on the bad side so you can do
things like that for now but in general
you would need a new set of solving
strategy and you can also do a lot of
fancy things that are usually talked
about in control theory you can actually
do optimal control here and just using a
simple formulation of the thing
basically you want to reach some goal
and we also want to make sure that the
cost of your control design is actually
at the minimum okay so usually although
here you have one more alternation of
universal quantifiers you're usually
okay with replacing this by some some
goal that you want to have so basically
you don't you don't have to find the
absolute minimum cost that means the
control plan that gives you the absolute
minimum cost but you are okay with
finding a plan that's giving you a cost
smaller than something right so you can
usually approximate this universal
quantification here and then I'm not
going to going to go into the detail of
more things but you can do them it's
just a matter of looking at the problem
statement and encode them as logic
formulas and then understand the you
know solubility complexity and actually
having solvers that can actually solve
them and in general you could think
about a sort of algorithmic control
theory and this is probably a term
that's used by others as well for maybe
different meanings but but basically you
can think about encoding all those
control problems into the appropriate
logic formulation
and then you can you can you can you can
use logic solvers that like the ones
that we just saw to solve this problems
directly without you know any manual
work right you could provide some
heuristics that are filled in into the
solver that you provide this interface
that the control engineer could just
write down the question that they are
asking and you're just directly calling
the decision procedure to solve the
problems for them this is really like
lifting what people are doing in the
linear differential in the linear
dynamical systems to this nonlinear and
hybrid domain right in linear systems
you usually would have a program running
linear algebra and there are very clever
algorithms going on that if you are
beyond that scope you basically have no
systematic way of doing things but now
we're basically saying you can just
write down those formulas in a formal
way in a logical way and then use the
automated reasoning tools which are just
extensions have you know the algorithm
that you probably originally had but
there are now having you know logic
capability for doing the logic decisions
which is the hybrid part of your system
and the capability of handling nonlinear
differential equations which is nothing
a part of your thing the whole prompted
the whole framework becomes this
formulation first and then solving next
and then you're done so the hope is
really to have scalable solvers that
includes that contains all the
computational power you have your usual
standard algorithms and put them in this
logic framework that you can you can
just use to solve those questions
and then I in at the end I want to talk
about this mapping from realist and from
theoretical models from formal answers
to the actual programs that you can
actually have in those systems the
observation that started not just all
work but I am sure everyone else's work
as well is that the embedded software
although their very safety critical
they're very complicated they're in you
know this they have all those those
difficult continuous mathematics going
on but the program structure itself is
actually pretty simple if you just look
at what he run I mean the sulfur in your
car actually we we have practical
experience with some of that you would
see just a big loop you know running at
certain frequency and we've seen that
loop you have you will rarely see very
advanced programming techniques right
you most likely you don't even need
pointers you would never have recursive
calls you never have complicated
programs constructs and that if you
think about the problem problem in more
detail you see that it's really i mean
the gap between the cirrhotic model and
the actual code you have it's really not
that big I mean the gap is not that big
basically if you have a hybrid system
that you can directly write down any
tool you have the differential equations
defined and you have the logical
decisions then the the car is found of
course this is a very simplified thing
that
but the basic idea is this right you
have this big loop and you just have
different cases and and and you switch
between them and each time you execute
your your program up to a delta T
duration okay so you're basically just
translating the differential equations
into difference equations that you have
in the program and all you actually need
to do is to prove that the program that
you have and the Cerreto hybrid system
model there you have there are you know
they buy similar each other up to some
error bounds and that error bound of
course is related to the delta T that
you pick the the behavior of the
functions say the Lipchitz constant of
differential equations that you have and
some minor things but the big structure
is really something like this so this is
a simplistic picture of what people are
now are now calling the model-based
design idea right so you have formal
methods you have verification and
synthesis on the model level and then
you would directly generate code from
that model and most likely all you need
is some mapping from the variables that
you have in this erratic model to the
commands that you need in the program
and then you need to prove the
faithfulness of this translation from
this erratic model to the programs and
that is the task that's much more easier
much easier than the direct code
verification that you can think about
say you take this Selden's tens of
thousand line of code from a and
embedded software I want to basically
reverse-engineer the original control
design that is a very difficult problem
but if you if you go from the model
first if you verify your property
and then verify the translation is
useful is reliable up to a certain error
bound you can actually do this right and
actually this is something that we are
trying to do it's a real small robot
that we're currently building at CMU the
property that you want to ensure so it's
just a very small car it's just it's not
email cards two big wheels and and one
small one for balancing and you want to
program it so that it can run in any
room and it just it has sensors on it so
that you want to verify that it doesn't
it never hits anything right he never
hits a wall a person walking by and
there is anything that's something that
you can verify on the model level okay
and also to to have that you actually
need to synthesize the controller for
instance the the small robot will see a
wall and it needs to reduce its speed
right and you need to reduce the
velocity and then what's the
acceleration that you want to give for
that and that is something you can
directly synthesized by solving the
logical formers describing the questions
and the model that we have and not pay
showing it here but it's really ages one
page hybrid otamatone just like three or
four control modes and each mode is
really not very complicated differential
equations it's really a small thing that
um we have a student from mechanical
engineering who doesn't really care
about the you know the logic Syria or
something d he just learned about this
hybrid otamatone language that we have
and he made this and he's making this
robot and then we're going to just
generate the code directly for the robot
and see that the formal properties that
we verify on the model can actually
you know you can actually witness that
in practice so this is roughly all I
want to talk about the message is that
there is this promising framework based
on the appropriate logic containing all
those functions that you have or whether
in the Euclidean space and all and you
have a tongue automated reasoning and
they're lying the the logic and the
usual difficulty either in serie or
practice can actually be avoided by our
formulation of this Delta problem Delta
the same problem and or Delta H ability
there are all the reasonable things to
ask and then this gives you a new set of
techniques to handle nonlinear and
hybrid system control and the practical
tools that we're developing oh you know
the power is going to keep growing and
we think it's very promising and the
future work is that you want to handle
more complicated models and also now
that you have the logic solver you can
actually basically translate all the
sophisticated verification and synthesis
techniques that you have in other
domains in hardware and software domains
to this field and you know improve the
state of the art greatly so that's
that's all I want to say thank you
excuse me
posted
so much for me
operator
yes because usually do we so much proof
is altered exactly exactly i do
so that's so i think it's actually open
whether the size of function itself so
if I mean just adding this one single
function gives you on the side of it I
think that is the open there are some
constructions in the papers and you can
easily show that is undecidable if you
have more complicated computable
functions I have some papers that can
show you and yeah so my guess is
actually for founded problems if you
have the sine function itself it doesn't
give you any size ability but for a bit
more complicated function
we would have
problems
the other side because it's not much who
framed in your position right is a
corresponding bout in skin smooth
deal with friends we were discussing
tragic cigarettes you can find a
reference
is that most exactly so yeah I remember
seeing some very complicated
construction about how you I think it's
mainly about how you can encode Turing
machines using the yeah using the design
function itself just just using some
function and it the construction is very
complicated I remember and yeah actually
I don't know if it's due in our current
version of the paper but I think we put
that as a question like open question
like is it possible that it's found it
and you don't have to i'll tell you just
design function itself gives you decided
yeah yeah Lucy the size two poles I
thought initially equations with lots of
sure
that bunch of food environments right
exactly but what you do have a X you see
the whole exactly that's really it's
actually I shouldn't write it that way I
was just simplifying things just to show
that you can do things but oh yeah so
what you need is to put the so actually
we have this this you right so the
control is the new variable that's the
thing that you really want to encode it
so so here right so here I'm not talking
about this difference between the
control in the plant so I was
simplifying yeah so usually you just
help you and it's some other
differential equation that you put in a
difference equation form yeah because
basically you don't have like a social
meeting is that the next is that if we
act is that place exactly that's that's
what we were doing for the small robot
here actually we will allow the user to
to clarify severable to be the sensor
variables right and we leave them out in
the synthesis I mean in the occult
generation and if we run a simulation of
the thing we can actually make a product
of you know the control itself and the
plant model which itself is also another
hybrid otamatone that gives you sort of
the signal so for instance if you have a
map of the room you can put that in
terms of a hybrid system that give you
different sensor data for a different
time so you can take the product of
those 20 times and I have this full
thing running for a simulation and then
for code all you need is the control
part nice
I never each other water environment
exactly but because I
how small early because you can have
people running for that little book so
that are watching our sins right that's
definitely related to the to the actual
parameters you have and we can for
instance the velocity of the vehicle is
a wrench so you would your property will
likely be that if you don't have an
object approaching your vehicle with a
velocity higher than something okay is
that so so I mean like relative to yeah
yeah so so so the final formal claim
would be well anything that we can
actually verify on the model and that
will contain those parameters nice yeah
so it just have a big thing heating on
the robot of course they can avoid that
so Anders on the side
it's ready so this is the the front end
we have arterial for right 40 real or
the reach and whatever we call so
basically you write down this hybrid
system of thing and yeah we just want to
follow this Cerreta Colo for managers
are you marrying the same thing and the
flow he gets a differential equations
and the jump it's just it's just as in
people so and we generate the SMP
formulas so from this and yeah so so so
this is the front end for Bonnie model
checking and we're right not doing the
invariant based reasoning and now then
that's actually a would be a simpler
script that you can write I do generate
the phone line and each is no camel
right yes yes right right it's red it's
a friend
but useless walk then just be a boxer
for to do it has some there's no
computation and just translate they're
just like resistant i wrenched thank you
too when we get to Daniel I see what do
you plan trav like some I think like
Porter fluence all this we want to check
maybe we can do some abstraction oh yes
yes yes yeah i was mentioning that all
the techniques that you have in our
software verification they should be
built in to this and you can just scale
up to more and more complicated models
yes it is one of the drawers starting
point that yes you can add things into
it and yeah and so homemade it open
source so book your social it is a
policy yeah exactly nvm cell service
just anyone can really capitalize words
that transition to the
don't you need to is a stop doing them
we go again</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>