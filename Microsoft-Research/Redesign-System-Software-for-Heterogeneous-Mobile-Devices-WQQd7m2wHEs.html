<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Redesign System Software for Heterogeneous Mobile Devices | Coder Coacher - Coaching Coders</title><meta content="Redesign System Software for Heterogeneous Mobile Devices - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Redesign System Software for Heterogeneous Mobile Devices</b></h2><h5 class="post__date">2016-06-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/WQQd7m2wHEs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
hello everybody this is my pleasure to
introduce Felix lean from Rice
University he works with Professor leans
on his research is in the area of mobile
and variable systems especially he tries
to develop no level software to exploit
the emerging features of those devices
and for his work he recently got the
base paper ordered at s plus and today
in his talk he will talk about that
recent work and few other works that he
did in his PhD that acrylics ok thank
you sooner hi so have you guys ever
wondered if we can spend one mobile
system over highly different processors
for both performance and power
efficiency so you might work I will
redesign system software to make this
happen now let's start from why we
should do this part efficiency rules it
has become the major concern for many
many sisters from sensors all the way to
big servers for example in meting cases
if we have better power efficiency will
naturally get a better performance
because we can switch mode transistors
at the same time for mobile people party
efficiency means usability because the
device itself will become cooler and it
will last longer for server people
higher power efficiency means dollar
millions of dollars saved from utility
bills so that's why everybody tries to
improve part efficiency so in this race
mobile is one of the pioneers reason is
that pretty much clear because mobile
device usually have very tight thermal
budget we cannot put a fan on the back
of our smartphone and also have a very
tight battery budget because of small
impactor the better thing is the two
budgets do not scale up over time there
is no more slow folder so let's see one
example from twisting a 2013 we see the
performance of a commodious smartphone
has scaled by 13 times but the battery
capacity only scale by 2 times
the phone factor almost does not change
so let's turn these evil Wars the
skating is like the skating is like the
other way for wearable devices for
example Google glass compared to a
smartphone into some eight in
performance scaled by 24 X the battery
is half and the phone factor is even
most even smaller if we don't design
we're buying our attic in the way things
can be very ugly so let me tell you one
true story so in our lab with this
experiment with wrong video chat google
hangout um Google ass after 20 minutes
the surface temperature of googas is 15
3 30 degree which is above the human
tissue damage threshold so that's
something you don't it's not quite
wearable now this is a pressure for high
power efficiency for mobile device from
the hardware side how about a software
side one defining characteristic of
mobile is a wider range of workloads
from the background always an
intelligence all the way to the
intensive Multi multi media workloads
and in the coming years we are going to
see this range girl for example for
natural interface and perception
workloads so across the whole spectrum
there is 1000x difference in power in
performance demand note that all these
workloads are hosted by one mobile
device and many of the workloads
actually are in the same application
ideally the mobile device should provide
power consumption proportional to
perform and so for example for the most
intensive workloads we want to keep the
power consumption or mobile device below
10 watt so device does not have to burn
our hand now for the background always
our tasks we want to keep the power
consumption below 10 milli watt so we
can still always run in a background
they can serve us from a literature so
there is a white paper a picture
community by the paper so they drag for
21st century
conducted research so they have this
numbers like the other long-term goes
that's how even more a visual school
definitely we should have targeted that
yeah so the thing is how can we how can
one mobile device provide 1000x core
difference so that's the problem now
today I recognize that approach to
achieve 1000x part power difference is a
is a hardware agility so the idea is
quite intuitive instead of having one
unified processor for all kinds of
workloads we should have different
hardware for different workloads so
ideally we can map different workloads
two different hard work we can meet the
performance demand and also have the
best part efficiency so however in
today's smartphone because we have to
achieve 1000 x power difference so the
asymmetry or the heterogeneity among
those processors have to be so high this
usually gave us no global hardware cache
coherence among those processors now let
me explain why let's look at a trade-off
between power and performance here yes n
we've had this for awhile Raven asics so
even the earliest i had a cpu the nail
said anything repressed for playing
mp3's yeah so it's just that the Hessian
ad was a set of single purpose basic
course that did one thing and you didn't
need cache coherence because you just
sent this point you to a stream data and
let it process right yeah so keep talk a
little about that world versus the world
you're talking about right so I thought
difference existed there as well right
so I think that two dimensions one
dimension is a symmetry now you have a
very different general-purpose
processors the art dimensions you talk
about is the specialization basically
you have a cpu GPU and a six I think we
can explore unless to post to damages
Jennifer Percy is easier for application
programmers to program okay so let's
look at the trade-off between power and
performance let's assume we have one
mobile device and is there is only one
core in this device if we want to reduce
the power consumption
for some light workloads we can do TV FS
so this is a classic technique basically
to reduce the clock rate and save some
power now if we want to further reduce
power consumption for some even lighter
workload we can incorporate another week
at all in the same coherence domain so
this is the case for our big little this
will give us an other 10 x power saving
but if we want to further reduce the
power consumption for some light
background always an intelligence we
have to have another even weaker call in
a separate coherent stormin so you may
have questions why do we have to have
separate coherence domains there are
many readers now there are top-three
realism number one how do our cache
coherence is complicated to design so I
talked to melon heart attack architect
is complicated to design by removing the
global hardware cache coherence it's
easier for Hardware designers to
incorporate multiple asymmetry course in
one mobile system still have assured as
this for servicing so at the lowest
level so that multiple ways to interpret
integrated multiple estimates right so
there could be shared memories there
could be non shared memory so from the
software perspective there could be
shared memory address space there could
be now like separating my manager space
I will talk to talk to talk about that
later so number one so it's easier to
incorporate asymmetric codes for
Hardware designers number two by
removing global heritage clears it so
course I loosely cut out it's easier for
Hardware designers to design final Grand
power domains so those power domains
could be independent inter on and off at
a wrong time to save power more
aggressively number three because we do
not have the global hardware coherent in
the connect the interconnect self cache
controller could be even know where
power so we can afford them to be always
done to serve the background tasks now
we separate coherence domains we can
have another twenty export saving for
this background
intelligence and software power so i
think we by doing in software we can
poach the complexity in software we can
it a software to define the policy yeah
it's a there's some debate so this is
the debate from 20 years ago but in I
believe you can do it more efficiently
in hardware these days but the thing is
that number one how do I is not there
yet number two we can more flexible
policy in in software by doing the new
software the motivation to save
appearance tonight right russia's right
and now you're gonna put your inspect on
top of that do we do we just throw away
old parish no this is a by behavior by
basically by implementing the crash
course in software we can decide for
example this domain this lets the state
is not coherent this state is coherent
basically like software-defined memory
coherence yes it sounds like you just
said you want to push more complexity up
to the program and they have to think
about how did as Catherine's across
these four incidents so it's our job to
deal with the complexity I'll by us I
mean a system software designer not blow
to programmers okay I expect you're
going against this but I'm curious to
see how this is going to manifest in the
programmer in the end because I expect
we can't hide this with layers of system
software I definitely yeah yes we should
expose something to the programmers
right I will I will talk about that okay
so because of the motivation right so
hopefully across the whole story we can
achieve 1000 power difference in one
mobile device now the design of multiple
currents domain actually is not is
everywhere it's not some research ideas
is is known in today's mobile devices
from wear bows to smart phones to
tablets for example if we look into
iphone 5s and a member of iphone 5s we
not only have the high power high high
performance a7 processor for demanding
tasks browsing video streaming we also
have the low-power processor m7
for background tasks so they do not have
a hard work at claris which means they
are your separate coils domains now with
this architecture let's define our
architectural model more concretely so
we assume there is one mobile device and
there are highly asymmetric course in
this mobile device hosted by several
coherence domains there is hard work
edge coherence within each domain but
not across domains multiple cores in
different domains can talk to each other
by message passing like hard mr. passing
at the lowest level and they can
interact with each other actually so
with this architecture the holy grail
for software is to span across multiple
areas domains for power efficiency and
performance let me use one example email
synchronization so in the email
application you my email application the
background synchronization elicitation
tasks that'll run in from time to time
should be able to run under low power no
course in the local domain we call it a
week domain now the flashy shiny user
interfaces like email composition should
be able to run on a high power course so
we can have the best power performance
for the pestle performance and also the
best user experiences now there's two
parts are running in one application and
they do share a lot of states within one
application for example email contents
convert a cute thread search index and
even remember that database cash so to
c2e2 realize this scenario the biggest
problem is there is no coherent memory
program state supported by hard work to
see why this is a problem let's look at
the good old days to say how software
can easily span across multiple cores in
one coherent machine let's say we have
four calls in one coherent medical
machine this is the case for our laptop
for desktop for most of the cloud
servers each of the color has its own
cash the cash are separated but keep
coherent by the hardware let's say we
have an OS easily can you despair across
all course OS could be linux windows
all this legacy OS so let's read let's
say we have a good thread running on
call zero the thread make a cisco to
create a circuit as part of cisco
attached some state which will be cast
in code 0 sketch here later let's assume
this thread has migrated to khartoum you
can use the socket s that is created
previously transparently because the
hardware we automatically propagate the
cash update from co 0 to call to so all
this is done in hardware neither the
euler's read nor the OS has to take care
of this this is transparent to them
everything is simple now in our types of
teacher things are different we have
separate coherence domains the hardware
will automatically propagate the cash
within one domain but not across domains
so the interdomain communication
requires explicit software operation
which is way slower than hierarchical
areas usually by orders of magnitude so
to this end my work is to enable
software stack from application to OS to
span across multiple queries domains to
achieve this goal I have three design
objectives number one we really have to
simplify application programming because
there are millions of mobile
applications are up there and they get
used to unify the memory of you and the
one single OS view and the number two we
have to simplify OS engineering because
mobile OS these days is a huge clipes
Android has 1 million lines of code we
just simply we cannot like build
everything from scratch number three we
cannot sacrifice performance nobody
wants to use a slow persistent and under
the same level of performance we want to
maximize power deficiency now to achieve
the three design objectives I will
redesign system software in New
redesigning I will follow through it
design principles number one because we
have a symmetric hard word right now we
should build a symmetric system software
yes so we're dealing with the
disparity course and enter spaces you
can think about a single OS image
without patience panning in for multiple
OS images mm-hmm with treating them as
little system with application with
breaking apart application to different
services or pieces depending upon the
car see what how did you decide to go
with a single or similarly single
application and a seamless view versus
one that explicitly race apart these
different domains and asks the
programmer to reason about that by
building services for each part right i
think the Frog application program model
you can say later we still require
application programmers to specify this
piece of code goes to strong demand this
piece of code goes too wigged on it so
that's the only thing they have to do
basically implement different threads
for different domain but we do provide
the unified memory address and one
single OS in each appointment so that's
our approach okay so going back to the
principles we follow number one because
hardware we have hot asymmetric hardware
so we build a similar to existing
software number two we were at a
software-defined memory coherence
basically which means the policy in
memory coherence and which state is
coherent shared and which state is
replicated now shared at number three we
will refactor existing system software
rather than building everything from
scratch now really you do this so if you
tell what is not there you said about
the Apple II seven and the m5 being
percent right today it's frankly there
so what kind of coherence to the
implement the implemented in software or
is it hardware right so right now I'm
good collaborator but I give you some
forecasts basically they try to talk to
this problem the Apple just does not
allow you as a application program
through at any application for the m7
they will provide you some predefined
libraries because they don't have a good
programming model yeah
so okay so my work has two major pieces
number one to enable user programs to
spread across coherence domains and the
number two to spend a single OS image
let's start from spend single user
program as we mentioned before the
biggest problem the biggest challenge to
write an application for this
architecture is the program state is not
coherent right as soon as I mention
today's state of the art program
framework tries to dodge this problem by
only allowing application programmers
write application for the strong
processor for the main processor here
right so there some research here in
that actually by the fund hardware from
the lowest lowest abstraction so they
are in separate car instruments but
there are some research building some
severe memory to bridge this to memory
address spaces yeah thats related that's
relative okay so the state of the art
you only have an application for the
strong demand for the most powerful
processor and vendors like Apple
Microsoft will provide the libraries
only available for the lowest lowest
lowest power core so at the wrong time
the two pieces of code will talk to the
other msg pass it so this this approach
works right but there is very inflexible
and actually incurs a lot of development
overhead right executing is that they
provide a library interface that does
much as we must be a service yeah yeah
ls1 in there are actually we're like a
journey yeah so can we do better we
really want to enable one application
entirely from the application developer
to span across multiple instruments but
here in order to enable this we have to
face the challenge how do we relieve
programmers from dealing with
non-coherent program straight so our
solution is called reflex reflexes that
super sheer memory is one layer below
the application so the idea is kind of
intuitive we will implement the software
cache coherence within our this layer
now you may wonder what's a novelty
right the distribution shared memory is
out idea from 20 years ago when people
are talking about running one
application across multiple machines in
one cluster but those classic design to
not serve our purpose will because one
of our major design goals is to enable
energy efficiency so we have to adopt
this asymmetric design we have to keep
strong domain powerful processor in
sleep as much as possible now let me
give you a minimal example to illustrate
how does this asymmetric design work
let's see we have two coherence domains
why you strong hosts the powerful
processor wine is wick hosted the
loophole processor and both of them
share one memory object which is an area
here so according to our design any
shared memory object is always hosted by
the WIC domain which is which makes it
home now if the strong domain wants to
access the memory object it has to send
that request to the WIC domain ric roman
will respond and the memory object will
be copied moved from the home to a
requester from the wig guy to the strong
guy so this is natural on the other hand
if the week domain tries to access the
memory object here it cannot send any
requests or it can do is to passively
wait until you're strong domain finishes
accessing the memory object and the read
it back so the WIC domain can go ahead
to access memory object so this is a
minimum example but hopefully you can
get the asymmetric flavor here now the
memory model we build the release
consistency which is very standard we
implement to synchronization primitives
acquire and release so in propagating
memory updates two domains are
asymmetric again the strong domain will
eagerly propagate any memory updates to
strong domain to the WIC domain so it
can itself the strong term itself can go
back to sleep as soon as possible just
to save some energy the wig domain on
the other hand will do this lazily so
you were only propagate the memory
updates to other guys when it's being
asked so this is try to avoid waking
other domains from sleep because of the
coherence communication now again this
is a symmetric design this is for power
efficiency yes David option if you have
this you always have a ordering among
your domains so what happens if you have
domains that are not clearly ordered say
a GPU and ESP programmable processor
that where it's not clear which one is
the strong and the weak right now for a
for a general purpose program you have
right so that's again that's another
dimension of the heterogeneity that's
their specializations I don't have a
good answer for that but i think the
here we try to address the asymmetric
general-purpose processors so we have we
do have a clear order for that but the i
think the there is one we didn't work to
that they build some tea to be sharing
software did we share memory between GPU
and their cpu and as they try to use
this similar asymmetric design for that
but the in that case they make the GPU
always hosts the shared memory objects
so the bottom line is I think the
asymmetric this sort of a principle
could apply to that case as well but it
would definitely we should sort of a
rethink how to deal at another system
okay so so that's about the overall
design of reflex but we have to
implement this right we have the
beauties so today I as I mentioned there
are many many mobile devices have
asymmetric multiple coherence Thomas
mobile processors you want in one mobile
device but back in Tucson 11 we don't
have this flashy shiny devices Technic
hi so we have to build some dangerous
prototype ourself so what we do is we
took a nokia n900 phone smartphone from
the market which was nice shiny
smartphone as many other smartphone
nokia smartphones it has this a nice
camera but we have to remove the camera
out in order to access it's a peripheral
bus so we build a custom board with two
low-power processor a signature loop a
processor on it and we hook the board
with the modified and 100 smartphone and
boom we have one of the earliest
prototypes in the world with the
asymmetrical processors multiple stories
so if you look back today actually the
tulip whore processors were used before
in early the early days are actually
used by people this year's right iphone
5s and moto x so they are using the
processors we have used people so
something interesting so based on this
hard report hype we implement reflex and
we were able to spend one application
across three different processors and we
can gain one order of magnitude higher
party fishing straight for applications
yes again we give those to several
things go here before another so there
are three go here and so and yes yes yes
yes those are both kind of like
multi-core processors right single core
right also we are single call so back in
that high we don't have we even don't
have multi-core for smartphone so a 900
single call okay okay so this is about
reflex to just briefly recap we build
that distribution memory you software to
provide unify the memory address space
to application so application can
usually spent a course mark ocurro
snowman say yeah so where's the cash for
each of you so actually I losi they
probably have their little l1 cache but
definitely they are not coherent they
have separate text yeah I know you used
to that we can but they have their
separate memory right so it's different
physical memory so that cast actually
does not matter that much you have to do
message deposit explicit method passing
be chillin with respects to see you
creates managing some cash yeah sure
that's how do I care how do I cash yeah
okay so that's the first p domain what
is the definition of coherence there is
no coherent right but I wish feel quite
personal Magister because we are dealing
with multiple cores yeah yeah so each
coherence domain doesn't implement any
kind of coherence you just are we will
see a mud mud horse multiple clay home
decor sinclar his stomach so because
this is a kind of early systems right so
we will deal with more complicated
system USA yeah yes Andrew so in terms
of overhead systems you know if the
current funds that have these different
ports are they using one shared physical
memory or like the new iphone
implementation do they still have
different I don't have that okay yeah
yeah yeah stay tuned and okay so that's
about that spending user program that's
a first piece let's talk about the
second piece how do we spend while I'm
single OS image across marble quarry
instalments so this may be more
controversial you have multiple
questions number one why do we have to
spend single OS images right can we have
a like canopy in the OS have mixed OS
available only available on one coherent
stomach in this case let's see we mix
the OS only available under strong
domain to say why this is a problem
let's use an email example again see the
gmail synchronization a little bit more
background the email synchronization
task actually is a particular so this is
some research result from Microsoft
Research every day in our smartphone in
standby mode the gmail cyclization task
will consume about a fourteen percent of
battery life in Steinman mode so this is
a lot of power it would be nice if we
will have a symmetric processors would
be nice if we can run the email
secularization task in the low power
cord here right so the strong core can
go to sleep remain in deep sleep mode so
we can save energy however with the OS
Odin available on a stronger man this
does not work because all network
activities from the American Task have
go through to the OS which is on the
strong core
yes because say the same thing about 30
mission 10 years ago people would say
that you know sensing and proximal
durang's talking with ALS and guess what
super their eyes to do that you go to
wipe on today and you see it didn't get
a microprocessor with librarian xray
that can actually sense all the sensors
do the processing over there why not do
something like that for that 10 most
power consuming tasks on the phone
emails right so i think the the pot the
question is do we need OS support for
the background task or not my personal
beliefs is we definitely need more and
more or the other ones doing the studio
is itself right these are two different
yes yes yes yes so emails inhalation is
why example right you definitely want to
for example create a circuit there and
use it other ways i will get the platter
later and another example is a David Lee
they have this perfection application
profession task which could be running
in the background from time to time so
in that case you really want to have 10
s right so I think that there are more
and more compelling cases to have a West
support I don't know power domains no
power cords okay so basically the idea
here is we cannot make the OS only
available to a strong domain because in
that case the background cast will we
have the stronger may from time to time
because it has to use the OS services
now can we mix OS owning available on
the WIC domain that does not work either
because the week domain low power was no
performance that will mix OS to be the
performance bottleneck of an entire
system which is not which is does not
work as well now another alternative
design is can we have separated OS 6 10
s for each domain for example OS one for
the wicked oh man os/2 for a strong
domain this does not work either because
the true oasis have to collaborate to
manage many resources in the system
therefore we have to modify many things
in to oasis from memory management all
the way too many bad drivers this
requires a lot of overhead in
Engineering the OS so application
programming is complicated as well like
I mentioned before if you have a
application running iOS to you create a
socket you cannot reuse that socket
always one because they are separate
less images so this gives a lot of
headache to programmers now we are clear
what we really want is one single OS
image across multiple estimates but how
do we do that how to design such an OS
so we first have to decide this
structure of the OS one central problem
was central concern to decide that
anyway structure is how is software
state shared among OS component now from
1978 this classic people basically says
there are two fundamental away
structures in today's world basically I
shared everything and shared nothing
shared everything is like Windows Linux
the entire West is what coherent as
supported by Hydra coherence or most of
the time sure that nothing is you have
multiple OS components they have their
own separate a memory address spaces and
they will talk to each other pregnancy
passing now which of the 20 s models to
OS structures with our purpose will
neither so to motivate our decision
let's see one key observation we have if
we look into today's mobile OS mobile
kernels for example Linux we can roughly
categorize or OS components or we call
your services into a few sets once that
is co services basically they are like
this small infrastructure of the who s
performance critical developed by small
number of people virtual memory pager
allocation scheduling etc on top of
course services there is a large of
there is a large set of extended
services like the best drivers network
file systems so they are large in number
and their develop a lot of people
Microsoft Google samsung actually there
is a ecosystem behind them so compared
to cost services they are less
performance critical now with this multi
voices upper division we propose our OS
model we could share the most OS no
so basically the core services small set
performance critical are replicated as
shared enough instances so why is this
for each coherence domain on top of
course services the not number of
extended services can be transparently
shared across coherence domains so their
source code could be reused if we try to
plot our OS model into a spectral of OS
structure you can see where somewhere in
the middle like here this is because
we're trying to find a balance point
between the years of engineering
programming racers the performance and
power efficiency now with the OS model
let's see let's build OS but before that
let me introduce one important hard work
background so we have been talking about
multiple instruments in one more
assistant but in real world them two
major ways to integrate them in one
mobile system so number why is coherence
domains on separate chips like people
mentioned previously so in this case
each chip each coherence domain have
their stupid memory and i/o and as
multiple chips are connected through
some relatively low speed high latency
proved robust like I screw CSPI that's
it that's a case for example our reflex
prototype we have three different chips
and also for iphone 5s two separate
chips so that's the first type of
integration the second type is a
coherent domains multiple instruments
and one single chip for example in this
case there are two cohorts domains and
one thing and one same cheap most likely
to share the same set physical memory
and i/o i will give concrete example for
that later to add one more twist to this
big picture sometimes this true types
integration can coexist in one mobile
system for example in this case this
chip can have multiple instruments
inside of it now let's look headed to
type some delicious again coherence
domains are several chips and on same
chip now with this
grant let's try to implement our own or
less because reflex was targeted on
multiple chip case it was natural for us
to try to build an OS across multiple
chips like this but back in that time we
found this problem to be really
difficult because the physical memory
are separated and the interconnect is
really slow so we do have a lot of
concerns back in that time for example
how do we ensure performance of the OS
because OS is such a performance
critical piece and number two should we
build everything from scratch what kind
of components can we reuse and number
three do we have enough at picture
support to build such an OS back in that
time we did not have good answers for
this for this design questions so let's
see let's dip what let's take one little
step back we try to build the OS for
some a little bit different a picture
which is the second type of integration
we wear corsa slightly title couple in
one chip so advantage is that we do have
shared physical memory and the
interconnect is faster because the
interconnected isn't cheap so these are
good news for OS designers like us so we
will build OS for this architecture
first so the hardware platform we chose
is a TI OMAP for this is a popular
mobile system chip has been used in many
popular mobile devices from we're both
too smart phones to tablets on the cheap
of emm for there are two coherence
domains one coherence domain host
different type of course so for example
we have a9 core in one coherence domain
which is for you know powerful demanding
task and we have em three core for the
week domain which for background tasks
they do not have global head of a cache
coherence and they can share the same
set of i/o and physical memory they talk
to each other different cars in
different domains talk together by
Hardware message passing so this is
hardware support they can pass around
32-bit messages the very short very
short messages and therefore they can
interrupt each
now by applying our share the most OS
model to this a hard work picture we
build our experiment OS we call k2 which
which is a mobile OS spanning
heterogeneous coherence domains so k 2
instead of k2 on top of two coherence
torments we have two Colonels one kernel
for each Clarence domain instead each
kernel like we said before Cole services
are replicated one instance for each
coherence domain on top of course
services there is a layer of OS level to
the shared memory which present the
illusion or extended services as if they
are running on a 40 coherent machine so
we can reduce the source code from all
those extended services so let's talk
about a software this with your memories
here the idea here actually is very
close to what we have used for reflex
basically try to provide this illusion
to higher level software but the
implementation here is different because
we have hardware Mme you and with the
hardware support the latency the
performance of this regime memory
actually is way better for each access
miss we have about a 15 micro tech I
will talk about how does the 50 micro
second packed the overall performance
now Cole services them that we have
mentioned before their multiple core
services and in each core services each
co service is replicated as a separate
instances now how to coordinate those
instances is case by case for example
let's see page a locator this is one
important co service multiple
independent instances of page educators
will collaborate with each other to
manage the same set of physical memory k
tool will coordinate those instances by
inserting balloon drivers into multiple
kernels like this so you can imagine
balloon drivers is just like a dummy
device drivers controlled by k2 their
job is actually very simple
abalone driver can inflate basically the
k tool will try to get a large peach
block from the local page allocator it
will you can also deflate basically the
k2 will put the large block back to the
page educator now with multiple below
the best drivers k tool can move large
page blogs are wrong different page
educators so it can control how much
memory is available to each of the
colonel to each of the instant each
instance of the page a locator this
design has two benefits number one the
balloon here this one is almost
transparent to page alligator so we do
not have to notify the pager allocated
the next page i allocate the source code
too much so we still can we use most of
the linux page aggregator source and the
number two because we are moving around
the large page blocks so we actually can
reduce the interdomain communication for
good performance so that's about a page
a locator let's look at the look back at
a structure of kato to recap between
core services are replicated as share
nothing instances and we can we will
manually k 2 will manually explicitly
calling in them there is a software
special memory which will present one
you Lucien two or extend services so
your source code could be shared this is
where generally easier ordered
there are for example scheduler and also
the interrupter management so each core
services case-by-case actually it's our
state's Chen is challenging but the good
good news is that there is a small set
of core services so that's fine like
right now is 500 six five or six
something like that yeah how much time
do I have 50 minutes ok so I will skip
this hacking part so basically some
little hacking fun we have so imagine
just to just to like a briefly summarize
we have two kernels in different
instruction sets so they have different
ISAs to binaries but the thing is that
two Colonels will share the function
pointers at runtime so the problem is if
one kernel tries to follow the function
pointer pointing to the wrong
instruction set it will crash and it's
sort of an unrecoverable crash so how do
we do that how do we handle the function
pointer with a little bit of compiler
support and 110 support so this is some
hacking hacking fun we have during the
Korean plantation so I will quickly skip
that let's loosen look-alike evaluation
so how well does k to work so we try to
answer three questions in the evaluation
number one how much energy efficiency
can we get so we compared with Linux
because K to our OS can span across
multiple asymmetrical processors we can
actually exploit the low-power processor
for high energy efficiency not
surprisingly we have higher much higher
perform energy efficiency like up to 10x
this is good amazing but as we plan
yes we have a well three typical like OS
benchmarks so typical three are like OS
workload and we actually measure power
consumption by hooking wires to the
power of wheels under under under dev
board say anything specific about those
benchmarks so this is sweet activist
benchmarks OS used by many many
applications for example the DMA is like
used by almost every device drivers and
the five sisters of course like commonly
used features for saving silly you to
move on right because i'ma assume that
in this case the processor is on the
radius of the displays are so should I
wish you'd studied overhead right and if
you do you to be algorithm that the only
way to control media 4g great here right
this is the high end process so the the
the display is off actually in this case
we're talking about background tasks
like the emails in addition the
background and also prefetch in the
background actually displays off the
iphone 5s that has the uncertain
processor me how would your bar novice
compared to rotationally is right so I
know 5s cannot run the OS service on
that loop heart set pattern at all so
you have to use a strong processor
high-power one for any OS services you
have so you have to wake up the strong
processor from time to time
send black round green card at the two
different processors you're preparing
the main processor to work so the black
bar actually this is energy efficiency
so the y axis to the energy efficiency
so basically we're wrong we use
basically right dress on user space
driver to use to stress the OS service
the same OS service what wisdom okay so
on linux the OS is all is always running
on a strong core so so could you think
you look back that's essentially just a
local computation yes the answer showing
that the the main core use a lot more
energy right right no your baseline is
basically everything runs on yes I think
you're not using the small right right
because of basically and the one of the
top go of gateways to a neighbor or
where services running on the small one
right so we can exploit we can open this
small processor folder to that a lot of
our services mystery will put your all
things that can run yeah yeah of course
you have any examples of workplace so
there are for example some some hardware
by design some hardware feature is
private to the peak or for example
interrupt so if the interrupt is the
hardware interrupt owning goes to the
peak or so then you cannot run it on a
smoker but that's how how do I
limitation yes Eric so for the UTP
thanks for response if I understand
there's not an actual there's no actual
radio involved no no you know if you did
have a radio involved in that experiment
at that point then the actual throughput
would start to play a factor and you
might actually have to keep the radio on
longer if you are using the less power
yeah yeah my offset a lot of those yes
yes so I think there are two two effects
if we have real radio the idle tongue
will be longer between two packets that
will penalize the Bighorn because the
big big hole out of town either is more
power hungry but I agree with definitely
the a lot of
large number of the radio power
consumption yes Tim ok so what timing
right how how is the time in the DMA of
the UTP ODST to is affected by the
of your growing right i think the young
so we actually tried different sizes of
the work for example we try different
sizes of dma like 4k 128k and the one
megabyte its way it's more I oh
intensive our Kate world to better
because the because the idle time
between I operation it's actually a very
power hungry for the big hole because
the small cold idle with much lower
energy of the power so the processor is
much faster right so actually they are
yeah that's one of the dimension the
other thing is a young for the OS for
the OS workload if we look at the
instruct the energy per instruction this
kind of energy efficiency Patrick in
that case the small call can be more
efficient than a big hole because the OS
workloads a kind of irregular it cannot
benefit it can hardly benefit from the
advanced the microarchitecture features
like deep pipeline branch prediction
something like that which is featured by
the strong core yeah gee just maybe
follow up on pinterest previous question
yeah but just take the the other extreme
value hard-code everything on the small
for as a library or the small OS yeah
and use those to support these
benchmarks okay do you have a sense of
where are you in that spectrum are you
much it does do a lot of space to
improve but does the flexibility cost
you anything or not yeah so I think in
terms of energy efficiency is there is
no difference because the you basically
you if you can handcraft the OS this is
the same right but the things that
development overhead is hot much higher
you have the craft two separate OS
images application is difficult to write
because of the king developer has to
deal with 20 essays
efficient as handcrafted yes yes
different alloys yes yes yeah so
remember we have sweet given a
three-course number two is to simplify
always engineering so this is 2 yeah to
achieve their goal okay so this is about
a k2 but let's try to jump out look at a
big picture again k to actually spans
one single s image across different
coherence domains in one chip and one
chip remember we have this go up before
we try to build an OS over multiple
chips back in that high Wilfer this was
difficult because performance
performance concern OS engineering
concern and also architectural features
concern we feel that was difficult ways
in size and knowledge from k2 we feel
this was the actually this is variable
it's durable so for performance concern
we should steal you to share the most OS
model but in this case because course
Alma loosely coupled so most states
should be replicated instead of shared
coherent for always engineering to
control the less engineering to to
reduce the overhead the engineering
overhead we should do still to refactor
refactoring basically we use OS
components from the legacy code base and
architectural features we really need
hardware mmm use for different chips so
we can build the one unified memory
address space easily and we really we
really need the hardware messages
efficient hundred messages across
different chips so we can do
intercommunication more efficiently so
that's something we are trying to do
right now this is ongoing work now I
will skip related work so to recap twig
have the scenes that has been done the
target architecture is highly asymmetric
processors in one mobile system and
there is no global harbor cache
coherence among them so in order to span
the entire software stack across those
procedures we have redesigned system
software to achieve two important views
why is coherent memory of you so
application can span across coherence
domains the other why is single OS view
so application can still see
one single OS so we have followed
through a design principles which we
believe will be useful for future
systems design number why is we build a
symmetric system software number two we
let a software to define the policy in
memory coherence number three we will
factor existing code base system
software code base rather than
rebuilding everything from scratch so
that's the work has been done let me
quickly talk about the future directions
just to be on time so what I have done
is this the software for noncoherent
asymmetric general-purpose processors
look into future I try to address
distance challenging from three
directions number one is higher
heterogeneity number to hire parallel is
in these two are for mobile devices for
wearable mobile devices and to look
beyond mobile device into larger systems
let's talk about higher heterogeneity so
these days we not only have general
peppers processors in one system
asymmetry in the process invoices then
we also have a for example the
competition of geography and the DSP
Multimedia course in circle in one
mobile system now how do we build system
software how to build assistance support
for them so this is a steal open
question because some of the course may
be able to run the OS code some of the
maybe not some of them may be able to
run the program code some of them maybe
not I think therefore aspects we should
push it at twists as a system software
designer number one is abstraction we
should provide a good abstraction for
application developers throughout the
application for all these heterogeneous
hard work multiplexing which should
enable multiple programs to fairly share
the same set of heterogeneous hardware
protection if we want to run some unit
code and one of the hydrogen is pastor
we do not want to mess up our state in
the system and the configuration the
dependency among the more the last type
of course that are like scoffs at oh but
dependencies I mean functionality
dependency power dependency voltage a
dependency like dependency how do
we provide
system support to simplify the procedure
and how to how do I like automatically
verify this project this configuration
so that's a big question now higher
power needed so we not only have more
types of course we also have larger
number of course so in a few years we
are going to have tens of say few chords
and a few hundreds of gpo course Oh in
one mobile system how do we use the
extra number of course for higher higher
interactivity this is an old question
actually from 20 years ago in 2010
people ask how many quarts do we need
for one interactive system they say you
need to chorus now since that ten years
has passed people ask this question
again because no profit yeah let's see
are we I wish I could yeah okay let's
play try to restart okay so basically 10
years has passed since to some 2,000
there are many many new like feature
rich interactive applications so people
ask this question a key how many course
do we need for interactive system let's
say you need one more core right but
today the extra number course is an
asset we have to use it or we will
wister them so that there is a open
question how do we do can we have a
noble use of many calls for
interactivity for example can we use
extra cords to support natural in the
interface and augmented reality this
sort of a new interface and can we
paralyze interactive workloads for exam
html5 so I'm looking forward with
program language people and organist
direction and some even crazier ideas
can we use extra cores to speculate user
inputs to compute all the possible pues
have them ready before the system sees
after its user input so this can
probably give us the like one minute one
millisecond latency so that's even
crazier idea i will explore now look
beyond mobile syste a high plateau Kubra
path to look beyond mobile system
heterogeneity is everywhere in nitro
system for example GPU cpu this is
probably the most of successful hydrogen
your sister in the last ten years and if
we look at an edge of the clouds there
is something called the card base
station which is highly heterogeneous as
well we can see we have seen as a route
that it has and hers for example the ti
Keystone SOC is a heterogeneous SOC for
server market so inside one Keystone SOC
they're a bunch of arm processor general
purpose and processor and a bunch of DSP
so that we can run the general-purpose
workload and the communication workloads
3g 4g side by side you have in a real
system in a real server
lot of Keystone SOC interconnected for
example is the case for HP moonshot
server in a cloud base station you at
regional center there hundreds of
servers like that how do we program the
highly heterogeneous system and how do
it d bug such a high difficult in your
system so these are open questions now
if we look at the very tip of the cloud
this is basically the base station the
Sailor tower or smartphone direct talks
to they are creative genius as well this
something we have built the clay has
filled actually as rice so the idea is
basically the spectrum is really
expensive is a premium in today's words
communication in order to improve the
utilization for spectrum we can use
multiple antennas and use a larger of
hydrogen a lot of number of collagen
ears computer resources so we can
improve the utilization for
heterogeneous for the photo philostrate
inspection so in this direction I'm
looking forward to working with words
complication people to address the
systems of your challenge here now
finally let me try to position myself in
the computer stank so I'm working on the
low level system software which is on
the boundary between the hardware and
software so i try to code design the
system software by working closely with
the architecture and hardware people and
I'm trying to look into the hardware to
serve look for this cool I take your
support for sister software our code
design the system software with folks
from other areas like compiler
programming language networking and his
resistance and with the code design
system software hopefully we can provide
good strong support for all these
high-level applications for example or
within computer he became reaction
machine learning and we can provide
strong guarantee for high-level concerns
like security and the privacy so to
recap the whole talk what I've done is
to redesign system software for
noncoherent asymmetric processors so one
software stack can transparently span
across multiple coherent
domains look into the future I'm ready
to address sisters challenges from three
directions hierarchy virginity Carolyn
and the latter sisters thank you yes oh
you want it to be easy an egg programs
for these kinds of places above their
head originates or not and I like that
abusing sheriff memories that's familiar
interface people are comfortable with I
think one of the downsides of shared
memory is that the cost of communication
between different parts of the system is
implicit you have hardware support for
coherence and think people are willing
to tolerate that implicit costs that
maybe have any unpredictable performed
TV does your partner support Pete and
the costs aren't that high but now
you're kind of proposing that instead of
hardware coherence we use software
currents to do the same kind of thing
and it seems like the performance
predictability is going the performance
is going to be much less predictable
because now the costs will be higher
yeah communication here actually happens
through that yeah I guess the question
here is did you look at the trade-offs
in using what you described versus using
something that makes the performance
difference explicit if you have
operations that are going to be doing
communication or not doing communication
because the performance cost is hiring
so exactly you that this is a good point
so right now the program model we're
proposing user-programmable proposes
that user equipment different threat for
different coherence domains because I
might the fundamental really migration
is hard right migration is hard from
went on into our domain this also makes
the performance boundary explicit so
they know this thread the thread is
running on the height type whole domain
the threat is running on the low part of
me and as they know the the sort of the
sharing busines to thread actually
across domains but and wear dresses are
ideal I don't know but the thing is I
think it definitely makes sense to
provide some sort of a hints like pipe
bi-directional hints from the system to
the application and also for an
application to a system yeah but the
good one good news we have is the
container
between this two part is not a lot of
high in mobile in the background task so
we target the right because they come
they don't communication like all that
time so that sort of i believe the
product is the follow-up question i'm
giving them given that's how you guys
address that problem is how easy is it
for an application programmers
identified what should go on the weekend
what you're going strong because i think
you just looked at a program without
understanding what it does it might be
difficult to wrestle it out yeah so Mike
basically and right now the next
application the bank the boundary is
implicit but i believe it's kind of
doable for application programmer to
specify the performance need right but
not the power need but as long as they
specify the performance need i think we
can do that kind of a partition they
only have to my philosophy is a
programmers only have to reason about
the performance not about the power
consumption but that's just me yeah okay
okay thank you thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>