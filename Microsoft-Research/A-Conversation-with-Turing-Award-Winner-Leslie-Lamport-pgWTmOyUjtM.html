<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>A Conversation with Turing Award Winner Leslie Lamport | Coder Coacher - Coaching Coders</title><meta content="A Conversation with Turing Award Winner Leslie Lamport - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>A Conversation with Turing Award Winner Leslie Lamport</b></h2><h5 class="post__date">2014-04-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/pgWTmOyUjtM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right we are here with Leslie
Lamport the 2013 Turing Award winner and
congratulations how does it feel to be a
Turing Award winner oh thank you the
award should come with a warning saying
caution this award is dangerous for your
mental health yeah and your inbox may
lead to bloated ego and you probably got
a couple of congratulatory emails after
a couple yes yeah yeah and so where were
you when you found out well it's a funny
story I was sitting in an airport you
know the waiting area and San Francisco
Airport about to board a plane for a
vacation in Iceland and I happened to be
connected to the Wi-Fi there and link
told me that I had a phone call at the
office and I would usually have ignored
it but on a whim I decided to answer and
that was the phone call Wow and and so
what was the first thought in your head
after you hung up from that phone call
actually the first thought was could
this have been a hoax yeah
it's a while before I got some further
email tour what convinced me that it
wasn't I mean that's a good start to a
vacation but did you get a chance to
celebrate or if you you even celebrated
yet is it all sunk in well I guess the
closest to a real celebration was the
night before I flew here to Redmond my
wife got a split a half bottle of
champagne and we celebrated that way
nice so your your paper time clocks and
the ordering of events and distributed
systems it's one of the most cited
papers in computer science and it's
incredible because that's from 1978 why
do you think that's so often cited it
seems to have taught people something
and I'm not sure exactly what yeah the
significant part of the pay
is that it introduced the idea of
implementing a distributed system by
using a distributed implementation of a
state machine okay but that part of the
paper seemed to have gone unnoticed for
quite a few years in fact on two
occasions I've been talking to people
and they've insisted that there was
nothing about state machines in that
paper and I had to go back and read the
paper to make sure that I wasn't
imagining it all yeah there's something
about giving them people a new way of
thinking about distributed systems that
seems to have helped them the idea
seemed totally obvious to me although
when I was when I had the idea for the
paper I felt that it was going to be a
good paper but I had no idea it was
going to be that popular yeah and
sometimes soon after its publication I
was chatting with Jim Gray
and he said he had heard had people had
two reactions to that paper some people
thought it was obvious and some people
thought it was brilliant
yeah and my reaction was that I couldn't
argue with the first and I didn't want
to argue with the second yeah well
everything's obvious after you've read
it from someone else sure
so paxos is used in almost any major
distributed system today
can you explain what it is for the the
novice and even start with what is a
distributed system well first of all
there's the notion of a concurrent
system where you have different agents
or they're usually called different
processes who are operating concurrently
independently of one another but
communicating with one another a
distributed system so that covers things
like multiple cores inside of the same
computer
and my definition of a distributed
system is one in which the time needed
to communicate between the different
agents is long compared to the time it
takes the agents to perform actions
locally my mind originally that was what
distributed systems from other
concurrent systems what has turned out I
think to be more significant is that
distributed systems these days are ones
in which you expect some of the agents
to fail and so unlike traditional in
multi-core applications you expect that
you know if the computer is working then
all of the cores are working you know
not just some of them now this may
change in the near future when you have
hundreds of cores on you know in the
side the same computer and your computer
will have to tolerate the failure of
some of them but for the moment the
distributed systems are ones in which
you have separate computers talking to
one another over some communication
medium like Ethernet or Internet and as
a question I I didn't explain of what a
state machine is a state machine is a
mathematical machine you know like a
Turing machine in which is very simple
it has a state and it performs actions
by receiving an input changing its state
and producing an output so state
machines are basically very
straightforward because things happen
one after another you make your action
of withdrawing money comes either before
or after my action of depositing the
money whereas in a real distributed
system you may be I may be doing the
deposit in Kazakh Stan and UB may be
making them with
all in Beijing yeah and it's not too
clear exactly in what order they come
and so what my time clocks paper showed
is how you can implement an arbitrary
state machine in a distributed system by
appropriately sending messages and
keeping what are called logical clocks
but that algorithm didn't handle
failures and what the paxos algorithm
does is a implement it's a general
algorithm for implementing a state
machine in the presence of failures as a
computer scientist in 1978 I mean you
you knew about Moore's law and kind of
where things were going but how is the
world now different from what you kind
of expected and in 1978 well personally
I don't think I learned about Moore's
Law who later than 1978 I don't feel
that I had any particular ability to
predict the future or to foresee the
future the things that I've done that
have turned out to be important like
working on distributed systems in the
first place came about not because I
thought that your distributed systems
are going to be important but that I
thought that the distribution is an
important concept yeah and and therefore
an interesting concept and therefore
it's worth studying and interesting
fundamental concepts turn out to be
useful things to to understand
so I want to ask you about the way that
you approach problems people who know
you say you have a clarity of thought
that's not often found in in people how
is your thinking process different as
far as you can tell I mean it's hard to
say how others might think but what is
your thought process when you approach a
problem it's hard for me to say how it
differs you know from other people
a colleague told me that Edsger Dijkstra
said to him that I have a very good
ability at abstraction and I think that
characterizes well what distinguishes me
for most people the ability to I think
as as you put it to see the essence in a
problem and not be distracted by details
and often it seems to me that what I'm
doing I mean that abstraction that I
find is perfectly obvious but it
apparently isn't to most people I don't
know where I got that or sense of
abstraction how I developed it but I
know that it came through mathematics
came through my background as a math
student and basically getting my
doctorate in mathematics I mean all of
my education was been in mathematics and
so that's part of the story but I also
realized that I had something that was
different from even most mathematicians
is that I've always had a need to be
able to understand things from the first
principles in mathematics that is the
thing I loved about mathematics is the
ability to prove things from axioms and
to understand in some sense the complete
picture and I think it may be that
desire that gave me the incentive to
look at computer systems and try to
understand them mathematically which
meant try to understand the underlying
principles
so that's part of the story the other
part is that paradoxically is that
whereas other computer scientists looked
at problems in concurrency as
mathematical problems I tended to look
at them more as problems in physics so
for example Dijkstra's great
contribution which really started the
field of concurrent programming was his
paper in that introduced the mutual
exclusion problem and the mutual
exclusion problem is the problem of
given a collection of processes each
with a region of the code called the
critical section and have them
synchronized so that at most one process
is executing it's critical section at
any time and most people I think saw
that as a programming problem or a
mathematical problem and I saw it as a
physical problem a problem of two agents
and really keep them from doing two
things at the same time and that sense
of it as being a physical problem I
think eventually led to my producing
what in a sense is the first real mutual
exclusion solution that is the first
solution to the mutual exclusion problem
that didn't depend on some lower level
primitive that assume reach of exclusion
so I read in high school you used to
work with computers and back then you
were looking for vacuum tubes for people
who I mean I started with punch cards
but for people who are younger and don't
know what that was like
explain what computing was like back
then did you have to build systems were
they kind of cobbled together or did you
work with like you know larger systems
that belong to someone else
this was actually before the days of
operating
systems you when you programmed you had
the raw computer and the had your
program had the computer all to itself
and fortunately or perhaps as a result
by necessity computers were a lot
simpler than than they are now and I
found that to be I think quite useful to
have a sense of what real computers are
like in my later career I started really
working with computers really
programming theaters the summer I
graduated from high school and I worked
in odd jobs programming throughout my
you know education and part-time jobs
and this you know in during the school
year or summer jobs and I never thought
of connecting computing with mathematics
the one idea actually I had was I
thought that it might be cool to be able
to write computer checked proofs of
mathematical theorems and I was totally
naive at the time I remember it was
somewhere in the early 60s before as far
as for perhaps before anyone was
actually working on it and I thought
that being very naive that it might make
it maybe four times as hard to write a
proof that could be checked by a
computer as writing an ordinary
mathematical proof and I discussed the
idea with my math professors and they
thought it was terrible idea it would
take all the fun out of math so I forgot
about it who were the people who most
encouraged you or inspired you from high
school on in this field
well there was in my first summer job
that con Edison the utility in New York
City
a man named Norman Brown who I haven't
seen and since I last worked at con
Edison which was and maybe 1959 he
inspired me by giving me little
programming problems and even some
mathematical advice and if he's out
there somewhere we'd like to thank him
then I would I think the next major
influence on me was dick Palais who was
my thesis advisor at Brandeis he taught
me that real mathematics could be done
completely rigorously well I never
studied computer science and as I never
took a computer science course and my
influence the people who have influenced
me basically people I regarded as
colleagues and they're just too numerous
to to mention if I would single perhaps
some one out as as the primary influence
it would be Dijkstra through his through
his papers so for someone who's in
computer science now and looking to
graduate what what things would you
suggest that they read or things that
they should look into her study well
there's well computing is a huge field
for people who want to be programmers or
system builders what I would advise is
to learn as much math as they can not as
much math in the sense of math topics of
mathematics like esoteric math but to
develop a facility with mathematical
thinking
because as computer systems become more
complex more difficult to understand
and as they become more critical to our
daily life the building computer systems
will depend more and more on the type of
abstract critical thinking that one
develops by learning math I'm not sure
if I have anything to say about other
areas other than with you when you're in
university your goal should be to get an
education not to get job training you
learn your job on the job University is
a time to educate yourself what is the
work that is most passionate to you well
at the moment it's the work that I'm
doing now which is on formal
specification and verification which is
a highfalutin type of term to say that
I'm trying to get people and give people
the tools to be able to think properly
about the systems they're building and
what I've come up with is a particular
language called T la Plus whose goal is
to get people to think outside the code
in particular to think at a higher level
in the code because I think that's the
key to developing better systems so it
may be tough to get started but what are
the benefits to it well the immediate
benefits are that you have tools that
will allow you to find high level bugs
in your systems high level design errors
before you start coding and that is
enormous ly useful because you don't
want to find fundamental design flaws
you know after you've coded your system
because correcting them by just patching
the code
is does not work very well it usually
just introduces new errors and starting
from scratch is obviously very expensive
the longer term goal is that doing it
improves the way you think about the
whole process of how you write code and
engineers have told me that it just has
been a game changer to that for them in
terms of how they go about thinking
about systems and designing them and it
really improves what they do what's the
next big problem that you'd like to
tackle well I would say that it's too
late in my career to tackle big problems
but that would mean misleading I don't
think I've ever tackled big problems
yeah early in my career I think I
probably had some grand goal of
developing a theory of concurrency and
that never happened
something that Bob hargeon just
mentioned to me a couple of days ago he
said I never was one to develop grand
theories I just worked and saw little
problems and what I pointed out with him
is yes you just worked on a bunch of
little problems and then when you look
back you realize you know you realize
you had done created a grand theory yeah
and it was that way with me I never I
always felt like a failure because I
never succeeded in making a theory of
concurrency but when I look back by just
solving one little problem and that
leading to another little problem and
just a series of little problems I look
back and I created not what I would call
a theory but I created a path
have followed yeah and I think this
award speaks to the importance all those
so congratulations again and thanks for
being here today thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>