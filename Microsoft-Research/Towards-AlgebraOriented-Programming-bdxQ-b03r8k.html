<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Towards Algebra-Oriented Programming | Coder Coacher - Coaching Coders</title><meta content="Towards Algebra-Oriented Programming - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Towards Algebra-Oriented Programming</b></h2><h5 class="post__date">2016-08-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/bdxQ-b03r8k" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
okay good morning everybody so thanks
for coming today's speaker is Bruno
Olivia whose did his PhD at Oxford on
generic programming such an advanced
form of fresco for those who don't know
and he's worked on a border ain't a
broad range of today you saying okay
thank you very much it's a pleasure to
be here and have the opportunity to
present my research and what this talk
is about is about their programming
abstractions for dealing with
cross-cutting concerns and so you might
want to ask why do we want this in the
first place and the reason why we want
this is because there's a real need for
it in in industry and in software
engineering people these days are trying
to build really modular pieces of
software and in order to build these
pieces of software they really need to
have a good handle on cross-cutting
concerns so there are some solutions out
there that already help you with this
but these solutions okay can we wait for
slide 2 okay but these solutions are
typically based on code generation and
code manipulation and they tend to be
quite brittle so what I'm going to
suggest here today is that instead we
should try to look at this problem at
the more fundamental level and try to
come up with programming language
abstractions that help us to design
software that deal with this
cross-cutting concerns and I'm going to
make a concrete proposal for this which
is to use algebra switch I'll explain
later in the talk so what's a
cross-cutting concern basically a
cross-cutting concern is in some code
that is logically representing a feature
in a program but it turns out that the
implementation of this feature is all
spread out across the code of your
program so for example if you have heard
of aspect-oriented programming you
probably know that aspect-oriented
programming helps you dealing with one
type of cross-cutting concerns and this
cross-cutting concerns is what I call
amo genius cross-cutting concerns so
what happens in omagh genius
cross-cutting concerns is that typically
you have kind of the same code appearing
in multiple locations of the program and
so what aspect oriented programming
allows you to do is to modularize this
code in a single location and then
simply instrument the program at the
right places so it allows you to
modularize this kind of code there are
other types of cross-cutting concerns
and the type that I'm going to be mostly
interested on today is what I call an a
true genius cross-cutting concern so a
nitrogenous cross-cutting concern is is
code that belongs to a feature but
instead of being the same code in
multiple locations is just different
code in multiple locations even though
it logically belongs together so let's
look at this example to explain this
heterogeneous concerns in more detail so
suppose you are trying to build an
interpreter so if you're building an
interpreter and if you decide to do it
in an object-oriented way one thing that
you might do is start by having an
interface let's say interface for the
expressions that you have in your
interpreter and in this interface you
play some of the operations that you
want let's say that you start by
implementing the pretty printer of the
interpreter so that's the simplest thing
to implement so you go on and design an
interface with a single methods that's
the sprinting method and now you
implement a number of classes one class
for each type of expressions that you
have and for each of these classes you
go on and implement the printing method
so now suppose that you decide to
implement the evaluation function for
this interpreter what do you need to do
well essentially what you need to do in
an object-oriented language is that you
essentially need to go and edit the code
everywhere and you need to do this
because you need to now have a new
method to the original interface the
evaluation method and for each of the
classes that you implement you need to
go and implement the evaluation methods
so you need to define the evaluation
method for each of the constructs in
your language so evaluation in this case
is a cross-cutting concern because it's
it requires code that is spread out
across several locations in the program
is that not true whenever you add a
method to an interface yes it's
essentially it's exactly that problem
yes so adding a method to an interface
is a generally creates a cross-cutting
conservator okay so why do we want to
model rice cross-cutting concerns in the
first place well the software
engineering answer for this question is
because essentially what you want to get
is to get large-scale reuse and this is
actually a diagram that I borrowed from
Linda Northrop she works in the CMU
software engineering Institute and it's
a nice diagram that kind of describes
the evolution of reuse during times and
so you you if you go back to the 60s so
in the 60s we
created subroutines and what subroutines
do is that they allow you to capture
small portions of code put them together
in a nice abstraction and then you can
just go and reuse this portion of code
by instantiating it multiple times in
the 70s and the 80s we came up with
modules and objects and then this
allowed us to modularize larger portions
of code so we increase the reuse then
Linda argues that in the 90s and the
2000s we add components and services but
eventually she ends up with today and
what she argues that we have today which
is the ultimate form of abstraction is
what she calls software product lines
and software product lines are these
ultimate kind of abstraction that
they'll allow you large-scale reviews so
what's a software product line basically
the software product line is is this
idea of having a set of highly reusable
components where each component
represents a feature in in the programs
that you want to develop and the idea is
that you can if you want to design a new
program what you need to do is grab some
of these components you put them
together and you compose them nicely
maybe you treat them a little bit too
for the particular application that you
have in mind and then you get one
program if you want to develop a similar
program but not exactly the same you go
and do the same thing you take some of
these components you compose them
together you tweak them a little bit to
fit the particular application and then
you get another product I next light
is it okay but anyway the idea is that
you have a family of products all of
them are very similar but they all have
a small portion of variability but
essentially if you want to implement
these software product lines what you
need is a good way to deal with cross
cutting so what's a concrete example so
nokia for example uses software product
lines to develop their software for
phones and the reason nokia needs this
is because they have hundreds of models
of phones and each phone has a different
number of keys different display sizes
you have you have to deploy these phones
in different countries with different
languages so for nokia the key question
is how can you develop the software for
all of these phones in a cost-effective
way of course one way in which nokia
could approach this problem would be
that they would take the first phone
that comes by the first model they
develop the software from scratch for
that model and then they take the next
phone that comes along and what they do
is they simply copy the software from
the first to the second they patch it a
little bit and they get the software for
the second phone and they keep doing
this but what's the problem of doing
this the problem is that if now you have
a bug for example now you essentially
have to go and fix the code for every
copy that you have done for the system
and this code is modified so it's not an
easy task so it is really a maintenance
nightmare so instead of doing this what
they do is that they use the software
product line technology to have this set
of highly reusable components that they
can just use in all of their phones so
if you have a bug you fix it in in a
single location and the bug gets fixed
for all of the phones essentially so
that's the idea so there are many other
examples in industry actually there's a
indus
engineering community there is a
community that deals with this software
product lines and they have a Hall of
Fame so your if you are interested in
seeing some other applications of
software product lines you can go to
their web page and check some of other
case studies okay so how are these
companies developing software product
lines so what tools do they use there
are tools out there so two popular ones
are ahead and feature house and what
these tools do for you or the wait is
that these tools work is that they use
what is called superimposition and
superimposition is basically a synthetic
way to compose code so suppose that you
want to develop a software product line
for Java programs so the idea is that
you would go and use one of these tools
and what these tools provide you is a
superset of Java and what the superset
of Java gives you is some language
constructs that essentially allow you to
say things like if you compose this
module with another module then just
fetch some methods from the other module
and put them in copy them into these
classes so it's essentially a very
synthetic way to compose god you're just
composing the text of of your code
rather than composing the binaries or
something so so what's the problem with
this solution even though it's very
powerful and people have developed large
software product lines with it it's very
brittle and it's very brittle because is
it essentially becomes very difficult to
have any form of module type checking or
separate compilation or more generally
any form of modular reasoning so for
example if you want to type check the
software product line what happens is
that you take these modules that are
written in the superset of Java you
compose them and then the tool generates
some Java code
and only after getting this generated
Java code you can now run the Java
compiler you can get some some typing
errors so if you get some typing errors
essentially you get them from the
generated code instead of the codes that
you have originally written so something
analogous to this is c plus plus
templates so if you're familiar with C++
templates C++ templates are pretty much
using a very similar idea to tools like
a head and feature house so what happens
in C++ templates is that you have a
template language that you right on top
of a C++ and what this template language
allows you to do is that whenever you
instantiate the templates you get some
generated C++ code but the problems are
very much the same as with the the
software product line tools so basically
it becomes very hard to get modular type
checking becomes hard to do separate
compilation and you have typically have
these nightmare error messages because
the error messages are in terms of the
generated C++ code instead of the module
that have you have written in the first
place so what's the solution for this or
what's a better way to do something like
templates well people in this room some
of the people here have actually worked
on doing something better than templates
they have developed generics for.net
languages and what generics give you is
that they are semantically integrated in
the language so they are not something
outside of the language they are just
part of the language so they are perhaps
not as powerful as C++ templates but
they are powerful enough but they are
much more robust and they are much more
robust because now you get properties
like having modular type checking you
have separate compilation so if you have
some type errors these type errors are
really in terms of the code you have
written in the first place and not in
terms of the generated code
just mean parametric polymorphism in the
style of ml do you yes okay yes well in
the case of object-oriented languages
it's less powerful in templates oh man
yeah yeah sorry very very much less
powerful than yeah yeah yeah the
templates are kind of a turing-complete
language soon can actually do but I
guess in ask of you also have a
turing-complete vism doesn't really
address the challenges you are no no I'm
just giving an analogy here just saying
that the problem that I'm facing now is
that we at the moment what we have is
this and well basically what I'm going
to suggest is that we should have now
instead of using cogeneration why don't
we do something like we did with
generics and instead we create some
programming language abstractions that
deal with this problem in the first
place so that's my suggestion anyway so
before I discuss my solution just I just
want to make it we are why aren't
existing programming language
abstractions enough to deal with
cross-cutting concerns so the basic
problem is that existing programming
language abstractions say
object-oriented interfaces or algebraic
data types in haskell they are typically
very good at modelrising your code in a
certain way but they are not so good at
multi authorizing your code in some
other dimensions and and this is what
creates cross-cutting concerns and many
people have already made this argument
before so for example aspect-oriented
programming arose from this issue but
perhaps the one the work that summarizes
the issue more clearly is philip
wobblers expression problem so in the
expression problem in terms of this
cross-cutting concern perspective is
essentially telling us that no matter
which paradigm you choose object
oriented
programming or functional programming
you will always have to face a choice in
terms of these cross-cutting concerns if
you take object-oriented programming as
a starting point then having new
variants which corresponds to add a new
class is easy so in the context of our
interpreter if we wanted to add a new
language a new type of expressions then
this is easy because you can simply have
a new class and this is very modular you
don't have to touch any code but if you
want to have operations in all languages
then this is hard because now you have
to go and change all the codes that you
have before if you switch the functional
programming you have the dual problem so
if you develop your code with algebraic
data types then adding operations
becomes easy but adding new types of
expressions becomes hard or
cross-cutting because now you have to go
and change or edit the code so actually
the expression problem is a challenge
poses a challenge to us which is
basically how can you modularize your
code in a way that you can have model
variants modular operations with full
modular type checking so that's that's
the expression problem from this
cross-cutting perspective so what I'm
going to propose is that instead of
using object-oriented interfaces or
algebraic data types we could be using
algebra as a programming abstraction and
what I mean by algebra is in this talk
is essentially a form of algebraic
signatures and algebraic signatures were
very popular in the 70s and they are
closely related to abstract data types
and also closely related to ml modules
but essentially what they are is that
they are a kind of form of interface
like this where you have an abstract
type II and you have a set of operations
defined on this abstract type
so for example if you wanted to model
some simple form of expressions just
with literals in addition you could have
a two methods like this which are
basically have the signatures of the
Constructors of those expressions so why
are algebraic or more helpful than other
programming language abstractions in
terms of cross-cutting concerns well
essentially because they support multi
multi dimensional modularity so they are
not modeler in in just a single
dimension they are modular in many
dimensions at the same time so they
support composition operators for each
of the dimensions of the expression
problem for example so for example you
have this combined operator here and
this combined operator allow is what
allows you to compose in a model array
several operations the idea is that you
have an algebra f and you can understand
this type a as being the operations in
your system so you have two operations a
and B and this combined operator allows
you to create a new algebra that
contains the composition of the two
operations we have X pouch of e so in
this part in this slide is the x-files
pop the airport and the e / ok so this
corresponds to the F X algebra and this
corresponds to the a ok so the a part is
the title over which you're going to
operate it's not the operations it's the
time you can view it as the interface of
the operations that you are going to
operate it will become clear in a minute
so ok so but then so this Combinator
essentially allows you to deal with
modular operations if you want to deal
with modular variants you need another
Combinator which is what I'm going to
call the Union and this takes two
different algebra F and G opera
waiting on the same type a and it
composes the operations of the to
algebra into something that operates
also in this type a so basically this is
what allows you to have the two forms of
modularity but you can also have other
Combinator's like for example things
that decorate the algebra is with cross
orthogonal concerns like logging and
tracing more security and furthermore
the other nice thing about algebra is
that there's a lot of theory behind
algebraic signatures already and algebra
programming and all that and there's
already some support for proving so you
can actually support not only modular
definitions but also model approving
about these algebra and the other thing
is that you can represent these algebra
concretely in in different languages
using different representations so if
you are a functional programmer you
might have heard of f algebra sand FL
zebras work very well in functional
programming if you are an
object-oriented programming you can use
another representation which is object
algebra but there are many different
representations that you can use ok
let's look look at some code ok let's go
back to this interpreter example and now
let's try to see how we can develop this
interpreter example in a more modular
way so this code is is written in Scala
and if you're using an object-oriented
language you can model this algebra is
very directly or dissolving interfaces
by just having by just using a generic
interface so this keyword here traits
you can read it as interface in Java or
C sharp it's more or less corresponding
to an interface in Java or C sharp and
then this is essentially an interface
which is called X algebra and has a
generic type II and this generic type
represents
a abstract type and what you have is you
have two methods which represent the
Constructors that you have in your small
algebra of expressions so when you look
at this this is actually very similar to
an algebraic data type saying a
functional language like Haskell or ml
so if you would be using us call or
email you would create an algebraic data
type with two constructions constructors
lit and add and algebra or algebra
interfaces make you think about your
programs in a very similar way so you
think of your programs as kind of
grammars for the grammars of your
constructors of what you can construct
but then the idea is that if you now
want to create a new feature you create
a feature interface and that's the
interface of of your operations so if
you want to implement pretty printing
for example you can create an interface
I print with a printing method and now
to implement this feature I could leave
with an Aegis dream no no no because
this I print is going to be replaced by
this e here so you're essentially when
you implement an algebra here ok this is
an actual implementation so you
instantiate the algebra with this
interface here and the idea is that
printing methods so so the reason why
you don't have a here is because you an
object-oriented programming you have the
self right so so the e is the self so
you're thinking of the the self argument
so so that's the argument that is
missing here so as and for example how
you go and implement the lit case the
literal case is like this so you just go
you want to implement a literal case
with this matter
so you define the printing method and
the constructor already gives you the
argument X and all you have to do is
call X dot to string okay so this is
very similar so there's a little bit of
verbosity here just because its object
oriented programming and scala but this
is very similar to defining a function
BiPAP and matching in a school so if you
would define the code for this in a
school with an algebraic data type you
would end up writing something very
similar to this case lits x equals to
show x basically so that's what you do
and it also works of course with a
recursive constructors so you what you
get is objects that have the printing
method and you can call the printing
methods like this oh so print the first
argument put the plus in the middle and
then print the second argument okay so
how about that in evaluation okay if you
want to add evaluation then now just
create a new feature interface so you
can create a new interface for
evaluation and so that that has the eval
method and now if you want to implement
evaluation you simply instantiate the
algebra interface with this a feature
interface and now you go and implement
the evaluation methods in again in a
very similar way to what you would do in
a score so for example in the addition
case you have an object II one which has
the eval method so you can call eval and
then you have that to the result of
evaluating e2 and the point here is that
adding this operation is done in a model
away so I didn't have to go and edit
existing code sorry so you're using
scholars the reason why you can use do
this in sahaja yoga you can do this in
c-sharp or Java yeah
okay but the point here is that this
code is modular so now unlike the code
I've shown before I didn't have to go
and touch existing code so how do you do
variance so for example how do you have
a new case now to your expressions okay
if you want to add a new case okay so
I'm going to show how both be printed
everybody yes okay so if you want to
have a new variant now what you do is
that you create a another algebra which
could either be an extension or could be
an independent algebra but let's say you
create this algebra for subtractions
minus and now what you need to do is go
and extend the existing algebra with
this case and essentially again this is
modular all you are using is subclassing
so again heading a new variant doesn't
involve cross-cutting concerns so you
don't have to go and edit existing code
it can all be done in a module way so
how do you compose these codes and
assemble a different product well the
first thing is that you need you need a
way to create data right so you want to
create data how do you create this data
the idea is essentially that you have
some building methods like XP r &amp;amp; and
what this builder methods do is that
they take an algebra as an argument and
then using the methods of this algebra
you can create different values for your
data this K in this case you have 3 plus
4 here so just by invoking the methods
of the algebra but the key point is that
you always when you create this data you
always create it in a polymorphic way so
this here is not instantiated to a
particular type is parametric on this
time so this is an abstract types
is creating data of some abstract type
one interesting thing about this code is
that you can create data from different
types of expressions so for example you
might have a type that supports only
literals and addition and you might have
another type that supports literals in
addition addition and subtractions and
these types are compatible with each
other in certain ways so for example you
can use this builder method here to
construct data of this larger type okay
so how do you now go and create some
objects that actually use all these
infrastructure so the idea is that if
you want to create objects what you need
to do so these objects are the
particular programs whether the
particular types that you want to use so
if you want to have an evaluator that
has both the method evil and the method
print what you need to do is to use a
Combinator this combined that i told you
about in the previous slides and this
combined takes two to algebra put puts
them together and creates a new algebra
whose type is actually the intersection
of of these two types here so actually i
should mention here at this point that
so this is actually something you only
get in scala so you don't get this in
java or c sharp you can also work in
java or c sharp but where you would
replace these widths these intersection
type by pairs but it's not as convenient
but you could model these repairs as
well but ok then one I thing about skull
is that you have these intersection
types and these intersection types
capture these allow you to write this
Combinator that composes the interfaces
of the objects and what you get here is
an object that contains the two methods
here so you can actually call the
evaluation method and you can call the
printing method but you can have other
variations this is the point of
programming in this style
that you you can have multiple
variations you can have objects just
we've evolved you can have objects just
with the printing method you can have
objects that for example create an
evaluation method that is decorated with
a logging information and all of this is
done in a modular way so you don't have
to go and edit the previous code so all
you use is Combinator's that basically
introduced either new behavior or
compose the existing behavior together
okay so just to give you a history of
how how did I came to this so i did my
PhD in oxford and in oxford there's this
very mad mad this very mathematical
tradition on functional programming and
in particular they have this what is
called the algebra of programming and
one of the key ideas of the algebra of
programming is is that you use folds you
use folds to write programs you use
folds to reason about your programs and
actually the algebra is that you have
seen before what they are effectively is
that they are these fold algebra so when
you write an algebraic data type like
the data type for expressions you would
write something like this you would
write well I have data type for
expressions and this has two
constructors lit and adds and the lid
constructor takes an integer and returns
an expression the ad constructor takes
two expressions and returns a new
expression so what what these algebra
does for you is that allows you to
essentially replace each of these
constructors by the function by these
two functions those are the functions in
the algebra to get some new type II as
as a result and my inspiration and the
do how I started working in this line of
work was that I read a paper by ravinder
and Ruffing they have this nice
representation
of fault algebra this type classes in a
school and they're what he was trying to
do he was trying to provide a generic
programming library without using some
sophisticated language features but
there was an important limitation of his
library basically the library had
limited's used because it didn't allow
one form of extensibility essentially
the problem that ralph was facing was
the expression problem and this is how I
got interested in this line of work and
kind of my first work my first research
work was exactly on how to try to get
rid of these limitation that Rauf hats
and what I did was still in asshole I
used tag classes and the sub classing
tag class subclassing mechanism to
basically become modularize this algebra
and compose the algebra signatures and
with this design I was able to overcome
the limitation that Ralph had and
essentially provide a solution to the
expression problem ok after I've done
this initial work some other researchers
came along and they decided to employ
very similar designs to modularize dsl's
and this is perhaps the main success
story that I have to tell you about
these techniques so early on it still in
esco some people have shown how you can
use these representations to modularize
domain-specific languages are embedded
domain-specific languages and then this
technique was ported to scala actually
and in scholar this line really picked
up and these days there's a large
infrastructure for modular dsl's in in
scotland the ideas again is this idea of
a software product line so you have the
set of comp
ponents of dsl's and basically these
components represent different
constructs that you might have in a
domain-specific language you might have
a small language for arithmetic
expressions you might have a small
language for bullion's you might have I
don't know statements and the idea is
that you can just go grab the the
features that you want to have in your
domain specific language then helps
perhaps have the domain-specific
constructs that you need for your
language and then you're done the
advantage of course is that if you want
to have an optimizing compiler for your
domain specific language you don't have
to write it from scratch what you do is
you just reuse these components and what
you need to write is only the the code
for the new constructs of your domain
specific language and this this is a now
a very popular approaching the scallop
community anyway I've continued my
research in this line of work and what I
did after working in a school was that I
was very curious to see what these
techniques represents in object-oriented
programming and what I found out is that
they are closely related to the visitor
pattern and so one of the first things
that I did was show how how can we
improve the visitor pattern to make it
more modular so again the visitor
pattern what it allows you to do in
object-oriented programming is that it
switches the advantages in terms of
cross-cutting concerns so you can make
an object-oriented language become more
functional in the sense that now you
start seeing modular rising operations
instead of modularizing the variants and
what I've shown is that you can have
what you can now have is that you can do
model visitors again you don't have to
make this choice as you do between
functional programming an
object-oriented programming you can
design visitors in a model away but what
I've done more recently is
simplifying all of these techniques and
this simplification is essentially the
code I've shown you previously and I
call this simplification object algebra
and this this was essentially the code
that you have seen before and the nice
thing about this object algebra is that
they provide you a nice technique that
you can use in mainstream languages
including Java and C sharp and you don't
really need advanced features all you
need is essentially a standard
object-oriented language with generics
in it if you have that you can program
in the style that I've shown you before
that's all you need and this was the
first solution that was kind of work in
such a simple way in a mainstream
language I've shown a few more things so
I've shown that these actually scales to
more complicated cases for example you
might have in the general case you might
have several mutual recursive types that
need to be extended and actually these
techniques also scale to that case and
more recently I've what I've been
working on is dealing with a feature
interaction what is this feature
interaction problem so basically future
interaction is this idea that sometimes
features are not nicely orthogonal like
printing and evaluation sometimes when
you compose features they need to
interact in some ways and how do you
specify the interaction that's the
question and again what you can do is
you can have a generalized Combinator or
composition operator that allows you to
specify out how these interactions
happen and what this Combinator looks
like is essentially it looks like zip
weight in functional programming so it's
very similar to the type of a Zipit okay
so for the last part of my talk just
want to tell you that you can also do
modular reasoning so it's not only the
case that you
develop the software model early you can
also prove things about this software so
one of my most recent works is this
material a card which was presented in
poeple this year and the idea there is
that well programming language people
are interested in formalizing meta Terry
of programming languages but in order to
formalize this formalization process
tends to be quite one oolitic in the
sense that you go and formalize a better
theory for one language and then you
have a small variation of this language
and what you need to do is just copy the
code and modify it in a number of places
and then you get in a new development
but if now you need to change something
then again you have this nightmare
problem because now you have to change
all the copies so what we've provided is
this framework where you can actually
have these modular definitions and
proofs as well so you can actually
modularize the definitions you mobilize
the theorems and you model arise the
proofs and the key challenge that we
have solved is how do you come up with
the proof methods to prove to make these
partial proofs because you cannot now
you cannot just use a standard
conduction because that's a closed
principle so you need to have some some
form of modular induction and actually
again if we go back to this algebra of
programming and we look at universal
properties of folds we can from there
derive a modeller induction principles
and that that was kind of the main
result of our purple paper and just to
quickly tell you what we are now working
on is how you can also deal with
components with side effects because
side effects also they cause trouble
then you have to model this effect so
our framework our initial framework
could only deal with pure languages but
what we are using now
this is a paper that we have just
submitted is that we use monads and
algebraic laws about effects to also now
have met ettore for languages we defect
so we can deal with languages like this
for example so this is this is kind of
the languages that our framework can
deal with so we have components we have
five sets of components for arithmetic
boolean expressions lambdas references
and errors and these to use effects so
you actually have to come to have a way
to do proofs about exceptions and state
but the point is that we have components
that are fully modular for these five
language features and with them we were
able to recover 23 language variants but
this train 23 language variants use a
single code base so you don't you're not
copying the developments so you're just
reusing the same formalization for every
one of these 23 language variants so it
so what we have essentially is something
that looks like this we have a set of
components you know we can have features
for arithmetic we have the functions for
it automatic we have the terms we have
the proofs and we can just pick some of
these put them together and then maybe
if we need to prove meta to you for some
language that uses our own extension we
can just have our own extension and this
is how you would go and prove the meta
Tori for your new language so you can
just reuse the existing development
rather than hopping or pacing it because
it's something like the order of
evaluation expression affects the way
exceptions propagate or affect certainly
a new study notes so they're not you
want to snap them together and expect
everything to just look that's true we
must be hiding something here yes I
didn't mention feature interaction but
you're right so for example there's an
interaction between state and exceptions
and so what we do is that whenever you
compose two features that use different
sets of effects you also have to specify
some laws about this interaction so for
example with state and exceptions there
are actually two reasonable semantics
which is you can either propagate the
state or not so and each of these two
semantics kind of gives rise to a law
that specifies how the interaction
between state and exceptions should work
that's essentially how you do the
interactions you lots of papers about
that so you show exactly what to do if
you sure took two random things and you
threw them together no systematic way to
discover exactly what the interactions
now you have to study you have to study
the interaction you have to to go look
look at it and figure out essentially
all the interaction between the two
types of effects should occur so of
course what we have done here is that we
have modularized things that we already
knew the semantics what we haven't done
yet is to investigate you know like how
now I compose these with something new
that hasn't been studied before but the
idea should be that you need to figure
out essentially how the operations we
defects interact with each other so so
in the case of state and exceptions you
want to figure out how catch and put
work together for example and if you had
a new type of effects we need to figure
out this anyway just to summarize
summarize kind of the contributions that
I've done in this area well first of all
I think the main point that i want to
tell you today is that algebra zar
really a promising abstraction for
cross-cutting concerns I think this is
the key point but so they want one nice
thing about algebra is that they have
solid theory behind them so this is not
like for example aspect Orion
programming or these tools for dealing
with software product lines where people
are just figuring out ways to
synthetically compose the code in here
there's an actual mathematics that you
can use to reason about this algebra but
okay so the first thing that I've done
was really to show how give nice
interpretations of these algebra and
tell how they are helpful in terms of
modularity in both functional
programming and object-oriented
programming so that was my early work
and then more recently I've shown that
you know if you want model algebra you
don't really need sophisticated features
actually most languages that we have out
there already have the basic support
that you need to program with this
algebra so in object-oriented languages
as long as you have a standard to
object-oriented a language with generics
you can probably get most out of these
algebra is already and I've shown that
you can actually extend these techniques
to more realistic cases like the cases
where you have several mutually
recursive data types evolving at the
same time I've also looked at how to
support model approves and model proofs
which allow you to do model proofs by
induction and also model proves with the
effects and then I've shown that this is
highly compositional so the object
algebra really allow a very
compositional way to develop your
software and I have some case studies
and perhaps a success story but okay in
terms of future work but I really want
to do is to work more on programming
language design even though we can now
model program with algebra in existing
languages it would be better if we had a
programming language design that
supported algebra is from scratch and
supported all these composition
operators
a language construct instead of encoding
I think this would lead to a more
natural way to program with algebra and
I also think that we need to another
thing that I need to do is to try these
techniques on larger software product
lines so I've tried some medium-sized
software product lines but not something
that is really really big I think this
this would be something that I would
like to do ah ok to conclude they when
you presented the Scala code over soon
as possible to see shopko to kind of
looked fell into act is it is it an
encoding or does it get clumsy um is
there a big win to be had here well if
they're still and what you would gain
would be for example in terms of the
composition operators so so you you have
a kind of heritable in Scala so you need
composition operators for different era
tease of your type argument so for
example you have if we're talking about
Haskell you have types in kind star and
then you have types in kind star to star
and again you need if you want to have
algebra that operating all these kinds
you would need to repeat the
infrastructure infrastructure for each
of these kinds so if you have a proper
language design that supported these
composition operators then this would be
something that the language itself would
deal with rather than you having to
repeat code so it is a typical problem
in generic programming libraries yeah so
and the other thing is of course that I
I would still prefer the asshole version
of that code I an asshole so if i wanted
to write the evaluation function it
would take me two or three lines in that
Scala code I still have to some
verbosity and that takes like seven or
eight lines so I mean there's some
verbose if you just because of the
syndics
okay but um anyway I think I said the
main points so I think cross-cutting
concerns can be solved that the
programming language level so that's the
key point no need for a doc extensions
and there's still lots of work to be
done I guess I should stop here okay
thanks very much we had quite a few
questions but we probably got time for
one maybe one more what you can't get
this nice separation forever even
actually had an example between a vowel
and print where for you know certain
forms of expression they were two
totally separate things but for printing
the addition that didn't make sense
unless you have the ability to do an
evaluation to wanted to have that as
part as you lose all of your modular
isn't even one version of it winsome no
actually what you can do and that's
something that we have also shown in
this latest paper in Europe is that
let's say that you have a printing
function that actually depends on
evaluation so what you can do is that
you can express this dependency by a
constraint so you can you can say
something well this will work as long as
my type is constrained in a certain way
it depends on having this evaluation
methods available and so you can
actually nicely right the evaluation in
a model way so evaluation doesn't know
anything about printing and then from
the printing feature you have a
constraint that tells you that it
depends on evaluation and it also allows
you to call the evaluation method
basically so you can you can build with
this problem as well okay very last one
yeah so you mentioned the vision of the
software product lines
and you gave the example of Fame nokia
unclear whether it's very successful in
terms of the building of the software so
completely exist in how would you what
would it with the Federation of these
ideas being the quantity of large
software product plans I would you stay
with them as most of the delivered work
is valid it also right man I mean there
are several other examples so I as I
told you there's actually a web page
with several other examples I do think a
validation is necessary so so i'm not
sure but maybe you have two different
questions one is whether software
product lines are a good idea in the
first place and the other one is whether
the techniques that I'm presenting are
or how would I validate the techniques
that I'm presenting so for the first
question I think you know just the fact
that so many companies are using
software product lines should tell you
that you know companies really believe
in this technology so actually I believe
that's kind of the justification for you
know software product lines are a good
idea but for the second question yes we
do need to what we do need what we need
to do is really to study to see if we
can model existing software product
lines existing large software product
lines using these techniques and I think
this still requires a little bit of
research and effort so I think what I've
shown you is promising but is perhaps
not the complete story yet so I think we
still need to do some work and really
try out a large software product line
okay in the interest of time I think we
better wrap it up but let's like brainer
for an excellent talk</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>