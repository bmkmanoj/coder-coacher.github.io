<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Modular Total Correctness Verification of Fine-Grained Concurrent Programs with Exceptions and I/O | Coder Coacher - Coaching Coders</title><meta content="Modular Total Correctness Verification of Fine-Grained Concurrent Programs with Exceptions and I/O - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Modular Total Correctness Verification of Fine-Grained Concurrent Programs with Exceptions and I/O</b></h2><h5 class="post__date">2016-06-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/sUUiY35rjm0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
good afternoon everyone thank you all
for coming I'm restylane oh and today I
have the pleasure to introduce bark
Jacobs who has been an intern with us
for a long stretch of time about a year
homeless I think and he was extremely
productive during those internships and
we were sad to see him go but it was
good that he did because he is gone and
done wonderful things in all those years
and one of those achievements has been
while he's worked on checkers for
dynamic frames for implicit dynamic
frames which I think that in place the
dynamic frames some of those ideas he
had when he was here and he was trying
to convince me that they were good ideas
and in in retrospect they were really
great ideas so he's some in the last
several years been working quite a bit
with his very fast verifier which takes
both C and Java as input and then the
programs are specified using separation
logic now separation logic is used in in
many contexts but but his tool really
makes it a reality that you can actually
make use of it in in specifying the
programs and if you if you see part only
every so often you turn around and then
all of a sudden there are new wonderful
features that are so impressive in the
tool and that happens constantly so
today he's going to tell us about one
goes which is modular I think
correlation checking could probably
explain what it is so welcome thanks
ersten so actually i'll be talking about
for new features or actually three new
features and one new one one proof that
all of it actually I know so let's see
if we get through all of it so actually
these are the things i will talk about
the first one is modular termination
verification so recently i added support
for proving not just partial correctness
but also total correctness of programs
to very fast so you can prove that
terminate or if you don't want them to
terminate you can also prove it their
life that they are responsive so that's
the first thing I will talk about the
second thing is the part which is not
really a new feature but which is like
the foundations of some of very fast and
so this is in the context of recent
developments in the concurrency
verification world so people have come
up with very intricate and very
sophisticated higher-order logics for
very specifying a verifying concurrency
but actually there is a very
unsophisticated way of verifying fine
grained concurrency and that's what is
implemented in very fast by the way all
of these sophisticated ones don't have
to support yet they're only exists in a
bluefish system so you have to use them
very laborious Lee and interactively
this one is supported in very fast and I
will talk about that and then thirdly i
will talk about provably life exception
handling so most programs that you write
at least in Java they will not be live
that is in the presence of exceptions
they might deadlock and in.net it's
slightly better because since version 2
point 0 if a threat term it with an
exception the entire process is killed
but that's not still not quite the
behavior you want so I'll talk about how
to deal with that and how to verify then
these programs in the third part and in
the fourth part I will talk about
verifying hello world so we recently
achieved verification of hello world
after a long time so usually people I
mean it's the site people don't really
concentrate in that kind of programs
typically we only prove that we don't
crash we don't prove that the program
actually does something and so that in
the fourth part I will talk about
features for specifying and verifying
that the program actually does something
useful okay so let's first look at
modular termination verification and for
that I have a different slide deck
okay still
you
alright so this is work I did with
people in the Netherlands so first what
is the problem precisely so it's not
just termination verification it's
modular termination verification that's
what makes it slightly new the approach
I mean people have known how to verify
termination for a long time it's harder
to see how to do it in a modular way
especially in the presence of dynamic
binding so if you have a programming
language like for example Java or C
sharp with interfaces and the methods
are virtual methods therefore are
dynamically bound how to give a contract
how to specify these methods such that
you can prove such that the proof of
each module separately when taken
together implies that the entire program
terminates that's the question so so for
example how to specify these methods and
you want to prevent for example that
this implementation verifies you want to
reject this implementation this is one
where the intersection method delegates
the work to the object passed in as an
argument right so you want to check
whether the receiver object intersects
some other set and to do that you ask
the other set whether it intersects you
like that for partial correctness that's
perfectly fine for total correctness
that's not fine because you're not doing
any work and so if you implement n'klet
instantiate such a such a set and then
you call intersects on it passing itself
in then you have an infinite loop so how
to catch that so what so of course one
improved system is one that this allows
everything that so you cannot prove
anything that's perfectly sound it's not
useful so we want to allow many programs
including this one so we have an
implementation of set that is the empty
set so it doesn't contain anything it
doesn't intersect with anything we have
this set that equals some other sets
plus one element inserted into it so it
contains some element x if x equals alum
or the other set contains X
and then this set intersects with
another set if the other set contains
actually this would this should be a
lamb instead of this right or the other
set intersects with with other okay so
that's fine we should we want to also
support if a set is based on top of
another set for example if you define
the union of two sets for example this
way and then you have to find another
Union so the reason why I give this
example is because you might think that
you say that you can prove termination
by looking at the size of the sets that
it has to go down at each goal but here
the size of the sets doesn't go down at
each call because here you simply
delegate to another class without doing
any work yourself but it's the classes
earlier in the program and we will also
want to support that okay so these are
some examples that we want to support
now the proposed solution is built on
top of separation logic so I first I'm
going to quickly recall separation logic
for object-oriented programs before
adding the new feature that I propose so
how to add to specify partial
correctness for such an interface so
what you typically define is in
separation logic is you define a
predicate that abstractly denotes the
resources required by the set so it in
more specifically it will denote the
memory locations that comprise the sets
representation so the the fields of the
objects that this set uses to store its
own state that's what is represented by
this predicate so then the contains
method will require that you give it
access to the set since the contains
method does not modify the set it only
requires some fractional permission to
it and we
don't care how much deflection is so
it's an underscore this means give me
some fraction of the permission to
access this set so we can read the set
but not modify it and we will give back
some fractional permission the same for
intersex we require from access to the
set to this set as well as to the other
set and we give it back so now what is
the theory underlying that it's as
follows or actually I think it's just
that this title is in the wrong place
okay we're already in the in the middle
of explaining this so what is an
implementation of this interface what
does that look like well for example for
insert we give a body to this predicate
as follows the representation of an
insert object can consist of the LM
field so we have to have permission to
access the alarm field we don't care
about its value and separately we have
to have permission to access the set
zero field so this is by the way this
syntax for declaring a class is like
Scala so you declare the fields of the
class in parenthesis after the class
name so this is carlo syntax for
declaring fields of a class so we have
access to the LM field to the set zero
field as well as to the set object
pointer tool by set zero so you can have
recursion here so set is defined in
terms of set itself but for another
object in this case but since it's an
inductive predicate so long as the
recurse recursive occurrences occur in
positive positions it always has a
well-defined me so this is how we define
the representation of a set and then the
the bodies of the methods can be proved
easily against the specification and the
client problem can also be proved easily
against the specification so if we start
with nothing we know only true then we
create an empty object so we get that
empty is a set we create an insert
object so we get
the fields of this insert object and we
can make it more abstract by summarizing
this as set to dot set so we're folding
up the set predicate for set 2 so this
is the body of the set predicate for set
2 and this is if we fold it up and then
the same for set 3 and now if we split
this into two halves we can call it with
itself so here this program doesn't
terminate but it's safe so for its the
partial correctness condition holds so
we can prove it with partial correctness
even though this program doesn't
terminate or actually toaster mate sorry
so in this case it terminates because
empty and insert they terminate so the
syntax of assertions is as follows EF
points to assertions predicate calls
separating conjunction existential
quantification and the boolean constants
the the method definitions look as
follows so you have a method header with
a return type and parameter types it
requires some precondition and it
ensures some post condition and it has a
body so what is the meaning of
assertions the meaning of assertions is
given as follows it's it's given in
terms of an interpretation I for
predicates and an an hiep H which has
the contents of all the fields so the
points to assertion or def points to V
is true if the tuple okama f comma V is
in the heap that is if ol RF is in the
domain of the heap and the heaps maps
the heat maps order def to V a predicate
our application is true if the
application is in I is in the
interpretation of the predicate so I is
a parameter here we will see later how
we can define a specific interpretation
for predicates but here it's just
delegated to I
and then separating conjunction is
defined as follows p 1 star p 2 holds in
a heap H if you can split the hip into
h1 and h2 so this means that h1 h2 split
the heap up up and p 1 holds for h1 + p2
holds for h2 so I is the interpretation
for predicate applications so it's a set
of tuples of this form and we will see
later how we define a specific I so if i
give you the set of all predicate
applications that are true then i can
define the meaning of arbitrary
assertions that contain predicate
applications we will see later how we
actually be find a particular I to be
functional in the last war with is then
so that you cannot have 0 f be in B&amp;amp;H
and also have ofb prime yes that will
always be the case too that's right so
yes this is actually H is actually going
to be a function from older def pairs
two values or actually a partial
function right so this is actually just
shorthand for saying all that is in the
domain and although that is map to V
that's right well it's a partial map
from object reference field named pairs
two values so you can have one field of
an object being in the heap and another
field of the same object not being in
the heat and that will be useful later
so heaps actually represent permissions
to access parts of the full heap so this
might be the full heap or this might
actually be a partial view of the heap
in a sense so a part of the heat and
actually we will use this year right
with the separating conjunction what
you're doing here is you're interpreting
p1 in one part of H and P 2 and the
other part of H so if be one talks about
one field of an object
we too should not talk about the same
field but it can talk about another
field of the same object that's the
Attic the core notion of separation
logic is this ashley spatial
reddington's frame um another separation
at University not not really so i will
also so these predicates they can also
talk about the heap because note that HS
passed in so it's part of the tuple that
is either in or it's not in I so they
the predicates they bundle up a number
of points to assertions then bundle up a
part of the heap no no they're not
applicable because just because this one
is in I doesn't mean that it's going to
be a tie if you take a smaller H change
as a programmer screams that's why it's
doesn't change a predation of all the
predicates yes and H keeps changing yes
what about local variables local
variables are not in here so I is not
just cannot mention to a predicate
definition cannot mention a local
variable Y this left to the left of the
turnstile you have I and age when I was
also expecting and you will have the
valuation of local right yes you don't
have that typically you have that but
i'm here i'm using a programming
language that doesn't have mutable local
variables so you have read only local
variables so i assume they are
substitute the values are substituted
into the assertions already that
simplifies some things but yes in
general typically in the literature you
have this all right so this is the
meaning of assertions now how do we mean
how do you define the meaning of
predicates well as follows we given if
we already have an interpretation I for
predicates we can define a new
interpretation f of
I as follows so we look at the
definition of the predicate so suppose
we want to know if this tuple is in F of
I so then we will look at what is the
class of object oh if its class c then
we will look at the definition of
predicate be in class c suppose this is
the definition of that predicate there
and then we will interpret this body
under I and H and if that's true then
this tuple is an F of I ok so we will
use I for the recursive calls in the
body of the definition and given this
functor so to speak you can take the
least fixed point so this is the least
fixed point of F which is well defined
because F is monotonic so that's the
cluster touch the theorem and so we will
have the property that f of I fix equals
I fix so that means that it satisfies
the equations that are the predicate
definitions and so that means that we
can use this as a reasonable
interpretation for predicates so in the
further down in further slides I will
just write this and to mean this thought
the I fix will be implicit from now this
has something to do with I think a
restriction you alluded to earlier that
predicates appear inside definition of
the predicates only in positive or
that's right yes it that's a crucial
restriction to make this work so here in
this syntax you will see that there's no
need negative construct so there's no
implication or negation in the syntax of
assertions which enforces trivially that
predicate calls occur only in positive
position in the nation and the
appreciation all right well now you can
use it for boolean expressions right so
there are boolean operators so if you
just have an X actually it's not so
actually if you have something that
evaluates to either true or false if you
substitute in the local variables then
it's fine so that's allowed you can have
false in here right
but you can't have a negation or an
implication that has either points to
assertions or predicate calls in in its
operands being bullet close but the
existential variables are like
undetermined constants at the top level
maybe yeah then yeah and what you said
yes exactly okay but actually I will see
later I will see a way that you can
still have negative facts about
predicates and very fast but it's not in
this particular talk in the next one the
next part of the talk and second chapter
so to speak I will say show how you can
use ghosts commands as proofs of
negative facts so you will have nested
triples 20 triples about Ghost commands
and they can have a predicate in the
precondition and in a sense of
precondition of a triple is a negative
position so in that way you can still
have negative factor to speak about
predicates okay sure some of these
restrictions I imagine you're inheriting
because you use separation logic and
some of these restrictions are probably
because you want this well founded this
definition of your recursive predicates
am I correct well so the restriction on
positive positions is because I want to
do it make this fixed point right
because i want this separation logic
arrow thingy cannot the one here or
there or something right the magic ones
i don't have it here i don't know but
that that points to you and you should
make a comment that the points to cannot
appear in some situations right so the
points to I just said that it also
cannot appear in negative positions here
in this case but actually that's that's
not even needed to be able to make this
so actually actually I've never needed
and negative points to in any proofs so
I don't think it's used
really useful okay all right so now how
do we express the semantics of programs
and you can use a CO inductive semantics
for that so if you run a command in a
particular heap it will have an outcome
or it can have one or more outcomes and
an outcome is either successful
termination in n steps with result value
V and final heap H or failure in n steps
or divergence and we will define the
notion of adding a natural number to an
outcome so if it's a successful outcome
then you just add it to the number of
steps the same for failure and adding a
number to divergence just means
divergence and given those definitions
we can define the meaning of a call as
follows if you perform a call in heap H
then of course you will look up the
method body and the body will depend on
the parameters X you will look the
matter of the method body in the class
of oh of course which is C and then if
you execute this body with the argument
substituted for the parameters then you
get some outcome so the outcome of the
call is going to be 1 plus the outcome
of the body and this should be
interpreted as a co inductive rule so
with double lines and that means that if
you have infinite recursion if the body
of em is it's how the call of em on the
same object then the only possible
outcome is divergence right if I didn't
have this one plus by the way if I just
had oh here then all possible outcomes
would be allowed by the semantics and
that's why I have this one plus so that
you can only have divergence here if
it's a nun if it's a infinite recursion
all right
so given that we have as notation for
the meaning of programs how do we define
the meaning of a triple so that's
defined as follows so for partial
correctness if the precondition so for
any heap where the precondition holds
and if we get an outcome oh that either
always die virgins or we have a
successful termination such that the
post condition holds in the post heap
with the result value substituted in
that's like the obvious meaning right so
tripled is true if if you start in any
state that satisfies the precondition
running the commands will end up in the
state that satisfies the post condition
that's it that's just what it says there
nothing else but notice that we allow
divergence here because this is a
partial correctness semantics or proof
system so then we want to prove it if we
can prove a triple using the proof rules
then it is true and I didn't show any
proof rules here but they are standard
and so then how do you prove this
theorem well you will prove it by
induction on the number of execution
steps so you will use the following
lemma for all number of steps and given
a that we reach an outcome oh then it
will not be failure in n steps and if we
successfully terminate in n steps then
the post condition is satisfied and you
can prove that by induction on the
number of steps
alright and then by induction and nested
induction on the derivation of the proof
three itself so then how do we extend
this logic to deal also with total
correctness what we add is just one
thing our core permission and it will be
in the first approximation it will be
qualified by a natural number so
actually this simply means that we have
n that we have permission to perform n
calls here so given that the meaning of
this assertion so we will interpret the
meaning of an assertion under I and H as
before but also n so then of course if
you claim that you have call permission
and prime then n prime has to be at
least so n has to be at least n prime so
you can have additional Kyle permissions
that's fine separating conjunction is
also interpreted in the obvious way so
we have to split not just the heap but
also the car permissions into two parts
such that p 1 holds for N 1 and B 2
holes for n2 so they are non duplicate
bull of course these complications and
then the proof rule for method calls is
extended so that it consumes one called
permission at each column so one call
permission is taken out of the program's
stock of call permissions at each call
and it's gone and since there are only
finitely many confirmations at the start
of the program it follows that the
program can only perform finitely many
calls it's very simple so how do we
prove soundness for this so the meaning
of a triple is exactly as before except
that we don't have this disjunct that
says that we allow divergence let's go
and then how do we prove that given the
proof rules we have that the triple is
true now we will define it we
use a lemma that performs induction not
on the number of steps that on the
number of calls so n is now the number
of calls and that will also work out so
you now perform induction on the number
of calls and nested you will also look
at the size of the command so the only
command where the size of the command
itself doesn't decrease through
execution is calls and calls are dealt
with using competitions so that's why
this is a valid way of doing induction
alright so now how do we use these call
permissions for modular specifications
because of course what you don't want is
to have at the top of main a request for
copper missions for exactly the number
of course at that particular program
will make that's not modular then you're
revealing exactly how many calls you are
making throughout the program so you
don't want to do that of course consider
this very simple program so we have a
main method that calls square root and
square root calls square root helper
some number of times so a naive way to
specify to perform modular verification
of this program is to say oh well square
root helper doesn't perform any calls
itself so we're going to request copper
mission of 0 so that's just the same as
true really because we're not requesting
anything square root it performs two
calls so it requests copper mission with
two and then main calls square root
which itself needs to call permissions
so may needs three complications right
okay so that's that's a valid spec valid
proof but it's not modular it reveals
information that we want to hide so how
do we do that and the way to do that
actually one other problem is that it
becomes very tricky to specify ackerman
so if you want to have a required class
for this main method that cause Ackerman
the Ackermann function which
is a well known function that performs a
lot of recursion then you will need to
specify the number of calls that are
performed by ackerman and that's quite
tricky you can do it but it's not
something you want to do so you want to
be able to abstract over the precise
number of calls that are made so of
course if I talk about Ackerman you hear
me coming I'm going to talk about
ordinal numbers about a lexicographic
ordering so in general we will look at
well-founded orders and an order is well
founded well I'm sure all of you know
but let's just quickly recall so a
relation is well it's not the set not
necessarily even an order a relation is
well founded our if are all non-negative
non-empty subsets of the domain of our
have a minimal element right so for each
non-empty set X there is some element of
X such that no element no other element
of X is less than it or no elements to
shortly no element of X is less than X
that's minimum of course minimal
minimality and that's the same as saying
that there are no infinite descending
chains of are of course the natural
numbers are well founded we can define
well-founded pneus given to well-founded
relations we can define the
lexicographic composition of these
relations and here we will assume that
the second element is the most
significant one so either the second
component of the pair decreases or the
second one stays the same and the first
one decreases so then we consider the
despair to be less than this pair so 10
comma 2 is less than 1 comma 3 and the
other thing that you can do is multi set
order so so this is denoted as follows
Omega to the X that means order over
sets / multisets of elements of X and
then the order is defined as follows you
get from well multi set to a smaller one
by removing any element and replacing it
with any number of smaller elements
that's how you move down in the order
over the multi sense and this is what we
will use also in our proofs so we will
not use just natural numbers but
ordinals to qualify call permissions and
so we will have we will interpret
assertions under I h and lambda where
lambda is a multi set of ordinals so
each element of lambda is a call
permission qualified by an some ordinal
so called the mission of alpha holds
under some lambda if alpha is an element
of lambda separating conjunction is
interpreted as follows we have to be
able to split lambda such that one part
satisfies p1 and the other part
satisfies be too we will also allow the
program to perform ghost steps that
rican lambda so you can if you have a
certain stock of carbon emissions you
can replace any of those call
permissions by any number of lesser
competitions and that is denoted by this
square subset symbol so we can go from a
state satisfying assertion p21
satisfying assertion p prime if p prime
is satisfied by a smaller lambda than p
so for example we have we then have the
following loss or facts call permission
of one can be weakened to complication
of zero StarCore permission of 0 and for
another example is complication of 0 1
can be weakened to call permission of 10
0 and copper mission of 20 0
complication of multi set 3 can be
weakened to cal permission of two to two
and call permission of one because both
of these multi sets are smaller than
this multi set
this the lambda prime less or equal to
lambda 1 strictly lasting less or equal
it's fine if it's the same one then it's
Ordinary implication of assertions so
the so this is one assertion implies one
other assertion right it's there's no
star there right so how do you how do we
now use this to abstractly specify this
program and the trick here is to use
method names as ordinals so we will
interpret method names we will define an
order on method names simply by the
textual order of the program so we will
say say square root helper is the
minimal element and square root is
greater than square root helper and main
is greater than both square root and
square root helper and using this
disorder we can use we can define call
permissions as follows so we will use
the method names as the set of ordinals
so main and in all programs that you
will see from now on main will always
require simply a call permission for
itself for program domain so that so the
specification for the main method
doesn't reveal anything about what the
program does internally how many calls
it makes it always simply requires main
since main calls square root it needs
and square root itself so many ways more
generally any method will simply require
a call permission qualified by its own
name so queer root square root will
require confirmation of square root
square root helper will require call
permission of square root helper so if
main wants to call square root it needs
to weaken its own call permission to to
call permissions over square root Y to
one of them is consumed by the call
itself so remember the proof rule that
we saw before in a call is valid if the
precondition holds and separately we
have an extra culpa mission which is
consumed and lost forever so that's why
main has to be weakened to two instances
of square root one of them is low
and the other one is best into the body
of square root to satisfy its
precondition and square root itself will
also weaken its own permission to two
copies of square root helper and then
square root helper will simply not use
its core permission but that's fine of
course so now how do we verify or and
specify Ackerman Ackerman itself so the
general rule is if you have recursive
functions or recursive methods they
should be internal to a module so that
means that the specification of the
recursive method itself doesn't have to
be abstracted it is okay for it to
reveal the structure of the
implementation to be
implementation-specific so what you then
do is you have a separate method a
separate public method that is that has
an abstract specification so Ackerman
itself requires simply method Ackerman
here we have given a little bit more
structure to the call permissions we're
not using just method names but also
local ranks so now the ordinals used to
qualify call permissions are pairs of
local ranks and method names and the
local ranks are the usual kinds of
ranking functions that you use to verify
correct termination of recursive methods
yes does this mean I want to implement
an interface I need to respect the order
of the interface methods how they were
declared in the interface because in my
implementation they're gonna have to be
saying order to get the same or knows
yes but that can easily be you can
easily work around that by having the
implementations of the interface methods
call in two privates other private
methods that are above all of the
interface implementations so that way
they are all less they don't all be less
at the end of an augmentation methods
and therefore they can you can call any
of the implementation methods in any of
the interface methods right so you
simply duplicate all of the methods and
then it's there's no problem so it's not
a fun
the restriction in that way so okay how
do we then verify Ackerman so Ackerman
itself and the general rule will be
public methods simply require a call
permission qualified by zero comma its
own name so this doesn't reveal any
information about the contents and then
the recursive method will have a call
permission for Ackerman eater and as the
local rank the rank that is appropriate
for a cure mom namely the two arguments
lexicographically salted so Ackerman
ricans its own permission to MN Ackerman
eater which is less than Ackerman
because the second component is the most
significant one &amp;amp; Ackerman eater is less
than Ackerman so it can choose anything
for the local rank when it performs this
weakening okay then the really hard part
is dynamic binding so yes right mutual
recursion is done by so each each of
these mutually recursive methods will
request permission for the bottom one or
the greatest one yeah yeah in the paper
there's an example like that so how do
we do a dynamic binding so suppose so
here I here I fan out another example
that uses dynamic binding so we have an
interface for real functions you can
apply to a double to get another double
then we have a method a static method
that performs integration that computes
the approximation of the integral over F
between some bounds a and B so it's
going to have to call F a number of
times how do we specify these methods so
here is a first attempt well actually no
this is just a partial correctness
specification that we like we saw before
so we define a predicate in real funk
and apply will require this predicate it
doesn't actually give anything back
because since this is just a fractional
permission the caller can always keep
another fraction for further calls
so it doesn't have to give anything back
integrate also will require a fractional
permission for f so in the partial
correctness setting this is sufficient
this allows integrate to call f any
number of times now if you also want to
prove termination how do we do this of
course apply will want to be able to
perform static calls of things declared
earlier like we saw before like square
root needs to be able to call square
root helper so which will be so it will
by the ordinal ordinary rule that we saw
before apply should request the call
permission for zero comma its own name
and we can so this this dot apply means
actually class of this not apply so this
is the name of the specific apply a
method that implements this interface
method so this is not one name for the
interface method itself this is the name
for the class method that implements
this interface method and so then
integrate should a by the ordinal
ordinary rule that we saw before it
should request call permission for
itself so that itself can call methods
before it and also call permission for f
dog apply however this is not sufficient
specifically consider the following
implementation of integrate so integrate
will call a recursive helper function
that recursively applies f to some value
between a and B and then recursively
calls itself again right as you would
expect now the problem is what we said
here this spec allows f don't apply to
be called only once because F dot apply
so if you go back to the spec after the
ply requires this full call permission
that we're passing in here so after the
first call it will be completely
consumed so this is not sufficient a
specifically integrator will need any
copies of Abdul apply
for n being the recursive argument here
that is descending during the recursion
so how do we fix that and we cannot of
course we could just put like Omega here
the first infinite ordinal but if you
but that restrains the implementation if
for example if you want to call this
inside of ackerman then you don't need a
mega you would like something bigger
than Omega so okay can we put the
biggest ordinal with the reason of such
thing as the biggest order so that's not
there's no good modular way to fix this
without again using method names and I
will show how so the way to do that is
to not use local ranks pairs of local
ranks and method names as ordinals but
local ranks and bags of method names so
multi sets of method names so you do it
as follows integrate so for f dot apply
itself we simply require the single tone
multi set this top apply but for
integrate we will require the multi set
containing two elements integrate itself
and F to the ply and this allows
integrate to weaken this permission to
an arbitrary local rank when it goes
from integrate to integrate eater so
when you can integrate F apply to
integrate it or F apply you can choose
an arbitrary local rank and this allows
you to perform this call and here you
can perform any number of calls that you
need now this still doesn't now we still
haven't achieved a fully general
specification because F dot apply can
only perform static calls here given
this given this permission it cannot
perform any dynamically bound calls on
objects that it refers to by its fields
so if it has a reference to another
object that it cannot call that object
because it doesn't know that the methods
of that object are statically below
itself so here too we need to pass not
just this little
fly but some arbitrary extra set of
method names so this is an example of an
implementation of real funk that calls
into other objects so this real fun
defined as the sum of two other real
funks when it when you apply it it will
call F 1 dot apply plus F doodle apply
so that one isn't supported by the spank
that we just saw so how do we fix that
so this by the way is the partial
correctness specification for the some
class so it's predicate real funk will
have the permission to access field F 1
and it will have the real funk predicate
for f1 it will also have permission to
access f2 and the real funk read the
reddiquette for f2 so as I said this is
not going to be enough to verify this
body what we then do is we are expose
from the real funk predicate the bag of
methods are reachable by the object so
each object will expose to its clients
abstractly the bag of method reachable
from it this in itself sounds very
breaking of information hiding but it
isn't because we're not saying anything
about what this bag is we just allow the
client to name it just allow it to be
mentioned in specifications but we're
not going to say anything about what is
in there and what is not in there so the
spec for apply now becomes as follows we
have as just for the partial just as for
partial correctness we have a fractional
permission on this dot real funk and now
we bind this method bag D and then we
say we have called permission for all of
those methods d so this is a multi set
this will of course include apply itself
so for the Sun we define it as follows
it is a whatsit I thinks it's a logical
logical variable yes that's right so how
do we define the predicate for some
example so as before some needs to have
access to F 1 and 2 the real funk of f 1
and now we named the method bag of f1 as
d1 we named the method bag of f2 as d2
and our own D is going to be our own
apply method multiset Union d1 multiset
Union d2 and this way apply can call all
of the methods of f1 and f2 and it can
apply statically higher methods of
itself so now the proof is easy because
thanks to the fact that both d1 and d2
are smaller than d because you can at
least remove this element you can weaken
this call permission to all of the call
permissions required for the recursive
calls so this becomes the general
specification for real funk and the
specification for integrate now becomes
as follows we need the real funk
predicate for f it will have some bag of
methods d and we need Kyle permission
for ourselves integrate multiset union d
so these are actually all of the methods
reachable by integrate these are the
math this actually represents the
methods statically above integrate and
this represents the methods reachable
through the f object so we can prove the
implementation of integrate as follows
integrate it or we'll have a record will
require cooperation local rank n and
that method bag integrate it or union B
so how do we use what is some client
code that uses this specification so we
have a program main that will inform the
integration of some linear function
defined by some coefficient a and some
constant B so it will create a number of
those linear functions and will then
also create a some object over those
linear functions and then we'll call
integrate so how do we verify total
correctness of this client program the
class linear itself will have to have an
implementation of the real funk
predicate it's
so it has the access to a and B and its
own method back will simply be its own
apply method and then the proof outline
for the main function looks as follows
so main simply requires call permission
for itself so we have if we create a
linear object we get a real funk with
method back linear apply we create
another one so we have also real funk
for linear dot apply again for f2 then
when we create a sum we also have a real
funk for some multiply and then two
copies of linear dot apply right and we
can then weaken the cul permission for
main to two copies of cod permission for
some doll apply and two times they need
not apply that allows us to perform this
integrate call all these implementations
no statically how many method calls they
need to make murcia supposably it was
instead of a linear function something
that took up some dynamic data structure
mm-hmm needed to call as many as the
glorious dynamic chain right isn't that
like the some object so some is built
from linear objects and it doesn't know
itself that it's built from linear
object knows it well I mean they can
themselves be again sums for example yes
so in that sense right this is actually
i think the end well actually there's
one more problem remaining here i am I
know what happens at construction time
so as I won't also want to abstract over
what happens at the construction time I
can do it as follows so what does a
constructor function or a constructor
method for linear look like it will
require cooperation for itself simply
actually I forgot to 0 here and it will
say I will give you a knob ject that
satisfies the real funk predicate for
some D and D will be less than myself
and thanks to this information
so here we don't know the exact value of
D but we have an upper bound for it and
that allows the main function to weaken
its own Kyle permission to a call
permission for D and simple similarly
for some so create some will require the
usual call permissions for f1 and f2 and
it will give back an object whose method
back is less than create some Union d 1
Union need to so that's all I wanted to
say about modular determination
verification and I see now that it's
been an hour already so I guess the
other topics we should leave for some
other time all right thank you very much
ask questions for about and the party's
here and today and tomorrow's if you
want to chat with him battles the
historicity good taste any other
question is known about them so I your
examples of functional language by the
way you're allocating your data types
and they're playing us the other McLaren
bigger data types just support that very
well is that that all is supports mm-hmm
no so the logic fully supports mutation
and I mean I don't see it at this point
any reasons why the I mean the
specification style also should not
support notation for example these
predicates it's perfectly fine for them
to for the arguments to change as you
mutate the data structures innovation
that you have to travel ok circulus
right yeah where does that right so well
actually this are already shows you how
circularity would would be shown so but
actually if you create a circular list
then I would say that you that you know
that you're doing that so it would be
within one module
and then you know how many elements it
has so I think that wouldn't be a
problem yes yes what if you ask that and
right right of course it's ruled out I
mean non termination this is sound so
there's definite cannot prove the
program question is can you the question
is then I mean if it doesn't terminate
then you cannot prove it right so what
do you still want to prove about it
that's the question and I guess I
crushes more how does that work program
or the name chatter this but what is the
specific
so it's hard to tell it's going to fail
yeah i guess i would have to try it to
really be m to answer that but note that
of course these multisets these bags are
finite things so they would have trouble
to create an infinite such bag so we'd
have to they would have to during
creation they would have to have some
well-founded process to come up with
these bags that would be impossible I
guess
right have you had no stuff like my
program makes a system called the
converter extreme values and if the
system returns wanted to give the valley
loops indefinitely 10 otherwise returns
immediately right so this is for proving
termination right so does that program
terminate but then you cannot certify it
you have to know that its terminus right
otherwise you cannot clarify that
terminates
fastest ass yeah I suppose you're not
shooting for a maximum mobility which
allows you to prevent in your heart only
if it goes well yeah there are some
verifiers like that too oh yeah so part
will be around so please</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>