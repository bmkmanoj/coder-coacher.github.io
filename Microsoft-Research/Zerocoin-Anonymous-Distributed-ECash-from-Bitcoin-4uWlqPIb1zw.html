<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Zerocoin: Anonymous Distributed E-Cash from Bitcoin | Coder Coacher - Coaching Coders</title><meta content="Zerocoin: Anonymous Distributed E-Cash from Bitcoin - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Zerocoin: Anonymous Distributed E-Cash from Bitcoin</b></h2><h5 class="post__date">2016-07-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/4uWlqPIb1zw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year Microsoft Research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
good afternoon everyone
thanks for coming to this invited talk
it is my pleasure to introduce Matthew
Greene he's a professor at Johns Hopkins
University
his main research interests are on
applied cryptography especially focusing
on privacy preserving cryptographic
protocols and well today he will be
talking about Sarah Cohen so please
let's welcome Matthew pinning okay thank
you so this is a talk on electronic cash
I've subtitled it this sort of odd
subtitle and I think hopefully it'll
become clear what this is all about is I
get a little deeper into the talk but
this is some joint work with my grad
students Ian Myers and Christina Garmin
as well as avi Rubin at Johns Hopkins
we're going to be presenting this at
Auckland the next month so anyway
there's this really dorky intro to this
talk I might skip by quickly but I gave
it to some bankers on Monday and I
wanted to have some kind of fake econ or
finance background to this so I'm gonna
give my little my little spiel in the
beginning of this this kind of exercise
as you know it as I was making these
slides I went and I typed into Google
and then later Bing because I was gonna
be here you know some basic questions
about water what is money and this is
what being tells me money is money is
basically banknotes dollar bills gold
it's sort of not a very useful
definition except for the fact that it
tells me that money is referred to as
dosh and greenbacks which I thought was
kind of cool but not not a particularly
thing a useful thing so I wanted to get
a slightly better definition so I was
getting ready to go to the library and
find an econ textbook maybe and get you
know some primary source but then I
realized the library was like 15 minutes
away and it was kind of hot so I just
went to Wikipedia and I got the basic
definition which tells us that money is
a medium of exchange a unit of account
and a store of value which to me you
know thinking about this as an engineer
tells me that it has to meet some of
these basic properties it has to be you
know there has to be some limited
quantity of money
meaning you can't just make it
arbitrarily I have to be widely accepted
by a group of people for some reason and
then more importantly this medium of
exchange idea means it has to be easy
for people to transfer from one person
to another okay so this is what money
looks like to most people this is what
money looks like in science fiction
where you have things like the
Hitchhiker's Guide to the galaxy I
thought it was a great example of a
medium of exchange that was not easy to
exchange this is called the ninki it's a
coin that is 6,800 miles across and made
out of rubber so so there all kinds of
different examples of money in the world
and in the literature so the problem
that we're going to address here is a
little bit more concrete we're gonna
look at the problem of building
electronic money and again a lot of
these things are probably things that
you've all thought about in the past but
when you think about how do you build
electronic money you kind of arrive at
two possible directions one is very
difficult if you go down that direction
and the other is actually very easy the
very difficult one is to sort of take
the idea that money as we think of it
today is essentially information it's
ink written on a piece of paper with a
serial number for example and the
analogy there in the computer and
network world is it's a file so we'll
just translate this into a file and then
we'll use computer networks to exchange
it and of course you've all probably
thought about this for at least a few
minutes and you know that this is a
terrible idea and that all kinds of bad
things will happen to you when you start
trying to exchange money like this not
least of which is that the difference
between me handing you a $20 bill and me
sending you a electronic $20 bill is at
the end of the first transaction I no
longer have the $20 bill which clearly
is not going to be the case with
electronic money so this turns out to be
possible but very difficult the much
more obvious approach is just stop
trying to treat things as traditional
money and just do what all modern baek's
do which is create a centralized ledger
that just says Alice has $50 Bob as $60
Charlie has ten dollars whenever
somebody wants to transfer money from
one to the other just subtract something
from one accounts and add something to
the other accounts and this approach
when you think about it is essentially
when you move it to a digital model is
the the basis for all of the money that
we really use today
with a few exceptions all the way down
from the Federal Reserve to credit cards
even to these you know little cash out
tickets that you get when you go to a
slot machine in a casino
somebody is maintaining a database
somewhere that has amounts and it's
highly highly centralized so the
problems with this approach are obvious
I mean their problems to me at least and
the biggest one is that you need to
trust somebody to be your bank and that
person is going to have to be
centralized you're gonna have to have
one of those people or maybe a small
number of people who work together to be
your bank there are so many different
things that can happen obviously if
they're someone at the level of like the
Federal Reserve or a currency issuer
they can just go bust and so not only
are they creating the money but then
they stop backing the money and it goes
away maybe at a lower level we're much
more used to things like this for
example banks going out of business
we don't panic about that very much in
modern economies because we have legal
and regulatory backstops to this but it
does happen and it happens actually
surprisingly often so this is kind of an
issue before I get to privacy the other
thing that I would I would mention here
is that yes we're used to things failing
but when you think about the problem
with requiring a central bank the real
issue is not that it will fail it's that
nobody will bother to set one up in the
first place because you won't be able to
find somebody who's going to take on
that role so for every bank that's
failed there have been a hundred people
who probably could have used a bank but
just weren't able to get it together to
find a person to fill that role in the
first place the other problem that you
get in these centralized account based
currency systems is a privacy issue
which is that of course your credit card
number credit card company sees every
transaction you make everything you buy
everybody you interact with all of that
information gets kept it's available at
to law enforcement it's available to
marketing people and who knows what goes
on you know who knows how secure these
these systems are so they could leak out
later so I was talking to Arvind
Narayan I think is how you pronounce his
name and he suggested that there was
kind of this Zucco's triangle of what an
ideal currency should be he was saying
that well it's kind of a triangle and
that the three points of the triangle
you
have the notion that a perfect
electronic currency would be completely
decentralized you wouldn't have to have
a bank on the other point you would have
that it's secure
which encompasses all the things you
need for money like you can't
counterfeit it and you can use it
properly and on the third point you
would have privacy that you can use it
anonymously and you wouldn't have to
worry about people tracking your
transactions and then he said to me you
know isn't there some folklore result
that this is impossible so I went and I
looked on the internet and I couldn't
find that folklore result but I'm gonna
just go ahead and put this up here
anyway because I think it's a useful way
of thinking about things can we build an
ideal currency that meets all three of
these goals simultaneously which brings
us to a currency that's gotten very
popular over the past few years and
that's Bitcoin how many of you guys know
how Bitcoin works okay so how many of
you guys like could sit down right here
and explain to me how the Bitcoin
blockchain works okay okay so so Bitcoin
before I go on this this sign I found
this on the front door of the University
of Maryland computer science department
it's this is how you know you're
entering a computer science department
and not say like political science
department so this was there but this
was during the when it was $250 for a
single Bitcoin phase a few weeks ago so
bitcoin is an electronic decentralized
currency it was proposed back and I
think 2008 by a guy or group of guys for
all we know name or a group of girls
named Satoshi Nakamoto nobody knows who
this Nakamoto person is because they
only interacted electronically and sort
of anonymously with everybody else it
was proposed as a paper but it was also
given as a real practical implementation
with software you can see and there are
citations in the paper and it really is
clearly an extension of some previous
systems that existed one is be money and
the other is something called bit gold
that had a lot of the features that
Bitcoin has today but not all of them
they're in one package and Bitcoin kind
of polished that up and got everything
together and made it all work so the
basic notion behind Bitcoin is that it's
a way for a bunch of people to get
together and without having a single
trusted party allow for the creation of
currency the exchange
transfer of currency and to do this all
in a completely peer-to-peer setting
where it all works as long as most of
the peers or a good chunk of the peers
are behaving honestly for some
definition of honestly the really
amazing thing about Bitcoin which takes
it away from just being you know kind of
a some goofball on the Internet proposed
this idea is that people actually value
this Bitcoin stuff for real money I
don't know why but when I wrote this
which was a few days ago the total
market capitalization meaning the value
at least at the current price of Bitcoin
of the entire economy was one point
three eight billion dollars now
admittedly that's down from two point
two five billion dollars which is what
it was two weeks before but it seems to
have value and you can actually buy
things with Bitcoin which is pretty
surprising so I'm gonna give the world's
quickest explanation without computers
of kind of how you might build something
like Bitcoin I'm gonna just go through
this quickly so yeah I was trying to
find alternative clipart so this is our
Alice okay so I want you to start just
from the assumption that we have some
massive master Bank we're gonna get rid
of this Bank in the end but just imagine
that we have some bank that is issuing a
cashier's check and the cashier's check
belongs to Alice everybody trusts this
bank and so we can know that Alice
really has this money just by looking at
this cheque okay so now Alice has a
problem which is that Alice wants to
give some money to Bob Alice could
obviously go and cash the cheque or
deposit it and then write another check
but that would require a lot of you know
time and difficulty so really what Alice
wants to do is just take this cheque as
is and transfer the money directly over
to Bob well an easy way to do that for
Alice is just to flip the check over and
on the back do this thing that we've all
done at least at one point in our lives
just sign the cheque over say pay this
cheque to the order of Bob and then put
a signature on the right below that
which authenticates it now anybody who
gets this cheque from Bob can look at
the front say I trust this flip it over
say okay this is a valid signature
therefore Bob really owns this check now
and so we can move forward with this to
another person so Bob can now pay
Charlie just by appending a little bit
more information and then signing it and
so now we have a mechanism by which we
can transfer these kind of files or
digital tokens from one
to another so the question is how do we
make this electronic and how do we make
it secure well the first thing you
obviously will observe is that we
shouldn't use handwritten signatures
what we'll do is we will actually
replace Alice's name with Alice's public
key and we will simply use digital
signatures to authenticate these
transfers so now the check is a file the
file says Alice has this thing way if we
trust the original file then we can
simply chain on ownership transfers by
using digital signatures in a pretty
obvious way the problem is that this
gives us back to this double spending
problem that we originally had which is
of course now Alice can take that cheque
make two copies of its and one two Bob's
and one two Charlie they both think that
they've got the same amount of money
except that Alice has now doubled his or
her amount of money if Alice really
takes this to an extreme she can do this
or he can do this a thousand times and
then you end up with a currency that
doesn't work so how do we solve this
well the simple answer is we go back to
our centralized database idea we have a
central database that simply keeps track
of all the spending that's occurred on
the network so every time Alice
transfers to Bob that item gets
registered in the database
Bob can check that this has never been
transferred before therefore there's no
double spending and so on we know how to
do this with databases it's easy but the
problem is we don't want to do it this
way because we'll lose all of our
decentralized capability if we go this
way the way that Bitcoin addresses this
is to use a kind of a distributed
consensus approach so instead of having
a central database that keeps this
information we divide this database up
and have many many different parties
that appear to peer network replicate
the same information so that's at least
a start that means we don't have a
central database that's trusted to store
it but now we have other problems how do
we make sure that everybody has the same
view of this database how do we update
this database in a way that makes sense
so one thing that we can do at least to
try to tie the database together one of
the things I should mention is the
database just for convenience is going
to be broken up into blocks each of
which consists of a number of
transactions now the blocks are ordered
the transactions inside of the box don't
have to be so basically what Bob can do
if there's a transfer is he can say okay
I want to put a transfer in this block
has you know that same money been spent
in a previous block and that's what
allows him to detect double spending so
the question is how do we tie these
different blocks together well that's
easily done - we can use hash chaining
we can simply put at the bottom of each
block a hash of that block and all
previous blocks which means that if I
trust block n then I will know that all
previous blocks are somehow consistent
with that block and everybody else if we
all agree on block n then we all agree
on the previous blocks okay so a harder
problem is how do we how do we trust
this distributed network to group up and
add transactions to this to this ledger
to this blockchain well the way we do it
is first we can set up a distributed
broadcast network essentially where any
party who wants to can broadcast out
that they're doing a transaction that
they want to put a transaction onto the
blockchain now we could simply appoint a
central party to be the one who gets to
add things onto this chain and we all
trust that person but that means that
party is again another place where the
system can break down because they could
selectively add transactions or do all
kinds of things to hurt the network so
instead what we want to do is distribute
the ability to add blocks to the chain
the way we do that is we have all of the
different nodes compete with each other
in a kind of a lottery where only one
node is going to win that lottery for
each given time period and that node is
the one that then gets to output a block
which will of course be chained on to
the end of this everybody who sees that
node will then trust that to be the most
recent note in the blockchain and then
the process repeats so the particularly
that we're going to use is called a
proof of work the proof of work that's
used in Bitcoin is a very simple one
what we do is we hash the block which
includes you know another hash of all
previous blocks and we essentially
construct a block such that the hash of
that block ends with a certain number of
0 bits now the number of bits is
adjustable it could be 1 it could be you
know 30 it could be anything and that's
a dial that gets adjusted over time but
what this means is that in any any given
time period you have a bunch of
different nodes all in this network
putting together what they think should
be the new block that's added to the
system then they compete to be the first
one to find a proof-of-work to find
block that satisfies this particular
condition which is it hashes to this
structure value the minute somebody
finds that value that particular block
they output it to the whole network
everybody can immediately check that
that's a consistent block they make sure
the transactions are ok the hash chain
checks out and if all of those
conditions are met they drop whatever
they were working on and they adopt that
to be their new block and so then they
try to chain on the next block on top of
that and this happens every few minutes
in Bitcoin and the idea behind this is
if we assume that everybody in the
network has roughly the same
computational power that should because
this process there's there's essentially
a nonce that can be incremented inside
of these blocks that's what allows you
to try many different values we can
assume that the person who wins this
will hop around the network now
obviously not everybody in the network
has the same computational power some
people will be able to hash more compute
more hashes in the given time period so
there's going to be a bit of a race to
see who can deploy more computational
power but if we assume that hopefully a
majority of the at least the
computational cycles in the network are
controlled by honest parties there's a
lot of big assumptions in here we can
hope that most of the time honest nodes
will be winning this competition which
means that the damage that a bad node
can do is is pretty limited because
anything bad that they do will either be
detected by the honest nodes and
rejected or you know if they're just
blocking transactions
well my transaction might get blocked by
this bad node but the next honest node
who gets it will not be trying to keep
me out of the blockchain so this is a
very quick description of kind of how
Bitcoin works doesn't cover all the
possibilities that can come up and I
recommend you read the paper or the
papers that are on this if you want to
know more but does this kind of make
sense for the moment yes
oh gosh oh gosh oh gosh not well yeah so
so what will happen is that gosh in that
case you can actually have situations
where the view of the network splits you
have one group of nodes who believes
this is the most current block this is a
very unlikely case it could happen this
is the most current block and this is
this other block is the most current
block so then the network is now split
what's going to happen now as a
competition is going to begin or each
half of the network starts to try to
chain a new block on to the rest there
is a merge protocol where ultimately
hopefully the network will doesn't
always work very well but ultimately one
of those chains will get longer and the
idea is that the nodes are supposed to
look at all the chains that are out
there when they see a fork like that
they will ultimately resolve on the
chain that is longest and drop the one
that is shortest I can't tell you if it
actually works but this is the yeah well
yeah so there are two kinds of splits
they're the kind that happened because
everybody's participating properly and
then it's just bad luck right and that
just happens the other kind of split is
where there's a bug in one half of the
software and they disagree on what makes
a valid block and that's what happened
is there was a version 0.7 and a version
0.8 of the client and they disagreed
about how many transactions could be in
a block which caused a bunch of the
nodes to say well this block is totally
invalid has too many transactions
because it was being made by newer
software and then the network diverged
and what actually happened was the
Bitcoin people got up and they jumped up
and down and they said everybody stop
using that software and then ultimately
one of the things got it so that it was
not a not a great case but this is a
case where the protocol didn't work
because there was actually bug a bug in
the client three classes yes we're an
adversary finds a coin and sits on it
until the first sign of somebody
broadcasting a new coin and then
broadcasts too so
yes there are definitely things that can
happen like that however you have to be
careful about that because if you miss
that timing and it's first of all it's
hard to do it if you miss that timing
then you're you're hosed and you may not
be able to get a correct block in the
next time there are many ways you could
probably upset Bitcoin I'm definitely
not gonna say that this is a perfect
system but the amazing thing is despite
all that it's managed to work in a very
adversarial setting for several years
now it's a peer to peer kind of fill
flood Network essentially where you put
stuff on there and it just gets sent out
to all the other nodes I'm not too
familiar with the details of that
channel but it goes out and then it
everybody gets to see it and then they
decide these nodes that make the blocks
themselves are called miners and there's
a reason they're called miners aside
from doing the actual work of solving
these proofs of work there's a reason
that they do this work and I'm assuming
you know when you actually solve a block
you get rewards and one of the rewards
is that you are entitled to mint to
yourself a brand new 25 bitcoins so what
happens is in addition to the
transactions you gather it up off the
network you get to make one more
transaction that says I assign myself 25
bitcoins and then of course later on you
can spend that Bitcoin so that's how
currency is created the currency starts
essentially with at zero and then over
time you make more and more of it and
you fill up the system now this reward
has gone down it started at 50 it's now
at 25 it's gonna go down to 12 and a
half in a few years and ultimately
according to the protocol as written
today it will go down to zero at that
point a second mechanism of incentive is
supposed to take over which is that
nodes can also when you send out a
transaction you can include what's
essentially a tip by a transaction fee
you can say the node that puts us into a
block will get 35 cents or 35 you know
hundreds of a Bitcoin or something like
that and then nodes can basically look
miners can say well you know maybe that
transactions not giving me enough of a
tip I'm not gonna bother to put it in my
block so you end up with this kind of
market solution where I put out put out
notes have low transaction fees nobody
includes them I put them out with higher
transaction fees they get included very
quickly and we'll see if that works it's
very hard there's there are a million
game theory papers to be written on how
Bitcoin works because who knows what the
incentives are right now and they're
probably all misaligned but it works yes
well yeah I mean there is this Bitcoin
Foundation which does make some of the
clients and then they make decisions
about the protocol but there are lots of
different implementations so it's not
really completely centralized the first
version was but after that people have
made Python implementations Java
implementations so it's not completely
centralized and you have the ability to
dump it that leads to these software
compatibility issues so that's kind of
risky but that part I'm not too too
worried about maybe okay so let's look
at the Bitcoin the triangle that we had
before and see where Bitcoin falls into
it okay so first of all it's
decentralized you know for some
reasonable definition of decentralized
definitely meets that criteria it's
secure with the exception of certain
things that we might hope are not gonna
happen to the blockchain it's reasonably
secure and it seems to work but is it
private do we have any kind of privacy
guarantees in this network well not
really and the reason that bitcoin is
not private and kind of very famously
not private is that the blockchain is
you know both its best feature and its
Achilles heel in terms of privacy it has
every single one of these transactions
has to be replicated and available to
the public I have to be able to start up
a Bitcoin client and be able to download
this all from another node which means
that the history of every single thing
that's ever happened in Bitcoin is
entombed inside of this block chip now
there's some mitigating factors one of
which is that we don't use names it's
not Alice and Bob it's public key a and
public key B and moreover there's no
need to actually register these public
keys with a network you just generate
them and start using them so I could
make a thousand of them I could make ten
thousand of them so what this really is
is a pseudonym system not an anonymous
system so is that good or bad can we can
we break the privacy and these things
the answer is yeah probably because we
know how to extract information from
graphs like this there's some really
stupid things that happen now that are
just trivially that so let me give you
an example I went on Twitter and I said
because I'm giving this talk I want some
please you know give me a few cents give
me a few toshi worth Satoshi is a
Bitcoin divided by eight decimal places
or something just send me a few so that
I can show you know what it looked like
to get a Bitcoin so someone actually
sent me sixty dollars which is awesome
but then this person sent me twelve
cents which was cool to let me show you
let me show you what's happening here
so bitcoin addresses are actually the
hash of the public key so that's what
these numbers are here so I know it's a
little hard to see back there but this
is the sender address ends in M V M here
we have the amount so this is a previous
transaction that was worth two dollars
and forty three cents this has been
converted into dollars so the previous
transaction was worth two dollars and
forty three cents this person wants to
send me and I'm the guy who went to a
ckw twelve cents of that so that means
that there's two dollars and twenty five
cents left over where is that money
going to go well the person could send
it to somebody else who happens you know
they happen to owe someone else two
dollars and twenty five cents but most
likely they're gonna send it back to
themselves well the way most Bitcoin
clients work today is to create privacy
they automatically generate new public
keys all the times you may have dozens
of public keys and the idea is this is
good for you you have lots of these sort
of identities the problem with a lot of
Bitcoin clients is they don't realize
that when you do a transaction like this
where you're sending somebody some money
and you have change left over
you probably shouldn't send the change
to one of the other public keys that is
supposed to be the key that's you know
your other pseudonym that's protecting
your identity because this binds those
keys together and shows me these two
identities are the same person
so you're I can I can poke and show you
so this is me and this person who has a
totally different ID is almost certainly
the person who sent me that money and
from here forevermore I know that these
two identities are the same so if the
first one sends some money to his
grandmother and the other does a drug
deal then I know that you know they're
the same people so that's that's kind of
worrisome maybe we can fix that but it
turns out that even if you kind of fix
oh paper over some of these bugs a lot
of people are now looking at this
problem and saying how do we get
information out of Bitcoin there was a
least two papers in financial crypto
2013 and these are kind of the beginning
works I think they're going to be more
some people have done other work like
tracing batches of stolen bitcoins
throughout the network and and done very
well at figuring out what happened to
them after they were stolen this one is
the reason that I gave this subtitle in
my talk so a few days ago somebody on
the internet this guy Sergio Lerner went
through the historical blockchain data
and he was not looking at transactions
that people were making he was looking
at miners and how well they were doing
at making money early on in the in the
in the evolution of Bitcoin so Bitcoin
really started out around January of
2009 and this data goes through January
of 2010 and each of these dots on the
screen represents one miner making 50
bitcoins succeeding in getting a block
and getting 50 bitcoins now you'll
notice that some of them are red and
some of them are black anyone know what
the black ones are okay so the black
ones are well let's see so they're
they're a single mining rig and we know
this because they actually each of the
Bitcoin blocks include two nonce and
that nonce field increments and so we
can see that these are linked they're
increasing at the same rate we can see
that these are the same person
succeeding and you know mining block
each time 50 bitcoins did I mention that
bitcoins are currently worth over a
hundred bucks so this person is making
50 bitcoins each time they do this and
they're making a lot of them much more
interesting is that the this black chain
here starts at the very first Bitcoin
block so this person is Satoshi Nakamoto
this person is the guy who authored or
guys who authored Bitcoin and you can
see what they're doing is they're mining
some Bitcoin rebooting their computer
mining some Bitcoin rebooting their
computer and so on now how many in
dollars how many Bitcoin do you think
are represented on this this graph right
now any what a guess of how rich this
guy is now at least if you believe the
current price of Bitcoin 100 million
dollars just in this graph so far so
he's a very rich guy but here's the
crazy thing
none of this Bitcoin has ever been spent
this guy disappeared in 2011 or so has
never been heard from since and if this
is him he's either dead or maybe he lost
his wallet which means he can't spend it
or else he's waiting out there with his
hundreds of millions of dollars
and just gonna see what happens but
let's say you're this guy and you want
to spend your money how do you do it the
minute you go and you start to cash in
some of these vidcon's everybody's gonna
know who you are and they're gonna be at
your door asking for money or whatever
it is that people do when you have a
hundred million dollars in a crazy
cryptocurrency so he has no really good
way of getting this money out at least
without revealing himself so that's you
know we need anonymity for a whole bunch
of reasons this being a particularly
extreme one okay
sorry yeah this is not too helpful okay
all right so I've covered a lot of sorry
was there so I've covered a lot of stuff
and I haven't actually gotten to the
technical content of this talk but let's
just give a couple of more things you
need to know before we go forward so
what privacy solutions are in existence
today for Bitcoin well one solution is
be careful which means get better
clients that don't you know link your
keys together this is the current way
that the Bitcoin foundation people are
going is just trying to avoid these
trivial mistakes but that's not gonna be
enough it's not going to be enough
because the current attacks that we know
on privacy are all passive attacks if
you think about active attacks where
somebody puts marked bitcoins into the
network it's gonna be much worse another
solution is to use something called a
laundry service and a laundry service is
exactly what you guys think it is to mix
where you get a bunch of people together
they put their coins together the
laundry service randomizes them and then
hands out the coins and we all hope that
the trail goes dead because you can't do
naanum eyes the eight people who got
together and did this but in reality
it's probably not gonna work very well
at least with the trusted mixes that
exists today because you don't know if
they're doing it right there you have to
trust them you don't know if you're
gonna get your money back and the volume
is pretty low so not great solutions the
other solution which is the classic
solution is we all diplomatic cash let's
we have this great ecash system let's
get let's get David charm out here let's
get him to startup you know did you cash
again and what he'll do is he'll set up
a server and it will dis you blind
signatures and you know I know that
people here know a lot about this and
you make yourself maybe in a great
position to do this fine so you do all
this stuff but again this is not
consistent with a Bitcoin network model
because again all of these systems are
based on blind signatures and blind
signatures
a signer and a signer implies something
central you might use threshold
cryptography to distribute that a little
bit but let's you know it's not gonna
work so so that's not such a great
solution either so again the triangle
doesn't work so well for the
decentralization so so I have until
about two twenty or so and then plus
questions or okay okay
all right I'm shooting for 45 minutes so
if I enter or leave that that's what
will be okay so this is a new approach
so we spend a little bit of time
thinking how do you add cryptographic
ecash real cryptographic ecash to
Bitcoin without adding trusted parties
or doing crazy things how do you just do
it with the existing system well we came
up with this thing called zero coin and
zero coin uses some some actually pretty
standard techniques in crypto it's based
on a technique now I say it's based on
the technique that was originally
introduced by sender and touch ma we did
not know this until a week before we
submitted the paper so we had never
heard of this technique we came up with
an approach and it seemed great and then
we found out that there were some
similarities in an older paper by sander
and Sushma but they had two problems one
of which is that they didn't have
Bitcoin the other one is that they
actually had a very inefficient
construction that would not have been
realizable so what we have is this new
protocol which is actually implemented
into Bitcoin really at the protocol
level does not require trusted party
just changes to all of the Bitcoin
clients that are out there it uses what
it does basically is it doesn't create a
fully fully cash system instead it
creates what we call a decentralized
laundry the idea is I can take real
bitcoins I can transfer them into the
zero point thing and I can pull back
bitcoins with exactly the same property
you'd expect from a laundry except that
we don't have to have a laundry doing
that work the only thing that our
protocol requires beyond the crypto I'll
get to explain what that means but the
only thing that we need as an assumption
is we need the existence of a trusted
trustworthy append-only
transaction log and wonderfully it turns
out that Bitcoin gives us a transaction
log essentially for free we can just
leverage the Bitcoin blockchain
so here's the intuition behind how Xero
coin works all using very standard
components so first of all Xero coins
themselves are obviously just
information they're numbers the first
thing we do to make Xero coin is we pick
a random serial number which is just a
large number and then we use a
commitment scheme with some parameters
and I'll come back to where those come
from in a second but we use just a
standard commitment scheme to commit to
that serial number so now we have this
commitment
there's nothing computationally hard in
making this so they're not really worth
anything at this point you don't want to
go spending them because anyone can make
them in a fraction of a second what
makes these things have value is the
fact that you have to put them on the
blockchain and you're not gonna just be
allowed to put them on the blockchain
for any reason at all in order to be
allowed to put one zero coin onto the
blockchain you have to spend a Bitcoin
the denomination here is essentially
fixed all zero coins are worth one
Bitcoin could be a hundred bitcoins just
we pick one Bitcoin for this example so
you introduce a transaction that says
it's just like traditional Bitcoin
transaction it says I have some previous
bitcoins from this source and I'm going
to instead of giving an output you know
so saying it goes to this person I'm
just going to attach a blob of data
pretty small blob of data and that goes
on to the blockchain and now I have a
zero coin now the information that I
keep private here is two things one is
obviously the serial number itself it's
just a commitment that I put up and of
course I also keep the randomness that I
used in making that commitment and that
becomes my trapdoor essentially what I
want to go spend that zero point again
now how do I get these back well the
first thing that I'm gonna do is at some
later point maybe a hundred blocks later
I'm going to redeem this using a
different transaction what I'm gonna do
first is I'm gonna form this transaction
by just including the serial number that
I generated in the and when I made the
Bitcoin so that's simple enough and then
I'm gonna give a proof and the proof is
going to tell me two things it's going
to tell anybody who verifies a
non-interactive proof it's gonna tell
people first of all this serial number
actually sorry let's try it again so
it's gonna tell first of all I know a
zero coin that is on the blockchain
everybody has a consistent view of the
blockchain so I know one of these things
that's easy then it's gonna say I also
know the randomness that causes that
zero coin commitment to open to the
serial number I just gave you the very
symbol and when I give you that proof I
also say and by the way I would like you
to now deliver me one Bitcoin to an
address another Bitcoin wallet another
Bitcoin identity of my choice
hopefully it's a new Bitcoin identity
and not linked in any way to the
previous one so it's a laundry I've just
gotten one Bitcoin back now the question
is where do the bitcoins come from and
where do they go the answer to that's
actually really simple what happens is
that whenever I redeem a zero coin
remember every time I put one of these
things in the Bitcoin that I used to
create it just sits there on the
blockchain it's not going anywhere so I
take one Bitcoin I introduce a
transaction that says this Bitcoin that
I have that I control is now going
essentially into a kind of an escrow
pool and what that means is now nobody
there note semantics there's nothing you
can introduce that's that allows
somebody else to spend it
it is now sort of locked up in the
blockchain unless they introduce another
message that allows them to take back
one of those those bitcoins that was
locked up in the blockchain and of
course that is the zero point spend
transaction with that proof and when
they give that proof they're allowed to
go through the entire blockchain find
some other zero coin that was created
and identified it could be created by
some other party and they just say okay
I want those bitcoins back and they
could just pick one at random does all
this makes sense I'm not sure if my hand
waving is helping or hurting okay good
yes okay it's a it's a very it's a long
number it's an element and you know it's
the exponent of like a schnorrer group
it's it's a it's a big number and it's
adjustable obviously you can make the
security level higher or lower depending
on how you configure the parameters okay
so you have this thing and so you're
able to take back these things now
obviously the next step is just to take
that proof that non-interactive proof
and make it a non-interactive zero
knowledge proof which means all we're
proving is these two statements and
there's no actual way for me to link
these specific spend transaction to the
mint trance
action that created it and so now we
kind of get this you know or creating
the equivalent of kind of an ideal
laundry which gives us the same
guarantees not perfect and emiti
guarantees obviously but yes so that
actually is not part of the proof once
we've said you know this is the serial
number and this is a valid serial number
then the semantics of the transaction do
actually I'm sorry I should have
mentioned that you would of course in
verifying this check that that serial
number has not appeared in a previous
spend transaction so what we're doing
here is proving that the serial number
is a legitimate zero legitimate euro
coin serial number that's what the zero
knowledge proof proves then it's just a
question of making sure that serial
number has only been seen once and
that's not a double spend so yes I think
you're saying the same thing there but
it's not part of the Ciara knowledge
proof of course the serial number is not
because the serial number is never
revealed we have this commitment to a
serial number we never reveal the
randomness we prove knowledge of the
randomness and so now as long as
everything works it's the commitment as
binding and the zero knowledge proof
works then we know that you can't double
spend obviously you know with all but
negligible probability and then you
adjust how strong you want that to be
okay so that's the basic protocol yes
yes yes that's essentially it so I'll
get to the details of that which will
involve accumulators but that's right so
we assume that when I do this proof I
have a view of all previous transactions
including all zero coins thus far made
and I'm proving that I know one of them
and I know the opening to that
particular one so yeah again you can you
can then ask well what is the anonymity
that gives me that answer is more
complicated because of course if you're
the only person putting a zero coin in
the blockchain it gives you no anonymity
and if there are attack scenarios where
somebody malicious puts a lot of them on
and but it's trying to dia naanum i's
you but you can't really do much better
than that there so these are kind of
just basic limitations of an anonymous
kind of laundry system mm-hmm okay so
zero knowledge proof
all right I didn't know I have a
citation to goldwasser McCauley four
zeros but whatever so we do okay so I'm
saying okay so this is this is kind of
you know the stuff that I just said so
the trick is how do we do this proof
efficiently what what primitives do we
use how do we actually tack this
together
obviously we can do this I mean it goes
without saying that you know we can
prove anything but or anything in NP how
do we do this efficiently so what you
might think of is you might think of
using some kind of standard snore type
proof which allows you to do or proofs
you could do something like this you
could say go through the entire
blockchain identify all of the zero
coins that have appeared there just
commitments up until this point and then
you say okay we'll prove knowledge that
we have a C such that C is equal to C 1
or C equals C 2 I can't tell you how
many papers I've reviewed that have
proofs like this in there and they're
like yeah it's an efficient proof but
it's not an efficient proof it's a it's
linear in n which is maybe a million
zero coins that have been minted in the
past you're not gonna fit this proof
into the blockchain so another approach
is that what you can do is something
that's no pretty old technique we use
and it's a very old technique we use an
accumulator what we do is we go through
before we do this proof we we use a
one-way accumulator to just gather up
all those coins instead of doing this or
proof we stick all of those coins these
commitments into the accumulator and now
we have the single accumulator value
this accumulated thing this root and
then what we do is we generate a witness
for our specific for membership of our
specific 0 coin and it turns out that
now it's much easier to do this now I
wasn't sure what audience I was going to
be speaking to so I'm assuming that most
of you guys know quite a lot about
accumulators but the example that was
actually given an older work was the you
know Merkel hash tree where you just
basically you know put the coins down at
the leaves you hash them up into an
accumulator and then you have this nice
kind of log and proof of membership and
that's great in the sense that well it's
great for a bunch of reasons except that
it's really terrible if you have to do
is your are knowledge proof because as
we know with possibly some exceptions
it's very hard to do this kind of hash
tree proof efficiently I suppose you can
use something like Peterson hash or
something like that and
maybe that would be possible but I don't
know how to do it very efficiently
fortunately we have some very efficient
accumulators so let's just well before I
get there actually let me mention one
thing we need an accumulator and there
are lots of accumulators out there we
need one that has a particular property
which is that when I do the accumulation
anybody else should be able to verify
that I've done that accumulation
properly there are some accumulators
where you can only do the accumulation
if you know a trap door for the
accumulator and that's not going to work
very well because who's gonna hold that
trap door so we need something that's
kind of publicly computable or very
least publicly verifiable there are a
few of these Merkel trees would count
but they don't have this efficiency or
knowledge proof so what do we use well
we have the you know we have this strong
RSA accumulator there are some bilinear
ones too but they actually are not for
other technical reasons particularly
good for this application so what we use
in our construction is we use the strong
RSA accumulator which was by Bonello and
DeMar DeMar close enough
which basically is a very simple
accumulator you pick it does require a
trusted setup you need this modulus this
n equals P times Q but you never need
the P and the Q again you can throw them
away
so we could have some trusted party come
and generate these things and then we
can shoot them and then we have just n
okay so now what we do to accumulate
wellit's we just also pick this value u
and accumulation is simply just repeated
exponentiation computing a witness is
basically just doing the same thing but
omitting the value that we want to prove
membership of from the list of things
that were exponentiating and then
verification is just you know verifying
that this thing raised to the value that
we want to prove membership of is equal
to the accumulator value and it's a
great thing it's great for a whole bunch
of reasons and one of the reasons it's
great is that Kamlesh and lizhen skaia
and 2001 made some small changes to the
vanilla damar accumulator and they were
able to show a very efficiency or
knowledge proof which is what we use in
our protocol the only modification that
you have to make here is you have to
make each of these C values be a prime
not a big deal alright so here is 0 coin
minting and
in a nutshell it's pretty
straightforward what we do is we first
generate a random serial number s which
is you know some value and zq or q is
the order of the group we do a standard
peterson commitment with some randomness
are the only thing that we do is once
we've done this Peterson commit when we
check to see if the result is prime it's
not a prime we throw it away we pick a
new serial new randomness and we start
over again so ultimately this you know
may take a few iterations but ultimately
we wind up with a commitment C that is a
prime or at least with high
probabilities of prime we keep s we keep
the commitment randomness R and that's
our trapdoor for spending this thing
ultimately when we want when we want to
spend this we go through and we collect
all of those C values from everybody on
the blockchain including ours and we we
accumulate them all and we compute a
witness and then we execute the standard
we reveal s we prove knowledge of the
witness using the cam initialism sky of
proof and then we also do a separate
proof that shows that we know the
commitment randomness and unfortunately
and this is kind of the part that that
stinks about this to do this we need to
do a double discrete logarithm proof and
that makes it much more expensive than
other snort type proofs would normally
be if we didn't have that double
discrete log so the cost of our proof
for reasonable parameters is about 40
kilobytes which stinks it could be but
it could be better so there are actually
some techniques we have to shrink that
down but this is probably the big
weakness of this system yes you would
think it would be wouldn't you but it's
not and the reason is that first of all
it's actually not that expensive period
but it turns out that this accumulator
is incrementally computable so if I
compute the accumulator on let's say the
set of coins up until time one and then
somebody adds another block of you know
100 transactions I can just take that
check point that accumulated from here
put on those hundred transactions and
then compute another accumulator check
checkpoint which is what we call it and
so essentially we also modify the client
the miners to as part of the protocol
compute the accumulator as they go and
do it for us so actually that work has
just shunted into the network we do have
to check it people have to verify
multiple nodes will have to verify that
the accumulator being computed is valid
but that's not the end of the world
because you know they're only a few
hundred transactions per block so it's
not a
ton of computational work so actually
that's great so we can get rid of all
the work in there not all the work but
we can we can amortize that work in the
in computing the accumulator which turns
out to be fairly pricey it's we we've
been shooting we actually did different
sizes we have like thousand 24 2014 3
thousand 72 bit yeah so you have to
adjust you have to adjust the actual
security level because since it's a
hassle you're kind of reducing the space
of commitments it weakens it a bit but
only but not by you know it's it's
there's there's a weakening it's you
have to sort of dial up your your
security there's a somewhat arbitrary
yes to the dollars to get I'll show you
in a sec we have real numbers so yeah it
actually is more expensive you'd think
but you know it's not that bad yeah no
it's not I mean when I say more
expensive I'm talking like a second or
two not like two hours and 30 minutes so
yeah that's an issue okay yeah so this
is the question you just asked obviously
we have some optimizations in here we
can do this incremental computation of
the accumulator another thing that we
can do is because this proof happens to
be one of these it's an iterative proof
where what we actually do is we you know
you the more are taught the more
executions you do on verification the
more convinced you are that this is a
secure proof of knowledge you don't have
to do them all if you do half of them
you know for example let's say the proof
the guarantee is that with you know you
can forge a proof or given invalid proof
with one over two to the 80 probability
well if you do half the executions you
might only be assured with one over two
to the 40 so you could do something
where individual nodes will each verify
different parts of the proof there are
different kinds of optimizations you can
do to kind of reduce the complexity of
verifying the proof so things like that
will work yes could you say why the
binding pairings that commits a
yeah no I want it to be I want it to be
so there are two problems with the the
avout accumulator one is an efficiency
problem so the remember that we have to
be able to do the accumulation without a
trapdoor so the the accumulators we have
in pairings are very efficient if you
have a trapdoor they can be done without
a trapdoor but then what you have to do
is you have to reveal public parameters
that are essentially linear in the size
of the number of elements you're going
to accumulate so if you're going to
accumulate a million coins the
parameters are going to be essentially a
million group elements in size maybe
that's not too big a deal you could do
windowing where you have maybe multiple
accumulators kind of computed and
overlapping windows you could find some
engineering solution to this but that's
an efficiency issue well whatever it's
just you know it's just an efficiency
issue there the real problem we have is
that what we need to do is this kind of
double discrete logarithm proof where I
need to be able to so what we do here is
we are essentially accumulating integers
and those integers are commitments
there's actually no reason we couldn't
do the same thing except that what we
would have to do is we'd have to crank
up the order of the by linear group to
make it large enough that we could
commit to you know so it's here's the
thing so what we ideally want to do is
commit do the Petersons commitment in an
elliptic curve so we'd have a nice small
or a bi linear group and then we'd want
to commit we'd want to accumulate those
group elements that are the output of
the Petersons commitment the problem is
the accumulators don't work on group
elements they work on integers and that
turned out to be a technical problem
that might be something you can get
around but we could not see a kind of an
easy way to do it so you can accumulate
integers and then you could do maybe
commitments over you know a ring or
something like that an interested ring
and you could just deal with them that
way like we do here but then you have to
adjust that by linear group sizes you
have a bilinear group of a very large
order to avoid you know field-based
solvers that would does any of what I'm
saying makes sense it all makes sense in
my head I'm not sure that moving my
hands rapidly makes it any clearer to
you but you know we kind of went through
all these different solutions and this
one seemed like the most efficient it
can be done in by linear groups what we
really want is the ability to commit to
a value in a bilinear group and then
accumulate those group elements
problem is we can't do that because as
far as I know there's actually an
impossibility result that says you can't
have an efficient accumulative
accumulator over group elements you
can't have an efficient for example hash
function that takes in group elements
and this you know actually does this as
a set of algebraic operations and
outputs a hash result that is smaller
than the inputs and I think that also
applies to accumulators yeah that
roughly I know I spent a lot of time
trying to figure out throws yeah yes
yes and in the same for money pairings
right if we could just commit if we
could just icky but then we have to
accumulate accumulate these public
values and so I'm not really sure you
know with a commitment here so okay I
want to talk to you after this okay no
III really do because I'm not completely
understanding it if there is a solution
I want to know about it because we have
an implementation of this and if we
could make it more efficient in any way
I'd like to be able to do it so yeah
let's talk after this okay so they're a
bunch of optimizations I know I'm
keeping you guys late so all right I
wanted to show you what performance
looks like so this is performance these
three algorithms this one over here is
the minting you can see it's actually
very expensive in the sense that it
takes almost a second to mint a coin
this is at the thousand 24-bit size it's
over here yeah I'm not sure why those
are the same actually but for whatever
reason in our implementation it takes
under a second to mint the coins
regardless of the size that there's a
little weird suspend them is actually
very efficient because all we have to do
essentially is create this proof it's
very efficient to verify them it takes
more time depending on the size but
verify them is actually not terribly
terribly bad here in this one so this is
actually verifying that the that the
proof is correct
so that it's not a terribly inefficient
thing the problem is not copy
a tional cost on these proofs the
problem unfortunately is really the size
of the proofs and this is where you get
into the the issue that the thousand
24-bit size proof ends up with being
somewhere between 40 and 45 kilobytes in
size and it goes up to about 50
kilobytes as you get larger now we've
done a lot of optimization this is not
you know you'd think that you would get
like three times the size as you went to
a larger modulus but what we're actually
doing is we are changing some of the
parameters we're moving over into groups
that are more efficient and doing some
of our work there so that lets us be
more efficient yes well you know it's
strong RSA and also we're making some
adjustments based on the fact that it's
prime so I'm not I'm not actually sure
what the answer is on that so yeah right
so we use God I have to look at the
paper again to remind myself but we use
multiple groups we use one group that is
where we put the commitments that are
the coin we use one group for the
accumulator and then we use the third
group when we do the proof we actually
transition things over into another
group that happens to be a little bit
smaller the groups where we can we use
snore groups where we have you know a
relatively large P and a much smaller
Q's or order of the group so that we can
kind of make things very very efficient
that way so again I don't remember we
have there's a section in the paper that
talks about all the parameter details we
worked out as I'm sitting here right now
I can't remember them all so I don't
tell you something wrong all right so
this is the upshot I can take bitcoins I
can turn them into zero coins so I can
redeem them and IV ideally nobody with
that you know the exception of educated
guessing will be able to link them so in
a couple of minutes that I have left I
want to skip this and I want to talk
about some extensions that are not in
our paper but we think are just kind of
nice maybe obvious maybe not so obvious
kind of extensions that we think are
cool so one thing we don't do is we
don't have a value associated with these
coins rather I should say every zero
coin is worth the same amount of money
and that makes sense from a privacy
perspective because you don't want to
have somebody getting a $2 and 31 cents
euro coin and then spending it too
31 sin 0 coin and then you have privacy
problems however you could if you wanted
to make this an extension these are
commitments you can put anything you
want into these commitments they could
be vector commitments you could add you
know just an amount and satoshi of how
much this thing is worth and then what
you could do is you could make this
divisible and the way you make it
divisible is you simply add new
transactions to the blockchain so I have
an initial 0 coin that I place in that's
worth $1 and then later on I want to
split this into two 50 cent zero coins I
don't need to do zero knowledge proof
for this I just insert a new transaction
that essentially creates two new
commitments and then reveals the
commitment randomness don't even need to
do zero knowledge proof just say hey
this is linked to this previous zero
coin and I want to split it up and
here's the commitment randomness that
allows me to do it and all of a sudden
now I have to $0.50 euro coins and then
later on when I do the proof I will have
to prove value as well but that's not
that's pretty trivial to do with these
proofs so you can do lots of kind of
obvious stuff like adding parameters to
these coins you could throw a zero
knowledge proof that just shows that
they sum to one zero coin and then just
show that this other thing yeah exactly
all that's doable so that's simple
here's something that we have a paper
and submission we think is cool I'm
trying to convince other people it's
cool ecash is essentially very closely
related to anonymous credentials and
anonymous credential systems while I
love anonymous credential systems I
think we can all agree that so far
they've had a little trouble getting off
the ground and one of the reasons is
that right now to run an anonymous
credential system you have the problem
of creating identity in the first place
and and somebody has to authorize your
identity and your attributes but then
you have to have this credential issuer
which has to always be online to you no
issue credentials and to handle and then
you have to get everybody to use this
thing and there are a lot of
applications where all of that work is
very heavy you don't want to have to
deal with all that and maybe there are
peer to peer networks that want to do
some kind of anonymous assertion maybe
that I'm a trustworthy node or I've done
good things in the past without
identifying themselves they can't use
these kind of heavy systems so can we
extend our existing e cache to do that
kind of work well it turns out that it's
actually possible what we can do is we
can and before I get to exactly how this
works
I should mention that there are
systems how many of you have heard of
namecoin so they're already systems that
are actually commit coin-like systems
that are not so interested in the cash
but they're more interested in
establishing identity so for example in
namecoin what's happening is you have a
blockchain just as before but when
somebody wants to what somebody can do
is they can establish ownership of a
name where a name is just a string so
you can go and you can put a transaction
to the blockchain and say hey I have
pets.com
and if you're the first person to claim
ownership of pets.com
then you own it you get to have that
name and bind it to your public key and
then later on you could transfer
pets.com to somebody else if maybe they
pay you some money or you could
establish a different name so you have
this notion that you can now establish
identity that identity can be arbitrary
strings or collections of attributes and
so on you have a time that you did this
you could prove for example right there
that I have a.com domain name for
building a domain name system and then
I've had it for at least five years so
that kind of stuff can easily be done in
a non anonymous way now imagine
extending that so that some of these
assertions are more interesting like
let's say I want to assert that I'm a
peer in some peer-to-peer network and I
have a good reputation
well the nodes who are building this
blockchain could actually verify that I
really am appear who's done good things
in the past and they could embed some
kind of assertion that says you really
are into the blockchain and then later
on I want to be able to prove that there
are other things you might be able to do
so like reputation let's say every time
I interact with a node I want to be able
to say well you know it's a good good
interaction maybe I gained some
reputation from that I can update that
into the blockchain well it turns out
that you could do all of these things
anonymously simply by having updates to
the transaction from the blockchain and
then doing zero knowledge proof but
basically putting your attributes and
your information into commitments
putting them into a blockchain and then
proving knowledge and proving different
statements about the contents of that
commitment so it could be anything from
Iowa com domain name to I have a
reputation that is greater than 100
because I've done a whole bunch of
transactions with people and yet you
still can't tell Who I am
and so we think this is kind of neat
because now it gives you a way to build
anonymous credentials without all of
that you know stuff that's very
difficult of getting somebody to issue
them all you have to do is have some
kind of assertion that you can put into
a blockchain you can prove things about
it and so we think that's nifty yes
well it depends I mean you're right that
there's a limited amount of stuff that
you can vet and there's stuff you can't
so let's say that the criteria for
getting an identity is that I have to
solve a proof-of-work
or I have to pay ten bitcoins right so
right there let's say I have a
peer-to-peer network and it's C and then
I have a problem which is that people
are running civil attacks and I can't
uniquely identify nodes and anybody can
create a million identities and run
civil attacks because there's nothing
stopping them from doing that well now I
make it so that it cost me ten bitcoins
to establish an identity I've already
put kind of an expense bound on how many
identities you're likely to create and
therefore a limited the number of
attacks that you can run or if you don't
wanna use money we could have everybody
do a very complex group of work and so
all an identity here is an assertion
that I have a unique identity that cost
me some amount of computation to
establish and that's valuable and I
think some peer-to-peer applications and
to be able to then anonymously prove
that without having to have a central
party kind of sitting there who's going
to appoint that central party I think
just that all by itself is neat
reputation systems you can do without
any assertions about anything just
interactions between nodes and then yes
of course
you could build things where you have
like an identity provider that maybe is
doing outside assertions but you could
still use this to do the credential
issuing so you could say that I don't
get a credential unless the driver's
license agency gives me a signature or
my TPM gives me a signature saying that
I have a valid TPM and then I can be in
this network so I think there's a lot of
neat stuff you can do we haven't
explored all the applications but I
think they exist sorry I get excited
about this I'm gonna I'm gonna wind up
now all right so can we build I'm going
back to zero claim can we build zero
point today well the answer is yes so we
actually built a version of the clients
the Bitcoin client is called Bitcoin D a
C++ version and my grad students Ian
Meyers and Christina Garmin um I did not
touch this so I take no credit they did
incredibly hard work and if you've seen
the code quality on this thing you'll
understand why they did an incredibly
hard work updating it and inserting this
capability into this client so it
actually works we're gonna be releasing
the code when we present at Auckland
with some cleanup so it's a real thing
and you could use it the problem is that
in order to use it in a sort of coherent
fashion you need all of the Bitcoin
nodes to
adopted kind of simultaneously so
incremental adoption is hard there are
some things that you could do along the
way where you have temporary trusted
parties who could help you keep get the
system going and then ultimately you
could get rid of them so we hope that
there's kind of a solution that people
will do it the other thing that we have
to worry about is there's a lot of cost
to verifying these proofs and that has
some implications for the stability of
the Bitcoin network but it's a real
system you can actually use it's not
just a paper anyway so there's there's a
lot of future the last thing that I want
to cover and then I'll stop is what are
the ethics of doing this in the first
place I mean are is it let's say that we
do it let's say that people actually
think it's secure and let's say people
implement it is it a good thing that we
have an electronic and a decentralized
currency that is actually sort of
untraceable
are we facilitating crime by doing this
or are we creating a world where you
know everybody in the world can't see
that I bought medication from my
pharmacy which is the way things are in
Bitcoin today so I don't really know
what the answer to that is but I do
think that there's value in pursuing
this and then seeing what people make of
it so that's it I don't think I went too
far over but thank you guys it's more
complicated and that's gonna be a
problem so you're gonna have to have
libraries and you're gonna have to have
people who trust those libraries and
that's gonna be an issue the good news
is that really it's one file I mean all
of the crypto code is in one file once
you have the term transaction semantics
and you trust that one file of crypto
that's it you're kind of done so it's
more complicated though the Bitcoin
people are scared of it we talked to
them and they said we understand hashes
we understand ECDSA but I don't think we
can explain this to the people who
actually use Bitcoin today it's it's too
much
so as I remember from the slice the
reason for this centralization is that
at the beginning they would be like no
one to set up the central body to do it
yeah yeah yeah but now like me quite get
some kind of traction so I think like
there will be people willing to set up
some central authority reports there are
like similar for the real money whereas
central lines so the problem is there's
been one attempt to do a Tom Ian style
ecash and it crashed somebody started up
a company and then failed or started up
a project and it failed and I think that
until a company like that is running for
a good deal of time people may not trust
it very much they might put their money
into it for a little while but they
won't leave it in for very long and
unfortunately the anonymity properties
here rely on you kind of letting your
money circulate in this pool till lots
and lots of people are also there and so
the degree of anonymity you get is based
on you know how much do you trust this
company and are willing to trust them
with your money so I agree that it could
happen you could have a central company
but I don't see it happening in a big
way and getting widely used anytime in
the near near future
yeah although I don't think the
government's gonna want to help out with
the untraceable currency stuff but I
agree that you're gonna have problems
with you there are definitely lots of
organisations that could do it
Microsoft could do it they could build a
product to do it but I don't think
they're gonna ya know I mean it's it's
it's just an issue I think that it's
here's the other thing the last thing is
that it's a legal problem let's say you
build a centralised Tommy and e-cash
company are you crazy I mean you're
gonna get how much trouble you're gonna
get in if it's used for anything
terrorism-related if it's ever traced
bet that that's done your company is
going to be essentially either asked to
find some way to trace it or you're
gonna be shut down with this system with
a fully decentralized system you don't
have that problem
any other questions so they</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>