<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Bound Analysis of Imperative Programs with the Size-change Abstraction | Coder Coacher - Coaching Coders</title><meta content="Bound Analysis of Imperative Programs with the Size-change Abstraction - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Bound Analysis of Imperative Programs with the Size-change Abstraction</b></h2><h5 class="post__date">2016-07-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1SHzuOiP7xg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
there's a florian zoo liquor from from
technical university of vienna where
he's think just finished his PhD and
he's visiting today here so if you want
to speak to him afterwards then grab him
today ok hello everybody and thanks for
coming to my talk and yeah I'm happy to
be here today though because as was also
kind of a wrap-up for my PhD thesis and
my PhD thesis was financed by Microsoft
so i'm happy to report results and he
has endless as I've worked on this with
vomit Galvani from microsoft in redmond
and was a master student mouritsen and
my supervisor henwood fight so this talk
is about how we can analyze imperative
programs in order to get bounds for them
and a solution nice abstraction is
called as i sit abstraction so this was
the title of the talk is about and
you're soon going to learn more about it
so what is the problem we are want to
solve so programs consume a variety of
resources such as you time memory
network and was in power and it's
important to bound the consumption of
such resources clearly because there are
economic incentives you can give the
user better experience and like an
embedded systems they're hard
constraints on the availability of
resources so you want to make sure you
don't lose more of them and
interestingly sometimes even the
correctness of your program depends on
bounding quantitative properties such
that if you leak information at a
certain place of your program you want
to know how much information you leak
and if you have numerical computations
going on you want to make sure that your
recited stays on a certain
range so we have identified an
underlying problem which can help in
some of these resource questions and
this is what we coined reach ability
bound problem and this is given some
imported program as you can see on the
right you have some particular location
of interest else or for example get some
expensive resources allocated and you
want to know how often your program can
visit this location and what you want is
a symbolic bound and symbolic he means
symbolic in the input variables of your
program and this definition can help you
answering resource questions for example
you can ask about the time complexity of
your program if you sum over all over
all your loops and you take the bounds
for them and you can get the similarly
bound for the memory of you go over all
the location their memory gets allocated
and take the bound for this location
times the number of times the amount of
memory allocated so another assumption
that you know it is okay how many bytes
you allocate okay so clearly if you can
compute a bound for a loop this implies
termination of the loop and so on a
sense computing bounds is more difficult
than proving termination but it's a good
starting point to ask of the successful
techniques for termination analysis can
be extended to bound analysis and though
the recent years have seen two
successful techniques or the one the
earlier one is the zeiss change
abstraction and the later one is the
transition invariant and so I will
explain them more in a minute and answer
will be that we can use as I change
abstraction but using the transition and
variance is not so easy
so what is the size change abstraction
so let's look at a simple example
program so we have a loop and you have
two variables polarization initialize to
N and we go through the loop and non
deterministically decrement ayda x or
decrement why so in our setting it's
convenient to think about this program
as a control flow graph there you have
two possible transitions so for each of
the passes of the of the while loop and
the zeiss change abstraction is now we
take these transitions and and the
predicates and we just abstract them by
replacing them with inequality so if you
take as your predicate abstract domain
just a set of inequalities between all
variables and you just apply this
abstraction and this is what you what
you get and you have as you can see
primed and unprimed variables so we can
represent relations with it so if you
think of this abstraction in terms of
abstracted reputation what you get is a
finite power set abstract domain value
based elements are conjuncts of
inequalities so why is the power set so
because we are having this Junction
implicitly in the control flow graph by
having multiple transitions and it's
finite because there are only finitely
many inequalities between a finite set
of variables traditionally papers about
the size change abstraction have
represented them like like graphs there
you available the edges with
inequalities but it's just a different
notation so design change abstraction is
a success story because theoretically it
has nice properties so termination is
decidable in peace space and
there's also a systematic way of
deriving ranking functions for
terminating instances on the practical
site design change abstraction has been
implemented in widely use tools such
that a CL 2 and isabel's oboes tools
need their need to prove that inductive
definitions are well-formed and so that
they terminate and they do automatic
termination proofs all the time and an
ACL tool is particularly successful they
can prove ninety-eight percent of their
functions automatically so why why it
does it have such writers works on ice
and practice so because you have
built-in disjunction and because it's
fine and you can compute the transitive
house without referring to two
approximation techniques and the
decidability recite comes from that
transitivity isles preserved termination
and because you only have any qualities
you can do the abstraction most of the
time automatically so this sums up the
potential for automating this technique
on the other hand we have transition
invariants and they have been meant as
an adaption of science abstraction to
improve programs and so they have led to
a successful tool which could handle a
lot of device drivers automatically and
they are more general than the size
changes abstraction and you can see this
paper for formal comparison so I guess
you're quite familiar with transition
and variance so let's look how what you
can do for how you will handle this
program so you will do a termination
proof which looks like this so you will
prove that we will have to well founded
relations and you will show that yeah
you derived them because x and y are
local ranking functions for one of the
pass respectively and then you show that
the transitive file in
the concrete is included in the union of
these were followed relations yeah as
well as someone pointed ultimate engine
corrected so that's true it's a black on
the slides but this doesn't matter so
now let's look at slightly modified
version of this program so there you
have to the same program except that in
the one branch you reset X 2 to n and so
this changes the transition relation and
but you can do the same termination
proof so this means only the part of the
proof which is the actual termination
argument is really stays the same you
have to show it in a different way but
the underlying reasoning is the same and
so what you see here is that you have
two different programs which have two
problems which have different complexity
but they are proved by the same
termination argument so the that
argument you have is to emphasize to
capture at the difference in complexity
so we have to do something more if we
want to do one computation so when you
take the same programs and you size
change abstract them and then you will
have more information in the abstract so
you will have that in the one case X is
the same and in the other case accessory
set you will have it in the abstraction
so you can see that there's more
information than you have in the
transitional variant case so i will now
give you a short explanation how we
compute bounds and then later I tell you
more about how we how we do it but this
is just to get the idea so what we will
do for computing bounds as we will only
work on the abstracted transitions and
we have some heuristics for discovering
that x and y are important
here for the progress of the program and
then our bound computation will do the
following reasoning for the program on
the left side that will say okay x and y
are constant on the respect of other
transition of the program so it's okay
if we add the bound and so by taking the
initial conditions into account if you
get the bond of 2n and for the other
program we will use the fact that only
11 of the the norms so only access reset
on the other transition so it's okay if
we order them lexicographically and by
taking the by proving that they are both
bounded by n we can multiply them and
get the bound n square yes all this was
the introduction the why we want to use
the size change abstraction and it will
motivate it further by pointing out
challenging programs and explaining
challenges there and then I will come
back to these challenges later on when I
explain you the actual bound computation
so by this channels I really want to
show you that we chose the size change
abstraction because it's the right
abstract domain that can deal with this
kind of problems which which Orizon in
the problem so let's look at the
following program which i will use as a
running example so here you have a
program that contains an inner loop and
so what it does it increments the
variable I and in the outer loop and we
set the variable J and then in the inner
loop you you increment post variables
and the outer loop you sometimes
decrement I but only if you have
repeated the inner loop once so in order
to show that the bound for the out
was really n you are you have to show
that if I is incremented or decremented
you have been visited in a loop at least
once and thereby incremented I is all it
makes up for the later decrement so what
I want to shower here is that for this
you need this distinction if the inner
loop has been executed at least once and
this is really the junked of reasoning
so in order to be able to handle example
like this you need to you need to
provide a disjunctive invariant about
whether the inner loop has been executed
none times or at least one time and then
you have to combine it with what happens
afterwards so let's look at the inner
loop so if you want to because it's the
same counter so it's I and as we just
reasoned also there in a loop will have
complexity and but a naive approach
would just say it's quadratic and why is
that so if you do a cut point like
technique you just say ok let's isolate
it in a loop let's prove that it says
bound n and let's multiply it by the
outer loop then you get in a prophetic
bound but is this wrong so this is also
what makes bonk bonk computation more
complicated because you have to take you
have a left compositional problem than
then termination and still you want to
somehow take advantage of the structure
of your program and so I will talk later
how we still get can get some
compositionality in the problem so this
is an example which we found an actual
benchmarks and so every line is
important so it's already sliced and so
you don't have to understand this
program I just want to point out that
there are a lot of flags and so in order
to be able to compute a bound you need
to reason about this flags and so again
this requires I'm trying to
reasoning and but interestingly this
program has a complicated bound and it
has a max expression in sight and the
logarithm and an tradition and so these
judges should show you that the search
search space for possible bounce is huge
so it's really difficult to somehow
predictor form how this looks like and
here the one to give an answer directly
and what we do by using the size change
abstraction so we will design change
abstractions about using heuristics
locally to extract possible parts of the
Turk of the of the bound and then then
reasoning only in the abstraction you
compose these local entities to to a
bound and so this is how we are able to
get that spawns on the other hand you
see that this is another digital not
linear expressions and wise as a
challenge so most program analysis can
only handle linear constraints so
abstract domains are only linear most of
the times and so you in order to get the
bounds if you don't need to reason about
the whole bound I mean we have to get a
ranking function I bound out of the
ranking function and for this we have on
V we need to compute only upper bounds
on the constituents of the ranking
functions and thereby we are able to get
a bounce for search ranking functions ok
so I want to further tell you a bit
about my intuition for the size change
abstraction so you shouldn't view the
variables of the size change abstraction
as integer variables but they rather
some integer valued norm on the program
like the length of a list or the height
of a tree or some other any arithmetic
expression over the over the state and
then inequalities
that's two norms they reflect a
monotonic behavior of these entities so
a single size change transition denotes
how the progress of the program is
locally and then by out only analyzing
the abstract program you know getting a
nice separation between finding these
norms locally and then trying to combine
them to a global global bound so this is
so it's really about giving you
compositionality and just as a short
yeah i just want to point out on this
example that the difference between a
reach ability bound in the loop on sort
of just a side remark that if you look
at how often the statement l to where
the reefs or a better object is
allocated is how often this can be
reached it's different how often the
loop l1 will be executed so i just want
to say that the reachability bone
problems really different problems and
only computing new bonds okay so now i
want to tell you how we actually do the
analysis on unimportant programs and by
this i will first tell you how we derive
a transition system of the for the
program then how we extract heuristics
for the size change abstraction and the
end of it how we deal with control
structure like in this complicated
example we have seen at the beginning so
let's go back to this example vista in a
loop and so for this program we want to
compute reach ability bound for the for
the outer loop so often the head of the
outer loop can be reached and we will
work was the control flow of this
program denoted like this so where you
label every
by a transition relation so in order to
compute yeah we will compute the
transition system always with regard to
one location and the location for which
you want to compute the bound so for
this we will just take the strongly
connected component dislocation licen
and then we will compute this transition
system which is kind of a summary for
this for this control location so
because as I pointed out in the
beginning disjunction is very important
we want to get we want to derive a
transition system this maximum which
contains maximal disjunctive information
and zone order to do so the ideas to
enemy right all pass all possible passes
from l1 back to this location L 1 and
here we have infinitely many paths
because of an inner loop so this means a
problem for this idea and in order to
cope with that the idea is to first
recursively compute the transition
system for the for the inner loop and
use this for for summarizing the inner
loop and once we have then summarized
the inner loop we just plug in the
summary for the inner loop and then we
can use this idea of animal writing all
paths to get a transition system for the
outer loop so what do we do for
summarizing in a loop so we derive this
transition system recursively but then
in order to summarize it you need to
compute the transitive hub and so this
transistor file is representing
arbitrary many iterations within a loop
and the nice thing about this is that we
can use the same abstraction for
summarizing inner loops so we just take
the transition system size change
abstracting it and computing the
transitive
the abstract and so this can be done
because they are on this abstraction is
finite and so we can compute the
transfer file and then we just take it
and plug it in ok I want to say a few
words about transitive higher yeah and
yes that's a good question so as I
presented we assume that the program is
reducible but this is not a limitation
because by doing k splits on the
possible entries of strongly connected
components you can derive a transition
system in the same way you'll just say
ok a double jump yeah you say a double
jump in here we jump in here but let's
compute the transition system for both
and then just take the union of of this
computations yeah and because
irreducible program shouldn't there
shouldn't be a lot of non-determinism so
I would argue that this could be done in
practice but I give not implemented it
so our implementations only for reduce
over control flow graphs okay so yeah as
I said before the abstractions finite
and the power set domain so we can
compute transitive house and they have
this nice property that we don't lose
information with regard to termination
so when we compute the transitive Hal
you have the property that the transfer
file terminates if the original system
terminates and this means we don't lose
any yeah properties about this progress
and so this is just the motivation why
it probably it makes sense to do that
way mmm and yeah that's also the reason
why you can
you where you have a decidability reset
okay then let's go back to this example
so let us assume we obtain the summary
was with two transitions and then we can
now collect all passes for from l1 back
to l1 so we will get four four
possibilities so one for the two
transitions from l2 12 1 and x 2 for the
two transitions of the summary so this
will result in four paths which you have
to concatenate and we actually at that
point well check if the transitions are
actually feasible and just can rule out
this will rule our two transitions on
that case
so I want to discuss a bit what happened
here so for this kind of analysis we
have coined the term pass wise analysis
because what we're really doing is
abstraction or detecting invisibility of
complete pass and so by complete pass I
mean if there are inner loops we take
the summaries of inner loops and plug
them in but then there will be no
abstraction so we just collect all the
predicates on this pass and then check
if there you have checked in for
abstraction or for detecting in
feasibility and this really is a way for
leveraging the progress in SMT solvers
to static analysis because we were
reason about our long path straight line
parts of the program and in this way we
will also get an analysis which is more
precise and then block-wise analysis and
I will explain this later on and but so
this is the answer how we use the
structure of programs so our our way of
doing is summarizing inner loops nested
loops using the summaries planning them
in and going on so this possibly or what
you can do for our bound analysis
yes
and yeah so I had this idea actually so
you can think about this like unrolling
the program and so this make sense for
some examples and but so then not so I
sort of it theoretically but so for
implementing it doesn't make sense but
so like for many automatic static
analysis they have this heuristic of
unrolling it at some point of time and
it would make sense for us as well yeah
so again wanted to mention how how does
transition system generation is
disjunctive so on the one hand we have
the transition system are actually yeah
you can view them as dnf formally so we
obtained in by an writing cycle free
pass and so individual transistors
relations they are did do not contain
this Junction so this works nicely was
our bound computation later on and so
this proceeding like this is is possibly
expensive but in practice those works
most of the cases because we slice the
program before and so we have a few
cases was time out but mostly this works
a second disjunctive thing in this
analysis is that we have summarized in a
loop distinctively so we have instead of
arbitrary enumerations to the inner loop
we use some finite over approximation
but we'll just tell us disjunctive so
this is V answered challenge identified
in the beginning okay so i wanted to
contrast what we do with what size
change abstraction does classically so
they would take the control flow graph
and that you get from the program and
abstract every every every edge directly
and then do the analysis only on desk
and so for this example they will not be
able to prove even termination and this
is because at one point V as after Lou
loop we decreased I if we executed the
inner loop at least once and because
then you have an increased decrease you
will lose all information of your only
finis qualities and but but we were able
to do so by using the summary first and
entering a complete path analysis and he
had to wrap up this discussion the
classical science abstraction abstracts
block-wise it abstracts the program only
once in the beginning and then does the
transfer higher computation on in the
abstract what we do is we always add the
night between abstracting and trans the
file computation and so this how off me
Judas is the how of loops and asset and
by this video I've and analysis which is
more general and more precise than what
has been done before
yeah I don't know actually I wouldn't
sing yeah so my intuition is that it
would be the same because you just
delayed the extraction from the
beginning but I haven't thought about it
so it could be
okay and so what we do for extracting
enormous is a template based approach so
we will just compute the transition
system as i showed you before and then
we will look at at the formulas we
obtained from this transition system and
you just say for every inequality which
shows up in this in this transition
system we were regarded as a candidate
for foreign norm so this means like they
have an inequality one greater than e 2
e 1 minus e2 is a candidate for for a
norm and in order to really make it a
normal sized change variable we we want
to know if it's useful on at least one
transition and so we will check by an
smt solver if it actually decreases when
when taking this transition and yazoo
losses like you have a simple follow
then you increase somewhere I you will
check if it's less than n and then the
conditions are met so we included and
yeah the nice thing about this pattern
based technique is that you can capture
a lot of iteration patterns which show
up in in in normal programs so you can
also come up with with rules for
iterations of a bit vectors and over
data structures as long as you are able
to express your deceivex you need by in
an smt solver and then you you can in
the same way come up with new patterns
which you want to add to the abstraction
so this is more okay so i want to
discuss what we do here so this is like
you can think of it as a heuristic for
extracting predicates and predicates
abstraction so there you also go and
look at
and equalities or in conditions of your
program and take them as predicates and
all those template based approaches have
been quite successful recently and so
it's also good that these are the bounds
which you report to the user are
compared about identities and entities
which actually show up in the in the
program so it will be easy to understand
for the programmer and so we do not take
any complicated arithmetic expression
but you could include certain special
cases so you could say for example okay
you have identified that as a norm and
the norm and so okay because of this it
makes sense to also take the sum of the
two as as I exchange for the difference
or the logarithm or anything which might
be used for
again I want to tell you what we do with
those programs which have complicated
yeah bleeding control structure like
this and we will apply our transition
system algorithm and it were so they are
just if so in this case we'll just
recite the number of transitions so I
have deleted infeasible ones and okay so
there is the back in the slide so the
transition system the wattage was
opposed to show you is that and we only
have one location but many different
transition relations and in order to
make our life easier we will do a
program transformation before we do the
actual bound computation and the
transformation we do has the following
following idea behind us so we want to
we want to add to every location which
transition is going to be executed next
and if you know that we can delete some
infeasible transitions so going so
adding this location adding which to
transition is executed next it's
actually like a prophecy variable which
has been used by viral recently so you
add like a look ahead of one to each
state and so this is a simple
construction which can be done by an smt
solver and it will for this program then
look like like this and this is what we
didn't use afterwards so I want to tell
you how we do it because it's quite easy
so we'll just take the transition system
and make program there now every very
advanced control location for every
transition and then we say okay we have
transition to another transition if the
composition of the two
is actually feasible and so you just
take the transition relations
concatenate them and check this by an
smt solver and so what is the nice thing
about adding this control structure
again the nice thing about it is that
you can get rid of bouillon bouillon so
if you were lucky so in this case it
works and so if your bio istics we just
have these two sizes s and logarithm of
see as norms and then we abstracted
transitions you you've seen before then
the transitions we obtained they are
left a lot smaller because we got rid of
all the billions and they are sufficient
for the later bound computation
yeah so this is not unrolling so it's
actually something different so because
unrolling means considering two
iterations of the loop at one time but
here we are not doing that so we're just
saying okay just make a case distinction
on what transition is going to execute
next and then check photos if it's
actually feasible so these two program
transformations are orthogonal so you
can say you can share programs which you
can prove by by one of them but the
other not yet as orders should show you
that their flags are not present in the
abstraction and in this way you can
obtain separation between invariant
computation and actually bound
computation and yeah how can be done no
exploit structure yeah so because we
have encoded boolean somehow in this
structure here's or no we want to use
the structure of this graph for bound
computation and so we will compute the
deck of it strongly connected components
and then yes it is somehow corresponds
to the control structure of the loop and
then we go and compute bounds for each
strongly connected component in
isolation and then compose these bones
to an overall bound for the system yeah
that is what I just SAT and then you can
you can compose them as follows so you
will go through the different levels of
of the of the strongly connected
component graph and say okay for every
level we take the maximum and then we
Debbie some all levels of afters of the
max expressions and actually then you
have to go on and compute upper bounds
for each
of these expresses by some invariant
analysis and this gives you the bound we
have just we have seen in the beginning
ok so then what is finally missing as
how we compute bounce for for single
strongly connected components and the
the thing that we are actually doing as
something something quite simple so it's
it's it's a greedy algorithm and I want
to point out that we are not using the
full power of size change satisfaction
because there's already coping with a
lot of examples which occur in in
practice and I want to say this is
because it's an interesting abstraction
and you could possibly extended in cases
where you need more power ok so what
what are we doing so let's assume we
have a control flow graph like this and
desire for transitions so what we do is
then we in a first step we compute a set
of norms that are non increasing for all
transitions and which are a bounded and
decreasing at least one transition so
the second condition means so it's
useful as local as a ranking function
for at least one transition and the
first condition says ok it's never
increased on the other transition and so
then we can we can just take the sum of
all these norms and go on with a
recursive computation so we just say ok
now we've found that some of these
transitions so every time they get
executed they will decrease one of these
norms and so we can just delete these
transitions and shout it ok if you only
q execute the rest of the transitions
then also this cannot be done infinitely
often and for so you get a bound
recursive found out of this
and then you have to take this recursive
obtained bond and multiply it is that ok
so you can you can think of it as a
lexicographic ranking functions with
upper bound sort of allows you then to
multiply yeah so what we have done is so
we have implemented the analysis I if
I've told you about an hour tool called
lupus which is built over the LLVM
compiler framework so we read in C
source code and we have used yikes as
our logical reasoning engine and so our
tool is not as not completely sound
because we have some optimistic
assumption about aliasing so basically
we assume no aliasing so when they added
values a syntactically different and
energy differently by our analysis but
so just didn't so we didn't find any
problems festers and practice so for now
it's ok because yeah and so we have used
a see benched benchmark which is a
compiler optimization benchmark so it
contains all the core utils of your
necks like B sub half million codings
graphics aneurysms so we've analyzed
this code and we were able to get
bounced for sweet waters of the loops
appearing there so our analysis is quite
fast so we can handle most of the loops
in in four seconds and some more in
thousand seconds and so there are some
time outs but they're not so many that
we are actually tried to optimize our
analysis and so in cases where we fail
is that so we have not sufficient
support for for invariants numeric
invariance and so we cannot hand
memory updates or pointer arithmetic as
we don't have a reducible control flow
graphs and so some loops are not meant
to terminate and we cannot detect it and
so there are also just difficult guys
which would need complex invariants yeah
solid for the first one I would expect
that you can implement like numeric
analysis which is strong enough to to
show the properties you want okay so he
had this concludes my talk and I hope I
could convince you that the size change
abstraction as the as the right formal
ism for dealing with bound analysis of
input to programs and the contributions
are that we've given the first algorithm
for computing bounds versus I change
abstraction and if also shown how you
can actually apply science abstraction
to impressive programs because before it
was only used for functional and
declarative languages okay I'm happy to
take some questions
yeah so the intuition is that the most
of the times in programs you just have
like entities which are increased or
decreased all the time and the
complication stems from how these local
progresses are combined to to an overall
progress
we actually I actually have more
information yeah okay so what what Byron
was pointing out that so what is
actually done by terminate or this new
tool is not the construction of this
transition invariant only but also the
proof that this inclusion actually holds
and this is proven inductively and so
there are some resemblance in this tool
to what what what I was making explicit
before bye-bye doing this because if you
compute the transitive how the citation
abstract is kind of an inductive proof
too and so like the difference as I see
it is that so we are going to collect
the norms before we are doing the
abstraction and when we are doing the
abstraction so we have obtained some
norms for one program pass and some
norms for another program pass but when
we abstract so we also see how the norms
of this path changed on that path so
that we have this information then
available if we do the actual bound
computation and so the question would be
how you can then take this proof and
extend all this measures obtained
obtained here and they are also on the
other side of the proof and yeah and but
so the questions also really so that the
two extreme choices our tools so we are
really doing a greedy abstract
interpretation and more Byron stores
like doing like a really lazy
minimal information as possible proof
and how you could there's a lot of room
in between how things could be done
people synthesized preconditions for
termination I guess in your case where
you can't synthesize a bow you could
maybe discover the bound that you wish
yeah so this could be done possibly if
you're missing like a greater 20
somewhere and so I don't know actually
because you have to do this symbolic
backwards like weakest precondition
computation and I don't know how it was
gonna be like</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>