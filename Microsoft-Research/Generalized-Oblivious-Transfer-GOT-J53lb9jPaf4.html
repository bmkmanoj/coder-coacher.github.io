<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Generalized Oblivious Transfer (GOT) | Coder Coacher - Coaching Coders</title><meta content="Generalized Oblivious Transfer (GOT) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Generalized Oblivious Transfer (GOT)</b></h2><h5 class="post__date">2016-07-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/J53lb9jPaf4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
okay so it's a pleasure to have Samuel
when Alou she's speaking today Samuel is
a student at university of Mario and
he's done some work on multi-party
computation and I guess today he'll be
talking about a bluebies transfer so my
name is Samuel ran oluchi and today I
will pop be talking to you about a
primitive called generalized oblivious
transfer and then I'll show a couple of
applications of generalized oblivious
transfer so first of all I'm going to
talk about a couple of primitive first
of all there are going to be building
blocks for for understanding and you and
creating our protocols the first one is
oblivious transfer so we have a sender
who has two messages and the receiver
gets learned one of the two messages but
he should have no information about the
other message and the sender should not
know any should not know any information
about the choice of receiver of which
message a receiver received another
important building block is big
commitment it's a functionality where
the sender commits to a value where he
chooses a message and then the receiver
receives some confirmation that in fact
the sender is committed to a value and
then later the sender reveals the value
and the receiver is assured that it's
the value that the sender originally
chose and an easy way to think of this
is with an actual physical protocol
where you take a message and put it in a
lock box and then give the lock box to
the other person and I you can change
the message because he has the lock box
and if he wants to the only way he can
open the message or get the message is
if you give him the combination an
important primitive that we're going to
be using is going to be called
verifiable oblivious transfer and it's
kind of a combination of a oblivious
transfer
and commitment so it is very much like
an oblivious transfer but but also the
sender is committed to his input and lay
at a later time you're able to reveal
the values that you sent that the sender
can reveal later what values he sent and
then you'll be assured that those are
the values he sent so VOT is not a very
commonly used primitive so two ways you
can implement this are in their
information theoretic setting you can
erase your channels to more or less
implemented as it is and we're going to
be using we can use that to implement
generalize oblivious transfer later in
the computational setting what we can do
is if we look at how ot is implemented
usually it's it's very much that to
implement OT first the sender commits
the two messages and then the receiver
creates a ciphertext which allows him if
decrypted to learn one of the two
messages and and then the sender
decrypts that that ciphertext allowing
the receiver to learn one of those two
messages if we look at that OT paradigm
in the computational setting well it
would seem very evident to make it
verifiable oblivious transfer by simply
revealing the value of the original
ciphertext of course proving its
security is another thing so another
important thing that we're going to need
to know about is what an access
structure so an access structure is well
first we have the set in indices and an
access structure is where you take
certain set from the power set and you
call call those sets authorize sets and
it's important that if you take an
authorized set and you add elements to
it then then it's also an authorized set
and a very important notion the the
compliment of an access structure is
well for each element of the access
structure you you can kick take its
complement and the compliment of the
action structure is just the the set of
all those sets so maybe that takes a
further requires further explanation so
first we have a set I which is one two
three and then we have an access
structure which is the set containing
only the element 1 and the set
containing the element 2 3 as well as
all that is implied by these two sets
for the access structure and the
complement of the set one is the set 2 3
so that's in the compliment access
structure and the compliment of 2 3 is 1
so that is in the access structure is
everybody following up to now or ok so
also we we look at it secret sharing
more as an infirm here we define secret
sharing not as a protocol between
dealers and unplayed and a dealer but we
look at is an information-theoretic
primitive where we first we have an
access structure a domain and and
there's two algorithm the share and
reconstruct so the share algorithm takes
a secret and divides it into share such
that if you have the ship if you have an
unauthorized set of shares then you're
able to reconstruct the secret if you're
not you're unable to do so too and
you're not able to gain any information
of the secret and also will define as
that shares are consistent if if if you
take any set of shares that are going to
reconstruct to the same secret
so here we then we define what are
generalized oblivious transfer primitive
is so we have some sets of messages that
you're allowed to extract and others
that you're not allowed to for example
for one out of 20 tea you're allowed to
extract sets of one you can either
extract the first message and this or
the second message but you're not
allowed to extract the first and the
second message and this is as general as
you can go with generalized the brit
vyas transfer so this the input is just
who the sender has to choose messages
and the receiver chooses which message
he wants to learn and if he wants to
learn an authorized set he's able to
extract all the messages otherwise the
protocol will the functionality outputs
an abort so how are we going to
implement generalized oblivious transfer
well first we're going to the sender is
going to choose a secret and he's going
to share that secret using an
appropriate access structure and then
for each message and you'll execute an
OT sender and receiver will execute an
OT were either the sent the receiver
learns a share or he learns a message
and and if the if the receiver is honest
and he chooses a valid set of messages
well he's going to be able to recover
the secret and he can then send the
secret back to the sender and the sender
is going to be like yes you acted
honestly because you gave me the secret
and then he's going to kind of reveal
he's going to reveal the information
that's needed to to to learn the
messages so I'm mrs. Park but in the
you're not going to actually send the
messages you're going to send an
encrypted version of the message in the
OT and a share and that way you're going
to be able to extract the messages you
want plus the secret if you don't
extract the secret then you're not the
the descender is not going to
give you the one-time pads is everybody
clear on this at that point seventy yeah
along with the sheriff along with the
show just a good name for a potato and
so the receiver juices
so people to messages wrong with the
chili no no you put either a message you
either the the receiver either extracts
a message or a share so if he extracts a
share he's closer to extracting the
secret and if he extracts a message
while he gets the message if he tries to
get an unauthorized message well he he
if he gets assets of message that are
not authorized he's not able to
reconstruct the secret and the guy won't
give allow him to extract the messages
so formally this is the protocol it's
not it's still incorrect but we're it
gets closer so it's it's simple we
choose random pads we encrypt the sender
encrypts the messages using the one-time
pads he selects a random secret and then
shares it and the receiver just choose
which messages he wants to learn and
then the executor Nolte with the
encrypted messages the shares and VI is
which does he want to learn the message
or the share and tries to reconstruct
the secret he then sends the secret
along if the secret is not the right one
well yeeah boards and the important
thing to hear is that if he chooses an
unauthorized message well he's not going
to be able to reconstruct the secret and
then he just sends the one-time pads and
using the encrypted messages that he
received he can he can get those
messages I'll go to Upton our is like
ok
sure I move for it okay it's the
protocol has it though has a fatal flaw
well look at let's look at what the
security proof is so the security proof
for this is that the sender privacy is
protected because he has to extract the
secret and to extract the secret he has
to be yes to act honestly and the
receiver privacy well do tease don't
reveal anything about the receivers
input unfortunately this isn't not
complete because there's a small flaw
and the flaw well there's a big flaw
sorry very big flaw is that you can
corrupt the shares here and when you
exit when he chooses to reconstruct the
secret the receiver so the sender is
cheating and he wants to learn what the
set of messages that the receiver
learned and what he's going to do is
he's going to corrupt the shares and
he's going to reconstruct the secret but
what he's going to reconstruct is that
it now becomes a function of much
messages he choose and this allows the
sender to learn what messages of the
receiver learned and so so this allows
him to break the protocol so now how do
we fix it well the main problem here is
that the shares can be inconsistent so
what we want to ensure is that the
shares are consistent so the the basic
idea is to replace the OT with a
verifiable OT and instead of sending the
secrets directly he he commits to it and
then he the sender can reveal his shares
the shares that he used because of the
properties of the verifiable oblivious
transfer and then he can check that the
shares are consistent if they're
inconsistent the aboard and since he's
committed to it only committed to it
these the sender can't learning
information about it but then to make
sure that the sender actually chose
valid shares we open the commitment and
the sender can now make sure that the
receiver acted honestly
all
no no okay so the risk so for the
verifiable OT its it seemed it's like an
ordinary OT except that the sender is
committed to his in addition he's
committed to the inputs so so then you
can reveal your inputs that you gave the
oblivious transfer yeah you can open the
commitment but it's the sender who
chooses to when if he wants to yeah
you're going to reveal all the shares
and the reason why is you want to make
sure that he's actually that you're
always going to reconstruct the same
secret and so so this allows you to do G
ot so the only thing now is you have to
come up with access structure so before
we had a we we had a protocol that
wasn't secure but they had argued
security so we want to book go a little
bit stronger so we use the universal
composability framework to show its
security and what that essentially
entails I think I should go less into
detail may be about it but what it
entails is that you have a real world in
a deal world where the simulator is kind
of controlling it and you only uses the
actual functionality and you want to
pretend that he wants to pretend that
he's that it's the real world and you
want you make it so that it's
undistinguishable this yeah it's a bit
complicated but essentially what we're
doing is just a simulation of a the
protocol and using only the ideal
functionality this so here when we're
saying we're doing the sender simulation
where we're doing that there's the
environment there's the simulator and
then there's the actual protocol and we
want to pretend that we want to make it
so that they're under
tinguished ball so are you guys familiar
with simulation-based security okay so
so this is basically a in short it's
basically a simulation to me so that you
you you you you the real protocol and
the ideal practical is look exactly the
same and not the sender is corrupt yeah
the sender is corrupt so so the
environment is is trying to cheat and so
the simulator just looks and if he sees
anything inconsistent hehe just aborts
that's basically what he has to do and
then he can extract the messages and
just interact with the ideal
functionality and that's going to be the
solution here it's it's the receiver
that's corrupted and we're trying to
simulate that and it's a the so it's
just simulating what the protocol would
look like and the only flaw in this is
that if he guesses s if he tries to
cheat and guess his s correctly well
then then that's the only case where the
simulation really fails but that happens
only with exponentially small
probability okay so so we showed how G
ot we can do G ot so what are the
applications of generalized oblivious
transfer so first of all k out of n ot
then this becomes easy very easy to do
because the compliment of the access
structure associated to n minus K out of
n secret sharing is exactly the set of
messages authorized by a k out of n ot
so you execute n 0 verifiable OTS and
you can do any k out of n ot
sorry so another application of
generalized oblivious transfer is
something called batch single choice cut
and choose okie and this is a very
strong type of so you have an N by s
matrix of pairs of values so just to
make it i'll write an example here you
have a b c d e f and g h and there's a
so there's a and receiver he can learn
for each row either the first one or the
second one of each in the row and then
he can also learn both values in half
the columns so for example if I have
this if I choose to learn that if the
receiver choses learned to this column
and for this row he choses 0 and for
this row he chooses one well the values
he's going to get is a CD and for this
one he's going to get F and G H
and
the first element of the pair and then
he's going to get both of these values
and he's also going to get both of these
values because he chose to learn this
column both values and for this one he's
going to get F because it's the first
one the second one and then he's going
to choose he's going to learn both
because he chose this column plan
usually there are applications to this
that are there's some application to
this particular very yes yes so I'm
gonna so so well in short there's a way
to define a secret sharing that uses the
right access structure for this one that
actually only uses twice the size of the
of the so you you have two secret
sharing schemes that I'm going to use
and like combine them together to give
you an access structure and then there's
an application so we're going to have it
okay I'm okay yeah so so there's going
to be two basic secret sharings that
you're going to combine together the
first one is going to ensure that you
you learn only the first or the second
value for each row and this is basically
you you you have a el out of El secret
sharing and then you divide it again
each share into shares so that you can
make sure that you learn only one value
per each row and then you're going to
use a you're going to ensure that you're
going only going to learn the both input
for half the columns and that's their
secret sharing and you're going to
combine them their shares together by
concatenating them and this is going to
allow you to do a batch single choice
cutting shoes OT okay what are the
applications of this particular cutting
version of OT
or generalized well they have to do with
yells garbled circuit so it's in the
cutting choose paradigm so usually in
the cutting shoes paradigm what you're
going to do is you're going to there's
going to be half the circuits that are
going to be checked for consistency so
you know that they're right and then
you're going to evaluate half of them
and the big problem is that you have to
do basic three things you have to check
the circuits you have to make sure that
the the first player uses consistent
input and the second one consists uses
consistent input but what bat single
choice cut and choose OT is allows you
to do two of the three things it allows
you to it forces p ones to send
consistent circuits because these are
basically you can think of these as the
first the second players inputs so you
can either learn the first they're the 0
value or the one value and this is kind
of forcing him to to use consistent
inputs and the other one the columns is
to check the consistency of circuits
where he gets both keys for the circuit
so this allows you to make sure that the
the circuits are consistent and that the
second player always use this is the
same input and what's missing is that is
that you you want to make sure that the
first players input are consistent but
you can use combination of bit
commitments and a bit commitment with X
or to do that okay is that clear up to
because yes exactly the batch single
choice kind of shoes OT protocol but
they're the depending on a very specific
computational assumption what we have a
very black box primitive for a donor was
anyone at crypto here okay so do you rim
do you remember the Maltese did they
actually use it okay know that ok so the
multi center k out of n ot is another
primitive so every sender inputs a
vector of n strings and then the
receiver inputs a set of indices of size
exactly K and so here you each each each
so the receiver basically chooses the
same the same so if we think of every
player's input as a row in a matrix well
the receiver is going to choose certain
columns and extract those columns
yeah it's one of the Crowder's so so
it's multicenter cat of n OT so it's a
parameter yeah does every so
or the second message for everybody yeah
can I have a was the eraser so here for
example if the input from the sender is
0 1 and the second one is 10 well he can
either choose this one and he'll learn
01 or he can choose or he can choose
this one and you'll learn 10 okay but
there's many senders so so that it's
it's a bit different than
generalizability transfer well so how do
we implement this functionality well
first of all we first think of it as a G
ot so it's a very simple G ot where you
you basically have a G ot where you have
a matrix and you just say that you're
going to extract the columns and you you
kind of look at the shares like they are
but that's a single sender and a single
receiver so now you want to extend that
to many senders and just one receiver so
is this where how the secret sharing
that it's just linear you you divide the
shares each share has a row and then you
take your share and then divided in in
take each share and reshare it used for
each column ok
yeah so so this you can see that you the
G ot version is correct so now we have
to take this protocol which only has one
player and you you you you make it so
that there's many centers instead of
just one but so the way we do it is each
center generates to share as in the G ot
version of it and then what we're we're
instead of using any secret sharing
we're going to use linear secret sharing
and then what we're going to do is we're
going to take each player is going to
have a row associated to them so
everybody is going to give them their
row and then they're going to add up
those rows and if they reconstruct all
the rows the sender should be the
receiver should be able to extract the
sum of the secrets so if each player
selects a secret then by combining these
shares the resulting secret will be the
sum of the secret so this is hot this is
like the share combination and so to get
the actual multi-center k out of n OT
protocol what we do is we we combine the
shares together and then each person
uses those shares to you do like a k out
of n ot for g OT using those shares and
then they're also going to commit to
their secrets and at the end with the
sender should reveal what the receiver
should reveal is the sum of the secrets
and then they're they're going to
decommit to their secrets and we're
going to verify that that's correct also
there's the things that you still have
to check the consistency of shares and
and all that but it all comes together
so it's the same access structure as the
G ot version but instead you've got many
secrets that have been combined into one
and the sender's have to commit to their
secret and then reveal it so that
certain senders can't just change their
secret so that it appears that like he
recovered the right secret when he
didn't but the nice thing is that then
each each Center only has to use n V OTS
with the receiver and the receiver only
he has to do N squared verifiable piece
but he only had each Center only has to
do n verify abilities but share the
sharing costs is quadratic though in the
number of players so the applications of
the multicenter KR n OT are relating to
the IPS compiler and the IPS compiler is
that you have an inner protocol and an
outer protocol where you have like in
the inner protocol you have real players
and in the other protocol you have
honest a protocol for honest the
majority a protocol that succeeds if you
have honest majority and if you try to
cheat what you have to do is corrupt at
least a majority of the outer protocol
but in IPS compiler you have a watch
list where you're kind of spying on
certain players and if you want to
corrupt them it and if you detect any
cheating you aboard so in this compiler
the there's a watch list where you're
spying on people and then if you want to
cheat you have to corrupt at least the
majority but if you're corrupting at
least the majority well if somebody
spent spying on many on spying on some
of the virtual parties then you'll be
able to detect that they're cheating so
so the multicenter k out of n
OT protocol was an important primitive
to actually optimize it it's a it's in
the article so it's a cheap way to spy
on on the virtual parties so something
that's probably easier than what I've
shown you is priced oblivious transfer
so priced oblivious transfer is imagine
you wanna you want to buy a movie but
you don't want to tell them which movie
you want to buy and or you want to buy
many movies and then each movie has a
certain costs and you pay a certain
amount like thirty dollars and you say
okay I'm going to buy movies for thirty
dollars worth and then you say okay
we're going to interact so that you buy
those movies but I don't know which
movies you bought and I'm assured that
you're not going to buy more than thirty
dollars worth of movies so so so so the
solution is that we're going to use
weighted secret sharing where each share
has a weight w wi so and asset is
authorized if and only if the weight of
those is greater than equal then then a
certain number so the trick here is just
say okay if you but so the share is
going to be the so so to extract the
secret you're going to just say that
each share each movie is going to have a
share associated to it that has the
right price that has its price as its
weight and if you want to get more than
the price while you're not going to be
able to extract the secret
you should avoid a secret sharing more
efficient than just giving wi shares i I
I don't know honestly yeah which is
actually one of my questions so so here
we shown a couple of applications of of
generalized oblivious transfer and that
can be instantiated for verifiability so
we have K out of n ot which naturally is
just a simple generalization we have
batch single choice cut and choose OT
which is very useful for secure function
evaluation and we have the multi sender
caryville and OT protocol which was
useful for the IPS compiler its
optimization and we also have price
oblivious transfer and I think there are
many more but haven't been clever enough
to see more firm phone for now i'm still
looking and future questions are well
what are more g OT applications is there
more efficient things we can we do more
protocols more efficiently with it which
is the optimization also a missing part
is we'd like to show that a lot of
different primitives could a lot of
computational primitives can be used to
implement verifiable OT and we'd like it
to be securing the universal
composability framework and also the
last one is how efficiently can we
implement difference generalize
oblivious transfers which has something
to do with an access structure if
they're a excess structure thank you
that concludes my presentation since
you're talking about efficiency I have
to admit bristle that whenever I see
people talk about
and out of them secret sharing a lot of
LC Paciorek because you don't have to do
it see what sharing this is too powerful
tool for them you can share it by just
creating a bunch of values whose ex or
is the secret right you don't have to go
through all the secret sharing mechanism
well for the batch single choice
couldn't choose OT you had to have it
was a bit complicated because you had to
have learn have to call it half the
columns you learned both values and yet
you have to also learn only you only
should be able to learn for those
for those that are not in the columns
you should only learn one that are not
value so sometimes it's more complicated
yeah component is okay yeah certain
those case you don't need to bother with
color
yeah construction we do here is like
prostitution yes so you have reasons
that he or she wanted to constantia
I I think it would just depend on the I
think all you all you need to do is look
how cheaply how cheap is verifiable
oblivious transfer and I was saying that
the summer it's getting to be like I
don't know something I think there's a
lot of protocols for universal
composable OT string OT and they require
like a 20 exponentiation something like
that and i think if you take most oh d
protocols and try to transform into
verifiable OT i think there's a lot of
room that you can do that very simply
because a lot of them as they said
follow the paradigm where you commit to
your messages and then the the receiver
sends the ciphertext and then the sender
maybe I should go back to the example
because I actually use something more
general but Oh an easy way to do
homomorphic encryption is using is using
a an easy way to implement a lot of
people use a homomorphic encryption to
to implement OT and so why i think i'll
use the board so why a homomorphic
encryption is useful is because if you
encrypt x0 and if you encrypt x1 and you
send it to the receiver receiver well
the receiver what he can do is what he
can do is he can calculate a C and he
can then increase he can then encrypt
see and encrypt whichever message he
wants to learn with it and this will be
giving him the encryption of c plus
exbii right and and so there is still a
proof of knowledge to show that he
actually did that but then all he has to
do is then send will call this C Prime
he sent c prime and then he'll send the
decryption of C Prime and this will
allow him to uh to just he he just he
just subtract he he learns so we'll call
this Emperor Prime and he just does m
prime minus C and he gets a X B this is
pretty much blind yeah exactly so it's
blinding so if you want to transform
this to a vot well all you have to do is
take this and decrypt this and that
reveals x0 so it's a it's another thing
to show that security but it's a very
simple way of getting verifiable OT
conceptually and that's why I think
verifiable t is is is a very sound
primitive
some of you
extreme
um
well there's a if ok so I've you know by
linear okay solders there are certain
homomorphic encryption homomorphic
commitments and I think that if you
combine generalized oblivious transfer
and they somehow rely on homomorphic
encryption homomorphic actually perhaps
you can also use the homomorphic
properties for example because of the
the plaintext to do other things like
that so yeah there's possibly extensions
but i'm not sure how this beliefs the
bunch
oh okay i was thinking of another thing
is that so in that single choice ot for
example but they've actually got
optimizations where they use instead of
just doing one at a time the the the OTS
they kind of do them in parallel and
they used exponentially instead of one
exponentiation they can do many very
cheaply rather than just doing one of
them at the same time so on that sensors
there's optimizations that can be done
none over in general may look for
general release transfer if you have
verifiable teas and then you you can
somehow combine them and do them more
efficiently than just doing them
independently
thank you for having me at the microsoft
feature it's just been a pleasure</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>