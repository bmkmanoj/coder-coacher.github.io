<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>How to write your next POPL paper in Dafny | Coder Coacher - Coaching Coders</title><meta content="How to write your next POPL paper in Dafny - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>How to write your next POPL paper in Dafny</b></h2><h5 class="post__date">2016-07-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/7C-GitT4X6w" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
good afternoon everyone I'm Bruce Delano
and I am very pleased to introduce naira
I mean who has been spending well a week
with us here and we'll spend this week
as well but before then she has done a
lot of work with using using Daphne and
she's now learning how to hack in in the
Daphne sources as well to add the
improvements that that she would like
and now Nana has some like a developer
history as well from having worked at
Microsoft essen in turn some number of
years ago and worked at Google sm
developer as well right for in Zurich
and is now at epfl studying with for a
PhD with Martino turski so take it away
thank you mr. thank you for inviting me
to miss our has been a lot of fun to
finally dabble with Daphne internals but
this talk is going to be from a user's
perspective i've been using Daphne to do
meta theory of programming languages and
I've done both textbook examples and
research level paper examples and also
used it in my own research where I
wasn't really sure where I was going and
using Daphne to to guide me a little bit
in the both in the design and in the
proofs but for this for this talk I'll
start with a textbook example which is a
modeling the simply typed lambda
calculus and then mechanically proving
it's a syntactic type soundness and I
what I hope to convey here is that in
terms of modeling Daphne doesn't really
bring so much more than then but
it's really when you do the proofs that
you get a lot of mileage out of using
Daphne so first we will still look at
the model and I'm I'm starting to define
some I here i'm defining a data type for
four option which is really like just a
kind of like you may be the main maybe
monad in haskell or something like this
and i'm using it because i often want to
use have functions that sometimes return
result and sometimes not like the step
function of operational semantics
or the typing function not a return has
a type so i'll be using the option one
ad for this and then for my for my base
base types of the simply typed Cal Cal k
lambda calculus I'll I'll have this OPEC
base type to start with so this is this
is just a some type that you can't
really match anything else against
except itself and then recursively you
define this arrow type which which takes
a parameter type and a return type t2
and then for the terms we have variables
application and abstraction and the
actually here I should just say that the
abstraction also takes the the type team
okay so in terms of yeah is there any
question okay variable you're gonna
represent it by just yeah so concretely
so yeah I'm using integers as concrete
names I'm not using any fancy encoding
for for the purpose of this calculus
this is going to be enough because we're
only deal with close terms so we don't
have any issues with variable capture
but of course if we want to extend this
to other settings like like for example
in system effort you also have type
applications and here you can have
captured its 22 we all need to be a bit
more sophisticated bateria i'm using
this simple including and this is also
the same as the encoding used in the in
the development from from
foundations of software okay so in terms
of operational semantics we just define
what is a value in our language and 44
here it will say that any lambda and
lambda abstraction is a value and then
here there is some boilerplate in terms
of defining free variables and
substitution so the the interesting case
is really that so f of f of e says that
it computes this
to free variables of T of eternity and
the interesting cases if we have a
variable then we just returned its ID in
the set if we have an abstraction then
we compute the free variables of the
body but we remove the bound variable X
because it's it's not free it's bound
and then the other case are just
recursing over N and and union the the
free variables we find yes so using
point you have to define all this set
what they are but they're not so what do
you get here yeah so so Daphne has a
primitive for set and it knows already
about because it has already some axioms
about set so it knows things such that
if you remove X from the set here then
this whole this set here will not have X
anymore antigenex does this answer a
question any more questions yeah and
then and then substitution is also a bit
boiler pretty but it is the same pattern
so if we have a variable X Prime I'm
just so ok just to recap substitution
says that we we have a term tea and we
replace all free occurrences of X with s
another term s and the interesting case
is if we have a free variable X prime
then we just we go ahead and do the
substitution if it matches if the
variable matches otherwise we leave the
term unchanged and here this is where
Nicholas comment comes in we're only
dealing with when we're only dealing
with cases where s is closed so this is
ok in general if s can have free
variables let's say s had this variable
X prime then we're doing the
substitution we have s here and this X
prime would capture the free variable X
prime that is an s so we're assuming
that s is closed and this will show up
in the proofs as well but for now we're
not worrying about it so much ok and
then application is just just a
recursive case
so with this we can define our yes it
needs more fancy encodings I didn't just
remove
you have to do so Thanks yeah so what i
could do is this this is a bound
variable yeah this is a bound variable
so I could I could rename it to
something else but then if you start to
do renaming I you could do that but then
you also need a way to compare terms
that have different names but are still
equivalent so you need it well it's just
a fi equivalent so it's it's doable I
mean but I think using a different
encoding might be more useful so in cog
they have this library for locally
nameless encoding where you use the
bridging indices for when you when you
are in a local setting with bound
variables but in a in a global setting
you still use these these names so we
could do we could do things like this
I've I've played with with this but yeah
for this example I'm glossing over that
you can still use grenades and just
alpha can go to team for substituting
and that you don't necessarily need to
yep reason about alpha equivalents just
to loosen tactic I see if you like oh
yeah maybe not in this case yeah but I i
was thinking ahead of cases where you
would need to yeah no it's fine I mean
yeah I don't mind interruptions but I I
show later how you can do this as well
like this this afternoon yeah okay so
for the reduction relation so here we
see that if we compare with ml rather
language we have less facilities for
pattern matching because we can't really
have nested nested nested pattern
matching like here I have to explicitly
have these if statements but this is
basically saying if i have an
application and the function part is an
abstraction and the argument part is a
value did i can go ahead and do the
better reduction so the substitution
otherwise these are just congruent cases
I again I can I can step on the on the
function side or I can step on the
arguments type and I chose to make my
function deterministic I mean anyway
it's going to be deterministic because
i'm using these if statement but i'm
just being explicit about the fact that
i'm only
epping on the argument when when f is
already a value okay and then you can
define a multi-step relation and this is
really if you if you look at the step
function and think of it as a it's a
partial function so think of it as a
relation and then this is really just a
reflexive transitive closure of that
relation and here we're taking n for the
number of steps we're doing okay so we
can do some examples and this one
definitely figures out automatically and
now onto typing yep yeah so this is just
saying if i write it in i have lambda x
which takes a base type and returns x
and then i'm applying this to lambda x
then that just returns lambda X DX I
hope the first name is be early oh yeah
you're right
okay no not yet this one was actually
proved automatically I showed yeah yeah
it's just one step that's why I'm saying
and it just has to be greater than zero
is more of a deal is just another only
hope on complication yep mmhmm yeah this
was just it's kind of like writing a
test with ya alright so typing so first
I'm using maps this is also a definite
data type and internal data type 2 to
represent a partial map from variable
names two types and you can look things
up in the map so I'm I'm just and you
can extend the map as well so I'm going
to use these these are abstractions over
dough and the the typing relation is a
is a syntax directed so we have one case
for VAR apps and app and here we see
that ok it's not that pretty because of
this monad but that's why I've put these
these checks a bit here so that they
don't they don't affect the main flow
which is which is here so for for a
variable we we just look it up in the
context for an abstraction we we type
the body in an extended context and then
return an arrow type where the the the
type of the body is is in the result of
the arrow and then for application we
just type the function and the argument
and we we check that the function is
actually an arrow and that it agrees
with the argument and then we return the
result of the function ok so now we're
done with our model you choose to write
the typing relation is a function which
in the simply typed lambda calculus
is Lambie natural yeah but one would
normally write it as a relation yeah I
can also do this yeah in my own in my
own research work I've mostly used
relations and it's makes more sense
because even there sometimes I wasn't
sure if if something is decidable so
then you really don't have a choice
which is evolution and and you can also
work with with with undecidable things
if you if you also have a step index and
things like this and what's nice and
Daphne is that mutual induction works
really nicely so even if you have a step
index you can it makes it really easy to
do much mutual induction on things yes
the semantics of words sorry so far is
just a variable you use a lot oh the
virus are you duh yeah yeah yeahs the
right increase is T oh let's see oh wow
yeah so I guess it's getting know so
it's getting confused because here we're
extending the context so the context is
not decreasing yeah yeah but it just has
some default so here we just need to be
yeah yeah if I switch the paranoids
would have worked because it works yeah
lucky fault it's the lexicographic to do
all the work of the arguments anymore we
do sorry i was still pulling up a chair
so here are some examples again this is
just testing not proofs yet and here we
actually have to do more work in some
cases and the reason is that Daphne just
does a bit of unfolding and not much i'm
finally understanding this but with
justin we have some ideas on on how to
change this so that you wouldn't need to
to assert the intermediate steps but
anyway that was just to give some
examples we don't need to go to them in
details I want to get to the type safety
properties so for for type safety we're
going to yes it sure isn't variables
like names you mean yeah well because
def he doesn't have strings yeah
you're awesome yeah
okay so for the four for the type safety
theorems we're going to do syntactic
sounds so progress and preservation and
the way to read this discourse method is
really just something that's there for
verification so it doesn't get compiled
into code and the way to read it is that
the requires clauses are like hypothesis
of your lemma or theorem and the
insurance clothes are like the
conclusions so here we're saying that if
a term T has a type in the empty context
then either it's a value or it steps it
can take some step and first let's just
look at how this is done in on paper and
in to prove this so is this
readable or yeah so in on paper you
would really do an induction on the on
the typing derivation and then there are
a few cases and it's it's pretty
straightforward but I mean you you still
have to reason through them and then
incog this is how it would look so it's
a very long proof and already it's using
some automation with this dot dot and
yet so that's the end of the yes yeah so
yeah so you need to understand this
tactic language so for example this is
saying yeah yeah this is doing doing an
induction on on the derivation and then
well here we're going to use it's hard
to read without having the context the
interactive context of the proof but
anyway I just wanted to give you a
flavor wet it looks mm-hmm
a lot of other things engine yep guided
in the right way yeah it's what I hold
medjays words like this yeah yeah okay
and this is how it looks in Daphne
nothing okay so not of proofs are going
to be that easy but this one it figured
out automatically because it's it's a
yeah it's just an induction on the
typing derivation and so it could it
could fill this out I think here it's
doing it on the term but what happens is
that it has this dis hypothesis which is
the type right so at the end it can
really when it's when it's in the in the
states when it's the abstraction case it
can use the induction hypothesis from
that that comes from this typing the
full abstract the full abstraction so at
the end it's equivalent to doing a
typing derivation on the on the term
because you kind of your kind of doing a
case analysis I'd show an another
example of this theater yeah everything
and not these are the money yes that's
fair but it's kind of the default way to
do things if you if you want to go fancy
and it takes some it's actually
takes some thinking to to to really
automate and and do prove that are
modular but indefinite it kind of comes
for free okay so now we're going to do
preservation using the substitution Emma
first and here are just some some lemons
that I'm i also took from the the
textbook and definitely prove them
automatically so here I had to give a
hint to Daphne that says do an induction
where you generalize over both C&amp;amp;T and
the reason what's the reason you need to
generalize over the context as well as
because you have the abstraction case so
anyway this says that if X is a free
variable of T and T has some type in
some context then this context
definitely has X
definitely bind sex and and then mm-hmm
wondering about the process by which
you've arrived at ease so yes yes you
wrote the progress thing will you just
like really surprised that I just rented
yeah I was nice so when you got to Lamar
free in context how did you discover the
that you know maybe you tried the first
time you see it would go through
automatically and it probably didn't
yeah so I I did okay so let's let's
remove this
so here it's going to complain that
something and this one is actually a bit
of a tricky one there's a there's a bit
of a a bug so I'm just going to repeat I
mean I'm just going to go through it but
just just gloss over this bug so here it
says it doesn't know how to proved it oh
yeah not yet yeah wait that worked huh
that's weird okay so this is this one is
a bit buggy but yeah this this doesn't
make much sense that if you repeat but
in general i'll show how you yeah so it
just doesn't it just doesn't know yet
ensures maybe yeah that me gets help
just a little bit more and how to find
it also yeah I think so yeah there's
there's something strange going on with
this example button but usually it's
it's a it's a bit more straightforward
so I'll show some examples later of how
you do some derivations okay so then
we're only interested in close term so
this is how we define clusters just
saying that X does for all for any
variable X it's not in the end a fever
balls of tea yeah I could have having
something yeah yeah but anyway I wanted
to do a proof by contradiction so here
you go so well I guess I could have done
it in the other way but I so here I'm
saying a corollary of the previous thing
is that if you have your type about in
empty context then you're closed and i'm
doing this by i have to reproduce this
this pattern here so i have this for all
parallel statement kind of that says
well for all X we're going to ensure
that X is not in the free variable of
tea and I'm doing this by first assuming
that it is and then showing that you get
a contradiction because if it's in the
free variable of tea then by the
previous
lemma we know that it must be in this
context but this context is empty so
yeah I think maybe if if I if I try to
change it as you said this this proof
would also like simper okay so one more
it's just the context invariance I'm not
again it's one that's proved
automatically it's it's just saying that
if if if C and C prime agree on all
three variables of tea then they should
I agree on the type as well okay so now
this is we're coming to the hardest part
with it which is the substitution lemma
and this is also notoriously tricky and
many many calculus once you want to do
extensions so this says that basically
substitution preserves typing and this
statement is actually a bit hard to read
the reason is that I'm I don't want to
be adding extra variables here so i
can't really the only way I have of
referring to this this type which I know
I know it has some type and the only way
I have to referring to it is is by this
expression like this God get but this
basically says that if s has some type s
capital s in an empty context and T has
typed tea in a contest extended with X
having type s then if you do the
substitution you have the same type as
well and really the only interesting
case when we did the model was for
variable and application so this is the
only cases where we have to guide Daphne
a little bit and we're doing we're using
the previous lemmas in key places okay
good guy yeah right so did exactly sir
yeah so so so the way it works is that
let's say I comment this out
well okay yeah so then it's complaining
and this quickly is here which means
that it's really like a different case
that is campaigning about so then i can
i can try to figure this out by doing
xat app for example is this the
problematic case and then i do if t bar
is this the problematic case and then
and just add this phone yeah so then
it's complaining well okay now it was
complaining about this case so I know
that this is the case i need to worry
about yeah so then I I need to it tells
me I need to show that this post
condition holds for this case so yeah so
it's saying this post condition here
with this quickly doesn't it doesn't
know that it's hold for this case so I
need to help it and the way I have it is
by saying okay well if you look at the
t-bar case if you look actually at the
way it was done in them in the hashtag
function just gonna make this
if you look here then you see that well
actually in the substitution what you
see is that it has it has these two
cases so if X is equal to X prime then
SST so this means that here I also
really have two cases to consider if the
ID is equal to X as this and now we see
that Daphne has really confused only
about this case yeah and so now i can i
can keep drilling and understand why is
this case tricky well the reason it's
tricky is that we're we're actually
using them so this is the case where
we're doing the substitution and the
reason it's tricky is that we're
actually using the fact that s is closed
to do the context invariance mm-hmm if
you don't know the priori like these
doesn't give you like you can say you
can dig but so that you can really have
like the game well and in some ways it's
it's it's like what what so cop gives
you this interactive context and say ok
this is the case that you need to worry
about so here is the same except you
have the flexibility of choosing in
which order you did the case because you
know what you're in doing a derivation
on or you know I know that when I look
at this proof and we say there is
nothing that doesn't it this way yes its
interactive I mean you you try it out
yeah okay but I need to understand why
you assert equal sequence s why it's
there well okay maybe it doesn't it's
just all so for my understanding like I
know that I'm in the case that is that
is a variable and where the where the
substitution is happening so i know that
i'm substituting X is just here T is
just X and I'm doing the substitution so
this whole thing just becomes s so then
the type of this thing which was which
which was t we define the two BTW we
know that this has to be the same as as
can give you an intermediate status of
wise confused or something like that oh
yeah there is a way but I haven't used
the debugging support much okay so so
now for preservation it's really just
using the substitution lemma in the case
where it applies on the rest it does
automatically and that's it we're we're
pretty much done now I'm just defining
what is a normal form and stuck is is a
normal form that isn't a value and then
I can show type sounds by using this
progress and preservation so that's the
data that's that's the generic part so
now what I want to show is how modular
the proofs are what i did is i added
some extensions so i added boolean types
not number natural types and i also
added iso recursive types which are this
fold unfold operation I'd show an
example of this data and this is all
like I mean I don't know that he doesn't
have pragmas but I basically a and
comment this in and out and what's
interesting is that ok the model has to
change right the modulus is changing I
mean my values now include natural
numbers and these folds and and then so
so the model changes quite a bit and
that's expected I mean you're after all
you're doing a and you calculus but then
what's really interesting is that for
this case yeah so sorry I'm just going
to scroll down
okay I'm just to show like I'm actually
using this so I have examples of boolean
naturals and this fold thing but what's
interesting is that the type safety
properties stay the same so the proof
that we had before are exactly the same
nothing has changed and the reason is
that if you look at the proofs the only
interesting parts are for abstraction
and variables and the the application
part really wasn't mentioned anywhere
and so this new stuff is still by
induction on the congruence and
everything just works and I added this
isoh recursive type because I actually
wanted to find a case where it doesn't
work and so that I could show how I
would extend the proof but it still
worked so so I got ya so I think that's
pretty cool i mean yeah i mean if you if
you look at how to achieve this in
you really need to have the insight
beforehand to to structure your proofs
in the right way and just to show that
things are actually working nicely so if
i add a mistake for example if an has
type i change I changed I change the if
statement so that GF expression so that
it doesn't check that both benches are
the same
then hopefully I should get some error
somewhere well so this tells you when
it's done I mean I haven't enabled the
caching because it wasn't there were
some issues with it but this should tell
you when 2000 you blow the audience yeah
yeah yes anyway so it says that it can't
prove preservation anymore and you can
kind of dig in on what the problem is so
i can say f is the problem in TF well
here i know it's there but I mean I'm
just kind of have a suspicion where I
could even ask it is the problem with T
fold for example or is it the problem
somewhere else and it turns me yeah the
problem is here and then since here I'm
doing I'm kind of doing a case analysis
on the stepping functions yeah so here
it's recomputing because when there's
the the purple eyelids it's recomputing
so I know the department's here and I
can look at the stepping function
and I have the the three cases here so
yeah so it says it cannot show this and
if i add these three cases to tell me
which one is it complaining about
yeah yeah otherwise it's hard yet I mean
you can you can also yeah it would be
too much the cycle would be too slow if
you do it from the from the command line
edit should be supported by some sort of
proof to mother you shouldn't be able to
modify altimeter yeah it seems like but
it seems like there's an opportunity to
serve have some notion of a proof
debugger that's loud Simmons is sort of
like a psycho Crump strategy where you
can say it when they split it shows you
all the different do the same in line in
my 11 yeah that's true though so I'm
encanta for and another thing is so it
should be probably in some way
incremental the way the Cougar words
it's easier to reprove in everything
when the bag is in the same place over
and over so for us yeah well Jared off
the couch yeah I told of the captioner
but I mean it's because I wanted to make
sure that it was squiggling all the time
yeah but anyway so that's that's one
thing so now you know the department's
here and if you look at the stepping
function is going to step to the to the
s branch and since we if we have
something that looks like this
I mean this this used to have type net
because of the way the wrong function
the wrong typing move worked and now it
has typed true teacher which is
different so you know that there is a
problem so anyway so this was just to
show some some support I mean I guess
now I have it's already two to ten and
so I can discuss a little bit more yeah
what's like an extra CBD wise what are
their acceleration with talking about me
was like Wichita jeez so yeah so
deafening for example doesn't have
higher order functions which is which is
a big limitation we need for for
especially in this kind of setting but
usually you can represent so say in
you would use an environment for things
like a partial function environment and
here you can use a map right and things
like this so otherwise in you have
this these relations that allow you to
define inductively what your evidence
looks like and indefinitely you can use
predicates for this but it doesn't have
quite the same expressivity especially
in terms of of like termination and co
induction because Co inductive relations
have a certain properties of things but
yeah I've been able to do quite some
fancy systems and Daphne so one thing
for example is doing logical relations
it's very hard to do in cog because you
have a lot of mutual inductions but in
Daphne I can just use a step index and
and it works quite well
okay any more questions yeah so that
that's it for the for the demo part i
thought this example was was nice
because it it shows that definitely can
do a lot of the proving itself and you
can really focus on the interesting case
the way i actually use it in practice is
I I work top down so I start with what
the theorem I want to prove and then
whenever a case gets complicated I just
make up a lemma for this case and I keep
going and then and then later I realized
oh maybe this lemma is too general is
never going to hold and I refine it and
what's nice then is that if the original
proof works with the more precisely
modes so it so it still works and it's
not like in where when you create a
la moda the exact a form of dilemma
really matters for how you're going to
to use it in the proofs so what I mean
here is that I'd use an example from
from my presentation yeah so first I
thought I needed this lemma which which
I guess you would need to understand the
calculus but is basically saying that if
you have it's basically the sub typing
in version if you have two paths and
their types are subtypes of each other
and you can get something from P then
you should also be able to get something
from what it should be a P prime here
you should get something from P prime
and it should be in a subtyping relation
and the problem is then I thought I
found out that this doesn't hold in my
calculus which is strange because you
would you would kind of expect this but
then I realized that if I just add the
additional rule p reduces to P prime oh
my all my proofs were still going
through because in every case definitely
managed to prove that P does reduce to P
Prime and then I was able to to keep it
as it is just by refining dilemma
so I found out that it didn't work by
just looking at it and trying to to
prove it for a little bit and seeing in
which case I got stuck and then I came
up with a counterexample okay
so any questions about Daphne so I
thought I'd end up by showing how i've
been using Daphne in my own research so
just give a quick introduction to what
I've been working on with the Martino
deskey and others at EPFL yep it's a
sunday yeah it's on github Daphne
sandbox and there are other there are
other things there actually okay
so what we're trying to do with this
dependent object types calculus is
capture a core feature of skala which is
path dependent types and the goal is to
really have this core calculus v.v what
every other skala type maps to so we
would only have these path dependent
types these abstract type members and we
would silk model scala's mixture of
nominal and structural typing but only
to refinement types and then everything
else that Skala has like higher kinda
types existential types we wouldn't
really model directly in the calculus we
also don't want to model inheritance
this would be expressed by by a
translation to the calculus and just to
give an example just to give a beef
overview of the syntax what we have is
that the types are the most interesting
part this is what we're trying to
capture so we start with a bottom and a
top type and then we have these
refinement types which allow you to say
that we are extending this this type T
with a set of declarations and
declarations can be values and methods
as usual but also types and if they're
types you specify them by giving a lower
bound type and an upper bound type and
because because types can have types as
members you need when you have an object
of a certain type you should be able to
refer to these type members and this is
what it's done with these path-dependent
types so p dot n means take the type
member l frumpy and that's also a type
mm-hmm like that ok big array it's oh
yeah so to make it concrete you can have
an animal and it has some type meal
which is which is upper bounded by food
so you would say the lower bound is
bottom and the upper bound is food and
dot and then you can extend this animal
with a cow and you would say that here
meal is just grass so its upper bounded
and lower bound
bye-bye grass and then you can reason
about these things so if you have an
animal you can't really feed it anything
if all you know about it is that it's an
animal because if I could feed an animal
okay well meet then if it's a cow that
wouldn't be so good so and the reason
why this works in the calculus is that
whatever this type is it has to be a
lower bound of a dot mil and you don't
really know what a dot mil is but you
can open it up and since we're doing
subtyping on the right with me we open
it up by looking at the lower bound and
here we have bottom so we cannot feed it
anything on the other hand if we have a
cow we can feed it grass for the same
reason yeah so this is to make it
concrete but but really the point is we
just have these types elections and
refinement type so it's pretty minimal
and then we extend it with type
intersections and unions in a classical
way to get a sub typing lattice and so
the goal was to really have just a
minimal set of types and then I try to
see where we can go from there 11 key
motivation from skala was that currently
in skala it doesn't have this classical
intersection and union types which means
that when you compute the greatest lower
bound in the least upper bound things
have to be done in an eager fashion and
you can get into into types that that
that that are actually approximated by
an infinite sequence and in dot this
would be solved by really just oh I
forgot this one yeah so and that this
would be solved because you would just
say that well we just want the least
upper bound of C and D and that's just
the type by itself so we're kind of
delaying the problem to when we need to
expand this type and look at it
ok so the calculus itself is is a is
simply syntax is rather simple but in
terms of judgment it gets a bit
complicated like you have the usual type
of sign land subtyping word fulness but
you also have this expansion which
allows you to flat and look at whether
what is really the set of declarations
in the type because you can have nested
refinements refinements with
intersections Union and things and then
membership which allows you to select a
particular decoration from a term and so
if we look at the addy example where
we're we're we're looking at a function
that has an apply method and we're
taking the union with another function
with an apply method then in practice
what that means is that if we if we if
we type an application of this function
we need to we need to take the this is
the type of the function with when we
expand it we get this type for the apply
method and so we see that the D
computation is done at at at the time
where you actually need to know you know
it's not done at the time where the
function when the type is defined but at
the time where the type is used so this
was just to give you a flavor and for
for this for this concrete example of
animals what happens with these bounds
is that when we are refining animal we
still have to keep this we still have to
to use these these bands from animal and
from from cow together so the way we do
it is that for the for for this for this
refinement of animal here we have that
the the dis reads that the lower bound
is grass or bottom and the upper bound
is grass or foot and that just reduces
to grass or grass so that works fine
here but if instead we just said that ok
meal can just be food with a lower bound
of food then here we would get bad
bounds we would get food to grass and
this means that in practice this means
that this type can never be instantiated
because when we when we create a type we
checked the bounds are
oh yes yes yes
and and one interesting aspect is that
we don't really have a separate class
table for things the nominal ET comes in
really just through these path dependent
types which means that here if I if I
have something that is a that is a that
is a poodle then I know that it's a pet
because if it's a poodle I can I can
open it up and see that okay I I really
just need to compare dog to pet and then
i can compare pet to pets so by rev
eventually every subtyping rule on path
dependent types if if there is no
structural aspect that it reaches a
reflexivity part on the chain okay and
then i just wanted to give a flavor of
the kind of issues we have so one
example is that we need to take path
equality into account because here
there's no need to understand this code
and detail but the gist of it is that a
dot i dot l reduces to V dot l + b dot l
has this type that depends on B and a
dot i dot l has this type a dot i dot X
that depends on on on a dot I so somehow
now we need to be able to relate these
two types but on a first on a first
approximation they're not equal because
a dot i dot X has a lower bound of
bottom which means that here we can't
really compare it to be dot X by opening
it up but we know something more we know
that a dot I reduces to be so it works
in this case but somehow that means that
you're typing model needs to take bath
equality into account
because right I see ya the difference oh
yeah exactly so if here it was yeah yeah
well it's a it's a yeah it depends on on
what is in your store yeah I mean this
is only true because a dot I reduces to
be if I thought I was reducing to be
Prime it wouldn't be true anymore yep
yeah to the road yeah yeah but that's
that's that becomes an issue only when
you have things in the store so it's
really something that shows in when you
have preservation yeah and yeah this
this uh this is also related to the
subtyping inversion where you where you
can where you really where you really
need to add the clothes p reduces to p
prime in this and this lemma for it to
actually work and initially we also had
some very strange issues with well
formless one tricky aspect here is that
you have these intersections that are
somewhat delayed because you something
looks fine so if you just look at the
type over here down here it looks fine
by itself and it's only when X dot L is
refined to be this type here that you
have a problem and the problem is that
if you look at the red types by
themselves then you have that be refers
to a and then here a refers to be so
there's like a cyclic dependency between
them and somehow if you try to ensure
depending on your web form these rules
you might get stuck in the most precise
type not endure in the previous
situation so that's just to give a
flavor I mean we're in in summary what
we've been doing is is really actually
using Daphne to to help guide the design
of the calculus also and figure out what
do we really need to for preservation to
hold and we're also looking at
alternatives using logical relations and
big step semantics for this calculus so
yeah that's it any questions
if you represent some of the rules in
this language and Daphne already yeah
yes so I have the so this one is a very
big development actually so it it's it
probably doesn't completely time out in
the ID but it doesn't completely like
down some time outs and the ID when you
run it but the gist of it is you have
this this I'm going to remove the other
things
so I'm just going to make this bigger
so the main thing is that we have typing
for paths and the typing also takes the
store in a context and it returns a type
for the path and here I'm using what
Nick Hill mentioned before i'm using
this predicate approach not this
function approach and i'm also always
using a step index so that whenever i
have any recursive call i'm i'm just
decreasing the step index which allows
me to really do mutual induction proofs
easily just based on that and then mmhmm
yeah and then we have like all sorts of
other things like well-formed
declarations and everything well from
type and then you can see for example
this membership rule is not very
constructive right as just as well I
mean it's using exist n choose a lot and
things like this so so you can do that
sort of thing as well my typing has data
types mm-hmm you can do induction on
that dude yes g private using this
natural numbers is a better way to do
that induction
so I i miss a little bit being able to
do inductive evidence like kind of data
types in the in the in the prop world
and talk but on the other hand in
mutual induction is quite tricky i mean
sure it does some part of it
automatically for you but then you have
to do a lot of work to get it started
right and here i have so many judgments
that using the step index is just so
much easier like Daphne can can always
say okay this is decreasing and and and
then I can I can do my post of course
the catch is that if if I have a sort of
unintended cyclic dependencies which
means that for some derivation it always
goes to zero then that's not so great
but yeah so I need to watch out for this
but in general it's been it's been
rather nice to do that like just to show
also won one thing I didn't really do
too much is that because i'm using the
step index i need to actually show that
things are monotonic like if you
increase the step index you still you
still get the same types and so so
there's these ghosts lemmas that do this
and this I I mean I didn't bother to
prove the more like some of them I just
assume for now and and keep going with
this
ok so i guess it's mean this is really
awesome do you like it but for a moment
I'm going to play the role of it you
know it grumpy person you know just a
freshman you know that a person may
raise is that you know ty systems are
inheriting these constructive things
that you work with we get nice
construction crews out of part of
and you can interpret theorems and
godless of constructions and stuff what
can you say here yeah that's I mean well
hopefully I guess you're getting too
maybe having a verified core of Daphne
but I don't know for me it's really just
right now my concern is really okay I'm
doing this this research calculus can i
how do i how do I get some guidance on
improving it sound and ours so many
Harry issues and i find that doing
things in daphne allows me to focus on
the big picture I mean eventually maybe
it's you maybe it's not convincing to
everyone but for me it's it for it
focuses on the big picture I can really
I don't need to do this low-level
manipulation to get the exact poof term
that I need for for for something but I
mean under the hood I think if xiii is a
sound and things are fine right
yeah well does the classical existing
structure strong yeah yeah yes I guess
we won't worry i might look at it is to
say well no there's community people who
doing time cruise mm-hmm there's a
community pay these days will do you
know military in carpet and maybe this
is sort of you know somewhere in the
middle of you don't necessarily get the
tiny tcp that you may get the cough but
it's certainly like way better than yeah
maybe we don't need like my
participation
and and I think especially for teaching
Daphne has a lot of potential because
the way it does induction is very
natural so even just learning these
concepts it would be much easier and
Daphne then then in where you have
to learn more dismiss machinery and the
stepping curve is really high Daphne
uses some concepts that you already kind
of understand which is contracts and and
boot straps from there to do more
serious moving yeah it's generating
these groups where your party empty
college choices well yeah I mean one
thing you can do is you can also if you
really want to so it depends why you're
doing the proof right if you really want
to if you're doing it as a bigger
beginners true student trying to
understand progress then this is not so
helpful right that is just saying well
that's done so one thing you can do is
really do say here induction false and
then yourself try to do the steps
manually and I mean in this case it
wouldn't be so hard it would still help
you with other aspects but there is
there is a yeah there is a way to to try
to get more insights so what we do think
alike it is that the that you use this
is saving human
two groups in the first place then if
your people really wondering about
the soundproof then one can imagine that
one would take the proofs that seed
reconstruct Matt them back to Beaufort
well generate those groups and then map
that backs them out to the buoy level
and into the Daphne level and that will
be a large project to do but I mean some
people like doing that and he would mean
a lot to a lot of people you know I
guess I just wanna go some way to get
approved a format that's not viable by
something that is example a viable right
no no this one to me this season comes
out and but its version of water
resources then needs to be manipulated
and fed to something else that would
then you want independent verification
right and so it's it's possible but it's
a big project azis three still does it's
proof still a fairly big steps right
it's as I think it's an actress on bro
and I can also negative ends on what
you're using this checker
come on could also mention it such a
project i'm in such a while you could be
a very large one but if we started with
something that in these examples use
functions and data types maybe there's a
more direct translation of these groups
and and the input to bodega Savelle or
something at all
nothing is terrible but you can be I
guess you didn't show you the calc save
me oh yeah sometimes when you with your
right to prove yourselves instead of
having guests asserts and calls out to
to love us you can use verified
calculations and those are quite three
human readable yeah there was just one
trick like regarding the capture
avoiding substitution so you can do a
renaming like like here well this is for
like your type substitution but it's the
same thing but the problem then is that
the decreasing clause is a bit you need
to decrease on the size of your of your
data type instead of the of the of the
actual structural look of the data type
but you can also do this in daphne quite
easily by defining your own decreasing
measures and things okay deeply
impressed so too so that is here to tell
until the end of the week so if you were
if you want to
parts of our brain that let me know or
if you want to show her the latest
thanks
thanks Ramon thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>