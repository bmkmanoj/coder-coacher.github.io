<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Synthesis of small quantum and reversible circuits with quality guarantee | Coder Coacher - Coaching Coders</title><meta content="Synthesis of small quantum and reversible circuits with quality guarantee - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Synthesis of small quantum and reversible circuits with quality guarantee</b></h2><h5 class="post__date">2016-07-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/17k884aS3g0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year Microsoft Research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
they the Clark group it has Dimitri
Moslem visiting so we're excited to have
Dimitri here Dimitri received his degree
in mathematics from Moscow State
University in Russia in 2000 and
received his master's and PhD in
computer science from the University of
New Brunswick Canada in 2002 and 2003
currently Dimitri is working as the
program director and the division of
computing and communication foundations
a Directorate for computer and
information science and engineering at
NSF and is also an adjunct faculty
member at University of Waterloo in the
Department of physics and astronomy and
also for the Institute for quantum
computing which is there his research
interests include quantum circuits and
architectures quantum algorithms quorum
information processing logic synthesis
reversible logic and circuit complexity
and today we'll hear about synthesis for
reversible circuits with applications to
quantum circuits so we're excited to
have Dmitri let's welcome to Michi thank
you for the introduction so I right away
found an error um it's on the title I
forgot to change it so hopefully
hopefully for the rest of the dog there
will be no no other Corrections okay so
what I would like to talk about today is
about different kinds of optimal
searches for the implementations of
different kinds of functions so talk
about optimal synthesis of reversible
circuits optimal synthesis of multiple
qubit unit Ares the truly quantum
circuits in other words and optimal
synthesis of single qubit union trees so
the optimal synthesis of single qubit
unit Ares is actually highly relevant to
the work done by Alex and and krysta so
our result we developed independently of
Alex and krysta but it
seems as if we developed the same thing
from looking at it do different angles
so but I'll talk about it and we'll see
what the differences are so a good thing
is we just heard Alex's talk so it will
be uh it's still fresh in the mind
so hopefully the dip the differences
will be uh evident um so I wanted to
show those a few gates the not gate they
see not gate that awfully gate and
hopefully with more controls so for
example so this topic has two controls
it computes that exclusive or boolean
product of variables x and y the toefl e
for it has three controls so here it
will compute exclusive for of this
variable x boolean prod plus boolean
product of the three variables above so
when we talk about circuits the
difference between reversible and
quantum circuits and the classical
circuits is that we do not allow fan
outs and we do not allow feedback
because the way it works in quantum is
and the reversible case the circuits
aren't physical but they describe the
time evolution so having a fan out would
correspond to duplicating the particle
and due to energy mass conservation we
probably cannot do it and the feedback
would be travel back in time which is
also a bad idea probably I mean there
are closed timelike curves where you can
probably travel back in time but then
the complex the implications are such
that probably it is still in force
impossible even if the history of
travelling back in time were consistent
anyways that is not the point of the
talk so the quantum gates are the
Hadamard gate we'll already saw it
earlier today is a 2 by 2 matrix so I'd
like to is trade how the Hadamard gate
works on this
two-dimensional picture which you can
also think of as three-dimensional
picture this is a CAD 0 state and
perpendicular to it a cat one state so
what the HK does the Hadamard it
reflects the state about this axis so
algebraically if we apply H gate to the
cat 0 which is vector 1 0 oh I have a
pointer ok so which is vector 1 0 then
the result of the computation is this
state and indeed on the picture we can
see that if we take this vector and
reflect with respect to the to this line
then we have this vector and this is
exactly what H of 0 is so it's it's a
reflection for 0 for completeness let's
verify it for cat 1 so H applied to cat
1 algebraically is going to be this
expression and in terms of the picture
we take this vector we reflect it with
respect to this line and this is the
result and we could see that the result
actually corresponds to what we computed
algebraically so this coordinate is 1
over square root of 2 negative 1 or
square root of 2 so each gate is a
fairly nice and easy to to see so the
the other gate gates that I'm going to
use in this talk include the t gate so
unlike Alex I prefer to actually write
it down as 1 e to the so this is the
eighth root of unity so the W here
corresponds to the eighth root of unity
this is how I will denote it I will
actually use the eighth root of unity
throughout the talk so I'd rather
introduce it right away we already
discussed the reasons to use the t gate
well we needed because of the fault
tolerance and because we can actually
physically construct it so unlike other
gates that are not necessarily as
obvious how to construct and as such
they need to be implemented
as circuits with what we know how to
construct so the phase gate you can
think of it as T squared so when you
look at the matrix this matrix squared
is the square of its entries so the only
thing that changes is W which is 8 root
of unity it is changing to the fourth
root of unity and becoming I so the
phase gate is 1 0 0 I um in practice we
do not implement the phase gate as a
sequence of two T's because that would
be I mean that would be correct but it
will be way too expensive because if one
word who has to meet the relative costs
of the t gate with respect to phase gate
then in a good sense
if the t gate was associated with some
sort of physical cost called the hundred
and the phase gate would cost about four
so it is much much cheaper so are the
said gate again we can we can think of
the said gate as P squared or T to the
power of four and then when we raise
elements of this matrix to the power 4
this is 1 0 0 and this becomes negative
1 so again we don't implement that as as
a circuit with two peas because there is
a direct implementation of Z and I
believe it's physical cost is about
compared to T is about 1 on the scale
that I introduced so T gate costs
hundred this costs about four discuss
about 1 so it's it's much much cheaper
so why we consider those gates here are
a few reasons so using the library with
C naught gates we can compute linear
reversible functions so those functions
are quite important because for example
when we talk about Clifford circuits
linear reversible functions due to
Aronson and guardsman is the most
difficult
part of the Clifford circuits in fact
the very similar ability of the Clifford
circuits relies has the bottleneck of
simulating linear reversible circuits so
the efficiency of linear reversible
circuits determines the efficiency of
Clifford circuits the Clifford circuits
now we don't technically need the Zed
gate here but I included it now is our
last I mean Zed is just P squared so we
could avoid it completely this library
is over specified the Clifford circuits
are important because because they
they're required in the air correction
and in in quantum computing we will
likely need to correct the years more
likely so than in the classical
computing well in classical computing
was started by studying the error
correcting codes and then it turned out
that for computational purposes we don't
need those it looks like in quantum we
actually will need those so an clifford
circuits are very important so T plus C
not these are very this is an
interesting class this set is actually
discrete it contains a kind of linear
reversible circuits modified by T's so
this is an interesting set so TOEFL e um
you can also add Z naught to the TOEFL e
but in a sense if you have a single
qubit residing in state 1 then the C
naught is is it awfully using this this
single qubit so the toefl gate gives us
an irreversible function when we are
have the library with H and T gates had
more than T then we can implement any
single qubit a gate and by that I mean
approximate because we have infinitely
many unitary so with any discrete set of
gates will know it directly implement is
not enough to implement any unitary
from an infinite set but we can
efficiently approximate those and
finally Clifford plus T gives all unit
Ares via the approximation okay so the
first problem I'm going to discuss
contrary to the advertisement in the in
the abstract it made more sense to me to
invert the order of of the things I'm
going to discuss and start with the
reversible circuits because it is
simpler so the problem that we
formulated is we want to synthesize
optimal circuits and optimality means
minimal resources such as gate count
depth minimal so what else we can do we
can do the weighted gate count we can do
way to depth restricted architecture is
I mean there are lots of different
metrics that that one could use and so
why do we want to have optimal
implementations well one of the reasons
it could be a useful library for those
physicists trying to establish a certain
experiment and having a limited control
over their quantum mechanical system so
for example if if if your quantum
mechanical if your if your apparatus
allows you to apply ten gates and you
look up the unitary or the
transformation and library and it turns
out that that the optimal circuit has 12
then no you cannot implement it you have
to gain more control over quantum
mechanical system before you can do
something that complex so perhaps a
bigger reason is the peephole
optimization methods they're being
currently an important part of any
reasonably sophisticated compiler so
once you have a library of optimal
implementations and you want to optimize
a quantum circuit you just cut small sub
circuits compare those sub circuits to
the optimal circuit store it in a
library and see if it is beneficial to
do a substitution at
real idea but very practical and finally
the mathematical curiosity computing the
value of the Shannons complexity
function in other words what is the
number of gates required to implement a
function of a certain size so in 2002 a
Shanda Markov has and maybe somebody
else I don't remember all the authors
showed that linear that reversible
functions with three inputs require no
more than eight gates so we improve this
by looking at the 4-bit reversible
functions we show that the number of
gates required is fifteen I do not
believe that L of five can be computed
in my lifetime anyways even if the
scaling continues even if the Moore's
Law continues to hold I just if the
problem is too complex that's right but
can you prove that you can probably
guess but can you prove it
so our reversible for a bit function as
a permutation of the 4-bit integers and
it may be computed using those
reversible gates I introduced they not C
not thoughtfully and thoughtfully for
the reason I need it awfully for I need
for completeness I need an odd
permutation and the other permutations
are even so I just need something that
is odd we want to synthesize optimal
circuits and what was done previously in
2003 Iger mark of in a previous slide I
said 2004 but it mean 2002 2002 was
their conference paper this I am
referring to a journal paper so they
showed optimal reversible circuits for
three bit reversible functions and there
are two to the power of three factorial
of them so factorial is applied to two
to the power of 3 which is eight
factorial
in other words 40,320
so in year 2006 again the Markov's group
at the university of michigan tried to
synthesize for beat reversible circuits
and they were able to synthesize 26
million of them the number of reversible
circuits for beat reversible circuits is
2 to the power of 4 factorial which is
16 factorial it's a 13 digit number so
this number is an 8 digit number so
there are quite a few more digits to go
so we introduced two searches so first
let me explain how to synthesize a given
function and then I will explain how to
synthesize all functions so in a sense
if you can synthesize all functions you
can you can synthesize any one function
because you just you run the search
until you found the one that you want
but the search is is is very long so
it's not practical and conversely in
principle if you can synthesize any one
function you can synthesize all by
waiting long enough but then again that
also turns out to be non practical so we
have developed two algorithms so now
will synthesize I will explain how to
synthesize any any given function so we
use breadth-first search to find optimal
circuits with some L divided by two
gates we choose L divided by two to be a
high enough number to guarantee that our
algorithm works in our particular case l
divided by 2 is 9 and the L divided by 2
has to be greater than the number of
gates needed to implement any reversible
function o for inputs so once we found
all circuits with at most L divided by 2
gates so any optimal circuit for any
function can be found in this big
database of the coughs of all optimal
circuits
by searching this database of course
okay so in in our experiments it turned
out that the number of circuits that we
store is is this number so for so this
is the number of circuits with up to
nine gates of course if you if you just
have this database and you search it
twice for two halves the complexity
becomes too high it becomes s to the
power two and TS is this long number I
gave on the previous slide so it is not
efficient so we need we need something
more efficient and okay so this is what
it says the if we just search for two
hats
this is how many boolean operations we
need and we can do let's say 10 to the
power of nine in a second so so this
number becomes too large to be practical
so what we do instead is we hash the
table off of circuits we use Thomas Wang
hash function for those familiar with
hashing functions for permutations if
not then it's just air hash and function
I don't know why it's efficient but it
is so with our ass log s we have
approximately this many boolean
operations I mean of course I'm kind of
cheating here it's it's not this many
operations but just to show you that
this number looks much shorter than this
number so the difference between yeah oh
alright so the use of hashing so you
need to find two halves right so to find
one half you need the number of
operations equal to the size of a
database so but to find the second half
we we use a hash table so so we
calculate the hash key
and we queried the database if it has
any values with this cache cache and and
that is only poly log on the on the size
of the database which dates
okay yeah so okay oh you got all right
so finally we actually do one more
reduction which which in theory may be
not as impressive as it is in in
practice we we say that if we have an
optimal circuit then it is still optimal
with respect to input-output permutation
of which there are four factorial four
variables we can permute them in in any
order four factorial is 24 and function
inverse so if we have an optimal circuit
then the inverse of this circuit is also
an optimal circuit so we can pack almost
24 times to be in 48 circuits into into
one circuit because they're all in a
sense identical so here is a recap so we
started with the solution basically we
said that we use a breadth-first search
that requires order of n space and order
of n time complexity where n is the
number of its 16 factorial the number of
circuits
so we first reduce it to order of
roughly this is a little bit of cheating
this is a lower bound and by no means an
upper bound we cannot calculate an upper
bound but we believe that the upper
bound is actually much lower than the
order of n and what we do is we
synthesize only half of all optimal
circuits so then the run time reduces to
order square root of n but we have to
search for two halves and the and the
complexity of the search is is the
square of the size of the database then
we introduce the hash table and reduce
the time complexity to square root of n
poly log square root of n this is
actually a poly log but I mean
log poly log not a big difference as
long as we have square root in front and
the small constant because it has to be
practical ah and we reduced furthermore
the space complexity by a factor of 48
so it turns out that for a random for a
random reversible function of four
variables it has no symmetries more
often than not
so the actual fact or a practical factor
is forty seven point nine five I think
so which is pretty much says that only
in one in a hundred cases there are any
symmetries whatsoever so this is how the
distribution of reversible functions
requiring a certain number of gates
looks like so the reduced functions is
what we actually store in the database
this is the actual functions so what
here this table says is it says that
there are 4.8 million different
reversible functions requiring five
gates in an optimal implementation so
we're done experimented with ten million
random functions so on the input we have
ten million random functions fed one by
one and on the output the software
produces an optimal implementation in
principle there could be more than one
optimal circuit but as soon as we find
one we say well there you go
it is optimal so what is surprising
about this search is the time it takes
to find an optimal implementation being
zero point zero seven seconds per
circuit it is incredibly fast I could
not almost believe how fast it is
because so if you think of you know
having the answer being all optimal
circuits stored on a hard drive without
any reductions then this hard drive
would have to be at least hundred
terabytes so if it were
5,400 rpm hard drive then the expected
time to extract data a single bit of
data from such a hard drive would be
0.01 seconds so ours is faster is 0.07
seconds so it is very surprisingly fast
okay so now to synthesizing old
functions well we could not come up with
anything very smart so what we did is a
breadth-first search so what we did is
we composed an indictable set of 4-bit
permutations well taken input output
relay billing and the inverse symmetries
into account as much as possible so in
practice what we were able to do is we
were able to reduce this the 16
factorial the number of all functions by
a factor approximately 12 to 13 not the
full 48 because with both symmetries
included relabeling and inverse we could
not come up with an easy to compute
index and we wanted to have an indexable
vector so that we can change it
according to the function value and we
could calculate the function according
to the index very quickly so that was
the requirement then what we did is we
ran the depth-first search on the bit
vector to toggle those bits if the
function is implementable with an
optimal circuit of a certain size the
the a bit vector that we used is 209
gigabytes in size
we used a hundred and twenty eight
gigabyte machines so in order to feed
that factor into RAM we needed to break
it into three parts so so we actually
ended up running the calculation on nine
nodes of a cluster iqc cluster and the
total run time to calculate all optimal
circuits is about
1 million seconds which amounts to about
13 days so here is the complete
distribution of the number of gates
required in optimal implementations of
the 4-bit reversible functions so note
that there are only hundred and
forty-four functions of size 15 and
interestingly if you remove the
symmetries there will be only five so
meaning one has no symmetries and four
more have two symmetries okay so now
I'll talk about multi qubit circuits so
what we do in this project is is we try
to synthesize optimal implementations
for some small useful transformations so
for example the toefl gate I mean we
probably need the toefl gate because it
seems to be used everywhere you look at
it is used in sure is integer factoring
algorithm for the reversible computation
part it is used in fault tolerance for
for this syndrome detection and it is
used well it's used everywhere and the
reason of course an implementation of
the toefl gate using the library of c
not Hadamard phase and T and the reason
we use this library of gates is due to
the restrictions imposed by error
correction but we wanted to check if if
this implementation is optimal and find
optimal implementations if we can for
some other small functions so again what
we do is similarly to the previously
described project we compose a library
of depth optimal circuits so this time
we decided to look at depth but could as
well be any other function so whichever
function you want to use we can we can
use in the software as long as it
doesn't have too many values so we
search the library of halves to find
an optimal implementation and and output
the circuit so so the interesting part
here is the results so for example the
TOEFL gate speaking of the TOEFL gate is
we were able to find an implementation
with the overall depth eight I believe
the one in Nielson Chuang book has an
overall depth of about maybe 10 13 15 13
15 cents
of course here the Tdap and T is the
more complex gate likely it is not
necessarily the case because for example
if you can see there and and for example
a Hamiltonian used in liquid state and
Ammar then the t gate is actually
released expensive of all of these gates
in a in a non fault tolerant
implementation in a direct
implementation but but if you want to do
something full tolerantly skaila bleed
and then then T has to be implemented
differently it's it's a logical gate so
the T depth here is for which sort of
improves what the Neilson Chuang had
because they had the T depth I believe
it was seven but I via playing a little
bit with the circuit could be reduced to
six so we could reduce from or what sigh
oh yeah because you can execute this and
this in parallel by executing first
stage second third fourth and then this
is peak and and so on yeah so it's it's
it's four but you have to kind of
rewrite it a little bit and so then we
found this surrogate with T depth free
so ah so this is it's not written here
very well but this is one layer of T's
this is the second layer of T's and this
is the third layer of these
which gives the Tdap free so what we
have also done we are compared to what
we our synthesis algorithm to the one we
were able to find online and pretty much
the only one available is the docents
implementation of the salivic dive a
great thing about it I mean it has lots
of it leaves lots of room for
improvement but a great thing about it
is it actually works with multi qubit
circuits which is great so this is the
scaling of the docents implementation
compared to our implementations so as
you can see we can go further in depth
than then the dose and but in a way it's
it's not the best comparison because for
example if we use Dawson's code with
four levels of recursion to generate our
controlled age gate we come up with a
with an approximation that is 0.34
distance away from the controlled
Hadamard which takes about two minutes
and the implementation has about a
thousand gates where as we synthesized
an exact circuit our exact surrogate has
seven gates and the the it took 0.5
seconds to synthesize a surrogate but
you know we're not claiming we're like a
hundred times better because we're not
comparing apples to apples here we're
comparing apples to oranges but we only
had oranges to compare to so and we
wanted to make a comparison of sorts
another interesting thing we have tried
to do or so here is an optimal
implementation of the ctrl P note that
the key depth is 2 however if you
consider the controlled P as an
operational free cubits then this
circuit is an optimum
surrogate implementing the controlled P
note that the tea depth here is actually
one so we were surprised by this
phenomena and then we were able to prove
the following theorem basically what the
theorem says is is is if we have a
circuit with C naught plus T gates we
can paralyze it to any depth you want
but it's a subject to how much how many
ancilla you can give me if you can give
me sufficiently many depth one I can do
if you don't give me as much as I want
and maybe depth two if you give me only
a few than then the depth will be maybe
closer to the number of T gates so this
is formally a the statement of the lemma
all of the theory so this number can
actually be improved but I mean not
going to talk about that much still it's
it's interesting that any C naught plus
the circuit can be optimized to depth
one depth one T so I have to also say
that a part of this of this research and
and the theorem and some of the
follow-up things that were currently
doing was also inspired by discussions
with Peter Zenger who showed us a T
depth one optimal totally implementation
well it's obviously optimal because
there cannot be anything better than the
T depth one but it uses for insulin
another thing we try to do is we took
the clifford gates and we took the t
gate and we look at their controlled
versions and it turned out that all the
controlled versions can be implemented
in fact we implemented them using our
algorithm we implemented them optimally
so we then realized that if a unitary
you can be implemented exactly over the
Clifford plus T library then so can are
the controlled version of you the
control you and if the vector of costs
for the unitary you was well first
is the number of Hatter modes use second
as the number of phase gate used third
is the number of XI not gate used and
force is the number of t gates used than
to calculate the number of Hadamard
phase C naught and T gates what you need
to do is multiply this column vector
it's it's actually a column vector by
this matrix so so what we need to get
into this theorem is we took we took the
controlled H implemented it optimally
and actually if you can if you look at
this matrix you can sort of see what
happens so the controlled H the
controlled H when implemented optimally
requires two Hadamard gates zero phase
gates to see not gates and forties okay
so probably I read it incorrectly so let
me think for a second we multiply this
matrix by this column vector so yeah
their column so yeah so the yeah sorry
yeah so I thought I had to read the
column instead not the role so so you
need to have a Mart gates for controlled
Hadamard you need to face gates you need
one C naught and two T's any and that
gives you our control data memory and
controlled P is described by this factor
it's funny how controlled P does not
require P it required on requires only
T's and C knots but in a way T is the
square root of P so it makes total sense
because there is a direct relation
between a square root of a gate and it's
controlled version yeah it's on Neal's
in Nielson 2 on page 182 one of my
favorite circuits so I remember it okay
how do you how do you get to the point
where you are proved that that one day
you can be implemented exactly um since
you can be implemented exactly we take
the circuit for you and we control every
single gate if we control every single
gate it is equivalent to controlling the
whole transformation and for each
controlled gate we found its optimal
implementation and we substitute the
controlled gates with their
implementation yeah uh-huh okay so now
to the single qubit unit race finally so
here is the original motivation for our
research and what we actually try to
accomplish before we rot what we wrote
we wanted to study if a unitary you can
be implemented exactly in the Clifford
plus T basis so we obviously want an
exact implementation and the reason for
that is there are enough errors in
quantum algorithms already so firstly
firstly there are algorithmic errors
such as you know the Shor's algorithm
does not guarantee you the answer with
probability one it's not Kurt subas all
gotten that always guarantees that you
multiply two integers and you actually
do get the result but it's it's a it's a
it's a randomized algorithm in a sense
not a randomized it's quantum but but
you get the answer with a probability we
have errors due to decoherence and
that's the reason why we have the error
correction and full tolerance that
increases the circuit sizes when you go
from logical circuits to physical
circuits by a factor of what must be
close to a thousand if not more than
that in other words it is expensive to
have those decoherence errors and there
are systematic errors in the controlling
apparatus and again they also need to be
fought with so what we were able to
prove is we were able to prove the
following theorem in the single qubit
case are the set of all unitary is
implementable
the Clifford plus T basis is equivalent
to the set of unit Ares over this ring
so this ring is an integer extension of
pi and 1 over square root of 2 we
furthermore conjecture that in the n
cubed case the set of all 2 to the N the
set of all unitary zhan and cubits
implementable by circuits in the
Clifford plus T basis is equivalent to
the set of all unit Airy's over this
ring as long as there is an ancillary
qubit available that resides in state
zero so the requirement I will not be
able to prove the conjecture this is
what we try to do we couldn't do it we
made some partial progress but not
nearly enough what I can do is I can
illustrate that the ancilla qubit the
the requirement to have and seal a qubit
is essential and then I will outline the
proof of the theory so so first let me
let me show that the the requirement to
have an Cielo in the formulation of the
conjecture is is important in particular
we'd like to illustrate it with it with
the example of the controlled t gate and
the determinant argument so if you look
at the determinant of the controlled t
viewed as as a matrix on two qubits a
four by four matrix then the determinant
equals to the W and to remind the W is
the eighth root of unity
however the determinant of gates that
that we can work with Hadamard phase C
naught and T belong to the set plus
minus I plus minus 1.so so since
determine is multiplicative multiplying
these numbers we can never get the W so
we can not have the controlled T on on
on the two qubits you could say that
well what if we want to build the
control T up to a global phase well a
little bit more hand-waving
well maybe not necessarily hand-waving
but formal arguments
actually shows that no you cannot do it
up to global phase either so uh huh yeah
yeah no no no you cannot it's basically
the same determinant argument but have
to have to spend a bit more time
nevertheless controlled tea may be
implemented using three cubits by this
circuit this is this is unnecessarily
complex essentially what this circuit
does it applies cations trick oh if I
have a pen and a paper I'll show a much
simpler circuit so we want to implement
a controlled tea so what we do is we do
controlled swap this qubit resides in
state zero we do a controlled swap then
we apply tea here and we apply fredkin
again okay so get iced trick from 95 my
other most most favorite circuit I guess
so here it's just optimized a little bit
in fact it actually optimized even
though it doesn't look like yes exactly
that would have been a tea oh right
which would have given you the same
thing back and so that was your tea that
you have on the other one for the
control swap huh everything else if you
look at it yeah yeah it is so yeah so so
this is kind of inverse of music except
for one gate or a complex conjugate I
want because complex conjugate I complex
conjugate of C naught is just the C not
complex conjugate of T is T complex
conjugate and of P is P complex
conjugate and H complex conjugate is H
yeah yeah so it is symmetric just like
this circuit the parent is also
symmetric with respect to T
okay so now to the proof of the of the
theorem so to remind you what we're
trying to prove is that the set of all
unit Aries over the ring of the integer
extension of I + 1 over square root of 2
is equivalent to the circuits computable
by H and T gates because Clifford
becomes pretty much H and P but P can be
simulated with two T's so so agent T
suffices so firstly from a linear
algebra book we know that it's actually
I'm cheating here a little bit in linear
algebra this is e to the I Phi for any
Phi but we know that any unitary can be
written in this form so K runs from 0 to
7 so you can if you look at those unit
Ares of this form for different values
of K then there are all equivalent up to
multiplication by powers of T so in a
sense when you have a 2 by 2 unitary
what you have instead is just the vector
XY because everything else the column
vector XY because everything else you
can restore if you can if you can if you
can get to the vector X Y so this
observation helps us to move from the
synthesis of unit aires to the synthesis
of states if we can synthesize States
efficiently if we can synthesize any
state over the ring then we can
synthesize any unitary because unit Ares
can be easily restored so to show that
we can synthesize the states we use the
notion of this smaller is the
denominator exponent though so the
smaller is denominator exponent here it
is defined formally but it is an analog
of an irreducible fraction for
numbers so so when we look at the ring
that is an integer extension of PI and
one over square root of two we know that
we have some fractions where the
denominator is is is the power of the
square root of two so as de is just the
power of the square root of two defined
such that it is and what we're looking
at is in irreducible fraction so first
allama it's actually very simple to
prove if you look at a two by two matrix
then as the ease of all elements of this
matrix are equal so the reason for that
is if if this number has denominator
square root of 2 to the power n and this
one has square root of 2 to the power
say n plus 1 then this vector has to be
normalized and the normalization doesn't
work out it's yeah yeah it's yeah it's
irrational
it's like proving that the square root
of 2 is a rational number pretty much
the same argument very easy ok so next
thing we do is we consider the result of
multiplication of a vector and now we
work with vectors only because we know
that they're equivalent to two matrices
by H multiplied by t to the power of K
so by multiplying one two matrices by a
vector column we get this result so now
I'm going to cheat a little bit in the
sense that I'm going to show two
technical results that I'm not going to
prove but I'm going to claim that it is
proved in the paper I just don't want to
prove it the proof is not is not very
difficult
it's just technical you have to study
the properties of SDE for a long time
before you can prove this inequality and
this equality so right let me describe
what the inequalities are and what is
the meaning behind them so so we want to
show that by multiplying a state by
applying h
k ^ ki - of K - a state we are change
the denominator by no more than one in
either way we can increase it by one we
may not change it or we may decrease it
by one this is what this inequality
states
it states that SDE of the square of this
value and this value can be found here
- SD of this value which is this value
so the first coordinate of the of the
vector we're looking at it it is
squeezed between 1 and negative 1 so it
can increase by 1 decrease by 1 or not
change so and a second very interesting
thing that we need to prove that we
actually do prove is for any s in the
set negative 1 0 1 we can find the K
such that the difference of those s DS
so this expression is exactly the same
expression as this expression equals to
exactly s what this means is by applying
H T to the power of K we can reduce the
denominator by 1 power of the
denominator by 1 we can not change it or
we can increase by 1 so at this point
you probably are thinking well there you
go we have an algorithm for the
synthesis so we always find s such that
the denominator we always find K such
that the denominator is increased by 1
and then when the denominator is is the
power of the denominator is small enough
then we can use breadth-first search to
breadth-first search all those unit Ares
with small denominator size and this is
exactly what we do so here is the
algorithm on the input we have column
vector ok think about it on the input we
technically on the input we have a
matrix a 2x2 matrix but we right away
drop the second column of the matrix and
and we only look
the the first column so we do risk for
the second column at the very end but
it's I already said too many things
about a very trivial thing so the output
is the circuit that prepares state XY
from cat zero so the way the algorithm
works is well SDE of the first component
of the column vector we have is greater
or equal than four we'll find K such
that application of HT ^ K reduces the
denominator of X and we substitute H T
to the power of K multiplied by vector
column X Y into X Y so so this the
denominator of the first component of
this vector is smaller than the
denominator of any smaller exactly by
one than the denominator of this one so
in a sense for the SDE of the square of
the first component of the vector
greater or equal than for the set of
Clifford plus T circuits on a single
qubit is sort of flat and at every at
every level you can predict what is
happening you can increase the
denominator you can you can decrease it
it may not change so it's it's very
predictable the behavior is very
predictable and we brute force finally
when we can not apply this step anymore
because SDE is less than 4 we basically
brute force all the implementations of
all unitary such that as de is less than
4 there are probably close to 20,000 of
those but a few in either case yeah so
they can be easily brute-force done and
stored so let me prove H optimality in
other words let me prove that the number
of Hadamard gates is actually optimal in
our circuits so to increase or decrease
as d by 1 we need precisely 1 Hadamard
gate it is
it is proved so the set of all unit Ares
with SD of x squared equals 8 equals to
the set of H optimal circuits with 700
gates we ran a computer search to
actually verify that this statement is
correct so this statement is verified by
a computer search as such we conclude
that this is our N equals 1 a a sort of
state and the mathematical induction
this is the induction step so we use the
inductive proof to show that the number
of Hadamard gates required to implement
a particular unitary equals to the size
of the denominator of x squared where X
is the top entry u 1 1 plus 1 that's the
number of Hadamard gates and apparently
our algorithm just matches as d of x
squared plus 1 so we furthermore looked
at possible T optimality we cannot prove
the optimality but we can but with what
we can do is we can using breadth-first
search we can synthesize all optimal
circuits with up to 13 gates then we
synthesized them using our algorithm and
it turned out that we got all the T
counts correctly so we do believe that
our T counts are also optimal we cannot
say anything about the peak out so the
phase gates the number of phase gates we
use may be suboptimal we just don't know
we don't have a feeling we didn't try to
study that but H optimality we can prove
is is is there the T optimality seems to
be the case
the key count of T to the power K ah the
T count of T to the power of K equals 1
if K is odd and 0 if T is even because T
to the third is is PT yeah
Faye's times T yeah yeah so we yeah we
do this reduction yeah uh-huh it's just
it's for the proof it's easier to
operate with powers of T than to operate
with P times T or Z times T or Z times P
times T or yeah because it is much
cleaner so another thing I didn't have
the time to add this slide but our
algorithm the complexity of our
algorithm is linear in the number of
gates in the circuit so what this means
that this algorithm among all algorithms
among all synthesis algorithms is
asymptotically optimal I mean I mean
just the mere time it takes to run a to
to write the circuit with M gates is at
least order of n and order a fan is the
complexity of our synthesis algorithm so
so it is efficient our input is the
unitary so once we have the unitary we
can synthesize so in fact what we do in
experiments and I believe this is one of
the next slides yeah so let me get to it
it it's probably one after that so so
here is a similar comparison to Dawson
Nielsen so it's it's a software to
software comparison in a way again we're
comparing apples to oranges so this is
the behavior of the Nielsen Dawson's
implementation of the sole of archetype
so this is a zero iterations one
iteration to iteration 3 4 5 6 7 so at
you can see that the error did not
improve here
so this the scales are logarithmic and
sorry about the small font size but
that's it was generated by an automatic
software and did not increase the font
size yet so so this is the result of
using double data format in C C++ it
does not have enough precision to go
beyond airs on the order of 10 to the
minus 8 or 10 to the minus 9
it just flights out there it doesn't
work we have ever used a a Multi
precision arithmetic so we were able to
go far beyond actually I'll I'll show
you on the next slide that actually much
for then then could be shown in this
picture the the smallest error is that
we have circuits for on the order of 10
to the minus 50 then 10 to the minus 50
is likely unpractical and unpractical in
the sense that why would you need
something that is this precise yeah yeah
we approximate these rotations these for
tations for for other things we tried
the graphs look very similar so we just
show the few that you know look nice and
everything else looks about the same I
mean it's logarithmic scale so even even
if something is different by 30 to 40
percent which seems to be the case for a
random unitary right that this point is
going to be maybe yeah here yeah so so
they're going there about kind of the
same so so this actually very nicely
defines the range of points that's where
they're going to land all of them for a
random unitary but again I mean our
database was was larger because you can
see for zero iterations we're better and
our implementation was more efficient so
that's why partially the this slope is
much better
this slope also another experiment we
did is we took the circuits synthesized
by docents implementation of the
syllabic it I've computed the unitary
and synthesized the unit we're using our
algorithm so the reduction in the number
of gates was only on the order of about
50% so so the approximations are not
efficient but they're surrogates are
actually fairly good well 50% away from
what we believe should be fairly close
to optimal in whatever metric of optimal
that you choose yeah but this graph
shows that finding the finding a good
approximation to a unitary is a much
more difficult task than if you have a
good approximation already finding a
circuit for it
finding a circuit is easy it can be done
in time
linear in the number of gates in the
optimal circuit I mean it cannot be
better than that but finding an
efficient approximation is very hard ok
so here is a here is an example of the
experimental results so here it shows
the year down to 10 to the minus 15 so
if I if I click here we actually have
more circuits ok so here are the
implementations of the are z2 divided by
the power of an for an between 4 and 30
so each of them approximates down to 10
to the power of minus 50 approximately
so if you want to have a circuit with
that approximates to a very small error
then you have to pay a heavy price on
for example the number of T's 1.7
million so actually we also have circuit
files here so if you click here it's a
fairly small circuit the number of gates
in this circuit is only 73 counting all
gates
28
gates so this is the circuit okay not
displayed very well so let me switch the
browser then okay so here is the same
page so this is this is the circuit you
can actually view this circuit using the
software for viewing the circuits that
we that we also have on the group web
page oh it's called the QC viewer can
you can download play with it if you
want to it's not the best for displaying
circuits with millions of gates on a
single qubit but but if you have
circuits with tens of gates on a few
qubits then it's kind of much nicer in
fact all of the circuits that I showed
today were generated automatically by
this QC viewer software yeah okay so let
me go back to the presentation what's
left of it
acknowledgments so I'd like to
acknowledge the help from my students
met Amy who is a master student for the
English negev who is a PhD student ah
all the gala bits key one of the
co-authors he he's an ACM programming
contest champion and he's a really
extremely good coder which explains why
the numbers in the reversible logic
synthesis are so low because he has
helped tremendously coding it and he's
he's he's great ah then professor Mike
Mosca who is handling the the quantum
circuits Research Group in my absence at
the University of Waterloo and an ACEF
independent of research and development
program that allows me to do research
despite being an administrator okay
thank you
I liked it a little more about the high
precision arithmetic that you see I'm
sure I can just send you the links to
where you can download it from if that's
what you would no no no we downloaded it
from online yeah it's just available
it's a C C++ library for dealing with
large numbers and it's just that it's
one of those libraries you don't yeah
you don't have to use that library
because there are so many different ones
yeah I even brought one myself but it's
so low not good that it's not available
anymore oh okay yeah I can't recall
where we downloaded it from maybe maybe
it's yours oh it's internal well may
still be yours yeah I don't remember
which one it is I think that's the one
yeah yeah I think that's the one we use
from now it's gonna pop oh yeah no we
didn't try to prove we didn't want to
step on someone else's turf I think we
can actually have a few more but
the same since yeah yeah there yeah
there may be one yeah yeah you see the
we concentrated on the Hadamard because
that's how we looked at the matrices we
looked at the denominator and
denominator is defined by a demur and
between two catamites you can only
squeeze one t no more than one T so yeah
whatever that gives a single qubit case
which in my opinion is super trivial but
the two-qubit case we tried to prove the
theorem that we had in the two cubed
case it's much more difficult for
example because you need an ancillary
that you don't need in the single qubit
case for what it's worth you have
entanglement which may come into play
and it could only complicate things
some sort of projection or some sort of
yeah I think yeah I think it's it's much
more difficult it's just it's single
cubed cases trivial two cubed cases it
was very difficult in my opinion I mean
we couldn't do much
we were however if you would like to
know we were able to prove that the
unitary synthesis in the N cubed case
can be reduced to state synthesis we
could do that step but that's as far as
we went
and the proof is far from trivial
but that's a unitary system states oh
yeah in a way they're equivalent but
state synthesis is simpler because all
you need is any matrix with B column
that you want to have but when you have
M matrix you need the matrix that matrix
yeah so anyway we reduced the problem of
size 4 to the power of n to the problem
of size 2 to the power of n but but that
wasn't the the most difficult part we
don't believe that that that part is
difficult we believe that reducing it to
solving the problem with 2 to the power
of n variables that is difficult
so when you experimented with the matrix
isn't simply the case yes no what what
yeah we we did both I mean we used
salivic a diet that we implemented
ourselves so so when you have a unitary
that can that is not a unitary over the
ring that we have we know and if it's a
if it's a 2x2 unitary we know that
provably we cannot implement this
unitary exactly
we need to approximate it for
approximation we use solloway key dive
it's just that the code that we use is
the code that we wrote for Sal evocative
but not the docents code because when we
looked at it we found that we could
write something better
so we wrote something something better
which we believe is better and and then
if we're given a unitary we first look
at it and say is it the unitary over our
ring if it is synthesize it using the
algorithm if it's not use our Sal
evocative to come up with the
approximation unitary it comes up with a
circuit but we don't care about the
circuit we come we only care about the
unitary and then we use the unitary to
synthesize the circuit so in a way yeah
so G aprox is the time it takes to
approximate a unitary so because this
unitary is not a unitary in the ring
this unitary lies outside the ring so T
aprox is the time spanned by the our
implementation of salivic type and T
decomposition is the time spent to
actually synthesize the circuit using
our algorithm so so the software
consists of two parts
over urine yes and his DS are other
large yep numerator is the integers
could be also quite large yes we use our
own implementation at symbolic it's
fully symbolic because you see for
example here we have 15,000 Hadamard
gates 15,000 Hadamard gates implies
square root of 2 to the power 15
thousand two hundred ninety-two plus
minus 1 approximately yeah so we just we
need we needed our own arithmetic for
that so we used our own arithmetic
yeah yeah yeah all right all right all
right
that order or words the Gaussian
integers extended by screws ooh it's
actually we represent by four but yeah
we use huh so it seems like if you had a
software that does see extended by one
more square root of four then dealing
with infinite precision integer
arithmetic would be a subset of what
your package does oh no because it's
very specialized it doesn't do any of
the multiplication yeah okay
it's suited only for our needs it has
only a limited limited capability very
limited</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>