<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Engineering Methods for Ensuring Program Correctness | Coder Coacher - Coaching Coders</title><meta content="Engineering Methods for Ensuring Program Correctness - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Engineering Methods for Ensuring Program Correctness</b></h2><h5 class="post__date">2016-08-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/FLOKNkv6WUk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
okay so now we're online and welcome
back to the software engineering session
it's my great pleasure today to welcome
mr. Lee know who's a principal
researcher at Microsoft Research so he
is famous for having been involved in
various projects leading to successful
software tools in formal verification he
got his PhD from Caltech and he's going
to talk to us today about engineering
methods for ensuring program correctness
something in which he is an expert thank
you all right thank you all for coming
I'm going to tell you a little bit about
just one slide on some formal methods
some some techniques used for ensuring
correctness and programs that are going
on at Microsoft and then through the
rest of my talk I'm going to tell you
about the specific tool called Daphne
that you'll see a lot of during the
summit here and I'll give you some demos
of that but first to set the context at
Microsoft there's there are several
formal methods that are being used
formal program verification techniques
that are being applied in software
development and one of them is the is
the model checker slam that is these
days called a static driver verifier
that we heard about in in tony hayes
talk yesterday another one which is and
so the model checker there has been very
successful because it's used by
third-party driver developers there's
also white box fuzzing being done with a
tool called sage so sage has also been a
great success in that it's run on on
hundreds of machines over long periods
of times it could be days weeks and the
to find errors in in crucial pieces of
software another tool that I'm quite
thrilled about is called sim diff which
takes two programs and compares the
compares them so for example when you
have one version of a program that
you've developed and maybe it's very
large and you add a few lines of code to
it you'd like to see what are the same
mantic differences you don't want to
know just what lines of code did you
change but you want to know what what
was the effect of those changes so the
sim diff tool does some things like that
and the area that I'm going to talk
about here today is program verification
which is the traditional deductive
program verification that the people
envision in the late 60s 70s there were
some tools built in even in the 70s but
some of the things that did not that did
not happen at that point was that the
CPUs and technology and specification
techniques and things like that we're
not as well developed we know much
better how to do those things today 30
40 years later and that's what I'm going
to give you a taste of today using the
Daphne tool so um there are a number of
program verifiers out there in academia
and you can think of plotting them on
the on two axes so what I have here on
the chart is is on the on the right on
the y-axis I'm showing how much of the
program you're going to try to verify so
you might be interested in proving the
full functional correctness of a program
or you might just want to prove some
simple properties may be that the
program will terminate may be that it
will not crash when you run it so you
have a choice there in how much you
prove on the x-axis i'm showing human
effort that is how much that's a human
need to spend time with the tool to get
it to do useful things and that can mean
a variety of things it could be that you
have to annotate your program in some
way to begin with you have to learn what
the tool does you have to wait for it to
run and then you have to decipher the
error messages to figure out what it is
that you should do when you get an error
message from the tool so in the in the
traditional setting for impro graham
verification the way that it's used in
education the one tends to be somewhere
around here that is students are taught
to to prove the full functional
correctness of small pieces of code and
that's usually done by hand that's sort
of a traditional view of how these
things have had been used um but there
are also interactive proof assistance so
mechanical
ways to check that the proofs are
correct and there are mean tools like
 like Isabel Hall like a CL 2 and
and a number of other ones and with
those what you get is assurance that the
proofs that you did that you carry out
or really sound mathematical proofs but
it's still a lot of effort to to run one
of the tools so a number of years ago
15-20 years ago I was involved in two
efforts called extended static checking
that tried to use automatic decision
procedures so in other words proving
technology that you don't have to
interact with directly there are
automatic procedures but then scaling
down the ambitions so that you would
only try to prove simpler properties of
programs so that area we call extended
static checking and and the interesting
thing I find is that you can actually
use that same those same automatic
decision procedures and push things up
into the left upper left-hand corner and
that's where the tool daphnia switch I'm
going to show you today there are some
other tools like Daphne but Daphne
stands out in its in its automation and
cleanliness of how you how you write the
programs ok so let me tell you about the
Daphne language because Daphne is not
just a program verification tool it's
also language that goes with that so
that you can write programs and write
specifications and as a language you can
think of Daphne more or less as C sharp
or Java that is it has classes it has
generic it has pulled morphisms of
generic classes it does not have
subclasses so it's not a true or object
oriented language but you can still
encode tricky algorithms that have to do
with pointers and dynamic allocation the
way that you would do write the program
in C for example one thing that's
important for for this setting is that
that Daphne only has sequential control
there's no parallel lism there's no
concurrency in the indefinite we have
other tools that the deal with
concurrency but Daphne is only
sequential now when you want to prove a
program correct you want to have
specifications of some sort and daphne
builds those into the language so you
can write programs you
right pre impose conditions Lupin
variants and we'll see that today and
when you do that you also need some
specification support that is it's not
enough just that you would have the
specification constructs you need to be
able to describe data and often you use
mathematical sets mathematical sequences
inductive data types are quite useful
many times and something that's that's
also very nice is to have ghost
constructs so a ghost construct like a
ghost variable is a variable that that
the verifier looks on just like it was
any other kind of variable but when you
compile the program it goes away that is
it's their only two for you to
communicate some things to the to the
verifier and we'll see an example of
that okay so with no further ado what
I'm going to do is launch into a number
of demos so that you can just see Daphne
for yourselves and so what I'm going to
do is I'll write some some code I'll
write a few programs and we can look at
some other ones that that I've
pre-prepared and these programs are
going to be small programs that are
right just to show you what the features
are and how you interact with a tool and
then I'll show you some larger programs
that are have also been verified with
Daphne ok so as a first example I'd like
to to write a program that's going to
use several different features of Daphne
that in in a way that you can see could
be meaningful but the particular example
perhaps is not so interesting what I'm
going to do is define a data type so
data type is just like you have in in ml
or in F sharp or in Haskell and I'm
going to define a tree so the tree is is
going to either be a leaf node or it's
going to be a node consisting of a tree
and let's let's put an integer in here
it doesn't matter much what it is I
could I could also have made it made it
generic as that for example let's just
put integers in here for simplicity ok
so that's a that should look like a
pretty familiar data type now in some
languages like Scala you have both data
types like these n class
asus or same things in them in okay um
oh and that's a nice combination you
have it in in Daphne as well so now we
can write a function that that operates
on on this data type and what I'm going
to have is a function contains which is
going to take a tree and take a
particular a given integer and it's
going to say whether or not that integer
is contained within the tree now i'm
driving a function here so the function
in Daphne is a is a function in the
mathematical sense that is you can think
of a haskell function or a or function
that you'd write on paper a reason about
in your head it's not a c function so c
function is is a procedure where a
method and we'll get to those in a in a
bit but so function is just a
mathematical function and the way that
i'm going to write this function is in
the usual style of a functional
programmer which would be that you match
on the argument and you have two cases
you either have a leaf and if it's leaf
the delete then the tree does not
contain whatever integer it is because
the leaf does not contain anything and
if it's a node we have a left we have a
value and we have a right and in that
case we have the tree contains X if X is
equal to V or if if maybe the left
branch contain sex or if the right
branch contains contains X ok so so far
what I've written looks just like what
you what you would have written in in
some other language that is we have not
seen any verification features yet but
let me let me know show you what happens
if if you change some part of a program
that is going to change how the how the
verifier would work so Daphne
automatically proves termination of your
of everything that you write down that
is it's a termination of recursion of of
methods of loops so here what i did was
i change the the contains to pass in the
tree itself so if you pass in the tree
itself there's no there's no guarantee
that this that this function is ever
going to terminate and Daphne tells us
that it cannot prove termination so in
this case Daphne is not sure that that
maybe the program terminates for some
reason that that we have to explain to
the pro 2 to the verifier so therefore
it says try supplying a decreases clause
which is the specification construct
that you would use in the program to to
reason about termination but very often
you don't have to supply anything okay
so that's the so that's that and you can
see that just as I'm typing in the
program the verifier is running in the
background okay so now let's write a
piece of code that's going to do
something and what it's going to do is
it's going to take a given tree and it's
going to take the elements of the tree
and put them into into an array and
we're going to start at some at some
index that is at some index into the
array so we're given some array and
we're going to start filling the array
with the elements of the tree beginning
at that index now we're also going to
have to return something which is we we
may not fill the entire array and in
that case we're going to return the
first index that was unused so just like
we have in parameters in in daphnia any
other languages you can also have out
parameters and you can have any number
of them so in this case we need one of
them and it will be an integer okay so
now i'm going to write the first
specification that we've seen and the
specification is going to say what my
intent is what do i mean with the fill
method what is it that it's supposed to
do well I'd like to fill method to have
the property that M that for all indices
that lie between start and end it is the
case that that the tree contains the
elements stored in the array at that
index so this is my specification of
what I'd like the method to do and we
can see that we're getting these
squiggly lines right away even in the
specification we haven't written a line
of a real code executable code yet and
it's complaining that the array may be
null so this is because the
specifications that you write down must
be well-formed in some ways if you if
someone had passed in no Leslie
ray here what would this specification
mean it's not clear so Daphne ensures
that it it enforces that the
specifications that you write down are
well-formed just like it enforces that
the programs that you write are
well-formed so in this case we could try
some some sort of if statement but in
fact the the right way to do here seems
to be just have a precondition that
checks that make sure that that no one
passes in all as the array so
precondition is something that the
caller should live up to and we can then
assume that in the in the body well
we're still getting a complaint and the
complaint is that the index that we are
given here may be out of bounds we know
that in this context I is somewhere
between start and less than end but we
have no idea what start and end are they
could be any integers so we will add
another precondition and so the another
precondition that says that that start
is going to be somewhere between zero
and and the length of the array so we're
going to allow start to be all the way I
mean at the end of the array so that
nothing else could fit in there in that
case the fill method will not do
anything and we will also ensure as a
post condition that end is going to end
be somewhere between start and the the
length of the of the array okay so once
I've written those things Daphne is
happy with the specification I get no
more complaints so some of the things
that you should think about as you see
these demos by the way is how do you
write programs when you write the
specifications you write the
specifications afterwards do you write
them as you develop the program if you
write the specs when you develop the
program it's much easier something else
that that many of you may be interested
in is when you teach these sorts of
things in a class having the tool there
to explain these things for you for the
students that is to get the red squiggly
lines all the time is something that is
that helps improve the cycle of
turnaround that is you can go through
many more attempts in this way okay so
now let's let's write the the code for
this method so we can see immediately
when I started adding the body that it
starts complaining about the post
conditions well that's because I haven't
written anything yet that's going to
ensure this condition so of course this
can be any piece of code but in this
particular case it's going to start off
almost like a functional program because
I'm going to match on the on the tree
structure that just happens to be the
case in in this particular program so if
we if we are given a leaf what should we
do now and I'll be happy to take your
suggestion so just shout them out here
what should we do in the case of getting
a leaf I see a hand half raised over
here from any ideas nothing yeah almost
nothing we do need to do something we do
need to set the output parameter but in
fact otherwise we should do nothing so
that's so there are several ways of
doing that the simplest way is just to
assign the to sign to the output
parameter you can also you can also
return the value that's going to also
put it into into the output parameter
but let's just leave it at that okay so
in the other case when we have a left we
have a value and we have a right what
should we do then well in this case we
need to do we need to do some recursion
that is we're going to operate filling
from the left branch and the and the
taking the value itself and doing the
right branch so what I'm going to do is
just call the method recursively on the
left tree the same array and the same
start index because that's where we want
to start filling it and this is going to
return to us where that recursive call
has ended filling in the the array from
the left branch so I'll have to put that
into some variables I'll just put it in
the in the variable and since that's
seems convenient okay then what we're
going to do is we're going to now take
the the element itself and stuff that
into the array that's what we're
supposed to do after all and then
finally we will call the the method
recursively again this time on the on
the right branch and I will give it one
position further since we've now
filled in the V and in fact whatever
that returns is what we want to return
in in the end here so that is perhaps
what you might write as the program to
begin with but but now you're asking
yourself is this program correct can I
rely on that this piece of code is
really correct and definitely thinks
that it is not it's complaining here
that we're updating a variable name it
namely a that is the elements of the of
the array and we're not allowed to
because the specification does not tell
us that we're allowed to to modify
anything at all so in the specifications
that you write if your methods modify
something you must say so you're not
allowed to just arbitrary arbitrarily
modify things in the in the heap so the
specification is simple to write we just
say that we modify a which means that
we're allowed to modify the elements of
the array okay well we still get some
some complaints about the post condition
in about an index out of range so who
can tell me why why are we getting an
index out of range here yeah
start and end might be the same that's
true but the but that's it's not always
the case that it could be that the left
branch was was just a leaf in that case
it would be fine to have start an end be
the same
yes indeed the postcondition I'm glad
you answered it not by the postcondition
only says that end is going to be
somewhere between start and the length
of the array so it could be at the upper
end so if it's equal to the length of
the array then we're not allowed to use
that as an index so if you think about
what's going on at some point we had
better check to see if we run out of
space in the array and there's no piece
of code like this and that's what we're
getting the complaint about so we check
we'll check here to see if end is not
equal to the length then we will update
the array and then fill it from the
other side okay so that looks looks
better now we should get rid of of that
complaint but we still have another
complaint which is that post condition
does not hold on this path now if you
study this program carefully you would
you would try to get you would start to
build some confidence in that the
program is actually correct but the
verifier does not know it and the reason
for that is that when the verifier looks
at the recursive calls all it looks at
is the specifications that are given and
in this case it turns out that the
specification is too weak so all that is
known afterwards here is that the is
that the is that the indices between
start and end are ones that are
contained in the in the array but it
says nothing about the other ones so in
particular the verifier thinks that the
recursive call may just change the other
elements in the array arbitrarily so
what we need to do in this case is write
another specification that talks about
the other elements of the array so I
will say that for all indices up to up
to but not including start a sub I is
unchanged which means that it's equal to
whatever it's the old value used to be
okay so with that special specification
the verifier verifies that this program
is correct so now we are we are done
with that program okay so what I've
given you here in this demo is giving
you a flavor of some of the features of
Daphne that is both data types and and
erase imperative features I've shown you
a few specification constructs like pre
and post conditions modifies clauses and
you've seen that check both for
termination
and you've seen it check against our
code against the specifications so this
is the sort of way that you would that
you would interact with the verifier
okay are there any questions about this
demo before I go on to the next one this
would be a nice time to take some
questions on it okay let me go on to the
next demo done alright so i'm going to
show you just a very very common
specification common example in program
verification and I'll I won't try to
hold all the code i'll just pull in some
of it but i'd like to see just to show
you how you might do binary search just
because if you're teaching students or
if you've if when you were learning
computer science if you learned how to
prove binary search that's a common
example you might now compare your
experience with with what i'm going to
show you that is how how it feels to do
it in the editor in on them on the
machine so i'm going to write a pre and
post condition here i already wrote that
that the array should be not null and
binary search there is important that
we're given a sorted array so we're
going to write that as a precondition so
we're going to say that for all indices
I and J if you take an eye on J that are
ordered in this way then it will also be
the case that a sub I lies on that side
of a sub J okay that's saying that the
array is sorted coming in and as the
postcondition we're going to say
something about what the output
parameter is in this case R is the name
of the output parameter and it may or
may not be that the key that we're
looking for an array is there so we will
follow the following a protocol that if
we return a non-negative value that
signals to the caller that the value is
actually there so i use the implication
operator here and in that case i will
just simply say that that r is an index
into the array and furthermore the array
at that index is equal to the key all
right and in the other case where r lies
on the other side of zero then we want
to say that there there's no element in
the array that is equal to the key so i
will just simply
that for all I in the entire array it is
the case that a sub I is not equal to
the key okay so that's how you write
this back now when you write the the
code itself you will go through a
similar process but I just have
something that'll pull out of the oven
here so here's the here's the code for
it and what I want to highlight in this
piece of code is that to write this
piece of code what's important is that
you write down the loop invariant unless
you did it recursively by the way then
you you would just have the
specification of the method but so you
can see that there are there loop in
variance in the language that you can
write down and the important thing is as
you know from binary search is that that
the window between the two variables low
and high shrinks as we go along so let
me just show you though what what
happens if if we're a little bit unsure
about this program in what it does or if
we can if we can change it in some way
for example here i'm setting high to be
mid submit is the point in the middle
that we have that we have sampled to do
the comparison maybe we could make the
program a little bit more efficient by
saying that high is mid- one so then
we're shrinking the window a little bit
more quickly so what you might do if you
did if you develop this program without
the help of a tool is that now you would
sit here and think a lot about is this
really right is this going to function
the way I hope the two and here we can
see that there are complaints about the
loop invariant so something is wrong and
we don't have to rethink the loop
invariant or realize that this is not a
good attempt same thing with the if I if
I made a change in the other direction
of low for example maybe I thought that
the code would look nicer if I changed
it in this way then we also get the
complaints in this case it's it's
complaining about termination because
this program may not terminate because
mid may be set if low and high are just
one apart mid could be set to the same
value as what low already was and then
you make no progress okay so you can see
that what you can do with the program is
you can interactively change your
program change the specifications
bit about what does it actually mean for
the program to terminate what does a
loop invariant mean for example is it
really necessary to have all of these
inequalities or could this really be
maybe less than is that also an okay
loop invariant and these sorts of things
are things that you can ask the program
verifier you don't have to go back to
your teaching assistant and ask and then
one week later get get an answer okay so
just like just like other tools that we
use hammer home concepts like a missing
semicolon when you have a missing
semicolon the programmer gets a report
missing semicolon we feel it in it's no
big deal and if we could get computer
science to move in that direction for
four verifiers for semantic analyzers or
programs if we just write the program it
complains something is dereferencing an
array outside of its bounds we say no
big deal i'll just fix it the error
message is right there we haven't even
compile this program we have not run at
a single time and we get the complaints
and we can fix the errors okay so I'm
going to just flash by something that is
a bit larger just to show you that the
that you can do challenging algorithms
as well so the shore wait algorithm is
an algorithm that that does a marking of
a graph it's typically used in in let's
say a garbage collector so it does a
depth-first traversal of the graph and
it marks every reachable node and it
does so not by using recursion and not
by using an explicit stack that's a
separate data structure but instead it
does it by reversing the pointers in the
heap going down so when you want the
reason about that that's a complicated
thing and you can do that by with Daphne
but you have to write the loop invariant
in this case it's a complicated
algorithm and therefore it's a
complicated loop invariant I won't show
you everything here I'm just going to
scroll by first the specification of the
method which I won't really point out
here either but you can see things like
the nodes everything that is reachable
from route should be marked is what
these two lines say and this line says
that if something is marked then indeed
it was reachable in the in the initial
state
and it's very important of course that
you restore the pointers to what they
were which is what this specification
says it says that that the fields that
we're modifying are restored to their
original values okay so here comes the
code and the loop invariant and the loop
invariant and the loop invariant and the
loop invariant and the loop invariant so
it's rather big and it has lots of
quantifiers everywhere but once you
figure out what that loop invariant is
which I mean that's not an easy thing
for this particular algorithm the the
verifier verifies this one in about
three to five seconds so it's it's a
good deal there okay what I'm going to
do next is depart from the basic
features and show you show you just a
little taste of what you can do with
classes and I'm I don't have time to to
give you to give you large examples of
go into all of the fancy things that you
can do so i'll give you just a small
class more or less just to demonstrate
the concept of a class in merriam tube
okay so what I'm going to do here is
just just about the simplest class i can
i can think of which is going to be a
class that contains one counter that is
one variable and there are methods for
incrementing for incrementing this
variable but just to make the
implementation a little bit interesting
for the demo um i'm saying that the
abstract value of the class that is how
to think about it from the from the
point of view of specification is that
the class test contains a value and
therefore i'm making that variable a
ghost variable because this is this is
not something that's going to be there
represented at runtime this is just for
the verifier and for whoever is reading
the code to understand what the code
does and in the implementation for kicks
I'm doing I have two variables I'm going
to to keep track of some number of ups
and some number of downs and whatever
the difference between those two is what
the value of the counter is now in this
case then i'm actually complicating the
implementation for no particular reason
but it's it will work for the demo to
show you a relationship between various
variables okay and then we have the
usual things
constructor we have something that
returns the value of of the the counter
and you can see the specification of the
of the guessed value returns him to now
parameter the same value as the as the
ghost variable says but the ghost
variable is there only for specification
purposes it's not there at runtime so we
could not implement this method by
simply assigning value to the output
parameter but the specification can talk
about it and you can see the
implementation returns the difference
between the two and here I'm just
showing you another little feature that
is that is nice sometimes for
demonstration purposes and for for
reasoning about certain kinds of
programs and algorithms and that is that
I'm either going to increase the apps or
I'm going to decrease the downs and I
can do that it doesn't matter for
correctness which one of the two I do so
maybe this is a decision I don't want to
make at this point so I just put a star
there so I say if star so that's a
non-deterministic statement so informal
methods non determinism is quite common
when you reason about programs or you
you model things and in this case you
can also put it into the program text in
the final program that you would that
you would execute you would not tend to
use such features but i just wanted to
show it to you here okay so if you want
to prove this program to be correct then
you need to write a class invariant and
there are various flexible ways to write
to do that in daphne and here i'm using
just a very simple approach which is the
approach that the student would
encounter as the first sort of thing and
that is that that the invariant is
written as a predicate so predicate is
really just a boolean function it's the
same thing in in Daphne and here I'm
saying that the the specification
variable the ghost variable value is
equal to the difference between ups and
downs and with that it it can verify
this class quickly i might say as well
but ok so that's all I'm going to say
about classes but if you have a question
about classes this would be a nice time
to to ask
okay well good AM iam continue okay when
you do when you write a program when you
get really serious about verifying
programs that is when you're past the
the simple introductory examples and and
you're really starting to prove some
programs that you care about something
that is that tends to come up is that
you need to have some mathematical
properties of your program and this
often happens even if you don't think
that your program is so mathematical and
so in interactive theorem provers you
can prove all sorts of things about
mathematics and those are used those
things can be used as lemmas when you
when you reason about the program so if
you reason about the program it's much
better not to use an interactive theorem
prover but to use a program verifier
that is streamlined for proving programs
correct like Daphne but then what
happens when you need to prove a bit of
mathematics well the nice thing is that
you can actually prove some mathematics
and some lemmas about your programs
using Daphne itself so i'm going to to
just give you a little taste of that and
but if you want to prove complicated
mathematical things but don't use a
program every fire like Daphne then use
a any interactive verifier but if you're
just proving simpler properties that for
the purpose of proving your program is
correct then this is a good choice ok so
what I'm going to show you is is the
proof of the following property that in
a ski here I've tried to to show you you
may know the following mathematical
property that if you sum the numbers up
to N and you take their cubes sorry if
you take the cubes of the numbers up to
N and you sum them up you get the same
thing as if you take the numbers up to M
and N and sum them and then square the
result that may be a mathematical result
that you're familiar with if not you
will see the proof of it here ok so how
are we going to prove this so again this
now looks like we're straying from
program verification but I'm showing you
an application of just how you can prove
a mathematical lemma
in in Daphne so first I write a
mathematical function that is going to
be the left hand side of this this
equality so it's just going to be the
sum of cubes up to n I require as a
precondition that the number that we're
given is at least 0 I don't want to deal
with negative numbers here and I'd just
define it recursively just like you wait
the way that you would I take n cubed
and then plus the sum of cubes for the
smaller one okay that should look
familiar now for the for the right hand
side the expression inside the
parenthesis here that denotes a triangle
number so I call the method that
function triangle and it's almost the
same as thick as the cubes here I just
sum up the the numbers themselves so now
I want to write a theorem or lemma about
these two things so how am I going to
express that using a programming
language well the way that you do it in
Daphne is that you write a method and
you give as the post condition of that
method the property that you want to
prove so let's think about this for a
moment what what the programmer fire is
going to verify for you is that if you
start in the start state in that is if
you start in the state that satisfies
the precondition then the verifier will
prove that the body of the method will
terminate and it proves that when you
get to the end the post condition will
hold so this is almost like you go to
your math mathematics and friend down
the hall and you and you you give your
mathematician friends the the problem
and and then you go away for a while you
know that new math man your
mathematician friend will terminate his
process of thinking and when he does he
will have proved the theorem for you so
that's when you come back from coffee
and all is good so this is similar here
okay so how are we going to to prove
this thing well the only thing the only
technique that we have available in in
Daphne to us is we don't have proof
tactics and things like that for the
most part but instead we write code so
what I'm going to do here is I'm going
to write a piece of code that is going
to convince
the verifier that that is indeed the
theorem so what I'm going to do well if
n is equal to 0 then then the case is
really easy right there's nothing to do
you just substitute the definitions of
these two functions and then you're done
you see that everything is equal to zero
so the interesting part really comes in
when when n is not zero well if you
prove this by hand you would use what we
all know as an as an inductive
hypothesis you would prove this by
induction how do you do that if you
write the program well what you do in a
program instead is that you make use of
recursion so what I'm going to do is I'm
going to call the the theorem
recursively passing in n minus 1 so
let's think about what happens here
we're dealing with a programmer fire so
when we get when the program verifier
reasons about that call it will check
that the precondition holds well will it
we're passing in n minus 1 and the
precondition says that we must pass in a
number that's that's at least 0 but
luckily we had checked already 40 so
this is ok ok then it's also going to
check that this will terminate and in
this case that also comes down to
checking that the parameter is going to
decrease I won't go into any more
details of that at this point but you
need to know that the induction is well
found that is but that comes down to him
and given those two things we are now
allowed to upon return of the method to
assume the post condition so now we get
that post condition but for n minus 1
and that's exactly what the induction
hypothesis is so in this in this case
the the I was expecting another property
but let me so you can you can get get
more complicated things in the in the
proofs that you that you supply that you
need to have more more methods more more
conditions and it turns out that Daphne
also performs a little bit of induction
automatically for you and and that tends
to have
but the if you write if you write
universal quantifiers that you try to
prove so I won't go into the tech
techniques of that but let me point out
one more thing which is that this method
which is which is I've just named
theorem that's something that we're not
interested in executing this we don't
want to actually compute that post I
mean whatever actually this method
doesn't it doesn't change anything it
has no output parameters it doesn't
really compute anything but we're never
interested in calling it at runtime we
just want to verify or to understand
what it does so therefore I've made it a
ghost method so having it to be a ghost
mess that just means that the compiler
will not emit any code for it just like
a ghost variable or some other goes
construct by the way I should have said
also that all of the specifications pre
impose conditions assertions loop
invariants all of those things are also
ghost constructs and Daphne so when you
compile the program all of them go away
because there's no reason to check them
at runtime the verifier has checked that
they will hold okay so what I will do
now is just quickly show you a larger
program and that is that's making use of
induction and this larger program was
part of one of the verification
competitions that that took place last
year and it was essentially to prove the
correctness of Floyd's tortoise and hare
algorithm you may know this algorithm it
it's given a linked list or if you think
of it mathematically it's given a
function but it's given a linked list
and it wants to check does this linked
list ever end in with null or does it
loop into a circle at some point that is
is there cycle on it and one way to do
that is to have two pointers that you
march down the linked list and you
advance the front one twice the speed as
the as the one in the back so that's the
tortoise and hare you have something
going fast and something going slow and
if the two pointers will ever meet you
have you have detected a cycle and and
you know there's a cycle and if they
don't meet the one will reach the end of
the linked list and there's no cycle so
that's a tricky argument that you would
make for making sure that this is
correct so this file is is rather large
but we can see the Miss search for
induction so in the proof of this there
it happens several times that you need
induction and here it's here it's using
that induction tactic automatically the
one that's built into Daphne here's
another place here's another place and
here and that was it so there are
several places in in the method in the
in the file in the proof where you need
induction just to prove some properties
of of an algorithm and that's that's
what you see here so Daphne does those
things automatically in some cases okay
so let me just get back to the slides
and start wrapping up here I want to
tell you something about what the
technology is behind Daphne you've seen
that Daphne runs in the background in
visual studio for example and it runs in
the background and it seems fast and
responsive in fact if you look very
carefully you would have seen the CPU
meter and seeing that most of the time
that we were waiting for the verifier
we're just waiting for for a little bit
of idle time so that the verifier knows
oh this is a good time to run so it's
very fast Daphne builds on the program
verification engine called boogie um
which is also developed in our group
boogie is a is a language by itself and
it has a program verifier associated
with it and what you do with with Daphne
and similar programs is that you
translate your source language into the
Boogie language much in the same way
that you would translate your source
language into into machine language if
you want to compile it but you you build
up a mathematical model in in the
translation into booking and then boogie
gets confused a large or large
mathematical formulas verification
conditions those conditions are correct
if and only if the boogie program is
correct and those formulas are passed to
the automatic SMT solvers III which is
also developed in our group which is the
the best one of its kind in in this kind
of with this kind of application but
this so this is the picture that that is
behind Daphne the way I showed it in
these demos but that's not the whole
story Daphne is part of a whole family
of a ver
his tools and here i show some of them
this is not a complete list there are
many different program air fires and
similar tools that are built on top of
of boogie that also make use of xiii and
boogie can also go to some other
verifiers but we tend to use xiii really
exclusively and there are some boogie to
boogie transforms that that can check
that can infer properties about programs
or can check the difference between two
programs for example and out of the
programs on top the verifiers on top
several of them are developed in our
group several of them are developed in
the academic community in in other
groups and there have been the some some
really impressive things being done I
both using these tools for example to
have a tool has checked large portions
of of the windows code base for certain
kinds of errors okay so that's the the
family so all of the daphne and boogie
and many of the of the other checkers on
top are open source as well and they're
available so you can you can use those
as starting points if you want to build
a verifier okay so you might wonder now
who is using Daphne so I've shown you a
number of examples so it's Microsoft
using Daphne for example do we use it in
in developing products and that's not
the case Daphne is a is a research
prototype it's it's the it's using and
experimenting new features of
specifications and what tends to happen
with those features is that that some of
those features like determination
checking some of the inductive data
types and the way they've been handled
and they're probably some other features
on the brink of happening as well that
are flowing into the VCC verifier which
is a verifier for seed programs and that
one has been used to verify some tricky
pieces of code in them that have been
developed at Microsoft so Daphne itself
is not used but definitely has been used
to verify algorithms that are like the
ones that you that you've seen and it's
it's being used in teaching so I would
encourage you that if you're in a
situation where where you'd like to
teach about reasoning about programs
then consider using a tool and of course
I would recommend Daphne I think that
Daphne is the the simplest one of the
ones to use
but do you use a tool I think it's a
really good good idea it gives the
students feedback but much more quickly
you can run Daphne on the web in the
rice for fun at the rice for fun site
where we have a number of tools that
that are being produced in our group and
Daphne recently passed 100,000 different
different users that is different
programs that have been submitted over a
hundred thousand of them and up from
comparing that to January in January was
about 35,000 so this number is growing
pretty quickly at this point um there
was there been some program verification
competitions and there was one that gave
out medals that was the vs CT 2012
program verification competition and in
it there were teams from all over the
world they're competing with many
different languages many different
verifiers and six of those teams use
Daphne there was only one other tool
that namely that was used more
often than then Daphne so daphne was
used quite a bit and there were six
medallist awarded so there were two
goals two silvers two bronzes and out of
those six two of them were Daphne teams
and in fact Cox which was used in more
did not get any medal this year one of
the other medalist was was using the VCC
tool so that's also built on the Boogie
chain so if you're interested in these
sorts of things or if you have students
that love programming and love getting
into competing with these things do have
them I mean check out the verification
competition it's was a great 48-hour
adrenaline rush and I would recommend it
to anyone ok here's the daphne on the
web which is on the rise for fun website
that you've seen some other mentions of
during this conference as well and
there's a very nice tutorial for for
Daphne that you can find on that on that
website you might wonder what where is
Daphne going next there are number of
features that I'm rolling into Daphne
and there are some other things that
that are being developed around the
program verification not just doing
programmer ification but thinking about
the program development cycle like
refinement and synthesis
okay so in summary what I've shown you
is a program verifier that lets you
prove not just simple properties but
that can go up to full functional
correctness so that you can verify
programs and you can do that
interactively when you interact with the
tool all the interaction that you do is
at the level of a programming language
you write loop invariants preconditions
things like that you don't go into
mechanical a theorem prover and try to
to issue tactics and things like that
you say with the program that's how you
think so you can use to acne yourself
both in binary forms in and in the in
source form you can teach with it that
is use it in in teaching have exercises
that are there are Daphne programs or
that are using the Daphne tool and you
can extend it by getting the sources and
I'm leaving you with some some URLs but
if you just go to the Daphne source to
Daphne web page which for which we have
a little postcard that we're handing out
as well you'll find all of this
information as well let me just give one
more plug and that is for a little video
blog called verification cornered I do
where I have a collection of videos
that's that that's growing where I
demonstrate various concepts in program
verification and and those are can be
fun to watch and you might also learn
something so with those things i'll draw
too close and i'm happy to take any
questions until you detest tells me that
it's that I can't have many more thank
you very much
yes yep maybe you want to maybe you want
to put it yes if you've proved your
algorithm with Daphne but you need to
use it in Java or C or whatever yeah and
so maybe you don't have you know this
the the same primitive so what do you do
right so so the question is then I mean
the fact that definitely works on Daphne
programs and you have other programs
that you would like to verify so there
are a number of them you can if you go
outside the use of Daphne there are some
other verifiers as well for example VCC
is a very powerful verifier for C
programs that does concurrent see
programs and all of the seeghe or eNOS
and things like that they're the there
are also some other tools for
sharp and so forth but they're not as
well developed so there there are sort
the sources are available and you can I
mean if you're interested in those sorts
of things may be there there's some
collaboration that could happen to beep
those up a little bit more if you use
just Daphne the the way that you would
tend to use it in that cases you would
go to Daphne type in your program verify
it and then you would do a very careful
job of rewriting it in Java just hoping
that you don't get things wrong but the
right that tends to be how it is
definitely compiles to.net so you can
there's some ways that you can call
between between Daphne and other things
you can get the c-sharp code for example
but definitely can translate to c-sharp
code but in general right Daphne is for
Daphne programs yeah yeah Tuesday do you
shall awesome nice trick for inferring
programs from specifications yes uh-huh
do you think it is possible to do this
more automatically and I like for
program synthesis yes but I slope right
onto saying them in my Daphne tutorial I
showed some sort of techniques or
heuristics that you can use that you
developed you develop this specific
first and then the program's those work
very nicely for certain examples the I
think that that has inspired my work on
synthesis in fact that is that you could
actually write it in that way and but
the there's much more work to be done
and and those techniques work for
certain kinds of problems where they
work very well and the but I think that
in any case if you have specifications
in in your head even if you don't have a
recipe for how to develop the code
directly from it if you keep in mind the
specifications when you develop the
program you'll be in a much better shape
than if you just code and you don't know
really what you're doing all right thank
you very much or all right one more or
resolve okay thank you very much okay
thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>