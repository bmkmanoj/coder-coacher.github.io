<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Ziria: Wireless Programming for Hardware Dummies - Part 1 | Coder Coacher - Coaching Coders</title><meta content="Ziria: Wireless Programming for Hardware Dummies - Part 1 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Ziria: Wireless Programming for Hardware Dummies - Part 1</b></h2><h5 class="post__date">2016-07-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/s6iyGCa7700" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I have the pleasure of having bazi
dadada Novick who's one of my colleagues
and we've been working together for the
last four years bozidar did his PhD in
epfl Switzerland and then he did a
sports doc in ens Paris oh good yeah
good and then he joined Microsoft
Research and you must have you probably
remember still the solar platform and
how couldn't develop the software
defined radio and he did say that it's
going Boozer is going to make it easier
to program so passe either is going to
talk about this wireless programming
language zaira and i pronounced it right
we were calling it video but material
zero as I owe his idea whatever yet so
this language yeah lets you develop
these wireless protocols and implement
demons of three different radios at a
high level language so I will hand it
over to goes there no thanks for
introduction and thanks for your clothes
keep introducing me and for inviting me
and yeah so this is a kind of gear shift
from Marco change the compilers I hope
you'll enjoy it too it's a summer school
you know she should be diverse you
should hear different things that's what
I was hoping for and then they approved
my kind of general title so there you
are ok so the high level so it's four
hours it's quite a lot of talking so
i'll try to have some demos and examples
i was hoping that maybe you can do some
demos and your laptop's yourself but
actually it's not trivial to install it
in these few hours that I'm here and we
didn't manage to do it before so all
these examples that we will see our
online and I'll basically it was the
website here so the whole thing is open
source you can find it on github there's
link here and i will post these examples
online of everything that i'll present
here and the code so that you can
actually play with it and do the things
yourself afterwards right and maybe even
tonight i'm not sure if i'll put them up
tonight for tomorrow but from there on
ok so this is the ha overview of the
talk so first i'm going to give you an
introduction why
interest in this why do I talk to you
about compilers now when you came here
from Wireless and then I'm going to tell
you about the programming language we
created to facilitate programming
wildlife devices and doing the pool
wirelessly search then a bit about
compilation execution which is very high
level overview from my point of view and
I'm a wireless networking guy not the
compiler guy so I learned lots of
interesting things it was quite exciting
and try to explain you some high-level
things how do we do these things how do
we make it work efficiently and so on
hopefully it's interesting then I'm
going to give you a case study of Wi-Fi
discipline so another thing is I don't
really know what you heard last week
exactly so I know roughly the type title
so i think i heard that you didn't
really discuss the Wi-Fi design so why
fine design is something kind of which
is well known now but i guess maybe not
for everyone here and so i want to
introduce you and give you a brief idea
why Wi-Fi Wi-Fi design and why is it
designed a physical air why is it
designed as it is designed so basically
it's below what you heard in in in the
morning and then allow you to build your
own Wi-Fi change it and you know play
with the physical air hopefully once you
understand these few basic things you
can then go on and explore and build
your own interesting research on the top
of a plane and then some conclusions
right and I'm not yet sure about the
timing so basically I have a lot of
flights so we'll see how it goes feel
free to ask interrupt with questions
anything and then I have some time for
tomorrow to adjust the slides if if if
it's needed right ok so again the first
question I should answer is why this
course why do I talk to you about
languages and compilers so there's lots
of innovation on physical error and mark
design right if you look at the papers
for example in comprehend sees there's
software you find radios which are like
sora you heard about radios you can
program and you can implement your own
algorithms at the very low level so that
you can design different networks right
and the problem here is that modern
physical layers they require high rate
signal processing and radio signal
processing so I guess you heard about it
in Coons talk about Sora but you need to
do receive samples at 40 minutes
40 mega samples a second in order to
achieve the full rate of Wi-Fi so
basically you need to be very very fast
and you get examples and need to think
about carefully about the hardware you
will be using about the programming
methods you'll be using about
optimization and all that and then it
becomes very difficult to for a regular
human and in particular for a young
student who's just emerging in the area
is to kind of understand all these
things right so you need to learn about
signal processing algorithms you need to
learn about networking of the of it but
you also need to know learn how do you
get is harder to work how do you program
in how the optimized so so this so the
first example that was kind of
simplifying this is a new radio which is
a thing which is you have everything in
MATLAB you can implement things you
might let me have C code as well you can
write your waveforms in MATLAB you can
send them you receive another radio you
see what happens and you can really play
only with algorithms in in in MATLAB but
the radio is there a nice link to face
the problem with new radio is that these
things are then slow so you can create
create your form waveform offline you
can send it you can do experiment I
suppose you did something like that in
in warp on you were just doing sending
things receiving and analyzing what is
there but that's the first step if you
want to build the whole platform right
you need to do a real-time thing if you
want to run on the top of it some cool
application TCP whatever it is you need
to do that you know you need to do it
really fast right otherwise the whole
system is different so there are
platforms like sora and warp which are
which a team achieve the processing
requirement which can do it very fast
but then the problem is that it's very
difficult to write code for these
platforms and i'll discuss a little bit
more later and requires lots of
optimization so this is the kind of a
state of the art today and so so in
particular for different hardware
platforms so one example is a cpu
platform bit sora right so you can do
lots of things that cpu the nice thing
it's very programmable so you know you
can write a sikh owed and you can you
kind of all know how to write C code
right so you can write C code in the
matlab code but if you want to write
fast seco then you need to write the
FASTA code using the tricks that
couldn't
was presenting right so you probably
need to care about vectorizing how fast
you know how much you can how are going
to transfer data you will want to trade
look-up tables you want to worry about
cache sizes function inlining lots of
stuff there right so if you really want
to make it respect the thing so it's so
they build this platform on top of it
which you heard about which is kind of
making these things easier to program
but I still find it difficult then I'll
tell you a little bit about why I find
it feel difficult the other sort of
person is FPGA platform how many of you
have programmed their pjs before okay
there's some still right so for those of
you who have you know it's kind of quite
painful painful process and depends
which tools do you use so it's it's
again difficulty to learn how to do
digital design and then from there you
need to move into algorithms and you
need to worry about all sorts of things
that come in interaction of the two and
then the other problem is that
Portability and readability so you know
I'll give you a code which is written
for in Verilog or in for fpga or in
simulating for fpga and you see bunch of
these blocks and you you look at them
and you figure out you're trying to
figure out what they mean right so also
you want to interface this code right so
what is the interface you design in
particular for fpga right you want to
you see the some wires going in and out
but there are many implicit assumption
about clock synchronization and a lot of
things so if you really want to pour
these things it's incredibly difficult
so and it's impossible to pretty much
the move on platform one code from one
platform to the other so you cannot
compare results you cannot reuse some
codes and so on so there are all these
kind of things that it's difficult to
write and reuse code and that that is
the main thing if you look at the
popular open source platform now one of
the reason for such a development of
software engineering and so on is
because you have all these open-source
platforms you can build on you can merge
you can you know improve and you don't
have to do everything from scratch and
right now pretty much in wireless
physical layer design you're still
rather doing everything from scratch so
that's the main problem so I guess I
already told you about the platforms so
there are several other FPGA platforms
like this airblue from MIT where they
actually try to use a different
programming model
relying on a programming language for
fpgas which is high level called blue
speck then but that one is still has
some assumptions about it's difficult to
port there are other cpu based platform
so sorry you heard a lot about it
there's an interesting initiative I
found out about recently is basically
guys that built radios for configurable
radios they produced an open-source PCB
board so an open-source Hardware layout
that allows you to build your own radio
platform interface with their chips and
make this process streamline this
process so doing that there's a lot of
now companies small companies that come
up with on radio so you can buy these
radios for a few hundred dollars so
there's something like new radio but
there's much more diversity different
form factors different newsies lots of
cold so this is interesting from the
harder point of view so from our point
of view of the programming who like to
to be able to program any platform and
ideally you want to write your code once
and you just bought it to any platform
and that's kind of a very high level
goal which we haven't achieved yet and
there lots of details aren't discuss on
the way but we are a step closer there
with this kind of design issues so
basically the thing is you can have lots
of various hardware's you don't want to
be strictly fixed one and you want to be
able to compare results with others and
so on so let me give you a bit more
intuition what's wrong with the current
tools right because if we are designing
a new tool and trying to persuade you
that this is a useful thing so let me go
over the existing tools so for fpgas
obviously you can first use very log in
VHDL and that's kind of a very low level
and also very usually very fixed a
specific fpga you want to target and so
on there's some portable tools these are
commercial ones there lots of research
behind there you can use simulink
LabVIEW which will allow you to write
some code but this is also very this is
not really portable so if you have been
working with a similar thing so if you
if you want a design simulink for
designing the fpga you actually use
islands blocks and you just connect the
wires so it is almost like very low
program
it looks like you know you have some
kind of portable thing but it's not much
portable once you write the code if you
wanted to compile there you have to
write it for signings and you have to
understand digital design there's lots
of the CPU based tools like you heard
about Sora and then new ready and so on
and that's written in C C++ and Python
there's lots of low-level optimization
have to happen there's like control and
data plane separation idea a couple of
projects and this these are research
projects still not really still haven't
picked up too much and there are some
domain-specific languages and I'll tell
you about it what we are doing is
writing a domain-specific language and
this is just a state-of-the-art so none
of this is picked up and I mean I think
I don't want to go into details about
comparing our work with previous works
I'm happy to do it at the end once I
explain you what it is if you're
interested but this is just a kind of a
current layout and up so in high-level
what the issues are is that the
programming assertion is usually tied to
the execution model so you have to
assume something about how you execute
your code and you put in the design and
that's not necessary good if you want to
port it to different platforms if you
optimize your your your performance and
so on then verbose programming you have
to write a lot of code and to write a
simple functions and that becomes quite
difficult and I'll give you more
detailed each one that's in the
following slides there is a state and
low-level optimizations and I'll
illustrate all this example examples in
Sora code and luckily you've seen a
little bit of it so at least you know
what is it all about and again I mean
stopping with questions if I'm too fast
or not not detailed enough in any of
these so so here is a running example of
a Wi-Fi receiver this is a high-level
scheme and I will explain you how Wi-Fi
receiver works in the second part of the
talk and the reason is that I want to
first introduce you the language so we
can actually do some examples and run
the code and see why do we design like
we do so forgive me for not going into
details of these blocks but you can
still ask me questions now if you want
so I'll just give you a high-level
lottery so basically the first thing we
do we take the input samples from the
right
so this is here you can imagine data
coming directly from your radio card
from your analog to digital converter
you get them at the very high high data
rate like 40 megahertz mega samples per
second so 40 mega samples per second in
sora terms each sample is a complex
number of 16 bits each real and
imaginary this is four bytes per sample
so this is hundred forty megabytes per
second right so that's the rate of the
speed of data getting there but I think
could mention that probably so that's
what happens here so then what you do
first you kind of go into tech carrier
you're looking for the packet you're
looking for preamble once you find this
bangle they say okay I plan I'm done the
preamble so I do channel estimation so I
process some header and I figure out
what is in the header and how do I
process it and once I've picked up the
channel then I go and send this channel
info next to the actual receiver but
this part the receiver just receives
header right so it's a first 48 bytes of
a packet which described pretty much
what is in the rest of back so this bit
here has like the channel inversion
which is now using this information to
the inverse channel and explain you why
I have to do this later and then it
decodes header and says oh this packet
is encoded the data rate of 54 mbps sir
so then it sends this information to the
next bit which is then the actual
decoder which is going to decode the
rest of the packet now because the
encoding rate is different we need
different blocks right so so basically
the data comes here going to the tech
area and then kind of moves here and
then every something goes to this bit
and then everything moves here until the
packet is decoded and then you start
receiving there there is a kind of a
flow of information and again I'll
explain this in more details as the top
goes on so the first question to ask
here is if you implement it on a cpu how
do you execute this right so for example
I give you you've received one complex
number so you might do remove this here
on this complex number and you get some
output so what do you do next you send
this complex number here and you execute
this one or you take a new complex
number and put it in here you have a
single CPU for example what would he do
well it's kind of unclear you have to
make a decision right or once you get
this one here do you then ah or if
you're in this line here
do you first go send 11 item all the way
through or you first execute a few here
and then a few here right but then if
you want to execute a few here right you
might be wrong because maybe something
else will happen there which will send
you off so the point of this should be
that you there are two things to specify
here right the first thing I specified
is the functionality so I told you what
I want to do and hopefully that was
clear right you understood where that
has to go and if I give you this and
with bit more details you'll understand
the function ID but that's not enough to
explain how will you program this on a
TPU in say Sora so to do that you need
to actually design a scheduler execution
model how do you execute is on cpu and
currently you write both of these in
your code right so the problem with that
is if you want to change the execution
model you need to rewrite your code and
many places right and that is difficult
because you know for example if you want
to change architecture you want to have
two CPUs or something it's not there are
some things that are easy to answer it
but that's a general problem there is if
you want to change things like that so
the keek one of the question is to
understand how to write is how to define
this execution model ok so the next
thing is it's about state so typically
what what what people do is like well
they design this kind of notion of
vertices in data flow graph so each
vertices s previous lines is processing
some data and sending data further on
and its data gets process and so on now
suppose we want to send some message
which is going back from this node to
this node right when is this message
going to be received in terms of our
execution plan so how is it going to
affect the data you receive it's that
something needs to be defined again
relate to the diffusion plant if I want
to reconfigure a part of the of this so
I want to send a message say ok now
change the data rate right when does
this message arrived does it arrive
while five items are here or maybe 0
items are here do we guarantee reception
and so on and again I'll discuss this
more like later when we have a more
solid define example so why is this
is everything okay yeah okay just like
why this okay so I already said this one
so shared state so so several components
might need to share state right so for
example we might use the same data rate
may have different packet length and so
on so what do we do here so if you look
at this two things can you tell me what
is the stress state it's not that easy
you have to read through all these lines
of code and figure out where it is and
so this is the shared state so you use
this thing here in various pieces of it
there but it's not very obvious what is
the search thing right so if you now
you're worrying if you change a
functionality one component how is this
going to affect the proportionality
another component and also when will you
change it and how is it going to
propagate so unless you understand what
what is the shared state you don't
really know there could be all sorts of
back that pop out there and this is
against general software engineer
problem but here it comes out because of
the all these aggressive optimization
that we need to do anyway so we can't
use any programming tools we have to be
very careful about the performance the
second thing is separation of control
and data flow so this is an example of
Sora code again and so there is like a
reset implementation in one of these
data blocks right and what it does it
actually send something to the next
block right and if you look at this next
one next to next three I mean basically
it needs to know who is downstream and
what to do to the control downstream
whereas if you think of portability of
this code right the block itself
shouldn't know who is it connected to
write if you want to make it portable if
you connect several blocks and you wanna
do to change the order of execution of
lock it has to be at a high level if
it's inside the block you need to
remember it's in the block and you need
to change it when you get to the point
that you're you're reusing it so that's
another example of that of the problem
then there is a verbosity of the code so
one of the problem with them C and C++
is basically the sort of guys and have
this
clever idea of embedding everything in
C++ templates which then allows you a
lot of optimizations to be hidden from
the users site but the problem is that
then because you have to use all the
same plates you need to respect the
syntax of C++ in the templating so
basically all this is just the
definition of a function right so you
have to say there's local context
inherited from these this is read-only
there's another reference love them so
all this is just the finish of which I
mean okay we can do now in one line and
and still you have lots of shared state
is not clear immediately what is it
doing so if you want to do fast
prototyping right as we will do later
you know I will actually write the code
in front of you in three lines if you
don't take this code and do something
like that it would take your days right
because you need to understand what's
there figure out all the bad template
errors that you get and so on so that's
another problem manual optimizations so
basically lots of times you want to be
very quick so you want to write some
look-up tables and I think couldn't
mention that so probably that is look-up
tables this is how they look like right
so you have something which is doing
some creation of some lookup table and
which is supposed to do something which
in standard this is a standard
definition of the thing so dearly what
you want to do if I give you a Wi-Fi
itit 8-11 a standard you want to look at
a standard you want to look at the code
and see that this is equal to death
right and right now from here it's kind
of tricky to understand right what's
going on and i'll show you an example
how we can do that so you do want to
minimize the effort for a programmer
from a standard or from a conceptual
input idea to actually writing it down I
will explain two slides yeah so I'll
exciting two sides just yeah I'll spin
loft yeah I will do this good point but
I think in two slides I have a complete
except it's not example of this one I
just this is here just to say that this
is the deficiency right so another thing
is also vectorization which comes to the
back to the execution model so now it's
beneficial to process items in chunks
right so i might want to have let me see
let's let's go here i might want to get
50 items and do the invert channel
and then pass them here and do decoding
and why do I want to do that because if
I copy from here to here I have less mem
copy then I have a local cache locality
and so on but the problem is how do I
know that I don't what is the size of
this chunk if i take too much data then
i'm not i'm going to use too much data
from top which should have gone to this
other decoder which belong to bucket
right so I don't know how much data i
should process in this block and how
much I should do here and that it's not
a job of programmer to specify there so
a compiler should infer how can it
optimize the code with respecting the
semantics you give here so again I'll
give more details of this later this is
just the kind of their problems and my
own frustration from from my own
experience was that I've implemented
several physical layer algorithms in
FPGA and basically I was always it was
pretty much impossible to reuse them I
pretty much had to almost right from
scratch if I had to use him that in
another design because of all the timing
issues that I guess you that program
their pjs before would understand
because you need to kind of make sure
that all integrates well the integration
of the API is really bad and for sora i
had a problem once i was trying to
create a smaller example from of their
head and i wrote like three blocks in a
row and i spent two hours debugging
which state i haven't i have forgotten
to initialize so nothing works right so
i had to go and try to figure and if you
go and execute the template code you
don't know what it's growing and you're
like I don't understand really this one
of the things i have an inch light i
just took it out of the code poor copy
the subs in my own code and then i took
took me two hours to figure it out so so
I want tools to allow me to write
reusable code and then I want to
incrementally build more complex systems
I build something today and I tomorrow i
add more of it and i reuse and i give it
to you and your ears and so on so that's
the goal of this of this project right
so this is what we designed them we
design this new programming platform
which includes a language and compiler
and so the code is written is high-level
language and you just want to explain
conceptual parts of the design and then
compiler deals with low-level
optimization and ideally we want the
same code to compile on different
platforms and we are not
yet we can do optimizations if you have
multiple cores they have different sizes
of course and so on there's some
flexibility in that but we would like to
target fpgas or DSPs or other platforms
and then the challenges we had to solve
is like design the programming languages
obstruction their intuitive and
expressive so that when you see these
the algorithm of Wi-Fi you see the code
and it looks straight forward you can
understand everything and hopefully I'll
give you a lots of examples I appreciate
you that we are there you can understand
things and then you can design the
official multiplayer compilation schemes
based on these abstractions if i give
you obstructions that are nice to
explain and can give you the PDF right
from from Wi-Fi but you can't really do
much with eating compilation right so it
has to be really efficient in
compilation now this is a general
programming problem right so you can say
everyone would like that whatever your
domain of interest is you want to do
this right now that we are interesting
wireless and so we try to explore the
exploit the special features of wireless
basically which are a large degree of
separation between data and control flow
which doesn't happen in let's say
MapReduce programs right or and then we
want to understand how some of these win
their way they're written we can
actually optimize it because there's
lots of binary operations and so on so
we try to learn no use our knowledge of
the wireless design of the algorithms to
design these obstructions ok so our
choice is domain specific language so
the question for you who knows can you
give me example of some domain-specific
languages have you heard of any ok hints
make or sequel so make you want to make
code right so this is a domain-specific
language sequel as well as a
domain-specific language right you write
queries it's very well made for database
so lots of them there and some of them I
guess you you know right general purpose
coding sequel but you know there's some
of them are more useful some of them are
less useful and the benefits of these
languages is they capture the specifics
of a task so that again which allows
compiler to optimize better so that's
something we will hope to
to get with with with this one so again
why is wireless code special so wireless
is special because there's lots of
single lots of signal processing and
there are lots of signal processing
elements that are predictable so if you
think of Fourier transform so you get a
chunk of data you do some over this
chunk of data and you meet the chunk of
data there is no the processing does not
depend on date right or you take
scrambling clothing decoding will go to
some of these examples later if you're
not familiar but basically there is
there is no controlling their whatever
data I give you you will just do the
same algorithm there's no ifs there is
no no decision based on data and there's
lots of code is like that so we want to
use that and so they will help us
optimizing right because we know this
control flow parts are actually high
level but then there are control floor
elements but they're kind of
distinguished nicely so you can have
rate updation header processing some
kind of lie don't know if you want to
implement things with mixer fine and so
if you look at LT you have odma needs to
decide how to scheduling in these things
so there's lots of you could have lots
of control it's not like a simple strain
streamlined pipelining probe as you'll
see in some of the examples or as you
saw in this this example I gave before
with that with the box connected right
yeah great
true while network I guess they they
have a little bit less a troop demand in
a sense okay if you if you look at CL
processing it's done at 40 mega data
samples per second mega complex numbers
so when you go and do you have to do
lots of signal processing like Fourier
transform lots of real-time analysis in
there whereas the networking classical
networking you do different types of
things do lookups at Heather sighs and
you do it very even faster rate you do
40 gigabits per second right but you do
different types of tasks you don't do
single processing right you do matches
look-up tables for routing tables and so
on right so that's the difference
between networks similar question could
be like what's the difference being this
and multimedia right and again
multimedia has a little bit less control
flow because maybe you don't you know
there is some control flow and I don't
know that well the example if you do
MPEG decoding or encoding right there is
a little bit of rules there but it
doesn't have to be it's not as there's
not as much control for s is in violence
right so if you know if you ask me
whether any other existing language
could be used here I haven't seen anyone
and I have we can discuss it afterwards
once I go through it what are the
benefits of this compared to Pacific
other solutions but in particular for
violet for wired two different types of
braces you do you don't do all this kind
of and I think you might be able to use
this in our solution for wired networks
but i'm not sure if it's you know our
goal is really for this community to
have something that everyone can use and
it's better to be focused i think if you
have a good good target than to go too
far we'll see you later i mean maybe
becomes useful or not to see
other questions
I'll give you loads of examples please
refer I just trying to kind of give a
bit motivation but it's difficult to
illustrate everything straight away
oh there was very much personal so I was
using fpgas and then I moved to Sora and
I had to draw away all my code which was
the first shock and well I knew about it
but I was I was desperate for that
because everything I knew I had to learn
new platform new tools but then he was
also thinking like I write the code now
how do i write it given all my previous
bad experiences with FPGAs how they're
ready to make sure it's portable and so
on and I was talking to one of the
programming languages guys who we happen
to have lost in the building and over
the coffee and he said why don't you
tell me how to program these things
there was very much interaction there
and then we kind of started over there
but it was just my personal realization
that i'm not i don't have anything
suitable for the task and maybe there
was another way I don't know we can
discuss afterwards but I couldn't we I
mean even now when I think back I don't
think there's tool that could do as much
at the moment of the ones I know of as
we can do now and hopefully I appreciate
into that by the end of the top and i'll
give you loads of example of it i'm
starting like examples in a minute so so
okay so this was the the programming
model programming models who kind of
describe this right when i tell you data
goes here and then until we detect
carrier and then it goes here and then
it does John estimation and then it goes
here and then does this thing so this is
a kind of programming model that we want
to describe and again I'll give more
details but I don't want to go I don't
want to give anything else in my code
just this which you can all understand
and agree that is kind of Wi-Fi and then
for example and that comes back to the
to the quick example look-up tables we
had before so this was the example of
the Scrambler where I gave this
impossible code on the previous slide so
this is i triple e to the 11 scrambler
so i'll explain you later with scrambled
eggs i'll do a demo of what you can do
but basically for now this is the simple
state machine okay so this is
initialized to I think all once okay and
this X is a delay element so think of
these all ones so no it can't be all
once one is zero sum there's initialize
do something okay
so what happens is that these guys so
this is a so they just shift as a clock
ticks they shift right so x1 become X 2
becomes X 1 X 3 becomes X 2 X 4 becomes
X 3 and so on right and then X 1 becomes
the sort of x for x x 7 right and so
this is this happens in a loop right
it's a kind of state machine for every
new input and then input whatever input
you send it just gets sword with this
and get out okay so this is what in this
picture define scrambler in Wi-Fi specs
so I just copy paste this from my trip
Lee specification right and then this is
a kind of the way people kind of
sometimes defined they say the first one
becomes the sum of the the zero element
this a seventh and forth right so this
is zero a cold okay so this this is what
we actually right to make it compile so
you basically say this temporary element
is the sword of I hope I didn't put the
wrong picture here maybe it's a
different state machine 6 system yeah it
should have been 0n three maybe I'm no
sorry this is 0 and this is three just
counting the other way around so 0 and 3
that goes there right so this should be
six five four three two one zero sorry
for that I didn't think of that so this
would be X 6 becomes the sore of these
two right so this in this line here
everything else is just shifted by one
and then you saw the input which is X
with temporary and what is X we just
take one input okay we calculate the
output bikes are in these two and then
we emit input why there I don't know if
you're persuaded but basically I'm
thinking I'm saying that this code comes
as close as it gets to this description
in a in a pseudo code or actually this
is the real code that will compile as
compared posed to the other one we had
there as opposed to this this one which
is a kind of lots of which is doing a
lookup table essentially but i'll show
you that later and maybe you heard of me
so so that's part of the part of the
goal
of what we want to achieve and then one
more thing to say before we go in there
to set the expectation right we don't
want to optimize very highly specific
DSP libraries and the reason why we
don't do it is because they're like well
we don't optimize this for example in
Wi-Fi we use FFT and Viterbi decoding
which are written by solar guys we don't
touch them right you could write them
together but the point is that they're
the same blocks used in many standards
so we kind of reuse them and and the
reason is that writing an efficient FFT
is the research area on its own and a
lot of people that did it right so we
can just borrow from these things
they're like CPU efficiency of your
library's FPGA guys that give you these
blocks so while you could integrate that
in here it's kind of orthogonal thing to
write none of these blocks but i'll
point out that we only use these two
blocks in the whole Wi-Fi design which
are kind of out outside blocks which are
highly specialized all the scramblers
inter levers encoders everything else
you see in the code is written by as a
area code and again you could write this
as well but there it's a different kind
of optimization you do there ok so now
give you a flavor of the programming
language so I'll just explain you the
programming language and hopefully
explain you how we can write all these
constructs and I'll go in detail to the
Wi-Fi example and show you what kind of
things we we can extract there and I
mean I guess this is the kind of the key
part to gain better understanding of of
what we can do once you have a little
bit of knowledge of language I won't
give you too many details right so later
if interest you can pick it up but i
think it's generally instructive to see
how you can write these kind of
languages and another thing and another
message I want to give is that actually
it can be useful right if a lot of times
if engineers or designers try to do
something they'll take the existing
things they don't look brother to see if
they can actually improve the tools or
understand if they're better tools they
can use to do things and for me this was
interesting exercise to realize that
actually you spend some time thinking
about the tools and write a good tool
you can make your life much easier in
longer-term and so that's why I want to
give you a bit more details to
give you a net flavor how you can do
that and and then it's not really
impossible right it's actually something
that you can do yourselves as well if
you ever come up with with that kind of
problem so so what's the principle so
now okay now I'm describing zrya
basically language so the whole system
is to part there's a language which
describes what you want to do and
there's a compiler which make sure you
can actually run this efficiently so the
language the design has two layers so
lower layer is actually an imperative
code like see something like see which
is a subset of C and so part of it looks
like MATLAB and so on so we basically
this is something that will compile
relatively easy to any of the platform
so we don't do all the features of C we
kind of take deliberately simplify
things and the reason is we want to use
only operation that can efficiently be
that can be efficiently optimized right
and I'll give you more details on that
and the important thing is you can write
any c function you want and plug it in
so it's very easy right if you miss
something you just write the c function
the problem is this c function might not
be portable then but that's up to you to
decide and you can bring make your own
libraries you can change them and so
this kind of flexibility there but yeah
more on this later now it's just
important to have this kind of and then
the second layer is high layer which is
the kind of forget about this monadic
this is if you're in the PLU like this
term very much nowadays but basically
it's um a language for specifying the
stream processors for specifying these
boxes and controls between boxes and
that allows us to enforce clear
separation between control data flow
watch out which are which is what I kind
of hopefully convey that what we want to
have and again I'm coming into details
now so just to reiterate that bit so so
then we the second part is the runtime
that implements the low-level execution
model and the other thing is also which
is important is that by having this the
way we describe this languages and
you'll see later allows you to do
optimizations again it will come in
in more details in an examples later
okay so this is kind of the first thing
about the product the programming
language itself so we have these boxes
you saw them before and so we are
crossing streams so we have wireless
stream either coming from Mac as lots of
bits that we want to do something with
them and send them in the air or we have
something coming from the air and we
want to convert them somehow and send it
to Mac that's a kind of a setup we think
about and so the most of this thing is
something called stream transformer and
basically you take some input bit some
number of input bits do something on
them and output them like Fourier
transform is a great example you take
let's say 64 complex numbers you
transform in your output 64 or 128
whatever you want and this runs forever
ok so the does the transformer is
something that stays there and forever
does whatever you said it that there is
no controlling it just runs that and
then the other abstraction and the high
level is computer so computer is also
simple it takes input stream and that's
something to the input stream and
outputs but doesn't do that forever it
does it until it wants to finish when he
wants to finish and that's determined by
the code inside then it says I'm done
and also in addition to saying I'm done
it says I have some output to give you
ok whatever it is so one example could
be packet detection right packet
detection I'm getting input stream on
searching for a pattern and and I'm not
outputting anything because I don't care
before I find the pattern i don't want
opportunity so i'm searching for
patterns and once i found the pattern
maybe I give some information like
frequency offset or something right so
that's this is called the computer so
what we argue now is that by combining
these two we can define any control flow
we want and it will satisfy all our
criteria so these are the two blocks
reviews ok so how do we compose these
blocks so there are two types of
compositions there is the vertical arrow
which basically says whatever goes out
of c1 sent to t1 so it's just a simple
thing it's kind of I guess obvious
whatever comes out of here you can put
an F of T and then you can put some
thing else here channel equalizers or
something and everything will go through
it and then the other thing that you can
do is this semi colon which is
horizontal binding control pant binding
and so what it does he says okay once
this guy is done move to that part so
what happens is intuitively how are how
we should execute issues first we go and
put all the data here right and then
once this guy is done then the data will
go this way so you will not go any more
to this one once this guy's done right
and so another interesting thing to
observe is we can actually it's a very
kind of well typed language in the sense
that if you look at this bit like we
have a computer and transformer so if
you put a computer in transformer if a
computer finishes its computing it will
stop and will it will move there so if
you look at the aggregation of this tool
this is type the computer so if you if
you aggregate a computer and respond
where they become a computer because
they can stop if you aggregate two
transformers are vertically they are
still a transformer so they never stop
if you a great the computer semi column
transformer it becomes old transformer
because this thing will never stop this
guy will do will do things eventually
this guy will do things but this guy
will never stop so it will become a
transformer so it's easy to compose
these blocks because once you compose
them they still become the still stay
computers or transformers and they
kindly treated Lee correspond to things
you might want to do in this as we saw
in the previous in the why for example
and i think i'll give you more there
okay so let's see how we do the
Scrambler example that we mentioned
before so this is the example of a
scrambler again as I said this is
wrongly enumerate should be 0 1 2 3 4 5
6 right and the entire Wi-Fi is no it's
a computer because it stops a packet is
yeah you can do it you can make it so
you'll put a repeat around the computer
to make it a proper just 1 i'll show you
that you're right yes you can yeah so
scrambler is a good example of a
transformer it keeps on processing data
so so we showed a little bit what it
does so basically takes in data
input does the things and output so so
this is how we define a computer sorry
the computer so this is the
computational method it's not
necessarily only a computer it's
slightly so if you remember this 22
layer thing there's expressive language
which describes a celite code and
there's this computational language we
describe this control so so this comp
here is from the computational language
it could be either computer or
transformer so sorry for this notational
thing so all in here is a big either
transformer or a computer in this case
it's gonna be a transformer and I'll
tell you why in a bit right so then we
design some variables these are local
variables I mean ok it's similar to what
the programming language you like you
just say ok this is a variable they
would use and it's an array of bits and
then we use this common just suggested
to denote these are bits then you know
you can never raise and you can have a
usual kind of things and this is a local
state for this transformer nobody else
can access it right it's it's valid here
and inside so then ok it has all these
types and can use constants and kind of
usual programming language till now you
have this computer so how do you compose
a computer to create a cover computer
you use other transformers of computers
but you have to start from somewhere
right so we have these basic computer
some transformers that do main stuff and
they're here right so we have ah sorry
we have this this guy is less let's say
we take so what is take take is a
computer so what it does it does it
takes an input from from a stream right
and and puts it in this variable here
and i'll explain you in a second how we
compose them but take for now it's a
special element that takes some stream
and gives it to whoever wanting and put
it in this variable X which is then used
in later then Amit Amit takes this
variable and put it in the stream ok and
I'll explain you again in a second how
that composes and then this do thing is
a way to put in imperative code
imperative code again you can think of C
code or MATLAB code you write whatever
you want in this code so this is our see
like or MATLAB like code that does this
actual
operational bit and its encapsulated so
do makes it list it to become a computer
right so okay this is the matlab
imperative code so let's make this a bit
more clear what with all these computers
in transformers so what I do now I'm
saying this is this all this thing is a
transformer and intuitively a scrambler
is transformed it just does de
scrambling forever just texting zone so
how do we make it to transform so if i
go back to the previous story with these
diagrams how do we compose all that so
here it is so let's start with take okay
so take is a block that takes an input
from a data stream okay it finishes
immediately and it gives its input to
the next guy in a in a par so this is
like inner in this after semi column so
there's a semi column like we said
before so basically these guys takes the
X and give it to do ok so do takes this
X and does any C code you want right so
this is and then it gives it to emit
right and I meet put this back on a data
stream right so inside here x is not a
data stream this is some local variable
that's part and this is essentially how
we decouple control and data flow right
so they the control is basically you
decide where these data goes but inside
this block right you place people take
to get one element in you do something
with it in this imperative code and then
you put it back on data flow so you're
doing data processing inside that the
the whole thing will tell you where data
goes but once you get your data item
right this is here you can do anything
but you don't have to worry about
control flow you cut your data item you
do your f50 you do whatever you want and
then once you're done you give it back
to data flow and you let these blocks
worry about how the control we go and so
on so if you look at this thing so they
stake semicolon which is this kind of
composition do semi column which is this
kind of composition meet this is this
sequence here is a simple set of
computers that perform operation on one
single data item which they take one bit
this is one bit they do oppression one
bit and emit out and all of them can be
composed as a one single computer right
you can see them as a computer now how
do I make it I want this to work forever
I make it a transformer that will work
forever I'll just put a repeat around it
so repeat the special thing that says
I'll just repeat this forever okay and
so I have this repeat on around this so
it's going to do every time this finish
is going to reinitialize reinitialize
and reinitialize and so on so I'm going
to do it again and again so this
hopefully I mean the code I would hope
it sounds like intuitive you know I say
take some day tight and do something in
mid data item and you put into it
forever repeat right now what is
important here is basically to convey to
you how this section can be composed on
these basic settlement we had initially
right everything works in these basic
element and we all treat them as basic
common you don't need to understand what
happens behind them and thinking but
that's how we get this control and data
flow separation and maybe this partially
answers the question but out there'll be
more examples and so how do you write
the whole program to write a code like
this okay and then you say read and
write so read is the input to the whole
thing and so that comes either it's your
radio or and write is maybe your bit
stream sending to IP or maybe it's the
other way around maybe this is going to
be further for the receiver this is
going to be a radio board and this is
going to be IP stack for the transmitter
this is gonna be hype is taking the
radio board and but the nice thing is
now we can play with it we can put file
in there we can put dummy things you
know it's just part of the completely
ultimate I so you can test with inputs
from file we store the inputs and file
test them again change our algorithm you
know we can do lots of nice things and
now back to your question about the
receiver we can say receiver is a
computer that actually is finite the
text a packet receives the whole packet
and ends right but you can put the
repeat around it so every time we have a
packet we dump a packet and then repeat
again so then it becomes a transformer
but intuitively a Wi-Fi receiver is a
computer it gives you a packet yeah
right yes yes yes I'm going to discuss
this this is a very simple it could be
multiple tape so it could be a take off
of an array so and that's precisely
that's one of the optimizations we are
doing now going more details there this
is very yet this is true so this is very
inefficient if you want to compile but
that's how I'll show you then we can
optimize this and that's kind of one of
the examples I go through and show how
that works so so computational language
primitives now that hopefully understand
the basics so so these computational
language natives are this repeat
economic and define the control flow and
there are two groups and formation
computers so these are the Transformers
so perhaps the simplest informer is map
this is something you see in other
languages as well what basically says
this is I give a function which takes
one integer and returns one integer and
then map basically on every input i have
do this function and give it out right
so that's a simple thing this is like
take do emit it's just map now repeat
can be more complex right so repeat you
can take something and say i take and
only if its larger than zero i meet one
you can do whatever you want right as
long as you compose it in the right way
you know maybe count only those are only
those are large interior meet one
whatever you want in repeat it doesn't
have to have regular input a regular out
could be anything you want right so
repeat is more general than map but map
is faster so we'll see how we can
respond then we have computers so useful
computers while so while some thing is
done like for example while crc is large
and zero i searched sorry shouldn't be
in like preamble here while while i
haven't found a preamble search for
preamble so i have this again this is a
control element and my imperative code
is here so here is my data code where I
don't worry about about basically
control much anymore I still could but
it's different way I'll show you again
examples here but here I'm just looking
for data and the control is here right
or if then else so maybe you know I'm
looking at if my rate is a one half my
coding is one-half I lose including one
half otherwise I encoding two over three
right and so these are all control
events this this is the imperative code
it doesn't have to be right here in this
example it is an imported code it could
just be another computer a transformer
or something I did and we also have
taken meat which you see there is a four
as well you can see for repeat 10 times
instead of while pretty much like any
programming language but this is it a
computer level so this is the language
used used to this describe the control
at a high level now expression language
is really poor data processing so this
is the mix of CN matlab there can be a
directly linked to any c function and
you can think of it as pretty much a
subset that we dumped directly in c you
can you can recognize this code i'll
show you some example of you you look at
your code you look at this code i'll say
oh this is it right which is good for
debugging if you usually have bugs in
this despite of code and these are the
data types we support this is just the
basic one so we need these kind of fixed
point arithmetics because fixed-point
arithmetic is what you can do fast so if
you want to do if you want to do
floating point in matlab it's good but
you're never going to do for 2 megabits
per second or mega samples per second so
we also have doubled but you don't want
to use it very often we have structs for
a simpler programming if you know past
complex data structure and they're
erasing arrays are useful because you
can aggregate things as you pointed out
you might take more stuff and i'll show
you later a bit more about examples and
so here is just an example of an
imperative code to demystify it's
nothing special right you can also have
4 loops in imperative code you know if
and then and so on the main difference
is that if you put a for loop and if
loop in imperative code we don't we
don't optimize it really much right we
cannot vectorize you cannot look but
there are things we can we cannot do it
for example you just you do you want to
build some coefficients and you want to
put some numbers in an array right
there's no control loop there it's
really a local operation where you're
filling in an array with something right
and for this algorithm you need the for
loop so it's not control data separation
it's just describing the date algorithm
and there is nothing really of control
there is a local thing if you think of
control but it's just a fall
the phils in something so you can still
use all these things but it's a
different nature right you're expressing
a specific DSP algorithm you're not
doing the connecting the control way and
so and then what is I guess important is
that if we invent this weird c language
you can say oh I don't want to use it
because I can implement this or I don't
have so actually it's really simple
because we dump everything we compile
into C code right so the way to link i
could write my own punctual for example
this is an example of function we wrote
to do SMD subtractions you put two
arrays this is doing c equals a minus B
right and this function is just going to
be compiled into this sequel so as long
as you provide the c function with this
signature everything is compiled two
runs you know you just you're
responsible for that and we wrote lots
of these functions basically we rely on
Sora library soraa has an excellent
library very fast with lots of SMD
operations there 15 better be fixed
point geometry visualization that's
already there so if you get the code
from github you get the links to all
this you need to install solar to use it
but it's linked naturally and you don't
have to do anything just use all these
functions that's what we do for our
Wi-Fi VC so this kind of and you know
you can link your favorite library if
you want later right if you want to move
to new radio I don't know we haven't
done it but you know you can take hold
this library radio and port your code
pretty easily I suppose we haven't done
it but I believe right and any but these
are local things that you have to
optimize for for the for the texture and
we don't do like SMD so SM DS vector
operations in modern CPUs in case you
sound you don't know like SSE
instructions or AMX whatever they call
the ABX so these things in there people
worked on how to vectorize c code
automatically and so on you can rely GCC
and Visual Studio C compiler they do
their job sometimes you can rely on that
you can but this is something we don't
do so we just provide interfaces do you
can put any other optimization one there
right so one way is to put these
libraries for different platforms
different OS these different compilers
yourself or rely on a compiler to do it
or put another tool to do it whatever
you want right this is just an interface
okay so a few frequently asked questions
in a day then I guess we can go for a
break so the first question is why
designing defining a new language why
not for the interactive part of code
I've hopefully I appreciated you and I
mean I'm still going to try to persuade
you in the next three hours that this is
the right way to go but at least the
imperative code is where we write that
these PR which is why don't you see or
MATLAB or something yeah and the reason
is are pretty much opportunistic because
we design it we need to write a compiler
for it right so we don't we're not going
to write a compiler for the full C
because it's very tedious or also for a
full month we try to support the
features we could so that make it work
and I think it's pretty useful never
done I mean we have a rich set of
features and also we can implement the
whole Wi-Fi lots of parts of LT and so
on and and another reason is we want to
make sure we compile efficiently we
don't want to use malloc we don't want
to use recursions and all this stuff
right because if all the recursion maybe
even possible i'm not sure but they're
not fundamental for wireless and then it
will flow down your code so really focus
on the features they will make sure that
we can actually implement all the modern
wife wireless physical layers but
they're still fast and we know how to
compile them fast so that was the key
argument so how do you share state the
answer is we don't share state and then
I think it's not disabled you could but
that's what we try to avoid and all the
code written there is no share state
there's just a shared get a state can be
shared now showing an example explicitly
by passing it around and so other things
we use these are functional language
techniques and it's a kind of more just
in I intuition for an idea about the
function language is not really
important here so we have
yeah actually we do lots of copying and
we do have some penalty of efficiency
but we're still fast enough for Wi-Fi we
we have lots of optimizations to do
there so that's something we haven't
done because it wasn't fundamental as
soon as we saw that we are I don't know
ten twenty percent of Sora and above my
eye we stopped right but there these are
future student projects and so on right
right through but the point is that
there is an interesting trade-off right
so how much do you waste by passing the
state and the reason is if you vectorize
this is all in one so if suppose I'd
person I do a person of 64 elements so I
and then I do a mem copy I amortize it
so much over sixty four months that you
won't even see it often so I'm willing
to pay this penalty but having my
programming model much more clean and
this is an interesting trade-off and we
don't seem big penalty of these things
but it's true diff you have a share
state you still would need to do at
least one copy i guess or a few copies
in our in our in our program and we
don't do we don't completely eliminate
well still to have to explore how much
we can limit but because of the
vectorization everything the performance
hit is low but we actually get much
better where we get matter better
permeability and measure and i think i
have one example right after this too to
illustrate the difference s'okay quickly
this thing so basically this is some
kind of inlining you can doing
functional languages let's keep because
it's not really and then this is another
weird thing that I'm also worrying
myself so why doing this and not this
okay so has anyone programmed Haskell
didn't expect that you have okay good so
they have something like this and
basically this is an immutable state so
basically says exes will not be changed
right and then allows you to avoid
copying because then you know it's not
checking so you can do some tunes ations
I still don't think it's very necessary
but half of my team was a big Hoss big
husky believer so we had to pee
you know I think it's not too bad anyway
so okay so there is the thing about
passing state right and this is a
question for all of you so let's say I'm
not sure you'll be able to answer but
they'll give you a try so let's say we
have this thing is frequency mixing
something with doing some processing no
controlling time they some equalizer and
decoding and then this decoder he
receives inside some new frequency so it
has to send a message here to say a new
reconfiguration message received right
so what you can do it can have a stretch
take which is called new frequency so
when this guy writes to this state then
these guys are real estate and change it
right but we don't allow sophistic and
the reason why argue the state said is
not good is now if I do that right so
the question for you is if this guy
changes by the frequency when will that
change really happen semantically I'm
having the stream right and I'm
executing so maybe I have five elements
here three elements here two elements
here right or maybe I have 002 I don't
know right so it's all down to the
execution model I don't want to specify
that so now you send this message right
so this message has to come when
immediately after the last processing
bit or after three or after five how do
you specify them then say again well I
don't know it's actually kind of ugly
that's a very good very good assumption
so my question is really how would you
do this with the abstractions we
introduced if you still remember them
all without the share state if anyone
has an idea
that's true but the problem is I mean
even if you think of fpga terms this is
a pipeline right an FPGA there'll be
lots of elements inside but it really
depends how you are someone else implant
is equalizer how many elements are in
here they're already screwed because now
you receive this guy and the early you
haven't changed frequency for those guys
so it's not well defined right depends
on your execution water or what you are
implemented here and we don't want that
so how can we we don't allow share state
so how would you do it without share
state with our primitives it's a
difficult question i mean if anyone has
an idea okay i'll give you the solution
so it's not that I mean what if you if
you get experience with so it's
basically just to repeat around these
things right so we do this we do this we
do this and at the end of it this guy is
going to be a computer and this computer
will stop when it receives this tape and
then send it back so now how are we
going to execute it I don't know it
doesn't matter but it's very well
defined right and it's very well defined
in a sense that when this sky finishes
we should change the stage so it means
that at the last element not no elements
should be in here right it's very
well-defined surrounding so we do like
repeat and we say this whole thing
frequency mixing equalizer and decoding
is a big pipeline all the the the the
the parting so there's like these things
are together and the frequency mixing
has a state with no the state is a
parameter new frequency right so when
and this guy will stop when the decoding
returns and the return value is going to
be raped so we assign the new frequency
to read read the new frequency repeat
and now the semantics of our program
tells us there should be no other thing
here so once we receive the last time
and that said decoding and precisely as
you said we don't we should not affect
anything afterwards we first change it
and then take the new element now again
execution model is a different story we
need to make sure this is done
efficiently so in FPGA terms they make
sure there's nothing in pipeline here or
we need to back off and do speculative
execution it's but at least in the
language level it's very clear right and
so that's one of the reasons right
because if you want to do the state
share state and you want to run over
multiple CPUs or FPGAs what happens
right and we don't want the
specification model but we want to we
can write optimal resolution models
afterwards okay and I think this is a
good time for a coffee right switch this
off now
yeah well we had another name which was
a blink and then there was a issue with
them there's another microsoft research
project will blink so we had to clear
the name and it's not easy if you're in
a company to clear a name so this is a
mountain in greece next to place where
my quarter lives so we needed the name
fast so no no yeah no no meaning other
than that if you think of a good meaning
let me know</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>