<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Programming Languages for Life | Coder Coacher - Coaching Coders</title><meta content="Programming Languages for Life - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Programming Languages for Life</b></h2><h5 class="post__date">2016-06-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/vo2-fcFfGYk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
so the title is sort of ambiguous it
could be either programming languages
for life like living systems or it could
be programming languages for life like
life sentence you know with programming
languages and actually both meanings are
intended so I'm going to start with the
very early days of Luca and kind of try
to cover the history of computers and
programming languages from from very
early on when Luca was two years old
that that was that computer was built at
the Weizmann Institute of Science in
1956 actually it's just the part of it
it's another part what's another part
here are a few more parts and that's the
disk and building which was actually the
Weizmann Institute of Science at the
time which had a huge basement and the
entire base basement was filled with
with his computer since then we've seen
two important trends first of all since
Luca was two years old he started slowly
growing up and gaining weight and since
that time computer started the
decreasing in size and weight and I try
to calculate when the two curves crossed
oh when was Lucas wait higher than his
computers and you know what was that
what is the answer I think I figured it
was around when it was 25 or 27 when he
used the lift machine he was still
lighter than his computer but when he
switched to the mac I think Lucas weight
was higher than right so it would your
about 25 26 something like that so for
the first 25 years of Lucas life the
computers were heavier than his the
those that he was aspiring to use okay
that's one bit of important history to
know when Luca was I think a three or
four see ya fortran was invented by john
vikas and his team and when I just look
about fortune his his facial expression
was not extremely positive and I must
admit that when I studied the Fortran
this was my first programming languages
language Luca was luckier his first
programming language was a similar 67 as
he told me so he had a much better early
life than mine I had struggled with
Fortran and I couldn't believe why
people would invent such a and ugly at
least two in my to my aesthetics
construct but things got a bit worse
later you will see any way for those who
are not familiar with how you program in
Portland then you would use these these
devices and the way you would debug you
would feed the card on one end of the
card reader and copy part of it and then
type the part you want to correct and
then press the copy button button for
the rest and that's how you would fix it
if you had an access to such a machine
if you didn't then what you would do you
would feel these coding sheets by hand
and give it to someone else who might
have time to type them for you or not
and then you would the program that's
how you program and and when I was
learning it was in high school so the
debugging cycle time was one week this
the teacher would take the coding sheets
get go to the nearby university that
would type the cards run it it will
bring it next week and that was our
debugging cycle for fortran programs at
the time so the next important milestone
was a couple of years later ah the first
trend of programming language designed
by committee which I think became
extinct after a while anyway that the
look also was exposed to this language
and I I also worked a little bit for to
earn living their programming in Kabul
in I was a sub was an employee of a
subcontractor of bank appalling which is
a big bank in Israel and you know what
the programmer is in bank appalling head
on their desks and he guess nothing they
had nothing under this but you know what
they had behind her desk the head
shelves with boxes like big boxes with
cards in them so every programmer had
this 2000 3000 lines of code which it
was responsible for and it was organized
in boxes big boxes which they would
carry to run or debug or compile to the
computer room and on each box that was a
with a marker a very large diagonal line
anyone knows why they're on why the hell
would they put a diagonal line on the
box luca knows if two programmers bump
into each other in the corridor each
carrying his box with the cards what
happens and the cards fall on the floor
how would they sort him back they just
put him and according to the diagonal
line they would put the cards back in
order so that that's that's the legacy
of kabul programming and in these lines
movie gone i think a revelation for
everyone was was a skull including
myself in in the 1970s where suddenly
you'd see that programming language does
not does not need to be ugly and and for
me it was
even a profound revelation the Turing of
art lecture by john backus in 1978 but
Lucas says that he has been already
converted to ml before that so for him
this was a minor minor event anyway for
me this was a you know seeing that
programming does not have to be
separated from clean you know
intellectual mathematical thinking but
can actually embody it and the examples
in the paper I thought were extremely
fascinating my intellectual environment
my teacher was at the time was a
Marinelli who's a very strong proponent
of imperative programming languages and
he looked at this and said well you know
this is a nice toy but it's not for for
real real programmers in real life and I
think these two camps still the legacy
of these two camps still is still living
today and probably resolved in the in
the future at some point or not I will
not get into this thing but you know
Bacchus repented for for his Fortran
scenes by by offering this Turing of our
lecture but still 35 years later Fortran
still won a Nobel Prize and and these
all these people are really avid Fortran
programmers who still uses water on two
of them are actually uh Weitzman
Institute alumni they they did the the
beginning of the Nobel Prize work they
did at Weitzman with her advisor who was
who died so he was not eligible at the
time for the price but anyway so fortran
still lives on despite of all our
reservations from it and even got a
prize so um what happened next I think
my my intellectual what I should say
that both biologically and academically
look I and I are more or less of the
same age but our paths have
we've gone on on parallel paths actually
surprisingly part I'll show you a couple
of anecdotes in a second for for at
least 2 20 years kind of doing our
minding our own business without
interacting with the other but but
really in parallel and for the last 15
years or a bit less we've been paths
across so it doesn't look exactly like a
chromosome but but still this that's
kind of a depiction of history so I'll
do it fast forward for the first 20
years just to set the stage for for the
main part of the talk which we'll
discuss that the work that we've been
doing in collaboration so so this is
black because these are the said 20
years without Luca said 20 years of my
life without Lukas I'll just say a
couple of things first of all it turns
out that both of us started our PhD work
in AI and are in the AI department or
section and then moved after some
initial for different reasons we moved
to computer science part and we both
finished at the same month on April 82
we both got our PhD in different
continents but the same two and we both
mostly enjoy back music so I think these
are three important facts even though we
were living separate lives you see that
there there are some similarities and
relations so my Luca was doing his
programming language work I started in
the area of inductive inference trying
to work on inductive inference of
theories from facts and but the first
kind of point of almost in interaction
intersection was when I heard of
prologue which was developed by David
Warren Fernando Pereira and Lucas alma
mater I think while it was there in
edinboro and i tried i realized that i
should say that the natural
implementation language for what i was
doing atl at a time both technology wise
and environment wise was lisp but i
couldn't for some
connect to this language and when I
heard the frolic I said ah that's what I
need so I wrote to David Warren and he
replied to me that the only copy of
prologue in the United States the proto
compiler for the duck 20 is in New
Mexico New Mexico Tech and gave me the
name address of the person so I wrote to
him and he sent us these big tapes with
with prologue and we installed it and
apparently forgot to send us the user
manual so whatever I type the prologue
the product interpreter would say no no
it had something else said no as I said
you know what's going on so I said uh I
know what I'll do i typed through and he
said yes actually there's some
intelligence in the machine now we have
to figure this out so after a while we
also got the manual and and I did the
right is this inductive inference system
in Prolog and got sucked into
programming language language research
and wrote the textbook about it and
worked on concurrent programming
concurrent logic programming
collaborated with the Japanese people
these are all happening while Luke I was
doing other things that the great things
that we've heard about in a couple last
couple of days started an Internet
software company that was doing
real-time distributed the instant
messaging in communication in the very
early days of the internet before it was
popular sold it to America Online then
bought it and sold it to IBM and then
while doing this I sort of was trying to
figure out what I want to do it with my
life and I realized that this is not
what I want to do in my life so I went
to the borders bookstore and bought this
thick and heavy book called molecular
biology of the gene and and and started
reading it and and decided that what I
want to do for the rest of my life at
least when next phase of my life is not
to continue with this in their internet
crazy you know world they would manage
well without me but to go back to
weitzman and start something new
research on on on
on something which was not clear
molecular computing after building
computers from molecules so my main my
main interest was was was molecular
computer which is trying to build
molecules from from trying to build
computers from molecules you know when
computer scientists see see see a new
medium medium media he the knee-jerk
reaction is how can I make this compute
so that's that was my knee-jerk reaction
with molecular biology how can I make it
compute and that was my main research
effort and thrust at a time but I had
this side track into molecular
programming had this PhD student a vivir
ago who was formerly a PhD student in
tel aviv but she came to mean say look I
have this idea that I want to use
computer programming languages to
describe molecular systems I said well I
want to use molecular systems to
describe to build computers but you know
let's let's talk and see what happens
and we talked and talked and talked and
and we converge on the idea of using pi
calculus for describing this and the
question is what what how could we make
it work and the I said okay let's look
for my calculus implementation and use
it well turns out we couldn't find
anyone any such and then i remember that
i wrote actually forgot to to show it
but several years before i wrote a paper
before the my internet kind of detour i
wrote a paper on embeddings among
concurrent programming languages which
was my kind of excursion into category
theory and i showed among other things
that pie calculus can be embedded in
concurrent prologue and we did have a
concurrent prologue system you know
collecting dust that at weitzman so I
said okay Pikul clothes can be compiled
to concurrent prologue let's let's write
an implementation of pie calculus in
concurrent prologue and use it and and
we did and lo and behold it worked so
this led to
this initial work of of Eve and
basically the the key insight was that
there is a very natural analogy between
process algebra computational entities
and molecular entities that molecular
species species are analogous to process
species molecular populations the system
of concurrent processes complementary
motif motifs and types are complementary
input and output occurrences on the same
channel and motif occurrence in a molar
in the molecular domain is communication
offers on channels in processes so and
and then all the operational semantics
followed so so really had this very
naive inside that there is very strong
correspondence we should make it work
and we started making it work by writing
examples of code in PI calculus and
debugging it and seeing that it actually
behaves like the molecules that that we
saw and that in molecules we need like
we knew the molecules behaving and you
know we wrote a couple of papers with
the deal Silverman who's the implementer
of the system showing it you can do
various things but it was very clear
that it's really just the first step
that molecular systems are stochastic
and PI calculus is not and we should
have a stochastic version of Pi calculus
so we searched and found that actually
there is the stochastic version of my
calculus by Corrado pre-emmy was here
and somewhere in the discussed it
earlier today is he here I was gone ok
so so I can say what I want about it so
anyway he so we opened the discussion
with him and basically implemented
stochastic calculus on top of concurrent
prologue system we had as an extension
of the pie calculus implementation using
the Gillespie algorithm and try to run
it and it behaved completely bizarre and
then we realized that the stochastic
rules that were in the definition of
stochastic calculus as made by by
corrado were very good for computer
networks but we're completely
are incorrect and useless for molecular
assistance because we want the
probability of interaction among
molecular systems to be a function of
the number of male of molecules in the
system basically and the the original
path calculus a different definition so
we revised it so that it really captures
the classical kind of probabilities of
molecular communication so the
probability increases the more offers
there are four molecules to to interact
in a particular way and we got the
correct behavior and then simulations
and that was really very nice consider
the graphs of virus teens implemented we
were very happy with it um so then I had
the occasion I forget how and why but I
really wanted to visit robin miller and
tell him about what we are doing and
have his insight and feedback and so I
told him that my calculus that is alive
and well and kicking and we actually
used it and showed him all the examples
i think i think i gave the talking is in
his group seminar and it and in our
discussion I said look what's what's
really missing for us now is any some
sort of structure in the pack alko's
like a big soup of molecules and in
biology you have all these compartment
and things are happening locally and
molecules can move from one compartment
to another and all biology is about that
so he said look next door or next
building I forget is a Luca ghirardelli
and he's done this ambient calculus
maybe what he's doing is relevant for to
achieve that so I same building or next
Bentley I remember to cross so I crossed
the street or whatever to the next
building visited Luca and again started
the stock from beginning and they told
him at all about this and about
compartments and I said yeah it's
interesting and I think one of my main
scientific achievements in my scientific
career which I'm most proud of is that
event because I basically sucked one of
the great minds of computer science to
think about biology and and and you've
seen what what happened as a result so
Luca was got interested in more and more
and more and basically this effort
took off and and I'll told it some many
of the consequences you've heard of and
I'll just mention some of them so the
first result was this joint publication
my first paper with Luca from 2002 3
something like that in a bit vague of on
and which became a chapter of Eve Aviv's
thesis and it had their many nice
examples in it many figures of different
molecular systems and that can be nicely
implemented using bio ambience which
included also the PI calculus is a
subset for foreign direct molecular
interaction and also the notion of
compartments and of course we
implemented it and assimilated and we
were very happy with it and what
happened then we've graduated it's this
unfortunate event happens for most
graduate students most PhD students and
left and we had this dilemma you know
what to do with the project I told her I
had enough I run enough large-scale
software development projects in my life
and I'm not willing to have another one
so I'm not going to do what it takes to
make this system for real a really
usable you know programming system with
with this your interface and manuals and
all that she is welcome to do that and
she said nope I want to have another
direction in my career she said it so
explicitly but in practice she she she
went to a postdoc in harvard and
basically told me she's not she wrote up
the papers but did not want to undertake
this as a large-scale software project
for the rest of the curse so this was
just kind of left up in the air and
we're extremely fortunate that the
andrew phillips and luca decided they
wanted to take this forward and
basically the re-implemented the
stochastic calculus on top of the using
their own engine and took a life of its
own and
the is now a robust and usable a
software system that many people can use
and that's a great outcome of this work
basically what happened since and
actually I gave this talk a year ago
almost not knowing that I'm gonna have
this occasion to give it to look I I
basically try to tell the world that
there is this great computer scientist
who is doing amazing things in biology
they should just look at his website so
I think you can probably tell when this
web how late is this web page but it's
somewhere around the year old or 10
months old you can see that Luca has has
really spread his interest on almost any
as many many aspects of computational
biology it's I find it completely
amazing and unbelievable that that he
can do all this this amazing resurgence
in so many different directions and and
the results are are here only on his
website nicely organized and and you can
see that many many different aspects of
biology and computation are addressed by
by his research the list goes on and on
and since since a year 10 months ago and
this snapshot of his website was taken
many many interesting papers more
interesting papers and important papers
emerged including the most recent one
which is really beautiful on the
relationship between structure and
function of circuits which is really I
feel I feel it's a very it's a it's a
really a fundamental piece of science it
will have impact for for many many years
to come so the best for Luca is yet to
come that's what I'm trying to say and I
just want to highlight one paper which
came out i think a year ago gonna or 10
half year last year and and for me this
is personally it's an extremely
gratifying paper because you know at the
time I was working on in two directions
on molecular computing trying to use
computers what molecules to build
computers and molecular programming
trying to
is programming languages to describe
simulate analyze design and molecular
systems and and these are I had two PhD
students working on this I've ever given
called benenson and they were friends
etc but they were completely unrelated
at the time research directions I don't
think they even were referenced each
other's work because they were just on
the face of it unrelated and they both
graduated and continued and this was you
know more than almost a decade ago and
since then these two fields are evolved
and developed and this paper is really
the first paper that kind of merges them
together by bringing Lucas Andrew
Phillips and 13 further developments in
molecular programming on assistance for
describing the behavior of of for
programming languages for describing and
simulating the behavior of molecular
systems and they work on molecular
computing in by some groups led by
George silicon and others and basically
this the the molecular computing people
were trying to build computers so
complicated they couldn't design and
simulated them by hand so they needed
the molecular programming people look I
and Andrew Phillips to help them design
and simulate the molecular computers
that were trying to build so this this
paper is really the culmination of an
important milestone for these two fields
where molecular programming was used to
design and simulate analyze debug
predict the behavior of a molecular
computing system and there is a little
cherry on top because the algorithm the
key algorithm that they were trying to
to implement that they implemented
successfully which is the most
complicated distributed algorithm
implemented using molecular computing is
the approximate majority algorithm has
been discussed earlier today in the
context of the cell cycle switch and the
designer of this algorithm is done Dana
angwin which was actually my PhD advisor
so like it's like all pieces of the
puzzle fell fell in place and it's
really an important and beautiful piece
of work and for me personally it's it's
like a little celebration
okay so that's first chapter of my
collaboration with Luca what time is I
have another 15 minutes that's way so
look as you've seen from his website
look I went on to many many different
directions in biology in computing and
since we've left left my group I didn't
continue personally research on
molecular programming and and my
research interest drifted into other
things on the border of computer science
and biology but you will see again that
the look and I had another interaction
on that so I'll so bear with me for a
few minutes so another project it
started just because we were there and
we were on the board of computer science
and biology was trying to understand
selling edge trees so we all know about
strings you know which bioinformatics
people use to describe the DNA molecules
and why in some important obstruction
and in data structures the next
structure you learn after your length
strings you learn trees so trees are
also important and in particular and
trees can be used to describe the
cellular history of multicellular
organisms so here we see the cellular
history of form called C elegans which
starts like any other multicellular
organism from a fertilized egg and goes
through consecutive cell divisions
binary cell divisions and cell death
until it the organism becomes until any
point in time in this this depicts the
growth of C elegans till maturity and
the rooted labeled binary tree can
capture the this level of abstraction of
cellular of the history of the organism
now many other things can happen of
course and happened during organism
development cells change they interact
with each other all these are abstracted
away and the the cellular tree just
captures the history of which cells were
and how they divided in their topology
and maybe their type etc so science what
science knows the silliness tree of oh I
should say yeah this is the C elegans
now signs know the cellular through a
fun organism this and for more complex
organisms like mice or us science is
still very much in the dark now each
each of you one of the reason is that
the organism is is much more complicated
in large if you really you're walking
self is really the leaves of your silly
nagy tree basically yourselves are the
leaves or selling registry which is 200
which is about 100 trillion nodes big
okay so I hope it's not a shocking news
to to anyone here but each of you
started your life is a single cell as a
fertilized egg which is the result of
the fusion of your mother's egg in your
father's sperm and since then that cell
underwent binary divisions until you
became yourself and God knows selling
registry which is this mathematical
entity which represent your cellular
history and we would like also signs to
know that not just God and the question
is how to do that and my research has
been on that since okay that's just a
structure of the tree I don't think any
disinformation um that's I said and
basically we had we had an insight that
silly nagy trees can be reconstructed
from the noise of the machinery of DNA
replication if you the dog mine biology
is that each of us has a different
genome unique DNA that makes us what we
are specifically but all the cells in
our body have the same genome its
original our unique genome is in this in
all the cells so this is true to a first
approximation and is forced to a second
approximation and the reason it is false
is because DNA is replicated
extremely accurately when cells are cell
division occurs but not absolutely
accurately so there is some leftover
noise in the division process which
every cell care is some some noise which
is unique to that particular cell
division and if we just collect all the
noise all the errors that occurred from
the fertilized egg up through all
divisions up to a certain point in time
for each cell then each cell has a
unique genomic signature has a genomic
signature which is unique to the
organism with extremely high probability
which is just all the errors accumulated
during cell division and of course in
some cases like cancer or immune system
the the mutations are even more profound
but I'm talking about normal normal you
human cells and so that's one thing so
each cell in our body has a unique
identifier it's the this the
accumulation of all mutations from the
fertilized egg unique to that cell and
also the distances the Hamming distance
between these strings if you will really
reflect the distance in the lineage tree
so if two-thirds are our only one
division apart i have a few a few
mutations that separate them if there
are 20 divisions are part i have many
mutations that distinguish between
between them and what we what we showed
in our first paper on this subject is
that the these mutations are a
sufficient to reconstruct the human cell
energy tree with extremely high
precision if we knew them okay so what
does mean if we knew them we let's say a
person donated his or her body to
science after death and we analyze all
the cells in the body so we have to
sequence every cell find the mutations
in every cell and then we could
reconstruct the human cell in each tree
completely so we have about 100 trillion
cells sequencing the whole genome is
about a thousand dollars so for one
person it's a hundred thousand trillion
dollars and we we could have the answer
so that's a that's a bit extreme I think
even for Microsoft's budget so we need
to do other things and basically we I'll
tell you
with what we have done but first maybe
before spending hundred thousand
trillion dollars or even a fraction of
it we should see why we want to do this
and the answer is it many many
fundamental questions in biology and
medicine are about the structure
dynamics and variance of the human
Selena tree and that's I can say this
with I've been in this business in this
kind of around this research question
for more than a decade and I can say it
with ever-growing certainty that if you
go from one field to another of human
biology and medicine people argue about
fight about don't know ask the questions
they don't use this language because
it's a computer scientist language but
what they really ask is about the
structure dynamics and variance of the
human saline industry in just a very
simple example in leukemia we know that
when we treat people with chemotherapy
some of them recover and some of them
seem as look as if they they're cured
and then after a year or two years
suddenly they have leukemia again so the
question is where does this a relapsing
cancer come from and basically the two
possible answers one is it leads like
this that the chemotherapy killed almost
all the cells of the cancer but not all
of them so some escaped and then the new
cancer is just the descendants of this
we see it on on the left here on the
left side of the figure or in other
possibilities like this that maybe
chemotherapy killed all the active
cancer cells so all those that are
dividing quickly and the the distance
from the root really represents the
number of divisions but there are some
other cells that that were not killed by
chemotherapy and the net vehicles are
dividing slowly because chemotherapy
really targets quickly dividing cells
and the new cancer arise Rose new cancer
emerged from from these cells and the
the question is it's a very simple
question what is the case and of course
if we can know the the cancer cell in a
tree we can answer can answer this and
it has major major implications for
therapy because
if it's this if it's this case it means
just give more chemotherapy maybe you'll
kill also these remaining cells just
leave Jack camo therapy should be 10
times stronger 100 times strong to kill
each and every last cell but if it's
this case it means look chemotherapy
killed all the quickly dividing cells
this country started from slowly
dividing cells so no more chemotherapy
will never kill it you should find
something else you should identify these
other sales and kill them as well and
our experiments are really supported the
second case in collaboration with with
Rambam that indeed the cells in the
relapsing cancer or more shallow than
the cells in the primary tumor and
therefore could not be their descendants
logically speaking and we had other
evidence suggesting that they are
closely related to what's called cancer
stem cells which basically is the
property ah that even though they divide
very slowly and or divide rarely they
have the potential to create cancer you
know if they choose to and that's it
this is indeed what happens and
therefore therapy should try to target
also cancer stem cells okay so this is
just a small example why why this is
important and and we've built a system
to try and analyze single cells and
mutations reconstruct i'll i'll skip all
that and we're still building on that
i'll skip on that and we still building
trying to build this pipeline using the
latest technology of microfluidics a
next-generation sequencing that's really
the major project in my lab and i'll
skip that as well and i'll come to my
second paper with luca which basically
arose out of the need to calibrate and
analyze and improve the algorithms ii we
use for saline and reconstruction
because what what are these algorithms
with take mutations from from the leaves
of the tree and try to reconstruct the
lineage tree using phylogenetic standard
fellow genetic algorithms to do that but
how do we know if we're doing well or
not
biology doesn't know the tree so any
tree we say they can live they can
believe it or not believe it or how can
we prove that what we're doing is is is
correct and they're basically two
avenues to do that one is to go to
biological trees that you can
reconstruct that story that you know
exactly the structure is a pity because
you it's it's a true it's it's a system
in biology in Mouse biology or human
biology that people know exactly their
structure for example in colon crypts
it's the case and we were able to show
that to be reconstruct the lineage trees
of colon grits correctly or it's a you
kind of manually growth cells and allow
them divide and separate them in and
have a collection of cells that you know
exactly which selby got which cell and
then take the DNA from them and see
whether you can reconstruct the tree
that you've grown this is very presently
very extremely labor-intensive and in
our first paper from 2005 we did that
and show that we can we can indeed
reconstruct luh trees course selling
arteries but it was a very one example
so what you really want you want a
language it can generate many types of
trees in a programmatic way with
mutations and then computationally and
then take the data from the leaves of
the tree reconstructed three and then
compare the tree that was generated by
your software to the tree that you've
reconstructed so as I said people are
infected with the programming language
bug they see always an opportunity for a
new programming language everywhere they
look so for us it was as well we saw an
opportunity for a new programming
language to language to describe these
these these processes so you know first
of all in these populations you can you
can see you can go for the terminus tech
solution which is you know solving
differential equations roar for
stochastic solution which stimulates
simulates molecular species of the cells
that you have or the entities that you
want and for us it was clear that we
must go the stochastic route because we
want to simulate precisely
what's happening not not solve
differential equations and this is an
example of the top one is a
predator-prey system the bottom one is
just a system that grows up to a limit
and then stays there stochastically or
or deterministically and the first thing
we'll do is let's look at what what
exists and two natural candidates were
chemical reaction networks and
stochastic by calculus now chemical
reaction networks are standard too I
have to finish some chemical reaction
networks are standard tool for for
describing these but they are not good
or skip the long the long justification
whether not good i'll just say that they
are not good because you cannot track
histories and lineages you just have
these anonymous populations of entities
that interact and process algebra odds
are not good because they are too
complicated and unnecessarily detailed
so we really wanted the language which
is much simpler and easy to describe
these these lineages and we looked at
stochastic three grammars which are
basically context-free grammars with
probabilities which is a natural choice
and then the tree structure will just
give us the trees we played with with
these for a while and and we were able
to get you know reasonably reasonably
nice behaviors of stem cell
differentiation etc as you can see from
here these are reminiscent of the things
you get from stochastic by calculus but
you also get the the tree structure
which is very important because you want
to understand that the lineages but the
bad thing about it is that the behavior
of the entities because it's
context-free is very unstable so you can
get you know for in different stochastic
simulations radically different
behaviours of the population which if
you average all of them you will get the
correct behavior but each into each
individual behaviors is highly highly
noisy and unstable so our solution was
to make a little twist to stochastic
grammars and hair
and not change the contrary context-free
nature which makes it them very simple
and elegant to design but add a little
environment component which basically
you allow the probabilities to be cannot
the tree structure to be controlled by
the probabilities and rates to be
controlled by environmental parameters
typically the size of the virus
populations so if you do that you can
see that you can with it with a very
easy twist like here by adding the the
number of of a elements into the
probability you can get a very nice
stochastic control so we still have a
simple context-free grammar for for
either a can either divide or die but
the probability is a function of the
number of A's and if it grows above 100
then the probability of dying increases
and if it goes below 100 the probability
of splitting increases and therefore it
fluctuates very nicely between these two
and basically we took off with this idea
and because I'm out of time I'll just
skip through this showing you that we
wrote in despair this all figures from
this nice paper we published with Luca
we showed that you could you could write
very elegant simple programs for the
behaviors that you want which is really
what programming languages are for and
we have this simulator to execute these
programs and also tools for analytic
further analysis and you get both the
dynamic behavior in terms of process
accounts and also the three structures
and we went through existing models this
is a very powerful paper an optimal
development of crits which had very deep
mathematical analysis and we were able
to capture it very easily in EST geez
and of course the prey predator model is
easily captured then you also get the
lineage trees with bursts of the
population that you can see here here
and what else we did feedback regulation
I'll skip that example it's fairly
complicated implemented added a couple
of slides weather gets the computer
crashed okay so
at the time okay so i'll tell you in
half a minute that was the slides i got
from the email just this morning but i
guess computer question i don't have
them so we now now close the loop and
let me see if i can just live in it do I
have a minute or minute minutes you know
scientists I really want to finish
everything yeah
you should ban consent form that's what
I left Isabelle ok ok so we close the
loop by using this tool finally we have
a tool that we can generate on we can
generate lineage trees on the computer
with various interesting properties
sample randomly cells from them with
mutations that are being constructed
computationally according to known
parameters try to reconstruct the tree
from these mutations and compare the
true that was reconstructed to the to
the tree that was created by the
simulation and I remember why I wanted
to show it because this was an ESTJ
program that I wrote it's the first
program the first program I wrote for
the last 20 years I'm will be proud of
it it's doing this simulation and you
get the trees with nice behavior and
then you can use them and okay so now I
have to go to my other talk because I
have to say something very important
happy birthday look up thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>