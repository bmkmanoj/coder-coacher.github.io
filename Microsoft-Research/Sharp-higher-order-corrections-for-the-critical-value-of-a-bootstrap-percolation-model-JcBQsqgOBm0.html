<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Sharp higher order corrections for the critical value of a bootstrap percolation model | Coder Coacher - Coaching Coders</title><meta content="Sharp higher order corrections for the critical value of a bootstrap percolation model - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Sharp higher order corrections for the critical value of a bootstrap percolation model</b></h2><h5 class="post__date">2016-07-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/JcBQsqgOBm0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
next speaker his name is Tim aschoff he
received his PhD in 2013 under the
supervision of wonder hosted and he's
going to be talking about sharper
thresholds for an anisotropic booster
percolation one thing i forgot to say
that he now works at suppose dr. fella
at UBC and p ims thank you so while that
thing is its own yeah thanks for letting
me speak here today very much appreciate
it I'm going to talk about about
bootstrap percolation indeed this is
this is a project with Hugo do- copper
and iron out fun enter and rob morris
and we I thought it would be a fun topic
to talk about here because it kind of
has its its its its roots may be here a
bit at Microsoft or at UBC I don't
really know where this where this I
think got started but definitely in this
particular area of the world so I
thought it would be fun to sort of talk
about it here so so it's about bootstrap
percolation now I'm sure a lot of you
already know what bootstrap percolation
is it's kind of a common model but for
those of you don't let me just include
you in the conversation as well you
start with some graph let's say it's a
square lattice square lattices are nice
but you can think of other graphs as
well if you want then you pick some
number which is the threshold value and
you pick a set which is just a set of
sites in the graph and let's Center it
around the point 0 and so it can be any
it can be any set of sites you can well
if I write it like this it's it's kind
of hard to see what such what such a set
looks like so I like to draw it as a
little picture so in this case the you
you could take for instance just the
nearest neighbors of zero and circle
their wrappers
zero but you don't have to take this
neighborhood you can you can take other
neighborhoods as well this is one that's
been studied quite a lot it's kind of a
remarkable neighborhood has interesting
properties but the one that I will
mostly be talking about today is is this
neighborhood where you have the nearest
neighbors Plus also to decide the next
nearest neighbors and this is what i
will call an isotropic bootstrap
percolation this model so how does the
model work so once you have these things
chosen the next step is to do a site
percolation where you just take some
parameter P and you infect every site in
the lattice I call it infection some
people call it activating or infection
has a sort of an unpleasant sound to it
but it's hmm yeah especially these days
it's not really like politically correct
to be but I'm going to say the word
infection like a hundred times today I'm
going to say the word log about 500
times today so if nothing else this talk
will at least be that half an hour where
you heard the guys they log about a
million times so so you do a site
percolation and then and then the idea
is just to iterate so any site that is
in fact it remains infected nobody gets
better in this particular scenario and
if you're healthy and one of the guys
you're sitting next to is is is sick
well that might still be okay but if
you're surrounded by them that's not so
great and that's here represented by the
fact that in your neighborhood if you
have more than the more than or equal to
the threshold value of infected sites
around you you become infected yourself
and so this goes for every site this is
the update rule and the idea is just to
update this as often as you like
basically until you find the stationary
or a stable configuration so that's the
description but it maybe it's easier to
see how it goes if you look at it so
I've been working on my computer the the
the grad students at UBC know how how
much effort is to
because I'm super bad with computers
really but I've been making some
pictures and so here for instance are
some initial configurations and I sort
of chosen a couple of interesting ones
so what you're going to see is if we
apply to bootstrap rule then those sites
that have two infected neighbors which
are black in this case will become black
themselves and so indeed you see that
these become black and if you continue
this process at some point you wind up
with a set of infected rectangles and
these are stable because they none of
the sites now that are inactive have
more than two active neighbors if you do
this for a random configuration and the
P is relatively low you indeed see that
this is a that this gives you a
configuration of disjoint rectangles and
if you try and update this any farther
nothing will happen it kind of course
happen that you choose your pee to be
quite high in which case the whole
rectangle gets infected so this is an
actual simulation of such of such a
thing so it doesn't it doesn't look it
doesn't look super informative so my
next attempt was well I kind of stole
this from google but to then color them
according to the time that they became
infected and then you can actually see
what is going on it's um you see that
the blues the blue sites are the ones
that became infected first and then
gradually moving to read those are the
sites that became infected last here i'm
not really doing it on a grid i have
periodic boundary conditions which you
can see if you look at it closely that's
because in the beginning I was not even
smart enough to to simulate things
without periodic boundary conditions now
I know how to do that but so you see
basically you get these blue rectangles
and then they stop growing for a long
time you can tell because they're
surrounded by red things but one of them
actually remained kept growing and ate
up the whole thing and so that's how
this thing became filled up if you go
and you do this on a larger scale well
you might see more than one such thing
oh and they might all grow if you will
reduce be a bit maybe you can bring it
down to the point where there was only
one such cluster that group this is
without periodic boundary conditions so
here you can really see that the corners
of the of the thing are the last to be
filled up so this is the so this is what
I call the standard model it's called
the standard model because basically
ninety percent of all this of all the
people who of all the papers about
bootstrap percolation that's not true
with a lot of papers about bucher
percolation especially in the beginning
we're about this model and it's the most
natural choice obviously so the other
model that has been studied quite
extensively another model that has been
studied quite extensively is the
anisotropic model which I mentioned
earlier and this model has its own
properties and so now you need the
threshold value is 3 so you need 3
infected neighbors but you're given a
slightly bigger neighborhood to choose
that and this neighborhood is not
symmetrical its symmetrical along the
axes but it's not rotation symmetric by
90 degrees like the previous one so you
expect that somehow the growth is going
to also not be symmetrical and indeed
this is of course true so if we do the
update on these things well you see that
the sites that are surrounded by three
there in the upper left corner get
infected immediately you also see that
the diagonal there well there's not
enough sites in the neighborhood of any
point there so that will just remain
stable and if you grow these things one
thing that that is that is noticeable is
that it grows more readily in the
horizontal plane and in the vertical
plane and even the stable configurations
this is stable we cannot update this any
farther does not necessarily consist of
just disjoint rectangles it can have
weird shapes especially upward-facing
and if you do an actual simulation you
see these as well so here for instance
you have this cluster with this big hook
it won't grow any farther than this Adam
you know if you want to study the model
this poses some so minor challenges you
have to sort of think about
how this growth goes in particular what
you need for a rectangle to fill up a
line on the top is that there are at
least two sites close to that rectangle
close to each other while on the sides
you only need a single site to grow
sideways so it's much easier to grow
sideways then upward or downward so here
again you can do simulations and you see
that these that these clusters are
stretched out and if you go to larger
sizes in fact you see that these
clusters are they get more and more
stretched out the fact is that mb in the
horizontal plane this particular model
grows exponentially faster than in the
in the vertical direction that's that's
a feature of this model so people would
call the call this an unbalanced model
for this particular reason okay so one
one feature that is that is fairly easy
to see about about these two models that
I just described for the standard model
but also this holds for the anisotropic
model is that if you take the whole
plane of ZD any any amount of any P
larger than zero will fill it up we call
this internal east and that basically
means that a that will later be a more
relevant statement before a rectangle
internal east and means that if I just
do the site calculation on that
rectangle and it will fill up from the
inside out so without your help from the
outside so that the always fills up
because you always can find somewhere a
small cluster of very dense a dense
cluster that will grow into a seed and
then that thing will keep on growing and
growing it will always encounter
something on its boundary so the the
entire is that d is not interesting but
it is still interesting because what
happens on these smaller lattices is
that you you have the probability of
being internal expand for a rectangle
this actually undergoes something of a
phase transition made a stable phase
transition so if you take
sequence Ln that goes to infinity and
you take a sequence pn that goes to zero
then if the limbs soup this is an old
theorem there's way better ones in case
you're annoyed that I'm showing you
something old but this is an old
theorized Amanda Lebovitz that sort of
got it started they say if the limb soup
of pn x log n is less than some value
lambda minus then this probability goes
to 0 and the limit and if it's and if
the limit is greater than some lambda
plus and the probability goes to 1 so
the question then became of course are
these lambda minus and lambda plus are
they equal and if so what are they well
that was answered mr. Holroyd it's it's
in fact they are equal and this is the
famous result if you know anything about
bootstrap percolation you've seen this
number that it's x squared over 18 yes
so I want to talk a bit about a similar
result for an isotropic for n isotropic
bootstrap percolation to express this
for anisotropic bootstrap percolation
this is not a very nice way of looking
at it so I would rather discuss it as a
I would rather look at p as a function
of L and of course we can do that and so
then if we rephrase this then there
should be some critical value pc which
i'm interested in and it's emily and we
express it as L so in this case pc
should be 1 over log l of order with
this particular pi squared so we can
express it as follows that pc is pi
squared over 18 log l and then there are
some little o of 1 there so this so this
results can also you can obtain a
similar result for for n isotropic
bootstrap percolation and it's almost
the same except now the pc as a log-log
l squared factor there instead of just
that log l and also here are now 10 hugo
have have found the the sharp
our value of this PC and it's 1 over 12
and so here we have essentially a
similar similar result the log log l
squared is interesting though very
recently and I think this is a very very
interesting set of papers and they all
they all appeared in the last well let's
say 12 months maybe a bit more two of
them are still on the archive I believe
only something has become known about
the universality of these models it
turns out that these models can be
roughly grouped into three they can be
grouped into three groups they are
either sub critical critical or super
critical so what does that mean so if
their sub critical then they have some
PC that is always larger than zero the
limits of PC is greater than zero which
basically means that also on set D this
has a non-trivial phase transition and
these are the very the models that have
great difficulty growing so for instance
the threshold value is very high
compared to the neighborhood then you
have the critical ones where PC decays
as some as some negative power of the
log so in the critical case we have both
the standard model and the anisotropic
model they both fit this picture and
then you have the super critical case
where PC goes as some power of l so for
a supercritical model you could for
instance think of a of a standard
bootstrap percolation neighborhood where
threshold is just equal to 1 then if
there were a single site inside of this
rectangle it would fill up so the
probability of finding a single site in
a pc that you would have then is roughly
it's 1 over l squared right so this is
interesting but what is more interesting
maybe is is is the is the third paper
this is my opinion this is quite a
surprising result it's it's again by the
bowl of ash and and and in this case
also who go and and Rob and Paul Smith
this also appeared on the archive quite
recently is that this PC of critical
model
at least in two dimensions can only
really have two forms so either it's the
standard model it's a 1 over log l to
some power kappa ok this bar kappa is
model dependent or it's a log-log l
squared over log l to some power kappa
in which case it's like the anisotropic
model and so basically this allows us to
to put these models into two boxes you
have either the balanced models similar
to the standard model or you have the
unbalanced models similar to the similar
to the anisotropic model and even if you
look at the proofs it really is quite
evident that the the way you should look
at them for the balance models is really
is quite similar to how you should look
at the standard model and for the
unbalanced models it's really quite
similar to how you should look at the
anisotropic model so this makes the
anisotropic model sort of an interesting
toy model to understand an entire class
and similar for standard model of course
so one prasad what is truck what is
quite cool about this result by the way
is that it also contains that third
model over there that third model is
called do AR 2 model after the person
who came up with it and and so far
nobody really knew how to do anything
with it other than with martingale
techniques it's quite unique in that it
was the only model that you could that
people knew how to study with martingale
techniques there are some models some
results that don't rely on those but but
that also fits into this particular
result which is quite interesting
alright so this is one feature of these
models that I wanted to mention there's
another feature which is called the
bootstrap percolation paradox is that
already in the 80s in the late 80s
physicists that simulations of what is
lambda critical right which I mentioned
earlier the PI squared over 18 what it
should be in simulations and they went
too pretty large numbers they really did
a great job especially for that time I
think they mentioned in their paper that
they used a a create computer so I was
curious and this is what a great
computer looks like it's it costs 15
million but you do get a bench with it
so that's you can sit and when you no
wait it's um it's apparently it's a it
has about a 1 mega flop that's that's a
quantity of how fast the computer is
which apparently also according to
wikipedia my playstation is like a
thousand times faster than this thing
but still they went up to to almost
30,000 i don't know how many samples
they did at 30,000 and this and i found
this number that's that's it
oppressively large if you did something
like that for percolation for bond
percolation on set to you would
certainly find the value pc equals
one-half with very good with very good
accuracy except of course that if you if
you know about this this is nowhere near
what the actual value is supposed to be
it's it's it's a x squared over 18 is
much larger twice as large that's weird
and this and this sparked a lot of
interest in in in bootstrap i think also
among computer scientists and physicists
and people talking about it and people
even said you know the Stephen Wolfram
the guy from from Mathematica that he
must be he said so he wrote some book
about how cellular automata could could
solve all the problems in the world and
then people were like no because see
here's bootstrap percolation and it
ended in it and it's awful even though
it's really simple but okay that's not
an explanation of why it is why it is so
so again I'm I'm still going through old
results here but then mr. Grovner and
mr. Holroyd came up with this particular
bound on PC with an undetermined
constant there but still you can see
that there's a that there is a log 3
half and log 3 half of l4l small is
pretty close to just being the log of l
and there's also a lower bound which
they then found together with rob morris
which is which is almost matching so
there's a log-log I'll cube there in the
lower bound the test very small and
according to rob according to his
website at least and I I must admit I
haven't read this paper and he has some
remarks next to it saying that it's it's
a sketch but I believe in because these
smart guide is that is that actually
there is a constant there so so this is
bounded by a constant I should also
mention that in the original paper that
came up with that lower bound they also
discussed it a related model for which
they actually give a precise bound and
that also explains a lot of this of this
stuff away but this this alone maybe you
should want to contrast it to another
result about bootstrap percolation again
for the standard model is that the
window of the transition with a free
good gal I type argument you can show
that it's that it's bounded from above
by log log ll over log square oval which
is much smaller than that correction
term over there for small L you will
agree and so this basically says like
how how sharp is to transition right
that's what this result is about how
fast does this thing go up so if you
sort of act like a physicist and you say
well ok I believe in the naturalness of
numbers or constant should be roughly
the same if they are in the same model
then you can do some some
back-of-the-envelope calculation and you
can see that if i divide this actual
value of PC as I assume it to be just
with the sea replaced by PI squared over
18 if i divide that by the by the first
order term then I'm actually off by
quite a lot i'm off by one over the
square root of log to the power 12 now
log is about a squared so this is about
e to the power 25 so that's about the
square root of 25 so that's about
one-fifth so that's 0.8 alright so this
is off by quite a lot
indeed you can forgive these the those
physicists from the from the late 80s
for having missed this if you draw it as
a picture as I imagined it and I have
drawn it as a picture what you basically
see as you go and draw these curves for
different sizes of L what this what this
p log l is versus the probability of
being internally spend you see that is
this transition gets sharper and sharper
the window gets smaller but the but it
moves very slowly towards the actual
critical value there is a huge gap there
and if you if you were naively saying
like okay I'll go from in factors of 10
you wouldn't you wouldn't see it
converge you would have to like double
the size of your thing every time to get
a nice sequence of graphs that looks
like it actually converges to the right
point so so we thought this was very
interesting and we also thought that the
that the anisotropic model is very well
suited to to do the same thing because
the anisotropic model is like it it
grows very fast horizontally and so we
figured that if there were a correction
terms they would be even way worse than
they would be for bootstrap percolation
the standard model so we did and so here
is the so here's the the main term and
I'm going to unveil to you the
correction term it's log log L times log
log l / 3 log else so it's even the same
it even has the same denominator there
and the log log out and log log log log
L are basically like the same numbers if
L is small so this is really this really
bad but somehow to our surprise it
actually went much better than that we
also found the third term which is log 9
over 2 plus 1 that's 2 and a half let's
say a log-log l / 6 log l so two and a
half over 6 is actually kind of big
compared to 1 over 3 or 1 over 12 a
student of iron out wrote a master's
thesis and she also found for us the
window
this was already a while ago Susan
Berman wrote this down so the window is
the same as for as for the as for the
bootstrap basically there's a cube there
but that's not so important it's much
it's much what a narrower than the
correction term again and watch it's a
bound on the window a big ol we don't I
don't know I didn't read her teachers
but are now tells me that it's correct
so I believe are not so anyway so
there's this so if we write it in a
slightly different way we see that
actually the third up to the three terms
there's only two constants that
determine it so the first two terms only
to rely on the c1 which is 112 and then
there's a c2 in this in the third term
actually c2 is really really small it's
a minus it's a negative number 0.003 too
that's because 8 over 3 is is quite
close to eat actually so this is a very
so so basically this this whole thing
the first three terms almost exclusively
depend on on the first constant and if
we actually start to look now at well
how do these how do the second and third
terms measure up to the first one well
we see some pretty may be expected
results since what we already knew but
the second term is actually bigger than
the first term up until about when L is
10 to the power 20 390 that's a bit
larger than computers can basically deal
with and the third term is also really
large for for computer sizes at least
it's it's bigger than than the second
and bigger than the first as a result
when it's up to 10 to the 13th if we
really want to see these things vanish
well that's not even going to happen
ever because it only vanishes around
where L is like 10 to the 10 to 2 1400
which is according to wolfram alpha is
about a googolplex to the power Google
and then some more so that's numbers
right not no rival companies
and and also the third term is huge
until into a way way way far off so okay
how come how did we manage to find this
still have a couple of minutes to tell
you well the main idea is is that if you
want to know the what is what this what
this critical value is well all you need
to do is find out the probability or
something much smaller to grow large
because once it reaches a certain size
this X by Y which we have to figure out
of course then it will keep on growing
so the probability that it's internally
spanned is basically equal to the
probability that there is such a such a
cluster inside of it which is much
smaller and so basically you just want
treat this like a binomial and you just
say well the density the P should be
such that this l squared over x times y
that's l squared is much larger than x
times y so if you take a large number
and divide it by a smaller number it's a
really large number this L then that's
basically the same as just saying l
squared is and so this is proportional
to the inverse of this probability l
squared is proportional to inverse of
the probability so what we really want
to show is the inverse of the
probability and this is where all the
work goes and here we see that is
probability that x times y is internally
spanned is minus 2 times c 1 over P plus
2 times c2 over p log 1 over P so
there's log square 1 over P in the
correction term is a log 1 over and then
if we take one over the square root of
this of course we get our value of L and
then we can figure out what pc is from
that so if we write it slightly
differently we see that it looks like
this so it's 1 over 6 log square 1 over
P plus 1 over 3 p log 8 over 3 times e
that is just there because I didn't want
to write a minus one third and then a
log 1 over P and if we split this up we
see that this is basically just
depending on two numbers to number three
and the number eight there's also a
number two there but that number two
dozen
do anything that's that's that's
universal for these kind of problems so
where do the three and the eight come
from well the three and eight are just
basically they result from the way this
thing grows so the three comes from the
fact that up to vertical translations
this thing a rectangle will grow to the
sides if it has a site right next to it
a distance one or a distance to sorry
there so this is distance one this is
two distance three so there's three ways
and it will grow vertically if it has a
pair of infected sites right on top of
it and again up two translations there
are basically eight such tight now I'm
cheating because there's not ate such
sites and actually much of the work for
the lower bound this will be fine to
pretend like they're eight but for the
upper bound of course will have to be a
bit careful because it could be that one
of these sites is not yet activated at
the time that we that we get there with
the rectangle and so indeed we can draw
all kinds of annoying things that really
make our life hard like what if these
pairs overlap that's something you have
to bound with the probability it's not
so hard what if they get activated at
some time later than one like that light
gray rectangle over there and we can
have them at arbitrarily large times now
again from a probabilistic point of view
you have to do some work with the
community works this is not so hard but
the problem is at some point is that
they get arbitrarily wide and that is
and that turns out to be really annoying
if you want to be precise about these
things so that's that's for you an
indication of what is hard about this
proof for the rest we just did what
everybody does we just take all the best
ideas from the previous papers about
bootstrap percolation and gobble them
together into something that looks ok
but here's here's where we really had
our work trying to understand how to see
how these things grow so like I
mentioned once we have this particular
bound we can find the critical length
and it is this thing and then from here
on we still want to calculate pc so how
do
does it happen here we have an
expression that only has two constants
and yet we find for pc and expression
that has three terms well this is
actually quite easy all you have to
notice is that there's not one there's
one l but there's three times 1 over P
in there so if we take this particular
critical length and here I'm just
assuming that the second term isn't
there so I could fit this on the slide
for you and so you could read along with
me but if we have just the first term
will get the first two terms of pc quite
easily because pc times log l is now
some function of 1 over pc again log
squared of 1 over pc and if we write
this the other way around we get that 1
over P we can express also in this way
and so we just take the right hand one
and plug it into the left hand one and
what we get is this we expand this out
and what we get here is the c1 so that's
the one over 12 times log log l squared
and now we have a thing that almost
looks like what we need except as
they're they're still a log-log one over
pc there but now we just use again from
the initial bound the Edda on the
critical length that we can do it like
this and so we can just replace that one
over pc by by a log l without paying too
much and then we get the first two terms
of this thing right so I then I went to
simulating because I wanted to see if
now with the you know our formula this
thing actually looks much better I'm so
bad at this stuff that I only came to
500 and then I had to run my computer
for an entire night to get this 500 it's
really embarrassing I if I had known
that this was gonna be so hard I would
have you know it's not hard I'm sure
somebody knows how to do this much
better than I do but anyways I wanted to
get larger numbers but i didn't but for
the poor for the purpose of illustration
these four numbers will still do so what
if we just take the first order term
it's really bad actually it goes up at
the beginning that's never a good sign
if your pc goes up if you're when you
increase the size of your lattice so
actually you can see that at one over at
1 to the power 100 well we still don't
really see convincing numbers there if
you go to the second order term if we
had kept it at that we would have been
even more embarrassed because then I had
to show you just this here they're
almost all negative because the second
term is bigger than the first one like I
earlier explained earlier so then
there's the third order term and well
frankly they don't look so good at 1
million it's 0.06 but I'm almost there
already at 500 so this also is there is
something going on here there are more
terms that we haven't figured out yet so
we can conjecture and actually we're
quite close to proving this I hope we
can make it but I'm not sure that that
actually there's a 1 over P that that's
the third term and if you do that then
you can easily calculate a couple of
extra terms namely two extra terms and
they again are just the same numbers
repeated and so this already looks good
but let's go for a slightly stronger
conjecture which I'm sure we cannot
prove with what we know now but if we
have also the c3 which should exist then
then we can also get the the sixth term
and it's all so big and after this I'm
kind of confident to say that you have
to go to higher orders of log to get
extra terms / log to some power which
could still be big admittedly but if we
have this then with the conjecture at C
3 equals 0 I had to pick some number I
couldn't really make it fit that well
but at C 3 equals 0 this actually looks
kind of encouraging because now at least
the 500 value is it seems to be
somewhere in between the 500 value of
the conjecture and the 500 value and a
thousand value so maybe you know maybe
we can find some way I'm gonna when I
have a student this is the first thing
I'm going to make them do is going to
try and figure out how to simulate this
stuff and then come back to me with what
this c3 could be anyways that's that's I
suppose all I have to say so thank you
for listening
research ya know no questions I suppose
I learn more of a philosophical thing
which is that so you have these amazing
super suppose I'm Helen impressed with
with your calculations because it's
amazing to have this very slowly
converging sequence of terms and to get
it so precisely that's premiered yeah if
it actually starts converging at 10 to
the 10 to the 240 or whatever it was
yeah 2000 way larger than the number of
atoms in universe absolutely yeah
there's no way that ever a computer
could no node can you really speak about
look I I have to say though I think
ander just now had had a number there
that was way bigger still than the
numbers that i showed with the 1 over 2
to the power 2 to the power something so
philosophically speaking i'm not sure
but it's like a fishing here isn't it
intended originally as a physic month
yes yes it was a physics model of course
for a magnetism well you know could
still be a physics model it's just the
finite size effects of this thing are
absolutely overwhelmingly larger than
then then what you would expect them to
be our hope that patient well let's
change the speaker again</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>