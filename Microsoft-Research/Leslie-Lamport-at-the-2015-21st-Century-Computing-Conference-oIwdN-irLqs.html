<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Leslie Lamport at the 2015 21st Century Computing Conference | Coder Coacher - Coaching Coders</title><meta content="Leslie Lamport at the 2015 21st Century Computing Conference - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Leslie Lamport at the 2015 21st Century Computing Conference</b></h2><h5 class="post__date">2015-11-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/oIwdN-irLqs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">let's welcome dr.
okay I don't have much time so I will
start with about the simplest system I
know of a clock simplest digital system
and as a matter of fact I don't even
have time for some real clock I'll
talking about a 1-bit clock so this is
what a 1-bit clock looks like to an
engineer it's a physical system it
represented as voltage as a function of
time if you've studied anything in
physics or anything about the science
you'll see graphs like that its behavior
is described by voltage as a function of
time now what this makes this a digital
system is that we can take an idealized
view of the clocks behavior and we can
pretend that it's not really this little
fuzzy complicated graph of voltage
versus time we can pretend that there
are just two values zero and one and it
switches from one to the other
instantaneously and that's what makes it
a digital system now so we abstract away
continuous voltage I'm also going to
abstract away time because I don't have
the time to get into details about you
know how you worry about whether it's
ticking at the right speed or not i'm
just going to worry about the fact that
it's sticking going from 0 to 1 and 1 20
and back again and so we don't care
exactly when it ticks so we can describe
this system as a sequence as a behavior
as a sequence of states where a state is
just an assignment of values to
variables in this case we just have a
single variable which I'm calling
and now there's a practical method of
specifying sequences of states you do it
by specifying an initial state what the
first state is and state transition how
you go from wed state to the other so
they can be described in lots of ways
for example programming notation hears
you say the initial state and sign v20
and then the state transition can be
represented by this little piece of
program or you can describe it by an
automaton which will look something like
this room a little circle for every
state and arrows telling you how to go
between them and some funny pictures
saying that this is a initial state and
there are all sorts of weird computer
science languages that people have
invented but I was trained as a
mathematician and a scientists so I'm
going to do it in what I think is a
better way math so to specify initial
state what you're specifying is just a
set of states and a state transition is
simply a relation between states now
sets and relations that's the lifeblood
of mathematics so how do we represent
the set of states well represented by a
predicate a formula that tell describes
what the set of states are so a state
and his assignment of values to
variables so a predicate on States is
just a formula containing those
variables so for example here's the
formula describing the initial state
very simple now a relation between
states you can also describe as a
predicate this time not on states but on
pairs of states so the way I'll do it
lots of different ways you can do
it but pretty much one basic way you
have a formula that talks at both about
the old state in the new state and I'll
do it using primed and unprimed
variables where the unprimed variables
describe but the values of the variables
in the first state and the prime
variables are discussing the values in
the second state so here is an example
the value of V in the new state v prime
is equal to the value of its olds in the
old state plus 1 modulo 2 so here it is
described in math so I've described
admittedly a simple system but no
language is no programming languages no
pictures none of that stuff just two
simple formulas what could possibly be
more elegant than that well specifying
it with one formula and to do that I
have to introduce a little bit of
temporal logic a temporal logic formula
is a predicate not on states or on pairs
of states but on behaviors and remember
that a behavior is just a sequence of
states and a state is just an assignment
of values to variables this is all very
simple so a formula like v prime equals
v plus 1 mod to remember that's a
formula that's a predicate on pairs of
states so that formula viewed as a
temporal formula is true on a behavior
if and only if it's true on the first
two states and it was a special case v
equals 0 doesn't have any prime
variables so it's just a predicate on
the first state so it's true on a
behavior if and only if v equals 0 is
true on the first state
and then I'll injured use a single
temporal formula temporal operator the
Box operator and box f is to run a
behavior if and only if F is true on all
suffixes of the behavior including the
behavior itself the behavior is
considered as a suffix of itself so for
example what is box V equals zero
mainland well box V equals zero is true
on a behavior beta if and only if V
equals zero is true on every suffix of a
bit of the behavior but what is it B
will zero me being true on a behavior
mean well it means it's true on a
behavior if and only if it's true in the
first state of the behavior so that's
true if and only if V equals zero is
true on the first state of every suffix
of the behavior well every state of a
behavior is the first state of some
suffix the behavior the suffix that
starts in that state so that's true if
and only if V equals zero is true on
every state of the behavior so this is
all quite simple so instead of what I
will do is take those two formulas and
using this box operator I'll turn them
into a single formula so what does this
mean this formula is true on a behavior
the v equals the conjunction of two
formulas it's true if and only if both
formulas are true so the first formula v
equals zero asserts that v equals 0 in
the first state of the behavior and the
next part the box asserts that v prime
equals v plus 1 mod 2
is true for all successive pairs of
states in the behavior so that describes
exactly what I was saying in words
before it's just one formula okay now
we're ready to get on to something a lot
more complicated twice as complicated
well a two-bit clock okay we start with
a 1 bit clock it's described with the
voltage V and T and we add a low water
bit so it looks something like this but
again this is a digital system so we can
abstract from the actual physical
behavior an idealized view where you
have discrete States so these two
variables V for the high-order bit and W
for the low-order bit all both take the
value only 0 or 1 and so here is the
system behavior starts with in w both 0
then the low-order bit changed then it
changes to zero and the high-order bit
changes and so on does this thing have a
laser oh well
I'll have to point verbally so but if I
give you it a two bit clock and I say
forget about the first low-order bit
well you've got a 1-bit clock I mean if
I tell you to you know hide the second
hand on your clock you have an hour and
minute clock so here's the behavior of
the two bit clock and if I ignore w-well
I now have a 1-bit clock so this should
be a behavior of the one bit clock but
something looks wrong here notice that
we have two states with v equals zero
then two states with v equals one and so
on so how can that be I mean those steps
aren't allowed because those steps say
that every step has to satisfy v prime
equals v plus 1 mod 2 so we've got a
problem and the solution to the problem
is we let the formula allow stuttering
steps steps that don't change V because
after all if the state is describing the
system and the state doesn't change well
nothing has happened so you can't tell
if somebody has you know it just shows
you this one bit of the clock you don't
know that anything is happening that
there's any you know low-order bit
that's changing so the way I do that is
I just change this specification by
allowing this other possibility that
every step either is satisfies V prime
equals V plus 1 mod 2 or it satisfies V
prime equals V and i'm just going to
introduce a little piece of notation
since i'll do that often this little
square bracket with a subscript that
means or
that subscript is unchanged so there's
one problem this specification allows a
behavior that maybe takes a couple of
steps and then does nothing but
stuttering well that represents that's a
clock that stopped you know the high
order that the V hand of the clock
doesn't move it's just stopped and well
that's certainly things that can happen
to a clock but maybe we don't want the
clock to stop and if we don't want the
clock to stop well we add a formula that
forbids stuttering forever now what I'm
doing is writing these describing this
plot with two formulas this first one
which describes what's called safety it
describes the finite behavior of the
clock and I add another formula that
describes liveness which describes the
infinite suffixes of the behavior in
other words another way of looking at it
is the safety part says what's allowed
to happen and the liveness part says
what must happen and for the one bit
clock I could actually write the formula
this way and if you remember that
formula you write down and think about
what that box means and scratch your
head for a while you'll really say see
that it says that it takes infinitely
many steps that change V which says that
it can study forever well I tell you it
would take me about 15 minutes to
explain how to write these liveness
properties in general but I'm not going
to take the time so what I'm going to do
is I'm your only we ignore liveness
safety will is what comes first you
worry generally about safety first first
you make sure that your system doesn't
do anything wrong doesn't produce the
wrong answer then you worry about you
know is that actually going to produce
some answer for later use I'll give a
name to this formula i'll call it clock
now we'll describe another system a
little more interesting one it's a
matter of fact that's a very important
system it's a little hardware signaling
programming called the two-phase
handshake that it was probably singing
you know in several places inside of
your computer and and it processes
communicate using two one bit wires
which i'll call p and c and there are
two processes that i'll call tick and
tock and the initial predicate says that
p and c are both equal to zero call that
I and the next state relation is the
disjunction of two formulas because
there are two possible types of steps
that the system to take a tick step or a
toc step a tick step can be executed
when P equals C and what it does is it
complements p changes it from 120 we're
back again just like a 1-bit clock and
it leaves see unchanged c prime the new
value of C equals the old value and talk
is is similar except a toc step can
happen when p equals C unprimed
variables mean the initial state so a
talk step is one in which he is
different from see in the first state C
is incremented by one mod
2 and p remains unchanged now call that
n and so the handshake protocol is
described by this formula initial
predicate box next state predicates on
that sub PC remember sub PC means n or
PC prime equals PC well priming an
expression just means priming all the
variables in the expression so that's
the same as saying p prime c prime
equals pc and two pairs are equal if and
only each if their components are equal
so that's equivalent to saying p prime
equals P and C prime equals C or in
other words that it's a stuttering step
so what this says is every step is an
end step or it leaves pnc unchanged so
there's the two-phase handshake and if
you work it out you can see there's only
one behavior with no stuttering steps
and looks something like this okay now
I'm going to have mathematical formula
that's one of the wonderful things about
this you can do all sorts of wonderful
things you can compute with it lots of
stuff and what I'm going to do is I'll
define this expression I call it V Bar
and call it t plus seem odd to that will
define it to equal that and then let's
see V Bar is a function of the of the
variables so it has a value in every
state so let's look at the values of V
Bar in all the states of this behavior
well 0 plus 0 mod 2 is 0 1 plus 0 mod 2
is 11 plus 1 mod 2
is to mod 2 which is zero and you can
guess what's happening and in fact the
two phase handshake changes v-bar
exactly the same way that the one bit
clock changes v well we can prove this
wonderful thing about mathematics is you
can you can prove it but first we have
to state it mathematically exactly what
does that mean well let me define clock
bar to be clock that formulas the
specifying the clock except with the
bars substituting for substituted for be
it's a nice thing about mathematical
formula is a very important operation of
mathematics is substitution you can't do
that in programming languages or in
utama dough or stuff like that but it's
mathematics so this is clock bar with
you know clock with v bar substituted
for B and we can substitute the
definition of v bar for V and it it
means this so the saying that the
two-phase that v bar changes the way the
one bit clock changes v that's true of a
behavior if and only if the behavior
satisfies this formula clock bar so the
statement that the two-phase handshake
changes v bar the way the one bit clock
changes v means that every behavior
satisfying the formula HS k satisfies
the formula clock bar or another way of
saying that in mathematics formula HS k
implies clock bar so this statement in
english has this very simple precise
mathematical meaning
and I could take 10 minutes and write a
perfectly rigorous proof of this theorem
now simple rigorous proof sarn't the
goal you know engineers most of you you
know you go out you know work building
systems you're not going to be writing
proofs rigorous proof simple proofs
aren't the goal but they're a sign that
you're doing something right if true if
verifying something as trivial as this
that the handshake protocol implies this
clock protocol you should be pretty
simple and if it's not you're in trouble
so what this formula means is that the
two-phase handshake implements the one
bit clock under this substitution
another way of saying it is you
implementation or refinement or it
refines that statement substitution is
the basic mathematical concept that
underlies implementation when you say
that something implements something else
if really does underneath it there's a
theorem very much like this theorem a
chat highsmith handshake implies clock
bar
there's no notion of substitution in
programming languages try substituting
for X you know in in an assignment
statement X gets something it just
doesn't make any sense you can't
substitute it in an automaton or in most
of these weird computer science
languages that there is a language that
lets you do this it's called TL a plus
for an interesting reasons and this is
how it right the this specification of
the handshake in TL a plus pretty much
writing exactly what i wrote before well
not exactly because mod is written you
know percent in TL a plus and you can't
write P equals C equals zero that's an
abbreviation for two formulas B equals 0
and C equals 0 but that's what you write
it this way and you declare variables
with pnc or variables this imports the
integers module the operations like + +
% aren't built into the language they're
defined in a standard module that you
know gets instead she it gets imported
into almost every specification and then
a little bit of boilerplate and that's
the TLA plus specification of this two
phase handshake protocol well actually
this is the pretty printed version this
is what you actually type you can see
it's not too much different that's all
there is to it for example we're the
type declarations there are no type
declarations have you ever seen type
declarations in any math class types are
in a concept of ordinary you know simple
mathematics
type correctness is actually an easily
prove theorem type correctness means
that P and C are always take the values
0 or 1 and that's this theorem the
theorem that the handshake protocol
implies that it's always the case that p
is an element of the set 0 1 and C is an
element of the set 01 and that's a
trivial probe theorem to prove or Theory
theory trivial theorem for our tools to
check so I obviously only have time to
show you of a toy example but TLA plus
is a real language it's not a toy it has
industrial-strength tools has a model
checker which model checking
exhaustively checks a small instance of
a system and if you've never tried it it
does say doesn't sound very interesting
i've got this thousand processor system
and i can model check it for three
processes but is incredibly effective at
finding bugs because on that three
processor system it checks all possible
behaviors and it has a proof checker
proving correctness of real systems is
almost always going to be too expensive
to be something you one would do in
practice and at this very moment
orbiting this comet whose name I can't
pronounce is the European Space Agency's
Rosetta spacecraft this is a simulation
showing the lander which actually is now
sitting on the surface of the comet
there virtuoso real-time operating
system which controls several the
instruments on rosetta and that was
designed using t la plus and here's what
the
leader of the virtuoso development team
said by the way I knew nothing about a
Miss was obviously going on for 10 years
or something but I just heard about it a
few months ago and i wrote to eric for
house you know asking him about you know
what his experience was and here's what
he wrote he said that the TLA plus
abstraction helped in coming to a much
cleaner architecture and i love this he
said we witnessed firsthand the
brainwashing done by years of c
programming one of the results was that
the code size was about a tenth the size
of a previous version of the system
thanks in very large part to there being
designing and thinking about it in terms
of t la plus t la plus use at amazon
it's being used regularly in system
design in amazon web services as of year
ago ago have been used on 14 real
systems systems that are part of Amazon
Web Services being used daily there's an
article in April's communications of the
ACM that's a very good article that
describes their experience in using t la
plus and other things that they've tried
used t la plus was used it in tell by at
one point by for design groups the my
informant that intel has left intel so i
have no information about what they're
doing now use it microsoft here's what
Dave langworthy Microsoft engineer had
to say he said using simple math that I
learned in high school I found flaws in
my programs that would have been next to
impossible to debug on a live server and
found them years earlier when we still
had plenty of time to fix them
simple math that I learned in high
school arithmetic sets functions and
first-order logic things that you
computer science students should be
learning by the end of his first year at
the University a plus these two thing
Prime and box those are the only two
things in the language that are not
things you learned in your elementary
math courses and as you see they're
pretty simple so a typical system
specification they're typically a little
bit bigger than the two-phase handshake
the but they will have the same form
initial predicate box next state
relation subscript by the set of
variables and aliveness formula the
variables there typically maybe 10
variables but they can have complicated
ver values of a variable maybe an array
of records of of functions of pairs or
something fairly complicated the initial
predicate is typically just a dozen or
so lines of you know very simple math
and the bulk of the specification is
that next state relation I mean it was
about what six lines for the two-phased
handshake it's about a thousand lines of
in a typical industrial spec but it's
still simple math and prime you know
plot you know little arithmetic some
sets notations and stuff like that and
the temporal logic there up to maybe
about 15 lines of temporal formulas very
often engineers don't even bother with
the liveness
because the they feel that the safety
part is the place where there are most
likely to be errors they're most likely
to build a clock that ticks the wrong
number rather than a clock that stops so
this is where the action is that's where
the bulk of the specification and it's
simple math simple math that Dave
langworthy learned in high school
whether you learned it in high school or
university depends on what country are
living in but it's very basic stuff it's
not the rocket science that the Mike his
book spoke about this is really simple
math and first sentence that I omitted
before the day what Dave wrote and these
these quotes are things that Dave wrote
that and other quotations are not ones
that you know I didn't drag it out of
them these are things that they wrote in
some context or other said t la plus
taught me how to think chris Newcomb
former Amazon engineer it's one of the
authors of that paper in communications
of the ACM said t la plus changed how I
think Brandon Batson who is my first
informant at from Intel said the hard
part of learning to write t la plus
specs is learning to think abstractly
with experienced engineers learn how to
do it and he also added and that
improves their system designed learning
to think abstractly well
it really isn't TLA plus that's teaching
them that computer scientists and
engineers believe in this magical power
of languages you know you just write to
get the right language and all the
world's problems are going to be solved
and so when they see you know TLA plus
you know doing some great things for
them they think it's it's because it's a
wonderful language it's not TLA plus you
know I didn't do anything that's
terribly wonderful or brilliant into t
la plus the brilliant thing that I did
was to learn to use meth and what's
really teaching them to flink is
thinking in math rather than programming
languages programming languages don't
teach you to think abstract Lee remember
we witnessed firsthand the brainwashing
done by years of C programming
programming languages are not thinking
teaching you to think abstract Lee now
not all languages or is brain damaging
as C and I don't mean to put down
programming languages programming
languages you know you know are
complicated they're complicated for a
good reason they've got a complicated
job to solve you write programs that are
a lot more than a thousand lines and
your programs that you do write have to
be executed efficiently mathematics
doesn't get executed efficiently it can
get executed in fact by the by the model
checker but but not efficiently and no
language no matter how wonderful the
programming language designer you know
will think you know may tell you that
they're great wonderful none are as
simple and is expressive as elementary
math and you know I can in a very
mathematical sense elementary math is
infinitely more expressive than any pro
gramming language the fundamental
problem facing computer engineers is
complexity and good engineer means
making your systems as simple as
possible and the math needed to describe
computer systems is simple programming
languages are complicated again
complicated for good reasons and I could
you know list a lot of ways which
they're you know complicated things like
objects when you look carefully at them
you know they're really complicated and
if you think that programming you know
some people have this notion that you
know math is complicated programming
languages are simple well the way people
descry explain programming languages by
giving them a semantics they give the
semantics of a programming language in
mathematics nobody has ever tried giving
the semantics to mathematics in terms of
a programming language you wouldn't get
very far programming languages are
complicated and you don't achieve
simplicity by thinking in terms of
complicated languages simplicity
requires thinking abstract ly before you
start implementing and this means
thinking mathematically before you write
any code TLA + teaches you how to think
mathematically because you're using
mathematics to write your specification
few engineers are willing to try they
have years of brainwashing to overcome
and it began with their computer
education in pewter edge of science
education that is somehow convinced them
that programming languages that c is
this wonderfully simple language but
that mathematics is
horribly complicated stuff I mean that's
really backwards mathematical thinking
needs to be taught at universities now I
think I know what students need to learn
and its really fairly simple
understanding a system as a state
machine if you look at the way I
described like the two-phased handshake
initial predicate and next state
relation its describing an abstract
state machine but describing the
statement that students learn to
describe the state machine
mathematically in terms of an initial
predicate and next state relation
because if you look at all of the
different ways of writing or tomato
programming languages touring machines
whatever they're all estate machines can
be described very easily with initial
predicate and next state relation and
thinking of implementation as
substitution because what you're doing
you know if you're implementing
something you know as a list maybe as an
array with pointers or something what
you're really doing is a substitution
exactly the same way that the one bit of
the one bit clock was being implemented
by those two bits of the handshake
protocol you're implementing simpler
mathematical concepts like a list or a
sequence with more complicated objects
which are again can be described
mathematically like arrays and pointers
so that's really all that that
you need to know to understand to start
thinking mathematically about the
system's you're building but I'm not a
teacher so it's people here many of you
will be the next generation or are the
current generations of teachers and you
have to be able to teach them that thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>