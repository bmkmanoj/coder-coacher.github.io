<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Efficient Zero-Knowledge Authenticated Data Structures | Coder Coacher - Coaching Coders</title><meta content="Efficient Zero-Knowledge Authenticated Data Structures - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Efficient Zero-Knowledge Authenticated Data Structures</b></h2><h5 class="post__date">2016-08-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/T1eS4wiCWSo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
right so we're very happy this week to
have s oh gosh visiting us from Brown
University so Brett shesha is a PhD
candidate and she's been working in
intersection of privacy and security and
applied crypto and today she's going to
talk about some of her work on
authenticated data structures and adding
zero knowledge yeah thanks Melissa so
today I'm going to talk about our work
on efficient zero knowledge
authenticated data structures so this is
a brief overview of the talk first I'm
going to tell you why this field of
study is important I'd motivate this
field of study and I'll tell you some
traditional authenticated data
structures that actually do not give you
the support for privacy then I'll give
you first and informal and then build up
the force a formal security definition
that we proposed and finally I'll give
three different constructions for three
different data structures and this
section is completely modular and
finally I'll conclude so so with the
advent of cloud computing a large number
of corporations and individuals
outsource their data and computation to
this untrusted cloud storage or server
it is a very common thing now and since
the data is now the owner who owns the
data is not in physical possession of
the data anymore it is stored on an
untrusted server there is obvious
question of integrity as in that the
data has not been tampered with and it
has been maintained properly but along
with that often third-party providers
are given partial access to this data
which introduces another problem of
privacy so that they have partial access
and partial view of this data but to
prove integrity often this more
information is leaked about the data
than they should learn so this is more
than a theoretical risk because there
have been serious attacks in this so I'm
just going to give you a few motivations
so what is called a zone enumeration
attack it is an attack of d
named result queries where DNS queries
are basically give me the IP address of
some host name and the way the zone
enumeration works is an attacker gets to
know all the IP addresses of a
particular zone all the host names of
particular zone so how does it work so
this the owner of this zone are it
generates first of all let's call this
there are two kind of resolvers primary
name resolvers the secondary resolvers
so when a query comes that give me the
IP address of this particular website
this resolver gives the answer that this
is the correct this is IP address now in
90s early 90s DNS SEC was proposed to
defend against attacker so that you know
that the correct IP address is being
returned these addresses are usually
signed by the trusted owner and then
there is this issue but then there are
zones that are not the queries can come
from were arbitrary website
corresponding to which there is no IP
address in the record so you have to
also prove to the query ER that that
result is not in the database now
proving the positive so there are two
kinds of queries one is positive
membership and other is non membership
or negative membership so proving
positive membership is easy because in
the offline phase the result where can
just sign all the pairs that are in the
law and store it even with an untrusted
server so this setting is very important
because often the authoritative name
servers that administers our zone they
do not they have secondary resolvers for
example if you do an nslookup for brown
dotted you three of the rim resolvers
are owned by brown one is actually owned
by UCSB so what happens is the secondary
resolver can also answer these queries
and they need not be trusted their
secondary resolvers they do not
administer the zone so in the problem
here is how to prove the non-membership
the membership proof is sort of easy you
just sign it offline or the
authoritative name server signs it
offline and the secondary just gives the
signature and that proves membership so
there have been a few ways proposed for
non membership so the most recent one
insect 3 which basically says hash all
the website names generate this hash
values then sort this hash values and
sign every pair okay and store this
record with the secondary resolver now
when a query comes say q.com which is
not in this list of data the proof is
the hash of qcom is computed and let us
say the hash falls between these two
rakaats so it is sufficient to return
this to record sign and that will prove
that that zone is not in the database it
was a proof now what is the problem with
this proof of course there's this
dictionary attack in the zone
enumeration attack so what an attacker
can do is it can take asked many many
arbitrary queries and collect all these
hashes of the zones and then mount an
offline dictionary attack on this so
this is a scenario where privacy is
really important not just integrity
another example is where public audit of
digital yeah yes yeah so why should oh
this is a privacy issue let you are
going to learn all the host names in a
zone that could be a private sleep
preserving thing in itself you might
name know the all the hosts have the
router names and everything and that is
a base to mount more complex attacks no
no you have to learn you have to ask
what is my IP address and then you learn
all the host names in that zone
okay this is the question about digital
records are often subject to audits or
authorized parties or analysts are given
access to it when something malicious
goes on for example the database the
email record of a particular company it
is often stored with a third-party
server and in case of some sort of fishy
activity between certain dates in this
example say this date period authorized
data analyst is given access to records
from within this time period but because
of privacy again here there are again
the requirements are twofold first of
all you need to prove to the analyst
that it this server hasn't tampered with
the messages it is returning the correct
messages that it got from the
organization but also because of privacy
reasons it's necessary not to reveal
anything beyond this time period and the
data and finally this is another example
where XML data is stored as directed
trees so for patient health record for
example and the insurance company might
have access to certain portions of the
tree and to prove integrity you should
not reveal anything beyond that sub tree
wherever it has access this is a
motivating example so this scenarios
motivates the following model okay so
this is a three-party model where there
is a owner a server and clients okay the
owner is a trusted owner of the data set
how many you trust to generate the data
set and give some authentication
information on it now this data is
stored on this untrusted server so this
adversarial model here is that the
server is not trusted to store the data
faithfully all along it might delete
hurt might get committed might get
attacked but this so there is a peru
okay i will come to that later but the
data is stored with the server so the
owner basically generates some sort of
authentication information about this
data set and stores it with the server
it also generates a short succinct
digest of this data second
is it publicly available and then the
owner can store and periodically update
but otherwise owner goes offline from
this scenario now the clients interact
with the server to our asked queries on
the data set and gets responses here the
requirements is that first is integrity
where does the the client never accepts
incorrect answers so whatever the owner
has generated the server cannot give
some other some answer which is
inconsistent with the data store
generated by donor and the privacy
requirement is that the client does not
learn anything beyond the answer of the
query anything else about the data set
yeah so if you are familiar with
traditional authenticated data
structures traditional authenticated
data structures gives you that guarantee
that of integrity that data is not
getting tampered but this proofs are
generally leaks a lot of information so
for example this is a very well-known
data structure Marcos hash tree so when
you prove integrity in Merkel's hash
tree for example you want to prove this
the integrity of element X 2 so the
authentication path are these red nodes
which reviews a lot of information first
of all it reveals the number of records
in the database and if this data data
elements are sorted stored in sorted
order it also reveals the rank of the
element lot of leakage that happens with
the prove that this is indeed in the
database and the way non-membership
proof is proved is if they are ordered
like we just discussed in the hashes you
give to neighboring elements and that
also reveals a lot of information so
this info this is not privacy-preserving
so this is another data structure
authenticated skip list which again
reveals a lot of information this is to
say that the traditional idea says do
not give privacy the zero knowledge
privacy
ok so now I will come to the formal
security definitions so if you have any
questions at that this point could be
good to us ok ok so the algorithm there
are three parties let me set the owner
of the server and the client and there
are three algorithms one is the key
generation algorithm that takes the
security parameter in generates the
secret key and a public key for the
owner now in the setup phase the owner
has its own security takes a database d0
let's say timestamp 0 it generates some
sucks and authentication information the
little orange box that we saw that will
be publicly posted anybody can access
then there is theta 0 which is the
authentication information that it will
store with the server to basically
facilitate answering queries and some
state information internal state
information that it will use if it ever
it wants to update the database so in
the update state it just takes all this
information the database snapshot at
some time I and this is the updates tree
you while which it wants to update on
the database for example if it's a set
maybe it wants to insert a new element
or delete an existing element and it
gives you the updated database the
updated sucks in signature Sigma plus 1
some updates string that the server will
use to update things at its end and
updates its own state information this
one is where this one I don't see theta
that was fun while doing is this oh that
is the service or the server as as of
now has theta I so it will take this
update string and update it at its site
which is this ok it takes that update I
updates the database and the generate
such a type this one now so the server
is responsible for this perform update
and query algorithm this is in Quenya
algorithm it has this Sigma J which is
public information everybody has it has
theta J with corresponding to the
database J and it receives a query
Delta from the client okay and it
generates an answer on the proof so the
rest of the information it has from the
owner only this is the only information
that comes from the client and it
generates a proof for that yeah it
depends on the implementation it could
even have it in its state information so
it just needs to know what was the last
state the database iverson okay and in
the verify phase the client just takes a
public key the Sigma J and the query its
answer in proof and either accepts or
rejects okay so like we already
described the security features are
twofold completeness just means that
correct answers will always be accepted
the soundness is the game that models
the adversarial behavior of the server
so in this game the adversary initially
sees the public key from the Challenger
and it comes up with a database of his
choice holiday 0 it gets the information
that honest Challenger would to an
honest owner would go Sigma 0 and theta
0 and then some polynomial number of
times it asks some update information of
the database and gets the update strings
okay and finally it outputs some answer
which is inconsistent of the database
snapshot j1 as one of those snapshots
through which it is queried and it wins
if the answer is accepted even though
the answer is not correct with respect
to the database okay
so you notice that the server actually
the original scheme protocol the server
doesn't do the updates but this is a
stronger server who can also affect the
updates so even that even when the
updates are adversarial it should not be
able to forge this this one this is the
16 public information about the database
that's public yeah yes exactly yeah
should not be able to learn from so like
what is I don't understand the role of
this Sigma life but public information
it is some sort of sucks in commitment
to the database by the owner so because
the server has to prove correctness with
respect to the original database but it
does not know the original database so
it is consistent with respect to the
sucks and commitment that throne had
generated the very fair doesn't know yes
sir yeah server knows of course here the
very fat doesn't know yes okay no this
is the these are the definitions be
proposed for zero knowledge
authenticated at us this was no formal
study of this and then there is the
privacy definition which models that
versatile behavior of the client of the
verifier so here the client is
adversarial or that verser is we were
modeling the client so the adverts that
he initially sees the it model as it's
either in talking to the challenger or
it is talking to a simulator and it will
succeed if it can tell with
non-negligible probability over half who
is talking to so the idea is the these
views tools should be indistinguishable
to the plan to the adversary so that
verse initially sees the public key
which comes from the Challenger out the
simulator then it comes up with a
database of his choice so adversarial
data
which is sent to the Challenger if it
were talking to the Challenger but
simulator sees nothing about this
database and then it sees this sucks in
Sigma 0 that the owner would generate
simulator also simulates that and shows
it to the adversary and again then that
adversary asks two kinds of queries one
is query wanna is update so if it's asks
a query the it gets from the honest
Challenger dancer in the proof and in
case of the simulator it only has Oracle
access to the database meaning that it
the simulator only receives the answer
to this query with respect to the most
current database from the Oracle and it
general and it simulates the proof so
answer is only part the simulator gets
from the database with its Oracle axis
and this is the part proof that it
simulates then if it is an update query
then the honest Challenger obvious is
the update and it updates this Sigma but
in for the simulator it doesn't see
anything except a valid little bit
meaning is this a valid update on the
current database right for example if
it's on a set is trying to insert
duplicate that's not a valid update so
it only receives a valid it a bit and
assuming is a valid update it gets sick
my plus one in both cases if it's an
invalid update it gets bored not sure
yeah it doesn't need to see the query
also it only needs to see the answer to
that cray yeah it's yet to know the
protocol yeah yeah not in it's just yeah
yeah
ok so that was about the model now I'm
going to move on to the next part of the
talk which is specific instructions for
some specific data structures so the
first these are the three data
structures I try to cover the first one
is very simple it's that membership and
non-membership so this I guess I don't
have to go over this yeah yeah so you
should have to no good afternoon breeze
yes the company verifies yeah well the
Civil international the kind of way yes
but it's already defined by the edit e
the abstract data type on which story
it's producing an answer Balika cancer
it can't stand it's a new medicine has
simulator proof for particular quiz
aight nitrate is a very virus can be
verified okay yeah yeah that's right you
still get the query right yeah okay yeah
i need to get ready and right you know
just not or not the database yeah
okay for set membership it's based on by
linear map the construction so this is
just the notations and so forth
orientation let's say kai is a set of
elements ok this is the data base on the
Edit is so the client queries is an
element X in the set or not in the set
chi or not and the server's response is
a bit which is answered yes it is in the
database or no it is not in the database
and the corresponding proof so those for
a set will first represent it as a
formal polynomial you could write minus
here also it doesn't matter and the
polynomial is called characteristic
polynomial of Chi this is the formal
polynomial and when sorry that's a
product is and when this is evaluated at
a secret point we just denote it like
that that's a value right ok so this is
a construction for the key generation
and the owner so this little red things
denote the number of operations through
population that's going so first you
generate the bilinear public parameters
so take this by linear group g g one we
are doing it as symmetric group the
symmetric value operating the bilinear
map and this is a generator of the group
chief and this is the prime order of the
group so you choose a secret s from ZP
star rammed randomly this notation is to
say it's random and set the secret key
is s in the public he is e to the s and
this parameters it's a bilinear true
yeah
okay now in the setup phase it takes us
the owner again runs this set so the
additional thing it does it chooses a
random are from zippy star which is the
blinding factor really and it says a
sigma 0 g to the are the characteristic
polynomial evaluated at s the secret
point and then theta 0 remember this is
the auxiliary information that is stored
with the server so this is this long
public key which not the public hearing
this tuple and the blinding factor in
the sec sighs anyway the set is towards
so this was not in part and for this
talk let's say the state is the set that
is stores in Kate it needs to update set
later but if you can do other things
like this can also be out sourced and
can use lemarchal tree to just keep the
route to know the state of the side but
for simplicity let's say the state is
the set that its doors ok now the query
part so for the query part the server
has some snack sure of the set hi J sub
theta J and this is the query Delta so
if Delta equal to X is in the set ok
then the answer is 1 and the proof is
this Sigma J to the one over s plus X
which is basically this polynomial so
the server computes this and returns it
as proof
I'm not going to talk about it but this
is a polynomial with it is just a
characteristic polynomial with one
factor missing its degree n minus one
characteristic polynomial but the server
cannot compute it cannot compute this
polynomial and raise g to that but it
has this string GG to the SS square is
to the end so it's just basically raises
it to the correct coefficient and that's
how it computes it he completely
computes if it was not computed earlier
so what was computed earlier was this
without this factor s plus X divided ok
so that is yeah yeah that's what is all
this distance eii you have you it can be
done it a 15 first time and logon yeah
ok and then if the set is not in the set
the way we proof non-membership is think
of the characteristic polynomial of X
plus Z this is a degree one polynomial
rate if the if you are set where only is
the query X then Z plus X will beat
characteristic polynomial now if this is
not in the set then this polynomial and
this polynomial might be co-prime to
each other meaning that it cannot have a
common factor common divisor ok so the
way then this is done is run extended
Euclidean algorithm to generate the
coefficient polynomials the server does
that Q 1 z and Q to Z and what we
actually want to give is G to the q10
and G to the Q to Z that will prove that
its non-member the verifier can check in
exponent using by linear map that these
are co-prime but this is not perfectly
blinding so we have to additionally do
this step of peak of fresh randomness
with the server does and blinds this q1
prime and q 2 prime make it q 1 prime
due to Prime and rich so and this as
non-membership witness so the
non-membership witness is two elements
w2 and w2 yeah
oh because there is this blinding factor
are in the original accumulation you
sort of have to cancel it out to say the
verification goes through so if you yeah
so this is the verification right when
you do the painting you could take that
are off yeah that's all and that the
verification is obviously simple you
just for the membership fitness you plug
that witness right so this this is run
by the client so recall that the client
has this and this from the owner clans
gets this from the server and then it
can compute this part on its own and it
plugs in and checks if this equality
holds for membership and for
non-membership it basically checks that
the extended Euclidean the g series is
one in the exponent so what this give is
G to the Q 1 s into characteristic S
Plus you to the q 2 s into a dress
design it equals 1 in the next one he
said clear so this is the equation that
you want to check in the exponent right
so yeah and this gamma factors are set
accordingly so that they cancel out in
the exponent and you can verify this and
the update algorithm is also really
simple that's done by the owner so if a
new element is added to the set it just
refreshes the Sigma I with this new
factor and blinds it with a fresh
randomness so it's like S Plus let's say
X was not in the set earlier and it's
adding this new element to the set the
owner so the owner takes the old digest
and raises it is plus X some are prime
the fresh randomness for non-membership
witness it if it Tyga wants to delete
something it just takes off that spawn
from
that's all that's out date yeah and
perform update is very simple just
refreshing with this new our prime on
the server's end and the Sigma
the server needs our prior are in our
prime ears because the earlier one was
just are now you have blinded with fresh
randomness our prime so now the yeah
randomness that is in the exponent is
our prime uh well yes and he I fan prime
is larger it ever grows it takes one
more factor right yes exactly yes it's
in the new PG stream yes yeah yeah I'm
not going to prove it here but the proof
is based on and strong by linear
different mine assumption which
basically says for a ppt adversary who
has access to this public parameters it
is hard to invert in the exponent that's
what the proof is based on citation okay
now we're on to the next part yeah oh my
zero knowledge is because every part
that the client sees has a proper
blinding factor so what does the clients
it sees the public key but beyond that
whatever it sees about the database that
the succinct sigma that it says has his
blindness in its exponent and the way we
constructed the proof every proof also
has a sorry yeah every proof also has
randomness
if you see different proofs from this
side yeah it will be the same are but
it's that correlation is already known
to the client right I mean you are not
trying to hide in there is no unlink
ability property not trying to say that
it is not from the same database
if you should get is exactly the one no
it's just a randomness thing yeah it's
not gardens so I have similar somnus
proof for the cereal signature we are so
yeah so yeah so the simulator can just
pick any randomness and say gee to the r
is the sigma right and whatever proof
comes yeah it just divided yes at the
beginning yeah yeah exactly and these
witnesses who can generate with respect
to the initial randomness are you picked
random hard times just one run yeah yeah
and then and then I just divide it when
we wanted sorry every citizen that that
would be the only thing that satisfies
verification fake signal is only one
there's one only one degree of freedom
yes yes exactly yeah
okay so for the next part I'm going to
talk about range queries and here the
problem is the data store is a key value
pair store okay so keys are from a
totally ordered universe and the client
query is basically return all the values
who skis live within some range a to b
and the server responses the answer
which is a correct key value pairs along
with the proof that this answer is
complete that all the elements that it
had to turn where it is really in the
database and it has not omitted anything
like an example this is actually from
the Enron email data set on which Iran
experiments for this way so you can
think of this as the date or timestamp
and this is the mail ID so if you think
of the database there are many possible
time stamps and in some x times the data
there are males are those are empty
nothing is in there so this is basically
your range and the domain set 0 to 15
and some of this is the data store which
are the 6 records as you can see the 6
records are present so only these keys
are present in the data set and rest of
the keys are not present in the data set
so let's try to see how we could think
of a simple solution in this case do you
have any question ok ok so the world one
way to prove this could be that mean
ecially what we were talking about this
idea we have already revisited a bunch
of times so the key value pairs that are
present in the database could be signed
by the owner and to prove that the
things are not present the owner could
also sign the adjacent pairs right of
the keys that are present so 1 p-1
signature could be 401 the keys that are
present and this pair and then this pair
and so on so to prove that something is
not in the database you can give the
corresponding the server can provide the
corresponding signature
but this obviously violate privacy okay
now there is an attempt to that you
could think of like by not from the
solution we saw in part one why not
accumulate the elements the owner may be
computes a zero knowledge accumulation
of the elements that are present in the
data set and then when a query comes the
owner proves in zero the server proves
that these are members of the database
the owner had accumulated and to prove
that there are no elements it proves
non-membership in zero knowledge using
the accumulator but the problem here is
this range could be too long
corresponding to the number of query
data sets in the database so for example
if the key in this case is a four bit
string there are two to the help or two
to the four possible keys but only a
very few are present in the data set
usually so if you want to prove
non-membership you have to do so much
more gift to touch every possible
element that's not in the data set so
that's not a viable solution so let's
see what we can do that this idea that
we use was of hierarchical identity
based encryption okay so the idea here
is anyone can encrypt messages for users
using their public IDs and the users
will be able to decrypt only if it
possesses the correct secret key okay
and this I'm going to tell so implicitly
you can think of a hierarchy as a binary
radix tree where the root is empty and
the left child is marked with a zero and
the right child is marked with a one
like this rad extreme okay so if the
idea at level cake an issue secret kids
for his descendant ideas but nothing
beyond that so if somebody has a secret
key for this ID it will be able to
generate secret keys for every ID that's
below it or it's in that sub tree but
not be able to generate anything outside
that sub tree so that is if a message is
encrypted with the ID of 0000 can itself
decrypt it or it can generate secret
keys for any descendant who can decrypt
it but nobody else will be able to
recruit ok ok so now the idea now we are
back to our range queries so think of
the database that we were initially
thinking of ok now these key value pairs
are present in the data set and the rest
of them are not present in the data set
so think of this implicit radix tree and
delete all the leaf to root paths for
these keys that are present in the data
set ok so end up with a forest which has
basically this orange nodes ok so what
the owner does is the owner generates
signature for all the key value pairs
that are present in the data set and
sets up a hierarchical identity based
encryption schemes of that height of in
this case for bit of line length 4 and
it generates this secret keys for the
roots of this forest this is the setup
phase and these are stored with the
server now when a query comes let's say
the queries for 214 that's the client
query face the owner for the server
first returns this deep yellow key value
signature pairs those are the databases
that are present in the data set so it
returns this to the clients ok and for
the non membership we have to first
let's look at this idea of canonical
covering for arrange what does it mean
for a canonical covering for a range
from with respect to a tree of certain
height sale so the canonical covering is
basically a bunch of nodes in the tree
which
is the following properties first is
that every node is a descendant of one
of the nodes in the canonical covering
and the second is every nodes leftmost
child and rightmost child falls
completely within that range and this of
given height of course given a tree and
arranged this covering is unique so in
this example if 4 to 14 is my queried
range this is the canonical covering the
roots of this forest basically this one
and this one and this one okay now since
this is unique the client can compute it
on itself right now the client computed
on itself and it also has got the
signatures of the elements that are
present in the data set so it computes
is canonical covering and deletes those
parts from this forest the red path
until it's so it's left with this forest
the blue forest now the client takes
random messages and encrypts them with
these IDs the blue IDs and sends it to
the server notice that because of the
way the setup was done the server either
possesses all of this corresponding
secret case or it is able to derive the
securities for example in this case no
recall that the server did not have the
secret key for this one but it has a
secret key for its prefix so it can
generate the secret key for this and
then it's able to decrypt it so if
you're able to decrypt it you can send
it back and if they match the client
accepts so that's the end you can
replace it with the signature
hierarchical identity by signature
instead of encryption and that's the
complexity yeah this is a comparison
with the previous work so the only
previous work known for this was from I
car 2004 she was a long time ago
ostrovsky Rock event Smith and that was
a stateful algorithm it was very
inefficient with generic proofs of zero
knowledge
okay okay so yeah and the security is
based on the unfortunate e of the sorry
this is not agree gets in nature of the
signature scheme and the high-security
yeah and I have five minutes okay so the
last part of the talk is order queries
on lists so here L is a linearly ordered
list of elements set of elements and our
order query is a pair from the set and
the answer is x and y v arranged
according to their order in the list and
the proof of powder okay and we will use
aggregate signature for this game but if
you know this I am going to skip the
slide ok so the aggregate signature is
this idea of given signatures or n
distinct messages by n distinct users
you can generate a short succinct
signature Sigma so given the signature
and the public keys and the messages the
client can be convinced that they were
already in deed signed by the corrector
users and the seeker we will use a
special case of a single cider instead
of 10 different signers for end messages
will use a special case of four single
signer and it is valid only if they
aggregate it used all of the Sigma's as
a security of their rivet signature it
cannot give you a spurious signature and
aggregated along with other signatures
ok no no no it's just yeah it's just a
severe what do you use this so I have
talked about this ok now for the list
construction so what is the basic idea
of the list construction which is that
for every element in the list we are
going to associate a member witness with
it maybe the picture is better so if you
have this set X 1 to X 4 for every
element there is a member witness which
is some line 8 version of the
information of its rank in that set and
the element itself ok
now the owner will initially generate
this list identifier to say that this is
unique for the list it will generate a
member witness for every element in the
list and sign them individually okay and
aggregate them to form the list
signature and this will be stored with
the server and the Sigma that sucks in
Sigma that the owner publishes is its
public key and this list as a signature
yes okay so this is simple how is this
done to secret keys are chosen the
public is just cheated away and the
public parameter the sleep okay ya think
i'm going to skip this for the sake of
time but the basic idea is this so you
pick fresh randomness for every element
in the set and then compute this member
witness as G to the S to the I into R I
ok
I mean this is a bilinear public EG to
the SS square as to the end so this I
index is encoding the rank so for the IH
element the owner computes member
witness as due to this to the I into
this randomness are blind randomness
then it signs it hashes and science this
ok these are all signed together to form
this sub same signature which is the
agree good signature and then this Sigma
L is basically all this member witness
Sigma I and the salt this this
information is stored with the server
the authentication information that's
stored with the server ok now in a query
comes the order queries to actually
prove that some element proceed another
X precedes why these order witnesses are
computed by the server online these are
not computed by donor so the only work
the owner did is proportional to n list
size that sir now this order queries are
actually computed this is this is to
prove that it is a part of that list so
it initially the server generates a
signature for the queried elements only
this is because with the homomorphic
nature of aggregate signature ok and
some verification info which I'm going
to skip for the sake of time but it this
part essentially proves that this
signature and this two together forms
you gives you the list digest signature
it proves it's a part of the list and
order witness is more interesting so the
order witness that is computed is
computed basically it's a blinded
version of the distance between these
two elements
which is computed as follows let the
element drank bi Prime and I double
prime of the queried elements and the
distance that between them is i prime
minus i double prime then the way it is
computed is G to the S to the D this is
the distance right between element 1 and
2 ok notice that the server has this
from its publicly but it has this whole
big tube will do to their sup twist to
that so this into r1 into our to the
corresponding randomness that the server
the owner had originally used to compute
the member weaknesses sorry oh it was
even in server yes yes yes and then it
just generates those order witnesses so
the verification is first verified this
digest signature is correct and then
this is the verification is actually
yeah ok so this is the idea of the
verification so remember the member
witness encoded the rank information in
a blinded way so the client in a blind
adverse fashion checks this equation
basically that rank of x1 when the
queries are x1 and x3 checks the rank of
x1 plus the distance equals the rank of
x3 so that's just the check so this is
the order witness at the owner the
servite computed these are the two
member witnesses that were computed by
the owner that it had got and it
verifies at this equation accepts
say mrs. online storefronts yes on their
students so again the degree of freedom
is one here yeah this is a complexity
which is really proportional to dancer
size optimal whatever is answer sighs
the client does work proportional to
that it's like really no more work and
the proof is based on this and by linear
difficult many inversion assumption so
the intuition is that the server had to
cheat it had to compute one over s e-g
raised to the 1 over s and therefore it
cannot while computing the order witness
that's the reason it cannot cheat of
course I unfortunate e of the signature
along with that and finally okay so this
is a static construction so we have a
dynamic construction over this which is
from this verse sure the observation
that even though this construction used
rank information we really did not need
the rank what we need is something that
respects the rank order that you could
use another mapping to a larger domain
instead of 123 you could say five a 12
so that idea gives there is this well
study data structure called order data
structure that helps you maintain these
tags when the tags are coming online so
we use this data structure to make this
dynamic your privacy is already yeah and
that's it the conclusion was that we
initiated this study of privacy
preserving authenticated data structures
and the real takeaway from this work is
really privacy and security along with
efficiency that has been the major
motivation of this line of work and
these are the papers i talked about
portions from this paper all are
available on ePrint and of course you're
welcome to talk to me about them and
thank you
the first one that said the construction
hides the size of this yes so if you
were to relax it say okay with making
that like these originals in college
sense where really the construction
super complicated just I this head size
right there are constructions that
revealing the set size which is pretty
much in the same model well the
soundness is not as strong as that
because they are really not considering
update but there has been results which
reveals the set size and could do the
same construction this was published in
TCC last year it's sorry constructions
with you I will yeah yeah he was the
form of signature so it was more
efficient than doing proportional work
to set size yeah yeah question was for
the range queries privacy there but you
don't wanna make the repairs but can't
you know I hands of users after making
the instruction oh my ideas control
disclosure so yes if there are colluding
clients who have access to the entire
database then you cannot hide anything
right of course they will learn the
entire data set if they call you but the
idea is the control discloses so that
the proof doesn't tell you more than
that so if you were to only query the
database you will not learn more than
that
that's one yeah yes the instruction how
much do you have well it's or yeah it's
double the size so if you were allocated
a sense of size n you allocate space for
about 2 n data sets and generate tags so
that you can keep on generating these
tags which are like ranks which as as
long as the number do not fall bit below
n by 2 or 2n or go above to end and then
if it happens and you basically rebuilt
the data structure so this underwater is
guarantee that is excellent the size of
year he does yes of course it does yeah
he really that will scratch original
machines yes you have to recompute
that's right but because you have the
motors guarantee it doesn't happen too
often
ok</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>