<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Bug Finding Techniques for Programs with Infinitely Many States | Coder Coacher - Coaching Coders</title><meta content="Bug Finding Techniques for Programs with Infinitely Many States - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Bug Finding Techniques for Programs with Infinitely Many States</b></h2><h5 class="post__date">2016-07-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/2caosXHOtJ0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
so I'm very happy to introduce Pierre
ghanti to you piers been visiting us for
for about a week today's his last day
here he's visiting from India India in
Madrid what does India stand for here
institute of madrid in Advanced Studies
in Advanced Studies yes it's a Institute
devoted to come computer science topics
I mean there are like several of those
but IAM their software institute right
so yeah so Pierre works on verification
and automata theory and these kinds of
topics and today tell us about some work
has been he's been doing in the past few
years okay thank you Chaz for the
introduction so it's going to be an
overview talk of some of my work in the
last years and just to plan the picture
so I'm doing verification and what I
call verification it's a reasoning which
is precise and exhaustive exhaustive
about the the behaviors of the system
and in particular i'm interested in
infinite state systems such as
sequential programs or concurrent
programs and i'm going to speak about
both kind of system in in this park and
i'm interested in algorithmic techniques
which means that the reasoning is fully
automated there is no human assistance
and in those last year i have been
focusing more on the precise aspect of
the verification giving up on the
exhaustive ness of the analysis so here
are two important problems there are
safety verification for programs so for
procedural programs where you have only
one thread of execution and safety
verification for multi-threaded programs
so first we start with a bad news is
that in general both those problems are
this item and even if you take a drastic
assumption like assuming that all the
data in the program is finite or bronze
there in the sequential case you got you
obtain decidability although the problem
is X time complete which means it stands
very high in the complexity araki and in
the case of multi-threaded execution
it's it's not helping there to do this
assumption so this is why I want to
study under approximation so as over
approximation do it so here we want to
sidestep the program of undecidability
or high complexity of the program so and
when I say that we want low complexity
program i'm referring to classes like
can be your or p space so here in this
talk i will explain you under how to
obtain under approximation technique and
in the sequence sequential setting i
will give you a restriction on the
control flow of the of the program and
in the concurrent setting we will
restrict the communication between the
different earth rights so in what are
under approximation good for so one
obvious application is to use them in
bug finding one which is less obvious
and I'm going to talk a little bit about
this is to refine your abstractions when
you are in a abstraction refinement
setting okay so the first part of my
talk I will tell you about the
contribution I have done in the context
of multi-threaded program and then in
the second prompt we will go to
sequential programs so let's start here
with a safety verification program so
you have this multi-threaded program I
kept it very simple for the for the
presentation you have two threads and
those tools right they communicate
through the shared memory and in the
shared memory we have a one variable
this variable bit here which is shared
among the tooth right
and the question that you asked here for
instance is is the the line of code
labored by error reachable so before
starting with a algorithmic techniques
let's just have a dry run by hand
somehow and I'm going to use the
following model of execution so i'm
using this sand clock here to say that d
2 is not going to do anything and the
active thread is HT one so if we start
to execute t1 for instance we assign
force to the beach here we arrived at
the conditioner we evaluated it
evaluates to false so we jump to the
else statement and then we jump back to
a line at one so now say that I I go to
the if statements and here I decide
because I'm the scheduler of the system
I decide to perform what is called the
context switch so and what what I'm
going to do I'm going to change the
identity of the thread that's active in
the in the system so i move the sand
clock to thread one meaning that thread
2 is not the actives right and also what
I have to do I have to let no thread
number two what is the value of the
shared variable of bit here so I I copy
if you like the the value of the
variable in the show anymore which is
false no I run thread to which just
keeps assigning a true 22 bit so I
execute this and again I decide that the
context which happens so now i rewrite
the shared memory and I had that the
value of bitch is equal to two true i
resumed the execution which was about to
evaluate the conditional know the
conditional evaluates to true and i can
reach the arrow statement because my
point here is to tell you that to show
that even for very simple program that's
a very difficult problem but i guess all
of you guys know that conquer in
concurrent settings to primer are
difficult and the decidability picture
is not really good because even if you
assume finite data you have
side ability so what people have done
and by people I mean by chance for
instance is is to restrict the the
scheduler we will obtain decidability by
restricting the the scheduler of the
system and the idea here is that the
scheduler it's the agent that controls
who writes and what is written on on the
shared memory and so this this sequence
here is a schedule so and how you should
read it so the schedule says that first
g1 ones and then at the switching point
a bit is the value true is written for
bit in the shell memory then t2 runs
then at the switching point the value of
BT's is false so it has been shown that
when you restrict the schedule to a
finite set of schedules the the problem
becomes decidable know the the safety
verification problem under the
restriction of bonded schedulers so for
instance you are low like gay rights ok
context switches so what it means a
context switch it means that any of the
thread can run and and then anything can
be written to the shared memory and you
allow these to repeat at most K times so
in the Indus fashion by this expression
here i've defined i've defined the set
of schedules that corresponds to k
context switches and the way i have
contributed to this line of work is by
extended by extending the class of
schedulers not two bounded schedules but
two unbounded schedulers so of course I
cannot extend it to arbitrary unbounded
schedules I still have to to pick a
restriction to find the restriction
because the prom isn't is sediment and
this is for instance the kind of
schedule I can allow is the arbitrary
repetition of this schedule so that's
one in
so and in general what I'm allowing our
schedules that schedules that are
captured by a regular expression of this
form so you will see this kind of
regular expression throughout the torque
and to make things clear I call them
bounded expressions so you know work
what we have shown so we have done all
the reasoning in a language based
setting so and and to do this what you
do is that you take the your program
with the two thread and you translate
each of the threat as a context-free
language or rather a device that
generates a context-free language such
as push down automata non context-free
grammar now if you look at the problem
from that perspective the language
perspective you have the following
picture so the general program to know
if the the error statement is reachable
it boils down to to ask if the
intersection of two context-free
languages is empty or not so and see
here I put a third ingredients that this
Sigma star it's to somehow you could
remove it but the way I mean if I choose
to put it it's too unfazed eyes the fact
that the scheduler can be arbitrary here
there is no restriction on the schedule
so and that makes the forum and decide
among know when you start to take
restriction on the schedule like bounded
context switches then it boils down to
to to look for a witness of none in a
non emptiness of the intersection in
this set like the words are two lengths
up to landscape and the the case of
bounded expression but is called
pattern-based verification in the in the
paper so here you look for a witness of
the non emptiness of the intersection
inside the set which is potentially
infinite and that's captured by this by
this bounded expression here
and with those two restriction here you
obtain decidability and you can even
show that both problems are are in NP
okay so this work we have published a
paper at at popper about that and we are
preparing a joiner version so the
contribution from a theoretical point of
view we have done a complexity in
detailed complexity analysis of of this
problem and here are the parameters that
we have been playing with some of them
seems very natural some other you will
see are a bit more sophisticated same so
as a parameter we have looked at the
number of threaded in the verification
problem so the second parameter P are
here is the maximum number of procedures
for each thread there is the size of the
death threat and then the two last
parameter I a bit less natural so there
is the size of the bounded expression
that you're looking at and finally there
is this LSP so there is for each thread
you have to consider the the cold graph
of procedure of each thread and this LSP
it corresponds to the longest a cyclic
path in this in this graph and I won't
go into the details but we have nailed
down a procedure that is this complexity
for the safety verification problem and
on a more practical note we have
implemented a prototype an intern of
mine so Thomas Porsche actually
implemented the the prototype and we
collected some experimental results all
right so and this is the this work
summarizing in one slide so basically
you have the whole universe here and
then you have this disk shape which is
the intersection of the language of the
of the tooth right and you want to know
if this shape is the empty set down oh
no so this problem is undecidable but
when you fix the window here
like the window given by this bonded
expression then within that window you
can decide if you have the empty cetera
oh no and from this picture a natural
question that you can know ask is what
is the general class of languages for
which this problem is is is decidable so
can you go beyond into intersection of
context-free languages for instance so
and that's the question that we have
stood it and the answer is easy s and
I'm going to serve the results we have
obtained so basically we identify the
class of language for which the previous
problem so which is the emptiness we
don't a section of a bounded expression
so for which is decidable and those are
the language which are recognized by
multi hat perched on acceptance so what
are those multi had pushed on acceptance
so just in in in a few pictures here so
it's an extension of the of the personal
no tomato on model so you have a finite
set of upstate you have one stack and
then hear what I have drawn is the input
tape and on this input tape you have
several reading hats no and the way it's
defined is that so observe that the
heads they carry a color like a yellow
and green and so does the state and the
way you should read it is that all the
transition that goes out of the green
state they only going to use the the
green reading hat and same for the so if
a transie if a state carrier color all
the transition that goes out of that
state they use the head of the of the
same color so for instance one
transition you may have is that when you
are in q1 which will use the green head
and the gamma is on on the top of the
stack and that
you have a four that's the symbol to
which the green I had points to like
exactly in this case so you have the
green add points to a phone then you can
take this transition where you will read
a four and move to state q2 and replace
the top of the stack with with the value
so we have studied this extension and
what we have shown first is that okay
this extension contain all context-free
languages that's a rather easy to see
because it's an extension which several
heads if you have one head only you have
the personal otamatone in all the
context context-free languages so also
it's easy to see that you can capture
the finite intersection of those and the
idea is the following if you want to to
capture the intersection of two
context-free languages let's say L one
ll to hear you you use so what you have
you have one word on the input tab so if
you want to know if that word belongs to
l1 and l2 so you first check that it
belongs to l 1 which for instance the
yellow hat so you simulate the download
button for everyone with the yellow hat
and if the check succeeds then you move
on you will again read the same word but
now you will simulate the automaton for
l2 and a check that it belongs to the
language so and if you I mean if you
want to put more language in the
intersection you just have to add more
heads to to to to the automaton so since
we can capture finite intersection of
context-free languages we can also
conclude that this model is good to
capture the computation of
multi-threaded programs but there are
not only good for this so they're also
good for instance to capture the
execution of now we'll open a
parenthesis like sequential programs / /
integer variables so in the hole
I give you some hint here to understand
how you capture the computation so think
of the symbols on the input type as
actions of your program so they do
updates to the the variable so here you
have two variable so for instance action
a1 when you fire it what it does it's
it's adding one to the variable variable
one and it's adding 2 to the very
variable to know if you have a sequence
of those actions on the input tip and
you have to validate that it's an actual
computation of some programs what do you
do so first you look at the sequence of
action and you ask yourself can this
sequence of action can be actually
produced by the program no matter if
it's executable just can it be produced
by the the program once you have done
that then you will do a second check so
you will check that this sequence of
action is actually doable from the
perspective of a single counter on me so
for instance using the Yellowhead you
will validate the the sequence of
factional of the tip is actually
feasible so in how you do this so you
read each action and you make sure that
you can I mean you only look at one
control and you make sure that you can
fire the reactions and then if you
succeed you you go on and perform the
check for the second the second counter
so what I'm trying to convey here is
that it gives you a really simple way to
do the encoding because you really
separate concerns like first you just
check that it's a computation that could
be done by the program then you just
check that it's actually a computation
that is a doable from the perspective of
a single counter and you completely
ignore the rest so and then from the
perspective of this one so and by the
fact you have several heads it makes a
young coding simple
so it means that you cannot have
infinite intersection of context-free
languages so because i only have
finitely many heads in my mother so if i
have cats i can uncle i know i can
encode intersection of K context-free
languages so and we could download it's
a bit more complicated but we could also
encode systems where you have programs
that communicates through through a 540
queues and they sent the each other
messages through those 50 views ok so
what are the contribution of this work
so we have shown that not the emptiness
problem of the language of such
otamatone is decidable because it's not
it's undecidable but it's decidable when
again you add one of those expression
those bounded expression here in the in
your question and in particular we have
shown that it's a go next time complete
so rather surprisingly the complexity
collapsed when P when you consider an
expression like this where each word
consists of a single letter only in that
case the the complexity the complexity
collapse okay how can you use those
those results so first as I shown you
before so you can include the
computation of your system by using a
multi-page down otamatone and then what
you obtain from those decide abilities
complexity results is a safety check ur
when restricted to sequences of action
which are captured by such a bounded
expression so you can enjoy many results
like it gives you once you can do the
encoding complexity upper bound for free
and
also something that that that you have
I've shown you before in the slides that
all the concerns are separate so you
look at one contour at the time and you
validate that the sequence of action is
fine for this discounter so you can
actually mix different things in your
model so you can have counters and cues
and so as long as you can model it you
can really mix them together inside the
model and there is no no problem all
right so and ok so I told you that we
did the encoding for free for
communicating system so that was
actually the decidability of this
program for free for communicating
system was proved proved before us and
that's the like the journal paper doing
it and so you know paper so which is way
much shorter so we do this and also many
different models so I'm just trying to
argue that somehow things are much more
simple when when you use this this way
to to do things ok now i will move to a
more recent work on on sequential
programs and hear what i want to do is
that I want to endure approximate
procedural programs over the integers
and what I want to do in particular is
to compute the summary of a function say
here you have a function that takes in
inputs a B C and returns to values x and
y what I want to do is to be able to
characterize the relation between the
input and the output so in here I'm
assuming that I have programmed that
manipulates only integer variables and
that I can and for the logic i'm going
to use to express the summaries i'm
going to focus on the press burger
arithmetic so computing summary it's
useful in various settings so it's
useful to do compositional verification
it is also useful to the equivalence
checking
because if you wonder if f1 and f2 ike
Rivlin you can just compute their
summary and then you do a query in the
press burger arithmetic to know if
they're equivalent or no they can they
can be used in termination proofs and
also in a refinement of abstraction I
will elaborate a bit more on that later
so my goal here is to compute summaries
for procedural programs over the
integers and I want to do it precisely
so I remember I give up on exhaustive
nice but I want to be precise
now here I'm precise so there is nothing
that there is nothing over approximated
ok so when okay you can check there are
some checks to you can check that you
are complete so you can check that you
are exhaustive so if you can under
approximate the summary and check that
you are exhaustive so if you do that
then you know that you have an exact
specification of the function and you
could compare them that's one possible
use so okay computing those summaries
it's a difficult problem because you
have many features that are in the way
like a recursive call parameters by
local variables return values so the
methods that do over approximation the
pretty much sort the problem so for
instance I'm pointing here to the
interpret analyzer that allows you to
compute those procedures summaries okay
ok
okay okay this is a bold statement so
that the over proxima shin tool so what
I wanted to emphasize there is that if
you give a program with recursive call
parameters local variables and all those
features to an abstract interpretation
based engine I'm not judging the quality
of the output but they will deal with
all those things they will deal with all
those features if you look at what he's
done for under approximation or precise
our reasoning they don't accept that
would simply reject the program and say
we cannot deal with that so yes yes okay
this tool doesn't do doesn't deal with
it it rejects it okay okay and i will
explain what what's our contribution
here and the way to explain it I i will
use this what i call the interpreter
approach so in the idea is that instead
of computing the summaries of directly
of the program p i will use an
interpreter of the program p and i will
compute the summary of of this
interpreted program and i want to
explain that but from the summaries of
the interpreted programs you can easily
extract the summary of the of the
program and now we run a flatter on on
this interpreter so as flatter doesn't
deal with the recursion I will have to
provide flatter a recursion free program
so my interpreter has to be recursively
so flattered is a tool that's maintained
at very max oh it's developed by a red
rosy for colleague of mine and it's
following the line of works that it has
done for several years and before him
Jerome lahu with the fast tool they have
developed those those technique which
aren't injured are called acceleration
techniques okay so i won't give you a
definition of the the interpreter i will
try to explain what's going on in a
simple example and how the interpreter
works on this simple example and i'll
give it two shots so on my first shot I
have interpreter a that would be like
the what you expect from an interpreter
and the program is going to interpret
here it's a recursive program here it's
the function ink that takes an input
parameter N and we just basically a n
plus 1 and the perimeter must be a
greater or equal then than 0 okay so
interpreter a when it interprets this
program what it's going to do is the
following so say I'm doing the
interpretation for 3 which is the value
of N and I I run the program so i go
around along the the right branch and
then I reach the recursive call here so
what the interpreter does so it will I
put this node in pink it will remember
the return address of the call and then
it will continue to interpret the code
by diving into the colon in interpreting
the code inside the code so and here it
continues like this until you reach the
base case and so which corresponds to
the leftmost branch and then you will
return here from your
from your court so that's the
interpretation that you that you would
expect so and why I'm doing all this
fancy development here it's I want to
dev to to give an ocean here of budget
of the interpreter and the budget of the
interpreter i define it as the maximum
number of pink notes you have seen at
any time plus one and it's actually
corresponds to the stack used by the
procedure inc because we have a three
recursive call all right so remember
that if i want to to use flat to compute
the summaries here i have to give an
interpreter which is recursion free and
the way i am going to obtain a recursion
free interpreter it's by bonding its
budget ok so for instance if i give to
the interpreter a budget of four so you
can deduce that the execution that are
going to be a captured I execution that
have at most three pink notes so
basically I won't visit anything that
uses more than 30 stack frames and
flatter will return me this summary here
to tell me that when n is given it
returns s plus 1 but only for but you
will have discovered that it all sewn
leave for value from 0 to 2 3 okay
that's that's our first charge now we'll
give you another interpreter that's
gonna with the same budget it's going to
provide much more coverage than the one
I have shown you and gid is the
following so it will again I do like
before so we will go along the branch
here but at the point of a reclusive
call we're going to do things slightly
differently here so remember that before
what we were doing we were diving into
the core so now instead of remembering
the return address I will remember that
I have to go
to the core and I will replace the court
by a non-deterministic choice here I'm
very smart i'm choosing the value 3
which is actually what what I'm expected
to to have and then I will just continue
executing until the direct seed note of
my procedure now once i reach the exit
note of my procedure I have what do I
have to do I have to validate that this
guess I've just done is actually correct
so I will actually validate that the
goal to doing is is correct so I will
validate that my guess was correct by
continuing the by pursuing the execution
so and i will do it the same way all
right now if you think again about my
definition of budget is the maximum
number of pink notes you have seen on
the screen plus one so here you can see
that i'm using a budget of two only to
my interpreter is using a budget of up
to only and in this case for ink for the
procedure ink if i gave to my
interpreter be a budget of two which
makes off into the interpreter recursion
free program no flatter will return the
entire summary of the of the procedure
ok so what what we can observe when we
compare the two interpreter is that with
equal budgets be is able to cover more
behaviors than then a and also with the
fixed budget here the the budget to for
instance be able to cover runs of the
original program that with unbounded
stack usage so clearly the interpreter
be wins here ok so now i will go over
comparing a and B but from a different
perspective which may
may make things more clear to you so now
I have this abstract program here which
has the same control flow graph as a
sink but I've replaced all the
statements just by a by labels and to
this this program I can associate no a
context-free grammar so in the way I do
this is that each node in the control
flow graph is associate a variable
integral so just capitalize the the
label of the note and for the transition
we have we apply the following rule so
for this edge from 20 to q2 with with a
on the label of the edge I will have a
production of of this form and the more
interesting productions are those which
are derived from reclusive code so in
there are basically so in a cold side q2
you call F and then you return to q3 its
translated by your rule that says that
you write Q 2 as q 0 which is the
initial node of f + + NQ q 3 all right
so and the language of of this grammar
here it's a to the n bc which
corresponds to the terminal case D to
the N and if you think about a personal
matter on that should recognize this
language so the pushdown automaton it
has to use unbounded stack space because
when you read because you have to
remember that how many and how many eggs
you you read when you read the beach now
let me again compare interpreter a and B
and what interpreter a does basically is
to consider derivation of the grammar
which are only leftmost what it means it
means that when I have several variables
here in a
derivation step interpreter a will
always rewrite the left most of those
variables and you can see here that ok
that's the derivation of a to b c d 2
and here the notion of budget i had
before so the notion of pink nodes there
so it corresponds to the number the
maximum number of variable i see in a
derivation step so now if i consider
interpreter be interpreter be as more
flexibility so because when it reach
some step like this one it doesn't have
to rewrite the leftmost variable it can
choose any variable that he wants to
rewrite and for instance here you can
choose to rewrite variable q3 and this
is this is the derivation of the same
word and now if I look at the budget of
this derivation the budget of the
derivation is too because I have at most
two variables in the derivation step and
actually if you choose a diverse
derivation with a budget of two you're
able to recognize the whole language but
if you force yourself with less not the
leftmost derivation there is no budget
that will cover the entire language so
that's another perspective on the
difference between those two two
interpreters so as for the overview of
the contribution so what we have defined
is a source to source transformation
that takes an input possibly recursive
program over the integers and it
transformed it into a resolution free
program I hope I convinced you that the
transformation that we are doing is
better than just simply bounding the
stack usage in the original program
because because of what because we can
capture unbound executions with
unbounded stack usage so in the
in a work we have also shown some
completeness results so if the the
control flow path path of your program
they can be shown to be contained in a
in a bounded expression and with some
condition on the updates you do on the
variables flattish will terminate and
compute the summary the precise and
exhaustive summary for the the program
and we have implemented the
transformation and done some
experimental results inside the inside
flattered yes
so they have developed techniques
already before to deal with loops so
when the loops of your program they
confirm to a regular expression of this
form and that the the updates on the
rebels are in some satisfy some
assumption like Radu and also a home
logo before they already took care of
computing the effect of those loop you
can have tests in them and when you have
nested loops you have no guarantee
anymore so I'm okay I see what you mean
by disjunction yes there when you start
to have on one location to self loops
yes yes
so either like the program that's given
to you already satisfy this assumption
or you just force the assumption on the
program so you pick up an expression
like this and you do the intersection
and then you try to compute for this
it's an under approximation so since you
give up on an exhaustive net it's okay
late ok so what to bring home today so I
mean I told you about under
approximation a technique which is about
more precisely precise reasoning and
I've presented you to to family of under
approximation techniques so there is
this budget idea on the derivation and
there is this idea about those those
expressions those bounded expression so
for this work about the budget
constraints it's rather easy to come up
with an under approximation because you
just need a number right you just need a
budget you say five and then you can
start to run your analysis so now here
for bundle expression so you need the
somehow I am assuming that the user is
giving this this expression to you and
so my first paper about those bounded
expression was in 2010 and now I can
tell you by experience that it's not
easy at all to come up with those those
expressions so and and there a ok i will
suggest the following so I I don't think
that the user will ever be able to come
up with those those expression but they
can come up from somewhere else and I
think they can come up in the context of
abstraction refinement so just a very
quickly abstraction refinement so what
you do so you start with a coarse model
of your of your system you find a
contour example that's if it's a real
one you done if it's a spurious one then
you will basically what you want to do
is to eliminate this
impress eyes behavior from your system
and the way you do it is by recovering
precision in the model so and what the
cigar technique does it's to recovering
precision one counterexample at a time
it works well in many cases but in some
cases you may diverge and in particular
you may have something like this so the
first contour example doesn't go through
the loop it's just going from I mean the
left part to the right round then you do
refinement then you have that the second
example contour example goes once
through the loop you refine then you
have another country example that goes
twice through the loop etc so there I am
confident that this technique about the
choose the bounded the expression here
could be of some help and the idea is to
use precise reasoning that's what is
provided by the reasoning about those a
bounded expression to eliminate not one
counterexample man many of those at once
and the idea here will be simply just to
give you the intuition so to associate a
a word to each path here and then you
can see that if I can do precise
reasoning along such a bounded
expression then I will have eliminated
all the contour example that just go
more and more often through through the
loop body so that's just an intuition
it's something I have to to explore all
right so that's basically the the big
picture of my research so I have told
you about those two lines of words about
multi-threaded programs and also the
programs over the integers so I also
have done some contribution on even
based a synchronous programs and more
recently on on parameterize systems all
those work they have used some under
approximation and so we have used those
bounded expression here for
multi-threaded
programs but in all the others we have
used this idea of bonding the budget of
of the interpreter or bonding the
budgets of the derivations that we that
we look at and this under approximation
by using budget it's actually in many
cases not an under approximation so for
even based program so in the case of
parameterized systems we're able to show
that if you if you take a budget which
is high enough you will actually be a
complete from the question that you are
investigating in the case of programs
over the integer so in general it's not
complete but as I told you we have a
completeness results when the control
flow is captured by a bounded expression
and we also have done some preliminary
implementation work for for those except
for the parameterize system case thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>