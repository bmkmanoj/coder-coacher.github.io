<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Charles River Crypto Day: Constant-Round Interactive-Proofs for Delegating Computations | Coder Coacher - Coaching Coders</title><meta content="Charles River Crypto Day: Constant-Round Interactive-Proofs for Delegating Computations - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Charles River Crypto Day: Constant-Round Interactive-Proofs for Delegating Computations</b></h2><h5 class="post__date">2016-08-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/YK12zq4ZBWE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
well can't the I don't know what number
crypto day what second 666 crypto yeah
okay well welcome to the crypto day we
have four amazing Talk's today and the
first one is a whole world bloom who
will tell us about a beautiful
breakthrough plants around interactive
proofs for delegating computation thank
you very much hey hey good morning
everyone um so I'm delighted to start
the morning with a double session on
delegation should have a liteon we r
talks about delegation and this is a
title that hugs Carson around
interactive proofs for delegating
computations this is joint work with
Orion golden gai Rothman and sort of
because we're talking about interactive
proofs I encourage you to have an
interactive talk feel free to ask me
questions hopefully be constant round
you open that then you'll appreciate
what constant round really gives you
okay so what is that delegating
computations so the motivation is as
felt we have some weak computational
device let's say a grad student with a
laptop who wants to perform some very
expensive computation so just running it
on its the laptop is infeasible so the
matter of solution that comes up is to
use the power of the cloud so for
example actually Amazon will sell you
time on their servers to run your
computations so pretty cheap and it
sounds like a great idea so our grad
student will send over X to Amazon to
the cloud the cloud compute the result y
which is equal to f of X and send it
back the result problem solved so not
quite the problem is that we're
cryptographers and we're distrustful and
we don't want to trust the cloud that it
actually performed the computation or
that was honest in any way in particular
it could just be a make a mistake you
know could happen could be just lazy so
if this function is something that we
really haven't expect a value that we
expect it to have the just stand back to
that value without actually performing
the computation or this cloud could even
really intentionally be malicious
okay so we don't want to trust the cloud
and when we don't trust the cloud that
may be the most fundamental concern that
comes up is why should we trust a cloud
that indeed y is equal to f of X okay
why why should we have this correctness
kind of an orthogonal issue is the issue
of privacy if we don't trust the cloud
how can we stand x to the cloud but for
this talk I want to ignore that let's
think of X as being public and there are
solutions that you can build on top
using say for your morphic encryption to
get also privacy but for this talk think
of x is being public so x is known only
want to compute f of X okay so the
client somehow need to be able to verify
that indeed y is equal to f of X so it
can just do that right in compute f 1 x
and check that it equals y but of course
that kind of defeats the entire purpose
because we don't want the client to
compute F so the natural idea that comes
up is to use the power of the the prover
of the server to also convince the
verifier the client that indeed was
equal to f of X so we'd like such a
scheme in which the verification is much
more efficient than just doing the
computation by yourself on the other
hand since we use the the cloud or the
prover to help us we want that proving
is also not that complicated okay and
this brings us to the notion of a double
efficient interactive proof it was the
study of which was initiated by go the
sir kalaingar aathma and the idea as i
said is the phone so we want a double
efficiency requirement we want that on
one hand verification then indeed y is
equal to f of X be extremely efficient
and particular much more efficient than
a time that it takes to compute F on the
other hand proving should also be
relatively efficient so not much worse
than the time that it takes to compute F
okay on top of these two requirements we
also really want to minimize the amount
of interaction so we'd much rather
solutions in which the amount of
interaction is small to those in which
it's a large and of course there's
practical motivation obvious fact or
motivation for that okay so let's be a
little bit more formal so the situation
that we have is very menacing to that of
a classical interactive proof right so
we have a verifier V on one hand
approver p on the other hand they
interact and the proof is trying to
convince the verifier that x
longs to some language l as in the
classical setting of interactive proofs
we want completeness meaning that if X
is in the language then the verifier
accepts with high probability or even
probability 1 if X is not in the
language now we're going to end this
talk we're going to talk about
computationally unbounded cheating
provers and we'll get into that into
more detail a little bit later so that
is that X is not in the language no
matter what cheating strategy you use
you'll only convince the verifier to
accept with some negligible probability
probability of our fire accepts it was
negligible server to be rational Sharko
instead of like religious yes if you
only care about a sure right that makes
sense um since you brought it up there's
also like a model of people talk about
rational meaning like an a in sense of
money right so who is pay the most if he
answers honestly that's not our setting
right in our setting we're thinking of
uh okay so let's that brings us to the
issue of efficiency so as we said we
want the verifier to be extremely
efficient you're extremely efficient is
going to mean basically running Hamid is
linear in the input length regardless of
what language were trying to talk about
so just a linear time very far basically
just reads an input and the proofer
needs to be polynomial time I want the
prove it to satisfy our usual notion of
efficiency or the classical notion of
efficiency so I defined for now find it
in the input length so I'm restricting
myself to pee or bpp so one thing that I
want to stress is this difference
between the power that I'm getting the
honest prove ER and the dishonest
proofer so the Onyx prove of you who i'm
specifying as part of my protocol needs
to run in polynomial time the dishonest
provers that are trying to cheat me I'm
like very pessimistic I'm thinking of
them as computationally unbounded they
can break crypto they can do everything
okay so just to stress the difference
between these two types of proof
and let's kind of just drive in the
point what's the difference between this
and the classical notion of an
interactive proof well kind of the same
except for the efficiency right so in
the classical gmr type of interactive
proof we're talking about polynomial
time verifier here we insist on linear
time or quasi-linear time and the honest
provers there is computationally
unbounded actually you can implement it
in polynomial space but forget about
that here we're insisting on polynomial
time no that's gmr it's like a classical
interactive proof like I p equals P
space type of our and right so gk r
which is a globe a circle iraq on paper
is exactly the paper that introduced
kind of this column okay so let me first
tell you what is all this dimension some
power work so in this work of a gk r
they showed a such a beautiful protocol
that works for any bounded depth circuit
so roughly the class and see where the
verifier is laying your time the prover
is polynomial time when downside of the
protocol says the number of rounds of
interaction grows with the depth of the
circuit so quite a bit of interaction
one the only place I want to talk here
is uh this is longest i'll talk about
computational soundness so a naturally
taxation that you can make is to assume
that the chili prover is not that bad so
it can be arbitrary polynomial time but
it's a camp break crypto so it's kind of
a natural relaxation and indeed under
this relaxation we can prove very strong
result so Kiran has this beautiful
protocol for any language in NP based on
collision resistant hash in using pcps
here by NP to talk about NK means that
the honest prove ur also gets the empty
witness for it to make sense that it's
polynomial time and in the joint work
with yet and run Russ we gave a
one-round protocol for languages in P
based on kwazii polynomial a horrid here
and I should mention that there is like
a huge but this is kind of the tip of
the iceberg there's a huge body of work
on these problems including ranging from
implementations work in related models
like random Oracle pre-processing also
very strong results under kind of
knowledge type of cryptographic
and and so forth right right right right
so if you can't read messages this would
be four messages between the two party
and this would be two messages okay so
that brings us to uh the main route so
no so this one is public coin this one
you need a yeah it's not public
verifiable okay so this brings us to our
main result so our main result is this
kind of double efficient interactive
proof for the following class of
languages so anything that you can
compute in polynomial time and in some
bounded polynomial space you have such a
public coin double efficient interactive
proof of Fr is almost linear time for
verse polynomial time and just a
constant number of rounds of interaction
ok so that's the main result one thing I
want to stress oh so and this Delta just
some some some sufficiently small
constant that i'm not going to specify
know so this is a this death is a
universal constant existed yes yes and
uh and this constant round depends on
the language on the so if you want to
run this kind of protocol for a language
even compute in time and to the hundred
then the constant in the round will
correspond to the hundred I don't know I
mean I haven't checked potential you
could hope for it to get up to one we
don't get one yes yes okay yes the
doctors affects the birth wires running
time right no that is universal constant
there exists a single universal constant
Delta so if you take like n space yes
know that then the running time would be
some some fixed polynomial the rank time
of the verify would be some fixed point
on right sure yes yes uh and you could
update it to maybe I don't see any
heard reason why you couldn't push Delta
all the way up to 1 we didn't do that
yet potentially you could computable
poly time in Polly's face let's say n to
the hundreds no start off saying there's
a fixed polynomial such that for every a
yes right so we're actually going to see
the like a statement that will exactly
show you that like a general statement
not just for a language isn't be input
tanks yes yes just floor yes yes this is
an analyst and put like we're going to
see more like the general thing which I
thought would be useful now I think it
even more ought to see it in other words
if I wanted linear time for the verifier
that would dictate what does should yes
exactly exactly okay and one thing I
want to stress here is that this is an
information-theoretic result so we're
not making any cryptographic assumptions
we're not assuming that the cheating
provers is a computationally bounded and
in particular this could be so I'm not
saying that our protocol is practical in
any way but just the fact that you don't
use crypto can many times be beneficial
for implementations welcome to is
expensive okay so before telling you
more about the proof I want to say a few
more things so one thing is how tight is
this result so somewhat tight so if we
define the class of languages I p sub
now around s any example that you
language you constructed protocols for
which you mentioned implementation
mm-hmm I notice in these talks that
somebody gave it a mighty few weeks ago
focusing on particular languages I don't
know what it was matrix multiplication
what was it anyway there's some language
they invest a tremendous amount of work
I'm just wondering not for that language
but right so I thought actually
simplified versions even our protocol
for interesting languages for which you
can have three around three message even
not even three around um right but in
jan
the content in the constant violence is
going to be in not so good in general
there's some inherent dependence right
yes either on this space or we're going
to get to that yes yes you're talking
about the round yeah yes we're going to
get to that at least we conjecture that
there is to reasonable conjecture so
okay so how tight is this result so
let's just define the complexity class
of I p sub de at this class of languages
that have w ficient interactive proofs
okay so we have this nice complexity
class our main result shows that it
contains our languages I don't know it
this way so time-space poly n and to the
Delta now which is a computer in
polynomial time and enter the Delta
space so this is our main result and on
one hand it's kind of it's totally
trivial that this class double efficient
interactive post is contained in bpp
right because both parties are bpp
machines and on the other hand it's not
hard to see that it's contained in space
in linear space because if the verifier
is linear then in particular the
communication is linear and then at
least in spirit you can kind of in
linear space simulate all possible
approver answers okay so this is kind of
tight where the gap is one gap is kind
of getting a delta to be one and the
other gap is this kind of annoying
distinction between having one machine
that runs in bounded time and space and
in verse of the intersection here which
is two machines one running in small
time and one running the small space but
after that it's tight okay which brings
us to the kind of a general form of our
main route yes so the does tell me
something about the bill if I want if I
want linear time everybody tells me
something about it yes so okay so in the
formal statement is if I want Delta to
be one it doesn't mean a lot for the
verifier mrs. Devere far is going to be
rather than linear it's going to be some
bounded fixed polynomial yes okay so
let's state kind of a general is I think
it'll be useful would given the
questions here so let's say that we have
some language I we can compute in time T
and in space f so now I'm not
restricting just a polynomial time then
for
these type of languages we have public
one interactive proofs now let's say so
we have this down with you that we can
compute by ourselves in time p let's
let's say that we want to use the prover
together speed up of in kind of an
epsilon factor we want to go down from
t2 t2 the epsilon no this is for epsom
which other of constants know for every
constant epsilon yes so you have your
language then you want the speed of
blowing go down from t2 t2 the epsilon
okay so if we want to such a t2 that's
on them as you expect the verifies
running time is kind of dominated by
this T to the epsilon I'm thinking of
the space is much smaller than the time
so this is not too much too bad and in
addition I think maybe this is really
stammers question the you kind of have
to read the input so this is kind of in
spirit reading the input so there's a
factor than here in em yes for this
epsilon otherwise you could kind of a
yeah um that's so the very first running
time is basically to the epsilon the
proofer is kind of not that bad so it's
you would hope it for it to be T it's T
to the 1 plus epsilon plus a poly a
specter time's up all yours factor the
communication also shrunk down from kind
of okay don't know if it's rung down but
its teeth of the epsilon and now we
paint around right so if you want
epsilon to be very small it's going to
be many rounds in fact we pay
exponentially in their rounds holy s in
the verify the time is less than here
there's no data I'm saying in general
mm-hmm so that is such that the holy s
in the very final time yes it's uh
exactly yes anyway so here this result
even if you want IP for this even the
classical sense it only you need epsilon
to be my smaller exactly oh let me skip
that so you can get a little bit less
than a constant but not enough to get
what you're at once so you can't kind of
you can't scale this up too much yes
right right unfortunately
right so a very interesting question is
kind of maybe I get back to this in the
when I talk about open questions but
kind of scaling this up and even so it
just kind of forget that people prove
that I p is equal to p space for a
second you just want to use this theorem
to prove that I p is equal to p space
right it's kind of similar you have a
sum bounded space language and you want
to kind of a to improve the running time
with a verified from the exponential
time that it takes to compute the
language to polynomial time which means
that you want the speed up you want this
epsilon to be very very small and right
now we can't handle that things blow up
no so here I insisted that epsilon is
content and I'm hiding things going on
here which happen if epsilon becomes a
very very small if you're able to show
whatever log T so uh right yes you need
the so you want to move from t to poly
em right so you need a epsilon which is
a corresponding epsilon basically 1 over
log t right so that goes back to this so
some dependence as near pointed out some
dependence out epsilon under what I
think are reasonable complexity
theoretical assumptions is needed
basically a linear dependence seems
inherent we have an exponential
dependence and the I think would be very
interesting to improve this even to
anything smaller than this okay so this
is the main result so just a I mentioned
some PI work before just to compare how
this result relates to them yes yes hi
no I'm m do m doing it for me so it's a
the co tilde of something is something x
poly log in something
right right otherwise I wouldn't claim
constant yes okay um right so i just
want stress of this kind of this
protocol improves on what was previously
known in two aspects so one thing is
that even if we disregard the fact that
it's a constant around protocol it shows
up this class I p ee efficient
attractive proofs not only contains
bounded death computation but also
bounded space which was not a non known
previously even if we ignore the number
of rounds and on the other hand if we do
look at the fact that it's constant
around so if you look at constant round
interactive proofs with this linear
linear time verifier these were not
known even for a log space even if you
even if you allow the honest prove ER to
be unbounded okay it was known i think
it was it son publisher i think you and
guy had a result for NC one or even a
very uniform i think for anyone before a
log space it was not was not known okay
so before telling you about the proof
which is coming up i just wanted to
mention a few yes the number of rounds
actually grows with the space rather
than the dead are just something we
didn't know how does this compare to
sort of incomparable right stop it um ok
so when GK are right complexity grows is
it that yes we hope to have the version
of tequila where it grows with the space
yes def we know that some dependence on
either one is inherent yes does this say
anything about the question with this
face like can you get something that
goes with the space and not that I mean
we show that you can get it without
other number of rounds growing with the
space so it's kind of even better so I
think right so in particular what you're
saying would prove that I p equals P
space and we don't know how to use our
techniques to do that okay
does that answer the question okay okay
okay so before telling you about the
proof I mentioned some coral eyes which
I think are very interesting so one
thing that is a very interesting is so
in this talk so far we only talked about
kind of the proving ass but if I sound
this aspect what about zero knowledge so
something that's cryptographers we
really like so years ago result you can
get zero knowledge proofs for MP where
the amount of communication is basically
going to be more or less linear in the
length of the witness so instead of
going through all the NP completeness
reductions and so forth you can directly
get something that is linear in the
witness length this is true as long as
the MP relation can be computed in
polynomial time and bounded space again
this previously the same kind of thing
was known with bounded depth you think
gkr this allows us to do this for a
bounded space a second interesting
corollary is if you heard me previously
talked about interactive proofs of
proximity so dr. proofs of proximity or
interactive proofs in which the verify
runs in sub linear time okay so it
doesn't even read its input and the
sounders guarantee is kind of like a
property testing type of guarantee so
using a result together with a result by
a guy a field salir you can get constant
round proofs of proximity where the
verification or the running time the
verifier is sublinear then you can do
this for the same kind of class of
languages polynomial time and bounded
bone on the space lastly even if you
really don't like space and all you care
about is depth we can also slightly
improve the g KR result so in g kiara we
said that it's the GK result holds for
NC circuits but they need to be somewhat
uniform how uniform need to be you need
to be able to generate them using a loud
space machine using our results you can
improve that to NC circuits that are
generated by again polynomial time and
bounded polynomial space machines which
kind of gives more flexibility if you
only what you know is a bound on the
depth of the what you're constructing ok
so now let's go to the proof
okay so we have a language L which you
can compute by yourself in time T M in
space s that's what I mean by the time
space and s and now we can think of the
tableau of the computation okay so what
is the disturb la so each column here
corresponds to a configuration of the
Turing machine meaning it's stayed and
the it's all its tapes okay so that's
every column here we start off in the
initial configuration and then kind of
we get an input and the Machine compute
some tea steps and we got this big table
and again I'm always thinking of s is
being much smaller than T our goal is to
construct an interactive proof for this
language where the verifier runs in time
that is much better than T so here's a
natural idea let's split up this time
goes the this way yeah huge picture but
okay yes okay yeah okay i'm using the
fact that the the slides are wider than
they are at all okay so here's a very
basic idea let's take our t-step
computation and split it up into K
chunks each of length T over king all
right so we have these k chunks and
think of K is not being that large and
we ask the poo over to send us the
configuration of the Turing machine at
all these steps right so what's the
configuration will join the machine at
time t / que tu t / k 3 t / k and so
forth so these k chunks okay that's nice
and now we can observe that each one of
these computations by itself you can do
in time T over K and space s so a
natural thing to do say let's kind of
recursively assume that we have
interactive proofs for all of these sub
computations and run those on all of
them having a natural idea the problem
is that if you think about this if you
open up this recursion what the prover
is basically sending is this entire
table right so and in particular just
the communication is going to be x s we
could just do everything by
selves in time T so this is not a not a
good idea okay try something else I mean
if you open up the entire recursion then
the provers sending this entire table
and the first step is sending these k
but if you open it up it's actually
sending everything so that's not good so
let's write a subsample rather than
checking all of them let's just choose a
few at random and only around so we
assumed kind of recursively that we have
interactive proofs for all these
computations let's just choose a few of
them I'd random and recourse only on
those try to save on on a running time
so that does save on running time which
is good the problem is that the
soundness error is terrible and the way
that you can see this is just think of
the cheat improver that takes the
computation does it kind of correctly
until some random step then it does some
wrong step which leads it to a kind of a
weird configuration and from there on it
does the computation correctly and ends
up in and accepting the state right now
if we were unlucky and we don't choose
that specific block at any point of time
then we're doomed so the songs here is
really terrible terrible okay so what
we'll what would we want we kind of want
the best of both worlds we want to
verify that all k of these things are
correct computations but we don't want
to pay right so we don't want the kay
kay independent invocations of the
interactive proofs yes language where
the witness the thing to learn that
you're verifying the witness is space
bound you mean that then p relation yes
the PCP also there most of the work is
essentially doing recruit cursive
verification of that did you think about
that so so long talk about been
converting the stead PCP proof for that
same language mm-hmm good look at all
the parameters and I is any people
looked at window verification oh you're
asking about pc ps4 language was with
efficient service for verification
so it's somewhat related so this was the
work of a island run on attractive PCPs
and then you could so these are kind of
pcps which after the PCP is written to
verify it you use interaction so that
you could you could kind of use a
something like that we didn't think
about it seems interesting okay so going
back we have these two kind of very
naive ideas and we want the best of both
we want to be able to verify k sub
computations without paying k time to
the cost of each one so here's the hope
so what we'd like is the following type
of theorem suppose we have a language L
that has an interactive proof with
complexity see think of this as the
verify running time of communication
whatever you like so we have this L that
has an interactive proof we want to
construct an interactive proof for
verifying k instances of the language we
want to verify that each and every one
of them is in the language and we want
to do this better than the then the
evening which is running k interactive
proofs so this is the hope okay and we
call this kind of creature amortize
interact approves the reason is that the
cost for instance decreases as you
increase K actual like you like in
regular amortisation right so the more
the larger k is the cost per instance
decreases okay so our goal is going to
be to amortize interactive proofs yes
question okay so we want to amortize
interactive proves that team is kind of
difficult let's try with something more
basic let's try to amortize NP poofs
non-interactive proves what do i mean by
that so think of the function are you we
have an MP language and we have a prove
our which is given k KL instances and
the K corresponding witnesses and we
have a verifier that wants to check it's
also given just instances x 1 up to X K
and the verify wants to check that each
one of x 1 up to X K is in the language
so obviously the pervert we just sent
the witnesses but we want a solution
which potentially can use interaction
that's fine but we want the amount of
communication to be much less than M
times K okay so that this is kind of a
question that I think even unrelated to
the result on getting constant R an
interactive proofs is a natural an
interesting question okay so this is
this i call amortized MP statements so
in fact we don't know how to do this and
i think it's a greater open question we
do know how to do this for a specific
type of MP languages specifically NP
languages that have four axes that are
in the language there is a unique
accepting witness okay so this is called
the in terms of capacity is called the
class up4 unique or unambiguous and p
and the kind of canonical example for
this is the promise problem unique set
where you need to distinguish between
formulas that have no satisfying
assignments and formulas that have
exactly one satisfying assignment okay
so if x is in the language the only way
that you'll be convinced if you is if
you given the unique satisfying
assignment okay so our goal now is to
amortize you p statements and here's the
result so take your favorite language in
you p we show an interactive proof for
verifying k instances with the following
parameters so for the verifier what's
the verify running time so k times n is
just reading the k input so that seems
inherent and then instead of
multiplicative factor of M we just get
some some polymer factor in that up kind
of the naive M times K which you get by
sending all the MP proofs we're getting
only a dependence kind of we're breaking
this multiplicative dependence we're
only paying em roughly the proofer time
what can you do you need to the prover
with a question witness for the
satisfying assignment
right so it's going to be so here you
need to think of the so this would be a
promise problem and then you'd handle
the promise version of this so you need
to distinguish between the case where
you have x 1 up to X K which all have
unique satisfying assignments and the
class and the case where at least like
all of them either have a non no
satisfying assignment or one but not
like they don't all have one so we
handle the promise version so this
extends the promise problems as long as
here you're talking about the natural
extended promise okay so the proof or
anytime what can you do it needs to
solve the problems which polynomial M&amp;amp;K
the communication instead of being k
times M is roughly k plus M which is a
really what where our game comes in all
right yes in fact so this poly you can
really it's just that I don't care you
can really make this a linear I think or
a quasi than you M is the length of the
NP witness yes yes okay and the number
of rounds of this you p amortization is
logarithmic in k and in fact if you
really want to insist on the constant
round you can do that but then the other
parameters blow up a little bit so if
you want this to be a constant then here
instead of having lucky you have some k
to the epsilon or something but i think
this is like an interesting theorem on
its own and this I want to prove to you
okay I started late right so I have a
little bit more okay so how do you how
do we amortize these you p statements
okay so let's try a very like the most
name thing so we have again the setting
that we have is that the verifier has k
instances the proven has the k instances
and the k corresponding unique witnesses
and the uniqueness is going to come up
until a few slides so for now think of
them as just regular
p statements so what is the prove we're
going to do so the proven generates k
PCP is corresponding to these k
statement just to remind you PCP is an
encoding of an MP witness in which you
can verify by just reading few locations
and the proof I'm sure I'm sure you're
all familiar with PCPs so our prove it
generates pc ps4 the case statements
this big table a now the verifier
generates pcp queries for for this PCP
and i'm going to use the fact that in
many known constructions of pcps the
verifier queer is the place that you
look at don't depend on the input so of
course when you get back to the answer
you will look at the input but just the
places that you ask our kind of a
distribution that doesn't depend on the
input ok so our verifier generates
basically this kind of queries once
these queries are in a sense good for
all of the case statements sends over
the queries to the proven these queries
kind of specify columns of this matrix
and the approver just sends back the
matrix restricted to these columns so a
sub Q now the verifier checks that the
PCP there the K PCP verifiers accepts
all accept all of these answers okay
very simple protocol so one thing is
that it's really really efficient so the
communications just something like order
K maybe the queries is a log M or
something so it's really efficient but
we have first try here so it can't quite
work and in fact it doesn't the problem
is that it's totally insecure the reason
is that the sounds guarantee of PCP is
only holds if someone first writes down
the PCP then can't change it anymore and
then you go and do your queries here
sort of the unproven that's how he
worked but a dishonest prove er you know
first sees the queries and then can
generate the PCP so if you think so and
then basically all PCP constructions
this has to break and it does so this is
entirely unsung after you see the query
you can easily generate a PCP that will
make these queries accept so that's not
good what we really want is for the
prover to first commit to the PCP
that are constructed unfortunately we're
not in the cryptographic regime we don't
have commitments what can you do try to
do the simplest thing possible and see
what happens yeah yes I mean it's easy
because Killian did it 20 years ago yes
but yes um okay so I mean if you write
yes okay so let's try to do the simplest
thing that we can we want to somehow
have the approval commit to these pcps
will do the kind of stupid is commitment
you can think I'll just take an XOR of
all these pcps let's call this C for
commitment or checksum whatever you like
so just the X or a bit by bit XO of all
these pcps column by column and this C
is a pretty short so we're going to send
see over to the verifier okay so we sent
this XR that's just in oh it this way so
the prover sent over C to the verifier
and now we repeat the previous protocol
so the verifier generates the queries
this query specify a subset of the
columns the prover sends over the
columns but now given this commitment we
can do an extra check what check so we
got these columns now we can compute
their ex or cell and compared with the
commitment that we got it seems kind of
too naive but uh we're going to argue
something something useful about this
protocol it's not going to be sound as
this yeah but this is the protocol which
has this property yes yes yes and in
particular if you use a pcp with uh they
say quasi-linear length proof and you
can get instead of public the length of
what you send is almost linear in the
original witnesses okay so this is not
sound too too simple to be sound but
still we show that it is sound if you
make to relaxation switched will
motivate how will change the protocol so
let's make the two following relaxations
the first one I want to assume that sort
of for soundness I want to assume that
only one of the info
is not in the original language and kind
of this is seems to be a good assumption
because this intuitively this is the
hardest case and if there are many
inputs find the language somehow its
spirit it seems easier so only one of
the inputs is not at the language the
second assumption is a problematic one
so I'm going to assume something about
the behavior of the proofer what I want
to assume is that when the prover opens
up this a sub-q write the answers to the
pcp queries on all the inputs except for
the j throw this XJ star it answers
according to the actual PCP it doesn't
make up other am so these are empaths
that are in the language but the way
that the prove rat is it answers
according to the correct PCP doesn't
make up other answers that will make the
verifier accept okay and we call this a
single deviation proofer it only
deviates on the kind of wrong input okay
and I just want to stress that this is
really like a mental experiment it's
totally unrealistic assumption once we
tell the proven not to do something
that's exactly what he's going to do so
but but this will motivate the changes
that will do so what I want to say is
that indeed in this setting this
strength see that we sent over does
commit the proofer to a PCP for a XJ
star and put that it's not in the
language which PCP just take a seat and
exhort with all the right pc ps4 the
other inputs and in what sense is this a
commitment the way that the protocol is
built the extra check with a comparing
to the XOR together with our assumption
on the single deviation means that the
answers that we get on a queue has to be
consistent with this piece EP PI right
um so you're not really using unique I
mean it's right right but I could I
could I could have changed this
assumption to say that the chain
approver sounds like the
lexicographically first PCP or something
this is not like the real place it is an
extent but not the real place okay so
for these kind of under these weird
relaxation this will actually be sound
so we got a PCP that was kind of written
in advance before seeing the queries
this is the PCP for XJ star and the
proofer manages to convince kind of in a
PCP you sent the queries
approvers committed to pie and the
verifier except with PCP so this this
will they sound under our relaxation ok
let's try to improve this and the way
that will improve it is to use a more
elaborate commitment instead of just
doing this X or there's something a
little bit more sophisticated yes if it
was real PCP model we commit to it are
you getting some sort of partial
commitment what are you saying that if
you're getting a commitment if the
prover is well-behaved I mean not under
not on that is sort of well behaved in
the protocol behaving only a loud kind
of partial power it's not anything
useful it's a commitment right and that
for that in that setting yes in the
language yes pcbs exactly so it's not
even it's not even many pcps its many
answers to these queries to think of the
thing of the hosta PCP in which is just
a linear equation you can kind of do
anything that satisfies a single linear
equation gives you a lot of power kind
of but not this is not the real place
what's important is that I can kind of I
needed kind of something like uniqueness
to define what it means for the
dishonest proofer to behave a kind of on
the on the inputs that aren't the
language to behave in a particular way
right so you could say that i'm using
the fact that it's unique so he has to
behave that way i could have otherwise
like they find out that he hate what he
sent is consistent with a
lexicographically first pcp I mean so
this is like not yet the actual
important place for the honest truth
cannot create a malicious behavior on
the saamne slick only g-star so I'm not
even swimming so we're talking about
soundness so the chin prove it doesn't
even get witnesses but it can just brute
force and find all of them and now I'm
saying so here what I'm saying is
because we're talking about like unique
when this is I'm saying the cheating
approver has to work with those
you unique pcp alternatively for and
different setting could have said like
some canonical first up PCP there's not
yet it's coming up cleanliness it means
that your second bullet here literally
means not just that it's honest on the
remaining guys but also use this is
specific sure yeah right and in the case
of you p this is the only witness yes
okay so let's try to improve this and
ideas as i said to improve instead of
using this very simple x or checks i'm
not to do a little bit something a
little bit fancier so we're going to use
an encoding e which will apply again
column by column so it takes the K bits
which are kind of just a column and map
them shrink them into something like d
bits okay so it takes the column from
before and shrink it to D bits and it
has the following property so if you
take any two x and y's which are a
distance D or less or distance less than
D their encoding is different yes it's
very easy to construct these some
coatings can do it efficiently and in a
sense it's Tenley related to error
correcting codes okay so this is the
type of encoding that I want to use okay
so how do I use this so now when the
prove it generates the prover lonex
prove it generates the PCP now instead
of just doing an XOR it computes this
fancier encoding to construct a somewhat
taller matrix C but still not that tall
so it's D times M roughly and think of d
is much smaller than okay okay so we
just in code column by column as before
yes you could use a randomized encoding
but no reason to okay so now again the
Hoover sends over this more elaborate
commitment over to the verifier the
verifier generates PCP queries reads the
columns get back their responses and now
as before we can given these responses
we can check consistency we can compute
then coding by ourselves to the point
that it's efficient and check
consistency with what the prover sent
over back here and see okay
yes this is the XOR of all the long
column now it's our next sorts a labret
fancier commitment oh okay so sorry the
commitment is just that encoding yes
maybe the easiest way to think about it
is take a apply an aircraft in code
which has the property that it's kind of
systematic meaning that the first K bits
or remain the same so you only have like
these kind of check some bits these are
going to be the check from bit and you
send over the check from bits yes yes
and the important thing is that these
checks and bits are not that many it's
just a much less than K okay ah a few of
that you send a complete these are you
chicken to do with the case yes okay
okay so now let's think about a are
cheating prove er are poor teen approver
so it has kind of two options when it
opens up this a a sub Q one thing it can
do is to deviate meaning send stuff that
is not consistent with the unique
correct pcps unless than D of the rose
for now let's let's think of the let's
keep the first simplifying assumption
that there's only one open on the
language but it'll be easy to get rid of
that yes yes so not kind of separating
between what if it lies on the less than
the corresponding to our assumption and
kind of a morally or intuitively because
we have a commitment of length D and if
you think about it it kind of makes
sense the way though we built the
commitment that if we if that you
improve a debate unless and DF the rose
we should be we should be okay then it
requires a proof it's not too hard the
other option that the prover has is to
deviate on more than view of the road
and not something really interesting
happens because the fact that it
deviated on the rose means that even for
kind of the minus one or so of the
inputs that are in the language it's
sent answers to the this a sub-q was
inconsistent with the unique PCP for
these inputs that are in the language
this is something really interesting and
this in fact something that we can check
how do we
the verifier choose it around them k / d
of the of the Rose specifies them to the
proofer and now the prover has to open
up the entire pcp for these robes okay
Sam bats and the witness and the entire
pcp for these rows and now we know that
so if we're in this in the first case
what we had so far kind of handled that
if we're in the second case then with hi
pal building when we choose that's a
which is a thousand times K over the
statements with high probability we'll
catch a row which this row is still
something that isn't a language but it's
on the row on which the prove are
deviated meaning that it answered the
PCP queries in a way that is not
consistent with a unique correct PCP you
already if you had more space than
linear mm-hmm the verifier would not be
linear you mean um what was more space
right so the running time of the verify
is meant to correspond to the PCP yes
working within those guys yes yes how we
know you you seen wouldn't wait there's
a unique PCP I mean I like he used to
use another basically know how do I know
that that's nothing so there's a unique
accepting witness that's weird cuz then
we're a new p so he sounds over the
unique accepting witness given that I
can't even say efficiently computer PCP
I can see because because computer
competing with PCP is efficient I'm
given the witness in fact the witness
the PCP definitely contains the witness
inside so I could so right so now with
hi pal buddy I chose a row on with the
proofer deviated now the prover is
screwed right so we need to open up yes
yes ok so just explicitly stay with the
protocol I so this is what we had so far
now in addition I choose a subset of
chaos is roughly k / d of the Rose
specifies a subset of the roast and it
over to the proven and the prover opens
up alright it sends a opens up the
entire PCP on these roads okay what do I
check first of all I check these pcps
are kind of
incorrect and they're consistent with
the answer is that it opened up over
here okay for those PCBs yes what is
actually trivial all right he cannot be
you think we cannot do it in less than
heroes because that I mean it needs an
hour it requires an argument which is a
you need to construct like for this
wrong input you need to construct a PCP
and requires a tiny bit of work I
wouldn't call it trivial advanture right
or sun both the witness in the
randomness maybe or something like
random is for generating the PCP
typically the generation is randomly
check the answers workers we just in the
witness hey what's up yeah over here
sure yes you can actually generate the
given the instance you can generate the
PCP very efficiently yeah but in fact
it's easier right you can send both the
witness and the PCP and then and like
other computation that we use used to
generate and you can verify this
extremely efficiently okay so this was
kind of I hope this kind of convinced
you that this is sound what about
complexity so communication which is
kind of also related to the verifies
running time so just sending over this
commitment thing we had the it had
roughly dear o and M columns so this is
a descending that commitment so for
nothing of it a square root of K of K
okay so this was just sending the
commitment this is kind of just for the
the PCP k PCP answers think of a
constant query PCP though we are not
important and then just opening up I
chose I chose K over the of the PCPs and
asked that we were to open up so that's
for that if you kind of play with it you
can set D which is square root of K and
you get instead of the kind of trivial k
times M get square root of K times Polly
m which is already something highly
non-trivial okay okay so that's kind of
a square root of camera cessation
actually getting this improving this is
a
relatively easy so if you think about so
what was expensive the expensive thing
was kind of when the proof opened up the
entire pcps so we want to avoid that
well what we but what did we actually
want to check so we chose this subset I
of the rose and for each set row we
wanted to check one that the
corresponding instance is in the
language and to kind of the consistency
that the PCP of that of that instance at
a few particular point is equal to a few
particular values all right that's what
we want to check so what we actually got
are just k / d slightly more complex
instances for which which are themselves
in you p why are they and you pee
because given the witness you can verify
if these two conditions given given the
u.p witness you can verify these two
conditions at x is an L and that the PC
P of X I at a few particular location is
equal to some particular values ok so
these statements are also in you p so
just solve that by recursion okay one
thing to make note so you need to be a
little bit careful so if every time you
do this you Yuri encode with the PCP
you're going to get an overhead that you
can't handle so you don't want to do
that but what you can observe is that
the original PCP that we had for X I is
also a PCP for this more elaborate
language right so certainly a PCP for
checking that x is an L and it's also
PCP for checking this condition
condition because this conviction the
condition just says that the PC P of X I
at some points is equal to some values
so the original PCP is still a PCP for
this new more complicated statement I'll
bid with a slightly higher query
complexity know the place that I use
that unique is when I asked to open up
right so this is a kind of crucial point
so let's go back so over here we said
that the prover has two options to
deviate unless Andy of the road that's
fine if they prove it deviates on more
than the other rows then the way that I
wanted to catch him or her is to choose
K over thee of the rows and ask them and
ask the privet to send me a PC peas now
if he has the flexibility to choose
whatever PCP wants from a very large
family
he can't do this you can't send PCPs
that are consistent with the queries
that I previously sent yes well and then
the end opening phase yeah okay yeah
like the first part also requires
otherwise you I mean the it's just the
final deviate just to define deviate you
need some motion yes beware if there's a
unique witness then just if the fact
that the answers to the queries are
verifying then it means that these
answers are unique giving the queries so
that's called the freebie complexity PCP
terms and I don't think I'm not sure
about it but uh right but I don't think
so soon the constructions don't have
that they get not that far together
they're like two or something options
but uh yeah um I think maybe we had an
argument for why you can't have it
exactly but I'm not not exactly sure
right so I didn't actually use it that's
a good point so it was more kind of it
was easier to describe that way so the
way that the actual argument would work
saying if there are more than B
statements that are not or not in the
language then basically this step takes
care of that and if there are less than
D then kind of these same things work
right that's how i get rid of that
assumption the question was so i had two
assumptions when I was one was a kind of
harsh or assumption on the single
deviation and the mother assumption was
that there's only one input nine the
language I'm saying you can easily get
rid of that so if there are more than D
and put behind the language the
subsampling will be fine never a lesson
d then these kind of things are good
enough ok so I'm a little bit short on
time so this we did right ok so this is
just repeating the the parameters that
we just proved what you can get are
using using the recursion ok so
far we're talking about amortized you p
statements to get our constant around
interactive proofs we need to amortize
interactive proofs in fact also here we
kind of know how to do that depending on
your definition but anyhow to extend
ideas of what we did for mp4 the setting
of interactive proofs we need extensions
of the notion of pcps and of unique
witnesses to the setting of interactive
proofs okay so in the non-interactive
case of MP we had this notion of you p
unique NP and we have the notion of like
local checking which is PCP and now we
need to introduce corresponding notions
for the case of interactive proofs so we
call the for the unique thing of the
founder in a second we called it we
called unambiguous interactive proofs
and you'll see why and for the
interactive case we call this
probabilistically checkable interactive
proofs just uh related but different
from the notion of interactive pcps of
your arm so let's talk about both I
think they're kind of both interesting
notions even independent of this work so
what's in it what is in an ambiguous
interactive proof so in a standard an
interactive pool we have completeness in
Sam's right so X is in the language and
we interrupt with onyx provably except X
is not in the language whatever the gene
approver does we reject an ambiguous
interactive proof sort of there is this
kind of unique honest prove or strategy
in what sense is it unique so if you
think of exit isn't the language but at
some point this supposedly honest guy
sends a wrong message not according to
the protocol specification then with
high probability at the end of the
protocol the verify will reject okay
does that make sense and kind of a we
actually have like many of our protocols
actually have this feature so for
example in the subject protocol
classical protocol uh lfk and learned
for now sorry and ambiguous means that
sort of there are many if X is in the
language there are kind of many messages
that you could send and the verifier
would still be still accept
so ambiguous I don't biggest means that
even when X is in the language yes do
not follow the protocol yes I mean you
need to be it's important to you that
it's the coins from that point on um
it's kind of the technical technically
it's important but one thing that I do
want to stress is what does it mean to
deviate from the protocol so you could
like approver strategy in general
specifies for every message what message
to send back and certainly there are
approver strategies which are different
from the honest proofer which will still
make the verifier except because you
know you can change the proof for a
start you staying that if I get the coin
00000 I'll send some weird message so
what I want to stress is that this is
kind of a deviation in practice you
actually sent a wrong message okay and
so the subject protocol and eccentric
protocol and every round so whether X is
in the language or not it's kind of
checked the the Hoover sends over a
polynomial if at any point the prover
sounds a wrong polynomial then from that
point on with high probability of the
verify will reject because these
plumbers have a kind of large distance
and another thing I want to stress is if
you think about this kind of notion
restricted to just a single round and
deterministic and this is nothing more
than the class you pee right so the
honest proofer is kind of the NP prover
has a unique strategy of sending some
witness if it sends any other witness
the verify will reject ok so that's an
ambiguous interactive proofs that's one
notion that we need the second notion
that we need is an extension of pcps to
the realm of interactive proves the idea
here is so it only makes sense for
public going interactive proofs so all
the verifier does a stand over random
point and now at the end of the
interaction the firewire verify would
like to cheat to check some condition on
the transcript the restriction here is
that checking this conviction condition
only makes few queries to say each
message in the transcript ok so we run
like any old public one interactive
proof but at the very end instead of
reading the entire transcript the verify
only reads parts of the transcript
and if you think about it again the
restriction to just one round sending
over one message this is basically just
a PCP so it's kind of a natural
extension it's actually just a couple
weeks ago on a print a paper of Ben
sassone chiesa and summer or summer I'm
not sure which introduces a I think an
equivalent notion that which they call
interactive Oracle proofs but it's
basically the same and let me just
mention without going into details is
that we need kind of to combine the two
in order to apply all this machinery
that I showed you we need both an
ambiguity and this local check of local
chick ability which sounds kind of
paradoxical because what if I deviate on
just like one bit how will you ever
catch that so we need the robust notion
that deals with that which one this one
right so you can say that about PC piece
to write you have an empty witness but
if I could read all of it could read
parts of it um right just like a note so
you're saying you could accept the point
is you can accept languages without
reading the whole yes yes um no but it's
important because the runtime of your
verify earns the complexity that you get
at the end kind of it's a depends on how
much you actually read not on how much
yes right um right so the way that we
measure it so typically we count and
when we count the complexity of the
verifier we count like just getting a
bit on the communication stream we count
it as like work here for this model ton
of course not for the main result in
this model we have all this long
interaction yes look kind of the query
complexity of the verifier yes how many
bits you actually have to read from
define right right you say that's a
perimeter of interest me yes and yes sir
whatever IM guessing that's a no yes
right I'm and um in particular when I
talk in this model when I talk about the
verifiers running time I won't count the
communication
it's part of the running time only the
only the they're very verification at
the end I'm not suggesting this as a
proud of like an actual model look like
Fidel Gainey computation or anything but
that's how I kind of think about it it's
in the parameter seems like you're
cheating a parameter seems cheap okay
you're doing yes okay okay can you see
why doesn't see the cook the very heart
decides where to look only in the very
end so instead he sends during her just
for to help the proof of compute the
next message to help and to get sounds
worried we need yes but I mean you're
right that the I allow the verifier to
toss more coins after getting the last
message from the proof or if you want
you can kind of add a dummy round just
useless you don't force the server to
reveal where he looks at a certain I
mean I could I could also do that
because I could kind of add a I could
send over with my at the last round I'll
send over my pcp queries and the prover
is it's too late for him yes right so uh
so yes so first of all we show
transformation transforming interactive
proofs and to have this structure
reading kind of few bits and every
message and if you do the thing that
Chef you didn't want to do which is
count the verifies running time not
counting the communication phase then
you can actually do kind of better
things because you can get like a verb
right because i'm not i'm not counting
the verifier as communication i can do
even eventually more yeah oh sorry so um
how much time to have nothing minus okay
okay okay um great so we talked about
amortize in do p now we talked about
these notions that we need for a matar
using interactive proofs or these
probabilistically checkable unambiguous
publicity cleese checkable interactive
proofs and just a recap the idea was to
assume that we have these kind of
creatures for computations of length T
and now to use amortization to get an
ambiguous pci ps4 length k times T
computations where the ideas first
approver sends over the K intermediate
steps now we have a kind of K and
ambiguous PCI piece for each one of
these sub computation we amortize all of
them and overall we got a an ambiguous
PCIP for the entire k times tea-length
computation question ok no questions so
one problem I'll do this kind of briefly
one problem that we run into is when
doing these amortizations one on top of
the other the query complexity which
corresponding to the fact back and
amortization at every round of the
recursion our query complexity increased
their it was enough it was not that bad
because we were only doing one
amortization here we're doing the
motivations on top of amortization of
the top of amortizations the Creator
complexity explodes so we actually need
a an additional transformation which
takes an ambiguous PCP and kind of kills
off the Creator complexity reduces it
significantly this is kind of a query
reduction transformation it uses a kind
of PCP like techniques I won't have time
to show you that just kind of the broad
picture is the way that we we get the
computation is doing starting with kind
of protocols for very short computations
just trivial protocols we during
amortization stuff to get a longer
protocol that increases the query
complexity we do query reduction now we
do another amortisation for your complex
to increased we do a query reduction we
do these kind of balancing between the
length of the computation number of
queries and communication complexity
this is kind of in a similar spirit to
the zigzag product construction and II
reached proof of the PCP theorem no just
I just try to say that you need it that
it's like an additional yes
right so kind of the basic idea is to
have to add another message at the end
we kind of sent a PCP of the lot see for
now PCP of the entire transcript and
then what you need to check is that this
PCP is accepting that's few queries and
you need to check consistency of that
pcp with all the messages and because
these are all under like aircraft engine
coatings you can do this you need like a
specific kind of some check like
protocol to do this but you can do it
kind of checking consistency between two
polynomials on some fraction of points
it's actually a little bit more
complicated with that but it's not like
the I don't think is like the main
contribution of this work okay so just
to summarize so what we showed or what I
main result is is these constant around
interactive proofs with linear time
verification for polynomial time and
bounded polynomial space languages we
introduced these new concepts of amer
tising npip and so forth these sorry an
ambiguous interactive proofs and
publicly checkable interactive proofs
and just for some open questions so
going back to the else question so can
we scale up this protocol to get I p
equals P space and this is not
interested interesting only because we
already know that I p is equal to p
space but a more kind of a refined
question is whether we can get AI p
equals to P space where the provers
running time corresponds to the
computation the times it takes to
compute the language which is something
so our result gives us for polynomial
time but you I think it would be
extremely interesting to scale this up
and I think there's a hundred dollar
prize for this right oh yeah um the
second question which i think is of
independent dependent interest is
getting amortization for MP statements
and lastly in our protocol we said the
number of rounds depends exponentially
on one over epsilon which is something
we'd like to improve and the space as I
told you there's this polynomial
dependence on the space where I didn't
specify the polynomial and would be
great to get it down to linear that's it
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>