<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Quantum Computation for Quantum Chemistry: Status, Challenges and Prospects - Session 5 | Coder Coacher - Coaching Coders</title><meta content="Quantum Computation for Quantum Chemistry: Status, Challenges and Prospects - Session 5 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Quantum Computation for Quantum Chemistry: Status, Challenges and Prospects - Session 5</b></h2><h5 class="post__date">2016-07-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/CQ6e9Mge6FA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year Microsoft Research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
so very recently Microsoft Research
created a new group the quark group
which justice' for leads
and we're very pleased to have her here
today to tell us about some of the
research done in that group by herself
and her collaborators thank you thanks
Mike okay so yesterday we had a very
brief tutorial on quantum computing and
a big part that we didn't discuss is the
need to break down a unitary into fault
tolerant pieces or operations that we
can actually perform on a quantum device
and this comes up a lot in the quantum
chemistry algorithms when we have these
controlled phase rotations that
ultimately we need to decompose so today
I wanted to spend just 25 30 minutes
talking about this decomposition process
and the cost and can yesterday and his
tox showed a slide about this with the
stars and the different the different
methods and the cost of decomposing a
single qubit unitary so today we will
dig a little deeper into this and I'm
going to present a new method just
really recent work that I did with my
intern this summer Guillaume Duclos Jian
Chi from Sherbrooke he's David Poole on
student and so so I'll present what we
did so this is going to be on how to
implement an arbitrary or any single
qubit rotation so the problem that we're
exploring here is we want we have some
single qubit unitary U and we need to
decompose it into these fault tolerant
pieces because ultimately almost any
quantum device of course hopefully
topological devices won't require error
correction but almost any device is
going to have to use some form of error
correction and as Ken mentioned
yesterday we know how to do the clifford
gate it within a code space and like the
t gate so we want to decompose into a
basis which means
how to protect and we want to do this
decomposition in a manner that minimizes
the number of ancilla cubits we need to
use and minimizes of course the length
of the sequence we're going to produce
so we want a short you know a small
depth circuit that replaces the original
unitary and of course we also want a
small width circuit so there's some
trade-offs here so in solve a khatai of
decomposition one basis we can use for
for decomposition is this HT basis so I
had a Margate Plus this PI over eight
gate which is a PI over four rotation
about the z-axis and I'm gonna the cost
I'm going to use for the the cost of
these protocols is not just it's not the
length of the decomposition sequence
we're going to produce I'm actually
going to count the number of t gates
that's because the t gate is a non
clifford gate it's not really free in
our code in our codes it costs a lot
more to implement a t gate in practice
than to implement the clifford gates
okay so typically we have to do
something like magic state distillation
it could cost 15 or 15 squared or 15
cubed qubits to produce a single state
for the t gate so the resource is the t
gate and with salah vega type so this is
work that I did with Alex who's here in
the room over here
Alex Pasha and we have we came up with a
a method to improve solid weak solve a
Cateye of decomposition for the HT basis
and these are the results so the
previous best scaling so first of all
actually say solve a khatai of scales
the length of the sequence or the number
of t gates you get out scales as it's
log to the C of 1 over epsilon and this
see typically in practice the best we've
seen in practice up to a few months ago
is typically around 4 and the constants
there can be large so this this work
with Alex and we were able to well see
comes down a little bit but in practice
the order we gained several orders of
magnitude improvement in the length of
the sequence so you have say you know
thousands and thousands fewer t-gates
required in the sequence and and of
course that's for the HTT basis and it
uses no additional qubits so that's
something to note that in the protocol
I'm going to tell you about we're using
it some resource states but of course to
do all these t gates you need these
resource states as well so that's we
cost the T dates the T count so this is
a plot that's very similar to what Ken
showed yesterday but now it's plod
slightly differently so on the bottom we
have the accuracy epsilon to which we
want to have the sequence approximate
our original single qubit unitary so we
have epsilon and then here we have the T
the T count this resource cost that
we're looking at when these are on log
scales and this so this method with Alex
that I just mentioned is this this blue
line here and if you just look at this
perp this purple line is the deal
Nielson Dawson implementation of solid
egg ties so this is this was this kind
of a state of the art for many many
years at least seven years maybe if
you're not doing brute force look up so
brute force lookup is exponential time
so you can get something that's closer
to this if you allow exponential time
but if you only have polynomial time
then the best was this purple line here
and then the method I just mentioned
that Alex and I worked on that brings
down you know several orders of
magnitude better resource count and at
the same time you're getting a much
better you know for a given say I can
only afford a thousand T gates well you
can see you get much better precision on
that decomposition or the approximation
to that unitary these other this blue
and this green method these are two of
the methods that Ken mentioned yesterday
this is Cody Jones's work and others and
this is using this technique called
Faye's face kick back just like phased
estimation and then also this a
programmable and Sylla rotation
technique so you can see that these you
know there's trade-offs in which curve
you're going to want to use depending
what your accuracy needs to be and what
I'm going to talk about today is how we
this red line which is the work that
Guillaume and I have done and so I'll
show you how this works this this red
line yeah so this one here so we have a
so you can do a brute-force search you
can create a lookup table of the minimal
t count sequences and you can do that up
to a certain length so we have a certain
size database that we produce all of the
minimal length T circuits and then we
use actually the Neilson Dawson
algorithm which is a commutator based it
grows like the link to the fifth and so
there we plug in our database into that
algorithm and that's where you get this
improvement and there's more tricks in
there that we can that's why is the
theoretical best which we go yeah it's
right here actually so the theoretical
best is C equal to one and it's gonna be
it follows pretty much like this if you
follow where my laser pointer is yeah
so the solution I'll talk about today is
that the red curve there and here we're
going to use state distillation
techniques to achieve the rotation so
we're not going to decompose into a long
sequence we're actually going to use
resource States to produce the rotation
we need and this is a trick that has
been used in the past and of course we
hope to use fewer resource States or
fewer of the if you want to think about
it in t count cost fewer T count or
fewer resource states than these
salivate I of style methods and the way
I'm going to sorry and when I talk about
accuracy here for small angles it's just
basically becomes the difference between
the rotation angles and we're talking
about really small angles in a lot of
cases here so how do we implement in
general a z-rotation
using a we resource state so this this
this formalism or this technique is not
new that we did not come up with this
and it's probably been known since the
late 90s so we know that we can and this
is what we use to implement a tea gate
for example so here we have a resource
state this Z of theta so this is some
resource state which I'll define in a
moment and we have our state's I and we
want to be able to apply a rotation to
sy but we don't want to do it just by
applying the gate directly we're gonna
do it by applying a resource state and
we also want to be able to do it using
only Clifford gates these cheap cheap
gates if you will
Clifford gates a measurement within the
circuit itself okay so now the state
slide comes in we apply a controlled-not
gate you can also use this to do it an X
rotation but I'm going to go through the
Z the case of performing a Z rotation so
you apply a controlled-not gate and then
you measure and depending on the
measurement outcome depending on the
measurement outcome you'll either
perform the angle or you'll perform the
negative of that angle so here the
resource state we're using is this zero
plus e to the I theta one and of course
the incoming state
some arbitrary single qubit state and
you can now we can step through the
circuits so you see that we start in
this state then we apply this
controlled-not gate which results in
this state here and then we measure and
when we measure we either get out this
state or this state which is equivalent
to applying theta or minus theta so this
is a probabilistic application of the
rotation but we always apply theta or
minus theta results cheaper than
applying bringing something to apply
so it depends what your device you know
the fidelity if you have so it's not
cheaper if you had extremely high
fidelity to apply this rotation because
then you really don't need air
correction and maybe for your algorithm
you know your algorithm is a couple
gates long you don't need super high
fidelity to make it through that circuit
but this is a successful result right
but in general our circuits as we you
know as we've been talking about
yesterday are you know have order n to
the fourth or you know have 10 to the 15
10 to the 15 operations so we're gonna
have to err cracked and protect the
operations because we know that we can't
perform those high enough fidelity so we
have to go about so in this case now
we're going to break it down to
components that we know we can protect
with error correction we know we can
protect measurement and control not so
these are in the Clifford group and
they're easy easy to protect does that
help this is a extra comment
the thing I think which is key for
quantum error correction is you can't
you have to not allow yourself arbitrary
rotations because if you did just be
like an analog computer and corrective
thing
because we still have to do our fishery
rotation pain so that we have these
state tricks to
okay so our one of our favorite non
clipper gates is the PI over eight gate
so let's look at how this works within
the scheme I just showed you so as we
saw yesterday the PI over eight gate is
the rotation about the z-axis by PI over
four and the resource state I'm going to
call it an H state so the resource state
is going to be this state here which
sits on the Bloch sphere right here now
so I'm gonna I'm performing this so I
can actually convert the resource state
I showed you in the previous slide is
actually just if I use this H say it's
applying HS HX to this to this H state
and I get get this Z of theta state that
I have in the previous circuit diagram
so we have I have this resource state
here and then I can just go through the
circuit just as we just did on the
previous slide and you'll achieve either
the application of T or the opposite and
actually you know T adjoint what's nice
about the t gate is its deterministic to
fix this so if I accidentally apply
minus theta in general the next
application of this circuit I have to
apply to theta hoping that I get theta
and then I'm back to the theta I
originally wanted in this case because s
s being the matrix 1 0 0 i s t adjoint
is equal to t so i can fix up my circuit
if i apply minus theta here I can fix it
just by applying s right after so this
is a really nice trick for t gates this
is not true in general s is clifford
correct yeah yes so this this follows my
rules of using only clifford operations
in my circuit thanks Alex what's them to
cost of 99
oh yes I'm actually I think the next
slide I say that I'm making some
assumptions perfect segue so to obtain
the H state we have to use magic state
distillation or that's a technique we
know we can use to get the H state and
there are several protocols so I'm not
reviewing how those protocols work today
because we don't have a lot of time but
there's three great protocols for doing
this one being a really recent protocol
by Camille and his colleagues Meyer
Easton and Camille based on the 42
detecting code and then there's the more
standard one we all typically think of
which is this 15 qubit protocol by bravi
and Kataya there you have 15 you create
15 copies that are pretty noisy of the H
state you basically go through an error
decoding scheme and then you're left
with one H state that is much cleaner or
than the original 15 so and depending on
your base Fidelity's for all the
clifford operations that happen in that
circuit you might have to do this a few
times so you would you know you might
have to go 15 to the N where n is set by
your fidelity and then there's a more
recent protocol by bravi and ha that
looks very promising as well and should
have slightly better scaling than these
others so again we are assuming here
that we have one of these methods to
purifier each States you know even for
doing the Solvay khatai of just a tea
gate you also have to do these methods
for each h state so we're we're making a
fair assumption here it's the same cost
and of course we have these perfect
Clifford and measurements
so I just reviewed all this and just for
notation I'm gonna call this H state
that has power rate as the angles I'm
gonna call it H 0 so if we look at this
circuit so now this is very similar to
what we just saw I'm gonna take in two H
states then I'm going to perform a
controlled knot and then a measurement
and what happens here basically if we
step through the controlled-not this is
the resulting state after the controlled
knot but what's interesting is when we
measure if we measure the state 0 then
the and the probability actually is this
here the probability of measuring 0 is
given by this formula here and the
probability of measuring 1 sorry this is
the resulting state and the when we
measure 1 this is the resulting state
and when we calculate the probabilities
of achieving each of these states we
actually have they're they're not equal
they're unequal right so the probability
of measuring 0 is actually 3/4 in this
circuit and the probability of measuring
one is actually 1/4 so this is
interesting because what's actually
happening is on the next slide I'll show
what I'm gonna assume I'm my definitions
here what I'm actually doing is if I
measure 0 I'm actually moving to some
other state that I'm gonna call H I plus
1 and when I measure 1 I'm actually
moving to a state I'm calling H I minus
1 and when we define what those are
we're actually moving to these states
every time so we're either and you can
kind of think of this moving up a ladder
or down a ladder of these H resource
States so I've defined I can solve
exactly for what these Thetas are and I
know what angles
what resource States I'm producing so I
can use this circuit to produce a whole
set of new resource States noon on
clifford States or new new states that I
can use to perform non Clifford
rotations so this this circuit uses
purely
each states and what's nice is okay so
imagine I start with 2h zeroes here and
I either get out an h1 and on the first
step at the ladder I'm gonna toss it if
it's not h1 if I get h1 I can feed h1
back in with now I use one more h0 state
and now I can go up to h2 with high
probability and then feed it back and I
go up to h3 with high probability and so
on so I'm creating a whole set of H I
States and I have a higher probability
of moving up the ladder
up the ladder than down the ladder so
kind of pictorially what happens is I
feed into h0 States I can move up the
ladder with a given probability and
maybe continue moving up the ladder well
with high probability I'll continue to
move up the ladder and what's that
probability as we move along the ladder
that probability of moving up the ladder
is always between 75 and 85 percent so
if I need to reach some high H I state I
have a really good probability of making
it there and it's only costing me one h0
resource state at each point on the
ladder so why is this useful
so these H states are useful because now
these recall the original circuit I
showed I had some resource state coming
in and I can use that to directly apply
that angle on on a state's I so what
angles can I apply using these H States
well the H States it at all of these red
points if you look at the these
different angles so it allows me to
actually perform these different angles
around the z axis using just the the
scheme of finding the H I I need and
then and then applying that rotation
using the z circuit I showed earlier but
now we don't need something that is
exact we need something that's
approximate so we can use this scheme if
our angles sitting here then we can
slowly start to approximate you know
maybe I'll use this state to get there
and now I have this gap so maybe I'll
use a small angle to get the rest of the
way there and so now I can repeat repeat
repeat and
producing I'm really close to the angle
I need so I used some number of H States
to get there but I can achieve an
arbitrary rotation in that manner so
what what I would do for the protocol
you know it's fine find out what
accuracy I need which epsilon get the
target rotation angle that's close to
that close to the angle I'm looking for
distill the H I state that yields that
angle or that rotation and then I'm
going to run the ladder you know run the
ladder to get it check how far I am and
repeat so I'm going to repeat and tell
them close enough to this very high yes
so we have I'm gonna show the cost and
the predicted it's not a big setback if
you're working on a stove in your stove
you don't fit there so you might don't
throw it away okay yeah nice one so I
still have even if I step down the
ladder the next time I'm likely to step
up the ladder so I'm going to consider
two different costs for the scheme so
the online oops I'm sorry the online
cost is going to be the cost the number
of t gates I'm actually applying to my
state's i right and then the offline
cost is the number of H States I use to
produce the state that I'm using to
apply on-site does that make sense
so we have you know I'm calling this
online and offline because offline we
could prepare the resource states and
they can be doing that in parallel in a
factory so it's not costing me circuit
depth in terms of my computation depth
okay and so for this scheme that I just
presented
we now have C so the C value the best
you can do is one now the online cost
the C value is roughly one point two
three so we've gone from something
that's you know three and a half to four
to one point two three so this is a
really nice nice improvement the offline
cost now again this can be
putting in the factory so we carry a
little less about what the offline cost
is and but the offline cost is roughly
two or 2.22 and so offline is my cost in
a factory how many H states my factories
having to produce to achieve the online
rotation the online cost is the depth
the number of each state's
actually used in basically the logical
computation so for example the Z circuit
will use that to apply the rotation that
takes in some H state and we might have
to do it many times so I talked about
you know compressing this angle are you
a little using a restrictive factory
produces some online application
right but the so a given h state if it's
you know h ten that took additional
eight states to reach eight to ten
because i feed in h 0 to get up the
ladder but i can be doing all of that in
a factory so it's an offline cost i can
pre prepare I can prepare those in
advance so I don't on account the H
zeros
I just want to count how many H eyes I'm
using so here we have the accuracy
versus the cost in in each resource
States and the solid line is the mean
and then we have the deviation about the
mean so on average these are the SI
values we get so I just we have some
enhancements to this protocol which I'm
going to step through very very quickly
so we have other possibilities other
ways to produce a ladder a ladder of
states and this is the circuit for
another possible ladder again using only
H 0 resource States is input Clifford
gates on and measurement and it outputs
a different state given down here also
again with high probability of moving up
here's another one and another one you
can turn to the paper for more details
but these depths are ladder of states so
now recall that before I just had these
red points as the angles I could achieve
but now you can see that we have a
denser set of angles we can achieve and
a denser ladder so we can use this and
we can see how this improves our cost so
now using our denser ladder of states C
goes to 1.0 for for the off I think I
sorry I flipped these graphs apologies
this is a touch to here so C goes to 1.0
for for the online cost and 1.6 for for
the offline cost
so this denser ladder gives us much
better resource scaling
these numbers had or so I think you just
take a little largest
I suppose I didn't make this distinction
I think you want to add well these are
in the total okay so now we can actually
minimize the online cost further and
bring it down to constant and this is a
similar trick to what Cody Jones did in
his work so now instead of doing this
approximation you know apply the angle
do the next one do the next one until
I'm close right which requires several
online steps just try to apply the
closest angle upfront by pre preparing
that state and I may or may not get it
if I may get theta or minus theta but
with 50% probability I get theta so then
I can take one more step if I get minus
theta then I'll prepare two theta so you
can imagine in advance I maybe prepare
SATA into theta just in case I fail and
it was pretty high probability I'm gonna
succeed so now this is what I just said
in words the expected online cost goes
to two so this is two steps you know
purely so now they expect an online cost
is two sometimes it obviously takes more
and then the offline cost is going to
remain this one point C equal to one
point six four so how does this compare
to a traditional more traditional
solloway khatai of here this is just for
Z considered just Z rotation and I have
accuracy epsilon versus the cost this
resource cost the this is the let's see
the full line here this is the solid
makeit I of Dawson Neilson style and
this original purple curve that was up
to the right and then this here is our
offline and then our online cost and you
can see that the scaling of clearly is
much better
for this protocol for most for most
accuracies so if you need an epsilon
that's smaller than ten of the minus
four you know
sorry that's bigger then you can use
salivate type but for anything where you
need really small really high accuracy
you would want to use this protocol and
you can use this for any random rotation
so we know that any rotation is a set of
we can do with an X to X and the Z
rotation so we can use this protocol to
do both the X and z rotations and so we
can use it to any arbitrary rotation and
here's the scaling for any arbitrary
rotation you can see it crosses just a
little you want to use it for just a
slightly different set of accuracies but
the scaling is still quite a lot better
and again here you can use the online
trick I mentioned where the online cost
is just too but here I'm graphing the
worst the worst scenario I suppose and
in the QFT solve a tie with dasa Neilson
yeah I'm pretty sure this guy I might
have grabbed the wrong one this might be
ours but I'm pretty sure it's olive a
guitar with the Nielsen Dauphin
implementation I'll double check yeah is
yours
well it's still pretty much it's pretty
close to this so they would checkpoint
this to look at the temp to the power
minus 8 if you have it you should have
about 3000 feet
so it looks like our oh it might be our
yeah
yes it's ours so this is the quantum 48
so if we're gonna implement the
rotations required for the quantum
Fourier transform here's just a sampling
of you know three rotations that we
would use in that in that circuit and
three different accuracies or three
different epsilon values and then
comparing the Solvay khatai of cost to
these different again online can be set
to two if you like and these are the
primes says we're using the more
enhanced ladder the denser ladder and
basically you can see well the dramatic
improvements in terms of the resource
costs so you're looking at looking at PI
over 16 if you go out to ten to the
minus twelve if you solve a khatai of
decomposition you're looking at 30,000 T
gates required and in this case you have
you know you're preparing roughly a
thousand offline and then at the cost of
two online so this is a really big
improvement and then that's true for any
rotation so in conclusion what I've just
shown is a distillation based a resource
state based alternative to solve a
katara and it has some nice improvements
in the scaling in terms of the resource
cost and also in terms of the accuracy
so it's it's easier to achieve high more
precise rotations as well and so here's
the numbers we've already discussed and
then again you can use this online trick
to get a constant online cost which is
great I also I didn't mention that the
errors are very well behaved in the
scheme as well so we did study how the
errors behave and it might be what we're
looking at right now is how we might be
able to decrease the distillation cost
because the ladder itself has a little
distillation you know some distillation
property to it so you might be able to
feed in an even noisier H state and
still achieve a fairly clean h-i State
so that could save us some additional
cost as well and of course other things
to look at is when would we use these
different ski
it would be great to have a compiler
that says I'm gonna use this scheme when
I need this rotation of this accuracy
and so on so we could choose between
these different schemes it'd be great to
also look at this for other Basie's and
so on so hopefully this gave a
introduction to a circuit decomposition
and thank you for listening
yes you still suffer from this like 50
percent chance speeding rocking and so I
know it
the jones paper he says you pick some
cake
you try k times you cut a new head like
a tiger so is that also your plan yeah
when you do the online that cost of -
yeah so far that's what that's what
we're we that's what we were thinking
with this game is that if it starts to
go - you know you could pre prepare two
or three or four or ten but choose some
threshold and then if not switch to just
prepare you meet you know doing this
other scheme they that has a higher
online cost say we take Matias
Hubbard model pool and we have arbitrary
couplings and then we will what's nice
about it is we can do kind of all of
these rotations of parallel oh right now
you should be waiting here say okay I'm
just curious if I'm curious if the if
the the depth the time deputy blues like
you must lose it some system sucks so if
I have a million sight for my voiceover
thing okay but you're gonna lose but the
alternative is a huge cost I mean all of
these things are probabilistic right
online time all of these schemes are
probabilistic and they're all magnitudes
and magnitudes better than doing the
soul of a cat I have pre-compile you
know your exact circuit and the gate so
you don't ever well in some cases you
still might do that because if maybe
it's hard to implement a factory or you
still need a t gate you know H State
factory so I think in general you're
better off to kind of maybe you can look
into the pre you know preparing in your
factory preparing in advance you can
imagine you have all a bunch of H States
available at any given time point and if
you're wrong maybe maybe you give it a
little extra depth but but I think it's
still even if you end up having to wait
in your circuit it's still going to be a
lot better than doing this all of a
Cateye of sequence where it's paralyzed
from the beginning you already know the
time stuff
I guess I'm concerned about I have to
cut off at some point so be some
probability that happens right happy I'm
trauma rising it'll happen once every
so often someone in terms of like that
the actual I don't know this might clear
to me how much that one and that
algorithm what happens if you these are
tiny rotations what happens if you
simply miss one with funny is that you
move it the other way so I guess you
could skip it once in a while
yeah I think yeah yeah it's really I
think it's worth exploring how which
when to use the protocols and how the
problem you know this is this
probabilistic scheme affects you because
you're doing so many millions of slowly
because it the other room I know a
little look down but make sure the
average comes out to the angle you want
don't make any difference on the result
yes you know just add a comment to this
perhaps there's a solution to this coin
toss problem there's a notion called
forced measurement actually par Sablan
derson in a different different context
as a paper on the archive just a week
ago and so there's an adiabatic idea
where you can deform the Hamiltonian of
the system to drive the ground state
from where it is initially to you know a
fixed outcome and that produces a result
on the ground state which is like contra
accepted without the probabilistic
aspect so it's possible there's some
kind of forced measurement scheme that
solves this coin toss problem so we
should we should think about that great
other questions
their transcendental is that right these
data that you find it's very short apply
I mean they're not particular rational
combinations of PI are they know yeah
well the table was only the red ones no
oh was the table was the table of the
original ones yeah sorry I know
there you go no no previous this one
really I think now that was the only
skills well the very bottom
I thought sorry the cotangent of theta I
is put into I plus theta 0 achieving the
table yeah this is what we saw for the
Thetas that's it
hey for questions so actually I just
wanted to comment this is a really
beautiful work it seems to me that if I
understood correctly what you did is you
didn't solve the problem that so many
people were thinking about instead you
worked around the problem because I
think the way people visualized this
problem of improving solve a kitaev was
to find a more systematic way of
exploring the group out to a certain
radius and you just said well forget
about multiplying the group let's do a
measurement based protocol right yeah
well we started to think about
we started this thinking we wanted to
improve magic state distillation
students and then realize well you don't
we can actually use a similar scheme to
achieve any rotation you're very
beautiful
thank you so last speaker of the first
session Dave record very proud to
introduce one of our chief architects of
liquid is this a liquid tutorial yeah so
this is going to be quick so I apologize
for things flashing by but the idea is
just to give an idea idea sorry idea of
the system this is usually more like an
hour and a half talk with follow-on this
is why we handed out the paper yesterday
for people to look at the overview but
to be honest is 150 page users manual
there's a large API document set and so
forth so we'll just give you a taste of
what the simulation looks like we did
have some basic goals we wanted
simulation environment easy to create
complicated quantum circuits we wanted
to simulation that should be as
efficient as possible as large number of
entangled qubits and sets of them as
possible give you some statistics along
the way here circuit should be
retargeting this isn't just a simulator
stand-alone we want to be able to send
this down to other machinery be it
classical or quantum so this thing has a
life of it
own over time we don't want to just be a
closest and that we throw away and we
want to provide multiple simulation
simulators targeting trade-offs because
there's lots of different things you
want to do lots of different resources
and you should not have to figure that
upfront you should be able to design a
circuit and then try it in different
ways and we want maximum flexibility so
we start from a language in our case the
top-level language is f-sharp any of you
know ml or camel or o camel this is our
version it's a functional programming
language the main reason it was chosen
is because it's compact it's very easy
to write a lot of complicated things
very tightly and it's very provable what
you can do in it since it's functional
there's lots of ways we can optimize the
compilation however you're not stuck
there there's a scripting language so
that if you want to just use this from
an interpreted level if you want to
submit to a cloud if you want to do
things in various ways other than
sitting there in a programming
environment you can do that you can come
from c-sharp or actually any other
programming language that can link to a
dll on Windows so you don't have to sit
in F the simulator itself is written in
it and all of these compiled into gates
gates are basically functions they're
subroutines they call each other you can
define new gates that contain other
gates inside of them and all of this
gets compiled down to be run on
simulators and I say simulators in
plural because we currently have three
different ones there's a universal
simulator which will let you do any
quantum circuit you can come up with
currently in 32 gig of memory you can do
about 30 cubits no restrictions fully
entangled any way you want there's a
stabilizer simulator let you do tens of
thousands of qubits
of course you're trading off here you're
gonna have to stay within the Clifford
group this is basically the equivalent
of CHP from Aaronson and there's a
Hamiltonian simulator we want to get
down into the physics we'll talk about
that a little bit more since this group
will care we have a fairly flexible
Hamiltonian simulator that's extensible
this gets sent down to one or more
runtimes runtimes currently is the
client runtime run this on your laptop a
service which lets you run this across
any number of machines in an HPC cluster
on your land doesn't matter it'll self
install across your land
it's a benevolent virus if you want to
think of it that way it actually
installs as a Windows service on its own
across all the machines you tell it
it'll then distribute your work send it
out to all of them bring them back and
give you results and then shut
themselves down and you don't have to do
any install as long as you have
privileges on the machines that you're
allowed to talk to and then there's the
cloud version run it up in Azure go to
the web submit the script it compiles it
runs it sends your results back but
there's another path these same
functions instead of being compiled into
code can be compiled into circuits
circuits a data structure now you have a
data structure you can manipulate it's a
large number of tools they'll let you
work with these circuits optimization
tools that will let you do anything from
relaying the circuit out substituting
information you can also do things say
for Hamiltonians where we break
everything down into a single unitary
and then operate on a decimated version
of the unitary that understands physics
so we can make the matrices much smaller
quantum error correction I'm not going
to actually show examples today because
I don't have time but you can take any
circuit and say apply this Q ECC
algorithm and rewrite the circuit and
then simulate it for you example steam
seven is built in as an example but you
can put anything in there that you like
solve a Cateye of so the work the Krista
was talking about you can sit there and
say take all my rotations let's replace
them all with my favorite replacement
let's take a look at the gate costs you
can get statistics out of it you can run
the circuits export since the data
structure you can now send this
somewhere else you have two general
choices for backends classical where you
have a supercomputer you want to go out
somewhere with lots and lots of
processing you don't do linear algebra
or you have a quantum machine and you
want something use this as a front-end
to be able to define circuits you want
to compile down to the machine yes that
doesn't exist yet
I get Brian smiling at me but I'm an
architect my idea is to make things not
be obsolete over time so I try to make
sure it'll last at least ten years and
rendering you want to draw pretty
diagrams you want to do things with the
circuits so that you can publish and you
can show what you've done all of this is
extensible so the user themselves can do
what they want on top of it I should
give a little bit of syntax for f-sharp
because you're going to see some going
by parentheses don't mean function calls
they're just grouping arrays are
accessed with a syntax with a dot
between the array and the index lists
have square brackets with semicolons
function calls use white space between
the arguments output can be piped
between functions so I can take F of a
and B and pipe it to G as the argument
that's going into G the empty argument
is just two parens and then we've
implemented our own operators some very
simple ones
the typical complex math you'd like to
be able to do multiplication chronic or
products vectors and matrix alike so all
of that is just very very tight you just
say m star bang m and you've done a
chronica product between two matrices
and you can map a gate to a list of
qubits you can also map it with a
parameter this lets you say C naught
this qubit with all these other qubits
map it across or measure all of these
qubits and do it in one operation and
you can take any general syntax that you
like if you hit head hand it to bang
bang you wind up getting a legal list of
qubits back we'll see examples and some
of the code it just makes shorthand for
quickly operating on qubits so let's do
teleport I'm not going to go through the
actual algorithm I think everyone in the
room has seen it too many times but this
is the simplest thing I could define
let's define an EPR function takes a
list of qubits and it's a Hadamard on
the head of the qubit and a/c not on the
first two by convention every gate just
eats as many qubits off the list as it
needs this way you can have a large
number of qubits and you just hand it
the gate as an argument takes it as an
argument and pulls off from the front of
the list if I ask the system to render
it this is what you get out so no other
code is necessary you just write the
function I want to write the full
teleport again it takes a list of qubits
I'm gonna give names to the first three
in the list so I can use them take EPR
of qubits 1 + 2 C knock them how to mard
them measure qubit 1 do a binary control
gate which is an of an XK on qubit one
is the control qubit 2 as the gate we're
operating on likewise the binary control
of the Z gate that's the entire function
there's what it looks like when you ask
the system to render it done I can put a
little more in I have some dummy gates
like a label gate map it across and now
I've got labels sitting on the diagram
it's not that pretty so I can say we
have a circuit now let's fold it
together and now where everything lines
up pretty and we can see where the
parallel paralyzation can be done in the
algorithm yes change the order of the
qubits it's just whatever order the
qubits happen to be handed so you hand
it think of it as wires and I can hand
any of these to any wires and it'll
figure out where everything goes
should also be noted it's extremely
efficient it doesn't actually expand out
the unit areas across the wires it keeps
everything the size of a C not never
gets bigger than a C not no matter if
I'm applying it to wires zero and wire
37 it doesn't matter
everything still stays as tiny as
possible if the state isn't entangled it
also doesn't make that any bigger and it
keeps sub states that only entangled
together so the use of memory is very
very efficient
we'll show you some complicated circuits
we've got some with millions of gates in
them if I put a harness just regular
language code around it it just looks
like a function the language doesn't
know any different and if I just hand it
the qubits initialized one to a random
state run it look at the output here you
can see we teleported the same state all
the way through and the bits on the end
was whether we measured a zero or a one
to apply the X to the Z likewise the
entire system can be running from
scripting I just want to show what a
script looks like it's not that
important other than there's just a
little bit of a harness of what you need
for libraries you load a script and if
this is run interactively you call the
routine you defined and so it's the same
source language don't have to learn two
different languages but it can be run in
several different ways yes the f-sharp
interpreter run it it'll run it it'll
exit you can also say to it I want to
use a script which will run it but then
stay in the interpreter now all the
variables are available I can sit there
interactively working with the code I
just generated I can say run it through
the top-level executable and now we
compile it we have to compile it into
dll all of your code and then you can
call whatever routine you want and since
you've compiled it later you can load it
if you don't to compile it again and now
you have just a dll that's loaded into
the executable so it's very efficient
there are a lot of built-in gates this
is just a small list to give an example
that they look like standard gates that
we've all seen parameterised gates we go
down to pseudo gates that get more
interesting that are nonunitary lets you
bring qubits back to life once you've
measured them mitigates like binary
control and then things that wrap other
gates adjoint take any other unitary I
want the adjoint of it controlled gates
controlled controlled a wrap gate is a
meta gate that lets you say take all
these gates consider them a new gate so
for instance a qft can become a gate now
you can say in your diagrams what level
you want to
an output do I want to go all the way
down to the bottom do I want to go up to
the QFT
do I wanna see a modular adder do I'm
going to see Shor's algorithm as one
gate and you can lay them all out that
way
transverse is an example of a quantum
erika correcting gate take any gate do
its transverse version and the
Hamiltonian gates
none of these are baked in I'll show you
that on the next slide but you know you
can wrap these together call them inside
of each other so I'm doing measurement
on the head of the qubit and binary
control of the adjoint of a tea gate on
those qubits where the first qubit was
measured you can get things very very
tight easy to work with this is a C
naught then I say it's not baked in you
can redefine anything you want in the
system or create your own so I could
override this gate in this case C naught
has a name some help if you want a
sparse matrix that defines where the
elements are and how to draw it go to
line 0
excuse me right draw a line from 0 to 1
go to wire 0 put a circle that's closed
go to wire 1 put a no plus so you can
set up all the drawing instructions you
want and their boxes and labels and all
sorts of things you can do but all of
those were functions I said you can also
go the other way and make circuits
circuit compiled says take that teleport
function with these qubits give me a
circuit back when I say dump it I get
back out
ok teleport had a hat Ammar to C naught
another C naught this Hadamard these are
the binary the measurements and the
binary controls and since this is a data
structure I can dump this in any format
I want if I want to put this out in
straight matrix format I want to hand it
off to MATLAB or one hand it off to my
favorite linear algebra package or I
want to do this as controls for a piece
of hardware it doesn't matter just data
at that point we can also do some fairly
sophisticated things very easily so
here's just an entanglement test you
notice when we measure we get out all
zeros or all ones because everybody is
entangled the actual code is take a hat
Ammar to the first qubit remember it for
everybody in the tail see not the first
qubit with it that gave us the whole
middle and then finally map a
measurement across all the qubits
and this is pretty efficient the numbers
in the brackets are seconds it took to
operate 0.04 seconds or whatever the
numbers were this was I think on my
laptop here's a little more
sophisticated version where we grouped
these so we can do them in parallel if I
say fold it there now brought down into
a folded form you can see what the
parallelization looks like the actual
code I'm not going to go through because
I do some tricks here on purpose to show
things you could do an F sharp but very
good at list manipulation very good at
data structure manipulation so it's
fairly tight and here's 20 cubits took
two seconds per run to do fully
entangled and this is running out on my
cluster there's 24 hardware threads on
each machine you'll notice the machines
are up around 90 anywhere from 90 to
100% in most cases all 24 threads and
use this is running through did a
thousand runs of 22 entangled qubits in
three and a half minutes and just to
show out of a thousand runs 489 got all
zeros and 511 got all one so our random
number generator seems to work pretty
well Shor's algorithm so everybody
publishes four bits
you know factoring fifteen it's a 8200
gates this is a higher level view
showing the modular multipliers as we're
going through this is using Beauregard's
algorithm we've done 13 bits we've
factored the number 81 89 to show you
how far and that's about half a million
gates and that's running on one machine
each one of these so when I say we're
distributing these our ensembles each
one is running because it's just too
expensive to distribute the actual
computation but this is in under 32 gig
of memory running on anywhere from your
laptop to your server and by the way it
takes about five days so to give an
example this is the modular adder the
actual code that generates this looks
like do the controlled controlled add do
an inverse ad do an inverse QFT this is
the actual F sharp code that generated
this do the QFT do the control add the
CC ad do the inverse QFT clear the Ansel
that you used and finally do the QFT and
the final ad but you can build up a
library than of all these subroutines
that you use and it becomes very clean
very easy to work with to show actual
performance
this is Factory numbers from 45 to 80
189 their factor is the amount of time
it took the blue graph or the blue line
at the top is the first version the
simulator we did the optimized version
v2 and now v3 is in green you notice we
went from 3 years down to 5 days to do
that 81 89 so a lot of performance work
has been done this is a very efficient
implementation and I'm proud of it I
have to switch algorithms I'm using a
memory intensive algorithm and this one
I run out of the 32 gig of memory so I
switch algorithms at that point so let's
talk a little bit about Hamiltonians so
this I left out the stabilizer simulator
completely since again time but I think
everybody here knows what's involved and
it's basically if you know C HP it's an
equivalent implementation for that the
Hamiltonian simulator this will the one
version does adiabatic simulation it has
built-in simulator of doing spin glass
models everything that we've seen
published by d-wave we've tried
implementing and sure enough we can
simulate it and we get their results
which is always a good thing there's a
sample every one of these has samples
built-in we have a ferromagnetic sample
that you build Faro chains and anti
Pharaohs and clamp the ends or not clamp
the ends and just anneal them and see
how they do but again we're a circuit
model so we're actually building
circuitry with rotations and X rotations
and Z for the clamps on the end double
rotations for the joint term and so this
is all just to sync a simple circuit
that we can then optimize and work
within the circuit model
we also added a decoherence model on
entanglement entropy measurement so if
this is random measurement errors we can
also do single bit flip and phase errors
and this is for example a annealing
schedule going up to the right
so as we're annealing through the log of
the error probability and then the
entanglement entropy depending on where
the error happens and so you can just
get an idea of your probability of
getting a correct result and where the
system goes a lot of these things are
now showing his results our papers that
are in progress they should be coming
out in the reasonable future depends how
we get things done again I can do 30
cubits in 32 gig of memory and I can go
so that's I can go up to 30 cubits here
and as you double your memory I can add
a cube it's not a system restrictions
the amount of memory you have so alex
has 192 gig machines so you get a few
extra cubits but you know you've got to
get very big to get anywhere you know
much larger yes yes sorry we did try out
a little work on travelling salesman so
just think of the memory requirement yep
so three cubits is
9 and then they're complex
double-precision complex suffers
so that's 16 right or right so you
should be 16-gigabyte
right and you have a 1 you have an input
and an output vector and you've got a
matrix V matrix multiply matrix in
between or chronicle products so yeah
that's and we actually that we can't
actually fit that in so the full
operation fits we talked a little bit
about we're doing distributed to being
able to go to disp the speeds get
ridiculously slow
there's no point and it's more the
feeling if there's a reason you need a
quantum computer to go to lots of qubits
so if you're 30 is enough you know for
an average machine for people to do the
experiments they need to do to prove
that when they had enough qubits they
could get what they wanted yes someone
did ask me to I have a petabytes store
on the back end of the cluster could we
do 45 qubits because it would fit then I
did the the math for what one gate
operation would cost that everyone
stopped asking
this is Mattias Hamiltonian he gave me
for travelling salesman we're encoding
edges here the problem is without higher
order constraints even though we get the
Green answer which is the right answer
this is just six cities the system says
no no no no you want to salesman on the
East Coast salesman in the west coast
because there's no constraint to keep it
from having a non broken loop so they're
all closed loops but now you got two of
them there's no where it says it has to
be a single loop so you then have to
start adding higher and higher order
constraints every time you break things
but we're able to do eight cities which
is 28 qubits so that gives you an idea
simulation size-wise so we can do H
citty Traveling Salesman we also looked
at adding more sophisticated terms to
the Hamiltonian for instance bite by
doing pair of edge flipping so pairs at
a times that are single edges we're able
to get a doubling of speed and usually
this is where the papers stop that say
look we figured out how to double you
know the rate of getting answer to
Traveling Salesman well unfortunately
it's four times the cost when you
actually do the gate cost to add that
term so there's no point but it's the
type of thing the papers were working on
to show actual gate depths to show
actual costs for doing these sorts of
things
did you know this sense too
compared to code which is written just
to do house onions and we're terrible
and we know it but that's not the point
I'll show you and Matias will give you
some of that I think also in comments I
see him waiting everybody seen the graph
I won't talk about it began I won't say
why it's good do quantum chemistry I
think that's why everybody is here
this is h2 this is from the Whitefield
be aman take paper I should say
Whitfield at all but this is an
automatic generation from the system of
what it looks like this is an example of
our results the blue dots are the
outputs from the simulator it should be
noted that this was done in about a
minute on 20 machines in the cluster to
generate the whole thing so again it is
pretty good at what it does
I should also mention that the the X is
what Whitfield got in our published in
the paper we don't agree completely you
notice we're a little bit lower for the
Blues and actually Matthias did an exact
solution and that's the red circle so we
actually found a couple of mistakes in
the paper that we fixed and this
mistakes in every paper that's okay say
again
James feel that even though oh good he
also sent me the wrong data but that's
that's a separate his grad student had
done it doesn't some work on it and it
was the wrong version that was just had
no way of knowing this is why we need
prop data provenance and version control
and academic work but anyway all of this
those doable by script you don't
actually have to write any code we
actually have a general fermionic
simulator that lets you sit there and
say okay here's the information from
here down is actually the data coming
out of a traditional quantum chemistry
simulator so these are all the constants
and you can tell it things like I
actually want a single unitary out I
don't want to do a full circuit I want
to collapse the whole thing down and use
one matrix and run the whole thing you
can also tell it I want to decimate the
matrix in to physically realizable
values for instance parity stays the
same conserving angular momentum if I'm
looking for
ground-state I assume half the electrons
are spin up and half or spin down and so
we can decimate the rows and the columns
of the matrix and all of that's in here
which now gets us away from quantum
computer simulation but now back to
earth more actual Hamiltonian
simulations so thanks to matthias we
actually got something that isn't too
bad but you're no longer simulating at
what a quantum computer would do so
we've got to be careful how much effort
I want to put there versus how much I
want to put on - this is a quantum
computer simulator right but this makes
it very flexible we can just from the
script level do whatever you can fit
into 30 cubits here's water as an
example so we get some fairly reasonable
results you know it's different than
what either hartree-fock or DFT give us
however when we do an eigen solver
solution again thanks to matthias at 100
degrees and 1.9 for the bond angle we
get we were only asking in this case for
14 bit accuracy and we got 14 bit
accuracy so we're actually right on the
mark of where we're supposed to be of
course as has been brought out before
this is 34,000 gates to do water and
then 2 to the 14th to get 14 bit
accuracy first to get that you need a
Trotter ization of about 2 to the 10th
and then there's 50 samples because you
don't always get the ground-state
so you got to try about 50 times to make
sure you got the ground state at every
point and then there's 546 points to
make a 3d graph here and that gets us
out to about 10 to the 16th gate
operations this is without error
correction without solavei kitaev so
let's talk about that a little bit but
before I do I couldn't simulate this on
the simulator as a circuit there's just
no way I could pull this off in my
lifetime so now we do the tricks we
talked about we can serve electrons we
can serve total spin we make up spins
equal down spins and our two to the 15th
by 2 to 15 matrix becomes 441 by 441 and
since we have a single matrix of course
2 to the K really becomes K matrix
multiplies of itself
and so now I can do this in minutes
instead of years or decades but if we
take a look at the real numbers given
the size of water in a very small basis
the bottom sto 3G
and we now add the Solvay khatai of
rotations the quantum error correction
and the bottom of the graph fell off but
that's okay we wind up at around 10 to
the 18th operations necessary if we look
at ferredoxin which is what I ARPA has
been doing I get up to about 10 to the
23rd operations and this is not
surprising this is where Matias started
yesterday morning so this is not what I
would be trying to solve this was more
to prove that my dog actually barks or
talks not how well he talks ok
we've also lately been working speaking
of the Hubbard model from yesterday on
on doing Cooper it's so this is what a
circuit looks like for I think this was
one pluck head we're doing to pluck
heads currently and we have circuits for
permutations and bases changes and alike
for kinetic energy measurement matthias
previously published work in the area
just to show we get the same results
we're able to able to reproduce the
results and now we've built this version
where we can idiomatically prepare the
plackets
we can join them idiomatically then we
can do phase estimation on them we hand
them over the phase estimator it will
then do energy we can bring it back we
can change this change the the
Hamiltonian like the couplings in it now
you're close you can adiabatic li get
close something else do it again and
alight so anyway there's a lot of work
going on in this area and I'm out of
time so thank you very much it's very
interesting
just curious taking out you know the
physics constraints of
so enforcement number miss is wondering
you know if your yo architectures
obviously more general in the sense that
he was set up to do many many other
things and yes they simulate time
evolution the Hamiltonian so compared to
the code that would do test simulates
evolution of the Hamiltonian but didn't
take into budgeting special symmetries
was the overhead inside your
architecture compared to
you know is it minimal are you saying if
I'm if I am just doing circuit
simulation not doing the this how how
how much overhead there is there because
it's general none there's nothing matrix
matrix vector multiply er we Michigan
affected overhead compared to 1/2 coding
anything on a hard cut no I was at
between the opposite question right so I
was saying if I'm just looking at as a
circuit simulation if I'm doing it as a
like you said as a Hamiltonian simulator
yes factor made at least compared to the
hard-coded compiled version matrix P
operation but you just optimize it
directly right what do you mean by that
so that means what what do you mean by
heart cuz they're gonna do SSA mighty
cold
vectorized optimized code for the kinds
of pity I see one for example we typed
it for the effective age faster due to
memory effects and okay isn't it to the
but yes okay so we say now is to behind
like any well it's like an exact
ionization thing but you applied applied
it to do time evolution yes that would
be eight times more debate that's what
it's about eight times fast you do that
and how much I mean how much
to do it like computer science things
like choice of language and you know
using f-sharp versus some this is a
managed language I don't have control of
the bits at the bottom right
I have no SSE I have no ABX I have you
know I can't do you know the the Curt
the nice vectorizing instruction on the
other hand I can link in pick your
favorite linear algebra library and use
it I'm trying not to on purpose because
we're trying to make a standalone useful
tool you can run on your laptop you
don't need a license for mkl or whatever
you prefer to use but we already have
that available in the system actually we
that's how we do our eigen value solver
for doing entropy and a like we actually
linked in a linear algebra package when
you need that so if you said gee I
really need to get the fast hamiltonians
or the path simulation we could link it
in and talk to it in fact I've been
asked to do that a couple times and I
keep fighting it because I said our
point is to be doing a circuit
simulation for quantum computers and the
fact that we're within a factor it's a
order of magnitude of the hand code it's
I'm fine right I mean this is a garbage
collected lying there's a lot of tricks
going on here to get it this fast today
is is due to no implementation overhead
after you guys have been coming both and
how much is due to the underlying some
choice of F shop in a managed thing
I'd say I'm going like I don't have a
good answer
probably half and half poppies go give
the descriptives and trilliant know how
coded the couplings yeah but maybe more
than it meant be effective for due to
the scripting feature infected to to the
language the speaker's the language
isn't hurting you that bad it's a very
good optimizing compiler but there's
certain tricks I can't do I can't get my
hands on
oh that's how that graph was putting the
bonds in all different directions so
quickly
well the equilibria is that were at the
point where it all came down to bond
that was we showed the equilibrium no we
did both yeah this is that's why ones
bond lengths the others angle and so you
can see and this was the minimum that we
found and that at a specific point I
compared with Matthias as result I also
actually up graphs of hartree-fock and
DFT versus this but I don't didn't have
time to put them up
so they just go get some algorithm home
pod cubed up
we have standard and complementation zuv
that that plug in here we have a there's
a lots of modules to come
great I mean there's there's two methods
because I'm typing positions that's the
spirit
well I just think this is amazing math
work Dave short it's in such a very
short amount of time I'm always
impressed by people who actually
accomplish things I just liked it think
about things so let's thank David</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>