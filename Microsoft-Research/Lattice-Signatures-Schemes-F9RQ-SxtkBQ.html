<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lattice Signatures Schemes | Coder Coacher - Coaching Coders</title><meta content="Lattice Signatures Schemes - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Lattice Signatures Schemes</b></h2><h5 class="post__date">2016-07-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/F9RQ-SxtkBQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
for Speaker of the afternoon is our
wedding of shamsky he is a researcher at
inria EMS palace he received his PhD at
the UC San Diego and was a postdoc at
Tel Aviv he works in let's paste crypto
in particular fire to design derivatives
that can be used in practice and they he
and his colleagues introduce and prove
the security of ring sis ring lwe
assumptions which have formed the
foundations of most efficient lattice
paste primitives what do ok so thank you
sachin thank you for inviting me great
ok so today I'm going to talk about
lattice signature scheme so I mean I
lattices have been pretty popular lately
but so one thing that you hear a lot in
the introduction of lattice papers is
that you know lattices are you can do
anything with them and you know you can
even it can even be efficient so you
know it's exciting efficient but the
thing is it's true but those two sets
are quite you know the intersection of
exciting and efficient this Court is
almost zero so you know the exciting
things our fhe multilinear maps yeah i
mean that's let's rooming that's really
exciting stuff they're not theoretically
it's amazing efficient I mean not even
close so the efficient stuff comes from
the kind of the boring primitives that
are like public key encryption digital
signatures but even that until recently
it's not been known whether you can
actually do even the boring stuff
efficiently so I mean lattice is like
well like a long mentioned some things
I'm going to disagree with them beep so
you know lattices they gained popularity
as a theoretical topic so there was the
the great result of aight aight about
the average case to worst-case reduction
and for about ten years this is what
people cited like oh you know why do you
want to use lattices because it has a
worst case to average case reduction
even though really in practice you never
do right but that was the only thing
that we had
odd so we always cited that and that's
why lattices are important but it turns
out that you actually do things
efficiently so now I don't think we have
to lie and say you know we're doing
things based on average case worst case
reductions really are not right i mean
that we never said i wasn't a question
but i wasn't saying you in particular
but i mean the average case divorce case
reduction is really nice because they
they tell us oh you know these are the
hard problems but then when we actually
set the parameters they're not in the
region of what average case the worst
case reduction tells us so so to kind of
understand what the how to build
efficient things it's actually important
to know how lattice reductions outdoor
the Performing practice so that was sort
of dumb eons talk and understand what
are these average case problems how hard
are they average case problems in
reality and we don't really care about
the what the worst case problems are
okay so this is important to keep in
mind for what I'm going to talk about
and sort of how improvements come about
so these are not theoretical I mean
these are theoretical improvements but
they're actually also improvements in
practice that come from understanding
how hard these average case lattice
problems are okay so now i'm going to
say that all lattice problems are really
just the more fancy way of saying
knapsack problems so knapsack problems
are very popular in the 80s bad
reputation so we start saying lattice
problems but it's really just the
knapsack problem okay so so the knapsack
problem is the following yeah but you
have a matrix a right so there's a lap
sack over vectors right not all the
integers nothing special so a is random
in over zq and then there's some small
vector in the Z q that you multiply by a
so by small i mean let's say small norm
okay so not not zq but you know
something smaller and the result is t 1
q and the question is well given a and T
the blue thing can you find some s so
that a s equals T doesn't have to be the
same as right because if s has a lot
more entropy than then T then you know
there's not a unique s so you can't
really force somebody to find that as
but just find some
more or less so that a s equals T so
this is it this is where all the lattice
cryptography is really based on right
it's I mean so so it's important to
understand the hardness of this knapsack
problem so so you know this is a very
sort of unscientific graph goes up and
down but it really does look like this
it's important to know that there's some
point as you increase the norm of s so
let's let's kind of take s to be very
small right if s is very small then the
problem is not hard because you know
let's say s only has like two ones in it
so the norm is small well you can find
those two ones just by exhaustive search
so over here the problem is easy then it
gets harder and harder and harder here
actually the way best way to solve it is
through the lattice reduction actually
the thing that Tamerlan was talking
about how to solve cysts using lattice
reduction then at some point the problem
kind of becomes the hardest and then he
starts getting easier and easier and
easier and if you think about it if s is
if there's no restriction the size of s
then the problem is very easy just by
Gaussian elimination right so so here
it's easy here it's easy so at some
point it's hard and it's actually hard
exactly when the entropy of s is like
the same as the entropy of T so there at
some point where there's almost exactly
one solution this is where the problem
is hardest so what we want to do I mean
forget about all the worst-case average
case reductions is we want to design a
problem that's based on this problem at
this point right this is this is what we
try to do in lattice reduc in the
construction okay so now you know more
if you want to be more theoretical right
you you have these problems called sis
so small into your solution and that's
usually referred to that's when there's
lots of lots of s so that a s equals T
and if there's lots of s then in fact
there's some s that a s equals zero and
that's the that's the sort of the
standard definition of sis and on this
end is the learning with errors kind of
a really restricted version of a
learning where there is actually a
harder version of learning with errors
where you don't have many samples right
and that's so it's actually so I would
say that the learning with errors
problem is an overkill if we're trying
to base it on that because we never
almost never have an unlimited number of
samples that we can waive access to to
solve the problem so usually have just a
few samples and say okay find the s okay
so this part is the learning with errors
part okay a restricted version so right
the SIS one is that for all so the SIS
version is where like I said for all T
there exists in s let s equals T so
classics is T equals zero and so here
are some results that i will talk about
right so kind of early on we we realize
that you could build signature schemes
based on the cysts problem and in fact i
should mention that the cysts problem is
in theory harder than the lwe problem if
you can solve sis you can solve lwe so
it seems like what you want to do is
base things on sis but that's that's
kind of missing the picture of trying to
bit trying to build schemes based on
sort of better hard here right we don't
really care what the names of the
problems that we want kind of what's the
name what's the name what do you mean
what's the name I mean I mean this is
this is where like Ella we becomes sis
but may I don't know like at some point
right there kind of almost the same
problem the reduction is a sort of
equally hard so but but the thing is we
can never build anything based on this
so you don't have to worry about that
that has never come up here well I guess
no no I mean you would call it this
right because a collision resistant hash
functions are really up here so we call
it sis because that's stronger than all
the way but anyway so okay so we can
build signatures based on sis and they
are kind of over here right this
hardness but what I'll show you is that
really what you want to do is build more
efficient signatures based on lwe and
they're kind of on a line over here and
you'll see why we're actually why this
point is going to be higher than
for you know I labeled nothing but
you'll see what's going on and results
extends I'm not going to talk about the
ring version of the ring scissoring lwe
I'll just talk about sis and elderly and
everything will extend so completely
naturally to those two okay so just to
review of digital signatures I don't
know if anyone's not a cryptographer
here but let's just do it anyway so you
have the key generation produces a
secret key in a public key to sign a
message I you you know you use the
secret key sign mi and produce the
signature SI and then the verification
under the public key of the message and
the signature should say yes or no and
hopefully every time you sign a message
with the secret key it verifies with the
corresponding public key to yes and then
security is unfortunate e the adversary
gets the public key he gets to ask as
many signatures as he wants and then he
has to output a new message signature
pair so that it verifies to yes okay so
this is the sort of accepted definition
of signatures and it's secure so I guess
in classical cryptography based on
discrete log RSA stuff like that there
are two ways to do signatures and I will
only care about random Oracle signatures
because you're trying to be efficient so
no one practiced don't no one really
cares that random Oracle don't really
exist okay so so you have a hash ensign
so this requires a trapdoor function I
guess based on our essay you have hash
ensign signatures and then there's the
fiat samir transformation which converts
which gets a signature scheme from an
identification scheme and no trapdoor
function is needed so I I will I mean
most of the talk will be spent here but
I mean there's some really nice ideas in
hash and science i'm going to review i'm
going to talk about that as well I'm
sort of a survey right so so here is
hash ensign signatures based on cysts
from GP v 2008 so Gentry piker twinkle
Jonathan I'm 2008 all right so let's
let's think about let's talk about what
a lattice is all right so this point
this is all these points that's ZN ZN
okay the green points they form the
lattice so here are some green
points okay greenpoint green I'm not
sure how good yeah I think Green is a
pretty good color here it doesn't look
like any other color on the screen okay
so here are the green points if they
form a lattice now all the other points
that are not lattice points they are
actually representatives of co sets of
ZM mod the lattice right so let's define
the lattices sorry so I'm going to
define the lattices let's think of it
why as a such as a y equals 0 mod p
right so all of these are lattice points
and I can find an a so that all these
lattice points when multiple when a is x
then give you 0 mod p okay so let's
actually say we start with this and this
is this pictorial representation okay so
you can check that it's a lattice
because it's an additive group and
that's all you kind of need all the
points Y and all the other colored
points not the green points there cosets
of ZM marvelous ok so so the red ones
for example all the red ones they're
just offsets by the lattice of each
other so so now we have we know that a
times any green vector is 0 mod p a
times any other color vector what's a
yellow is going to be something else mod
p that's not 0 okay but it's always
going to be the same right a times any
yellow point is going to give you the
same thing here right the same in coding
theory syndrome over here and now
there's her GP v sampling works you have
your a and you have some secret bases T
and this secret base is T has short
vectors in it that's your trap door what
you what you can do is give an A and
some syndrome be you can find you want
to find an S so that a s equals B right
that's what you want to do so for any be
this should output a short so given a
and B it outputs a short s so that a s
equals b mod p ok this is what GP v does
not going to explain how it does it but
using a trapdoor basis and they it can
do it all right so now the important
properties that we need is the
distribution of s only depends on the
vectors comprising T so this is the
really crucial part it doesn't depend on
T itself I mean it has like lots of
vector T has some vectors in it
particular vectors but the distribution
of s does not depend on T it just
depends on the length of the vectors in
T okay so this is sort of the whole
heart of the GPB sampling algorithm
right it's easy actually to get an S so
that a times s equals B when s kind of
depends on T but then that's not good
because s is going to be our signature
so you don't want to leak out t you want
s to be independent of T and so GPB
sampling does is the following so there
you have some syndrome be it's going to
find some code cept representatives of a
times this equals B but this is actually
easy to do if there is no restriction on
it being short you just use Gaussian
elimination you find some red vector so
that a times radicals this closer so
let's pretend it's this one okay let's
say we found this one very easily no
problem so what GP v actually does is
then given this it's going to find a
lattice vector that is pretty close to
it but not doesn't have to be the
closest one but somewhat close to this
this vector here now by translation you
can then you can just sort of translate
it to make this lattice vector the
origin right because this is just the
lattice vector we can get it to be the
origin okay and then this turns out to
be a somewhat short vector right because
this was original vector this was a
lattice point close to it we translated
it down we did this sort of parallel so
this is now a short vector and a times
this minus short my a minus a lattice
vector which is short equals this
because a times green is there okay so
this is how you so GP v I mean that the
hard part is given this find the short
here right but once the GP v does that
we can find the short s so that a s
equals B so one of the properties that
are needed for 4s well like I said
before distribution of s only depends on
the length of the vectors comprising t
we'll see why in the proof and the
following should produce the same
distributions of SB so there are two
ways so one way is for to look forward
one way is going to be how the
signatures actually produced and the
other way is how the proof is going to
do it in the simulation and you want
those two distributions to be the same
for the security okay so the following
should produce the same distribution of
s and be the first thing is the honest
way is you choose a well-loved down this
way actually this is the dishonest way
is you choose an s according some
distribution and then set be equal to a
s okay that's so this is sort of the
obvious thing right you pick an s eight
times s equals B that's it the second
way that should produce the same
distribution of s and D is to choose a
random be first then run GP v use T to
find an S that a s equals B and so given
those two distributions you know either
either come from a and B and E you
should not be able to figure out where
it came from okay so this is what they
have and so this first property is
guaranteed by the GPB algorithm and the
second property is true if s has a large
enough entropy to make a s equals B
uniform mod p so when s is big enough
entropy a times s will be uniform all
right so now here's the la Hache ensign
lattice signature your public key is
going to be a this matrix a you can
think of it kind of making a lattice you
know in the way I described before and
then your secret key is going to be this
basis the short basis for from the
lattice so the public is a secret keys t
to sign a message m the first thing you
do is you construct be by applying the
random Oracle H which is a random
function to em so now you get B equals
hmm
you use the GP v algorithm to find the
short s that a s equals B and then s is
a signature of them that's it it's
actually quite simple and elegant and
then the verification just sort of does
the obvious it checks that s is short
and that a s equals hmm all right and
here's how the security proof works
let's say we're given an A and we want
to solve the system meaning we want to
find a small vector I don't know call it
Z so that a Z equals zero well we
obviously do not know short vectors in
the lattice form by a right so the
adversary when the adversary asks us to
sign a mess so we give eight as the
public key to the adversary so in the
adversary assets assign a message we
obviously cannot do it honestly so we
have to play a random Oracle tricks what
we do is we say ok we pick the signature
so we say ok this red thing that's going
to be the signature from the
distribution d then compute a times s
it's going to equal to something and we
say oh that's hmm i right so then we
program the random Oracle to say this is
hmm I I mean this is how all the passion
sign proofs work right ok and then we
give the signature in the output of the
random Oracle and the output of the h of
mi to the adversary and he said well
yeah ok that's correct I guess ok so
sometimes the adversary may also ask you
for a random Oracle query no problem we
can give them a random Oracle query we
just choose an MJ which sort we just
pick a random element say that's H of MJ
but what we but that wouldn't be good
because things will go wrong so we
actually want to every time he asked for
random Oracle query we actually do want
to pretend he's asking for signatures so
we ought to also come up with a with a
signature if he were we don't have to
give it to him but we come up with it
just in case ok so now at some point the
adversary's ready so he's ready to forge
so he says I will forge a signature of
em we say great
24 jan m though the adversary needs hmmm
right i mean because he's going to come
up with an S let a s equals a hmm well
how does he know hmmm he have to have
asked it of us so at some point heat
must have queried the random Oracle on
them and asked us for hmmm ok so m is
that one of the MJ he asked for HR MJ
well therefore by the way we did things
we actually know in SJ so that a SJ
equals eight equals H of MJ so here is
our SJ that we program that we chose a
while ago so we have a SJ equals hmm J
and now here is the new mess the new
signature that the or random Oracle for
that the adversary forged but their
equivalent a times our thing equals a
times history ok therefore the
difference of these two things
multiplied by ay is zero and that's the
solution to sis so these are both short
and hopefully nonzero and the reason
it's not zero is that for R and it's
like it's this entropy argument again
for random be there is more than one
likely possible output so it's actually
statistically impossible for the
adversary to know which s we knew right
because there's lots of possible s for a
given B so that's it yes there's nothing
really here ok so that was that was
hashing sign signatures ok so there's
questions about that we can condense
answer some if not we move on to catch
yeah yeah this is exactly the full
domain hash
ah so you're asking about the reduction
tightness about not care about the query
so I'm saying this is already tight so
so here's but this is this question
always come up comes up and I'm happy
that I can finally answer no no so so
you're you're thinking of the for
example the RSA things right where you
have to guess which for which on which
message he's going to query right so the
reason you have to do that is because
they're there was no hash function this
RSA function this the equivalent of a
times s was a was injective right there
was no there were no there were no 2 s's
so that a times that or no access to the
g times x1 equals G times x2 g2g to the
x1 equals e to the X 2 right here on the
other hand we're choosing it so that
it's not injective it's actually quite
you know lots of collisions happen and
for this reason we never have to guess
which thing and actually so if you know
the way that that all the trick the one
the trick I mean the only trick I know I
guess think it's cats wrong that kind of
makes it more tight is they did exactly
the site this idea of introducing
collisions into the RSA signature right
so but here we already that's already
our problem that's already our hard
problem sis is so it's ok so there's
there's no problem with ok that's a good
question
okay so let's move on okay so now we're
going to do Fiat ramir alright so here
is the main idea and if you think of if
you notion or signatures think of shin
or signatures a little bit but there's
going to be a major difference but we
won't get to it yet okay so the secret
key is going to be a matrix s and the
public key is going to matrix a and a
matrix t which is equal to a s to sign a
message mu so I mean you know if yet
Ramires comes from from transformation
from ID schemes but i'm not going to
show the ID scheme but it should be sort
of implicit okay so you pick a random
why compute the challenge challenge
equals H of a why mod Q and the message
and then output a possible signature Z
equals SC plus y so everything in orange
is sort of represents elements that are
small and everything in black elements
that are big right just so don't worry
about what small and big means but just
the you know if it's small enough so
that like small x small is still small
so if there's a small vector matrix
multiplied by a small vector it's still
the result is going to be a vector with
small enough coefficients okay so
small-time small is small alright so
this is the signature that we would try
to do if we just did straighten or you
know take snore uh sorry what
but sorry C equals yep er yeah what do
you mean I'm making no I'm not making
sure monistic this is this comes from
ident identification scheme where the so
there's three steps right commits the
challenge response right so so the
commit is a why the challenge is see the
response is Z right but if it's a
signature scheme I'm playing it with
myself so you have to kind of trust me
that the commitment is random oh sorry
the challenge is random so the challenge
the challenge is a function of the
commitment because the challenge has to
come after the commitment no then it's
false then it's then it's not secure
because if the challenge depends only on
the message I can just I can just commit
compute the challenge for any message
and and then we go backwards and figure
out with it ok ok so and the output is
zc ok this is what what we want to do
but this doesn't quite work so
verification but it's something close to
it will so here's the verification of zc
check the z small and that C equals H of
AZ minus TC mod Q again if you know
snore you can probably sort of map
things to exactly this ok so why does
this work well because AZ is TC plus a y
minus TC just leaves you a why here ok
so this verifies correctly and the
reason that z small is because
small-time smallest all right so here
are the two things that we want and that
we had in Schnoor is that given the
public key the secret key is not unique
well we actually did not have that
engine or but and we don't need it here
but let's for the proof let's just
pretend we will maybe think of it as a
komodo think of a locomotive ski maybe
that's a better analogy for this okay
and then the I think I'll come up
there's definitely a better analogy okay
and then the output is zc and what you
want is the signature to be independent
of the secret key okay so these are the
two properties that we want which is
kind of the same thing we wanted in the
in the hash ensign we wanted the public
key the secret key is not unique and you
want the signature to be independent the
secret key so these two things we always
kind of want well no matter what you do
and here's the security reduction in
case that holds okay so we get our
challenges a we have to find the short
vector so that a times this vector is
zero our simulator picks a random s
gives a and a s to the adversary as the
public key the adversary asks to for
signatures of messages the simulator
actually knows the secret key so he can
give signatures of messages no problem
at the end the adversary forges on miu
gives zc then if you know the forking
lemma he give we get him to produce Z
Prime and C prime for the same message
mu if you don't know the forking lemon
think of rewinding if you don't know
rewinding just think of me I don't know
I think of the previous thing we did
it's not related to this but if you
understood that that looks better than
that understanding in I don't know I
don't know I don't know so so at this
point that you kind of its new BF yeah
okay so let's pretend we all know about
forking my motor rewinding if you know
both they don't think of forking them
and
okay so now what you get if you have to
see two different signatures for the
same message is that you get that a
times Z minus Z prime plus T times C
prime minus C equals 0 it's just because
the two random Oracle queries have to
have the same input into them okay and
the input was exactly this so okay let's
and then you just buy separate since you
know the T equals a s you get a times
this equals 0 and you hope that this guy
is not 0 right if this is not 0 then sis
is solved and so for this for this thing
in the middle to not be 0 it's important
that the a dresser does not know s
because if he kind of knows s then he
can he can actually do the honors
signature you know he's signatures could
be the honors signature and then
obviously it's going to be as it's going
to be 0 right if he signs this using s
the way you signed it then this is going
to be 0 right if it weren't then when
you you could you know celsus yourself
but you could just sign with be honest
as yourself and somehow get a collision
you'd be done okay so you're asking me
why the for what is the forking them and
why does it work so the idea is the
following so do you know rewinding okay
okay so we can we can work with that say
okay so in the rewinding right you have
the the challenge right and them the we
rewind the adversary to answer the same
challenge twice okay the only difference
with signatures right is that you can
kind of you give them outputs of the
rent what so you give them outputs of
the random Oracle right and you know
that what these outputs of the random
Oracle kind of servers the challenge
okay except so at some point you change
the output but the only difference is
that you don't in signatures in
identification schemes when you do this
rewinding the adversary has to reply to
those challenges because he's in the
stage of the
security reduction where he has to reply
to the challenge whereas in signatures
right you have no idea what he's doing
right he might just out of curiosity
query something you have no idea when
he's going to forge so that's the
forking lemma kind of says well you
guess which of these is going to be the
important one then you change it and
then you change everything afterwards as
well and if that really was the
important one he has the probability you
know that a forging probably epsilon its
epsilon square okay is that okay all
right yeah yeah you have them you have
the you know here you do have the
tightness gap yeah okay so so the
security reduction is right basically
from this you get a solution to sis and
what we want in order to get this
reduction we needed two things right
when you get the signatures ec to be
independent of s so that this thing is
not 0 this thing is not this thing in
the middle is not 0 and for this to be
small right because if this is not small
then you know the signature verification
fails as well alright so now I'm going
to sort of make an important interlude
that's kind of really at the heart of
even though it's really simple but it's
really at the heart of improving this
efficiency of all these signatures okay
so instead of basing six teams on sis
why do you want to base it on lwe okay
so the things i said is the file of the
following you want given the public key
the secret key is not unique and the
signature is independent of the secret
key okay but what if given the public
key it's just computationally and
distinguished over the secret key is
unique this would be okay to you use the
hybrid argument maybe in a sum you know
just be careful it should work okay but
why do you want why would you want to do
this right i mean the proof can can be
modified to work but why you know the
question why would we want to do this
and here's the answer is in this graph
right so notice here when we had Z
equals s times c plus y even though zzzz
small it's still a little bit bigger
right it's because you multiply s by C
so the size of Z is bigger than the size
of s okay so the hardness of solving sis
is if you saw in the proof it was like
our the vector we found was somehow
related to Z it was Z minus Z prime plus
something okay so the norm of Z is
really important to the hardness
subsists the bigger Z is the easier the
problem is so you want to keep Z small
on the other hand you also have this s
and when I said given the public key the
secret key is not unique s must also be
in the region where there's lots of
possible SSO that a s equals T so s is
also in the SIS region so here's what it
looks like if we just think about what
the hardness of finding s is and what
the forging signatures right so here was
s s we just needed s to have you know
kokino just force a collision just one
collision so s could be you know as
close to this point as you are ok but
now the hardness of forging signatures
was not really finding s it was finding
something on the order of Z and Z was
bigger than s by a gap of about rudin
well more or less well we'll need it to
be more but I mean rude n but it's
because of something else that comes
later but anyway there's a gap ok but
now since there's a gap we move down on
the hardness of finding of solving sis
ok so the idea is the following well why
not move the secret key over here you
still have this gap and then the
hardness of forging signatures is on the
same level as the secret key so but the
secret key is now based on this problem
on the other side of the graph which is
lwe whereas sis is still forging
signatures distances so and this
actually saves a lot ok so this is why
we this is why we want to have a secret
key based on lwe rather than sis ok
that's why we don't want this many
secret keys for the same public key
thing
this is yeah I mean this is what you
want to do right because exactly it's
the minimum view if you go over too much
then okay yeah forging signatures would
be really hard just by just looking for
Z will be really hard but I mean that
silly you should just look for the
secret key this is the best practical so
you wanna you want to actually you know
figure out what these graphs are right
and then put your secret key in this so
they're at the same level okay so
alright so now the signature scheme okay
let's go back to the signature scheme so
this is why we don't want s to be too
big alright so now how do we pick a
random why right can we make Y uniformly
random mod Q know right because then Z
equals SC plus y then Z will be too big
and cysts and foraging will be easy so
you can't have Y uniformly random mod Q
okay because size of Z depends on what
can you make why small well I mean if
this works then why should be small but
can just make it small and that's it
well no because then in this case Z will
not be independent of s because when you
output SC plus y if Y is not too big
just think of coefficients of Y not
being too big then SC plus y may leak
something about s and C right if let's
say let's say just say why is like 0 1
coefficient then if you know them you
know if you get something Z that's too
big that's sort of the maximum it could
possibly be it tells you something about
the coefficients of SC so that's not
good either so what you want to do is
rejection sampling okay so you want to
keep Y small but output Z see only if Z
meet certain criteria otherwise repeat
and just do this a few times pick a
random why do this if it doesn't work
okay try again you want try too many
times and but if it if it out put
something okay you're done all right so
here's what rejection sampling is let's
say
have access to some samples from G of X
this is a distribution you have this is
some reason this is all you can sample
but you don't want it you want f of X ok
you want this distribution so how do you
get this red distribution if you only
have access to the green distribution ok
I don't know who is the first person to
ever come up with it if you ask somebody
they say it's that person from their
nationality so they just go back a few
centuries and say it's so I don't know
who did this but anyway so the idea is
you sample from G of X but you only
accept X with probability f of x divided
by M times G of X where m is some
constant so that f of x divided by M G
of X is always less than or equal to 1
okay because otherwise it doesn't make
sense to accept with probability if it's
more than one okay so and you can see
that this is sort of obviously gets you
the right thing right because what's the
probability of getting X its G of X so
the probability actually selected x
times the probability that you will
actually output it which is f of x
divided by M G of X which is just f of X
over m so the probability of you
outputting given that you output
something its distribution is going to
be exactly f of X there's this divided
by M by M is a constant so all it
controls is what's the probability of
rejection right so you will actually
proud put something with probability 1
over N so the expected number of times
you need to do this rejection sampling
is M ok so you don't want em to be to be
alright so something is output
probability 1 where m so the nice thing
here is that well let's say you don't
have access to G of X you have access to
H of X but you still want to get f of X
no problem right as long as f of x
divided by m for some m fits under
underneath both of them it's ok you
rejection sampling we will work no
matter if you start with G of X of H of
X and nobody can actually figure out
which one you started with first G of X
or or hrx all right so this is rejection
sampling it's impossible to tell where
the G of X of H of X was the original
distribution which means that the
original distribution remains hidden ok
and the original distributions if you go
think about what we're doing is that
original distribution is what depends on
our secret keys the secret key stays him
as long as the original distribution is
always above f of X / yeah all right so
here's the idea you take it so these are
really terrible gaussians but they're
gaussians okay so you take a pick a
random why but you pick a y from this
distribution from some Gaussian
distribution or whatever it is now y
plus SC is just the shift of Y in the
direction of SC right so this thing this
green thing is going to is the
distribution that we end up with but we
want to hide it because it reveals SC
well but so the distribution we want for
Z I mean we can choose any distribution
but it turns out they're good one to
choose is actually the distribution of
the original distribution of Y okay so
you want to end up outputting this red
distribution but you have access to
either this green distribution this
purple distribution or really anything
that's an offset of this district of
this red distribution okay so maybe i'll
skip the through more mathematical
things the normal distribution I mean
actually honestly I don't really know
why it's the most useful thing here but
they turn turns out the normal
distribution gives us really the best
way to do rejection sampling well some
some way of using the normal
distribution it's just you know you want
two distributions that when you shift
one they kind of gives you back what you
had before and normal distribution seems
to give you the tightest the thing so
okay so here's the normal distribution
whatever it is doesn't matter it's
centered at 0 standard deviation Sigma
here's an example okay here's you know
one normal distribution here's another
one with a bigger standard deviation
then they can be shifted right so by
shifting you just you know subtracting
the exponent then n dimensional normal
distributions are exactly the same thing
as one-dimensional except now you're
dealing with norms or vectors in the
exponent rather than
just integers okay so here's a two
dimensional example of a normal
distribution okay what do you expect so
then there's the discrete normal right
which is so what I showed before was
continuous but here we only care about
discrete normal meaning i want the
distribution to be centered on integers
on ZN so I mean that that's also i mean
you can define that right but just the
distribution will be defined you know
probability of x is the you know the
normal distribution of x evaluated X
divided by the sum of all the I mean
just to normalize you if they're divided
by the sum of all the integers the
normal distribution evaluated all the
integers I mean nothing just normalizing
okay so now here is rejection sampling
right you want to figure out what is the
maximum value of s times C because that
will that will explain that will give
you what is the biggest shift right
because the bigger the shift is the
harder it is to fit your original
distribution underneath the old all
right the bigger the shift is the more
they're going to look different the more
different they look the harder rejection
sampling is to do okay so right so then
you take your red one and you shrink it
by some factor M to fit underneath both
of these the problem is with gaussians
they will never fit right because at the
tails the ratio is gonna actually kind
of the ratio increases at the tails and
so it's going to be for any m this green
one is always going to be below the red
one over here and this is bad but that's
okay these are events that will happen
with very little probability you will
with very small chance will be actually
out we actually pick something that's
over here so it's no problem I mean you
have to kind of be careful right you
have to make sure to pick an M so that
for you know four points that are really
far away but it only it doesn't work
four points really far away so okay but
we can do that so what turns out that
for if Sigma
standard deviation of our you know the
Gaussian that we pick the Y from and
that we want the Z to be from is bigger
than 12 times this maximum then we're
going to then the we're only going to
have to repeat things with the about e
times so 2.7 times okay so if it's 12
times bigger the red thing fits under
the under any shift okay and this 12
comes from the fact that it's very
unlikely to get something within 12
standard deviations of a Gaussian okay
so so now I mean there's this 12 right
only the 12 again comes from the fact
that we want all but the very very very
distant points to fit underneath but you
still have to multiply by this 12 to
make sure that the points that are far
away but not that far away fit right and
the problem is with the tails so this is
where sort of the the mountain the math
thing comes in right we want to try to
improve rejection sampling aa-12 is what
you if you want to to the minus 100
statistical distance then you choose 12
right I mean yeah I mean if you want to
assume the minus 100 is not enough when
you choose you know 14 but so right but
if it's like log n if you want to do
asymptotic log in you will be within 2
to the minus log squared okay so 12 is
something to get 100 okay so here's the
idea for improving it right and this is
from the recent recent result I mean
don't worry about this let's just look
at pictures here's the rejection
sampling from that I just talked about
with the gaussians right you have
because you have to divide by such a
sort of because there's this because a
shift happens and you have to divide by
you know something that's fairly big to
to get them to fit to get the kind of
the tails to fit underneath for all but
the very extreme points
you're dividing by a lot and the two
distributions here is the distribution
you're you're sampling from the blue one
right this is on two scales right you
what you did is you shifted this guy
over by this so projecting onto this
axis it's still a perfect Gaussian
projecting on this axis it's a shifted
Gaussian but you have to fit this red
thing underneath both because that's
what fitting it underneath the Gaussian
means so you have to know the two
distributions don't look very close to
each other so the 80 and the problem is
again the tail so the idea is what if
you add another Gaussian what if you put
a gap what if the distribution is
sampling from is a Gaussian on both
sides right so it's a shift in both
directions so rather than having just
one shift you somehow end up with two
shifts right so then it's great at least
the you know the problem is a kind of
solved because at the tails I mean this
this the blue one will always be bigger
than the red one if you divide by
something because this is a shifted
Gaussian so its bigger here this is
shifted Gaussian here so its bigger
there right so they kind of take care of
it and so the two questions are all
right so this is great how but how do
you do it okay so getting this bimodal
Gaussian that's easy in the signature
ski so let's look at the previous thing
here Z was s times c plus y so it was a
Gaussian y shifted by SC but what if you
want a Gaussian the shifted by SC and
minus SC well instead of multiplying
instead of adding SC first you pick a
random be in- either 1 or negative 1
with probability fifty percent and then
add to Y be x SC so now what do you end
up with well the fifty percent chance
you are here and we fifty percent chance
you're here right so okay so that kind
of handles that okay so it's easy to get
a distribution but does the scheme still
verify correctly right you can't just
pick any distribution and you can take
any distribution you want but at the end
the scheme has to work
so but but first why is this nice so
just to show what what the nice thing is
the standard deviation now goes down by
a lot before the standard deviation for
the same e yet they have standard
deviation be max of SC x 12 whereas now
it's max of SC divided by square root of
two so almost like a factor of 20
improvement or short asymptotically it's
a logarithmic factor in the standard
deviation which which leads to
significant savings and the verification
now how does the verification work well
verification checked that H of AZ minus
TC mod Q gamma mu evaluated to see when
applied to the random Oracle but this
doesn't quite mean before it worked out
great because b times TC minus TC plus a
why was a y so this part was just a why
because b was one so previously you know
pick a random be in one but now it's in
one negative one so what you need to
happen is that TC equals minus TC right
you need the two things to cancel out no
matter what you want this to be periodic
mod two and you can do this by picking
an S so that a times s equals cute Qi
mod to Q so now this is our tea now Qi
and you notice that this T equals minus
T because we're working modulo 2 Q okay
and you can prove this is still secure
and now to sign we do what we previously
did we compute this you know pick a y
compute C choose a random be and then
output Z equals b c plus y and do
rejection sampling with the bimodal
distribution and verification is exactly
the same checks that it's exactly the
same okay and the security reduction of
works in a similar way you have your a
you pass it to the adversary he gives
you a Mew I
you pick zICA from the correct
distribution you can do this you can
program the random Oracle the previous
scheme I didn't hear I do it doesn't
matter really you pick it from the
correct distribution because we know
what this distribution is and it is not
dependent on the secret key okay we
program C equals this and then we send
it we send the signature to the
adversary until he sends us two
different messages which you know he get
using the forking lemma and then we get
a times Z minus Z prime equals 0 mod Q
so not good one went fast but there's
not nothing nothing two different than
the security proof and before okay so
okay so this is the basic idea so the
main sort of theoretical idea was this
was to figure out how to do the
rejection sampling optimally right and
so the optimal way that we have right
now is the reaction sampling is to have
this bimodal Gaussian that kind of takes
care of the tails in both sides is there
something better I mean I don't know I
mean it wouldn't surprise me but right
now I have no idea so that's a nice open
problem so the optimizations that we had
is ok based the problem on the hardness
of the entry problem not not sis so ok
so instead of the entry problem or when
I say the intro problem I mean you take
two small polynomials in some ring
divide them together the result looks
random ok is it true I don't know but we
haven't been able I mean for 15 years
this is what people believe ok so then
you can also compress the signature so
not you can notice not all of the
signature needs to be output doesn't
matter a few other small tricks and so I
don't know if you can see it yeah I
guess ok so for let's say you want
128-bit security based on what we
currently know as the lattice best
lattice attacks I mean with dummy on
said was talking about well if you want
128-bit security you can get signature
size to be 55 thousand bits for example
right so the equivalent thing for RSA
made
I don't know for four thousand bits so
it's a little bit bigger the secret key
is a little bit smaller but okay I mean
same thing signing is much faster you
know a big order of magnitude and
verifications are much faster as well so
when compared to RSA it's you know
except for signature size which is maybe
a thousand bits longer everything else
is is much better I mean the one
disadvantage of our essay I would say is
that I mean all these rejection sampling
and Gaussian sampling these are not
they're not super easy to do in for
example a smart card but people are
working on algorithms to improve on that
I mean ours but I guess you know if you
want to do RSA properly and you don't
just you know I would just square and
multiply but that's probably not the way
they do it right so so maybe it's not
very trivial the way they multiple they
exponentiate either so i don't know i
mean if you're trying to optimize
everything maybe RSA is not that simple
i don't know but yeah but sort of we get
something that's that's fairly
competitive and i would say that
encryption and signature just so far the
only two things that we know how to do
really well from from lattices but yeah
you know I mean maybe the same ideas can
be I mean this the same ideas from this
rejection sampling also used in the
identification so if you went to zero
knowledge proves it's the same idea so
the rejection sampling can be useful
there but so far it you know these
techniques have not improved upon the
more complicated these ideas haven't all
of a sudden made you know fhe to be
super efficient or multi linear maps but
you know I mean you know progress or
slow I mean it's you know this is about
a thousand times better than what we had
about five or ten years ago so that's
all right okay so this is all I wanted
to say thank
okay so i have a question isn't the
rejection sampling inherently prone to
tammy and x well the thing is so okay so
the I mean what is the what is the
object what is the attack that you're
thinking of timing it because the thing
is that node how much reputation it took
to generate a signature and you might
learn em and then you can well M is
public m everyone knows them but so so I
will tell you this i mean there might be
a tax and I mean there might be even
easier text but the obvious thing of
maybe what you're thinking of depending
on the secret key you might reject more
or less that's not true for every secret
key you reject the exactly the same way
whether or not you reject may tell you
something about why and that I don't
know so if you're but just by okay but
if you I think once you start looking
inside the scheme itself if you're able
to probe inside and get some values
there might be an easier way to do it
and just by looking at the rejects but
if all you're doing is you're getting
rigid so you're getting you figure out
whether I'm rejecting or not you learn
nothing because I'm for every key I'm
rejecting with the exact same
probability is there a specific use case
defined to what up the lattice digital
signature so far in industry most of the
you know applications use cases or
semiconductor companies all are you know
that deploying the traditional digital
signature scheme so any specific use
keys can propose um okay so so okay well
what the reason one thing you could say
is okay quantum computers get built you
want digital signatures based on
lattices okay so that's one thing but
let's say before quantum computers get
built let's say you don't believe the
quantum computers will
forget build because I would argue that
if you know they will be built in 10
years you should I mean signatures that
are made now will be completely invalid
in 10 years right so if you want things
that are signed now to be valid when
quantum computers get built you need to
you can't use something classical right
because then if they can just be forged
reader actively okay so that's one thing
the other thing is okay if you care
about their verification time so I mean
all that is facing just a very fast
verification time it's just a vector
matrix multiplication so that's another
one and a third one actually somewhat
deals with the leakage results
resilience thing the fact that lattice
signatures a lot of separations just
sort of linear it's much easier to mask
them so there were some work done in a
different direction but using kind of
the same idea that the more linear you
have the more linear function is the
more easier it is to kind of achieve
higher orders of masking because then
the reconstruction is just you ricans
you you know you you do something many
times and then you just add out up
together add it back up together and
that gives you the correct result
whereas if something is non algebraic
but maybe with the discrete log you can
do something fairly similar so maybe
maybe your leakage resilience is not the
best thing to compare it to RSA I don't
know but I mean at this point i would
say it's the it's the conjectured
security against quantum quantum
computers and you know the facts fast
verification tag I mean will I tell you
to you know stop stop using lipstick
curves and switch to lattices no I mean
at this point right I don't think we're
deberia I mean I I I certainly wouldn't
use anything based on lettuce right this
point but but the point is you know
we're getting there and hopefully
there'll be much more crypt analysis and
then we'll be able to you know get to
the point where lattices will give you a
good exact good alternative so there's a
simply an open source and TR you
encryption encryption does it is a
fiction ok some reason right right ok so
i guess so some rumor i don't i'm not
know much more entropy likes only used
and truth encryption because it was
faster yeah okay so okay I don't know
this must be true two people hurt maybe
you told me it still counts okay just
synthesized yeah Tanya so but now 3
comments so one was um I'll sure you
argue about your security levels there I
mean this is the based on the best known
attacks we I mean we took a margin of
error of course I mean I would say you
know even breaking this even breaking
this toy example here I don't know if
one can do it even though we conjectured
to have less than 60 bits of security I
mean all of these I think we really took
some really worst case things you know
worst-case assumptions on on how the
algorithm behaves are in best case
assumption for the algorithm worst case
for us and we kind of came up with these
numbers so based on what's currently
known i would say yeah this is fine can
something come up tomorrow the better i
mean that's not okay like i said i would
not use this but you know until more
critical I'm not asking me a secret
analyst like would you accept a break
which shows like 42 bit security for the
top one no they have fun well it's your
40-bit security then you should be able
to actually do it right no but if you
have 40 bits but you can't do it then
it's I question your 40 bits right um
second one how does it compare to hash
based signatures so in hashmi signatures
the secret key is much bigger I mean I
would say it's about were 30 maybe
thirty thousand bits
except that you have a ceramic function
behind it's not so bad actually then you
can keep a s as a background but how do
you keep generating a new secret key
without your you do dude once but you
can forget about them but you have to
store something along the tree right you
can recompute most of those okay okay
okay seriously um so you okay so you're
saying you take just take a random
Oracle I me ask you one time signature
if you take the and okay so how many do
you take a hash function do you very
comfortable with right okay out of 56
where we have more good videos okay so
okay so the signature size would be what
about 128 squared right so if you have
your base around shower right so you
encrypt oh sorry you sign every bit so
you have 120 okay you think more lampert
so if you don't win then it's so short
answer you getting actually into the
range where hash functions is also very
very efficient they can beat our essay
right now so what so what are they I
mean so what are the parameters so we
start with sha-256 they get so I found
28 bits acuity I don't have the numbers
right now there's a paper Bundy holes oh
yeah good can take the solvent lastly
was because probably mentioned and true
so there's also an entry signed version
out very recently yeah yeah I saw what I
saw there well okay so that what they do
is I'm being taped um so know what they
do so it's it's very much based on this
idea of rejection sampling but they they
introduce it so instead of using the n
true problem a bit ironic they use a
different assumption which witcha I
don't know I mean I've heard Jeff give
the talk and I what he'd the way I
understood it was sort of for historical
reasons he wanted that assumption back
in the 90s but they couldn't quite get
it to work but then with rejection
sampling they figured out how to get it
to work as far as is there any advantage
of that assump the number is just just
based on the signature size and stuff I
don't
see it but there might be some other
uses for that thing although right now I
don't quite see the advantage of doing
what they're doing if you see an
advantage I would be very curious to
know what it is so I mean their
assumption is basically instead of this
matrix a that I have is that it's a
fixed matrix that's a sub sub matrix of
the FFT transform so whenever you
compute a times s it's actually
evaluating s it's the FFT coefficient of
s on several on some hopefully random
subset of s and the idea is that if you
know the F if you know the complete FFT
evaluation of something then you
obviously have something but if you only
have let's say half of the F of T
evaluation of some short vector you
cannot find a short vector based on just
half of it f of T evaluations that's
something you need to assume is hard
although I'm not sure that the end
result you get actually a proof of
security based on that but that's the
minimum you need that's sort of all I
don't so you gave is the main current
motivation for this crew to the quantum
computer or as one very important one
but yet there's rewinding it sir and yet
there's a reminder exactly so okay have
you check how it all these signatures
work with what we currently know more
photo reminding our first one seems to
work the Genesis on but you would write
you will not be able to use this
tightness trick I think okay I not
ignite wouldn't follow all the night
there okay but the second one I think
for the unknown right so as far as I
know it's it's not known so one thing we
can do is we can set the parameter well
parameters in a certain way that
rewinding is actually not necessary and
it's based on kind of the same idea as
if somebody knows so I already mentioned
the cats wrong paper but that paper also
had another part which is the DDA a DD h
based scheme that does not use rewinding
so basically you have like a schnorrer
type signature but it's based on instead
of being based on discrete log it's
based on Leon ddh but and there's no
rewinding at all so it's completely
tight so we have a there's a version of
this based on lattices as well it just
comes from setting parameters a little
differently but the problem is you set
parameters a little differently and it
becomes less efficient your kind of more
down on this scale so but the fact that
all you have to do is change parameters
makes us a little confident that that
you know that whatever rewinding
whatever quantum algorithm can it still
use the ranbir but it's okay but this
could be so tricky no no that that I
think that case was actually analyzed in
a some Asia crypt 2000 by fish 2013 no
no not 2013 mid-2000 I think this pay
phone your charm units it's in it's an
average Asia crypt there's one in eight
by 50 it sits in it no no I think it was
the original was maybe 2010 2009 oh it
was it was it appeared early was on
ePrint for a while I think they actually
analyzed by Christian schaffner he was
on that paper too i think they analyzed
it and they said yeah it's okay from i
mean i wouldn't bet to you know anything
on but there's no rewinding and the
random Oracle is used in a pretty safe
way the way that they were they were ok
with so that one is secure so this one I
don't know but it would be very strange
that for a different set of parameters
all of a sudden this becomes into I know
I know this becomes insecure I mean this
would be really really really
interesting actually if this actually
does happen because honestly I don't see
how it could possibly become insecure
for a harder set of parameters yeah in
class but but yeah sure this would be
that this is definitely an interesting
open problem which I don't know the
answer but yeah this is definitely one
of these things that is a bit annoying
but you have rewinding based on against
colon
it's a good question yeah the first
scheme you mean the first one that uses
the same equation a y plus yeah it
wasn't secure you told that we can
choose a rejection sample rejection
method to prove that this is this is a
secure oh okay yeah I choose any any any
function any function you want just make
sure the rejection sampling works
alright so maybe you're the first you
cannot use the uniform distribution over
a finite range and that works as well
but the Gaussian one is tighter which is
that when you introduce my middle go see
and what was the main improvement
standard a standard deviation you need
for the Gaussian shrank by a factor of
20 a smaller standard deviation so we
can so the signatures are smaller and
the permit the dimensions can be smaller
again okay thank</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>