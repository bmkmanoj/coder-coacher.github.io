<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Bringing Theories to Life: Computer Science at Microsoft Research | Coder Coacher - Coaching Coders</title><meta content="Bringing Theories to Life: Computer Science at Microsoft Research - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Bringing Theories to Life: Computer Science at Microsoft Research</b></h2><h5 class="post__date">2016-08-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0fEItPsqz5M" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
oh this is microsoft research
connections and this is the group that
works with universities worldwide and we
work on a variety of projects in
computer science but also in science and
education so the three areas we work in
collaborations on science using computer
science producing tools that can help
accelerate progress for science and I'll
give some examples but above all what
we'd like to do is excite and inspire a
very important community for Microsoft
which is computer scientists information
scientists
okay thank you so this is the way the
group is organized we have five themes
two of them are scientific that's earth
energy and environment and health and
well-being and I won't be talking very
much about them today and all about
education and scholarly communication
which is if you like the information
science and engineering community so I
want to focus mainly on core computer
science activities you'll hear talks
about natural user interface at this
conference so we produce some research
accelerators we have global partnerships
in in all parts of the world so we have
in Europe we have a for example a
collaborative center with inria a major
computer science research center in
France and also in Asia we have a joint
labs with many of the major universities
in the region in Latin America we
collaborate with fap SP in Brazil and we
have a joint institute and fun projects
in Brazil but in Latin America generally
we have lack SIA and you'll hear about
our projects with the lacs a Federation
of universities so those are some of the
things we do the the other things on
external researchers we have sponsored
an ACM student research competition we
have internships as you know in
Microsoft we also give a Jim Gray II
Science Award and graduate women
scholars but what I'd like to do today
is an ounce we've just announced today
our new faculty fellows these are
fellowships that we give to faculty
who've been in position in universities
for less than three years and it's meant
to give them a boost in their career and
funds to do their research and travel
and 10 conferences fund students and so
on so it's a very competitive field we
I'm constantly a standard each year how
good the candidates are and how how
smart they are and I'm very pleased to
announce that a Latin American fellow
today is with us his research topics I
helping computers
and robots see the world so he's working
on algorithms for automatic recognition
understanding of images and videos and
so on the human motions and activity his
name is Juan Carlos needless from the
University del Norte in Barranquilla
Colombia and I could you please stand up
uncovers
congratulations and many thanks for your
participation today so one of the things
we've been doing is amplifying some of
the research in our labs and you've
heard some talks about machine
translation some words about that and
what we've been developing with the
machine translation team in Microsoft
Research is if you like a crowdsourcing
of machine translation and so Microsoft
translator hub is helping smaller
language thrive by giving the power to
build machine translation systems in the
hands of local communities so if you
like if you're worried about your
language for your particular for example
take Welsh in the UK it's a small
language and not many people speak it
not many millions it's never going to be
commercially important but it's very
important if you're Welsh and so that's
an example of the sort of languages that
can be helped and Kristen tal from our
group is talking about Mt hub tomorrow
and what I'd like to do now is is is
talk a little bit introduce a demo we're
going to show you chrono zoom which is
one of the tools for examining and
displaying big data both these empty hub
and chrono zoom use as your and this
will tell you how you can actually
capture / 13 billion years of history in
the same canvas and put all sorts of
data so Mike off you go I'm going to go
pretty quickly if the guys upstairs
could switch back over to this machine
please there we go okay so I'm here
today to talk to you about chrono zoom
this is the history of everything it's a
html5 canvas that runs on all sorts of
web browsers on all sorts of platforms
and it's a collaborative effort between
Microsoft Research University of
California Berkeley and Moscow State
University in Moscow Russia and it's an
open source project the code is freely
available and it's an interactive
dynamic timeline for exploring
historical events and telling stories
through all of time
so what you see here today is a time
scale at the top that goes from today on
your right over to fourteen point seven
billion years ago on your left where the
world began you know time began with the
big bang and the entire canvas is
clickable and zoomable and you'll see
this timeline scale as I zooming it out
and show different aspects of history
one of the things I'll call start with
is the the creation of the stars this is
threshold to one of the thresholds at
which exponential changes in the
complexity of the universe allowed new
things to happen and then here's the big
bang so in this timeline and in these
exhibits not only can you have
interactive media and big data mashups
of multimedia elements but you can
incorporate these things into my machine
working let's try that again the demo
gods are not with us today okay so
anyway this gives you an idea of how
chrono zoom works but I'm really excited
to announce today the launching of a
content update to corona zoom beta this
we just released a new set of content
for this platform specifically for the
Latin America summit and I'm going to
quickly play a tour this is one of the
ways that we're exposing stories and
historical elements throughout all of
time and we worked with felipe gaitan
and Carmina maurilio from the lasalle
university in Mexico City to create a
Mayan history timeline
hi my name is Carmen Amarillo I'm
responsible for academic relations of
postgraduate studies and research at La
Salle University Mexico we have made a
study of the Malian culture mainly
divided in five periods and focus in the
social aspect of this civilization
that's what we indicate the Malian
pre-classical / you as a way to
understand the starting point of what in
its moment was known as the Empire of
Kukulkan the narrative of the Popol Vuh
the mathematical invention of a zero and
the cosmic calendar whose precision
describes almost perfectly the cycles of
movement of aired the I'm going to pause
the the two were there and I'm just
going to start exploring chrono zoom I
think you saw that two billion year per
second journey we just took into an ana
pixel resolution that got us into the
Mayan timeline from the cosmos so if i
want to freely explore one of these
exhibits inside the inside the corona
zoom canvas you can see here there's
some rich detail describing the the
beautiful elements of the mayan calendar
there are supporting artifacts here to
tell you more about the detail of the
different glyphs that are used inside
the mayan calendar and we can even
reference other experts in the field to
help tell the story
and this is all happening inside the
krona zoom canvas gradually first Oh
having fun okay so we must have had a
network hiccup here tumon worked out how
the Maya marked time a system now called
the calendar round the calendar round is
made up of three interlocking cycles a
365 days solar year a cycle of 20 names
and the cycle of 13 numbers days are
designated by the way these three cycles
line up
for example I'll go ahead and pause it
here we're obviously having some network
issues but the point I wanted to make is
that there's all sorts of rich detail
and rich information inside chrono zoom
that tell all about the Mayan culture
this is specifically this part of the
timeline is describing the pre-classic
period and if I come out and show the
whole timeline here from about 800 BC to
about 1700 ad you can see that it's
broken up into various periods now the
classic period was the the time of mine
history where it was at its fullest the
richest were all the cultures of these
various tribes came together their
language was consumed they they formed
strong kingdoms and and here's an
exhibit that talks about their writing
order and how they had a language a
common language that came together and
how that worked and you can learn more
about the language constructs in here in
this exhibit the the ball games are
something that are also very popular
with tourists and very interesting and
there's some great artifacts and in
local local areas around around this
area which was pretty exciting what we
see here is a mash-up with some
Photosynth data inside chrono zoom that
allows you to have a virtual 3d tour of
the ruins of Chichen Itza and the the
ballgame court and you can also embed
all sorts of other images inside here
and really just continue exploring and
zooming into this canvas in all sorts of
different ways to help explore stories
and rich information and so finally you
know the post post classic era there was
at the beginning of this era there was a
lot done around observatories they're
the Stars and the alignments and how the
calendar and the gods and the sacrifices
that had to occur in the Mayan culture
to help them continue to survive
eventually you know there's there's
stories about droughts and and and
infighting between tribes ended up
causing the Michael
to ultimately decline and the Spaniards
came in and then kind of took over so so
this is really exciting I think for the
project and for Microsoft as well as
Latin America region and I encourage you
to go to corona zoom project org and
give us your feedback because this is a
beta and we're very much interested in
collaborating further it's again built
by the community for the community we're
really just facilitating the effort and
I'll let us take a journey back up to
all of time and give us an idea of how
small in the history of everything we
really are I'll be presenting this again
at demo fest on Friday and if anyone has
any questions you're free to come by and
see me then so thank you thanks very
much Michael thing if you could switch
the slides back please great okay so
this is just for information Microsoft
supports an open source foundation
called the outer curve foundation and
the microsoft research connections runs
what's called a gallery and it's a
gallery for research accelerators and in
there you'll find the the source of
Kronos room and you can take it and play
with it yourselves so we invite you to
join what I want to talk about in this
talk however is not those topics I'd
like to talk instead about computer
science research at Microsoft and we've
had great collaborations with the
software engineering research group in
Microsoft Research in redmond and I'd
like to tell you a little bit about
their work and some of the things we're
doing so this is a program that Judith
Bishop and her team in computer science
run she'll be talking tomorrow about how
software engineering is the best career
for anybody right you can agree or
disagree with her tomorrow this is the
program we've been running since 2009
and as you see it's about time mexico
girl on this list right so
I invite you to apply if you're from
anywhere in Latin America and get one of
these grants so what I'd like to talk
about a Microsoft secrets right so
there's a book was published around 1998
call microsoft secrets what was that
about well it was about the software
engineering challenges faced by
Microsoft now I came from a university
and I was used to writing software with
a couple of grad students postdocs small
teams and that was certainly the
approach that was possible in the 1970s
and 80s and things like dos Word and
Excel were written by really small teams
unfortunately software programs get more
complicated more complex it's not just
microsoft it's in the whole world
everything gets bigger and complex and
number of people grew to hundreds and
the now into thousands and the lines of
code grew from hundreds of thousands of
lines to millions of lines and how do
you coordinate and how do you write and
test programs of that scale so that's
what I want to talk about it's big scale
programming and software engineering and
what the book Microsoft secrets talks
about is how Microsoft deals with that
as you know Microsoft likes to hire
really smart people and so what we
wanted to attempt to build was a process
that allows large teams to work like
small teams and you can do that by
allowing large teams to work in parallel
on different things but you have to
bring it back together and that's this
synchronize and stabilize approach and
so you have these synchronization
product bills milestone stabilizations
and continual testing so you go from
working code to working code and that's
really part of the process in Microsoft
so I'd like to tell you some of the
that's what I wanted okay so this just
gives you some of the scale alright so
in Windows NT 200 developers testers
were about 140 nearly 5 million lines of
code by the time you get to Windows 2000
you have thousands of developers and
testers and you're now up to nearly 30
million lines of code and that's
something that it's difficult to
conceive of doing in a university but
this is the sort of problems that any
big software project fail faces and
particular Microsoft with its software
and as you can see that I've only gone
up to Windows XP but now we have
thousands of programmers and 40 million
lines of code and it's more now so that
gives you some idea of the scale of the
problem so software engineering there
was a study by the u.s. national
standards body NIST estimated that
software bugs were costing the US
economy more than 60 billion dollars per
year and the programmers were spending
most of their time fixing bugs then
instead of writing new code so what
Microsoft's philosophy has been software
tools not only to find bugs before the
software is released as you're writing
it to make it better and more efficient
to make it a more engineering discipline
if you like but also to analyze the
errors when their reporter what you do
with all the bug reports what you do
with all the error messages that you get
how do you decide which bugs should you
fix which ones are important so the goal
of this is summarized by using software
to make software better and that's
really what the rise group do so again
in 2008 a survey of Accenture did of us
program managers saying that forty
percent of the decisions are not based
on fact but on the managers instincts
and so what the software engineering
group are trying to do is is actually
gain insight from the data to enable the
software teams
make better decisions so actually
looking at the processes looking at
actually what's done in developing
software how could you make the
decisions better so you get generate
better code less bugs more efficient and
obviously Microsoft have a large number
of code bases for which to try these
tools out so this is something that
Microsoft Research does which doesn't
necessarily get into the outside world
although some of the tools don't do but
nonetheless is is absolutely vital in
dealing with huge projects of this scale
so what I want to talk then is about one
of the groups in the research in
software engineering team called the
empirical software engineering group who
look at three types of challenges and
I'll briefly touch on all of them I'll
start with looking at the data
data-driven software engineering what
can you learn from previous projects
what can you learn as the project goes
on to make the software better and to
make it more efficient about doing it
how do you measure efficiency and so on
whoops
and then i want so i press the wrong
button apologize i wanted to talk about
when you get the bugs what do you do
with them and who fixes them and then
who fixes them may not be the same
people who wrote the code so they have
to there were all sorts of challenges
there which is what i mean by the socio
technical challenges here so let's then
start with the data-driven software
engineering aspects and if i go there
what one does to make large teams work
like small teams you get the teams to
work on different parts of the code
simultaneously so you try and get
branches in the source control where you
have a parent and then these two teams
can work independently but you have to
integrate you do edits and then you
integrate again and so this is the
process you isolate work so that these
teams can work together at the same time
but then you have to bring it back
together so these branch convergences
are an issue and you can just see that
from the next slide which shows just the
code flow for the single file and if you
see here the integration all these
yellow dots and you can see it's a huge
amount of effort to bring these branches
back together and in this case the code
velocity that the the speed at which you
incorporate edits and really make
progress on building what you're trying
to build is particularly slow in this
case so can you do better than this well
first of all you need to know you have
this problem so mining your data to find
out what problems you have is absolutely
vital so how do you coordinate parallel
development and how do you make this
branch is more effective more efficient
how do you reduce the complexity and
that's what the the empirical software
engineering team do and they do it by
sorry by looking surveying the
developers to understand what their
problems are with the branches of
finding out what that what they actually
think their problems are mining the
development data for the relationship of
the various teams and
the branches are there in the same place
other the same team are working on same
parts of the code and then you can
simulate the costs and benefits you can
actually rerun the writing of a piece of
code and see could you have made it more
efficient and so the actions that come
out of all this analysis are you can
alert users about possible conflicts
where they're likely to be problems you
can recommend making a smaller branch
structure or adding things and deleting
things and you can even attempt to do
semi-automatic branch refactoring so the
next slide is meant to show you the
difference between Windows Vista here
and windows 7 and so this is on the
bottom you have file similarity how
similar are the files is his low file
similarity this is high up the side you
have developers other the same
developers are there different developer
team and what you see from that is that
most pairs of branches are not similar
down in this quadrant here so this is
not very similar files down here and not
very similar developers you can go up
you have the same developers but working
on different things is perfectly okay
and over here
you see here we have the same files hice
file similarity the same people so same
files should mean the same people
because then you get less problems
because it's the same people same teams
working on and finally down here you
have the same files but different teams
means you're liable to get problems and
so what you see from this slide is that
you really want to populate this area
more because same file same people is
not going to cause problems and so you
can see the major change here is that
people have been moved from here to here
and actually you can actually go and
measure the number of bugs at the same
time of development in Vista and in
windows 7 and I'm pleased to tell you
windows 7 is easier and better code than
Windows Vista was at the same stage of
development so and you can analyze that
here and in fact you can do different
things you can replay the history of the
code because you've got all these
records you can try and cost the average
delay increase / edit you can cost the
integrations of edit on a branch and you
can find the benefit provided by
isolating so can you do more work by
having a branch and if you do that you
can get this sort of data so you can
actually look at all the branches and
you can plot it against the isolation
that's the benefit that more people can
work on it versus the delay caused by
bringing them together and this is the
cost and this is the benefit and what
you'd like to hit is is high benefit for
low cost and you see these red dots are
giving you very little benefit and they
give you a fair amount of cost so if the
high costs low benefit had been removed
it would have saved you several days of
work and actually only introduced a very
small amount of additional conflicts so
you can do that sort of analysis and
help the dev teams actually think more
carefully about the branching structure
so summary by doing branch analytics you
can actually try and bring
a real discipline to the way you write
these big codes they can improve the
code velocity they can actually help you
define the structure they can help you
with scheduling and they can build you
reliable systems with low conflicts so
that's the benefits by doing this branch
analytics which is if you like data
mining on our own development data when
the software is out there you get bugs
reported and one of the problems which
is again not perhaps obvious is that get
the bug and you say well who's going to
fix this and you decide which which bugs
are going to fix and then you hand them
to somebody but one of the problems is
that for example in Mozilla and Eclipse
between around forty percent of the bug
reports are given to somebody who then
says well this isn't me who should fix
this and they throw it off to another
developer and that goes on another
developer so you get this this bug fix
gets tossed from developer to developer
and delays get in the system so can you
actually reduce the amount of time that
you get the bug fix to the right people
the right team to go fix it without
having to have multiple assignments
taking time and sometimes goes back and
forth between different people so that's
what Microsoft Research empirical
engineering have been able to do they've
reduced that the time that bug reports
get tossed around by up to seventy
percent and so you can make benefits
been in how you actually deal with the
bug reports when the code is actually
out there and finally bug fixing well
our codes are maintained and evolved by
programmers who didn't actually write it
so the testers for example in China
India or whatever all over the world
don't have the same background knowledge
or the memory of how the code was
written so how do you actually how do
they get enough knowledge to fix the bug
and how do they actually understand
enough of the code not to introduce more
bugs and so they're all sorts of issues
here do you keep them in the same team
are they they
to face communication knowledge
management all these sort of issues that
come in and actually studying and
understanding them is really clearly
beneficial so this is just looking at
what the team in India do what how do
they get information to satisfy to fix
the bug and they do it from a variety of
things they look up in a library they
use existing knowledge they ask
colleagues they ask colleagues in
redmond and so on so you can analyze
exactly where the knowledge comes from
and with that knowledge you can actually
do something about it so that's
empirical software engineering and I
think it doesn't sound normal exciting
but I think it really is a very exciting
type of data mining which actually is
necessary to do to build these huge
software packages so the next thing is
different this is the the quotation from
bill gates that Peter used in his talk
this morning so actually building a tool
which can use theory to check whether
something about a program is correct and
what I'd like to do is tell you a little
bit about this it's model checking in
action if you like so so the application
that was chosen were device drivers now
device drivers were chosen specifically
because there are a application the
device drivers aren't written
necessarily by Microsoft but because
they interact very low level with the
operating system they can cause crashes
many of the crashes you see in windows
that are blamed a Microsoft actually
became from the device driver which we
didn't write so they can have very
severe effects and it really is
something we need to educate people to
write correctly and so the code is
usually relatively small and there are
protocols of how the device should
interact with the operating system and
the question is are the drivers that
people are building respecting the
correct protocol are they doing what
they're supposed to do and this is an
example of a finite state machine
hope this is that you acquire a hold
when the hold is here you can't acquire
another one if you do it's an error and
so on so this is a very simple example
of a finite state protocol where you can
see that there's an error and what it
turns out is that the the correctness of
these programs usually in something like
see depends mostly on the control flow
so what the team developed some years
ago was a tool called slam which uses
this trick of called predicate
abstraction and refinement so what that
does it takes a sea program here removes
the actual most of the variables and
replaces them for example excavated and
why can possess biological boolean and
and the control structures it can
replace by bullion's and so you get
what's called a boolean version of this
sea program which you can then run
through the model checker and you can
see whether it actually satisfies the
API you can check against the API and
you can sometimes say it's correct if it
doesn't come out as correct you're not
sure that it's it's wrong may not may or
may not be a bug so you produce an
abstract trace which you can then make
into something that you can actually see
if the program can really get there and
so sometimes you can say immediately
that this this trace is a bug and you
get an error message and you found an
error in your driver often however you
can't and you send it around and you do
another refinement of the predicates and
run the loop again and again and so on
and usually although there's no
guarantee that the thing will terminate
most times it terminates and gives you
error messages or correctness so it's a
very useful tool and it's particularly
useful when you writing a drivers you
most driver writers use the sample codes
that Microsoft supplies
and if there's an error in the sample
code it will of course affect many other
people who use it they will just produce
the same code so this tool slam is now
in what's called the static driver
verifier sdv in the in the windows
development kit driver kit and what it
is applied regularly to the device
drivers of all supported models sorry
and has found bugs in the samples which
is extremely important because people
then right drivers with bugs in and it's
now available for third parties to use
so this is a tool that come from really
from theory and it's actually now is is
in the real world doing useful things
and what it does it relies at its lowest
level on the tool called z3 or z3 in
English smt theorem prover which is a
collection of these symbolic reasoning
engines here which you can read here and
this is a very powerful tool and has
been used by many many research groups
around the world we release it three
vaca demic you so you can download it
and and use it it's also won various
competitions in this verification
community and for example the sage tool
which is fuzzing code for testing it's
been used by win8 and office it ships
it's used with the SDV i just talked
about and it's also used to check the as
your firewall policies so it's widely
used within microsoft it's also
available as a download for the
community and on that you can build many
things and so what I'd like to do is
talk about get a demonstration of using
XIII and this
bernal software boogie in in one of
these applications so the application
that we're talking about now is by
roostin leno is going to come up in demo
a tool called Daphne which is a program
verifier so it advances the state of the
art at the moment it's used in teaching
and you can go and use it yourself on
the rise for fun website and it was used
by teams in the vs tte competition that
i talked about earlier so I'd like to
ask roost an to come and do a demo thank
you very much all right so I need your
help Mike alright so Daphne is a program
verifier it can get to the point where
you can mathematically verify the
correctness of your program that is to
make sure that there are no bugs for the
sorts of things that you're checking for
so Daphne is a language by itself it's
quite similar to c sharp or two to java
or to see and thank you and what i'm
going to do is I'm going to show you a
small demo of the of the program
verifier that is that is included with
with a theme so definitely just like you
would have a type checker run in the
background typically when you develop in
visual studio in daphne you instead get
the mean you get in addition the program
verifier what I'm going to do though is
demo it not in visual studio which I'll
do tomorrow during my lecture but
instead i'll just show you this
interface on the web that you can go to
on rice for fun so here i'm showing you
a small portion of a Daphne program it's
a class that implements a ring buffer
which is really just a queue and the
queue is is specified to have some
contents that you can see here well if
you have good eyes and it has some
capacity and it's implemented in terms
of some some variables like an array and
so forth and the the operations are what
you would expect there's a constructor
that could
and there are various methods for dq'ing
and end queuing elements into this ring
buffer now there's a complicated data
structure in between that's being used
complicated in the sense that the the
buffer is used in a in a ring that is
your your end queuing on one end your
dq'ing from the other and whenever you
get to the end of the buffer you wrap
around just like you would in if you're
writing this yourself using an array
that data structure is described using
using the invariant that you see here
it's not important you see the details
but you describe the the invariant to
things that always hold of the data
structure when it's in the steady state
and that's very important when you try
to reason about the correctness so let
me just point to one part in the NQ
where I have where have inserted a an
error and if I can scroll here the so
what I'm going to do is I'm going to ask
Daphne to verify this program for me so
at this point again it would definitely
would run in the background if you're
using visual studio here I'm using the
web interface I click the button and
it's complaining about an index out of
range in this line of code so it says
that the next empty might not be in
range of the of the array called data
well at this point we would go through
the code and we'd figure out what it is
and since I've already done that let me
just go ahead and fix it even though the
process for figuring out where the error
is is interesting by itself in this case
the the code was trying to double the
buffer if there was no more size if
there was no more capacity in it but if
you double a buffer that is zero size
you're not getting anything that's
actually bigger so that was the problem
here that is this this is the sort of
thing that that if you do testing you
really would have had to have something
that's calling it with with the zero
length that to create a zero links ring
buffer to begin with if you were to find
it ok so then I have written the code
here and I ask Daphne again and you can
see here that it verified the code for
me so this is the sort of thing that the
daphne can do thank you thanks
if we could switch back to the other
ones thank you very much so that just
shows you that besides doing api's we're
now actually moving on to doing real
code and I think it's really exciting
and we're very pleased to be working
with the the rise team and so this is I
think a round of applause for our this
software engineering the searches so so
they'll be talking about their work at
this conference and Judith will be
talking tomorrow so I do suggest you go
and talk to them and find out for real
what's going on under the covers and if
you're interested a career in software
engineering is obviously worthwhile and
so the last slide is then what's the
future of software engineering well what
I took to show you that the empirical
software engineering leads to sort of
software analytics which enables you to
make decisions based on data not on what
your instinct tells you and it tells you
what process you have and what practice
to use and so I think that has great
prospects for making software
engineering a more reliable and more
predictable process and I think that's a
continuing research problem logic based
tools can help you do better software
and you've seen a demo of Daphne and
there were lots of other demos building
on top of XIII and boobie that you can
go and have a look at and you can build
your own tools because boogie is
available open source as is Daphne and
as you heard in the previous talk future
platforms such as the web the cloud
mobile devices or provide new exciting
challenges for software engineering so I
do believe that Judith stalk is right
tomorrow that Lily software engineering
is one of the best jobs you can do so
with that I'd like to end and thank the
searches again thank you very much
thank you thank you very much Donnie ah
are there any questions ritani I can
take some questions if people would like
but I will be around drinking margaritas
after dinner if you wish okay okay not
too many margaritas I think the question
would be further but for the open bar
then okay sounds good thank you very
much honey thanks a lot</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>