<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Group Communication, Atomic broadcast, Gossip Protocols Part I (B) | Coder Coacher - Coaching Coders</title><meta content="Group Communication, Atomic broadcast, Gossip Protocols Part I (B) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Group Communication, Atomic broadcast, Gossip Protocols Part I (B)</b></h2><h5 class="post__date">2016-08-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/zFju-bTSgj0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
good so did anybody figure out where
widest works did you do over the break
have a good time or something so the
product of the critical property is that
if some process delivers n then all
correct processes must deliver in so why
is that true here
yes
that's right folks it here and then it's
sense it to all processes let's fight
virtual City if this process is correct
with that's the property of some correct
process of the liver there this process
is correct it will send a message and so
old correct processes will deliver and
by right at the abstraction oh here
seguin because I already knew oh that's
right okay so of course that's a very
expensive way of implementing reliable
broadcast and every time you see the
message you're going to start echoing it
to everybody else it suddenly becomes
very expensive so you can do a you know
a simple optimization here which is you
know whenever you broadcast MSU just
broadcasting you send a copy to every
every process interview and then you
using you know simple basically vector
timestamps you pick you back some a
little bit of extra information on
messages saying like which messages you
you have delivered like I delivered the
fifth message from process one and the
fourth message from process to like a
vector timestamp like you saw this
morning and then only at the end of the
view processes look at these vector x
times that they've received in all the
various processes figure out if some pro
some mess messages may not have been
received by everybody and only then echo
the messages that it doesn't know for
sure have been delivered everywhere so
this this this this whole three-way
handshake at the end of the view is
often crucial for building efficient
algorithms but when you receive the stop
view you know you you don't yield right
away because you may still have to send
some messages so you receive a stop view
and you look at all the control
information that you've received
figure something out about the state of
the system and then you're still can
send some messages like the ones that
you don't know have been delivered
everywhere then you yield of you and
then you wait for the next the new view
to be delivered that's how you implement
these things efficiently so that that's
that's that's often the trick to making
these these these protocol is actually
pretty efficient so it's not every time
you deliver a message here you you
broadcast it to everybody else it's only
in fairly exceptional cases okay let me
talk a little bit about how you do
replication in in virtual singin II must
be said that you know virtual cinemas
systems usually have built-in support
for replication but this is how one
might implement it i'll call this
passive replication it's like primary
backup replication there's some process
that's leader which says you know the
the one with the minimum identifier and
clients sent their operations to the
leader so the leader when it gets a new
operation from some clients so what is
this al on new uh pop okay this is sorry
this is a little different than I
remembered it to be but when some
process a replica gets an operation from
a client it forwards it to the to the
leader the leader that's here that's Q
in this case when it receives one of
these these updates computes the next
state and then the output and then
reliably broadcast a message with the
new state in it also keep track of a
version number then it waits for
acknowledgments from all the processes
in the view and when it has
announcements from all processes
national quorum all processes in the
view then it sends the result back to
the client
yes yeah I'm also confused so go ahead
yeah i mean its ability for all R&amp;amp;B
because it it's not the same cute of
course well so if if how do i do that so
if you don't get an egg from everybody
then that operation will never be
applied it gets lost but that's okay
we're only trying to make the system
consistent not necessarily sister
there's there's a something that maybe I
should go into my tag why not and
there's the end-to-end argument right so
the problem is the clients history
transmitted in any case the server's
until it gets back a response and so
it's okay to drop the occasional request
the it's not a big deal so it is ok so
for example if some processes envy have
crashed and don't say that
acknowledgement nothing happens it's
fine it will happen at the next right I
could but but i only use that inside the
implementation of the abstraction the
process is only sea views okay so that's
when the leader finds out about secures
the client here if you get an update
operation the primary execute the leader
execute that that operation sense the
result of the client winner has received
all acknowledge
but that's not this this particular
protocol I'm sure you know there are
lots of protocol zone could use but in
primary backup you wait for an
announcement from all backups not from a
quorum certainly we can go into
protocols that use Coram's and then have
all kinds of other prime you know nice
properties but this is pure primary
backup
let me go into that when i finish
describing his elburn that's right what
is the semantic do you get in you you
you are yes well so this done would not
so because of this this end-to-end
argument because of this retransmission
necessity an operation may be executed
more than one so we either have to
assume from the clients point of view
that operations are idempotent doesn't
matter or we need to keep track in the
state of what operations we've already
executed and and it has to be treated as
a no op if it has already been executed
one other two and that's just the you
know because if the whole into an issue
which hopefully somebody during this
lecture series will go into okay and
this is executed by the backups when you
receive from the leader a new state I
haven't said anything about ordering in
fact messages buddies reliable
broadcasts can be delivered in any order
so as to do a little checking to make
sure that it is a new state so they keep
track of a version number if it's higher
than the version number they already
know about that they update their state
adjust the version number and then send
an acknowledgement back to the leader
but all it is really is you know there's
a leader clients in their messages to
the leader and the leader then broadcast
to the backups of waits for
acknowledgments that's the basic basic
idea and sit in an important property
let me see what's on the next slide I
don't want to go there an important
property of this this protocol and
starting addressing your question is
that a result is only sent to the client
if all processes have updated the state
all of them
otherwise client will not see see a
result by the client having received the
result its guarantee that all backups
have it and so if we at some point go to
a new view and some new process becomes
the leader the leader is guaranteed to
have execute the client operation now if
you have used corms that would not be
the case because the quorums some
processes may not have executed the
operation we have a new view and the
next view there's a new leader that new
leader may not have executed the
declined operation and so the first
thing that would happen in such a
protocol is that the new leader first
has to figure out what the heck is going
on and that means that it will have to
ask a quorum of processes of the old
view whether you know like what what the
state is and the problem of course is
those process in the old view may no
longer be there so it's it's it really
complicates things quite a bit and a
little beyond the where I wanted to go
but this year this certainly will come
up in the Texas discussion but in Texas
of course there's only one set of
processes is not dynamic like this yes
Oh bunch of questions good how about you
that's correct or correct processes yeah
it's a good point actually so the point
that that was raised is because the view
sing any property virtual signi property
guarantees that all correct processes
deliver deliver this is this update
operation and and you know they all will
execute it even if it hadn't sent an
acknowledgement it will still execute it
before the next few starts and so if it
becomes the leader of the next view it's
it has the right state it's a very good
observation with the there's one caveat
which is that the leader of the next
view is not necessarily process of the
old view so it could be a process that
newly joined which case it doesn't have
the state at all
no I completely agree so so this is a
very smart audience that I should have
prepared for that better but you're
absolutely right so the so I think think
you're right the it's none actually
nessa so the decorum based version I
think might actually work you have to in
any case in the new view if you have
joining members or processes that may
not be the the joining but are in fact
weren't in the corum that were initially
consulted well actually that's not a
problem if it's a new member it has to
get the state from the old old processes
in any case so so yeah it's a very good
solution hadn't thought of that might
actually work just fine unless I'm
missing something lourenço or Rebecca I
think it will work yeah good point good
point
yeah but but but it doesn't matter I
mean city cores are only counted with
interview she's there yes it still seems
to be a problem though but I'm worried
about is because the virtual singer knee
does not necessarily make the assumption
that any that any set of processes
survive into the next view and so I mean
at least one clearly but and so the
problem is that an entire correr may be
gone and i think that's that I think so
that it still doesn't know I guess it
doesn't work you have to wait for all
processes to ya for all processes yeah
well the leader is the one who who keeps
the the leader is the one that that
keeps the primary version of the state
it applies to client operations in a
particular order yes clients consent to
any replica when all the replicas
forwarded to the leader if each replica
would just on its own update the state
we would certainly getting consistency
well if the leader fails the all the
processes that survive into the next you
and there's at least one of them and
it's something assumption I haven't
really stated but at least one process
needs to survive all of them crash then
there is no review that's the end of
that but so any process that survives
into the next you has the stake that's
why we're waiting for all processes to
acknowledge
it doesn't really matter though all
processes have enough information yeah I
think what your point is is that it
might be the case that the primary
received some updates that it then
broadcast but or maybe didn't broadcast
it may have received them and they may
have ordered them thus those are going
to get lost if the cut if the primary
crashes and no correct processes
delivered them and then we're going to
rely on the client retransmitting until
it receives a result is a you know
something the client needs to do in any
case because it's request me to the to
the replicas may have gotten lost if the
only way it can deal with that is by
retransmitting until we seize a result
so I this is a very interesting
discussion I but yet the corn based
protocol I don't actually for a second
yet you guys have convinced me but I
don't think it will work unless you add
some kind of assumption that a majority
of the previews of you survives into the
next view then I think it's it came from
but the dizziness additional assumption
that in fact some group communication
systems make and the in fact the way
Isis guaranteed that there was a unique
sequence of use is by exactly that
property it wanted to guarantee or it
guarantees that the majority of the
previous view makes it into the next few
I will go into that in a second but I'm
assuming consensus of some sort
we'll have to get the state from some
from some of the old members so he
starts with a broadcast somebody send me
to stay please sorry oh why wait for the
caller sorry broadcast and then send the
send the output back to the to the
client because if the leader crashes
right after that so City you the
reliable broadcast only guarantees that
the message is delivered if the sender
is correct but in this case the Sailor
is faulty so if if it was the case that
the fault that even if the process is
faulty it would be reliably delivered in
your right it would be in fact you know
no way for the message to get lost
however to implement that you there
would be a very expensive protocol
the only problem we have seen was in
terms of when he appears and the order
was aboard oh I'm going to stop this
this highly interesting discussion here
I mean there's there's a very good point
here it is there are many different
protocols that can achieve the same
thing however in order to understand
whether a protocol works or not you do
have to prove it correct and it's it's
easy to think like oh here's a little
optimization let's just use quorums and
you know everything will just work and
you know often these little
optimizations don't work and there's
like the slight you know corner cases
where these things don't work anymore
and you'll see that later with like the
consensus protocols you know these are
extremely subtle little protocols it's
very tempting to make little
optimizations you have to make sure
every time you make a small change of
the protocol see if all the invariants
still hold that you were assuming all
the kind of good stuff but yes there are
more there's more than one protocol to
do primary backup replication here's a
different way of doing it replication
with this called active replication also
the replicated state machine approach so
in passive replication there's one
process that maintains the state and
those operations on the state and
whenever it changes its its stated
broadcasts that state to the other
processes in active replication all
replicas maintain a copy of the state
and there's one process that or in any
case DD the various replicas eat
supplying the operation they say they
each have a copy of the state machine
like an active replication there's only
one copy of the state machine there's n
copies of the state here are n copies of
the state machine all processes apply
operations in order to ensure that they
stay the same they have to apply the
same operations in the same order and so
that's the difference between active and
passive replication so again we're going
to use a leader though
because we need somebody to order the
operations we could do that through a
leader protocol is a little simpler in
fact so when some replicas receives an
operation it sends that update to the to
the leader when the leader which
receives the update it sends a message
that includes a sequence number
initially 0 and increments the sequence
number and whenever that message is
delivered the accept message every
replica that receives the message
updates its state increments its
sequence number and and since the result
to decline so all replicas send a result
of the client and the client will just
be happy with the first one it's a
little little subtle tea here with it so
I won't go into it but the but if
somebody sees its sure I won't go into
it the the the basic idea is that we're
using the leader to order the operations
but not to to update the state and send
it to the other processes so the only
orders the operation send it to all the
processes all the processes execute the
operation and compute a new state and a
new output all right just to go back to
the old one there here it's the state
that's being broadcast to all the
prophecies arguably not a very scalable
way of doing things here it's the
operation that's broadcast to the other
processes along with the sequence number
because you need to you know the
reliable broadcast doesn't give you
ordered delivery it only gives you
reliable delivery subtle difference so
that's the act of replication approach
yes
yeah you're right that's the subtlety
that I was referring to it's really
pattern matching here it has two so it
it says you can only execute the
operation if it matches the sequence
number i could have written a bunch of
if and while statements in order to do
to make that right but this is a little
simpler okay so how does vsync garbage
collection work oh no Gookin occasion is
looking garbage collection what the heck
was I thinking of good communication
carpets collection it is for me six
o'clock in the morning or something like
that so forgive me okay so how does it
work I'm the house that implemented we
didn't say a whole lot about that I just
talked to you what the properties are
does you you know some slight hints on
how is working and so there's sort of
two important mechanisms there one is
the the messaging protocol that ensures
that when a message is delivered or
causally prime or messages are delivered
as well and then there is a so-called
flush protocol that has to do with the
changing views okay so here's a simple
message protocol that doesn't use vector
timestamps and yet gives you causal
ordering it's extremely simple lorenzo
as you did this kind of stuff right so
basically whenever you send a message
you just stick on that message you
piggyback all the messages you've ever
received and and that's the whole
protocol when you deliver a message you
just deliver everything that's on that
message to people to be delivered to the
process and it's a very simple protocol
that that you know obviously gives you
this dis property that whenever message
is delivered or costly prior messages
are delivered to because hey message
includes all the messages header
causally prior to it it's a completely
non blocking protocol
and by the way you know as long as you
get these messages in the older causally
prior message you might as well deliver
them in that order to so whenever you
deliver a message you first deliver all
the message that we're causally prior to
the message and then you'll deliver the
message it's called causal brought coke
causal delivery a broadcast story and
that effect can be handy for some
applications as we'll see in a second so
there is a simple protocol not very
practical it's you know messages as
explode in size as the as the system
runs it's in order to do a better job we
will use use some kind of vector
timestamps in fact we're going to use
something slightly more complicated
matrix time steps which will so matrix
timestamp is something like this there's
your view with three processes P Q and R
and in one of these entries it specifies
certain so for example p sent two
messages to q and hughes and three
messages through our hughes and
apparently two messages to itself all we
should have put zeros on this is a
diagonal but I guess I wasn't thinking
at the time so I probably wrote them in
the night too so that's that's a matrix
timestamp it completely captures how
many message each process sent to every
other process and instead of
piggybacking these messages on its
falsely prior messages we're just going
to piggyback the matrix timestamp our
messages as this concept clear to
everybody what this thing is so we're
going to piggyback that every process
maintain maintains one of these things
and when it never receives a matrix
timestamp it does something very similar
to the the notion of vector time steps
that we've seen before basically when a
process receives one of these matrix
time sitting say r receives one of these
things from frumpy so arc and i'll see
oh look at that i should have received
one message from be three messages from
you and five messages for myself I only
got one message from Q so I better wait
with delivering this message until I
received the two missing messages from Q
now we have a blocking protocol but with
this same guarantees it they said you
know you can you wait until you've
received all the messages you learn
learn from through these matrix time
steps throughout our messages set that
notion pretty clear why can't we just
use vectors so vector vector x times
count the number of events that happen
at a process but they don't say anything
about those events so say that we only
had a vector timestamp so when r gets
instead of a matrix times that we gets a
vector x them they can see oh wow
there's a five events that happen that
process p three events that happen that
process q and and you know six events
that happened at my own process from
that it cannot really learn whether
those events were messages that were
sent to to our to anywhere else and so
with our needs to know when it's in this
case it knows like oh it's here I'm
supposed to get three messages from Q it
needs to know that information in order
to be able to wait for that if it only
news while there were five events it
doesn't know how long to wait or what to
wait for so this gives you more more
information
but but the number of messages sent
could be through any process right so
you could have sent you know qss six
cents you send the events in this case
right 1 2 p 2 2 q and 32 hours so if our
learned there were six send events it
cannot learn from that the three of
those events were messages sent to it it
only knows there's a total of six but
that's not enough information so this
gives you them the necessary information
to implement the causal ordering now
most of these group communication
systems don't support point-to-point
messaging they only support broadcast
and if you have only broadcast than
effective timestamp is efficient and if
in fact if you read the papers they all
talk about vector x times he reflected x
is there because they only support broad
yes there is no way for peters and the
message just to cue the only thing that
the process can do is broadcast and then
you have to use filtering if you want to
implement some kind of point-to-point
mechanism so it's a trade-off if you
only do broadcast you can you don't have
to send a matrix you only have to send a
vector but the cost that you pay is that
if you want to do a point-to-point
message you have to broadcast it and
then filter it out at all the places
that don't need
you can deliver it until you know that
that you got to constantly prior your
messages and right because if you did
deliver it at that point but you didn't
wait for the costly prior messages you
may never get them because of failures
and so this is in order to implement the
abstraction that no messages get lost in
like simulating no message good laughs
so you better ensure that if message
delivered or costly prior messages are
delivered as well doesn't it necessarily
have to happen in that order you could
first deliver the message and that the
cause of a prior messages you might as
well put them in the right order that
has other advantages so far so good
not so nothing is being acknowledged
here yeah under the covers yes that's
true not sure how you would exploit that
though in for this and it the let's take
that offline i have no good answer to
that but I don't think it's sufficient
it's thinking yeah i mean this discovers
you know this this represent all the
sequence numbers right on all the
channels like the three processes there
are nine possible channels if you
include the self channel so these are in
fact all the sequence numbers of all the
all the messages that captured there in
one nice representation the thinking you
need to keep track of all of them in
order to implement this causal delivery
okay so the other thing that needs to
happen is this so-called flush protocol
so when there's a a failure then there's
this protocol that runs so i have here
up on suspicion of a failure let's for
now this soup upon a failure some
process is being recorded as faulty or
some process wants to join processes
then broadcast a flush request they
asked the other process is you know
let's do a few change when you receive
one of these flush requests for the
first one in the view stop you up call
is delivered then your boss still
allowed to send until it goes yield and
let's see if you've bit and then the you
call actually is going to wait for all
the other product that all the process
all the message that is sent to be
acknowledged so when all processes have
called yield of the correct process if
called yield in fact all processes for
all message from correct process being
delivered and because of the the
previous protocol the causal delivery or
prior calls the prior message being
delivered as well and then when all moan
cross passages have have done the the
yield call we can do the new new view
start a new view so this basically is
the protocol that's that's the terminate
the old view before the new view is
started it's a it basically ensures that
all messages that are outstanding in the
system are reliably delivered in the in
the previous view so yield doesn't
return to the said the yield doesn't end
until all messages that were sent by
this particular the process that invokes
yield have been acknowledged to it so
that guarantees all its messages have
been delivered and the causal protocol
that we saw before ensures that all
Causley prior messages have been
delivered as well so by the time old
correct process have called yield we get
this property that all messages have
been delivered and there are no more
message is outstanding yes fair question
so that's the the protocol that's called
at the end of the view change that clear
to that's this is all implementation
right so now who actually proposes this
new view right so here I said a new view
can be proposed that is when there some
failure happens you know everybody
doesn't really matter who does this
flush request and could be more than one
process but but who comes up with the
new view well somebody it's called an
Oracle so here's one way of implementing
such an Oracle so this is really the
cornerstone of virtual sanity to ensure
that that there's only one sequence of
views so since since failure detection
is accurate
there is in fact such a thing as the
oldest life member that everybody can
agree on and well you don't even need to
agree in it the process who thinks that
it is the oldest life member because it
detected the failure of all the
processes with lower identifiers or oh I
mean take that step back so in Isis and
and many other using the protocols the
the processes are actually identified in
the Orient when you join you get a new
identifier that's guaranteed to be new
bigger than the older one so you can
talk about the oldest live members but
if you want to think about it the one
with the minimum process identifier
that's fine too I'm going to call the
oldest live member a process can by
looking at its failure notifications
that are accurate can know that it's the
minimum water the oldest one I'm going
to call that the coordinator it proposes
a new view and broadcast it to the
members 50 of the view so when you think
as a member of a process that you're the
oldest process left around you propose a
new view and broadcast it now you wait
for acknowledgments or new failure
notifications if the coordinator gets
acknowledgments or failure notifications
from from the other processes of the
view at that point we consider it
committed and then we tell all the other
processes here's the new view it's
committed it's simple enough the only
unfortunate thing is that the
coordinator itself may crash during this
protocol that the coordinator itself
crashes the some other process that
thinks it's the oldest member that
survives now it may or may not have
received be view from the first
coordinator right so we had now have the
first coordinator that crashed and
there's a new coordinator the new
coordinator may or may not have received
the view proposal from the old one if it
did receive the the proposal from the
old one it just uses that as the
proposal for the for the new view it
cannot come up with its own at that
point
if not it can come it can pick any you
know it can propose any view that it
wants now why does it have to pick the
one from the old coordinator let's still
ensure that there's not the possibility
that two different views get decided if
by having a the coordinator the view
only get committed if it's acknowledged
by all of it but also correct members
and so if the new coordinator didn't
receive the proposal from the from the
first coordinator it's guaranteed not to
be committed cannot have been committed
because it can only have been committed
if the new new coordinator acknowledged
that view so if it didn't it the new
coordinator can propose anything because
it's guaranteed that the first one was
not committed so that way we can ensure
that there's at most one view that gets
committed and under the assumption that
there's at least one core one process
that survives eventually some
coordinator will be little succeed in
finishing this protocol you v1 v2
yeah I mean so I saw something that I
said in you know before I didn't find on
my slides but something that I'm i am
assuming throughout is that there's at
least one process that survives from one
view into the next it seems that if your
true requiring that a majority survives
is is more demanding that requiring that
one survives yeah but you do have the
assumption that somebody survives right
just making the Assumption a little bit
a little bit stronger which I have to
draw the line somewhere right hand it's
a bit but yeah all I wants to say that
in principle you also have to go to the
previous view my top right that's
correct well I mr. the the reason you
need at least one to survive from one
view into the next because if none of
the processes survive your status is
gone guaranteed you only need one to
survive and say it started in some sense
the minimum that you need you can make
it stronger I mean you could say oh I'm
going to require all processes have to
survive into the next tune that would
clearly be too strong the core might be
a nice trade off for and you know
certainly there are implementations that
have have done that well I guess that
when we were having this long discussion
and when I for instance was thinking
that this when you were asking that does
it work and I personally thought it
would work is because now I did I saw
that you also have to go to the previews
unbound and you go right to it you know
in a more limited fashion right because
I know that there's one process that's
revised and has the state but yeah I
mean you could certainly make it into
quorum but it's not not as simple that
protocol that I showed doesn't work with
just a quorum I'm sure you can make it
work but you have to make more
assumptions so in any case this is this
is in fact the consensus protocol very
simple one
and it's so simple because we're
assuming eckerd failure detection
without Edgar failure detection you
would have to do something much more
complicated and people after me excuse
me we'll go into that yes yeah but only
one at a time right again there's a
because affected failure detection the
if a process thinks it is the oldest
life member of a view it is the oldest
live member of you because further
detection is accurate so there's exactly
one coordinator the only thing that we
don't know is whether that coordinator
but it's it's view was committed or not
and the protocol that I gave you ensures
that there's at most one view that gets
committed it's actually both both safe
in life it's fairly easy to show
so you run that by me again yes
yeah yeah I mean so that's actually
property of the ISIS gives you is that
the oldest member of the view is always
the member a member that was in the
previous view which simplifies things a
little bit it's a useful you know
simplifying property okay so if you
don't have perfect failure detection we
could use consensus to to to agree on a
unique sequence of views this a little
more that needs to happen in the absence
of fruit of perfect failure detection
because actually the other protocols
actually also dependent on it
particularly reliable message delivery
which ensures that if some process
delivers a message all or costly prior
message are delivered as well I believe
it can be done in fact and I wrote a
paper with Dahlia and Ken that there
there is a tech report so can be done
without perfect failure detection but
it's certainly a whole lot easier
through these discussions to start with
thinking about not so much that the
system is synchronous but that that
there is a failure detector that can
accurately detect failures and it
simplifies a lot of protocols and simple
eyes a lot of the thinking about these
protocols but of course we can't have
eckerd failure detection you can still
implement the same abstraction with with
the consensus protocol okay so I haven't
talked much about ordering and I
actually don't know what time it is how
much time to have like 15 minutes left
that's that's probably about a about
right so I talked about are basically
liveness properties a little bit
discussed the safety properties x
actually this view mechanism i showed an
abstraction the guarantees that messages
are delivered I didn't say much about
ordering an ordering thus make things a
little easier
so we have broadcast protocols I mean
the simplest one is like best effort I
love that term for it for it's
meaningless this best effort means yeah
you know you try to get it delivered to
everybody I never know that's like why
would I care what are somethings best
effort or not but that's the the going
firm send it and forget tent and pray
then there is reliable which is which I
defined that is if the sender is correct
or some process correct process delivers
the message then all correct prophecies
have deliver the message except thinking
probably definitions for all these
things yes they'll never mind actually
here there they are so reliable is that
150 so the next obvious one says well
you know we might as well deliver
messages from the same center in the
order that sender sends the messages
it's often simplifies things a little
bit in the implementation of these
algorithms and that can be implemented
with a simple sequence number but you
kind of need in any case in order to
implement the reliability if the
reliability you know messages are in
fact identified by the sender and a
sequence number well if you have that
secrets number already you might as well
order them in the same way then there's
console broadcast which says now has to
be 50 and the messages have to be
delivered consistent with the happens
before it before or torso when you
deliver a message you have to first
deliver any messages that come costly
before that's right i'm sort of
strengthening the the notion that
everyone is stronger than the one above
but you know like basically causal if
you find so automatically yes and in
fact probably you know atomic could have
been 50 but i don't see if you can can
it's easier to think of each of these
hierarchy as you get what you already
had plus some more so you get the final
property plus this and then there's
something called atomic broadcast or
totally ordered broadcast and it's
that's pretty different from the notion
of atomic or the various versions of
atomic that we've heard about this
morning this is yet another notion of
what atomic means which is that the
messages have to be delivered in the
same order at each process atomic is one
of these these terms that we use in
computer science for any time we can't
think of another word so yeah make a
best-ever lip right okay so how so so
here's a here's a FIFO ordering with an
example something that's not 50 so you
know can be simply implemented with the
sequence number when you receive
something out of order you just wait
with delivering it until you receive the
earlier message I said this red message
no that is delivered here out of order
so this process here has to wait with
delivering this black message until
after it has delivered a red message in
order to make it 50 now for broadcast is
also local delivery I didn't show that I
mean you can basically deliver a message
immediately on sending that's its
efficient you never have to wait with
delivering locally so here's an
execution that's 50 but not causal I
guess we saw examples of that before so
this message you know comes causally was
sent constantly before this message and
so in order to make it causally ordered
we have to delay delivery of this red
message until after the black message is
delivered again local delivery can be
done immediately so it's a pretty
easy to implement with these matrix time
stamps and if all you do is broadcast if
there is no such thing as point-to-point
message delivery as I pointed out before
and you can just use a vector time stamp
atomic order it's a little trickier so
Tomic order is this property that all
messages have to be delivered in the
same order at at all processes and so
this process here so you cannot locally
deliver immediately as with these other
processes it access to wait with local
delivery until but one of them they'll
have to wait with local delivery until
the other other one is is delivered so
you know if you have this atomic
broadcast it becomes very easy to
implement passive and active replication
because all this nonsense with versions
and sequence numbers old it becomes
unnecessary you can just broadcast in
this order it's a very simple primitive
it really simplifies these replication
protocols so it can be implemented with
the sequencer rotating token protocol so
here is one with the sequence for
sequences a leader one of the process
the leader is the process and basically
what you do to implement this this this
protocol in a virtually singing this
abstraction is that you every product
every message that you send his first
into the leader and then the leader
sends them to the other processes in
five four and that will give you total
order is that clear the obvious right
token is a lot more fun these dashed
messages is a token that it's there's
like a little packet thickets send
around the processes so you have some
some ordering among the processes and
you just send this token around you know
in a ring and in order to to broadcast
the message you wait for the token to
combine we if the token
you broadcast and then you pass the
token on to the next next one on the
rink and the claim here is that if your
message delivery is in causal order then
you also get total water and the reason
for that is for example here it is this
broadcast in that broadcast because the
token basically puts a causal dependency
on these broadcasts this broadcast in
that broadcast these messages have to be
delivered before those messages and so
that that token is the reason it exists
is in fact to establish a causal
ordering between these processes and
then from the causal delivery you get
the tote the total war during that's not
usually how it's implemented though
what's usually implement is that the
token contains the sequence number it
gets incremented every time a message is
sent and then the message service
delivered in the order of the cmas
number it's probably an easier way to to
implement it but since we already have
the causal delivery might as well
exploited can this be
that the causal order in platteville I
mean we can certainly prove the
correctness of this this protocol I mean
basically would have to prove that if
one process CVI I don't know might for
example use proof by contradiction says
assume there's two processes that
deliver messages in opposite orders and
then we would show that there is a
causal dependency between those two
messages because of the token you cannot
send a message until you have to token
so clearly you know there one message
must be causally before the other and so
we would have a violation of causal
delivery at the process that didn't
deliver those messages in that order and
that would complete the proof so that's
that's how one would prove with without
causal if we didn't have causal delivery
we wouldn't get this nice property right
because know that without the causal
delivery there's nothing that says that
can deliver this message over here you
know this could be delivered at any time
it's the causal delivery that guarantees
that the total ordering so you need the
causal delivery and you can prove it
with the cause of delivery and the
protocol works the clear look look a
little you look pensive that can be good
sign or bad sign
ok so that was X to the nth I guess if
that's probably timing-wise not that bad
there's five minutes left I said right
did I write good so tomorrow I'm going
to be talking about gossip protocols and
it's a whole different story and that
they're not that I could get into that
in the last five minutes but maybe there
are some some more questions about the
material that I presented or I can do a
quick recap in order to make sure you
get what you pay for yes well that's a
very good question the said the problem
is you can't prove anything of you don't
have a specification and so it's hard to
find the specification in the first
place a virtual singing in in particular
so there have been surveys the various
properties that virtual city gives but
certainly the early virtual sing any
papers actually this is this is not just
virtual singing I mean if you look at
the old systems papers like you know
it's there is people didn't use to
believe in specification that is still
don't but they but it certainly didn't
get worse over time and it's it's it's
been rampant and so Virgil singing the
ears there's no good specification and
and then the other thing that happens is
that people show these protocols and
then sometimes they prove some
properties of these protocols but
certainly they don't Spence show that
that it satisfies some specification
because there is no specification now
that's a little different for the
broadcast protocols they're certainly
pros for like the atomic broadcast
protocol you know under this is using on
their assumption that there's a fixed
membership and in you know in some sense
we have that every epic has a fixed
membership there are various various
protocols that have been shown and have
been proved correct that's you know
there's a rich literature and also opus
to the books that were mentioned this
morning like Nancy Lynch's book will
contain contain
these specifications off order broadcast
and improves their off I don't know you
but this chapter of a book that never
quite laws by Sun and basses yes oh yeah
that is a very good paper to look up
yeah so they're the so what Lorenzo
points out the let's see i think it was
in sent to act fast Assad Psilakis it
wasn't their third author that's maybe
this is the two of them they they wrote
a survey paper off broadcast protocols
actually that hierarchy that I showed
really came from there they show a
specification of the properties and and
then they give give implementations
they're off I think the full paper does
have proofs of correctness of them as
well so and that's that's available
online it's a very nice survey of
broadcast political yes
how to take I mean so the virtual sing
any property I mean by by its very name
is it's more the other way around you
can take a protocol that was intended
for forcing an assistant is fairly
easily poured it into a virtually
singing this environment the says the
Cygnus protocol's tend to be a lot
simpler and you can because he had sort
of a simulated singers environment you
can do that you wouldn't do the other
way around because you know if you have
a protocol for anything the system why I
run it in in this singers environment oh
I see so you want to take that take a
protocol that cannot do reconfigurations
and now you want to extend it so there
can be elastic or dynamic in some way
yeah so you should be able to run the
protocol in an Airpark and then because
of the properties of the flash protocol
with it becomes you know basically put a
nice end to the protocol at the end of
the air pop right and so so so so it's a
good point so now it depends on what
properties that a single is protocol it
is trying to provide if that a sing this
protocol is but the atomic broadcast
protocol you're fine i think you know
like so you just order everything in one
view and then you go you know you flush
it shouldn't wave my arms it doesn't
like that and whenever I wave my hands
it's gets gets angry so the yes so in
one view you can the protocol would
order all the messages and then you know
you start a new view and then that same
protocol can be used to order the
messages there and buy the properties of
message delivery in the views you would
still have a total or so for that kind
of ordering it would work just fine but
I'm sure there are other properties one
could could come up with what
our problem maybe not ordering
properties where it wouldn't work and
it's to give an example of that say had
a protocol that eliminates duplicate
delivery it's it's a protocol that's his
own when there's a message that ever has
already been delivered don't deliver it
again well in that case it would work
with in one view but it would probably
nothing that prevents next view from
delivering a message that was delivered
in a prior review and so a protocol like
that wouldn't just work simply in a
virtual saying this environment so
there's some properties that would be
where it would work what it would work
for and so properly properties that that
wouldn't get to transfer that easily
more quick less questions good I'll see
you guys tomorrow we'll gossip thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>