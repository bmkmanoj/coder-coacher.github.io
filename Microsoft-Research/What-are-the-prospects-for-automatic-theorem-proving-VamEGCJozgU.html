<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>What are the prospects for automatic theorem proving? | Coder Coacher - Coaching Coders</title><meta content="What are the prospects for automatic theorem proving? - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>What are the prospects for automatic theorem proving?</b></h2><h5 class="post__date">2016-06-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/VamEGCJozgU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
well a very good afternoon and welcome
my name is chris bishop i'm the director
of microsoft research in cambridge great
pleasure to welcome you to the microsoft
distinguished research lecture an
especially warm welcome to the visitors
and particularly if it's your first
visit to microsoft research so it's a
great pleasure today to welcome sir
timothy Gower's as our lecturer timothy
of course is a very noted British
mathematician he's a fellow of the royal
society he holds the rice ball chair of
mathematics Cambridge he is also a rural
Society research professor in the
Department of pure mathematics and
mathematical statistics and he's a
fellow of trinity college he's worked on
Banach spaces Ramsey theory and random
graphs and random sets and a problem
that's familiar to many of us the the
problem of P versus NP in 1998 he
received the Fields Medal which i think
is widely agreed to be the highest honor
that a mathematician can receive often
compared to the the Nobel Prize and that
was for research connecting the fields
of functional analysis and Commodore
Toric's as well as doing his deep
research he's also variant in
communicating mathematics to a broader
audience many of you will have come
across the very short introduction
series of short books published by
Oxford University Press he's written one
on mathematics which as it happened I
read about six months ago and it's a
delightful overview and and it gives
very good insight into the beauty of
mathematics I commend it highly now of
course a lot of mathematics is done by
individuals or small collaborations well
timothy's explored the opposite extreme
he asked on his blog whether it's
possible to solve mathematical problems
through massive collaboration and he
posed a particular problem as part of
this so called polymath project and
within about seven weeks he concluded
that particular problem was probably
solved Timothy was recently knighted by
the Queen for services to mathematics
and today he's going to talk about
another of his interest which is the the
challenge of automated theorem moving so
Timothy
thank you very much I'm very aware that
they're likely to be several people in
the room who are much more expert than I
am in the field of automatic seer
improving so I feel a bit nervous about
the title here I'm not really an
authority a sufficient authority to be
able to give a proper answer to this
question so maybe a more accurate title
b what are the prospects for the
particular approach to automatic theorem
proving that i myself like and whether
or not that's the right approach is a
completely different question so as a
mathematician i've always been
interested in not just mathematics but
in how we come up with mathematics how
we find proofs and things like that
that's partly if a very practical reason
if you're going to spend your life doing
mathematical research then one of the
things you want to do is make the
process of doing it as efficient as
possible so you produce as much as
possible or as good things as possible
and so just standing back and thinking
what am i doing when I'm doing it I
think it's a good investment somehow and
so that's also with teaching one of the
things one of the jobs I've had an
additional research is trying to help
other people come to understand things
that they don't understand and again I
think one wants to think more abstractly
about what it is to understand math
mathematics what it is to what it is
that the people you're teaching aren't
able to do that you want to get one to
be able to do how to get them to be able
to do it and things like that and this
all leads me into thinking very much
about this general question of how to
find proofs and it's a short step from
there to thinking about automatic
theorem proving it's really the question
how do you teach humans to find proofs
is not that different I would contend
although this is slightly controversial
from the question how would you teach
computers to find proofs but I just want
to sort of say a little bit more about
what I what I mean when I say that I'm
talking about one particular approach to
automatic theorem proving rather than
the whole field so their various spectra
suppose one should say so one is
we just remind myself area from going
from checking to proving so sometimes
when people use the phrase automatic
theorem proving what they're really
talking about is the checking of proofs
are talking about taking proofs writing
them in some formal language like
or something like that so that a
computer can check that it's it's valid
what I'm interested in is very much at
the other end of the spectrum it's
improving its in sort of the ultimate
would be you just type in a statement
your computer would spend a millisecond
or two and then it would up comes the
proof of the statement on the screen of
course in general that's not feasible
it's an it's an np-complete problem so
if you don't know what np-complete me it
just means hopelessly difficult but
mathematicians aren't doing this problem
in general they're not taking arbitrary
statements and trying to find proofs
they're taking very specifically sort of
tailored statements that are sort of
beautiful interesting important relating
to other statements and that sort of
thing so that's really what I'm talking
about so I'm taking sort of natural nice
statements and tried to find natural
nice proofs so another very important
spectrum just on to sort of place what
I'm talking about as between machine
oriented and human oriented so roughly
the machine oriented approach says what
if what is it that computers a really
good at they're good at searching
through lots of stuff extremely fast
they have much bigger memories than we
do there goes a whole lot of brute power
what we're good at is a sort of
ingenuity bit so sort of combination of
our ingenuity and all sort of brute
force of the computer should be able to
do more than we can do on our own so the
idea there roughly speaking is to use
the superior power of the computer and
really exploit it in a way that would be
impossible for humans the human oriented
approach to theorem proving is to say
well it really seems to be the case that
humans are remarkably good at finding
proofs and they can find proofs of
things that so far
well nobody knows how to get computers
defined at least on their own so it
makes sense if you're trying to program
computers to look at how humans do it
and try to imitate that so there's a
sort of balance to be struck do use the
brute power of the computer will do you
could try to coffee humans as much as
possible and I am right at the I mean
what I'm interested in is right at the
human oriented thing that's what's what
fits in with my interest in my own
research and teaching and so on and that
is what I'm very interested in trying to
get computers to do I'll say what I mean
but I would classify myself as an
extreme human-oriented whatever I should
mention at this stage that although I'd
sort of it's probably best to regard
this as a hobby in a sense and the day
job is my actual mathematical research
it's a bit more than just a hobby and
I've as I mentioned in my abstract I've
worked with probably called Moines
gannis Willingham from the computer lab
in Cambridge well there's just saying
from the computer lab is perhaps not
doing injustice because he's very very
good at mathematics at linguistics and
the computing all sorts of things a very
talented person indeed with all sorts of
relevant abilities and I'll talk a
little bit about our work at the very
end but because as I say I feel a bit of
an amateur and a room full of
professionals I'll just so I'll relegate
that at the end just show you tiny bit
about what we've done but really what I
want to do more is just sort of so to
speak play to my strengths and just
concentrate more on a mathematical side
and one more spectrum between
interactive and fully automatic do you
want your program to be something that
you keep giving it little hints to which
is a an important thing could be very
useful or do you want to be fully
automatic so what we're interested in is
the fully automatic side but actually
the it's not such an important
distinction because if you've got
something that's fully automatic but
can't do absolutely everything then
you've already got an interactive
problem solver suppose you've got a
problem solver can do sort of moderately
hard problems but not super hard
problems and if you're trying to solve a
super hard problem then you sort of chop
it up into moderately hard problems
getting future
those and everything could be much much
faster so actually sort of not a semi
powerful fully automatic prove it would
turn into a very useful interactive
proven okay so here is what I regard as
the fundamental problem that I'm
interested in so this is where it's sort
of an interested in not just from the
point of view of computing but also for
my own research as I say so what is it
how the humans find proofs as efficient
is they do it's an np-complete problem
in general and yet when we for the
actual problems that we come up with in
practice of course there are lots of
open problems but we are also remarkable
success in solving some of these
problems that look completely impossible
to start with and then eventually they
get solved I want to give a very very
simple example it actually requires a
tiny bit of group theory but if you if
you're not familiar with group theory I
think you'll sort of get the general
idea or get the general sort of broader
point I'm trying to make with this
example so one of the important facts
about groups are something called a
cancellation law if ax equals a why you
have to prove that x equals y this is
true for ordinary numbers but groups a
bit more sort of like a lot of abstract
form of ordinary numbers so here is a
sort of what a human might do let's say
well if ax equals a y by the one of the
group axiom says you can find an inverse
to a witch be a equals the identity if
you multiply both sides on the left by B
then you use the associative law you can
replace B of B times ax by be a times X
is the same as B times ax BAC identity
we've established out so we get an ax
equals B ax etimes X as X because the
identity so X is e x because you can
swap things around when you have an
equality I'm just going through this
rather fast you do something similar on
the right hand side and then you get a
big chain a bit qualities and you end up
showing it x equals y that's sort of the
steps if you just go right back to the
group axioms that would need to be in a
computer and it's not very difficult for
him to come up with them in practice of
course a human wouldn't right
all these intermediate steps and it
would look more like this you'd say
we've got the day x equals a y
multiplied both sides on the left by the
inverse of a and then the inverse of a
cancels with the a on both sides and so
you get that x equals y now the slightly
mysterious thing about this is it's a
very very simple proof for a human but
if you start thinking about how a
computer might discover it you get this
sort of odd thing that it's taken the
original equation ax equals a Y and made
it look more complicated because you
just put an a to the minus 1 on both
sides you've got sort of a more
complicated expression and only after
you've done that do you then get that a
2-1 a cancels and it gets down to
something simpler and if I go back to
what we had here some spelling out all
the intermediate steps and it really
makes it quite a lot more complicated
before you finally get to the simple x
equals y and if you've got something
that's got to get more complicated first
then that makes it much more dangerous
if you're trying to get a computer to
search for the answer because if you had
an algorithm to just said whenever you
can spot a simplification simplified and
you know that that's going to terminate
its going to something gets simpler and
simpler it can't go on getting simpler
and simpler forever so at some point it
will terminate but if you're allowed to
get more complicated then there's all
sorts of different ways that you could
imagine getting more complicated packs
we could have multiplied things on the
left on the right by a 2-1 or we could
have taken the inverse of both sides or
all sorts of ridiculous things that we
could have done why did we choose that
one if you just add a sort of brute
force search you'd end up looking
through all sorts of different
possibilities until you sort of stumbled
on one that just happened to simplify
when you got down to make sequels why
that would be very unlike the way a
human works so this is just as why I
give this example to give it sort of to
say that even this rather simple problem
for humans is quite subtle so if you're
more of an advocate of machine oriented
approach then what you would might do is
in general with proofs and this is a big
difference between the way mohan and i
think about it and the way quite a lot
of people think about it so you can
think of the search for a proof as a
general sort of
problem computers can do quite a lot of
search but if you keep on sort of you're
searching for a step to do and then each
step you do leads to another search for
a step that you want to do in each step
there leads to another set if these
searches build up you get what's called
a combinatorial explosions there are two
possibilities and then for each
possibility there are two more
possibilities and breach of those
possibilities are two more than you're
sort of doubling and if you've got a
hundred steps to do then you've got to
to the hundred possible things that
search now it's just too big so what
people do is to say well if the search
threatens to get too big let's find
clever ways of pruning it you could
imagine is fitted with a chess-playing
program you don't want to look at every
single possible position so you have to
find clever ways of ruling out some of
the ones you don't want to look at it's
a bit similar been looking for a
mathematical proof so this the idea here
is you sort of you would like to do a
massive search you can't and so you sort
of chop it down until it just becomes
practical when you use the brute force
as a computer to do it so that would be
the sort of outside in approach and an
inside-out approach would be the exact
opposite you sort of you basically don't
want to you want to start with the aim
of using no search whatsoever if a human
would just say of course you multiply
both sides on the left by a to the minus
1 then so should a computer and after a
while you realize that even humans do a
little bit of search so you can't just
rule it out completely but you then just
sort of build it up little by little
just so instead of starting with a huge
amount of search and pruning it you
start with a tiny little plant and sort
of let it grow so to speak it's a
different emphasis but one of the
difficulties it bedevils this approach
is that it's very difficult not to come
up with sort of ad hoc reasons for why
you might say well in this example we
like to multiply on the left by a 2-1
for such-and-such a reason but and but
then that won't generalize to other
problems but on to some general
principle that works here and actually I
think unfortunately I think the reason
for this example is a slightly ad-hoc
one I think the reason we find it
obvious that we multiply on both sides
by a to the minus 1 is that we're just
used to ordinary numbers
with ordinary numbers we just divide
both sides by a that's the cancellation
law and then we sort of know when we
first start learning group theory that a
to the minus one is sort of behaving
like one over a and it's our sort of
analog of one over a and so we're just
reasoned by analogy somehow and say
let's try and do something similar to
what we'd do if it were ordinary numbers
and then multiply on the left by a to
the minus one is the nearest we can
think of and it works but that is rather
particular well it's either rather
particular to that example or it
requires you to understand all about
numbers and what how to reason by
analogy things like that so that becomes
a big task just for a very small problem
but I think that's possibly just the way
it is so why bother with a human
oriented approach at all the machinery
approaches had some spectacular
successes one of which is a solution of
something called the Robins conjecture I
won't say too much about that except to
say that it was an open problem of
interest to mathematicians and it was
finally sold by a computer so this was
regarded as one of the great success
stories of automatic theorem proving the
final proof that it found was fairly
short but the search for that proof was
huge sword duel to run for a very long
time searching through all sorts of
possible manipulations until finally it
found one that got from the sort of
starting point to the target and and
then that proves the Robins conjecture
but somehow that was a very special sort
of problem and not very like the
questions that we most mathematicians
come up with most of the time even
undergraduates so for a lot of
interesting problems I'm not saying the
Robins conjecture wasn't an interesting
problem but for a lot of interesting
problems you get this problem but I've
just talked about of combinatorial
explosion so you have the process of
discovering a proof involves lots of
steps that each step there are plenty of
different things you could do so if you
did a brute-force search then the number
of possibilities you have to explore
would rapidly become completely
impractical so and that's so
characteristic of such a lot of
mathematics that I just feel that the
human oriented approach it's just
absolutely essential but not going to
get to
a fully automatic theorem prover without
taking very seriously how human
mathematicians have evolved over the
centuries to do mathematics and another
reason actually is that if you've got a
process that finds a proof in the weight
of the human mathematician finds a proof
it gives you much more insight into that
proof then if you just have a sequence
of steps that happens to guarantee that
the original statement is true
guaranteeing that it's true is sort of
worth doing in math but it's only a
small part of the story and what we
really like out of our proofs is
explanations we like to understand why
the thing is true and one of the ways of
understanding it is just to be left with
the feeling when you read the proof that
sort of with hindsight maybe I could
have found that proof myself I sort of
see where the ideas come from and that
sort of thing actually this is a
criticism of some math paper some math
papers write a written in very cryptic
ways to okay see that it works but how
on earth did you know why formally
formulate that lever and thought oh
that's very annoying actually but people
sort of right in a way that obscures
ideas but some people don't and I think
we're having an automatic theorem
provers and one that can tell you it's
thought processes and they're not you
know I searched a billion possibly the
possibilities and this one happened to
work would give you much more insight
that would be very nice so that's just
another reason for being interested as a
mathematician in the human oriented
approach so I've said that there are
some problems that humans find quite
easy and computer still find quite
difficult I'm going to show you a couple
of problems and this is the first one so
the two problems i'm going to show you
our consecutive problems on the first
example sheet of a first-term
undergraduate course in cambridge it's
called numbers and sets of course so you
don't set a question on an undergraduate
example street if you think it's going
to be impossibly difficult so and this
wasn't one of sometimes you do he put it
at the very end of the sheet and put a
star this was not a starred question it
was an ordinary question that it was
expected that you know substantial
fraction of undergraduates would be able
to do
now the reason this would be fairly hard
for a computer i think and i like my
guesses or not absolutely certain but my
guess is beyond current technology for a
fully automatic there and prove it to be
able to prove something like that the
reason is that it's it's asking you to
find something it's asking you to find
some n from integer n such that n n plus
1 n plus 2 all the way up to n plus 99
are all prime numbers and doesn't give
you any clue about how to do it so how
might one try and do it well the only
obvious thing it's just a brute-force
search does one work no the to work out
of three work but actually it's a
carefully chosen question if you do a
brute-force search we're going to have
to go up a very very very large in and
used it's not going to work so right
there just too many Prime's the primes
do thin out eventually but it takes a
very very long time for them to thin out
a brute force search is not going to
work but then what do you do there's
nothing in the question that sort of
tells you what to do next somehow so
very hard to imagine how a machine would
do now what I want to try to do is just
break down the sort of typical thought
process for solving this question not
the only possible thought process but
just a typical one into smaller units
and those smaller units I think should
look much less challenging for a
computer to do automatically so I'm
really just trying to convince you I'm
trying to explain in a sense why I'm
really sort of have been convinced for a
long time that something like there's
something like this extreme human
approach should be possible
unfortunately I can't claim that I have
a program of doing this sort of thing
but I feel that what's stopping me is
simply that it's just a lot of work is
needed to convert the sort of basic idea
I don't feel as a fundamental obstacle
right if I had a team of you know 20
people working with me for five years
all very much with the same sort of view
about how things should be done and we
did nothing else but I I think we'd it
would be possible to to get there what
my experience with Mohan has been that
we've got things to prove quite easy
results also sort undergraduate results
but we keep finding sort of little tiny
technical difficulties they don't seem
fundamental but sort of oh gosh I'm
quite thought about that it was a little
tweak and it feels that that process
will converge but it just it hasn't yet
anyway let's see how we might find so
first of all it says make the question
just a tiny bit more formal and it could
be formalized much more if you wanted to
make it comprehensible to a computer but
I'll use words like we want and things
but that's if you that's short for
that's standing for an existential
quantifier and anyway so we'd like to
find an end such that n plus R is not
prime for all our is naught 1 up to 99
and that gives us our 100 consecutive
non primes that's just say what it means
for it not to be probably need to have
some a that goes into n plus R and being
a bit sloppy I'm not saying that a
mustn't be 1 or n plus R and there must
be a positive integer but that's what I
mean it's must be a proper factor of n
plus R so one of the standard techniques
that one uses is generalizing so when
you see a number like 99 you think well
it probably hasn't got a very
fundamental role to play in this problem
let's tidy things up a little bit and
and will it will replace 99 by to some
arbitrary number M it's attempted one of
the reasons for that is just not to get
distracted by it sort of irrelevant data
so to speak but actually have another
advantage which is once you've made em a
variable you can try some other cases me
you can actually try simple special
cases and not just not just complicated
ones or a very obvious one why not this
is try em equals one so can we find an n
such that both n and n plus 1 and non
primes I they've got factors now let's
just consider so we'd like to find an N
and an A and a B that a and B will be
the factors so what
going into n and be going into n plus 1
and I'll just reproduce that up here so
what next well if you're going to do
something like that a very standard
everything be so close games will
standard proof finding techniques so
another very standard technique would be
just let us pick the simplest
possibility for a and see whether it
works if we can get it to work so we can
find so I'm just specializing at this
point I'm going to say instead of honey
n a and B I'm going to just declare that
a is too and see whether it works so
we'll go for N and B so 2 goes into N
and B goes into n plus 1 well looks ok
so far we can take to get to going into
end but let's sister we've still got
this bee to worry about well let's try
the simplest possibility again the same
technique and well the absolute
simplicity might tries to but if to goes
into n then is even n plus 1 will be odd
so too is ruled out so let's try the
next one will try three so can we get
two to go into n and three to go into n
plus 1 but some specifically chosen n
and you're not allowed to choose n is 2
because the tools not allowed to equal n
sir so just make that clear but if one
thinks about it for a tiny bit even with
a brute-force search you quickly arrive
at the result of eight works so 8 is
even and 9 is a multiple of 3 so 2 goes
into 8 3 goes into nine and we've done
it for that special case so it seems to
contradict what I've just said so when I
say are we done what I really mean is
has that given us a sufficient insight
to solve the whole problem does the fact
that two goes into eight and three goes
into nine show us how to find a hundred
consecutive non primes the answer is no
it doesn't it's unfortunate just looks
like some experimental fact that doesn't
have too much bearing on the general
problem so there's continued a little
bit anything I can think of at this
point is to try the next case so let's
try finding NAB and sedo a goes into NB
goes at n plus 1 C goes at n plus 2 and
we dispose of this one
fairly quickly because we take as two
beers three but once we know that n is
even we know that n plus 2 is even and
so actually we can just take C is too so
that's not very important I mean not
very didn't really help us much what
about the next one so what are we trying
to do here by the way why we're trying
two more cases we're sort of hoping that
at some point will stare at it and see
some sort of pattern that we can then
generalize so n ABCD a goes into NB goes
into n plus 1 and so on so then which is
the simplest values we've already know
that 2 3 &amp;amp; 2 are going to work for a B
and C and now we find what could we do
for d going into n plus 3 well because n
is even n plus 3 is odd so tues not
going to work because n plus 1 is a
multiple of 3 n plus 3 is not a multiple
of 3 so 3 doesn't work either for
doesn't work because too doesn't work so
5 is the next possible thing that could
work so we think okay can we find an end
so that n is even n plus 1 to multiple
of 3 and n plus 3 is a multiple of five
now there's another question here it
says is it worth the bother of trying to
find such an end in a way it's not
really because you know when we found an
end worked for two and three we've found
eight it didn't really help it just was
ok could be done but it hadn't the fact
it couldn't could be done didn't really
give us a clue about how to generalize
so actually just experiment we might
want to do it to reassure ourselves but
it's not really going to help just to
exhibit an end so maybe we just don't
bother instead we just carry on with
this pattern so what happens next let's
just quickly if you carry on this same
sort of argument n plus four is taken
care of and so we end up wanting to to
go into n three to go into n plus 15 to
go into n plus three and seven to go n
plus five if we just carry on this
general approach and now I think one can
see a pattern so what does 2357 suggest
anything though
are the first four prime numbers and two
goes into n 30 plus 15 goes into n plus
three and seven goes into n plus five is
there a pattern there yes because two
minus two is zero 3-2 is 15 minus two is
three and seven minus two is five so it
seems as though what we're getting all
the time it sort of we want Prime's to
go into n plus stat prime minus two and
we would want things to work up to n
plus M so if you look at it a little bit
you find at we but we would like this
condition to hold for every prime up to
M plus 2 it's just if you're not
following exactly what I'm saying I
think I just want to go a little bit I
wanted whiz through a little bit but
just believe me that came that was very
easy what I just what I did if one
thinks about it like this much time to
think about it and it's reasonably easy
to show that if you've got that
condition and I'll jump over that part
then you will in fact be done so if it
is the case that for all Prime's up to n
plus 2 P goes into n plus P minus 2 then
you'll have your M consecutive non
primes so that's the general principle
want P to go into n plus P minus to
every prime up to n plus 2 and now we
realize that we can simplify it so P
going into n plus P minus 2 is the same
as P going into n minus 2 of n plus P
minus 2 as a multiple of PETA and so is
n minus 2 and conversely but it just
looks nicer not to have the P here so we
now want n minus 2 to be a multiple of
every prime up to M plus 2 now this
point it's become a very easy problem
but that's just spell it out can we find
a positive integers divisible by all
Prime's up to n plus 2 which would be
our n minus 2 yes just multiply all
those Prime's together and then of
course it's divisible by all those
Prime's and actually that's finished we
found a solution so what is the solution
it's multiply the first few Prime's
together in the case of a hundred
multiply all the primes up to 101
together and
track to know add two and that will be
your starting number and then those the
next hundred or the make that number in
the next 99 will none of them be Prime
so there's a whole process I've some
broken down the thought process into
much smaller steps if you go to a
supervision and you're bad supervisor
the supervisors will say consider n
factorial plus 2 3 I mean it's like 101
factorial then 100 1 factorial plus 2 is
a multiple 201 talkatora plus 3 the
multiple of 3 all out to 101 factorial
plus 101 is a multiple of 101 so it was
easy of course it's very easy to follow
that argument or if if you don't follow
it if you're a undergraduate
mathematician it's very easy to follow
that argument but absolutely no insight
has been given into how to find the
argument right and that's the sort of
thing a computer for a computer just
sort of happening to think of 101
factorial plus 2 3 4 5 is not usable so
here's our sent here this was the next
question on the same sheet so here we
have a sequence which we get each term
we had to then we had four then we had
six and then we had eight and so on and
so forth and the question is do you
always get a prime so how might one go
about that well here's a case actually
where it turns out that if you use brute
force on a computer you can solve it in
very short time but you'll get an
extremely unenlightening solution is a
sort of here's one that's not prime and
it would be just a bit too tedious a
brute force for a human to do for human
it's much better to think so it's a
sense thing to try first is to look at
the first the next few terms of the
sequence so 61 we add 10 at 12 at 14 at
16 at 18 and 20 and all those numbers of
prime so after a while when you do that
you start losing heart and thinking well
perhaps is actually as they are all
prime or at least I'm not likely to find
a composite one for quite a long time
and so maybe we should sort of step back
and see whether there's anything else to
do
there's a fair this is going to take
much quick much less time than the
previous one there's a pretty obvious
first thing to do is to find a formula
for the general term of this sequence
and what is the nth term well it's 41
plus 2 plus 4 plus 6 plus 8 all the way
up to as it turns out twice n minus 1
and a human would do this by I mean
maybe a computer would do that by just
sticking it in mathematical or something
like that I don't know but the human
might do it a bit like this you say well
this is some of the First Lord of even
numbers but I know that the sum of the
first n whole numbers is because I was
at school I did a level and it's n n
plus 1 over 2 so if you double that I'll
get in n plus 1 but if I'm instead I
only go up to n minus 1 i substitute n
minus 1 for n here and get 41 plus n
times n minus 1 and so that's a formula
for the general term not too important
how you come up come by that it's a sort
of standard thing to do so now the
problem is are all numbers of this form
prime so either you see that straight
away in which case it's mysterious thing
and I don't want I don't like mystery
and mat maari so let's just see what we
might do if you didn't see it straight
away and maybe you don't so here's some
say could it ever be an even number for
example so we will try to being
effective so good is ever be even now
says no because one of those two numbers
will be even so that product will be
even and then when you add 41 to make it
odd and a similar argument shows that it
can't be a multiple of 3 is slightly
more cases to check but it turns out
this can never be a multiple of 3 and in
fact if you want you can check that it
will never be a multiple of 5 but after
a while you'll start getting a little
tired of this case checking now when you
get tired of the case checking and
instead of just trying any old small
things instead of trying the simplest
thing you might say was there is another
problem solving technique which instead
of finding look just looking at the
smallest thing or something like that
try and find something is actually
connected with the problem so are there
any integers that are connected with the
expression for T 1 plus n times n minus
1 well of course that's one staring
faith it's 41 so it might be rather
natural I mean perhaps it would turn out
that in reality of models of the 40 or
42 or something but 41 looks like a
pretty good candidate for something to
to try so does 40 can we find an end for
which 41 goes into 41 plus n times n
minus 1 that is very easy but let me
spell that out by dividing up into even
smaller steps so what does it mean for
41 to go into n n minus 1 it means that
we want an N and an M such that 41 times
m equals n times n minus 1 and now we
can just solve it by matching up the
4100 the N and the M with the n minus 1
just say well let's take n to be 41 n
minus 1 2pm which means the dam is n
plus 1 so M is 40 and then we're done so
going back to hear if n is 41 and this
is a multiple of 41 that's not a prime
and there again you could just say that
straight away but it's there is a sort
of genuine problem solving technique ok
so of course it's not enough to show you
that the search for a proof can be
broken up into small simple steps in the
way that I've tried to do by there is a
very important distinction between the
proof being divided up into small simple
steps and the discovery of the proof
being divided into small simple steps
I'm talking about the second rather than
the first so the small simple steps of
things like let's generalize this or
let's look at a simple special case and
that sort of thing they're not you know
this implies this implies this implies
there's a completely different thing it
is a very interesting fact about
mathematics that proofs themselves can
be divided up into tiny steps but that's
not the fact that concerns me right now
so we've got all these devices it's not
enough to show that a sequence of those
devices will end up in the discovery of
a proof I've also got to give you some
account of how you choose the particular
devices and you don't choose other ones
that are totally unsuitable so there are
all sorts of other things the one could
do that wouldn't have helped to solve
those problems and so how do they know
to go for the ones that would so that's
one problem and
another problem is those sort of lower
level problems I once you've actually
chosen which problem solving device to
use like generalize or something how do
you actually go ahead and do it I think
the second is much easier than the first
to automate so I'm going to concentrate
on the first so that itself divided up
into two sub problems so one of the
things you want to do when you're
looking for a device has make some
estimate of how much effort it's going
to be and how helpful is likely to be in
that sort of thing so how do you
actually do that how do you look at it
and say oh generalizing looks as though
it's going to be good here trying
setting N equals 1 that's not going to
be any help at all so a human we make
these judgments quite easily but how
would that be an automated bull saying
so that's one question another question
is supposing you can do that so
supposing you can make good judgments
about how useful various techniques are
likely to be you won't be able to say
with absolute certainty that this
technique going to help and that one's
not going to be very helpful you it
always be some probabilistic judgment
which you'll then have to go and
actually do it and see whether it does
help if you didn't have to do that
you've sold a problem already so to
speak so if you've got assessments of
various different things to do how do
you actually go ahead and decide which
one to do what would be a good strategy
so I want to discuss this second sub
problem the sort of problem this little
strategic problem that your face when
you're doing math so it's actually a
special case of a much more general
problem so you're sort of in some
environment and the environment i'm
thinking of here is it's you and the
piece of paper on which you've scribbled
and the problem that you're trying to
solve and the thoughts that you've had
and you have a choice of actions that
you can make and these actions have you
know some some information about what
you think the rewards the various
actions will be in what the costs of
various actions will be so typical cost
will be just the time it takes all the
annoying effort it takes to do some
calculation that you know that you could
do in principle but it might be rather
tedious and then
sort of possible rewards are you know
maybe if I do that that will give me
some insight which will help me later on
to solve the problems we've got these
sort of costs and rewards and a goal you
want to get to which is solving a
problem but it's a much more general
thing which is just idea of actions and
costs so for example in those things
that people look at which I'm sure many
people know about Markov decision
processes it sounds quite like Markov
decision processes well there are fairly
important distinction between this and
Markov decision processes is that we
don't at all have perfect information
about what's going to happen later on if
we take various actions so if you do
know about those there's also very
strong sort of information constraint
well there people have thought about
that sort of thing as well about acting
when you don't have perfect information
so the point I want to emphasize is that
this sort of question has been studied
quite a lot so I think it's worth
studying it in the context of
mathematics although I think it raises
interesting difficulties that are
peculiar to mathematics but something a
bit odd about using a probabilistic
model for something that is
deterministic as mathematics so you
might sort of say I'm going to do a
calculation and I think the probability
that it will simplify down to something
nice is quite high if you say what does
that mean either it God sitting up there
knows either knows that it's definitely
going to simplify or that it's
definitely not going to simplify down to
something nice so what do you mean you
no and that's actually I said I find out
quite an amusing problem but it's not
something that puts me off because we're
all bayesian as these days and some
probabilities not a sort of measure of
what will happen if you repeat the
experiment over and over again it's a
sort of measure of our uncertainty and
that's something so I think that's a
probabilistic model is appropriate even
in this role of deterministic context
without a complete solution to this
problem let's just distill a couple of
general principles so something is good
to do if it's cheap and something is
good if there's a reasonable chance that
it'll it'll be helpful so if you've got
a very complicated calculation you
perhaps try and do simple things first
or if you've got a simple calculation
but you're pretty convinced is just
going to be completely irrelevant like
that one of seeing where 25 went into 41
plus n n-
one would be fairly simple but unlikely
to be helpful so you just don't bother
with it or you don't bother it if you're
trying to optimize your efficiency but
yeah sometimes you find that there are
some easy things you can do that are
probably not going to be all that
helpful and some things that look at
that it might be quite helpful but it's
going to require an awful lot of thought
to make them work which do you do first
and it's the balance so let's just have
a look in going back to this example
about how we might choose a problem
solving device so remember we wanted to
find an A and an n such of a goes into
41 plus n n minus 1 so here's a
selection of probability of
problem-solving devices that we might
have tried so one must have a look at
the smallest value of n it isn't yet
ruled out and Hendrick go for a but we
did that right at the beginning we
looked at some small values of N and we
found at all the numbers for all prime
and so we sort of know now that that
doesn't work it's not a ridiculous thing
to try but we've now established that it
won't work another one might be find a
smallest value of well actually it's a
I'll come to the assessments that is in
another slide but here so another one we
find the smallest value of a and then
the smallest value of n will find the
smallest value of a that hasn't been
ruled out and then see what that would
tell you about N and then try choosing
an end thats related to the problem try
using in a thats related to the problem
we'll try generalizing the problem by
changing 41 into m and some of these are
good some of these are not so good so
let's have a look at some not-so-good
ones so I just said it so if you try the
smallest value of n that hasn't been
ruled out you find that you look at
these numbers 41 43 47 5360 170 180 397
must stop and they're all prime so we
don't really get anywhere the next forms
to try finding the smallest value of a
and then the smallest value of n but we
already know that small values of n
aren't going to work so this strategy
doesn't you can sort of tell actually
that it won't be helpful and what about
the smallest value of a that hasn't been
ruled out and then look at the
constraints on n so you might say let's
try a
equals two I talked about this before so
that's saying can you find an n such
that 41 plus n times n minus 1 is even
it turns out you can't it's always odd
so it might say well let's try a equals
3 can you find one that it's a multiple
of 3 no it turns I just never a multiple
of 3 it's never a multiple of 5 and when
you've tried a few of those as a point i
want to emphasize it was sensible to try
out small values of a to start with
because it's a simple thing to do simple
thing to see whether it works but after
a short while first of all the larger a
gets the harder it gets to see what
happens and secondly the larger it gets
the more you sort of increase a and
don't don't get anywhere the more you
start to feel this whole approach isn't
getting anywhere and so you're sort of
assessments of the probability that
trying small values of a is the way to
go changes and you start at all the
balance between rewards and ease of
calculation changes have you get new
information that suggests that maybe
this this approach is not a good one so
it wasn't hopeless but it turns out not
to be good so you want to try something
else then all three of these it turns
out our good one so if you choose an N
you could take n is 41 problem solved
which is an a a is 41 that's one I
actually use before problem solved 41
divides and minus 1 and 0 KN is 41 will
do fine the third one slightly subtler
if you reply if you generalize rather as
we did with the first problem by
replacing 41 by an arbitrary integer M
that immediately sort of tells you not
to look at small things like two and
three because you don't know anything
about em so then you're forced to think
of something that somehow related to the
problem or built out of em in some way
it just forces you back this desire of
generalizing forces you back to these
strategies that were good ones and away
from the strategies of the bad ones so
it's a sort of good in a more meta sense
I don't take this slide too seriously
because I'm not an expert on machine
learning so it's just my little hunch
I'm in a room full of people who will
probably have exactly the opposite hunch
with much better reason and I have for
having the hunch but let me just say
so I feel that there could be a role for
machine learning and mathematics but a
rather restricted Rose I think machine
learning might be good for those
situations where but I would maintain
these are very rare these situations
where humans can do something with ease
but when you ask them how they do it
they just cannot tell you so if I if you
ask me how is it that I recognize my
mother's face or something like that I
can't really explain I send a car to
explain it in such a way that if you met
her in the street you say wow that must
be so but I think that sort of situation
doesn't occur very much in mathematics I
my spirit seems to be that even if you
think you've had some sort of idea it
just popped at your head out of nowhere
actually if you are not lazy and you
think about it hard you can work out at
least a plausible story about how it
might have brought into a head or how it
could pop into other people's heads and
so I feel that machine sort of saying
let's try machine learning feels to me
like a sort of cop out although that's
not to say that I wouldn't be absolutely
fascinated if somebody managed to do
something using machine learning in a
serious way that could sort of come up
with ideas but even then i'd be little
bit disappointed because then this idea
of explaining short processes might be
rather hard to get it be more like you
know you put it in your neural network
sort of it puts the something that sort
of tells you what the idea is and it
just looks a bit like magic because it's
for other hearts to open up a new let
work and understand how it's working
maybe not always completely impossible
but i feel unsafe territory it's like we
passed quickly on to discuss very
briefly and i er done with mohandie
honest living am so I've been talking
about the high-end problem sort of how
we choose strategies and things like
that but there's a sort of lower end
problem so if you want a machine to
think it like a human and avoid search
where humans would avoid searched and it
has quite a lot to be said for looking
at problems that humans can solve doing
no search at all there's a whole class
of problems
we would class as routine I think of
them as problems or proofs that I don't
have to all I have to do if I'm if I'm
giving a lecture where I have to present
it such a proof is just remember the
mnemonic do the obvious thing at each
stage and you'll get there don't worry
nothing will go wrong so I call those
routine proofs ones that you can find
just by doing all this thing at each
stage and they definitely exist as a
sort of human phenomenon and so if
you're trying to find something that
doesn't do search for humans won't do
search then you have this sort of
general idea what you'd like to find an
algorithm that when humans don't search
and backtrack and that sort of thing the
algorithm went if a human just goes
straight from the hypotheses to the
conclusion so should the algorithm so
that was a challenge we set ourselves
within one small subdomain of
mathematics which was abstract analysis
metric spaces in particular and so this
is in a way the most I think the most
striking thing to other people about the
program but it wasn't our main focus is
that it we could quite easily get it to
output its proofs in pretty much natural
language so I'll show you what a proof
looks like we actually did a tests I
won't do it here but we did a test of on
my blog i posted output from the program
and some human written proofs and asked
if people could tell the difference and
more people voted for our thing than for
the human ones but it was not a sort of
overwhelming majority as you know forty
percent got it right and sixty percent
got it wrong i mean i had so that was a
sort of mini Turing test so that our
program parts so here's here was the
problem if you haven't done second-year
undergraduate mathematics and this will
make too much sense but at least I think
you can sort of look at that and see
that it looks sort of vaguely like the
kind of prose that you see an hour it's
sort of not a hundred percent formal
language it's got all these are the
words in and
I might say just a tiny bit about how to
have that so one of the key things we
wanted was so one thing you might do for
this would be first you find the proof
and then you do a whole lot more
processing in order to turn it into into
a natural language output we very much
didn't want to do that we wanted to have
something that reflected the thought
processes of the program so it was
important it to be a sort of local
method of producing the output in other
words it would have a thought writes
down that thought there's another
thought it writes down that thought it
has another thought so what you see here
is basically what's going on inside the
program it's not some cheat where we
where you reconstruct a sort of human
readable proof after concealing all
sorts of search that the program did
there's a tiny bit of sort of not
exactly cheating but sort of tidying up
so if you just a sentence by sentence
then you find that you get sort of ugly
little repetitions from one sentence to
another and where a human would sort of
we've established that we're talking
about this and so we can use a pronoun
here instead or whatever it might be so
a few tiny little adjustments but really
not very much at all this is a this was
not a so Mohan actually works on
something much more difficult which is
understanding the sort of text that
you'd read in a mathematical textbook
and converting it into into sort of more
logical form this is the reverse process
you have something in a logical form and
they just want to produce some text that
it's more human-like that's much easier
because you get to choose what your text
is if you want to do the other way you
have to resolve all sorts of ambiguities
that was the main challenge for him and
that's very much harder but nevertheless
his expertise was extremely useful well
his multiple expertise was extremely
useful for all these things but it's
particularly useful at this part here
and I think I will stop there
in talk we have a little bit of time for
questions I might take the liberty
actually of asking the first question if
I may you said there that we're all
Bayesian so music to my ears of course I
my work is done if we're if
mathematicians to be Bayesian should
they not therefore move beyond saying
that a theorem has been proven or not
proven and talk quantitatively about the
probability that having been proven for
example if a computer has just checked
the first billion cases and not found an
exception then a rational betting
mathematician would presumably change
the bet that they would make based on
the evidence provided by those first
billion cases even though of course it
doesn't constitute a proof any thoughts
well one thought is that you have to
formulate what you're talking about
rather carefully so for example if my
safe theorem every positive number is
less than 10 to 100 10 to 100 and then
it will check the first billion done
then so some it's a it's a rather
interesting question actually when it is
that looking at a whole lot of cases
constitutes evidence for something I
when it when it's not so a case where it
where it is very compelling evidence is
Goldbach's conjecture so that says that
every even number is the sum of I've
been even number beyond from 6 onwards
is a sum of two prime numbers and if you
use various heuristics about the primes
being sort of reasonably random you can
actually predict not just it it's not
just that every even number aughts bit
of sum of two primes but it ought to be
the sum of two primes in several ways
and moreover you can estimate roughly
how many ways any given large even
number ought to be expressible as a sum
of two primes and if you compare that
against a graph of how many ways these
even numbers actually can be written as
a sum of two primes the agreement is
quite astonishing so when you see that
that becomes very compelling evidence
that think about the primes behaving in
a random sort of way is correct and I
think they've been lot of controversy if
you've been tried to sort of convert
that into a number because somehow those
numbers didn't seem very robust
do you know if somebody then suddenly
proves an unexpected fact about the
primes and maybe your whole estimates
which favorite but perhaps that's
actually what should happen in a
bayesian world some new piece of
evidence comes to light and you're lots
of probabilities change so it feels to
me as though there are possibilities
there and they're also obstacles to
making those possibilities work and oh
my goodness you haven't mentioned sort
of human experience here a little
student might do a lot of backtracking
to solve the problem and then when you
thought is undergraduate degree can see
they also straight away so can you make
the computer sort of learned from past
successes in the same way that well I've
regard that as one of the major
challenges basically so one which I
don't have a clear idea how to do it is
a rather mysterious process when you
watch human mathematicians learning some
say an undergraduate cause if you set
them some well-chosen exercises today
sort of do those exercises and then
something clicks they've got the idea
and in future they find that sort of
thing easy even if they find it hard
before because something's going on that
once they've sort of done a certain sort
of struggle after that it's easy but
what has happened for that to happen I
don't know so that's a hole that is the
problem of yeah how can how could you
get a program to learn from experience
so I think at the moment are we own I
think to try and tackle that would be
setting our sights very high indeed so
at the moment I think we our focus is
more on can you just make a program that
could be taught so you sort of let's say
a program that as long as you can say so
you have to tell it the abstract idea
that lies behind a particular class of
problems that say rather than them but
yeah it is a question I find very
fascinating but also another thing is I
would like to make clear that what you
said one of the other things you said is
very important that different people
with different experiences will
backtrack by different amounts so
everything is always sort of relative to
the experience of of the person and the
same would be true if you're serious
about imitating humans would be true
about programs so what I would want is
for a program maybe I should make it
slightly more precise Oh program should
not backtrack if a human with a
comparable level of experience what
you've given the program would not
backtrack something like that but yeah
in order to get to sort of the
singularity I think you need programs
that can learn from themselves maybe
even set their own exercises and once
you've once they can do that then you
just stand back and wait for the serums
to come rolling out is going to make
difficulties viewers common sense which
basically can be defined as the
accumulation of the best amount of
trivial knowledge so for your first
example certainly I and I imagine many
people who know some mathematical
mathematics will say of course the
answer's no I forget how you put it
because by the prime number theorem and
even if they know the prime number
theorem veneer the primes thin out their
force impossible that one percent of
numbers are scoring to be Prime forever
so they will know the right answer
immediately simply because of their
background knowledge and in fact in fact
me the idea of multiplying bunch of
numbers together also occurred
immediately and that I assume comes from
the inside I have idea of a math degree
but I've only done master logo on your
second question that was even easier to
my mind the immediate thing said was
prime numbers don't behave like that and
this is a knowledge of any
mathematicians just great I assume you
agree with me
everyone just knows they just don't have
these simple things that say oh yeah all
of those are going to be prime um and
this is the combination i had of leaving
lots and lots of mathematic books and
some are simulating vast amount of
knowledge but this is known to be a very
difficult problem in AI you just call
you make fast encyclopedias like site
which I type in mountains of trivial
facts and then try and get natural
behavior additive so and this is what
you're up against my notice or the
making wizard with those examples was I
agreed it for a really experienced
mathematician the solutions would sort
of pop into your head but it is also
possible to solve some if the idea
doesn't pop enjoy it if you've got much
less experience and so this you know for
a first-year undergraduate they wouldn't
know the prime number theorem so they
wouldn't necessarily think oh the primes
going to thin out and up so it's
obviously going to be true actually
another sort of small things as I think
the question is find an end that works
rather than just show that there exists
an ends and then that would mean that
appealing to the prime number theorem
would would not be enough because it
would just be a sort of abstract
existence proof but that's a little
pedantic point so I think that maced I
mean I think this could have
accumulation of common sense it prob i'm
sure it would be a challenge but i don't
think it and it might be enough of a
challenge that it means that there are
significant limits to where one can go
with this sort of approach but i think
what I've tried to try to convince you
obvious at least one can get started
it's possible to solve these problems or
to break them break up a thought process
into small ones even if that thought
process is not something that an
experienced mathematician would do but
it could be something that's an
inexperienced mathematician might do to
get from sort of zero to solving those
problems so so it's not obviously
correct this but I have a sort of hope
stroke belief
that mathematics is a sort of domain
where there are some of these notorious
AI problems kind of somehow pieces of
science depth but I admit that that
could be wrong could eventually find
that we just get stuck because of very
notorious problems so there are quite a
lot of people still wanting to ask
questions but I think in the interest of
time maps will bring the formal
questions to a conclusion sir Timothy
will be staying around for a little
while you're very welcome to asking
questions informally outside please do
join us for drinks afterwards and the
first please join me in thanking sir
Timothy for a fascinating</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>