<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Batches: Unified and Efficient Access to RPC, WS, and SQL Services | Coder Coacher - Coaching Coders</title><meta content="Batches: Unified and Efficient Access to RPC, WS, and SQL Services - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Batches: Unified and Efficient Access to RPC, WS, and SQL Services</b></h2><h5 class="post__date">2016-07-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Rxv6jfHbY5M" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
all right good morning everyone I'm
Bruce Delano it's my pleasure to
introduce William cook who's our speaker
this morning will you miss a system to
preface professor at the University of
Texas at Austin and he's done a lot of
work with languages and going into
databases and and other cool stuff he's
a hacker as we know and the he spent
about ten years in in industry and
startups after his his PhD and before
returning to to academia and today he's
going to tell us about what are called
batches all right thanks for stunned I
have been working on this stuff for many
many years and I finally having have a
good story to tell so I'm pleased to be
able to be here and tell you about it I
want to give a quick advertisement for
some other current work I'm working on
four different areas right now a new
system called Enzo for programming with
dsl's and support for hybrid partial
evaluation to be able to compile those
dsl's and interpreters sufficiently and
I'm also working on some structured
concurrency language called orc and
batches so this last two are about
distributed programming in the first two
are about domain specific languages so
I'm going to talk about batches today
and what I want to do is is suggest that
there really three different kinds of
remoteness that we deal with commonly at
least three different kinds there's more
but but if we take these three different
kinds they're very similar in some ways
and and see if there's some way to bring
them together the idea of computation
that databases or services are remote
and if we start with our pcs and look at
where the a lot of this are thinking
about this came from at least
historically is the notion of our PC and
we're taking a procedure and calling it
on some data and we want to allow that
procedure to be remote
and after 20 or 30 years of development
we had korba and decom and RM I and this
notion of distributed objects but
they're really all based on this this
idea of take a procedure and make it be
remote so that when you call the the
procedure the arguments get bundled up a
message is created it's sent over to the
remote server it's executed and then the
results are returned and it seems like a
reasonable idea it's trying to hide the
trip tied the remoteness make the
remoteness completely transparent and
the it's been somewhat problematic I'd
actually go further and say that the
entire thing has been fundamentally a
failure korba become all of these things
didn't work very well and it's one of
the largest sort of you know engineering
failures in the programming language
community you mean we just has not been
adopted widely and there there's a lot
of work that's been done to to figure
out ways to work around the problems
with it what are the problems well it it
has big issues with latency that every
time you make a remote call it's a round
trip to the server and so you the more
remote calls you make the more latency
you get and it tends to to require
stateful servers that is the server's
have to maintain knowledge about the
client state tends to be very platform
specific because we're serializing
objects back and forth and so there have
been some some ideas to solve some of
these issues where you redesign your
interfaces to to make the communication
have a lower latency by combining
different operations together to create
amro facade and doing bulk data transfer
using data transfer objects and the the
problem is that these solutions are
fairly ugly and they're sensitive and
that if the client behavior changes you
have to rewrite your server and so it
creates all kinds of bad dependencies in
your architecture and so the the
benefits of saying well we can use
existing languages and we can have a
nice elegant model where remoteness is
invisible the
it the the the the the problems with
that approach kind of overwhelm any
benefits we get so what I want to do is
start again and try and find something
that unifies these three things and
provide some of the benefits of each of
these different ideas in particular web
services a right cross platform our pcs
easy-to-use sequels got a lot of
efficiency and and transactional
behavior and so what I'm going to do is
is take a clue from an ancient paper and
this was actually the paper that coined
the phrase impedance mismatch or at
least applied it to software and
databases and and what David Meyer said
was that whatever our programming model
is it has to allow complex data
intensive operations to be picked out of
programs for execution and storage
manager so that what's this idea of
picking stuff out and you'll see one way
of looking at as a microsoft lync does
that but i have a different way to do it
so here's I'm going to do is I'm going
to start over and and take a different
example as my starting point our pcs
took as their starting point a single
procedure call with some data and I'm
going to take two procedure calls and
that little change is going to change
everything it just depends on what you
take as your as your starting metaphor
okay so now let's just consider what
happens if we have remote object are and
we want to make two calls to it get the
name and get the size and print out the
answer of both of those so there's
actually a interleaving of the remote
computation and the local computation
what I want to do is I want to do this
fast so it does it in one round trip
instead of two I want to have it be
stateless I want it to be platform
independent so there's no assumptions of
well this case nothing is being
serialized but I could also have had a
serialization involved there and and
keep the nice clean programming model so
anybody can San solve this problem right
give me the answer you've already got
the clue in the title of the talk right
batches sometimes present this in a
tutorial mode where I write this example
on the board and have students or other
you know professor types solve it and
it's really interesting because just
giving this hint even with no context at
all people will immediately get the
right answer
if you just tell them let's do two calls
at once so what we do is we need to
change the language though that's the
part we usually don't get to do in the
past all of these attempts to solve this
problem have always assumed that we have
a programming language that's designed
for a sequential machine and now we want
to make it work remotely but we can't
change the language all we can do is
write stubs and do code generators and
and write libraries but that you can't
solve the problem unless you change the
language and so my change the proposal
is add a new kind of control flow
statement like the for loop the if while
now we have batch and what batch does is
it takes a focus object that comes from
some service so I Tamar is a an
interface to a virtual remote object
we're not going to say that that remote
object exists on the client that doesn't
necessarily even exist on the server but
the client can can refer to its
properties and call methods on it like
get name and get size and the semantics
of this is to run the name and the size
together so the program is going to get
partitioned into the remote part and the
local part it's going to send the remote
part to the server as a script so if you
think about what our PC does it sends a
single procedure call to the server and
the server interprets it it's like a
one-line script that means call this
procedure well why can't we have a
script that calls do procedures it's
it's really easy to do and so this is
actually creates a remote facade on the
fly it allows you to call it a double
procedure in one call okay by composing
two of the actual interfaces and the
server will execute the two calls and
then it'll make a pair of results and
send that back to the client and that
creates a data transfer object on the
fly whatever calls you make it'll make
up enough of a pair or triple or a
two-pole to get the results back and
then and then it reruns the remaining
client code and prints out the first
item of the pair and prints out the
second item of the pair the only data
that gets transferred is the script and
the results as a tuple or a pair in this
case pretty straightforward right
well here's what it looks like if you
generate if you look at what the
compiler generates it's going to
generate us a script constructor that
will construct the script it's got the
two statements in it and what I'm going
to do is generalize this notion of a
pair a little bit to be a named tuple a
record and so this says capture the
output of the first call and call it a
capture the output of the second call
and call it be then execute the script
getting a forest or collection of
results back and then print out the
output of getting a and getting be added
at out of that result and that can be
typed in this case question this will
list it's going to be a forest because
of this example thank you so now we want
to do more operations on the server we
want to talk to a mail server and this
is again a mailer is mail is a virtual
handle to a mail service that has a
bunch of different operations on it and
one of it is to list the current
messages and so we can iterate over the
remote messages so again the mail server
all the messages occur exists on the
server we can iterate over the messages
check if the size is greater than some
limit now limit is a local variable all
right so now we're getting more mixing
of local and remote we need to check if
the size of the remote message is
greater than the limit and if so print
out the subject and delete it so we
don't have to just read operations we
can we can do imperative updates as well
otherwise print out the name and the and
the date now by putting this inside
batch I want it all to run in one round
trip so our scripting language has to
get more sophisticated so instead of
just sending a pair of method calls we
need to actually send the whole loop to
the server the server will run the loop
compare the size and it needs to have
the limit that came from the client and
then it needs to capture the subject it
can't print it out because printing is a
local operation but it can capture the
subject it can delete the message and
otherwise it can capture the subject on
the date so in this sense the subject is
always captured the date is only is
conditionally captured and the delete is
conditional the server can do all that
and it can
turn back a list of subjects and dates
to the client to then run the loop again
on the client and print everything out
but the client also needs to know this
boolean about whether or not the message
was deleted so what is going on here is
that we could recreate the control flow
on the client to be the same as the
control flow that occurred on the server
so here's the here's the the code and by
slashes on this slide it means that this
is generated code no program would ever
write this this is what the compiler
generates so it creates a script in some
way an ast of a script and it captures
the subject always it captures the
boolean of whether the size is greater
than this input named X and it deletes
the message if so otherwise it outputs
the date and so that the output the
result here is going to be a table of
with the column named a which always has
the subject a column name B which has a
boolean and a call name see that has the
date sometimes and otherwise this empty
and here's the here's the overall code I
couldn't fit it on one slide the idea
here is that after creating the script
it can create out input forest and put
the limit in and call it X so we're
sending a structure of inputs executing
the script and getting a structure of
outputs out it runs the script gets this
result and then it can run the loop
iterate over all the messages get the
boolean maybe get the subject and get
the subject and the date if necessary
and print them all out and if this is
the funny thing about this code is that
this code is very familiar this pattern
it's the it's the odbc you know Oh Lady
be JDBC you know link pattern actually
it's the same pattern and I call this
the i deleted the name I think anyway
I'm going to call this the batch script
pattern it's a pattern where you are
doing meta programming on the client
it's sending a script and decoding some
results and my argument is whenever you
write this pattern as a programmer your
programming language sucks okay because
this pattern
is not a pattern you should ever write
this is compiled code you should never
have to say this and and so we need to
generalize it and and what you meant to
say was this and the separation of the
thing into the script and the decoder
and the results and the buffering and
all that stuff should have happened
automatically from having local side
effects in the batch you are allowed to
have local side effects you're allowed
to have remote side effects but you
cannot have tangling of effects so let
me show you what you're just feeding me
the cues perfectly it's that it's not
this slide you jump one to the next
slide after this but this is the answer
to your previous one why is it a forest
it's a forest because if you have nested
loops you get nested tables nested
result sets so this says for each one of
the items print the name and for each
part of that item print the name of that
the output will be a list of items with
their names and then for each item a
list of their parts and their names so
this is the the master detail n plus one
query problem you know that that's quite
common as well iterating over multiple
nested sub collections and we want to do
that in one round trip as well ok and
then this idea of one round trip and the
tangling of effects so the the guarantee
is that batches require one round trip
to the server which means that if you go
and get trying to a batch where you get
the subject of a remote object of a
remote message and then try and ask the
user a question about whether or not it
should be deleted and then delete it is
a syntax error it's a it's a semantic
error in the definition of the batch
it's a programmer error you can't write
a batch that tangles the state you can
modify a local state you can modify
remote state the it's it's a lot like um
Luke splitting in a compiler where
you're doing aggressive out of order of
execution the assumption here is that
all the effects that happen
the server can happen in the right order
and they can be updates but those
effects are independent of any effects
that happen on the client okay that's
the idea of remoteness that there's no
implicit channel of communication of the
server and the client the only
communication is going to be through
this script and the results now you can
obviously set up cases where that's not
true but it's a it's a very common
assumption and if you if if the effects
of the server and the effects of the
client don't interfere with each other
then it's okay to reorder the operations
with respect to each other and that's
what we do we take all the the remote
operations and collect them into a into
a batch and send it over and have them
all be done at once and then the client
once it actually turns out that the
client can do some local operations in
the batch before sending the remote
stuff then it does all the remote things
and then it can do more local updates
after but it needs to be that the in the
effect system that's behind this you
need to be able to to stratify it into
all a bunch of local effects some remote
effects and then local effects and you
can't have any kind of intermediate or
tangled effects I guess is the way to
say it for example try and go to the
remote server twice which is what this
example requires yeah yeah and it's
approximation it just rejects programs
that look bad so it's a it's a
conservative approximation and the point
is that the programmer needs to be able
to read it and see whether it makes
sense so you need a set of rules that
are very simple and so it does a very
simple kind of effect analysis and if it
doesn't look good it rejects it yeah and
the program can rewrite the program to
make it you know just take some of the
effects out and store them in local
variables to to simplify it in case it's
a if it's a valid program which the
effect system rejects there are ways to
kind of rewrite it to make it clearer if
you just eliminated badge the badge
keyword yeah so what would happen well
so the problem is that you'd get lots of
remote local tangling the issue here is
that I believe opposition or is
actually semantically oh oh oh I see no
it's purely a performance yes this is
just about performance the intent is for
it to have no semantic significance at
all yes yes you could say absolute bitch
just around every little that won't work
gold that will not work always no that
will not always work so so in theory it
should have no semantics a magnificent
but it actually does and let me tell you
why because it rejects so the system the
underlying system so I what I was saying
is that it has no semantic significance
assuming that the objects were local
okay if you really did have a remote
system then here's the problem the
current batch model that I'm proposing
does not allow remote proxies so you
cannot have a local pointer to a remote
object other than the root so when you
iterate over message dot messages in a
normal rmi korva style message would be
a local variable that's a pointer to a
remote object that's what causes the
state fulness of the server okay what
actually happens with batches is that
this message object never gets
instantiated on the client it only is
instantiated it's a local pointer on the
server that gets created during the
batch execution once the batch is done
running that message can be freed right
so if you look at the client code here
there are no there are no references to
remote objects at all they've all been
removed they're all in here there's a
reference to a remote object but it's in
the code that's being sent to execute
locally on the server so yeah so so we
reject proxies and serialization
completely so so you have to put enough
work in the batch to be able to access
all the remote objects and complete a
transaction with them and then get the
answers back that you want and the
answers have to be strings and integers
and dates because that's the only thing
that can be transmitted remotely so what
about serialization everybody a lot of
people like sterilization it's kind of
fun and nice you know here's here's our
mail
server again and we want to just send a
list of recipients a set of recipients
to the server to to send our message it
what I said of so far is that you're now
we don't have serialization so you're
not allowed to to do that well it's okay
though because we can call factory
methods on the server we can actually
construct a remote set a set on the
server and populate it with values
alright so the server interface can
provide any interface it wants and so
what we have to do is we have to add
tell the server make a set and then
iterate over the local state and
populate it copy the local names into
the remote set okay then we can send the
message now this the key point here is
that this can be done in one round trip
because what happens is that the system
detect this is local code that needs to
run before the batch execute okay what
it does is it runs this Luke pulls out
all the names from the local set and
puts them into this input record then it
sends the input record to the server
then the server can create the the
server-side set insert all the names
into it and then it's got that the data
that it needs so what it means is you
just have to extract all the data out
from the local one and then write it
into the server so it's serialization by
the public interfaces and one of the
nice things about that is that it's just
as fast as normal serialization really
and it's not a representation dependent
right so you can serialize deserialize a
java hash table and write it into a
python hash table and it's completely
cross-platform cross-language don't have
this problem of trying to copy
representation internal representations
around yeah so that's kind of ugly if
you have to write that over and over
again this little serialization routine
so what we need now is we need to be
able to modularize the parts of a batch
in order to do that we just need to be
able to write functions
instead of executing only locally that
the procedure is also partitioned it's a
it's a modular batch component
essentially and so what this does is I
can write a assets end helper function
that's marked as a batch procedure so
that means that if you use it inside a
batch it gets partitioned it's as if it
were in line essentially and then gets
partitioning applied to it normally
local functions are always executed
exclusively locally these are ones that
participate in the batch so now I just
have to say recipient server recipients
equals send of the local names and this
send function will get split into a part
that collects up the names locally and a
part that creates the set and writes
them into the set remotely so it's
really just the same code it's just been
made to be reusable and if you really
wanted to you could make this be an
implicit coercion that got invoked you
know when a local thing got copied to a
remote thing so we could actually make
it look like serialization but it's
using a custom serializer that uses the
public interfaces not the internal
representation okay exceptions are fun
happen a lot in especially in the remote
world and so we can get exceptions on
the server we can get exceptions on the
client so exceptions on the server
happen when the server is executing the
script and it suddenly something goes
wrong and it gets an error one thing
that I I told you was that the control
flow on the server and the control flow
on the client are essentially
synchronized there they're duplicated so
what can happen is that we can have it
set up so that when the server gets an
exception at a certain point it just
terminates the batch sends the results
that have been collected so far back to
the client the client can rerun the same
excuse me the same computation the same
control flow and when it gets to the
point where the server's do an exception
that exception could get re raised in
the client can handle it locally it
doesn't allow the script on the server
to recover from errors my current
proposal is that server scripts do not
support error correction we could add
that to the scripting language but right
now it's not supported um client
exceptions are a little more tricky
because of this out of order execution
you can have a control flow where the
client normally if you thought of it is
going through five iterations of a loop
if the client gets an error on the fifth
iteration seems like not a problem but
the problem is that the server has
already done all 10 iterations and okay
so the client can fail to process
results that were happened in the future
essentially from its point of view and
so the client has to be a little careful
in terms of how it handles its own
exceptions I don't have any other answer
for this other than you just need to be
aware of the way batches work at this
point yeah thanks before setting off to
the server you have the same
no because what it does is it actually
requires I didn't mention that
explicitly but the requirement is that
all effects in a in a place happen in
the correct order so all local effects
happen in the correct order as if you
ran the code sequentially so in the case
that I was showing you here where it's
sent where it does some local code
before the batch those effects have to
happen before any of the after effects
of the the local code so it doesn't
allow reordering of the the effects on
the local system do not get reordered
with with respect to each other okay so
so the argument is that all effects
occur in the right order at their home
location so I think that was your
question but you see I'm first is
through
if the client got an exception before uh
during the the pre local then the batch
would never even be invoked I see yeah
and the client needs to know that you
know but it can tell where that is by
again there's a in looking at the the
static analysis that essentially
partitions the code just it analyzes it
and assigns three different categories
to it it's either pre local remote or
post local and doing that analysis is
pretty straightforward and it tends to
follow the at least the pre local and
the post local have to be sequentially
ordered in the code yeah okay so batches
are not necessarily transactional but
you could make a transactional server if
it wanted to because it's sending the
complete set of operations to be
performed the batch you could actually
make a transactional RPC server that
somehow serialize the RPC calls on the
server if it wanted to and obviously you
could use it for databases as well but
the server doesn't have to be
transactional I can also just completely
in arbitrarily interleave the the
execution of multiple batches if it
wants to so it doesn't so so batches
don't eliminate errors and they don't
eliminate communication errors or
failures there's a lot of problems that
happen when you have remoteness it at
least it reduces the potential for for
certain kinds of intermediate errors
intermediate States because the the
batch is sent as one script to the
server it's either all going to be
redelivered or none you're not going to
get communication errors in the middle
of a server communication and it does
lead to fewer round trips so there's a
little bit less opportunity for error
but it doesn't solve this problem the
other thing it does is it requires the
programmer to explicitly put the batch
statement in so at least they know that
remoteness is happening so my goal is
not to hide the remoteness it completely
it's to hide it almost completely but it
still make the programmer aware that
it's happening and put a boundary on it
so you're saying what if you don't say
put batch anywhere the batch says this
is the boundary of both efficiency and
it's some degree failure and and so it
makes it declared what's going on there
you said basically that the server fails
of a certain iteration hmm the client
will to get seen is there any website
the server ever fail don't do anything
racism it gives you more of a oh yeah um
yeah that's a really good idea I mean
the server could choose to completely
abort the script and sort of roll back
all the things that it did okay so you
could make a smart server that would
throw an error and then the client would
just get an error immediately all right
all clients would have that same
semantics animated yes but if you wanted
to have the client choose to do that I
think that um I mean the client could
obviously make a call that requested
what kind of failure behavior 'it wanted
dynamically but unless the server has
the capability to sort of cancel all of
its partial operations it's kind of hard
to force the server to do that I think
that I mean it's a really actually a
really good mode of execution and I
think that one of the nice things about
this is that elite it lets the server's
be smarter and gives them opportunities
anything couldn't even help for client
exceptions
the server actually affords the whole
thing is the plane yes so you can even
do a two-phase commit if you wanted yeah
you could actually make a sort of
two-phase commit that the server is
going to do some operations hand back a
ticket that says I've done these but I
need to wait for you to complete your
local code and then get a commit so you
could actually implement that pretty
easily too and that would be again just
on a regular RPC server not on a you
know your fancy database if you wanted
it yeah so okay this is the thing we
keep mentioning that that the order of
execution is preserved the local
operations and the remote operations and
and so this is a case that's actually an
error because what's going on is we have
a remote call update a and update be but
it has two arbitrary local procedures
that need to be called to produce the
inputs okay and then we're going to
print out the results now if you try to
execute this as a batch in one round
trip it requires both of these local
calls to be made first before we send
the batch because their inputs to the
remote call that is going to force this
local get be to happen before the print
which is an error and so this would be
an invalid program and the reason is
that well get P get B could look at the
length of the prytt stream and it could
be different if you did it before after
the print so the idea of those getting
at is that the local local code has to
execute in the natural order that it
would have executed without batches so
this is actually a syntax error and you
can fix this by assigning these get a's
and get any B's to the local variables
if they're you know to make it clear
what the order of the effects should be
okay so summary we have a new statement
and it has a new compilation semantics
this is a kind of control flow where it
does out of order execution it
partitions the code into local and
remote and it manages the communication
it's potentially works in any language
and I haven't really proven this yet i'm
still in the process of implementing
other clients is easy to write a new
server you just write a little script
interpreter and that's like you know PL
101 a week-long project for an
undergraduate to write another batch
server running
bache client is a little more
complicated because he actually have to
change the interpreter or compiler of
the client language and do this
partitioning there are libraries that I
have that'll do the petitioning actual
hard part but it's still some some code
to to make that work I have a working in
Java yeah and and the communication is
optimized as well and it's it's
essentially what we're doing here is
we're we're borrowing the sequel server
you know data you know execution model
right send primitive values back and
forth send scripts over for execution
let's just do it for other things
besides database access okay so here's
the actual batch script language so this
is equivalent to sequel right this is my
imperative remote scripting language and
what it lets you do is Constance
variables conditionals for loops
potentially aggregated for loops so you
can do a sum and it's like a mono I'd
comprehension you can create local
variables on the server you can do
assignments access fields call methods
do primitive operations capture inputs
and or use inputs and capture up with
and then actually have first-class
functions because they're useful
sometimes for doing a certain kinds of
server style predicates and in a fixed
set of operators and a fixed set of data
types so we just say this is the
scripting language and I don't have a
concrete syntax for this yet I have an
abstract syntax I'm thinking of using
javascript as the concrete syntax
because and the nice thing is it doesn't
let you call constructors it doesn't let
you do any of the dangerous things it
just lets you do all the things you
could have done if you were talking to
an RPC server anyway and it doesn't let
you do while loops either so there's no
unbounded computation so there's a nice
nice sort of bound on that although it
does view for loops something right so
like in cell it's like an enumeration
yes in a collection so if the server
wanted to provide an infinite stream
then you could allow it could allow sort
of unbounded computations but the point
is that the the collections are bounded
by what's assumed to be a finite
collection the iterations are bounded by
a finite collection yeah okay so let's
uh let's take this on the road and talk
about I mean you already seen it looks a
lot like sequel right so let's just do
it here's the batch script pattern
executing jdbc looks just like the
generated code of a batch statement and
so instead we just write this and this
is what we'd like to write and and then
we just put batch around it and it
partitions out the remote stuff turns it
into this batch script which turns out
it can be deterministically compiled
into efficient sequel and it turns out
that for any batch you write including
any number of nested for loops it always
generates a constant number of sequel
queries and that's a property that link
does not have for example the only other
system i know that does that is ferry at
this point so that solves that eat your
fish fix the badly no sweets is enough
always no you cannot write arbitrary
code in here pretty much very arbitrary
nested loops and conditionals but it
generates a batch script which is
straightforward but the bachelor the
interesting properties that the batch
scripts can always be compiled into a
finite into a constant number of sequel
queries okay so you get a performance
guarantee Lutz inside the batch scripts
are always looking over things on the
server side yes and so for example if
you had a data structure on the client
side and you want to loop over that you
really wouldn't do that in the script
well I did I did do it with the mail
sending messages so I could loop over
client things to get them to send to the
server I could also loop over a client
data I can you can actually do arbitrary
client computation in here you can do
exception handling and loops and stuff
Rio verte you have to worry about the
ordering yes so I mean it it captures
sort of a very very common
of doing a collection of operations on
the server and getting the results back
and doing something with them there are
use cases that require multiple round
trips and those will require multiple
batches yeah but yeah so it is tricky
actually when you have for nested loops
here it turns out generating for sequel
queries to generate that is non-trivial
I'm not going to explain how it's done
but basically what it amounts to is that
each loop gets its own sequel and the
sequel select statement generate
captures all of the iterations of that
loop for all of its containing loops I
don't know that's probably not clear but
if if you want an explanation we can
talk about it after okay so if you do
normal object relational mapping you can
define the structure of a data model
using a bunch of interfaces or classes
and then I want to do a quick comparison
with link here so in link you it handles
the writing of the query very nicely but
it still is the batch execution pattern
we're still creating an artificial data
structure manually and then decoding it
in the in the in the results so it's
it's actually you have to do that the
part of making that intermediate data
structure the data transfer objects you
have to do that manually still and
that's the part where where batches
Excel is is it and so you end up with
with a sort of cross dependency if you
add another if you want to add another
component here you have to add it in
here and make changes in two different
places another one that's interesting is
dynamic queries so in a dynamic query
the predicate or the condition depends
on local data it's it's sometimes
there's a test and sometimes there isn't
there's a very common on web pages where
you enter in a search criteria and
depending on what criteria items you
type in it makes a different select
statement a different where clause so
here's a case where there's a a title
and if the title is in a test string we
want to see if the titles
equal to a test string and if the test
string is defined we want to do the test
and if the test fitting is empty we
don't want to do the test so in link we
can create a query a virtual collection
we can test the local state create a
modify the query to add a where test
sort of we're now doing sort of a
virtual collection you know manipulation
here and then we can just iterate over
that virtual collection which may or may
not have the test in it and get the
results and iterate over them so the fun
thing is that in batches you just write
the code and test the local state and it
will figure out that this is local and
so it can be done before the batch is
executed and because it's short circuit
execution of or it will not include the
second part in the batch if the first
part is true so it's kind of fun so yeah
so we have a compiler that translates
the batch scripts into sequel and you
can either do that there's at least two
different modes you can do it you could
write a program and have the client
converted into sequel or you could send
the batch script to a server and have
the server convert it into sequel yeah
maybe like me the previous slide yeah
and it's much harder to translates to
sequel query again on the server right I
wanted to translate into sequel queries
actually the way this works is that the
batch system creates the batch script
that either has the test in it or not ok
so the script the batch script that
actually gets created is either or no
it's always is either in there or it's
not and so whichever ill Dan table it's
not entangled yeah from the point of
view of that the query translator it
doesn't even see the difference it's
handled by the batch system so this is
not a problem with link is that if
you're right lambdas the assumption is
that lambdas are sent to the server but
the problem is the lambdas can contain
arbitrary local computation and so they
could fail and so what batches does by
saying that yes we're going to mix local
and remote computation and partition it
we can actually handle that case more
explicitly and deal with one of those
fundamental problems notice that batches
we actually use the same trick as link
does to do aggregation so it still uses
links
aggregation it just doesn't use it for
the standard select and project
aggregation and stuff like sums right
okay so it really does support all
aspects of sequel including updates
insert so you can do a bulk insert you
can do a for loop iterate over one
database table and insert into another
database table and that will generate
the bulk insert query that no object
relational mapping at this point without
lots of fancy hand waving or complex
kind of programming so and this constant
number of queries guarantee so what it
gives you is a fine-grained object
oriented model with efficient sequel
execution and by fine-grain this is the
basic property of batches is that we've
been told whenever you're talking to a
remote server you need to talk to
complex large-scale operations right to
reduce the latency what batches do is
say no it's fine just use fine-grained
operations will collect them up for you
and do them all in a group and then this
is one of the things that web services
is about and you know again there's sort
of been this this long very rapid
experimentation with web services and
there's web services that emulate our
pcs and so they're great they have all
of the pitfalls of XML and all the
pitfalls of RPC so they're like when
people say web services suck that's what
they're talking about it's like the
worst of every possible combination of
things but there's another kind of web
service which is the document oriented
web service which to me was the really
the intuition behind web services that
you send a bulk description of the
purchase order to be processed and it
processes it and sends the results back
and you could send it in an email
message if you wanted to you know and so
this is an example of the amazon web
service interface of a year or two ago
and it allows you to do an item look up
and send it a list of item ids and a
list of properties that you want to look
up and it will give you back a table of
results this is an encoding of a kind of
sequel query here but it's really an
encoding of a batch it's in a custom
scripting language
you know which implicit has implicit
iteration in here and implicit
projections down here and every single
API is a different scripting language
it's just crazy you know and and the
code to write the clients is just
incredible it's explicit metaprogramming
you have to construct the request object
and then yes abstract syntax and then
send it over to server and you have to
write an interpreter every single API
call has a different interpreter so this
is the batch execution pattern again and
again here we are we finally get down to
outputting this the rank and the image
and of course with batches you just say
get me the item get me these two
properties get me the item get me the
two properties and it sorts it out so we
put a front a batch front end on the
Amazon Web Services thing and we were
able to rewrite a lot of the api's we
didn't do it for everything but we did a
really good experiment and we also did
this for this osgi this really huge API
for managing packages and Eclipse and
you know they're struggling with how do
we make this remote there's one purples
and there's another proposal and we're
gonna do it this way we're going to
change the API and we just said no the
API is good slap patches on the front
and you can talk to that thing
efficiently yeah just JavaScript John
this bitch yeah you have to extend
JavaScript with a batch keyword yep and
that's that's what I'm in process of
doing why is it necessary to enter key
word other than I mean case you can
imagine doing the syntax checking in
sort of but yeah I really believe that
it's important to have the programmers
declare their intent and provide a scope
because you can have a lot of different
remote operations and they might need to
be grouped into batches according to
some very subtle semantic dependencies
and when the programmer says this is a
batch they're saying something about the
the scope of that it's like it's like
you know it's like transaction
boundaries in a way the in transition
entry yeah so some kind of declaration
The Bachelor is just a way of doing that
as opposed to it no you can't because it
really has to partition the code I mean
it has to do things to the code that you
can't do with a library you just you
just mean maybe you could do with
expression trees you do if your
processor sure yes maybe you know with
fully reflective access in Smalltalk you
could certainly do it yes as a library
but the surface it seems like kind of a
it's a high bar to get the JavaScript
standard to include this well on the
other hand if you could eliminate the
code that you just shared this with for
Amazon and rewrite is this with with a
little bit less than tected sugar ya
know I really think that this is a
fundamental idea it's not just like oh
this is a hack that means I really think
this does have the merit to be
considered as a real feature and you
just cannot solve the problem it opens
up lots of things the same way that link
opened up lots of new ideas you can
actually have remoteness where the
remoteness was your GPU using batches I
mean it it creates a new kind of of
composition and modularity and and so it
really is a new kind of control flow
okay so everything called Java batch
Java that it's actually a hundred
percent compatible with current Java I
didn't have to make any changes to the
syntax or the or the static semantics
and the trick that I used was rather
than introducing a batch statement it
turns out the batch statement in all the
examples I gave is sort of syntactically
exactly analogous to the for statement
so I just use the for statement and the
trick is that the normal clue is that
the invariant or the requirement of the
for statement is that this thing has to
implement I innumerable or something
like that otherwise it just completely
fails well I say well if it implements I
batch service in it the for loop is a
isn't for our in this service object do
this computation so it's really not a
it's not a it's not even semantically
that much of a of a hack although it is
a little bit of a pun you can you can
eat assign an interpretation of for
where it says for do this stuff remotely
where that the server is it is a remote
connection now if you want to you can
actually put the batch keyword in
I didn't want to break my tooling so
loud I have modified the Jazz tag
compiler and i'm currently modifying
Java C C or Java Sea and I'm going to
propose this as a potential enhancement
for java 8 or 9 and Oracle has said
they're interested so that's about the
status at this point so there's a lot of
interesting opportunities here too well
the first one is to write this for your
favorite language and I would love to
help anybody out who wants to do that
i'm working on JavaScript right now
interesting opportunities for partial
evaluating the batch there's there's a
way it works is there's actually it's
it's it's configurable in the sense that
the client but the mechanism of the
batch system has a the language does the
partitioning okay so that's built in but
what it does with the batch script is up
to a handler the handler gets to decide
how to send it to the remote server or
execute it locally or do security checks
on it or or partially evaluated or
whatever so partially evaluating that
batch handler would allow you to
actually translate the batch script into
sequel in the compiler so what got wrote
would be completely straight jdbc with
hard-coded sequel as the output of the
compiler and then there's also questions
about multiple levels of communication
can we talk to multiple servers in a
batch can we talk to a server that talk
to a server could we have a this is the
one I'm most interested in is that you
talk to a server in a batch but then the
server wants to make some virtual calls
back to the client because they're often
our callback that the server wants to
make to tell the client information so
there really needs to be a return match
that the client then execute and maybe
sends results back to the server so you
can do this really nice nice batch
handshake idea but I haven't worked that
out yet as I mentioned doing it for GPUs
would be fun there's a lot of stuff
about asynchrony a lot of people say oh
latency is a problem we need to fix it
by doing asynchrony asynchrony is the
answer to everything well asynchrony
doesn't work if you have if statements
because you got to get the you know you
have to block until you you know it's
just like the same problem with with
instruction pipelining Right you get the
branch you have to wait until you know
the answer to know where to go so so
batches don't have any problem with if
statements because it just sends them
over however it really is interesting to
think about asynchronous execution of
the batch script with the client because
they are their control flow is
synchronized you can actually stream the
results from the server and have that
clients start executing before the batch
was actually done on the server and
that's what sequel server does too so
lots of related work what's fascinating
is that no one's ever come up with this
before because it's so obvious and so
simple it works so well I mean it just
kills RPC it's so much better I mean you
can argue way maybe it's not better for
sequel you can argue that I mean this
equals pretty complicated but in terms
of RPC it's just better and I don't I've
never seen anything that is is worse
about it you if you want remote proxies
you can do it you can put those in there
there's nothing that prohibits you there
it was the word like junior history /
yeah you do I think partitioning between
Clinton server well I know if you
noticed the list of people on this one
of them is Eli till a bitch who is so
he's working on rewriting J orchestra to
use this the thing that killed Jay
orchestra was the inability to have an
efficient communication model so yes we
could do we could actually are you keep
saying do I need the batch statement
well you could infer it you could you
could put them in yeah yeah then it's
just a question of whether now you have
any branches yeah if you had an app that
ran locally and you want it to partition
it into local and remote and at the
batch statements at the same time then
that would be a cool thing to do and eli
is thinking about that yep and yeah
there's lots of other things that are
related I really like the fact that it's
the inverse of deforestation okay
deforestation is when you take a an
intermediate data structure and you get
rid of it whereas batches create an
intermediate data structure
in order to optimize the communication
so that's one of these if I called it a
forest okay so we have papers on this
we've unified RPC with the ease of
programming that was the first paper
it's got a pretty good description of
the basic concept we showed how it could
be made a cross-platform with web
services we have done some some
theoretical work on sequel early work
that was the precursor to this at pople
and then more recently there's a really
nice paper at the database and
programming languages conference
actually it's a symposium or a workshop
I can't remember but it was a nice nice
meeting and we show how to do the sequel
compilation and translation the actual
algorithm is not in the paper because it
had a really small page limit but if you
want to see the algorithm I can that can
get it to you all right so in conclusion
we have a new kind of control flow
statement call batches and it partitions
programs into local and remote and it
unifies lots of different notions of
remoteness and potentially more it gives
you efficiency a clean programming model
no queries no proxies no requirement to
be stateful they don't have this
distributed garbage collection problem
that you have with korba nrma and it's a
language and transport neutral you can
use XML you can use our asn.1 you can
use JSON for the communication the whole
fetish about you know which
communication protocol we're going to
use is just irrelevant i think the big
negative as you mentioned is the apt to
change language but i'm going to argue
that you can't solve this problem
without changing the language at some
level so that's it thank
okay the you mentioned have some
syntactic rules for for sorting out if
it's legal that you defined repoed Lee
or where we find it all that that there
are cases there are that you would like
it to to figure out are actually legal
it doesn't miss complaints that is where
you would like more detailed analysis of
of the match statement we haven't found
any of those yet I think that the I
understand this this question is
important because it means does this
sort of technical approximation really
correspond naturally to the human desire
intuition about what should work and it
seems like it does you know that that
those those seem to be fairly consistent
I I can't say that i've implemented you
know everything that you know I haven't
haven't used it enough to really push it
to the absolute limit and when you
release a technology like this people
tend to do that they push it to the
limit so it'll be really interesting to
see what happens but my my hunch is it's
not going to be too bad there might need
to be some tweaks but I'm not really
worried about that yeah that I think the
interesting thing is a lake there's no
check for sign things like it just goes
wrong you entangle like link queries
with good side effects
it takes to meet you actually take for
it no but I guess you're so your chick
would be as soon as you have a medical
aid assume that there might be in effect
yes and if it's like maybe a property
excess or something you could declare
yes so their ways to kind of approximate
it but but right now if you do a
property access err it's going to assume
that there's an effect and so that
forces you to introduce a local variable
that captures that value so the
assumption is that values do not have
effects right so that's the that's the
thing you can always capture the value
and then that value can be used freely
it'll be in the pre part yes so one of
the things about our PC is that it gives
us one it's easy to use but it also
gives this illusion of sort of um the
cost being similar you know and what
you're doing you're actually creating a
higher costs for these batches right now
a single round trip you know it's going
to take a certain of habitat trip where
you sent over bad you have to do the
computation then you bring back the
whole thing you kind of take it longer
so you okay introducing longer latencies
I would actually argue that in the in
the case of a single method call it's
going to be the same the batch doesn't
do anything more for a single call than
a normal RPC no but I mean have a single
call if there's one remote call yeah
sure latency is not so the other thing
is that you know bandwidth is much more
available than latency latency is the
speed of light round trip time so if you
can reduce the number of round trips
you're going to reduce the latency you
may use a little more bandwidth but
bandwidth is free so bigger batches with
fewer round trips will always win that's
my argument in the in the way that
though these calls take a lot longer to
the image well okay so there's there's
latency that an injured okay yes rather
than a local call and thank your auntie
Moor Lane sees well I don't I don't
think we're really adding much more
latency I really don't mean maybe you're
talking about you know a few
instructions more or something but it's
it's not a it's not a relative the cost
of the network it's not really
significant the thing that it does do is
that because you have to say batch at
least it's a clue that remoteness is
happening so it doesn't hide it
completely
all right well good thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>