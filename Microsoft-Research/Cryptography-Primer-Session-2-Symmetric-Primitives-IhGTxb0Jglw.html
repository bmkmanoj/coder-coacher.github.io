<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Cryptography Primer Session 2 – Symmetric Primitives | Coder Coacher - Coaching Coders</title><meta content="Cryptography Primer Session 2 – Symmetric Primitives - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Cryptography Primer Session 2 – Symmetric Primitives</b></h2><h5 class="post__date">2016-06-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/IhGTxb0Jglw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year Microsoft Research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
so I should start off just giving a
sense of where we were and see if there
are any lingering questions so some
things we talked about last time the
basics of symmetric encryption that's
what we're going to be talking a lot
about for but you know encryption where
you have the same key for encryption and
decryption we talked about stream
ciphers like rc4 we've talked about
block ciphers in particular feistel
ciphers we showed how des worked and got
a good look at that today we're gonna
start off with a yes AES is really the
block cipher that is used almost
everywhere today it came into being a
little over a decade ago
the data encryption standard which we
talked about last time was I think 1974
is one of the first was published and
standardized and it became a little old
and tired there were much better choices
available and there was an extensive
competition held just before 2000 to
find a new block cipher NIST ran this
this competition they didn't know what
would happen they thought they might put
out a call and people would say yeah
right why should we go to the trouble of
developing a cipher for you one of the
conditions was the cipher that was
selected as the winner had to be placed
in the public domain and there was a lot
of concern well why would anybody go to
a lot of trouble built the cipher and
then not get anything out of it but it
turned out that when they went through
the process there were 15 submissions
some of them a little questionable but
you know most very interesting and and
some very good ones and the process
wound up with five finalists I'll talk
about them a little bit and will will
focus in on
winner eventually which is the middle
one here right now but the the first two
were in some sense the heavyweights
right this is IBM IBM had done the data
encryption standard guess that was sort
of the big start they seem to have a big
advantage Mars was about the most
heavyweight remote most heavy cipher of
all these what happened where it was
several teams within IBM wanted to be
the successor to DES and these several
teams wound up getting combined and they
took various elements of each of their
original ciphers and cobbled them
together and it really did look like a
camel and it it was discovered very late
in the process that Mars did not meet
its own design requirements and that
kind of killed it it was already you
know a problem but it it had a huge
substitution box one box you know if you
get an input that looks like this here
is the output and most block ciphers
have some sort of a substitution box
process where many of them this was an
enormous one that was generated and in
according to various criteria and it
turned out somebody looked carefully at
their big substitution box and no it
didn't meet the criteria that they
claimed the substitution box should have
so that kind of killed it
rc6 came from RSA ron rivest was heavily
involved in its design it was a very
interesting cipher and it came at
exactly the wrong time or more
appropriately it met conditions it was
ideal for conditions that existed right
around 1997-98 that didn't exist before
and haven't existed since the the thing
that I tried to take advantage of is if
you have a if you want to make a good
block cipher you have to have
something that's gonna scramble things
up really well somehow somewhere there's
got to be a lot of scrambling as you
wanted to be efficient you wanted to
scrub all up and they looked at what was
available on most architectures and they
found that the best scrambling function
was a multiplier and they said okay
we're gonna take advantage of some some
newer processors are starting to have
64-bit multiplies this is a good thing
and we can do it and they work there's a
lot of hardware thrown at it to make it
fast okay let's take advantage of that
let's do some some really big multiplies
and get some really fast scrambling it
was an interesting design it worked well
didn't work very well on you know on
small processors and aphids and things
like that
but you know was a gamble and that was
kind of the last time we saw 64-bit
multipliers you know commonplace and
processors was decided not long
afterwards that just wasn't worth the
hardware investment and all the
transistors and even for a while 32-bit
multiplies were were scarce but they're
they're pretty common now but 64 bits
not so much so without that our c6
really didn't perform very well I'm
gonna skip down to serpent which was a
very innovative design and in many ways
the strongest cipher out there this was
designed by some you know very strong
people in the field with with very good
reputations and was designed with a very
good security margin they didn't want to
be close to the edge and that's what
wound up killing it because with the
security margin that they built in it
wound up being slower than other
competitors not that much slower but
slower and this was a bit of a problem
when all of them looks secure nobody had
you know came anywhere close to breaking
any of them so this you know just well
there also
and this one's slower well yeah but you
could cut down the number of rounds in
half in serpent and it was still secure
that wasn't the case for any of the
others and there were some pleas of with
the authors to say can we have a mode
where it has fewer rounds so that it'll
be competitive and they were very
insistent and no we want a good security
margin and for that reason it didn't
survive and the final one I'll mention
is to fish Bruce Schneier Niels Ferguson
who's in Windows or amongst the
designers of this very clever very nice
that did a lot of tricks and by most
accounts because these two kind of
imploded and because serpent was
regarded as too slow to fish had no
obvious weaknesses and it was probably
considered by most the runner-up in this
but there's no official basis for that
but you know very nice cipher and people
still use it today it even though it
wasn't since it wasn't the winner it
wasn't required to be in the public
domain it has been placed in the public
domain and therefore it gets a lot of
use oh yes there are different ciphers
but both yes Blowfish is an earlier
cipher that was done I well Bruce Shia
was part of it I don't know if they're I
don't remember if there were others they
were part of it but but to fish you know
use some of those principles but but it
was a much larger design team and a lot
of new things in that the biggest thing
in common is the fish in the name sorry
but ok let's talk about Rondo Rondo was
the winner rundown as the winner is now
a EES and is a very interesting very
strong cipher
most of these also most ciphers out
there follow the feistel design that I
talked about last time as a very easy
way to construct a cipher that is
invertible right invertibility is the
hardest thing to achieve
rondell does not use
so let's take a look at what right now
does Rhonda takes either 16 24 or 32
bytes of key it's also designed to take
16 24 32 bytes of input data however AES
only required 16 bytes so the AES
specification says Rhonda with 16 bytes
of data so you can sort of ignore this
when we're talking about a yes it will
then arrange the data in this sort of
block form so each of these blocks is
now a byte and think of this square form
that's sometimes called a square cipher
it goes through a few steps Oh first of
all goes through a bunch of rounds this
round what well ten rounds is very close
to the minimum security margin right we
have seen there are theoretical breaks
of rondell and the theoretical break
means tiny tiny weaknesses have been
found up to seven rounds so ten rounds
is not that much more than that that
doesn't mean it's a useless cipher at
seven rounds it just means theoretically
it doesn't have 128 bits of security
that you would like it to have if you're
using 128-bit K so you're a es at ten
rounds okay it seems good go up if you
increase the key length the main benefit
you're getting is more rounds if if
there are more key bits you think you
get more security from the more key bits
and you do but that's not you know in
this case really it's the extra rounds
the the 128 bits is enough it's the
number of rounds that's that's really
the the edge and a lot of people suggest
it at the time that this was a fine
cipher but it should be more like 16
rounds here 24 rounds here 32 rounds
here and give it the same security
margin a serpent and if the Donna would
be very comparable with serpent we'd
have very good security margins and
maybe two fish would have one
because it was faster okay so this is
the way it's pecked out and this is the
way it works each round has four steps
and the four steps are all pretty quick
and simple and I'll tell you what they
are the first step is a byte
substitution step so what you do is you
have an sbox a table of 256 possible
byte substitutions it's a permutation if
you see this byte change it to that byte
and just an array of 256 values that's
that's the substitution box this box of
Rondo and all you do is you go through
this square and you go through and you
just change each byte according to that
table okay 16 changes the next step is
what's called shift row and what you do
is you start rotating these rows now
okay I worked way too hard on this slide
I had this vision of a slide that you
know they'd shift and they'd move around
and I'm not that good a slide we're
engineer it's not worth it but you could
sort of see how this happens basically
this row per permutes rotates one
position and two bytes and three bytes
down there okay and so that's all it is
very simple step two step three
oh so that's that's how it winds up okay
if you couldn't see it before step three
is a linear transformation on each
column so think of it as sort of like
you're taking the columns individually
and you're putting them through a matrix
multiplication but I use this kind of
funny symbol because it's not ordinary
multiple matrix multiplication this is
matrix multiplication in a Galois field
and I'll talk a little bit more about
Galois fields later although I promise I
won't explain what they are unless you
really really want me to and I don't
think you do but it's it's sort of a
funny kind of multiplication but it
looks kind of like matrix multiplication
and if you multiply for instance a
matrix times a vector you get a vector
so
effectively just goes through each
column multiplies that out and then the
thing that does is this multiple matrix
multiplication remember the wave matrix
multiplication works this times this
Plus this times this Plus this times
this Plus this times this and that winds
up going up top so you get effects of
all of these bytes mixing into there and
all of these bytes also mix into here
and here and here you go through and get
all that mixing and then you go through
and you do the same thing there you do
the same thing there you do the same
thing there and that's the only thing
that after the the bikes up has really
scrambled any of these bytes at all
other than sort of moving around there's
their principles in cipher design which
are sometimes described as confusion and
diffusion diffusion is moving things
around and that's sort of the rotate
stuff the confusion is the little bit
twiddling stuff that's been being done
and here we're getting some confusion
okay the final of the four steps is well
notice that furs are supposed to have
keys right we haven't actually used the
key at all yet and the final
transformation the final step is just
take what you have now and literally XOR
in a key nothing more than that 16 bytes
of key 16 bytes of data do a big XOR
well done that's that's the extent to
which the key is used the only thing
that's a little a little complex here is
that for each round you use a different
key and there is a key schedule it's
complicated I don't want to spend time
describing it there's also a lot of
Galois field mathematics in the key
derivation schedule but it's a lot
easier than the other stuff because
unlike the other stuff here every all
these steps had to be reversible a key
derivation doesn't have to be you have
the same key to decrypt you go through
from the initial key and you derive the
same sub keys the same way each time so
it can be a very complicated and it is
in this case very complex looking kind
of
operation but it's not that hard to get
something that's invertible like all of
these four steps were invertible so
makes sense that the key derivation
doesn't have to be invertible but
anything that's done with with the key
or with anything else to the data it
does have to be invertible and that
that's where you have to focus the
attention okay so in practice Rondo is
used more and more for a lot of reasons
it's it's fast that's small it works
well on big processors it works well on
small processors works well in hardware
was well and software boy was a good
overall choice people people are very
happy with it does have a lot of
mathematical structure and that
structure has been thought and might
become a weakness at some point but so
far people have found things that might
suggest weaknesses but nothing really
substantial but one thing that's getting
a lot more play and a lot more use is
the AES ni instruction set which is has
made it into newer processors basically
there's a whole round all four of those
steps as one machine instruction so when
you have that it's not one cycle but
it's still pretty fast when you have
that you can go through an entire AES
encryption or decryption very very
quickly if you have modern hardware so
it's becoming very popular for that
reason as well okay so a ESS I'd you
know everything about AES now I'm gonna
talk a little bit about how you use a
cipher like AES and when I say like a
EES and practice I mean a yes because
that's what we're using Bach ciphers so
when you have this nice tool available
what do you do with it well the first
thing you might think of is you take
your input data you've got a book you
want to encrypt you've got you know some
a big important data set and AES takes
data 128 bits at a time and encrypts
those 128 bits and gives you 100 28 bit
output
so what do you do well the first thing
you might want to do is okay take the
first hundred twenty eight bits apply
the cipher take the next hundred
twenty-eight apply the cipher keep on
doing that just go through everything
and that can work all right but it
leaves you vulnerable to some some
attacks one thing you might notice is
that if you have the same input you're
gonna get the same output so if you have
you know some maybe structure data some
somebody watching can see oh this
outputs the same as this output and I
have a guess as to what this might be so
now I'm pretty sure I know what this is
and you can start doing a little bit of
analysis there it's not a huge amount
it's also subject to reordering it might
be that this is your data with you
remember that the payment example we had
last time where somebody with a stream
cipher could flip one bit well you could
take a full block and substitute another
block maybe from here reorder things and
ways that might change the amount maybe
there are two blocks
that's the payment data and you switch
them around and suddenly now this was
all zeros and this was you know a small
payment and now the high order bits of
the payment move up here and you've got
a problem or they the person making the
order has a problem you haven't switched
it around probably have a lot more money
than you were supposed to okay so
reasons not to use this even though it's
very simple to do
you just run the inverse cipher to to
invert it it's not a problem but we
really want something better than that
so what we generally do is we see that
identical blocks give you identical
encryptions that's what I just said
about reorderings and give information
this passive observer information so
instead we prefer other modes and by far
the most common mode
and the one that if you're doing things
now that we want we the crypto board
want people to use unless there are
exigent circumstances of some sort is
called cipher block chaining and cipher
block chaining is just using any block
cipher and adding one additional XOR to
the work for each block that you put it
and it's a pretty simple thing all you
do is you start off with some IV and the
IV should be different if the key is
staying the same because if you have the
same key and the same initial value and
the same first block then you'll get the
same first block of output and an
observer could see that so if the key is
staying the same the initial value
should change every time and I could
change this by being randomly picked
this can be completely public so it used
to be called salt for any old-timers out
there so you have an initial value you
have a first block of data you
exclusive-or them you put that through
the block cipher instead of just the raw
value and you take that output and you
XOR that with the next block of input
before it goes through the cipher and
what this means is that even if this
block and this block of input are the
same this is gonna get ex-ored with
stuff here and it's going to get XOR it
and now put a next door it now put an
XOR it again there's gonna be something
completely different that goes in here
and something completely different that
comes out there so you've got things
scrambled up very nicely you've also got
things tied together
you can't just swap two blocks and have
the effect that the though those two
blocks of input are going to be swapped
or even swap in something from somewhere
else because everything is chained
together now decryption is pretty simple
here too you just run the cipher
backwards and you just take the X ORS
from here X or again the same trick of
XOR and twice that we've used before
okay gets you back to where you started
so if this XOR with that
went in here then when you come back up
here and you invert the cipher all you
have to do is XOR with that which you
still got around and you get that back
so inverting cipher block chaining works
pretty well so it all goes very nicely
now some people say that CBC mode cipher
block chaining isn't good for one of a
couple of reasons that are actually
myths so I want to show you a couple of
myths a couple of nice little tricks
here
first myth is I don't want to use CBC
because I need random access to the data
it's all chained together I've got this
you know 12 gig block of data that I
encrypted with one key well that's an
awful lot to do as one block but okay
there's 12 gigs of data there and now I
need to get random access to it I don't
want to use CBC because then I'm gonna
have to go back to the beginning and
decrypt not trip let's take a look a
little bit more carefully how this works
what do I need if I want to decrypt just
these two blocks down here so here's you
know somewhere in the day there are two
blocks
I want to decrypt that well I can get
rid of all this the only thing I need to
do that decryption is the previous block
of ciphertext I need that to come up
here but I don't need to decrypt the
whole thing from the beginning so you
really can yes you encrypt sequentially
you can't encrypt in pieces but you can
decrypt just a small piece of the data
and it'll it all works just fine okay oh
I had an animation I forgotten about
isn't that cute that becomes the IV for
this and everything work and and you
could just run this as though this is
ordinary CBC decryption now wouldn't it
with this as the IV just used the same
routine that you had before okay so that
myth has been dispelled so let's look at
another one CBC is terrible because of
data expansion right well it's not just
CBC this is a problem for any block
cipher because you have to Pat it out
suppose I've got an application where
I've got
37 bytes of data in this field and now
I'm told I've got to encrypt it and well
you have to do whole blocks right and
and maybe that field is hard-coded in
and I don't want that so I'm going to go
back to a stream cipher because I can
encrypt bit by bit with the stream
cipher well this you can also get rid of
that David expansion in almost all cases
with a block cipher using CBC with a
little trick it's a very cute little
trick that it's is surprising that it
works so there's something called
ciphertext stealing and it comes from
the observation that if you've got data
that you've encrypted in CBC mode and
you had to pad out the end because
there's some useless stuff out here this
your real date only went this far so you
just put in some zeros at the end or
anything but let's just say that you've
padded with zeros then it turns out that
you can take the same number of bytes
here that were padded and just discard
them from the second-to-last block the
penultimate block of ciphertext and you
can still recover so just throw it away
now you've got ciphertext here that's
exactly the same size of the plaintext
throw it away and let's see why this
works suppose I have to invert and I'm
missing that well I can still invert
this and I get some value here from just
running the inverse cipher on the last
block up through here I get that this
gives me a value I know that this value
here was supposed to be all zeros so now
I can figure out exactly what this must
have been to XOR with that to make all
zeros namely exactly what's up there so
now I know what's missing and I can go
and just decrypt everything as normal so
I do that I turn that whoops there I put
that in there that turns that
Zero's and i can decrypt okay so this is
a trick i said it works almost
everywhere it works as long as you are
using CBC mode with more than one block
of text it doesn't work on a single
block because you can't delete the thing
before this there's nothing to delete
there so yes you do have to have at
least one block but but you can still
make it pretty tight
okay so CBC mode works pretty well we
like it a lot we use it a lot I'll talk
about some other modes later on but that
myth has been dispelled okay one other
mode I want to talk about quickly that
comes up a lot and they'll come up later
so I want to mention it and that is
counter mode it's kind of an odd thing
you would think you don't want to ever
do this at all but I'll describe now why
some people like to do it and it'll come
up again I promise
so the idea is we just take whatever key
we're using and we just encrypt zero
then we encrypt one then we encrypt two
then we encrypt three and you can see
what comes next and that will form some
output and that output we will use as a
key stream and just extra with the
plaintext and get ciphertext so what
we're doing here is taking our nice big
robust block cipher and we said we want
to use block ciphers and that stream
ciphers because stream ciphers have all
sorts of vulnerabilities or not so much
vulnerabilities but fragilities that can
be used carelessly that can be misused
very easily and we have turned this nice
block cipher into a stream cipher well
why did we do that we were willing to
accept the difficulty and and slowness
relative to a stream cipher of a block
cipher to get rid of that fragility and
now we are going through all the work of
a block cipher and we're getting a
stream cipher here right now if I flip
one bit of ciphertext then
I know that that will flip exactly that
same bit of plaintext and you can start
playing tricks with it you have issues
with using the same key gives you
vulnerable ities problems well it turns
out that although stream ciphers are
fragile they can be used well if they're
used properly they can and they they do
have some benefits and I'm showing you
this now because I'll bring it in
towards the end of today as sort of the
modern way the modern block cipher mode
but before I get there I have to talk
more about that for integrity and if you
have some data and you want an integrity
checked then the traditional method is
well you had some sort of a checksum
right that's what you see on the the
last digit of a credit card or you know
lots of places you just you know add one
block of something one byte one digit
whatever as a checksum to guard against
some transmission error or some careless
error of some sort now a checksum is a
really good way to prevent accidental
disruption of data you know something
getting corrupted in the network it's a
terrible thing to use in a security
context because people understand how a
checksum is supposed to work and if
they're gonna change sudden block of
data here they can just make a
corresponding change to the checksum and
make the checksum the right checksum for
whatever they want to change the value
to so for cryptographic integrity we
need something better we need something
that can work against a an adversary who
actually knows what's going on so what
we use here is something that's used
everywhere a hash function and the hash
function turns out to be kind of the
hammer and the cryptographers toolkit
it's used for lots of things and all it
really is is just a function that takes
arbitrary length data and gives you a
fixed length output that's sort of a
fingerprint of this data it'll always be
this
for that data it's sort of that
something that stands in for that data
and it is supposed to be difficult to
invert and I'll explain what that is
what that means in a second but there
are actually several properties that we
have of these one-way hashes and it used
to be that we blurred them all together
but we've discovered they're all very
distinct they have very different
properties and and very different
assumptions behind them
so this non-invertibility turns out to
be the the assumption that that we start
out with that if you have the output of
a hash function you shouldn't be able to
find the input it also turns out that
that is the weakest assumption because
we use it in other ways with stronger
assumptions behind it another way that
another thing that we like to get from
hash functions is what's called
resistance to second preimage attacks
and a second preimage means if I give
you an X can you find an X Prime that
has the same hash value now how do these
two relate to each other well if you
have this then you certainly got that
because if you could invert then you
could just find something that that
should be clear at this point is there
are lots of collisions in a hash
function right you're taking a big data
set and turning it into a small tape so
even if we're hashing 257 bits down to
256 bits most outputs have a partner
that most most inputs have a partner
that have the same output if you have an
arbitrary length input there are
probably infinitely many things that
will hit each output so there's going to
be lots of collisions and the question
is can you find one well in this case if
you can invert you can certainly find
collisions because all you do is well
maybe when I inverted when I took H of X
and tried to
invert that I got X back but most of the
time for most inputs X that you'll get
something else back because there are
probably an infinite number of things
that have Y and if I can invert Y I get
just one of those things it match
anything in that infinity so this is a
stronger assumption but there's an even
a stronger one it's kind of the gold
standard for hash functions and that is
collision intractability that is that
you can't find any collisions at all
this is something that has no practical
value it has tremendous PR value and has
some value in our sort of understanding
of hash functions and it's sort of an
interesting property that for any good
hash function that's out there and even
some bad hash functions that are out
there for the sha-1 hash function which
I'll talk about a lot more so nobody has
ever found a single pair of inputs that
have the same output even though there
are infinite numbers of such there are
lots of them no one has ever found a
single pair like that people have come
close people think they know how to do
it people think that with a certain
amount of resources it would be hard
people think that if we took all that
hardware that's out there now trying to
mine bitcoins and use that hardware for
a couple hours they'd very quickly find
the collision but nobody has ever found
a collision there so it it's still
strong in that regard now md5 the
predecessor I should go back and just
sort of hit the list here's sort of a
list of hash functions that are out
there
md5 was broken about ten years ago MD
for an md5 actually broken together
broken in the sense that collisions were
found now still even though it was
broken ten years ago nobody has a clue
of how to invert it but there are
collisions and therefore we don't want
to use it anymore
if we do use it then we'll have
reporters writing articles about how
stupid Microsoft is using a broken hash
function even if we use it in a
completely secure way so we have to
avoid it and and the expectation has
been for a few years that any day now
any week now any month now sometimes
soon sha-1 is gonna go in that sense
sha-256 is a newer much stronger hash
function I'll talk about that a little
bit and sha-3 is an even newer but not
necessarily particularly stronger pass
function okay so here are the
requirements here's the gold standard we
want our hash functions to have no
collisions that have ever been found
anywhere okay and we have that still for
all the shah's but not for the MD set of
functions okay so these hash functions
turned out to be tremendously useful
they're used when we're doing encryption
especially especially symmetric
encryption as an integrity check
basically a checksum but a cryptographic
checksum that you can't muck with you
can't break because we usually put a key
in there and I'll describe how we do
that they're also used in digital
signatures if you remember the digital
signatures we talked about a little bit
last time signing a huge block of data
can be very cumbersome so what we
generally do with digital signatures is
take that big chunk of data hash it down
to something small and sign just that
sign basically the fingerprint and have
that be the proxy for that whole big
block of data and as long as nobody can
find anything else that has the same
hash function we really are signing that
signatures break horribly if we start
getting collisions including second
preimage is enough there you don't have
to be able to invert to make a mockery
of this characteristic and a third
characteristic that we take advantage of
is entropy distillation what we have
for all sorts of needs and cryptography
and other places but especially in
cryptography we need randomness we need
really good randomness and we don't
really know how to get really good into
this most of the time what we do is we
get things that look kind of random and
we don't know how much entropy there
really is how much true randomness there
really is in this stuff
so we take it and we kind of hope and to
boost our confidence what we do is we
don't just take a random source and say
okay this is a source that we hope is
good and random then we'll take 128 bits
of that and we'll make that a key what
we do is take lots of sources put them
together put them through a hash
function and get 128 bits or 160 bits or
whatever it is get that out and that is
basically distilled the entropy because
now if we have a thousand bits that were
really biased in bad ways and only had
about 200 bits of entropy total than
those thousand bits of input and we
hashed that down to 160 bits well now
we've got 160 bits of entropy in there
and then that's really good and we can
start using that so this is used a lot
it doesn't particularly matter if the
hash function is broken it's still a
good entropy distillation we use md5
constantly in this company for this
purpose and we should be getting rid of
it not because it's bad to use for this
purpose but because if it's used for
that then it somehow creeps in and
starts getting used for other things and
some blogger sees we're using md5 and oh
we're stupid again because it's broken
and yeah it's just yes it's not a risk
here from a security perspective it is a
risk from a peer or another perspective
which is sometimes as important okay so
these hash functions have lots of uses
let's talk about how they're built so
the most common way just just like we
had this feistel cipher design for for
block ciphers the most common way
of building a hash function is called
the merkle-damgard construction and the
construction basically started is is to
build a compression function and a
compression function is just like what
you would expect on a hash function it
takes a lot of data and produces a
little bit of data but it doesn't take
an arbitrary amount of data it takes the
takes a fixed large amount of data and
produces a fixed smaller amount of data
and then it's going to get iterated
somehow and it's gonna get iterated in a
way that looks a lot like what we did
about 20 minutes ago for a cipher block
chaining it's going to get iterated in
this way where we take the input data
submission value put these things
through a compression function and get
an output that's the same size as this
initial value and go through and we just
keep on repeating and eventually we get
through to the output okay
same basic construction this kind of
construction comes up over and over and
over again okay so I want to take a look
at sha-1 sha-1 takes a 512 bit input
here it's going to produce a 160-bit
output and it also takes the second
input the IV so the total input is 672
bits but this is sort of the the
intermediate block size that goes
through and I'm gonna spend just a
couple minutes showing you how Shaw one
works even though we don't want you to
use it anymore we prefer sha-2 they look
kind of the same and show what's easier
to talk about so sha-1 160 bit internal
state here
they say that backwards before this lead
ya the internal state is 160 bits that
goes through here yeah so that that's
what you keep at any time that's what's
going to come through next time so we
take 160 bits of state and you have to
take 512 bits of input and it's kind of
a sort of if you cook it's kind of like
sprinkling things
into a broth what you do is you take
this hundred and sixty bits of state and
you just sprinkle 512 bits of input few
bits of the time in and you stir and
you're stirred stir and sprinkle a few
more bits and you stir and stir and stir
and that kind of the way it works for 80
rounds of stirring so you take this
state 160 bits 5 32-bit words and mostly
what's done is shifting really each
round is mostly a shift so let's talk
about what happens in each of these to
each of these five words this word
doesn't change at all it just shifts
over this 32-bit word well it gets
rotated thirty bits were backwards to
bits and nothing else
that doesn't change that doesn't change
the only change of any substance and the
only place where any of these bits get
mixed in is down here and even that
doesn't do a lot so quickly what goes on
there is that final 32 bit transform
takes the rightmost of the 5d words of
input adds the leftmost word rotated
five bits so you've got the rightmost
word take the leftmost word rotated in
adds that in there's a round dependent
function on the middle three depend on
the middle three words I'll show you how
that goes so you take these middle three
words and you take a round dependent
function on that and stuff that in here
as well and here's what they're round
dependent function looks like depending
on the round it's one of these three
things and finally adds of a round
dependent constant sprinkles in some of
the bits that were up over here of the
input just a little portion of that 512
bit message just you know take a bike
from here and a byte from here and a
byte from there put those in put those
all together
and stir that's a round of shot one it
goes on for 80 rounds and you get an
output that reduces one block that
reduces that that consumes 512 bits of
input you do for the next 512 bet you do
another 80 rounds keep on going okay we
don't want you using sha-1 anymore we
want people using the newer hash
functions shaft 256 sha-512
well these look a lot like sha-1 sha-256
basically has almost exactly the same
structure it just has 8 32-bit registers
instead of 5 that's why it's up to 256
bits instead of the 160 bits before and
still all but it's it on each round it
shifts everything to the right right one
all but two of the values stay exactly
the same
other than being shifted one of the
values that goes through some very minor
changes just like that little tiny
rotate that was done in sha-1 and it's
only one of those words that goes
through some round dependent functions
and some scrambling very similar process
shot 256 is similar to sha-1 sha-512 is
very similar to sha 256 really it uses
it almost exactly the same structure the
only principal difference is that the
sub blocks the words instead of being
32-bit D words or 64-bit words here and
that way you get double the internal
state but everything is structured in
exactly the same way so now you know how
ha ha 1 sha to both both major variants
of stock to work there's something
called sha 384 which is just do this and
then truncate there's something called
sha 224 to be compatible with some
smaller things which is do this in
truncate nothing more to it okay
shot three is also something that's come
around recently there was a a
competition that just finished not long
ago about a year ago for a new hash
function the AES competition was
regarded as so successful that well
let's do it again
let's get a new hash function and the
reason was was different this time the
first time it was done because we
desperately needed a block cipher people
were still using DES because it was the
only standardized one but it was way too
weak it was easily breakable and people
who wanted security were using Triple
DES which is run des three times with
three different keys which is not that
bad but it's dog slow here a competition
was run for a new hash function but not
because there's anything known to be
wrong with it with the sha-2 family but
more a matter of in sort of an abundance
of caution here we use hash functions so
much everywhere and there's been such a
painful process such a slow process to
move from md5 and sha-1 to the sha-2
family it was decided we'd better have a
backup have an alternative ready to go
just in case so sha 3 is not appreciably
stronger doesn't it's not obviously
stronger in any way than JA to family
it's not appreciably faster but it is
different and that's the benefit and the
idea is that we get it built and get it
deployed and get it available and maybe
have it used in parallel for
mission-critical applications maybe use
both shot two and shot three
simultaneously and you make sure that
they both match what you're expecting so
sha 3 looks very different it uses
what's called a sponge construction
which does a large transformation on a
large data cache in the case of sha 3 in
particular that's a 200 byte data cache
it's pretty big
at least from four for cryptographic
primitives is pretty leg and then you
take smaller blocks of data and you just
extraordin to the sponge function and
you churn the sponge so does this remind
you of anything well it's kind of this
again the only real difference is these
blocks are now big blocks so here what
we're doing is kind of this the sponge
function is this big churning and you
churn and you mix in a few bytes with X
or ignite on the top so you just XOR
right along the the beginning of the
data cache and there's some output that
becomes the new input you XOR that in
you apply the sponge function you apply
the churn the big churn of the 1600 bits
of data in the middle now and you just
churn and put in a few put in a new
block churn and put in a new block and
eventually get the output and usually
you don't want all of this output 1600
bits of output in the hash function
there's a lot so you just take the first
256 bits or 512 bits or whatever you
want of that that's all it is and that's
really you know about all I want to say
about you know sponge construction here
just give you a sense for how it works
yeah
start with you European you see me more
of a yes hmm
so how about the following function just
encrypt your input you simply see me
more and using what you don't want to
use EBC mode you want to use CBC mode
but yes in fact I will mention that very
shortly your your a couple slides ahead
of me but that is a common way of doing
it it turns out to be slower because
ciphers have to be invertible and to
make them invertible they tend to be
slower but but it is used and it's used
quite a lot in fact so we're getting to
the end we want to talk about message
authentication codes this was the first
principle use of hash functions we do
this quite a lot with a keyed hash we
use a hash function and just put in a
key and our data and that way you should
know that you're getting what you expect
basically you take a secret key and the
correct message and you hash them
together and now if an attacker tries to
change the message the attacker not
knowing the key will not know what the
correct new message authentication code
should be and therefore it'll be obvious
whether to anybody who is trying to read
the data but there's a question of how
we're going to do this and the but how
comes in this form suppose we have the
data the message and the key should we
remember a hash function just takes a
big block of data it doesn't care what's
what should we take the key and then
append the message should we take the
message and then append the key well it
turns out both of these have problems
this has some big problems because of
the way we construct hash functions but
you can probably just append more data
to the end of this and figure out what
the hash should be so it has what's
called a length extension attack and it
turns out there are some attacks on this
method as well so we don't want that
used either what we do is what's called
a CH Mac this is sort of the standard
and the H Mac is a pretty simple thing
it's
just an extra layer of hashing it says
hash the key together with the message
and then hash then prepend the key to
that and hash that again well that looks
like well it's a lot of wasted effort
right I'm doing two hashes when I only
need one well yes it's two hashes but
this first hash might be a big hash if
the message is big but now what you've
got here is small so the second hash is
really just one extra iteration of the
compression function it's it's a small
hash it's not a big deal and it turns
out this has some nice provable
characteristics that it meets everything
you want so this is how you do a keyed
hash but still there's some issues on
how you actually use that key - suppose
we have your original message and you
have an encryption key and a key that
you're going to use for your integrity
check and you should always unless you
know for a fact that it's okay to use
the same key in both cryptographic
basically sanity checking and hygiene
requires use separate keys for separate
purposes so you have an encryption key
and you have a Mac key so how do you
integrity protect your message there are
a few methods out there one is usually
known as encrypt and Mac you encrypt the
message and you put a message or that
authentication code on that same message
and you send the two together there's
also what's called encrypt-then-mac
which is encrypt take the encrypted
message take the ciphertext and put an
integrity check on the ciphertext and
the third is Mac then encrypt which is
basically you put a Mac inside the
message inside the thing that you're
going to encrypt so you take the message
you put a Mac on the message and then
you encrypt the whole thing well turns
out there are very
use-cases various advantages
disadvantages but almost always this
turns out to be best I don't want to
spend a lot of time going into why not
always but almost always and this is
sort of the standard rule this is
sometimes you hear the do you
encrypt-then-mac do you back then
encrypt well usually you want to do this
but usually isn't always good enough so
what we really prefer is having
authenticated encryption and this is
sort of the new fad in symmetric
cryptography there's a lot of this going
around now if there's a disease this is
easy people are catching because this is
what people want to do right they want
their in their data to be secured both
from a confidentiality standpoint and an
integrity standpoint that's the standard
use if you're not thinking about it if
you don't know what you're doing you
want that done and you don't want okay
well I do this and then I do this and I
put these together I get these two keys
and let's we want a single primitive
that will do this as efficiently as
possible so let's go again
take a look at our block cipher modes
and see what we can get out of this well
the first thing I'll mention is cbc-mac
which is exactly what you were
suggesting we have this is a common way
of doing a Mac even though it's not the
most efficient it's still pretty good
which says you you basically take a key
you encrypt your your data and you just
take the last block and the blast block
of the Mac and as long as you're using a
different key than what you use for
encryption well then this is fine you
don't need all of this stuff because you
don't need to decrypt you're just going
to do an integrity check at the end okay
so here is one of our authenticated
encryption modes there are a whole bunch
of them out there now but CCM is a
popular one Niels Ferguson was also
involved in the development of this and
but CCM does is basically do CBC map
remember I talked about counter mode for
encryption counter mode whoo
this terrible thing turning a block
cipher into a stream cipher well it
turns out that if you use that and you
use cbc-mac
then you're using basically the same
block cipher for all of your operations
you don't need a separate hash function
and a separate this you can use the same
key basically you just put them together
use both of these together and
everything works well okay it's a it's
good but it's a little slow because
you're using for your authentication
this cbc-mac
which is a a little bulky so the thing
that's most popular today is what's
called Galois counter mode and Galois
counter mode does and I think this is
the last slide of substance here uses
counter mode again for encryption but
instead of going through this whole
added layer of encryption running a
block cipher which is churning right ten
rounds of AES twelve twelve or fourteen
rounds of AES whatever it is to do each
block it's doing something called Gauss
multiplication and Galois multiplication
or Galois field multiplication basically
it's just doing one multiply per block
and zipping through the blocks doing
something very very quick
now that Galois multiplication could be
a little painful in software except that
it's very fast in hardware it basically
looks a lot like multiplication without
bothering to do any carries so that
should be fast there except the
multiplication and hardware typically
does carries but newer processors also
with along with the AES and I
instruction have this instruction which
is affectionately known as pickle
knuckle duck and once you've heard it
you cannot forget it which is basically
performed carry lists multiply on quad
words 64-bit words
so it does this special Galois multiply
which is you know very fast and hardware
and zips right through and you can get
the unauthenticated decryption very
quickly okay
so I've pretty much used up my time you
can say a little bit about what's coming
next
next time two weeks from now we're going
to be talking about a symmetric
functions diffie-hellman RSA how will
our essay into few element actually work
you're in and you can really 10-15
minutes from scratch you can understand
RSA another problem and then we'll go on
to elliptic curves and lattice base
stuff protocol properties and other
stuff coming on okay I kind of raced
through this I wanted to get through to
authenticated encryption so I rushed a
little bit but anyway any questions
that's it you definitely lose security
the only reason for doing it is space
because you're doing all the work the
the more bits you truncate the more
likely it is that there'll be a
collision right you know imagine sha-256
truncated down to 128 bits
well truncated you know 128-bit hash
function just on if the length is
considered insecure and the reason is
maybe I should talk about this more
another time but most of you have
probably heard of the birthday paradox
and the birthday paradox you know says
basically if you get I think I can't
remember the number now is it 19 I think
it's nice it's square root of 365 plus
or minus 1 basically so I but if you
have square root of 365 possibilities
then that's enough that you get a repeat
right so if you get about 20 people in
the room and we could do this we have a
little bit more than that
I it's almost a certainty that at least
two people in the room have the same
birthday and if we were in an elementary
school class right now we'd go through
and have everybody say what month they
were born in and we'll find the
collision I'm sure there's got to be one
in here but with 128-bit hash function
you only have to go through to a two to
the 64 possibilities before you get to
inputs that have the same hash so for
the birthday paradox reason 2 to the 64
seems like a big number but it's not
that big a number it's not ridiculously
outrageous we really want longer 160
bits for char warden okay - to the 80
that's kind of beyond the edge but not
that far beyond the edge so even the
birthday attack gets you know breaks
sha-1 in not unreasonable amount of time
and there was some slightly better
attacks that are available
they just haven't quite been implemented
and used we really want a much longer
hash function just to resist against
birthday attacks and if we go down from
sha-256 - ah to 24 then it's only 120
112 bits of security against birthday
attack instead of 128 but that's that's
the only weakness nothing but bit
lengths yes very much so if you've got a
64-bit processor it's much much faster
so your function of choice depends on
your your processor size absolutely you
can do it you know the these operations
don't require a lot of 64 bit
manipulations it's not 64 bit multiplies
and such so you can do it with you you
can simulate a 64-bit value with two
32-bit registers but that means twice as
many registers to muck around with and
yes the performance will be a big hit
the gyms prefer ATS 128 over 256 okay
okay so yeah let me give a little bit of
a sense there I think basically our
feeling is a es 128 is just fine no
problem feel free to use it you get a
few extra rounds if you go up to a es
256 it goes from 10 rounds up to 14
rounds that adds some security you would
think you also get extra security from
the extra key lengths and there is some
but it turns out that it's been
discovered there are some slight
weaknesses in the key schedules of AES
256 that make it not quite as strong as
you would expect a 256 bit function
today it's still regarded as stronger
than AES 128 but there's a sense of its
stronger but AES 128 is really plenty
strong for all our applications there
are some weaknesses in the 256 bit
version why use it many people use it
anyway
I'm not going to tell you not to but I
don't see a big advantage yes I think
I've got round I think well I think that
the sha-2 functions actually had only 64
rounds in fact I think sha-256 and
sha-512 do the same sort of thing but if
I recall they're six they're both 64
rounds but there are somewhat more
complicated rounds but it's true you
don't do the either you don't get that
much more round security it's sha-256
and sha-512 are almost exactly the same
function it's just done double the data
and you get those benefits options yes
yes the I the IV's are fixed you yeah
you can look them up they come from
mathematical constants and
you know there yeah they the that the
the standardized used is only valid with
these particular IVs so that you know
exactly what you should get
but the CTR have the current security of
CB c CB c
normal okay
so what what we prefer with the crypto
board prefers microsoft standards is CB
c CBC encryption with separate
authentication that's sort of common in
standard the authenticated encryption
modes are new some people are saying hey
this is new I want to use it it's
available we're not going to complain if
you want to use one of the authenticated
encryption modes CCM or GCM especially
and they're sort of being rewritten into
the the the SDL rules to say okay if you
want to use those not a big deal those
do use CTR for encryption but they use
it in a way that's carefully managed
stream ciphers are you know is basically
CTR becomes a stream cipher it takes the
blocks they're from mixed stream cipher
there's nothing wrong with stream
ciphers when they're properly used they
were for years the most common form when
you did TLS negotiation you usually
didn't still maybe it's 40% of the time
now you're using rc4 is a stream cipher
in a properly managed environment it's
fine it's just there been so many cases
in this company and in other places
where we've messed them up that was
saying don't use them on your own but in
this context it's used within a managed
environment where it's used in this
particular way so it's okay yeah
you can misuse juice yeah did you talk
to her I not very well I I've heard some
of this I I should look it up more I'll
tell you what I'll take a look and try
to get some data for next time but I I
yeah I've heard this also I think it's
not a realistic case but but yeah you
talk about random right random reads
working from an expert burn for CBC what
about random rights obviously I won't
work that see that does not work what is
the like what is BitLocker use right
good luck obviously it has random writes
on a vast scale yes
what are using situations like that
BitLocker has some interesting
requirements because it also has to be
completely in place then it cannot
afford any data expansion because you're
taking what might be a completely full
harddrive and you're encrypting it there
might not be any space at all to write
anything else so yeah yes so it does
sector level encryption and what it does
is each sector is individually encrypted
there's no effect on other sectors
sectors aren't blocked together and the
the IV that's used is implicit in the
sector number so that's how get that and
what's done is a tricky method well this
was done for a while I think it's not
it's I don't think it's being used
anymore but but it's it's a nice design
what was being done at least was instead
of encrypting block by block within the
sector to get good diffusion across the
whole sector there's a preprocessor that
was run there was sort of a diffuser
that took all the bits in a sector just
scrambled them up not in any really
cryptographic way just sort of spread
them out and then did a encryption block
by block encryption
these spread-out blocks these mix so it
did this got this mixing in so if you
change just one block it's gonna change
everything in that sector see it's there
another okay I guess not I guess we're
done for the day here's the signup sheet
if people didn't get it thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>