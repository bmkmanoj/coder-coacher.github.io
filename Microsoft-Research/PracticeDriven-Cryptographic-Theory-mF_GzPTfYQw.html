<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Practice-Driven Cryptographic Theory | Coder Coacher - Coaching Coders</title><meta content="Practice-Driven Cryptographic Theory - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Practice-Driven Cryptographic Theory</b></h2><h5 class="post__date">2016-07-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/mF_GzPTfYQw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
alright so it's a pleasure to have Tom
Mison for speeding today tom is an
assistant professor in University of
Wisconsin done a lot of great work in
cryptography and security looking at the
use of randomness and cryptography hash
functions format preserving encryption
and all sorts of things and insecurity a
lot of reworking cloud security in
particular looking at loner abilities in
DC too and I guess today he'll be
talking about cryptographic theory
Thanks the introduction so everyone done
reading did everyone enjoy the quote ok
yeah whether you agree or disagree is or
if you wrote this quote that would be
awesome actually can a step forward at
the end of the talk I'd love to hear he
wear and to have a discussion so yeah so
this talk today will be about
cryptography particularly and kind of
loose a kind of viewpoint of what I'm
calling practice driven cryptographic
theory this is joint work with lots of
fine people so I won't read their names
but recognize that they did all the hard
work of course I'm just taking the
credit so you know we hear a lot about
provable security crypto and doing
formal analysis having lots of rigor and
the usual story we hear strongly that is
that you know theory we develop and this
educates how we should implement and
deploy cryptographic algorithms or at
least that's what you hear in the
academic community but what we know in
practice is that we have lots of
cryptographic standards particularly
that have vulnerabilities in them right
so there's a bit of a disconnect between
the in theory powerful tools we have to
avoid vulnerabilities and the reality
that we have a relatively poor track
record of completely secure standards
and these aren't just you know
implementation bugs that there are
plenty of implementation bugs out there
we haven't solved as a problem getting
rid of inflation bugs but these are you
know problems in the cryptographic
designs as well and you know there's
lots of explanations for this about how
standards are developed and you know I
think most importantly in terms of how
it relates to theory you know we often
find that standards were developed you
know without knowledge of applicable
theory that might help but you
they often that these standards are
developed before any suitable theory
existed and this I think is really a
comment address to theoreticians who
perhaps think theory is all there and
ready and happily will help us solve
these types of types of problems so we
definitely have this type of a handle is
my favorite picture from particularly in
light of the Olympics going on right now
we have a lot of pressure on our
athletes to not repeat this and we might
think that in the crypto and community
we we also have a little bit of a baton
dropping situation that you have furious
on the right trying to hand off some
information or acknowledge about how to
design crypto to practitioners on the
left and you know something gets dropped
what's that he's got a baton no but our
boys and one else's no baton no baton oh
the time oh so this guy doesn't have
let's see this this is it's I it's a bad
resolution I think I think NBC or the
events that the Olympic Commission
copyrights all the high res pictures of
this or something so the only ones I can
steal for free from online which I
shouldn't say that would being recorded
I'll we're uh yeah this is I think this
is a guy who won the race actually so
you know maybe that's like the the
static analysis community or something
doing better than the cryptographers
anyway so you know there's a baton being
drop so so today I'm going to basically
talk about you know kind of trying to
change the viewpoint a little bit
instead of thinking about Theory
educating standards let's look at it
completely opposite and think about how
we might derive new theory surrounding
in particular cryptographic standards
right and so will take standards is
ground truth and try to understand you
know use theory to understand better
what they're giving us or what they're
not giving is so in particular this will
excuse me give a you know I'll basically
apply this very high level approach to a
bunch of different projects we'll talk
about your project turn but the idea is
we're going to you know first start by
looking at standards right and
understand try to understand from them
what are the off it
an implicit security goals and then
match them to you know existing formal
definitions from cryptographic theory or
provide new definitions which we often
see that we don't have appropriate
formal definitions of security for these
types of tasks and and then you know use
our theory now as a post facto tool to
to analyze the schemes in these
standards the cryptographic schemes and
this will help us clarify the security
posture of these systems either by
helping us sauce out you know
vulnerabilities that were previously not
known or provide proofs that can help us
improve confidence in the cryptographic
schemes okay so with that viewpoint
we're going to talk through a few
different recent works that all follow
this this regime one is a bit older I
talked about this last year a bit the
TLS 1.2 record protocol I'm going to
talk about again those you guys who
haven't seen it and then i'll talk about
newer work that'll be appearing soon on
password-based cryptography and the H
Mac construction okay so let's just get
right into it with TLS and kind of skip
over some of the basics TLS is you know
used everywhere to protect web
communications and it consists of two
main cryptographic portions one is the
secret key exchange protocol to share to
a drive a shared secret k and then that
that shared secret is used to send data
via the TLS record protocol which is
aimed at providing confidentiality and
authenticity for communications so we'll
be focusing on just the record protocol
portion of this and not not concerning
ourselves further with the key exchange
so inside the inside the record protocol
is a particular cryptographic encryption
scheme that we call the Mac encode and
crip is also sometimes called Mac then
encrypt algorithm and the idea is that
we're going to provide an all-in-one
solution via two parts right first we're
going to take our payload data and
authenticate it with a message
authentication code
and then we're going to encrypt the
result of concatenate the payload with
the tag and some padding if needed with
encryption mechanism and then send the
result along the public channel okay so
there's a lots of different algorithm
cipher suites that are used inside TLS
we're just going to look particularly at
the CBC algorithms for underlying this
Mac and code and crypt okay so what
happens there will CBC mode within TLS
or as follows we take the payload the
Mac tag that we compute already and then
we have to pad out the the resulting
string in order to get a bit string
that's a multiple of the block size
underneath that's used inside CBC mode
so if we're using a s this is 128 bits
and so we need to have a multiple 128
bits and then we use CBC mode standard
CBC mode on the result as so so the most
recent versions of the standard the they
use explicit initialisation vector
vectors so this is where you choose C
not randomly each time you encrypt a new
message and send it across this is not
what they did in Prior versions of the
standard and before they use like the
last ciphertext block of the previous
encryption ok and then relevance to our
results particularly going to be the
padding choices that can be used in TLS
and basically it's this regime where you
pad out with bites and the byte value
that you use is indicative of how many
bytes of padding minus one that you have
right so if you have to pad out by one
by 200 if you pat out by two bites you 0
1 0 1 3 by 3 02 02 02 the idea being of
course from practice very nice right
because you just read the first night
that tells you how many more bites you
have to remove when you're decrypting
and moreover CBC mode or TLS allows
extra padding right so you don't
necessarily you don't have to do just
minimal length padding so to get out to
the next boundary
n bid boundary over the block length
boundary but you can also pad out
further okay and the reason they do that
as indicated in the standard is that
this is a countermeasure thought to help
prevent traffic analysis attacks
basically that analyze the lengths of
particular messages right so by padding
out extra amounts you can hide how long
the message was or at least that's the
idea okay so to summarize on the padding
choices there's there's two that the
standard supports one is minimal length
padding you just fill up enough to get
to the next block boundary or you can
have extra padding and so you'd have
extra blocks of padding beyond what
would be minimally needed okay and some
most implementations use minimal length
padding but some do use extra padding
like new TLS by default uses they choose
a random amount of extra padding each
message to again try to frustrate
traffic analysis at acts okay so the
first thing we notice when we you know
sat down to look at TLS was that this
length hiding goal that is explicit
inside the TLS specification isn't well
addressed by existing definition so we
rectified that and this was technically
relative technically straightforward
right we took existing definitions and
extended it to a length hiding setting
that also seeks to hide not just the
content of messages from adversaries but
also the lengths and then given that
tool we want to do analysis of the TLS
record layer and in this first work
which is the older stuff which of our
talked about which we all explained
again we point out that actually there
exists in a tack in the case that you
use truncated max with TLS Mac Mac
encode encrypt and this variable length
padding and then we show that if you
aren't if you don't meet the
preconditions of this
attack that you have basically one short
at least one short message and a short
tag and variable length padding than
everywhere else we get positive results
about security and so I'll mostly talk
about the attacks it's a cute and simple
and then more recently weird you know
this someone prompted us to try to
understand the benefits of this type of
padding based approach and we recently
had a paper discussing traffic analysis
attacks against these types of
countermeasures and i'll just briefly
mention the results about that and point
to you maybe piqued your curiosity go
look at the more extensive results in
the paper so the the very short take
away is that you know the tag size
matters in the end using mac and code
encrypt not just here in TLS but if you
use it elsewhere and if you have a
setting like this where the the tag is
short you have a message is short and
some of the padding ends up in the first
block then there can be distinguishing
attacks and otherwise you are okay
there's a you know pretty thin line
between security and security okay so
just to give the attack setting a little
bit more concretely so we have an
attackers a man in the middle and we
have a client on the on the left and a
server on the right and the clients
going to encrypt some message x let's
say it's either yes or no just for
concreteness note that these are two
different length messages right if you
assume that they're encoded is a byte
per letter and the goal of the attacker
now is to determine which of the two
messages was encrypted right and so he
gets this ciphertext and what he's going
to do is now mall the ciphertext so he's
going to modify it and then forward on
the result of mauling it to the server
and then look at how the server responds
to see whether it was a it was yes or no
okay this is a classic active man in
middle attack okay so let's set some
numbers so we have a tag length of t
equals 80 this is a classic choice for
truncated tags
blanc length of 128 which corresponds to
a s and now we have I'll just draw out
the two cases we have for see based on
whether it's yes or no being encrypted
Oh in particular and we'll have one
extra block of padding which is assuming
we're trying to hide the lengths beyond
the first n bits so if no was encrypted
then we end up with encryption and
padding that looks like this we have the
two byte know the ad bit tag and then we
have four bytes of padding filling out
that block and sixteen bytes of padding
in the in the following blocks that's in
hex I guess so ya mean by hiding the tag
length you're hiding just a one block
well so so if you extend out to to to
another n bits the in theory if it's a
secure scheme the adversary shouldn't be
able to tell whether you have encrypted
message that's of any length between
like one bite all the way up to you know
to n minus one bites right so all those
should look the same batter story
because he'll just see three random
looking blocks of of ciphertext ok so if
you choose to do this then you would and
you end up one of those messages you end
up in Krypton is just two bytes then
this is the result you would have ok so
answer your question or answer oh you're
just trying to hide how many bytes in
the last block or message and papas
right yeah so the adverse raishin be
able to tell whether there's like you
know 20 bytes of padding or one by two
padding right that's yeah because it's
all encrypted by CBC mode yeah ok so
then the other setting is if we have a
yes message being encrypted right and
that means we have one last block of
padding Oh bite of padding excuse me and
so you subtract one from 13 get 12 and
makes a slide generation easy ok so we
have these two situations it could have
been one of these two situation the
adversary wants to figure out which
right and so now the attacker wants to
he gets c0 c1 c2 and he's going to apply
the same you know modeling procedure or
he's going to apply a mauling procedure
to it and it'll do one
do two different things based on which
of the two message was actually
encrypted so here's what the attacker
does he takes the first block that he
gets c0 and he acts soars into it 10 the
bite 10 to the fourth okay so that means
four bites with the fifth bit set to one
right and the rest of all zeros okay and
we'll see what that does in a second and
then he basically deletes the last block
doesn't care about it and forms a new
cipher text at c0 prime C 1 and sends
that on okay so in the first case we've
thrown away the last block we've flipped
four bits in c0 and that ends up
flipping four bits of padding when the
recipient does decryption and so in fact
this will decrypt just fine on the
receivers end okay the mac will check
out the padding is correct and the
server will be like happy with it and
continue on with its communications now
in the case that the message was yes so
what happens we thrown away c2 we've
flipped four bits here that changes the
padding to be the correct values here
okay but we've also flipped one bit of
the tag and the security properties of
our tag will I mean the tags in store
mystic function so it's not going to
it's not going to verify and the server
will reject this decryption as invalid
okay and and in particular what the TL
spec says then the connection we get
torn down and so the attack will see
whether it was no or yes ok so this
attack works particularly because the
you can use the IV to flip bits in that
padding but that only works if you have
padding that is inside the first block
of CBC encryption and so fortunately
with the cipher suites that are chosen
in TLS that doesn't exist because the
max are always larger than one block in
length
if you use truncated max which is a
common thing to use and specs as
indicated i can RFC 6066 for TLS then
the attack could apply fortunately we
looked around quite a bit to make sure
nothing was actually vulnerable in
practice right now and it looks like
that's the case for the moment so no
one's using this particular combination
that's vulnerable and of course that
leaves the question of what happens with
all these other cases I won't go into
the details but we analyzed the security
and we showed that okay if you avoid
this one corner case you basically can
show security okay so as I said before
this prompted us to try to understand
what you know we were kind of curious
how far this length hiding security
actually takes you in practice and in
particular there's been this long line
of work on a particular traffic analysis
setting that you know TLS in theory
should be able to help protect against
and the ideas you have a tack or whose
again a man-in-the-middle but this time
passive and it's going to be viewing
ciprodex being sent back and forth
between some user and an HTTPS proxy
that means you're going to like funnel
your website requests over a TLS tunnel
so that the IP address and everything is
about the destination website is hidden
and the proxy is going to forward on
your request to some server and the idea
is that attacker shouldn't be able to
figure out what website you're visiting
okay is that you know if you're using
tor or any of these privacy enhancing
jaaneman any of these privacy enhancing
technologies this is you know an attack
setting of interest and so this is
called website fingerprinting because
you're trying to attacker you know say
gets some he wants to fingerprint what
the destination website looks like in
terms of ciphertext flowing back and
forth and then later figure out if this
is the same size website that you're
visiting and so the usual thing in the
active literatures look at a so-called
closed world setting so the attacker
knows like the set of possible websites
that you're you're going to visit and
the state of the RS use these types of
supervised machine learning algorithms
to try to train on label data so you
know you set up your own system to visit
websites
train a machine learning algorithm to
classify whether its website one or two
or three and then you take that
machinery in theory you can go and apply
this to an active attack setting so
there's been a lot of work on this as I
said and we couldn't really figure out
what the conclusions of this work were
because particularly all the most the
works had been in a setting where there
was no counter measures like length
hiding authenticate encryption and being
used like in New TLS and so we wanted to
understand how much these
countermeasures like the LH a
countermeasure and TLS can help so we
had a poor student go and implement all
sorts of different attacks from
literature including some new ones
simulate a variety of these
countermeasures including things like
the TLS countermeasure and get grabbed
there's some data sets that have been
used in literature prior previously and
then for all these variables run
extensive tests to see how how good this
attack can actually work how well this
is technical part and so the results are
what we thought were pretty pessimistic
so this chart shows the average accuracy
taken over a bunch of runs of figuring
out which of K websites a particular
user visited when using a variety of
countermeasures so none is just like raw
encryption without any length hiding or
padding mechanisms and then there's a
bunch of other ones like patent em to
you session ramp to feed five pack at
random which is this is corresponds to
TLS what you can do in TLS like what new
TLS does and then a bunch of other ones
including more advanced things that I
won't explain like traffic morphing and
what we found is that you know you
basically can set up a very simple
machine learning algorithm yes
council measure west and mer khamis
measurements order and that was saying
where's this say the exponential thing
yeah I mean so the so it's not clear
that it's like a linear thing right like
having kind of measure the
countermeasure might actually increase
the so let me explain what the
classifiers and I'll get right back to
your question so the so that what we
show is a simple naive Bayes classifier
that really just took a few features
from this traffic right so instead of
looking at individual ciphertext lengths
what it did is look at much coarser
information like the total bandwidth
used in either direction by the
connection the size of bursts and the
number of them and like the total time
for the connection which is a bit of a
difference from what the prior works of
new and they really been focusing on
individual cipher text links is the
important feature and so this is what
this v ng + + a classifier did and so
you know so to get back before i give
you the just a closing thing here the
the punchline is that these these
countermeasures like pad to mt you know
which one were you looking at
exponential can actually exaggerate some
of these features for us right because
you're at your padding so it might
separate better the total bandwidth used
by one website compared to another
website as compared to using no
countermeasure at all that's a rare case
generally speaking the the
countermeasures do a bit better than
then no countermeasure but it's not
necessarily always the case does that
answer your question yeah I thought it
was the other way around isn't higher
better in this graph for the attacker
yeah yeah yeah so the attackers doing
better against exponential over here
then then none yeah yeah so it's a great
question and the answer is that the you
know just for these features it turned
out that like that actually exacerbates
the phenomenon okay so the point being
that you know length hiding can be
helpful in settings where you're really
worried about these fine grain you know
lengths being revelatory like yes vs no
but seem to be less helpful at may
not helpful at all in in settings such
as website fingerprinting okay and this
is just like we did a lot more analysis
in the papers it was a survey paper
looking at all these things and doing
new analysis of all these various
algorithms okay so that was you know
looking at TLS 1.2 showed you know a new
we gave new definitions I didn't talk
about but there in the paper new attack
that wasn't known before and also looked
at I guess this traffic analysis stuff
which I didn't explain in too much
detail but you can go check out the
paper so now I'll move on to password
base cryptography class there's any
further questions about TLS okay so p kc
s number five is a basically the
standard that helps us answer the you
know the following question we have an
encryption mechanism like CBC mode right
it expects a encryption key that's
uniformly selected at random from some
space of bit strings so if you're using
a su expect a random 128-bit key but in
practice of course we'd often like to
you know encrypt our data with a human
memorized will password right so mines
like one two three four five clearly not
a uniform Lee selected bit string 128
bits so how do we do it at pkgs number
five is a standard that you know was
developed in her published in 96 or sup
1996 and it's been around for a long
time that speaks to how to deal with
this and the solution is very natural
it's to use what's called a password
base key derivation function or PB kdf
so the idea is we'll take our password
12345 we will choose a random salt okay
which is a just a uniform but public bit
string of some length say 64 bits or 128
bits will concatenate those together and
then we'll hash that result with a
cryptographic hash function like shot
one or sha-256 nowadays then we'll take
that output and we'll hash it again well
hash again again again we'll do that C
times to get a bit string and
we're going to use this as our key for
CBC mode of course if it's a little bit
longer so we can truncate k if we need
to okay so the algorithm in pseudocode
is as such right you get a pass or good
message you choose a salt you hash it c
times the pastor can in salt and you
crypt it with whatever your underlying
encryption mechanism is and you output
both the salt and the ciphertext now as
the resulting ciphertext okay so this is
used really widely or variants of it are
used very widely in you know tools like
winzip and openoffice even Wi-Fi wpa to
do derivations of session Keys uses one
of the PB kdf functions k cos number 5
and despite that there hasn't been much
analysis of this standard there is one
paper a few years ago which did a little
bit of work but wasn't very satisfying
and otherwise there hasn't been much to
say and so we want to understand there's
some you know get a better understanding
of it so the first thing we realized is
that and i'll explain this more is that
again here we have no theoretical
notions that really were satisfying in
terms of measuring the efficacy of the
measures a counter are the mechanisms
underlying pbk DFS in particular we
needed a new framework for defining what
we're calling multi-instance security
notions that measure kind of the
hardness of breaking many instances of
cryptographic objects in parallel and
then we analyzed p kc s number 5 using
this new framework give some proofs of
security amplification for for them so
we basically proved what you would
expect to be able to prove about them
but nevertheless were the first offer
such proofs and we have some what I
think you're nice simulation based
techniques that we think will be a pool
to places beyond just like password
based encryption but elsewhere as well
ok so the question on first question is
really why do we need new theory it
seems like this is a pretty
straightforward thing to analyze its
encryption we've have lots of encryption
definitions so why can't we just use one
of them
well let's see i'll give you a kind of
the most obvious approach to defining
security for a password based encryption
scheme this is basically you know using
the classic indistinguishable inator
chosen plaintext attack notion so let's
fix set d that's the set of possible
passwords okay it's not you know 128 bit
strings anymore but it could be some set
of possible passwords that people choose
and we're going to define security this
way so we have an attacker that's going
to play a game with a challenge which is
the gray box on the right and the
attacker queries two matches m0 m1 ok of
his choice and what the Challenger does
is picks a password well for simplicity
news talks just assume it's uniformly
chosen from this set he also picks a
random bit B and then he encrypts using
our PB like our password based
encryption mechanism one of the two
messages based on bit be under the
password and then returns the result ok
in the adversary wants to figure out
which of the two messages is ok so he
guesses a bit B Prime and wins if he got
it right ok so this is this is nothing
exciting right this is that if you're a
cryptographer maybe it's like super
exciting if you if you're not this is
the classic ind CPA definition just you
know with passwords as opposed to keys
and and of course just the single query
version for simplicity but it's easy to
extend to to multiple tries by the
adversary ok so under this notion you
can prove well this is a corollary of
our later results but you can prove the
security of PB encrypt using this hash
based construction and so and in
particular get a statement that works in
the random Oracle model so to make
assuming H's ideal that says basically
that the advantage of any attacker in
this game is bounded by Q over C times n
ok where n is the size of this
dictionary passwords sees again this
iteration count of the hashes and q is
the number of hashes hash computations
hash queries that the attacker can make
ok and this is what we would expect
right because this
matches a very a brute force attack that
works in time close to CN right what do
you do you just try all the passwords so
you hash C times each of the passwords
and you try to Krypton the ciphertext to
see which of the two messages it was so
that's good so it's it's it's tight with
a known attack and so this seems to be
the best we can do so there's two issues
that remain you know one is the kind of
obvious thing that everyone knows about
passwords which is the password suck and
n is small right and so this fundamental
in this setting but you know even if we
have you know an approx big like 22 31
we can set C pretty large like a common
choice is 10,000 we can't set it too
large because you know might slow down
functionality so like something like
10,000 is what's used in WPA I think for
example but still this means that you
only need you know and our proof works
showing that you need only that the best
attacking you do is the brute force
attack right which requires about time
to to the 44 which by today's standards
is getting pretty narrow okay this is
like a fundamental minute limitation and
passwords okay we're not going to hope
to do better than that but there is
something else that's kind of suspicious
about this whole analysis which is that
we never said anything about salts in
the whole analysis so remember a slide
ago I said there's a salt being chosen
and randomly and it's bits but you
notice nothing here about s nothing
about salts arises in the theorem
statement so from the point of view by
nGCP a security salting doesn't matter
which stands in stark contrast to the
fact that we hope will know that salting
matters really a lot in practice and so
let me explain why okay and the reason
is that salting helps quite a bit in
what in a multi so there's there's two
reasons salting works is very important
i'll talk about one of them one is that
pre-computation attacks become harder
right if you don't know the salt oo
priori there's an issue we're giving the
salt to the adversary right away so he
gets it right away so we'll talk about
the other issue which is that salting
helps in this or Klein multi-instance
attacks thinks now let's think about a
new attack model in which
the attacker gets access to basically em
different challenges so say he's getting
c1 through cm which are ciphertext of
independent messages and 12 mm encrypted
under independent passwords chosen from
the set d okay and his job is to recover
the messages okay so what do we know
well we know the best-known attacks are
such so with salts we get that the best
no attack takes time approx MCN Rex you
have to brute force or you attack brute
forces all em passwords and each of the
pastor's takes en time without salts you
there's a faster attack right which
takes time just C times n plus M times n
right because you can use like rainbow
tables to compute for each possible
password let's see wait for each
possible yeah for each pulse thing you
compute the hash you can use the
time-space che house if you want but
anyway the point is that that you lose
the the multiplicative by M factor in in
the attack okay so we saw that so what
this is the best-known attacks we'd like
to prove again that you know we get what
we expect which is that breaking em
encryptions requires MCN time but now to
prove something we need to have a
definition security we I just showed you
the ID CPA actually doesn't speak to
this notion of security doll so we need
a new one yeah Christians me descending
break one of them are all then means
breaking all of them oh yeah yeah so
breaking one of them would be like the
traditional like single instance
security saying what we're calling a
single instant security setting right so
IDC PA but here are we really saying you
need to break all of them and this is
one benefit assaulting that as you try
it gives you a second line defense so to
speak right that you know even if you
can brute force one password you may not
be able to brute-force you know a
million passwords and we'd like to be
able to show formally that that is
actually enjoyed okay okay so we need
new definitions so
I'm going to walk you through defining
not multi insecurities but just to
instant security because it fits on the
slide nicely with having to challenge
boxes opposed to many many and so the
first attempt that we had at at
capturing this this role of salting in
forcing this MCN multiple good factor
improvement in security is to use what's
called the multi-user setting which is
from bellari at all and the idea is now
we have two boxes right with two
different passwords okay and the
attacker can query both of them with
messages and he gets back from either
one the same left or right message
encrypted under that particular password
and his goal is to guess what the bit
was okay so this is an attempt this is a
defining you know indistinguishability
when you have access to multiple
different instances of the cryptographic
primitive so this doesn't work for us
okay because actually the best attack
again here works in just CN times as
opposed to to CN time right because as
soon as you brute force one of the
passwords you learn the bit that was
used for both boxes okay so that doesn't
help us so the next natural thing is
that ok we need independence completely
between these games so that they're
totally separate and so what we do is
have an independent challenge bit as
well as independent passwords for both
boxes okay and so the attacker again
gets interact with both these boxes now
this becomes what I guess people the
amplification literature we call like a
direct product game so you have two
independent copies of the games the
adversary gets to interact with and so
the question now is how do we gauge
success there's two challenge bits the
most obvious one which could be could be
fine is that the adversary tries to
guess both of the bits okay this is like
a nan measure he has to he has to win
against by guessing both and we can
subtract off the trivial probability of
winning which is a quarter here right
there's two random bits so the trivial
winning is a quarter we find this not
particularly convenient to work with I
mean it's a mathematically to find
definition but it's not going to work
with you know for example it doesn't
really capture breaking both instances
the advantage management really captured
breaking both instances because as soon
as you break one you can just guess the
other bit and you get you know constant
advantage like one quarter where we
would expect that to be zero because you
haven't really beat both instances you
just guessed against one of them so we
can solve that by changing the advantage
measure a little bit to make it more
commute to work with which is use an XOR
okay and this has you know this
basically gets rid of this weirdness
about having constant advantage even
though we only broken one of the
instances and so that goes to zero okay
and this is basically our suggestion
that we think this is the kind of a nice
one to work with it's called the XOR
measure and you can of course extend
this to multiple instances and actually
this is just for encryption but you can
do it for lots of other settings and in
the paper we talked yeah there's a
question yeah is it a stretch no no so
doesn't devil are a paper discuss why
they chose the same bed yeah so was it
though right so so I should have said
this was not a suggestion for our
problem this is just something that
seemed like it could be useful in our
setting and so the multi-user setting
was suggested for a different reason
which was to look at you know how to do
efficiency improvements for like public
key encryption schemes and you're
absolutely right there's something about
whether you have a bit that's joint
across the games or independent which
dictates something about what you're
learning from each of the individual
encryption so if there's a joint bit
that means the information that you're
learning potentially from the box is
correlated across the boxes and if
there's independent bits that it's like
independent information you're learning
from two different challenges so to
measure the hardness of this type of
multi Anson's tag where you really have
to break em things you need to have the
independence otherwise there's nothing
to do right for the next band plus 1 or
the you know the next instance if you
already know what the message was
there's nothing left to do so you don't
have to break the password right it's a
great question Yeah right ready right
and don't get you know another point of
clarification which is a great
opportunity to bring us out who we're
not saying that just breaking one
instances is ok right obviously that's a
bad thing to what we're trying to get at
to is the Y salting helps us also get
this other you know measure so we
ideally would of course like to have
that breaking any single instance is
very hard but in salt and passwords
that's not the case right so we'd like
to have the second you know setting
where at least you can't break many
instances oh I I disagree I don't know
is there actually oh this guy
okay oh not quiet I think I thought I
think floating or there I thought I was
just freaking out but something good
something my caucus morning okay measure
X or measure right lots more in the pair
i mean so this is very general thing
right you can define multi-instance
security for many places and and games
like this of you know like X or lamina
type results come up are very related
but not the same as what we're targeting
sorry there's like a lot to explore in
this setting and I want to talk about
that much more and all the other thing
is interesting and maybe not surprising
people working like amplification
settings is that things get technically
very challenging from a formal like
proof setting here so for example things
that were surprising us is that you know
very classic technique of hybrid
argument which is very used easy to use
in the in the single instance setting
becomes very messy in the in the multi
anson setting and so if that was
meaningful to you you can ask me about
after the talk wit but more about that
okay so back to the practically relevant
thing which is you know how to apply
this to PK cs5 well we go on to give a
differentiability style notion which I
will talk about that helps us with some
of the proofs and we're able to show
that indeed we get the the type of
phenomenon in this multi aniston setting
that we expect so we've gone from this q
/ CN to this q / MCN which matches the
the the the attack that we know works
right in MCN time when you have salts
that are sufficiently long okay so as
long as your salts provide independence
between all the points then between all
the instances then the attacker really
does need to brute force the all m
passwords okay so yeah any questions
yeah all getting rid of the red
yeah so it's a great question yeah uh
it's hard to say its inherent but it
would require a huge I mean so basically
this is all this setting is in a place
where you know you basically can think
of and here is just making this a flat
sets this is like a two to the main
entropy of the passwords right but
passwords you have lohman entropy so
we're talking something very small which
means that you can't use lhl or any of
the standard model techniques we know
they just won't work improve ibly won't
work at least for existing kind of known
haha universal hashing constructions so
that doesn't work the other thing we
don't know how to prove like the the
time see amplification if you go into
the standard model right we can show and
it's it's not trivial because you have
all these chains of potential like you
kind of think that you have em different
chains of random Oracle queries that he
needs to fill out and need to show they
know collide and overlap and do weird
stuff we definitely be able to show
anything about that in the standard
model and yeah likewise i think the M
factor is also something that would be
hard so it's a great question i mean
basically i think at this point for low
entropy inputs when you're trying to do
things like extraction we have no idea
how to do anything in the standard model
you know who goes has a very nice work
on this kind of pushing the boundary on
this direction but i don't think it yet
says much about this but maybe hello
have more to say about it soon and
insert and you know in practice this is
you know matching what we expect the
hash functions are giving us so any
other questions
okay so yeah yeah okay related passwords
there's a difference
so yeah it's glossed over here in terms
of related passwords I mean we don't say
much about this set end so you can
imagine this so actually this is a
simplification in the paper we look at
we don't even actually fix any
particular distribution over the
passwords they could be totally related
and what we show via this PB kdf in
differentiability style thing is that
you basically extract all the entropy
from the from the password space so if
there's so you wouldn't get a nice
closed form analysis here but you show
that all the you know even if you have
related passwords you get all the secure
so if you have one guy has a pastor
that's like one two three four five the
next guy has one two three four five six
you know that six was chosen uniformly
from 0 to 10 then we get you know
whatever entropy the first thing gave
which is 0 plus you know the 1 over 10
yeah anyway so the point is yes the
answer is yes yeah and it's kind of one
of the benefits of doing this simulation
style approach which it helps with these
types of things yeah yeah I versions
I'll mention passing in the next well
maybe I won't actually uh so the other
one uses hvac I'm going to talk about
each Mac necks and the result works if H
Mac is a random Oracle which we'll talk
about next fantastic segue thank you
very much so ok let's talk about H Mac
so just to set the stage Mac for those
of you who don't know is a keyed hash
function and it was designed originally
to help with the problems with length
extension attacks in the setting of
secret key cryptography so it was
designed with the idea that k is going
to be a secret key went uniformly chosen
and amisom message that you're trying to
authenticate it's used widely as a
message authentication code and TLS PK
CSS HIV sec pretty much anywhere you
look and there's been quite a few
analysis of its security in this uniform
he's heading on from the provable
security side view of course there's
also all sorts of like cryptanalytic
work analyzing it as well okay so a
little bit closer look at it you know
most most often in papers including some
of mind I kind of stopped at this view
of H Mac but for the purposes of this
work it helpful to get a little bit
deeper and in particular H Mac is
implement you know has structure to its
not just a hash from so you use the hash
function twice and what it does is it
takes this key K does something i'll
mention the sack transforms a little bit
and then x or is it with ipad which is a
constant bit string and then
concatenates the message hashes that
takes the the modified K XOR sit with a
different constant value and then
concatenates that to the result of this
and then hash is the final thing and
that is the output of H Mac ok ok so i
glossed over some details which is
consistent with most of the academic
literature on this and and in particular
the actual pseudocode for H Mac is is
this right so what you first do is you
check to see if the the length of your
key is greater than D bits d is a
parameter of the underlying hash
function so if the hash function is like
merkel damn guards is the block size of
your underlying hash function so with
shaw 26 its oh boy i just talked myself
in the corner there 256 bits 5 and 12
bits someone who actually knows
something please all right 64 bytes 58
anyway let's forget about its d ok and
then good so okay and what if it's
longer than this D bits you first hash
it with the hash function ok and this
gives you this K prime otherwise we'll
just set K prime decay and then what do
we do we then make sure that we then pad
out k prime to get d bits ok and we do
it with zeros okay and then we then
that's k double prime as i showed up
there and so then we XOR with ipad which
is d bits up here to get this h and then
down here Oh pad which is also d bits to
different D bit strings ok hopefully
that's consistent with people to
actually looked at hmax if you ok good
okay so and there you know and this is
really nice eh mac is a great you know
kind of Swiss Army knife it has it's got
two inputs right they both are can be
arbitrary length and so both arbitrary
line key is an arbitrary length method
messages and this is great cuz it makes
it very useful in a broad variety of
settings so it and indeed it's been come
used in so many many many different
settings so for example the PV kdf
question right there's a password based
cuter evasion function based on pmac
where now we use the password as the key
for H Mac which is you know again the
arbitrary length is nice password Robert
railing and we use is the input the salt
there's some other information to but
just think of it as a salt and then we
hash it once and then hash it again
using the past or each time for the key
of H Mac this is actually simplification
and PB kdf number two there's some other
stuff going on but it's basic structure
okay and of course this is not a uniform
secret key anymore which is important so
these other analyses don't apply excuse
me there's been lots of other
suggestions at least in other places for
using H Mac in other ways they're kind
of outside this traditionally envisioned
use so who has been suggesting this very
nice construction HK DF for doing a kind
of general purpose key extraction where
he uses the key input for H Mac as a
publix all value TLS 1.2 actually
already does things somewhat like HK DF
well I'll sorry uses H Mac as a
extraction max is not like HK epic for
the same type of purpose as what HK DF
would solve and in there K is again a
non-uniform secret like a password p kc
s number five and then i've used H Mac
in some other places as well what r k is
is is a non-uniform secret so you know
the question that came up was ok we have
analyses when k is uniform secret what's
going on when we don't have a uniform
secret and we'd like to understand if
these these other applications you know
are good so applying our
proach you know the first thing we
actually have a notion of security that
we thought was was good for this it's
called in differentially from random
Oracle and this is offered by Mauer at
all and it's basically says that H Mac
you know all together acts like a random
function on two inputs right so if you
change the key or you change the message
you get a totally different independent
looking output that's the very very high
level okay so then we did some analysis
of H Mac under the to try show that it
was in differentiable from a random
Oracle and what this popped out was that
there's some issues one is that there's
sa-weet keys we really should call them
weak key pairs in h mac and this relates
to something that i've been calling the
second dinner in differentiability
paradox which my co-authors hate that
name but I think it's really cute so you
can decide for yourself and I'll explain
that too and then we recover some
positive results in the cases that H Mac
avoids these weak key pairs okay so
let's uh let's see a long time let me
just say briefly so you know why do we
want to do in differential if random
Oracle well we had I said before that
I'd we had proven that you know H Mac is
when it's used inside pbk df2 is good
and that's true if we model H max random
Oracle so a function that like outputs
random things and differentiability
formalizes this notion of being in
differentiable from a random formalizes
this notion behaving like a random
Oracle and would in particular allow us
to you know show that this theorem works
when you take into account the structure
of underlying H Mac this to hash
construction plus the key massaging ok
so let me skip some of the high-level
discussion that let's let's give a
little bit of history because there's
some confusion about the individual NH
Mac both by myself and others so in
particular in the first paper that
suggested in differentiability is
analysis tool for hash functions they
analyzed a construction that they called
H Mac
which is not H back and I've yelled at
you getting about this and you just
yells back means to be we have a nice
time but anyway it's it's not H mag of
standardized so it didn't apply but I
mean people you know I read that and I
was like oh yeah it looks like it's fine
and it actually looks like the
techniques they use for that proof
should work for real H Mac too so it
seems like everything should be good and
so there's lots of works you know myself
included assuming that H max random
Oracle Croft check you know suggested
that the CDN po5 proof extends to H Mac
but but didn't get into details and
certainly it does look like it should so
we were we were we were curious to
figure out this was you know actually
the case and go do the due diligence and
figuring it out and this is where we
came across these weak key pairs okay so
if we go back to our description of H
Mac which is not what people you know in
this primarily thought of hmas but is
really H Mac we can see actually there's
immediately a troubling issue with the
way key handling is done and I hear
laughter in the back so so I've
highlighted the troubling issue which is
that if you have keys of different
lengths this is an ambiguous encoding
right and so in particular this gives
rise to what we call colliding keys in H
max so this is any two keys k 1 k 2 such
that they're not equal but H Mac of k1
on a message is equal to H Mac of k2 on
the same message so an example of
climbing keep air is just a key k1 and
then you add a zero to it and you get a
key k2 and you can you know verify for
yourself that H max going to treat those
two keys as the same value or the output
will be the same and this is a clearly
not what you would expect if you thought
H Mac was going to give you random you
know looking outputs for any different
k1 m k2m and so of course and this does
and do you give a very trivial
differentiability distinguisher you know
I guess if you had settings in which you
had related keys that looked like these
these types of relationships then you'd
have
real a key attack against H Mac so it's
it's not that not that great but
definitely you avoid this prom and i'll
talk more about the practical
implications of this and a couple slides
you can ask questions the sky is not
following yet but this is variously so
the colliding keys don't exist if you
use fixed length keys ok assuming h is
collision resistant I suppose so you
know these are keys of different lengths
so it doesn't work but even when you do
that which you know remember this is
like the original design goal was for
like uniform keys of a particular length
even if you do this then there's a
another slight issue that arises in the
way that the differentiation between
this interior internal application of h
and the external application of h gives
and in particular we get what we call
and get big uous key pairs and this is
any keys k 1 k 2 such that after you
process with this pre-processing to get
k 1 double Prime and K 2 double Prime
you have the the equivalence that K 1
double prime plus iPad is equal to K 2
double prime plus 0 pad I probably never
mention this hope Larry Moe picked up
this is X or in reality okay okay so
what does this mean this means that
there's not strict domain separation
between like the internal application H
and the external application of age and
you know so examples of ambiguous key
pairs are obviously like any K 1 such
that you define a k2 that's equal to k1
plus iPad plus of a pad right and this
particular works when k 1 and k 2 is
equal to D or you can also do it when K
one size of cable and size k 2 is equal
to D minus 1 and I don't think you can
do it when it's equal to D minus 2
because that's the first bit that's
different between iPad and notepad the
and there's other you know other
settings too but kind of narrow a corner
case in terms of the key space of each
Mac and so right no domain separation
it's not clear this doesn't give rise to
trivial kind of issues like the
kleidung key pairs do but does cause
problems for proving in
differentiability of H Mac and in
particular one can well we gave a lower
bound on in differentiability H mac and
so it's a bit technical haven't even
told you and differentiability is
technically but the point is we
basically show the implications the most
important thing that the lower bound
rules out having proofs and
differentiability based proves that give
good concrete security bounds and I you
know I can offline tell you more about
the details and they're lying the
technical issue instead I'll talk about
my favorite term which is this second
iterate paradox which you know gives RI
has the same issue start similar
structural issues as what happens from
ambiguous key pairs an H Mac but for a
simpler construction and this is
actually yeah so it's much simpler so
this is a construction that was
suggested in 2003 and textbook by a
higher and Ferguson and it basically
says okay let's take a message and we'll
hash it once and then we'll hash it
again second iterate of a function and
again this was a suggestion to prevent
length extension attacks which it does
seem to do but the thing that's
confusing is that okay if you you would
expect of course that if H is a random
Oracle it's ideal that if you iterated
m.h twice you'd you might lose like a
constant factor too and the security or
something because there's two
opportunities for collisions but you
certainly would expect nothing worse
than that right but when it comes in
differentiability actually you can show
that you can only have intervention with
very poor bounds and so in particular
like if you try to conclude using and
differentiability that this is closed
resistant you would best be able to show
that it's collision resistant to like 2
to the n over 4 where n is the output
size which is you know much less than 2
to the N over 2 anyway this again it's a
little bit technical I have some slides
like to describe what is the
underlying a tuition but running out of
time so I'm just going to skip all that
if you want to stick around we can talk
about it after the hours up we'll see
there's a lot of them oh ah you're some
more implications that's the best part
you skip all the technical seven get to
the implications so right so H Square
doesn't behave like random Oracle can't
hold with good bounds we do a lot of
work to figure out if this is something
that's practically damaging because this
is all proof stuff that I've been
talking about and the closest we came
was looking at a fairly natural setting
called mutual proofs of work where
you're basically you know two parties
are trying to prove that they've been
doing computing some hash chains and you
can abuse the properties arise from H
squared and also ambiguous key pairs in
H Mac in this mutual proofs work setting
but I'll refer you to the paper for
details is we don't know I mean passion
is used all the place I don't know if it
actually gives rise to any
vulnerabilities in any places it's a
really good question and and so the most
important practical questions like what
you know what does all this imply about
H Mac which is used all over the place
and you know r ich8 pairs could cause
problems but they really don't seem to
you know they're kind of like very
loosely like the week keys and dads
right they they exist but they don't
really come up seemingly in practice so
much so for example like with colliding
key pairs you you need two keys that you
know like if you had a password and then
another password which was that password
concatenated with a zero right if you
want one two three four five zero then
these would be treated as the same
password by the pbk DF which would speed
up you know brute force attacks by
factor too but that doesn't quite work
because actually of course and ascii
like when you even code and ascii you
know zero doesn't get encoded to the bit
binary value zero so anyway so a lot of
applications to seem to Center typically
avoid them certainly like HK DF and some
of these other things are using fixed
length keys that are you know like
uniformly chosen if they're public and
it's not a big deal and here we can show
stronger positive results about the
security of H Mac in the sense of and
differentiability which then should
allow you know showing security of these
other applications
with good normal bounds like that you
would expect in the sitting close to the
birthday bound oof so sorry the the
takeaway is that there's something to be
concerned about and aware of but doesn't
seem to be threatening any actual
deployed thing that we're aware of and
certainly makes doing formal analysis a
huge pain okay so with that I'll just
briefly reiterate when we looked at
three different projects here TLS 1.2
record protocol we had some a new attack
that hadn't been observed before when
you have short max did some new proofs
password-based crypto which kind of gave
rise to this new definitional framework
that was needed to explain the benefits
of salting and which you know from a
theory out imeem pretty tioning from
throughout construction we didn't quite
have the right tools to even explain the
benefits of some long-standing you know
mechanism that's used in practice and
did some proofs finally for a peek acs
number five and then we looked at h mac
and you know realize that in these newer
settings that h back is not that new but
in these other non originally envisioned
settings that H max be used in there's
issues with weak key pairs potentially
and our you know can't we can overcome
these in some cases to recover nice
positive results so from this you know
lands of practice driven theory and I
think the the message is you know while
it's great to and certainly a useful
perspective like think of fury as
educating practice I think we can also I
mean I hope I convinced you that you can
also turn around a bit and use theory as
a post facto tool right not only to you
know uncover you know based as a
vulnerability tool finding tool right
there when we go to try and prove things
and this complexity wreck way we really
are have to nail down all the all the
corner cases and what as we saw the
corner case has come up and apparently
these weren't realized before so it's a
great way to assess these subtle issues
out you know of course it helps at least
give some rigor to some intuition and
formal security goals
in the best case of course we can prove
something which isn't you know the final
word on security of course that only is
you know if it's secure when it deployed
in a system but can certainly improve
our confidence when we can show proof
and then you know maybe also
surprisingly that contrary maybe to sum
up in people's opinions you could grant
practices excellence / ation I think for
for new theory right things that that we
hadn't really considered before so if
you go look at standard you're not just
doing a you know community service to
try and understand security of a
deployed products but which is what
maybe through your Titian say but you
can actually also pop out really
interesting your theory that that can be
quite compelling so that I'll take more
questions and thanks just waiting for
someone asked me go back to all this
slide yeah no I'm just kidding sorry
good depictions again
well so the hybrid argument would right
yeah so good so this is a great question
the question you know can we why doesn't
single instance security approve
multi-instance security because you'd
expect the hybrid argument would do it
and that's true you could show a hybrid
argument that would take the q / CN
bound that we had before and give you a
new bound in this setting right but that
new bound would have a factor of M in
front of it right and that factor of M
would be on the top the numerator not on
the bottom and so actually will be
showing is am q / CN right which is
exactly opposite what we want to show
which is q / MCN right so it's too loose
is the short answer ought to use a
hybrid argument yeah and more generally
speaking this multi-instance security
setting we're really worried about very
small advantages right because it's not
no longer just like the security of one
instance but security many uses and so
if you I don't think about don't think
about what I was about think about it
doesn't make sense but how we're dealing
with very small advantages we have to be
very careful to make sure we preserve
them in our reductions and this is where
some of the other technical complexities
come up to and doing the proofs right so
uh it seems like it was presented in two
thousand and then people who've done
well the multi-user instance multi-user
okay uh well so that's a good question i
mean i think the the the recall the
multi-user in multan instance are
despite the poor naming conventions
perhaps that we chose as recent paper
are different right so ones ones looking
at i mean i think the way to
conceptualize is multi users like the
weakest link security soon as the
weakest of all the instances or users is
broken than all the security goes away
and multi anson security we're asking
that for instead that you know the
attacker has to break not just the
weakest link but he has to break all the
links right and so this is you get this
that you get this ability to measure
things like you over MCM here so i don't
know i mean i think the the there is the
reason the multi-user security notion
which is the weakest link notion didn't
catch on is that in most settings it
doesn't really matter whether you
analyze it in the hybrid if you analyze
the single instance setting and then
just use a general hybrid argument or or
use multi-user my recollection i'd have
to go back and read the original paper
from 2000 again is that that the you
know they're doing that particularly to
analyze constructions that were like
building you're using the same
randomness across other multiple
instance multiple users or doing other
things that were kind of non-standard
and efficiency purposes and you needed
that framework but for like normal
situations where you have independent
instances it you know you just you do
fine using the normal single instance
security notion but yeah we can we'll
talk more later on yeah okay so i'm just
wondering this notion
I feel like it's a little bit similar to
like harness and the kitchen of like
encryption schemes like you first took a
sickly sherry and quick many yep yeah I
mean it okay so I'm cutting you off go
ahead yeah and another maybe so in your
definition I feel like it's like yeah
hummus and verification is somewhere
inside this because you are like from c
qo vers ce and you like make it stronger
to em yeah so yeah so I so I mean I just
if I might the question is like what's
the relationship between this and the
traditional hardness amplification
literature the answer is very involved
actually so the the so for example like
this X or this X or measure smacks very
directly of like X or lemma type
constructions but like in an extra lemma
type construction you the construction
is actually the the constructions
actually that you XOR the bits from
these hardcore predicates and the
adversaries goal is to guess that bit
right whereas here we're doing something
slightly during we have independent
challenges that are separate from the
construction and the goal is to to guess
the XOR of all those bits okay it D and
then I sure that to be too
Oh share it I guess you could those
would be independent those would be
distributed the same but yeah but the
construction is not is not yeah so but I
mean you're absolutely right there's a
lot of connections and we've only like
scratched surface and exploring the
connections and indeed like you know so
yeah there's a lot of work so you can
use the same types of techniques that
have been used for like hunger has this
paper about analyzing you know whether
you can show and securities implied by X
or security in their context in kind of
a general setting which which seems like
which does apply here actually but it's
you know it's partial result you have to
do some mapping between the two so yeah
we're not trying to claim that like this
isn't related hard to say invocation and
in fact it is and lots of the same
techniques we probably arise maybe
there's connections we haven't even seen
yet there's actually like so can you go
back to other one probably a keel just
get this way this is once again I'll be
happy too many admissions yeah yeah
because I in this second of the big
dictionary size is more like
traditionally are we were thinking about
like something we could make illegible I
in here like there couldn't be anything
yeah so I mean yeah clearly if n is like
really really big like to to the
thousand and it hardly matters whether
you're attacking a million or ten
instances but yeah here you know we're
really worried about concrete security
here so like asymptotic Lee it's not
clear you get any benefit from these
it's again somewhat subtle to think
about this stuff asymptotic Lee so it's
really we're trying to preserve concrete
security right so you can think that
like if you're trying to break em algum
all instances or M ddh instances your
sub you know we would expect again that
you know the best you can do is like two
times the time I'm sorry M times the
time of the best-known attack would be
the kind of obvious approach to break
like loss mrs. and there you have
individual negligible answer but we
could also hope to gain that extra log
and security parameter like improvement
by like having to break many in parallel
the problem in no sense we should talk
about it like yeah</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>