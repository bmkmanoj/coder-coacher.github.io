<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Verifiable Functional Encryption | Coder Coacher - Coaching Coders</title><meta content="Verifiable Functional Encryption - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Verifiable Functional Encryption</b></h2><h5 class="post__date">2016-07-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/lnSK53P8BM0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
so we're very happy to have a sec
rochelle visiting us today yesterday
uh-huh saikrishna is a grad student at
UCLA and he's going to tell us about
some work he's done on verifiable
functional encryption thanks Melissa so
hi everyone my name is saikrishna I'm
from UCLA when I talk about verifiable
functional encryption this is joint work
with ripu I Oshana myth so before we get
to what is verifiable functional
encryption let's think about what is
classical encryption again there is some
person Bob who has some input X and he
encrypts it and sends it to some cloud
now if the cloud does have some secret
then he can learn the value X in the
clear right and suppose the cloud does
not have the secret then he learns
nothing at all the cloud learns nothing
at all about what is hidden inside the
ciphertext this is a guarantee that we
want from classical encryption right in
some sense looking at it a bit more
philosophically this is something like
all or nothing it says you either learn
everything about what's hidden inside
the ciphertext or nothing at all so to
broaden the goals of encryption the
notion of functional encryption was
introduced by say hi and waters and the
goal is to give more fine-grained access
to encrypted data so how does it work
let's say this is the same person Bob
who has some input X and he encrypts it
and sends it over to a club ok and now
the goal of the cloud is not to learn X
in its entirety but to just compute a
specific function f on the value X ok
and how does the cloud do this it talks
to another trusted party a party that
has a master secret key that is used to
generate everything in the system and it
tells the trusted party that I want to
compute this function f on any
ciphertext that i receive now after this
the trusted party returns to the cloud a
secret key corresponding to this
function f and using the secret key for
F and the encrypted message it can
recover the value of the function
applied to the message hidden inside the
cypher tech
okay so is that all we definitely want
some notion of security right what would
we want if this cloud was malicious Bob
does not really trust the cloud and does
not want the cloud to learn everything
about his input X he just wants the
cloud to learn the value of the function
alone right so the security guarantee
intuitively what we want is that the
secret key for the function f which I'll
denote as SKF should not allow the
adversarial cloud to learn anything
about the ciphertext except for the
value f of X ok we will formalize this a
little more later in the talk but
intuitively what we're trying to say is
that only f of X is given to the cloud
this is as good as Bob not giving the
encryption of X but rather just giving
in the clear the value of of X right so
this is notion of functional encryption
functional sorry who decides what this
function f is 0 so the cloud can choose
whatever function it wants and if the
tri-state party feels that the cloud is
authorized to learn the value of this
function f it returns a secret key for F
but if the function is just say the
identity function and the trash should
party things this is a bit too much for
the cloud to learn then it does not give
back the secret for F what kind of form
is this function to building typically
like expressed so it can be a class in
multiple ways are the most standard way
of expressing it is a circuit with and
or not yet but you could also maybe
express it as a ramp program or any
other model of computation that you have
one
so function encryption is a pretty
general primitive it's it's a
generalization of several well-known
primitives that we have studied like ID
based encryption predicates encryption
searchable encryption and so on so
before we get into more detail let me
formalize the syntax in a functional
encryption scheme there is an initial
setup algorithm that generates the
master secret key and the master public
key this master secret key is given only
to the trusted party rather this set of
algorithm is is run by the trusted party
and the trusted party gives this master
public key to everyone in the system in
particular the person Bob that you are
talking about gets this master public
key now whenever anyone wants to encrypt
the data they run the encryption
algorithm using their message X and the
master public key to produce a
ciphertext ok now whenever you want to
produce a secret key for a function f
you run the key generation algorithm
that takes a function f and the master
secret key as input and produces the
secret key function as output so if you
look back at the previous example this
algorithm is run by the trusted party
who has the master secret key with
itself but the function is fed from the
club so the cloud gives the trusted
party the function and if this function
is something that the trusted party
thinks the cloud should indeed learn or
secret for then the rational party runs
this algorithm on the function f and the
master secret key to produce the
function secretly and now there is a
decryption algorithm that is typically
run by the cloud in our previous
application where it takes a cipher text
and the function secret key as input and
it decrypts the two to recover the value
f of X
now let us try formalizing the security
notion that we wanted let me type let me
call this notion as message privacy why
we called a message privacy because you
want to hide the message that is inside
a ciphertext right let's just think back
to the notion of classical encryption
what would we want we want to say that
there is a person Bob who has encrypted
as input and send a cipher text that
contains X inside it and the same person
Bob in a different world altogether so
then the left world is M crypt sex and
since in the right to already encrypts
yn sense and if you really want the
ciphertext to hide what is being
encrypted he wants the cloud to not know
in which world he is interacting it so
that the adversarial malicious cloud
should not know whether it's interacting
with bob was encrypted X or with bob was
encrypted y intuitively the cloud does
not know which of these two words it is
in then the message is safe right
because nothing about this message is
known from the ciphertext so can we this
is the popular well studied security
notion for encryption can be discreet in
this can we just say that versary should
not distinguish between the left and the
right false clearly not right because in
the leftward he learns f of X and the
right word Iran's f of x and is there
different he can obviously distinguish
which one reason so what will the next
natural generalization of this be if f
of X is indeed equal to F of Y then the
adversary should not distinguish whether
he is in the left world or the right
word because if f of X is indeed equal
to F of Y then we saying that the only
thing he does learn is the value of the
function and once he learns the valley
the function learn nothing else about
the message that is hidden right so this
is a notion of message privacy and this
is a very simplified version where I
said this is one cypher text that is
being encrypted and just one function
key that the adversary has we could
generalize this to say that the
adversity gets secret keys for several
functions FG heads and so on and you get
ciphertext for several messages X x1 x2
x3 and so on and we would want the same
kind of guarantees to hold for every
function secret key and every pair of
messages in the left and the right word
the output of the function should be the
same but it's it's probably useful to
just think about this think simple
scenario of one function in one message
for the rest of the talk so what is one
practical use case of functional
encryption let us consider a scenario
where there is an auditor potentially
malicious who's tasked with the job of
auditing several banks and let us assume
the word bank is the trusted by T that
all banks across the world trust and now
this world bank has a master secret key
and whenever a bank with some input X
what is required to be audited it
encrypts its input and sends it to the
auditor and the auditor now requests the
world bank for a function f and gets
back a secret key corresponding to his
function f this function could be doing
some sanity checks and checking whether
everything in the bank's data was
correct and it learns the value f of X
right and since the auditor could be
malicious we want the guarantee that the
auditor should not learn anything at all
about the bank's private input apart
from the f of X so this is one practical
application of functional encryption but
is there any drawback in this so we
consider the scenario where the auditor
is malicious but what about the poor
honest auditor who really wants to do is
job correctly but due to some unforeseen
circumstances he is not able to what
does that mean let's say there is a
there is an honest bank that encrypts
its input X and sends it to the club and
the auditor after getting secret key for
the function f learns the value f of X
all right he is happy now there's
another bank clearly there are multiple
banks in the world so another bank comes
up and encrypts its input Y and sends it
to the club but this bank and the world
bank is some good summer collude maybe
they have some agreement and the bank
says I will give you some money if you
can hide my data okay and the poor
auditor who intends to learn f of y does
not learn FF i instead ends up learning
g of fibers of different function so how
could this happen maybe the value Y was
not correctly encrypted or maybe the
secret Keef of for F was not correctly
generated it may not really be a secret
key for F it could be some convoluted
function that says if the input is not
why output F of input but if the input
is why alone output G of input right
because the World Bank who we thought
was a trusted party is probably not
really trust
right so what is the issue here the
issue is in traditional notion of
functional encryption we assume that
there is a stress state party who
generates the master secret key and so
on but why do we really trust them right
so consider an others yeah here the
Justice Party is actually interesting
book but only why it's more prone to
thank yous motion uh I think it gets a
little more simpler if the tricep party
is India trusted but yeah I can get to
that so the as as my disappointed or the
more interesting scenarios where the
trusted part is not really trusted
because once you do have a trusted party
generating those systems you could
always ensure that using some additional
work that everyone encrypts the data
correctly or that they are really
encrypting something valid you could
compile it with some zero knowledge
proof so what's another drawback let's
say there is one bank and all the banks
were honest ok so the banks are not
doing anything malicious are maybe they
they want to do something malicious but
probably not again it just encrypts his
input X and sends it to the cloud sorry
the auditor but now the auditor who
wants to learn two functions F and G
gets back secure keys for F and G
supposedly but instead instead of
learning f of X and G of X he learns f
of X and G of X prime or X double prime
for some arbitrary different message
right all he has is just a ciphertext
and a function key and he does not know
the message inside the ciphertext so he
has no way of telling whether what he
did get was G of X or G of X prime for a
different message right so the poor
auditor is lost and he believes he is
doing his job correctly but apparently
not so what do we want out of this we
want we want to add the notion of
verifiability right this is not
something new it's been there in crypto
for a while we want to tell that
everyone is doing whatever they were
supposed to do correctly so how do we
formalize a little more let us say there
is some person who get some ciphertext
out of the blue from somewhere he wants
to run a publicly verifiable
algorithm that takes the ciphertext as
input and tells whether this is a valid
ciphertext or not it takes a ciphertext
and just it does not tell what the
message inside the ciphertext is but it
just tells you that the ciphertext was
honestly generated according to the
encryption algorithm okay so he's happy
now that he has a good valid ciphertext
the no one right a cheat him with now
let's say he gets a function secret key
supposedly for function f now he wants a
guarantee that the secret key was indeed
for the function f that he has in mind
he again runs a different public
verifiable algorithm that takes the
secret key and the function f as input
and again tells whether this is a valid
function on a valid function secret key
or not so now he is happy he has a valid
ciphertext a valid function secret key
and you can decode both of them to
recover FFX so just to put it in little
more formal terms verifiability states
that for all the master public keys
generated in the system for every valid
ciphertext what do I mean a valid that
there is a public algorithm that will
output given a ciphertext whether it's
valid or not inside every valid
ciphertext there exists a unique message
x that is encrypted such that for every
function f and every valid function
secret key again by valid I mean that
you can test its validity with a very
publicly verifiable algorithm if you
decrypt this valid cipher text with this
valid function secret key you will get
the output to be f of X where X was the
message hidden inside the cipher text in
particular if I decrypt CT with SKF ever
get us I would get f of X and if I
decrypt CT with skg I would only get G
of X I would not get G of X Prime this
is the guarantee we want yeah so here
will you well it's either case justice
you don't know what message and send you
just go through what message is an
ambitious
method except allen key corresponds
valid with respect to a particular
function uh not necessarily it's enough
to say that a valid key is valid with
respect to just being a valid function
secret so once you know that it's a
valid function secret key you could
always test whether it was the function
secret key for the function you had in
mind is a second since it's a public key
encryption sorry sent to the public
function election system I could encrypt
a dummy message myself and then just
decrypt my dummy cypher text with this
function secret key to see if I get back
f of that message their options it's
hard to find the decorating for like
that function no but I know for sure
that this is a valid function secret key
mmm but so if you know that it's the
third version see a few for some circuit
but in order to tell if it's exactly
this function you might have proven on
all inputs right so happy ok that's a
good point so maybe we can think of it
as the test validity for a function
secret key you need the function also as
input so the validity box would give
back a tick only if the secret key is
indeed a sacred secret key for that
particular function ok so I guess that
would address go ahead yeah so let me
briefly describe the results that we
obtain said if you remember the security
notion for message privacy it was what
we would call an indistinguishability
base security notion because he said the
adversity should not be able to
distinguish with the reason the left
world of the right word right so there
is another stronger notion of security
which I am NOT going to get you details
about which follows along similar
notions considered in crypto called
simulation security let me show that
simulation security in general for
verifiable Fe is impossible to achieve
and then we show that given any public
key message hiding functional encryption
scheme you can generally transform it to
a verifiable one with
not too much additional book this is the
main result that I am going to be
focusing on flesh to the talk in
addition we also give generic compilers
for the case of secret key functional
encryption that also have function
hiding along with message hiding and
also for the more general notion of
multi input function encryption we use
the same techniques to achieve
verifiable obfuscation i'm not sure if
i'll have enough time but i will try to
cover that briefly we're even in the sub
to just put in a couple of lines even in
the context of obfuscation if someone
gives you an obfuscated code you really
don't know what's in the code so you
want some guarantee that the correct
code was office cated so to address that
concern we put forward the notion of
verifiable obfuscation and give and
initiate the study of that area yeah
exactly so there is a lot of modeling
issues that arise so the way we try to
address that it was saying that the
office cated code would satisfy some
particular public predicate so you just
have a guarantee that your your office
carrier could satisfies a given
predicate but you don't know which
circuit it is essentially office gets
this is like a question and then we give
an application of verifiable fe outside
the context of functional encryption to
this new notion of functional
commitments so just to tabulate our
results so remember i told you that fe
is a generalization of a b ib predicate
encryption and so on so you take any
well-known scheme for predicate
encryption a B or IB you can easily
transform it to a verifiable one with
not too many additional assumptions in
particular the only assumption we need
in addition is the deal in Assumption
over by linear maps and note that most
constructions anyway already implicitly
required as assumption and we also have
another result that shows that look if
you do have a verifiable function
encryption scheme it implies having deal
in assumption so i am not going to get
details of that
so is this a trivial problem to solve
given any let's get back to the case
where we have a public key functional
encryption scheme with message hiding
and we just want to make it verifiable
is this a really a trivial problem to
solve so let us say we have set up
algorithm and here these are new
encryption algorithm for the verifiable
Fe case given any messages input encrypt
the message as you would encrypt using
the original public key Fe scheme so the
red cipher text corresponds to a cipher
text in the public efe scheme that we
wanted transform ok now you just compute
a proof that this was encrypted
correctly what proof is it in particular
let let let us use a zero knowledge
proof zero knowledge proof is just a
proof that tells that nothing at all
above the statement you're proving is
going to be revealed ok and now the
cipher text is just going to be that
here is the encrypted saw cipher text
with the old fe scheme and the proof
that it was encrypted correctly now
everything seems to work fine right but
unfortunately this wouldn't work because
in order to generate this so-called zero
knowledge proof you need something which
is the common reference string in your
setup right but who runs the setup the
setup is indeed run by the authority and
the whole point of verifiability was in
the case of the authority is not trusted
so if the authorities believed to be
trusted then he could generate the crs
but this is a circular problem right so
clearly just adding a zero knowledge
proof would not work but do it's trivial
fail at end it offers quite a lot of
insight into some into how we could
approach this problem notice that the
only thing that didn't work here was
that we needed something special in the
setup right as long as you didn't eat
anything in the setup if you could give
a proof that everything was done
correctly then you're done so let's
switch to a different kind of proof
system which we call witness
indistinguishability I will explain what
it is just for sake of completeness a
little more clearly but the crucial
point about witness and distinguish
proof systems either they do not need
anything in the setup yeah anyone can
publicly run it without having to
program the setup to have anything
special so what is of the witness
indistinguishable proof that we will
compute it will just say that a witness
indistinguishable proof in general just
says that when improving or given system
either of two witnesses could have could
have be in the way to prove that
statement okay but the proof does not
tell you which witness was used so let
me explain it in the context of our
scheme let's say we had the same public
efe scheme that we started out with let
us run it twice the red master public
key and master secret key are the first
run and the green ones are the second
run now whenever you want to encrypt a
message X you compute the red blob first
using the first master public key and
then the green globe using the next
master public key and give a proof that
says that either the red blob encrypt
sex correctly or the green blob encrypt
sex correctly okay this proof would not
tell you whether the red blob didn't
critics correctly or the Green Globe and
click the desk X correctly it just tells
you that one of them did encrypt it
correctly and not which one yeah so this
is the two exits are necessary insane
very soon oh it is the same it's the one
that is fed as input to the encryption I
thought but the statement will approve
it doesn't have excellent clear thing or
is it before they like soy Dora the
statement doesn't have X in the clear XS
part of the witness okay good make sense
yeah so there is this next such that I
don't accept your thread finger sex were
you dreaming
so the statement would just be that the
proof is valid and the witness for that
would be the X that was encrypted either
on the red blob or the green blob and
the associated randomness that was used
to enter it okay so now you just give a
proof that one of them was encrypted
correctly and let us do the same thing
in the case of the function key
generation we generate to function
secret keys one with respect to the red
master secret key and one with respect
to the green master secret key and just
prove that at least one of them was
encrypt was generated correctly as a
proper function is equal to ki so with
this work this is easily solve the
problem not really because let's say the
red encryption encryption was done
correctly with respect to the red blob
and function key generation was done
correctly with respect to the green blob
how would you decrypt such a system
first I haven't explained the decryption
algorithm given the red blob and the
green blob sorry for the ciphertext and
a red blob and green blur for the
function key you would decrypt the red
cipher text with the red function key to
generate some f of X Prime and you
decrypt the green ciphertext with the
green function key to generate some
other F of Y prime right and now you
have no idea which is what how would you
pick which one of these two to be your
actual output just see if both of them
are equal and then pick that to be your
output okay to just explain it a little
more clearly you have a red cipher text
and a red function key decrypt the two
together to obtain one output you have a
green ciphertext and green function key
decrypt the two together to obtain one
output and both of them do match then
output that as the final decrypted value
if that is the way we are going to
proceed then clearly this would lose a
verifiability right because if you
decrypt the red cipher text that was
encrypted correctly with a wrongly
generated function key you will not get
a valid function output and similarly
for the other case so what is this tell
us this tells us that verifiability
intuitively look needs a majority of
systems to be correct on either side
right
okay so maybe now let us use three
systems for the underlying Fe scheme a
red green and a blue one and repeat the
whole process what will the ciphertext
prove it would prove that two of them
did encrypt the same message correctly
and what with the keys prove if you
shall we prove it all three are keys for
the same function in which case we know
that at least a majority of the site the
red green and blue ciphertext would have
corresponding function keys that do
match right but then if you do if you do
go with it with this approach we cannot
argue message privacy because the minute
we prove that all three functions are
indeed bound under the same system we
cannot we cannot switch the message from
an encryption of X to an encryption of Y
right because in order to be able to
switch the encryption of X to an
encryption of why we need this challenge
ciphertext to come from the outside from
another challenger that the reduction
would not be able to generate it itself
but the reduction would have to generate
a proof that the third key was correct
so inherently message privacy is not
going to be easy to argue so instead can
we just show that two of them are
correct function secret keys why would
we need all three to be correct we just
have a majority correct that side and a
majority correct this side with this
work not really because how would a
decryption procedure will a decryption
would say that decrypt the red the two
red blobs d could the two green blob
stick with the two blue blobs and see if
a majority of them are correct what if
the encryption algorithm proved that the
red in the green ones were correct and
the decryption algorithm proved that the
green and the blue ones were correct
sorry the function key generation
algorithm now in your decrypt it's only
the green blocks that match right on
both ends the red and the blue ones do
not match and they're going to produce
faulty outputs so you will not get a
majority equal of equal correct outputs
so what is yeah
texting that something went wrong you
actually liked it the right answer sorry
so you can imagine I guess I think this
is weaker than what you're saying brainy
just you want that if somebody is done
some either you get the right answer or
you can tell somebody's reason yeah
exactly so with this approach as your
pointer you can either get that the
decryption algorithm is perfectly
correct dot plus f of X or you're happy
with the decryption algorithms is output
bought saying that someone screwed it up
but you don't know who but we want
something stronger we don't want anyone
to screw up you want everyone to be
correct and that is not solved by this
right so what is the main bottleneck in
this approach it looks like
verifiability and message privacy are
two contrasting things right
verifiability says I need a majority of
large systems a large majority of
systems to be correct so that when I
decrypt I get a good majority of systems
to be correct on both sides in the case
of the encryption and in the case of the
function keys but message privacy
intuitively says you need some amount of
free system so that you can switch them
from encryption of extra encryption of
why is it obviously you need a majority
for physically oh shut up driving seat
um side which is correct let's fill the
verifiability so if you look at it here
maybe right maybe right now it's not
obvious that for med 6 privacy need a
majority of free systems but let's say
we need at least a good fraction of free
system so that you can switch or at
least one free system to be able to
search so let's go ahead with that we
need at least one free system to be able
to switch three parallel systems didn't
seem to work would four work again it
seems difficult because even the notion
of majority in four is not ready to find
you go with two or do you go with three
so let's go ahead and start with five
systems okay I am NOT going to list out
the colors but you can see that there
are five different systems out here and
now in the encryption algorithm we prove
that at least four of them encrypt the
same message X or just two of them
encrypt the same message and all of them
are coming
in this public parameter C okay we
introduce a new parameters e in the
public parameters and just prove that
all of them are locked together there
the minute you generate the proof
somehow all of these have just been
locked together in this public parameter
it seems not really useful right now
okay but let's see how we can leverage
the fact that they somehow hidden in
this public parameter to generate a
function secret key you either prove
that four of them are keys for the same
function f or you prove that for our
keys for the same function f and if you
look at the public parameter that had
five small ciphertext inside it and you
decrypt now you open up what was inside
the public parameter it had five blobs
inside it you decrypt each blob with The
Associated function blob that you have
generated here this proves that the
decryption of each of those five blocks
is going to be the same okay so what is
it say it doesn't say that some of them
are going to be same or three of them
are going to be same it says this public
parameter that you are fixed if you open
up the ciphertext inside it everything
is going to d clip to the same value
okay yeah it looks like the the g cases
like the case in the right hand
side is like strictly stronger than the
first case exactly it is indeed strictly
stronger than the first case so i'll
explain later why we need the two cases
separately but yeah for now it's it does
seem like the first case is redundant so
let's assume the first case was not even
there it seems like a favorite could
always just print the first case if
either one of them is true the first one
movie trees right now it is that right
right that's good okay so right so a
malicious provo could always do that but
an honest provide want to use the second
case to get little more against
malicious very file
maybe we'll become little clearer when
we try thinking about how do we argue
security ok so let us ignore
verifiability for a minute and just
argue message privacy my claim is this
system already satisfies message privacy
and the way we would do that is let's
say we had to encrypt the message X and
we encrypt X in all the five blocks and
the goal is to now change every X in
those in the tuple of five to an
encryption of Y right we want to switch
from encryption of X to an encryption of
Y so initially let's say we prove that
four of them in cryptex correctly and we
prove that four of these are keys for
the same function f this is our starting
point now we switch to say that four of
these are keys for the function f and
this additional condition that if you
look at the public parameter all of them
adequate correctly so what would we
place in the public parameter we would
place the commitment to all the five
blobs that are generated in the
encryption algorithm ok you would now
switch the encryption algorithm to use
the trapdoor statement that says that
only two of them encrypt X correctly it
would be the first and the second system
alone ok and what with the function key
prove it will just proved that the first
four indices are keys for the same
function f so now look look at the fifth
index the fifth index need not encrypt X
correctly and need not generate a key
for F correctly p not v not you're going
to use the fact that we know how the
fifth index is encrypted or how the
fifth function was generated the fifth
function security right so in the fifth
index we can easily switch from an
encryption of X to an encryption of Y
right and now you would repeat the same
process we would prove that the four
keys are keys for the indices one two
three and five okay and we would switch
the fourth index to have an encryption
of Y and then again we would prove that
the keys are correct for the first
second fourth and fifth indices and
prove that the third index and
leave the third index to be free and
change the third index to be an
encryption of life okay so this way yeah
exactly so the reason why we need this
statement is because you're using the
fact that whenever we switch an
encryption from an encryption of X to an
encryption of life f of X is indeed
equal to F of Y so we need decrypt a
blob with either a blob that encrypted X
or encrypted why we're going to get the
same value and there is no contradiction
there arises so message privacy seems to
follow with some amount of work in this
idea right so so once we were achieved
this point we can switch the last two
indices to be the ones that are correct
and then change the encryption of X in
the first and second index to be an
encryption of life so this the
high-level AI di hope is clear you can
just believe me that this does not read
too much amount of work but clearly
verifiability is not maintained here
right it's look at the scenario where a
ciphertext was proved using the second
statement and a function key were
generated using the first tale now if
only two of the five blobs and trip are
encrypted correctly then you cannot hope
to achieve a majority of correct
decryptions right so what is the problem
here if the ciphertext was encrypted
according to a second statement and a
key was proved according to the second
statement then we have fine because the
public parameter says that the
decryptions would work out correctly but
it's only problem arises where the keys
are proved using the first statement so
the two tick marks that are shown these
are the only ones that pose a problem to
achieve verifiability so let's just add
another lock and say that these two
things cannot occur together so we would
had another parameter in the public
parameters call w and say that if you
wanted to prove the cipher texts
encrypted correctly using the second
statement then you would additionally
prove that w is a commitment to one and
here in the case of the function case
you would additionally prove that w is a
commitment to 0 now note that the
two together can never occur because if
a proof was valid and it proved that the
second witness was correct for the
encryption it necessarily proved that w
is a commitment to one and if it's valid
and prove that the first witness is
correct for the function keys it
necessarily prove that of this
commitment 20 and they cannot occur in
tandem right yeah are you going to talk
about why you need to appreciate it all
right did you use the new person um
right so right now we didn't use that in
the proof at all you could have
essentially had only the second case to
go ahead with the entire proof but
something they're not going to mention
why it's needed is the wave the next
goal is to actually can transform any
secret key function encryption scheme to
a verifiable one that also has function
hiding in that scenario note that I am
not sure how to bring out the intuition
for that but the first statement would
really be useful and in order to prove
function hiding along with verifiability
that the issues arise arising would be
the same as proving message privacy and
very phablet in the public key context
so the idea is to mirror whatever we did
in the public econ text in the secret
key context as well so in the public
econ text note that the free statement
in the cipher texts says that four of
them encrypt X now in the secret key
case you want to say that function is
hidden so in order to mirror that you
want to say that four of them are key is
for F so maybe intimately you can think
of just extending the system a little
more having few more witnesses to say
that the secret key system has message
privacy function privacy and
verifiability okay
yeah maybe /strong okay so let me
briefly tell you there are result for
verifiable obfuscation so what is
indistinguishability of Fisk a shin
let's say we have two machines that are
functionally equivalent then
indistinguishability office k shania
states that if you do office kate the
two programs separately then an
adversity cannot distinguish between
these two obfuscations as long as the
two office cated circuits were
functionally equivalent okay so given to
functionally equivalent circuits and
adversely should not know which of the
two was indeed office gated and given to
him but again the same issue of
verifiability arises here how do we know
that the correct circuit is indeed
office skated in most applications of
i/o you trust someone else to give you a
correct office cated circuit believing
that they indeed did office Kate a
correct circuit right so you want to not
really trust them entirely and you want
some guarantee that they indeed office
Kate at the correct circuit so this is
the notion of verifiable I you and let
us look at a trivial scheme and see
whether this would work let us say we
have an iOS keen to start out with and
we want to office Kate a machine em
let's office get it three times using
our original I of scheme and just
compute a proof that 20 to these three
office cade functionally equivalent
circuits in order to evaluate such an
obfuscation given an input X you just
verify the proof see if the proof
verifies that the obfuscation are valid
then evaluate each of the three office k
shins and output a majority of them if
the proof if the proof just told you
that two of them at least two of them
were equivalent then clearly when I
evaluate them at least two of them going
to give you the same output yeah this
office gates some circuit okay right so
this yeah just obfuscate sunset
according to the legal right so you need
to add some properties as to what you
really want to risk it but that's not
going to be too hard because your proof
could additionally just proved that the
each of these obfuscate its circuits
satisfy some predicate that is well
known publicly right and trivially
verification follows because if two of
the three of obfuscation were correct
then a majority of the evaluations was
work note that there is no problem as in
the case of fe here because the input
that you evaluate with is always correct
you are the evaluator there is no common
majority of system that have to be
correct just a majority of the stations
have to be valid right so verification
is somewhat free and security is not too
hard to achieve either so you start out
with encrypting sorry with office
skating m0m 0m0 and you want to go ahead
finally to a system that offers gates
and one so you switch the last
obfuscation to be an obfuscation of m1
then you switch to prove that the second
and the third ones of the skate
functionally equivalent circuits because
that's what we want to prove then you
switch the first system to office Kate
m1 then you prove that the first and the
third ones off the skate equivalent
circuits and you change the second
system to a biscuit n 1 so it seems that
security should easily follow yeah does
that weigh anything exactly so notice
that only issue that arises here is that
proving that go circuits are
functionally equivalent is not an NP the
only way I can prove that two circuits
are equal in recipe run it on all
possible inputs and show you that on
every input they give the same output
but that's clearly not an NP so this
approach would not directly work here
but it does work for a relaxation of i/o
where we guarantee that there is an NP
language that tests equality right so
this is the main idea and now what's
left is just some modeling issues about
what kind of circuits you can hope to
office gate and whether they give you
reasonable applications you get to
choose the circuit so to some extent
right sort of arbitrary circuit site so
you can choose circuits that can be
efficiently shown exactly right so in as
you pointed out in traditional
applications of iou obfuscate specific
circuits and it's not too hard to show
that those circuits have a small witness
of being equal do it with deal in the
first half is that all it's not yourself
to up in the Navy you need dealing from
there does not be at all related to
actual underlying functions right it
doesn't seem to be any deviation exactly
so if check if I go back to the table if
you do have an IB scheme or a predicate
encryption scheme that just arises from
this pitch logger let's say ddh then you
would need healing as an additional
assumption but if you have some ID
scheme that already requires deal in or
something worse then you don't need any
Oh in the first case you idiots I don't
know what else we have Perficient skills
but you know you based on like so Dylan
is just assuming you don't have any
better ways to debate the question so
can you a little bit about like what
kinds of functional encryption schemes
are there right uh maybe I can explain
it with the table
so there is an ib scheme that is that
first came out in 2003 there are a lot
of schemes for predicate encryption
attribute based encryption there is
functional encryption that just tests
whether inner products are equal since
there is functional encryption that
computes inner product there is
functional encryption for all circuits
that is functional encryption that just
takes to cipher texts input and computes
functions on two inputs then there is
the most general notion is this multi
input function encryption that can take
arbitrary ciphertext and computer
function on arbitrary number of them
what is so w/e just you or the player in
the last one oh sorry owh is one wave
functions oh the risk is something to
show your decision
yes okay so does that answer your
question well how like I mean there's
probably like huge efficiency
differences right so the more general
class of functions that you want the
less efficient it gets and it requires
more heavy how much larger crypto tools
but if you do want something very simple
like just testing inner product being
equal or just maybe even computing inner
products then you can do that quite
efficiently what's the deal and based
functional notion the heck the third
from the bottom is 1000 such tennis hi
ends currency early blue and gb w 12 is
high-tech we know then so gay so this
was the one where they also i think this
is the paper on reusable gobble circuits
and fe for bounded collusions so if they
just show that you can get fe for all
circuits as long as the number of
function keys that are the raspa the
adversary is bounded in the s the hammer
constraint if you brother back with just
like obfuscation some easier to get so
you're saying that I got proofs you
can't do the purse fell from heaven
string yes I for the aisle right oh yes
yes so if you have a comment your
instinct then you don't need to wait you
don't need the fact that you have a
short witness to prove you just office
cater circuit once and give a proof that
your obfuscation was correct</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>