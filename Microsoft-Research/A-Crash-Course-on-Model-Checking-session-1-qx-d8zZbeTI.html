<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>A Crash Course on Model Checking - session 1 | Coder Coacher - Coaching Coders</title><meta content="A Crash Course on Model Checking - session 1 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>A Crash Course on Model Checking - session 1</b></h2><h5 class="post__date">2016-07-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/qx-d8zZbeTI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year Microsoft Research hosts
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
yes okay so you know me my name is Shira
this is the crash course on water
checking
so the question you're going to talk
about today is the model taking question
is that as a model satisfy your property
and I'll hopefully I'll try to define
each term before I use them so I'll try
to say what M is
and what Phi is and what satisfy really
means to restrict my scope of
Investigation the kind of property that
I'm really I'd really be interested in
this temporary properties which means
things like if you open a five you
eventually close it if I do a request
and I eventually get a response back at
all times two processes don't get into
the critical section at the same time
things like that so what I really mean
is simple logic model checking
so I'll take each one of these questions
what is the M what is free will to
satisfy so what is them to me M is just
a state machine and so I'm going to zoom
finite set of states and my state
machine is going to have states and arcs
in addition it's going to have colors of
the states by that what I mean is I have
a bunch of atomic propositions that my
specifications can refer to they are of
the flavor x equals 5 or b was true
something like that but xvr
are variables in life in my system and
then an observation is a evaluation
through all these propositions so if
there's K propositions then there's
going to be 2 to the K colors and there
is no the colors are not really useful
if you like a paper present something
but in our talk is very useful because
if I label s 2 and s 2 the same color
what it really means is that for an
external observer those two states look
identical so my model is really a label
statement label tape machine and I'm
going to have a finite set of states and
some some of them I'm going to call
initial States and we just don't have
transition transition relation which is
a bunch of arcs I'm going to have a set
of atomic propositions
and then I'm gonna have a label that
mats each state to a color which is
their set of propositions to the truth
oh no no no this this is just a
description so this is something and
after the - this is - II's a set of
positive double - that's a comment so I
should have used that's a common
character okay all right so that's em
and what what is what is fine so I
already said that I'm going to talk
about temporal logics but there's no one
temporal logic and there's different
kinds of them and in fact there's a
cottage industry of temporal logics out
there there's people who make a living
out of inventing them and studying
properties over them and so we're going
to look at a few most common ones so for
each of them I'm going to talk about the
syntax which is like what formulas are
syntactical being correct in the project
and then I'm going to talk about the
semantics so for instance the simplest
temporal logic is the invariant logic in
which you have only propositional for me
which is that you have atomic
proposition these are all the formally
that that can be coded as invariance so
I can have negation I have conjunction I
have disjunction maybe I don't even need
over there it's probably gated you think
that and then the satisfaction really
means that M satisfies feve all the
reachable States of M satisfied fit by
reachable I mean if I started the
initial state whatever I could reach
with satisfy C and if this is the logic
then what is the model checking
procedure and so an obvious one I could
just started the initial states and
explore the states of M using that first
search a depth-first search at any state
if I wallet me in varium then I could
print an edit place which is actually
one of the nice things that Monica's do
you sure
this is basically every node will say
what what is it yeah you can't say that
here you can't say that a lot but you
can probably see that by adding more
state to your bottle yeah that's right
so so so so your median for not I'm not
very expressive but they're extremely
useful because you can always add
suppose you want to say that and yeah
it's true until B becomes eventually
true right what you could do is when it
becomes true you can just turn on a red
light in your model so you can add state
to your model and then make invariance
very powerful right the state machine
and then make a new instant part that's
right yeah but these are this is the
simplest temporal logic very good right
it is invariance a more complicated one
is CDL but it's not all that complicated
it's computation tree logic it's a
branching time logic so they're in
addition to these which is just boolean
you have pre temporal operators so this
is exist next it's pronounced exist next
this is exist until it's a binary
operator because it is two operands this
is exist globally so you should just
think of what this is a single operator
just two operands but I just hide it
like this right and what is the
semantics here
okay so this so this listing is called
batching time logical things called
linear time logics the reason why these
things are called writing time logic is
that this the semantics
one way to view these semantics is to
view them for trees of evolutions of how
the system can be bought right suppose I
am I'm in one place in the next state I
can have three possibilities maybe and
after that I can have from each one of
them I have a bunch of possibilities so
I could just sit here and look at my
future as a tree and then the logic is
interpreted over that tree
that's what branching time logics are
the other way to view on a system is to
think about linear evolutions of the
system and think about a system as a set
of linear evolutions and then have
logics forward those sets of linear
evolutions and those are linear time
logics what makes it a branching time
logic is this is the fact that you have
an X you have any addition to the
temporal operators you have a a a
quantifier in front of that as well
so I'll show you a linear time logic
which which would not have any of these
things that's what makes it so it what
makes the logic branching is is this
like this here okay so if when I when I
define satisfaction that will become a
little more clear so what is satisfy me
so these are these are easy to say and
so what I'm going to say is the one
thing I would say is CTL is a state
logic in addition to a branching time
logic it's a state logic which means
that each formula of the logic is either
true or false in every state if I could
talk about a state satisfying your
formula or not satisfying your for you
and I'm going to buy semantics I'm going
to inductively define what it means for
a state to satisfy your formula like
atomic propositions conjunctions these
junctions are very easy to define right
atomic propositions if a formula is
satisfied if it's true interstate
connection distension
obvious negations obviously okay so
that's good actually I'm glad you asking
these questions because my notation so
this camera is what maps each state to
the copies right okay so yeah if you
have such questions asked that's good
okay so the tip so this listen I think
is really in these three so state
satisfies exists next Phi so s satisfied
exists next Phi if there exists some
next day which satisfies Phi this is
Atlantic's for that right if state
satisfies so then this bedside
satisfying take this next one then I
state satisfies exist fine X i if there
is a there's a path from the state and
he's starting s there is a path here
such that Phi is true everywhere and
then eventually sided Ostra right and
then X is Goble Phi is true if there
exist an infinite path image files to
everywhere so that's the semantics
yeah yeah that's fine as well if I see
that four point is capitalized maybe I
didn't want it but yeah no no no so you
could see this could be true and still
fire until fine
could be false for that to be true sign
has to be true here as well
so these are
five words
yeah so that's what this means so from
now on five holes there exists a pad in
which five holes until sign holds
support this means in English this means
that exist a path in which globally five
holes
this means that exists a nexus state
verify holes right okay so till then
mine
what I want to do is I want to call it a
marching algorithm for CEDIA I don't
have flights for it because the
algorithm is not very complicated
yes so how would you come up with a
model checking algorithm for for Cpl so
I suppose they give you a model and a
formula how do we check whether modern
size pocket I mean for invariance let
the position proceed is very simplified
I just have to teach ability it turns
out that all you have to do is then
since CDL is a state logic you can label
each state with the sub for meaning that
are true in that state and if you do it
in the right order then you can come up
with a very impatient a little bit more
logic CDL right so put in for that by
what I mean by that is well it what do
you mean the sub for me
suppose I give you a formula that looks
like this
right the subfamily of this formula of
this formula are all these
is excused and if I call this phone
that's a fine is the formula Phi itself
these are all the sub formula of this
formula right then what I do is sort of
order them in such a way that the sub
formula of this formula comes before
that formula was it back
so what I've done it this is exist
Blondel blah so think about this as five
and this is fine right so this is that's
why this is a CTL formula right and this
formula is still kind of this video for
you right which is take this GP yeah if
you feel like these questions right so
by cell formula what I mean is in any in
every formula I just write the component
as well and then there's some formula as
well right so for this formula these are
all the subcomittee I get right and I
can sort of all of the formula in such a
way that before a formula shows that
when when ordering all the sub formally
of that formula show up in the audience
this is this bottom one there's no this
at all that's okay I mean I could just
transpose there's there's a bunch of
orderings that might be good for me yeah
so there's the topological order and
after the any linearization of it is
okay right then what I could do is I
could tell you how I could label each
state with a formula assuming I have
labeled states with the formally that
that happen before then right for
labeling atomic propositions and
connection the strength of the easy so
I'm not gonna worry about them the other
ones are also not all that easy not not
all that hard right how am I going to
label state with exist next fee all I'm
going to do is I'm going to check states
that have the label C in them and I'm
going to just look back at that and
every state I'm just going to label exc
right so that takes care of that
all right how do I take care of exist
fine on inside that fun once again
yes
so so how do you do this tradition I
suppose they've already labeled Phi
inside then how do you
who by
that's that's that's that's that's
pretty good right but it's more
efficient to do it backwards because we
do it forward then you have several
steps to do so what you do is you start
with the ones that have SCI and then
label them with exist financial side
right and then you could find go back
and as long as you are satisfying fine
you could continue to label them and
keep on doing here right right then how
do you do this exist globally fine so
what you could do so yeah these are
things to do is to find the strongly
connected components because many are
the for cycle so what you do is you this
restrict your graph to the nodes that
satisfy fine so take your model like a
take your model and restrict it to the
things that satisfy fine so you have a
you have a different model now just like
a sub model of that one right and then
you find the strongly connected
components in the mall right and then
all these phone connected components
have some cycle that satisfy pass so
just by definition all of them are gonna
satisfy fine but I'm not done yet
right I still have to go back from this
one credit components as long as why you
satisfied and those satisfy eg Phi as
well
three-five that fact that's all it is
so this algorithm is a really famous
it's called the CES algorithm and it
probably has like a thousand citations
so you wonder why you did not come up
with it well okay I'm sure that
hindsight is useful yeah it stands for
computation tree logic yeah so the CES
algorithm is this for is by Park Emerson
and syslog and they actually it's a
little more complicated than this
because it's the same thing called
fairness and the TV lab see is how the
other words that as well but I'm not
going to get into that
so much
they wonder if our markets efficient
okay I'll answer that do you only ask
that first you know one second so yeah
so the deal is if you don't do it
backwards and what do you do what you
could do is the forward algorithm could
do something like this if Phi is true
currently and in the next state exists
Phi n plus Phi is true then in my state
ad Phi X is Phi into Phi as well that
will be the forward algorithm right so
each iteration of the algorithm takes
sign that's proportional to the size of
the graph and the number of iterations
you have to do is again proportional to
size with that it's become Solomon
square so we at that would essentially
code
that's actually a nested nested search
this actually does it in a single search
but well it's not search at all because
you're just it's much more likely the
lead
that is a backward propagation that's
what it is
yes the complexity is the size of model
trying to slide to the formula
I haven't said what it means for a model
to satisfy the formula actually I'm
gonna make it what it is actually is if
all the initial states were modern
satisfy your fungal antenna model
senator in father that's what you mean
when you say a model satisfy the foxy be
a part of the elevation or we know
okay you could always yeah yeah so for
conducting disjunction you still have it
even have to you need to do a
disjunction conjunction in the usually
but that doesn't involve any temporal
operators are if Phi and I are both
satisfied then you say PI inside
when you're dealing with any formula if
you label this up for me then you don't
worry about how the subcomittee got
evaluated so there you go basically sets
it off the only place where in the CPS
edge is doing 85 the realistic the
strongly connected components it was a
sci-fi Tom
Oh
I heard the problem with that
here you're going to label certain
states with facts you probably don't
even care about yes so in
in data well there's a simple magic
sense which is if you have a query at
some node I want to know the formula
then you sort of push the knowledge
about what you know that formula down to
the query and then when you do your
bottom-up evaluations have this nice
property that you only
arrived a useful fact I gotta label
something that's useless yeah so for
instance so to accentuate that I could
have a two or and a clumsy formula here
and they evaluate that formula then I
have to label everything anyway so so
there's actually another cottage
industry and how do you do this
efficiently and there's like a bunch of
papers lots of them and the things that
you described there's approach is
similar to that using like there's all
the people talk about like forward it is
backward there's techniques that can do
forward CTL more efficiently then the
more obvious ones as well yes actually
this is there's a multiplication on the
stuff so I can't I don't know anything
concrete that I could just say how long
the lines that he said alright so I'm
going to now describe a linear time
logic so in synthetically it looks large
simpler than the other one actually
before I do that I need I need to also
say a few more things about about
branching Roddick's see all these
quantifiers that I have our existence
here right but but you also have
Universal quantifiers you can make if
you apply negations right so for
instance there's a few abbreviations
that people usually use
this is usually written as this means
finally three holes
given there exists a way in which we can
finally hold
that's just abbreviation for that and
then this is nothing but always because
it's like an invariant and so that's why
invariants are a proper subset of CDL
not there exists it not be right and
then you could also write for all FB
which is not there exists gee nothing
this is always a among all pads people
eventually hold that's what is it it so
you could try things like that and you
can also write this this means among all
pads P will hold until Q holes I'll
leave it as a homework exercise a little
bit tricky to write this s in terms of
the other ones so in the similar way
right using that try writing this so you
sort of understand what it takes to do
these things so what is the LTL an LTL
the reason why linear time is that you
talk about only executions so you
different LTL semantics on linear
execution so all your models are gonna
be straight lines you can be state state
states there's no you know branching
since there's going to be no branching I
don't have to worry about that exist
something or always something so the
path quantifier is doing this in so in
some sense LT is a much simpler logic
syntactically and but semantically it's
much more complicated than CTL right
which is why I did cereal best right so
this means fee is true this just means Y
is true for a while and then cycle
that's pretty much all the temporal
stuff that is actually I also need the
next I haven't written that so you also
need next fee which means in the path
see holes in the second stick that's
that's all that XP means so this is the
syntax of LDL and it turns out that it
holds one in the until the semantics is
five holes for a while and then sy holds
eventually you can you can have the
always using the negation right you can
negate such things and get eventually
always yeah so I'm not going to go to
the model checking algorithm for LDL the
one thing I will say that it is pspace
hard so the only known algorithm is
linear in the size of the model and it's
exponential in size of the formula right
so but I'm not going to go through it
no no no so one thing I did not say is
that a model satisfies an LTL formula if
all pads from the initial state satisfy
the LTL formula right so I will define
the LTO semantics only for a path yet
right now I would also say when does the
model satisfying LTL formula so I have
to say M satisfies an LTL formula fee if
for all pads fine
right in M Phi satisfies
you could say that right but but it'll
be a loose statement to make I think the
hard thing is that you cannot do divide
and conquer in reality a very easily and
you can sort of label states with their
sub formula because you can't have so
it's very hard to start start labeling
states so that mean if you write have
arbitrarily complicated LTL formula
there's no way to just divide and
conquer if there's a way then it won't
be pistes hard so that's what it is
oh sorry from initial state why is that
distinction and monitor what is the
significance of that and conceptually
what does it tell me that a model
satisfy satisfy okay so what it really
means is that it's say for simplicity
let's say there's only one H Pawnee
nation state I think that it elicits at
the point very clearly so what do you
say when a model satisfies a CTL formula
is that you start the initial state and
sort of unwind the model that you get a
tree right if your model is like this
your model can have like cycles and
everything right but if you sort of
unwind it maybe you will you will
replicate states multiple times and
you'll have a huge tree before you and
the city of semantics is step on the
tree right that's that's what the CTL
semantics is on it's on the tree right
that's why it's a branching logic the
linear logic is you have a lot of paths
passing through and every path must
satisfy the formula
no no no you're not right but if the
initial state that is like the formula
then the modulus is a the formula I'm
just giving you a definition
don't know always it interesting you
might want to say see you might want to
say ah that's because see I'll give you
a formula right maybe the initial state
has some property then that p is true by
and then then eventually P becomes true
an initial state but maybe there is some
other state here in which P doesn't
become true and that state does not
satisfy FP right but when you're fine
with the system you're talking about the
system satisfying P because when you
state probably to the system is if
you're talking about probably the system
starting from where the system starts
right that's how you define it but it's
there's nothing deep yeah but you can
state them as well right for instance
you could say them so you could be for
if you want all states a satisfy a
property people just write always
globally than the property five hooks so
you could say that as well I should just
note that the distinction within LDL and
CDL is quite subtle is that
inexperienced people to make lots of
mistakes yeah
so neither one of them is more
expressive than the other
I could write CTL formula that cannot be
written in equivalence to have an LDL
and Weis yourself
yeah so the one that you said is a city
of fun with it does not have an
equivalent in el dia and you could also
have al
so you can have the elevator so from
expressing this point of view they are
not compatible so just to give you an
idea that there are lot more this
cottage industry is huge and this can
throw one other one but I'm not going to
just go into this in great detail they
something call the modem you calculate
where the these are sort of similar to
what you have seen already but then you
can have this functional and if you talk
about what there is in these fixed
points and there's a notion of
satisfaction which I'm not even going to
get into but the interesting thing about
this is that the complexity of model
checking this logic is not even known
it's the model chicken problem is known
to be NP it's also going to be in coined
in Knights it's not to be an NP it's
also not to be in coin thing and that's
all that is known about this logic so
you could write really simple things
like an s-line for which for which model
signaler algorithms could be could be
pretty complicated yeah so the other
thing you could do is actually the
designers actually hit these logics
because they just first thought if they
are in greek and they're hard to
understand so so you can also write
specifications that also sort of look
like your models you can if you like
your specifications as state machines as
well so then the model chicken problem
probably comes like the refinement
chicken problem right so if that what
you do is your specification is also a
state machine and it's it also has the
same set of colors that your
implementation has it has different set
of states but the commonality between
these two is in the colors right and
then you say that an implementation
satisfies the specification if every
behavior is an implementation is an
allowable behavior the specification and
use the less than sign to reload
okay so I do not know what happened
so everything
so I'll stated more precisely in the
next couple of slides I'll stay the most
decisive that's the intuition yeah this
Pacific Union this allows yeah it
doesn't have to do with the
specification could be like
non-deterministic it could allow a lot
of behaviors I can make an example of
that would be the specification could be
an instruction set architecture and the
implementation could be a pipeline
implementation it could be an
instruction set architecture that allows
an arbitrary amount of delay between the
time of instruction comes and it gets
executed and every pipeline that
implements its all this makes their own
performance decision to implement that
but the semantics has to be maintained
so formally what it means is I have I
have these models and I have runs which
are just funny from the initial state I
have I have pads and then I have traces
which I just I just forget the state
over the colors then what I really mean
by by refinement is this trace and
solution right so every trace around
this should be a place of it and this
language containment so you could do
anything on table theory
yes and with the bottle so usually I
used to use Phi but now since this is a
state machine and this is friendly to
designers I started using English
letters for that
I am please go read read read and then
so I'm assuming that the colors are sort
of common to go but the states are not
come I did not understand any question
oh yeah yes yes so you have to define
the notion of colors appropriately for
some version of colors it will work out
yeah okay so that's the only reason why
you use colors it's because you'd only
compare two things the different levels
of abstraction you have to have some
common language compare them right and
in a presentation it makes sense to call
them colors yeah okay so it's that even
though even though look it even though
even though this is sort of like a very
simple way to specify things you don't
need logic to do that
there's intricate connections between
refinement and logics right so these two
statements are equivalent if M refines s
that is equivalent to saying that every
linear temporal logic property that is
true in s is also to an M if you can
prove that these two are equivalent
statements right so even though you
don't want logic logic is like grain the
seams it's there right and then the
complexity of this is is exponential in
a stiffness complementation and the next
week I talk about some work
yes yes so similarly you can also have a
notion of branching the Fineman right
that's actually called simulation I'm
not going to talk about it and then
there's a corresponding analog with
respect to branching ethics so there's
an interconnection between refinement
depending on what knowledge notion you
use and Roddick's right but again I'm
not gonna worry about that so this story
so far is that you can have models and
you can have all these logics and you
can have model checking procedures for
them and some of them are polynomial and
some one of exponential and but but the
real problem for a practitioner is not
it's not the fact that that all these
logics exist him and they have Mahone
shaking procedures but but the fact is
that the model itself is something that
we cannot comprehend or build on
anything because models are pretty huge
so for any tool builder they'll follow
is that for theoretician am sort of
exists but for anybody who's a to them
is the real power because you can't even
sort of bill them right same is
exponential in the description of M for
instance if you are talking about
circuits then you're going to be given a
succinct representation of the model
namely the circuit and then you have to
reason about the states play that
circuit similarly if the concurrent
program you're going to be given the
program text and then that's the model
and then and this model is exponential
with that model
anomalous days yeah right so the
majority of this part is going to be in
fighting this explosion so that's why I
mean the model checking at the logics
actually I'm just going to go down as an
interaction so in fact what I'm going to
do in the English how much time I have
is this talk about ways by which I can
contain the explosion in here from its
succinct description I'm going to talk
about methods that are more automatic
first and and I'm going to talk about BD
DS just symbolic method then I'm gonna
talk word a particular method called
partial R is reduction and if I have
time I will talk the symmetrical action
today but maybe not today and then next
week I'm going to talk about divide and
conquer which are these approaches are
less automatic and this is a tool that I
worked on for my thesis but maybe a lot
some chance to talk about that and then
I would abstraction intervention
so today I'm going to talk about more
automatic techniques so all of them
actually requires some tweaking but it
is the degree that is that is different
and when I am considering these I'm
going to consider only the simplest
logic it is invariance right so you
could you could write a lot of papers
for each of these methods for each of
those logics but to focus on the
explosion I'm just going to consider the
simplest logic right
this is invariance and next time I'll
probably talk about abstractions Nazeem
guarantee and if anyone shows up the
last time I'll talk about applications
to software and how about some of these
techniques have been used in software
hope what has been done so far there's
been some work in using for
specifications and believe it or not
somewhat some work that has been used
for it for checking it on actual C code
there's a reason why I put it in the
last class so that people show up yeah
expand
no no you should probably give it give
it to me yeah so you have two weeks so I
can digest it on potential as well yeah
okay so I'm not familiar with it so so
today I'm going to talk about the more
automatic ones and the first one is
symbolic methods so what are symbolic
methods then this Bryan came up with
this thing called binary decision
diagrams 10-15 years ago and this he
didn't come up with it with it with
model checking in mind I mean he wanted
to just implement represent boolean
functions efficiently right so I'm going
to talk about what B duties are and then
I will talk about how they are used in
water checking so if I just want to
implement the boolean represent a
boolean function ax r bx r c XR d right
i could represent it as a decision tree
so but if i for most functions there is
a lot of commonality and redundancy in
this decision tree for instance in this
right this and that are started by some
watering and so are this and there and
it's a lot of redundancy so what you
could do is equal to two things if two
nodes are isomorphic you can submerge
them and the second thing you could do
is if I have
if I have an old P if I have a note a
for which both the zero child in the one
child point to the same node then I
could just yank that no no and then
connect everybody who's connected to a
down there because there's no decision
point that is made there so if I do
those two reductions repeatedly until I
can't do any more reduction then I get a
B D D for instance if I if I start with
this and I do this you will get this and
the nice thing about this is only once
you give an order they are canonical so
there's only one such dag that you can
study can come up with once you fix the
order a B C and B right so it doesn't
matter the order in which you you do
those two productions you'll always come
up with it and there for for a lot of
common functions they are very compact
and this example sort of gives you an
intuition as to why they are compact
suppose and let me just define something
called a cofactor so a cofactor is
something which you take a function and
you hardwire some values into it like
for instance if I take the cofactors of
this function with respect to a and B
write this for cofactors I can have F 0
0 F 1 1 F 0 1 and F 1 0 right which
means that if I if I choose the values
for a and B I can choose them in four
ways so I get four different functions
but usually there are not that many
functions right so here right these two
functions are sort of the same and these
two functions are the same right so here
right if I choose 0 0 or 1 1 0 1 or 1 0
the information I have already chosen
doesn't actually distinguish me in
several ways for several practical
functions of the case so even though
there are if I'm depth K I have 2 to the
K distinct 2 to the K different
cofactors there's only a small number of
distinct cofactors and what beauties do
is that at each level they represent
only the distinct cofactors of a
function right and and there's another
reason why they are canonical because
cofactors are independent of the
implementation of the function they are
they say something about the semantics
of function
you don't have to first start the dance
yeah yeah so you don't have this oh
that's right so what do you do actually
is what you can do is that if you have a
circuit right from the circuit you can
actually come up with the BDD from the
structural circuit itself I'm going to
show you how to do that okay so this
yeah you're right so if you build a pool
table and then make this it doesn't make
sense
sure so there are techniques to just
will come up with this automatic so the
one thing I'm going to say is the
variable order straw is affected the
size of the BDD so you can write
functions for which you can just change
the variable order and for one variable
order you have an exponential BDD and
for another variable or you have a small
PDB right so when you say these are
automatic and they are automatic if you
have good order and then finding a good
order is still in the complain and so
really good uses of being a pivot the
very clouded themselves so but the
economical for a given given order and
the question that money was asking was
if I have a circuit right I can start
from the leaves and I can sort of build
a BDD for this for the for the circuit
from from from the leaves all the way to
the root so for instance if I have F and
G that are inputs to a circuit and if I
had to be released for F and G I can do
the BB for F and G F by by this adding
the BDD and those boolean operations are
very efficient 70 Dewey's right and so
that's why actually the first
application for bilities will actually
combinational equivalence right in the
hardware companies have get little
moorings of circuits and then they
switch level models right and they are
sort of there is no state encoding the
staining between those so what people do
is that they extract so these are just
two different ways to implement the same
function so they to check whether they
don't have any bugs in them what to do
they do till the BVDs for both of them
and simply a canonical
the circuits look different but
abilities have to be the same right and
since the economical pathologies very
equal in check right because there's
only one fat halogen which is this right
so any any circuit that is the tautology
look like this which will the BDD
correct
yeah that's the one you predicted me so
that so if you want to combinational
equalent actually that's what beauty is
just screen and but if I know the model
chicken you need another operation that
bites you pretty bad and that's
quantification so what is qualification
so if I have a function f the exist
tential quantification of a particular
variable V is defined as that so the
definition is you hardwire we to zero
and then you can have the function
that's independent of we right then your
hardware I read one you get another
function and then it just all the two
functions but still again independent of
week so and you could you could you
could have this you could have
quantified multiple variables exist BC
and it turns out that the order in which
you quantify them is not important you
could prove that you could if you prove
that
take this DC is the same as exist CT
right for instance so what we do you
think about quantification is if you
write it as a boolean expression and if
you want to quantify B and C just erase
them for the board and you will get the
quantification right so the existence of
quantification of B and C with respect
to this function is one in which you
just erase the B and C and you'll get
there right but something that's so
simple D on the board is whiskey's
exponential to be DS right so if you
quantify n variables right it can just
explode but it's heuristic efficient you
could you could do it for a lot of
things it works well so so so far I just
talked about beauties now I'm going to
go back to to model checking in
particular I'm going to go back to only
invariant checking right just that's
what I'm going to talk about so to do
that I need to represent two things as
nearly DS the first thing I do is I have
to start representing sets as DVDs right
so just so let me just assume that my
model has boolean variables if it has
non boolean variables I can encoded as
boolean variables and so my any set of
states I want to represent is going to
be a subset of 0 1 to the N right so the
idea is that I can represent any set set
by its characteristic function which is
the boolean function right so for
instance if I have this set of four
states
or the Des Moines or the variables X Y Z
I can represent it by its characteristic
functions X plus y plus Z and the
characteristic function I could
represent it as a DDD right so that's
that's the basic idea so the idea is
represent character characteristic
functions and DVDs now I could do set
operations as BDD operations I have no
idea what these boxes are doing here
predating that they are not there in my
okay so so if I want to do union of P
and Q I could get a characteristic
function of the Union by just adding the
BDD and similarly intersections and a
negation right so I can manually except
with BDD that's not a problem the other
thing at all
Oh so this act I haven't put them as
well it is the universal set yeah
so
I can also represent transition
relations as babies because transition
relation is all the steps right so I can
think about each arc in my state machine
as a pair right the set of all arts is a
set of all pairs of things right now
this is also a set I could represent the
reasoning abilities but then if you go
to the same problem and I can't draw the
state machine and then represent the
arcs when I could I should come up with
his are from the succinct representation
and you could do that for circuits
pretty easily for instance suppose this
is your circuit right so this is much
more succinct than a state machine right
and you could build all for it directly
all you have to say is that the next
value of V naught prime is the negation
of V naught right and the next value of
V 1 which is v1 prime is the exclusive R
of the previous values of v1 and Amina
and every transition that you do has to
exactly satisfy this right so now you
can do two things you can represent
States sets as be release you can
represent transition relations with DVDs
and once you do both of them you can use
the existential quantification to do the
search symbolically
that's why the existence of
quantification comes up I'll show them
in the next slide so this is terrible ah
I realize I'd chosen a really bad color
how can I do something again
I can just use blackboard that's right
so what I've written there is suppose I
have I have P which is a set right and I
want to find the set of all states that
P can reach in one step that's going to
be the basic operation that I need in
doing in doing this kind of search the
way I could do it is the image of P
which is our image of P is the set of
all we such that there exists serve all
v prime such that there exists some way
in P such that R of V D Prime
nothing like Fe right and I could write
that as exists we the characteristic
function of V and the characteristic
function of bar V D prime you can
imagine that and to encode this you need
the existential qualification and so I
have written as well and you could also
go back we're using the same technique
but the deal is once you have this image
operation then you could actually start
from the set of initial States and then
keep exploring like in a brig flow
search without actually representing
those states and by representing all
those sets of states as binary decision
diagrams right so if you want to if you
want to check whether what whether an
invariant we is violated what you could
do is you could start with the negation
of the invariant and that's also again a
DVD right and you could have the
invariant sitting here somewhere
negation be invariant and you could just
keep expanding and once you want to hit
the invariant you could there are ways
by which you can fish out an error trace
out of it or to the PD D so you start
with this and then you keep just compute
the image and then you Union that and
then you compute the Imagineering is
that that's what you do right so so far
so good
so be deities are a big breakthrough in
Hardware the guy who wrote the the BDD
based model yeah you could write
otherwise you you prove P space equals
three so tightly the intuition for what
kinds of things works well with BDD
so things like then Macmillan did this
in like 92 this is one the ACM thesis
award and and since then actually it is
become quite famous in every hardware
company has a BDD based model checker
and and large formal education things
are based on them but actually you can't
believe that Sigma fighting all these
formally like an University of sitting
and just as engineers who don't have
PhDs pushing models occur so that is
quite a sight if you go there yeah so so
the one thing that lead is do is that
they compact with represent transition
relations you can prove that the
transition relations for circuits for
most of them are actually compact
because what you what tends to happen is
that if the circuit has bounded
communication complexity you can use the
structure of the circuit to come up with
a variable ordering right and you can
sort of prove that the bilities for the
transition relations are compact but
what tends to be really hard is the
images and reachable sets there is
basically no mathematics to help you and
they tend to blow up every once in a
while and they tend to blow up so much
that this PhD thesis written on how they
computer make this without them blowing
up yeah
yeah
that all these places that are hiring
all these hundreds of people
aren't getting
that it really
so I can talk a little bit about that so
so what actually happens is so actually
so I can give a short answer to the
question and a long answer later
actually so what happens is that is that
is that in bidi these four units right
so that may be the answer to that is the
next slide so people have just done so
much hacks so much hacks on this and the
bottom line is that if you have 100
variables in your system then be
released tend to work with someone who
doesn't have a PhD
right so if you have 500 variables then
you need someone who has done it this is
an image computation to actually drive
them it's sort of dual and there's been
so many variations of these from like ad
DS 2 ZD DS when people just build a
different kind of BDD for arithmetic
circuits one for multipliers one for
floating-point units and you name it
there's there's there's something else
for there so what happens is that for
for particular for the particular
hardware security verify you need a
bunch of tricks that are native to that
domain to try the beauties to go well
and if you can do that then the build is
verified units very well right they
verify control logic very well
so what beauties can do is that if you
take like the description of the powerpc
and then ask you my my bus deadlock then
the diesel definitely going to blow so
what you need to make be really scale is
that you need some user intervention on
top of DVDs for instance from my thesis
I was doing compositional verifications
is actually dividing approvement parts
and dividing requires a lot of user
intelligence and if you have something
like that then you can verify much
larger circuits so in our group we did
verify a really large signal processor
but it took us like two and a half
months to verify it even have to
building the tool so so the answer the
question is I think units people as
people are able to verify if you take a
particular unit and as long as it as
about hundred variables people are able
to verified it and that's still
enormously useful because there's lots
of components with high potentiality in
them which are pretty small and for the
abilities one Paraiba
but I think what the companies are
finding out is that is that you cannot
easily make global statements about your
chip and and to get from the unit lead
to they to do something about the system
level is something that they are not
able to do and I think the people who
solve Allah talking to them first like
so that it will be able to verifying
their chips and then the management is
getting sort of dissatisfied of these
people because now they can't prove that
the Pentium in right I think and prove
only the floating-point unit a friend
diem is right and then that's sort of
the situation yeah so it's on now going
to talk about another method just ah
it's partial
so actually I personally think that
buildings are not the right way to go
for software because I think babies are
just like a bit level and even if you
take a small program and start encoding
your integer variables or some finite
domain you just run out of things pretty
quickly so so my babies really work for
hardware because because the circuit
flow sort of gives a natural ordering to
the variables and you can have to some
results that at least some of the
abilities are small and that's the
reason why they succeed it there
I didn't even for small software
programs babies I go to blow so so this
is actually not parallel with Porsche
and Porsche all the methods this is
actually a different domain so what
actually happen in model checking is
that is that it's a pspace hard problem
right but then each domain people sort
of came up with with tricks that solve
their particular problem and then when
two or three designs are the same kind
have the same kind of tricks then they
saw them sort of unified into one kind
of technique so so I'm presenting the
more general ones and you could always
find in almost case studies where I have
this particular bus controller for this
particular processor and I had to do
step this representation the model check
it so so first our methods are useful
for for for protocols actually where
your basic model is actually an
asynchronous composition of processes
and here the idea is that you don't
explore you don't do anything symbolic
you still explore States one after the
other but you don't explore all the
states they explore only a portion of
the state space but still you can make
statements about the entire state space
but you can prove properties about in a
state space but how are you going to do
that you're going to use the structure
of your program to do that right so the
process object model is what portion
order people usually use and then you
have a bunch of processes and a bunch of
objects and each process it runs the
program it has a program content and
objects are shared between the processes
I think about objects are just either
variables a shared memory or queues or
whatever right so this could be this
could be an example of a of a of a
process object system so you have two
processes and you have two shared
objects x and y but they not really
shared because only each one is using
its own they both of them are not being
used by both of them so the first
process just checks for the X is less
than 10 and then it increments it and
similarly that
so what I want to say is that situations
like this can be always model in terms
of guarded commands right where you have
what do you have is that you have a
bunch of variables and here a bunch of
goddard commands each of them have a
guard and then some arbitrary code that
change is something right and so this is
how I've encoded the previous problem
into this right so when I do discussions
I'm going to just use the guarded
command model to describe these things
so the semantics is that you have a
bunch of variables and then at each step
one guard so this is the initial step
and then one guard is chosen which is
enabled and then it is executed and then
another guard is chosen maybe the same
one and then executed the global system
is still a label state machine and you
could still think about the system as as
it's a safe transition glass but will be
much bigger and the process object model
is a succinct description just as
circuits are a succinct description of
state spaces so it is convenient we'll
talk about actions when you talk about
partial other reductions so what are
actions actions are just labels given to
to God the guarded commands so so the
one thing is that the non determinism in
the model arises because any of the
enable actions could be scheduled at any
point in time right actually I started
at five minutes after the hour so can I
take five minutes after the hour or
people completely bored then I need to
stop so can I have a word yeah okay so
so the non-determinism of the modern
arises because at any point any of the
enabled actions could be scheduled next
but once you decide which action to
schedule the next trade is deterministic
right so because on the right hand side
there is no non determinism of actions
you can also label state machine
transitions with actions action name
that's quite useful so for the previous
small example that I showed you this is
how the state space is going to look
like I'm going to start at 0 0 and the
alphas are going to increment the XS and
the betas are going to increment device
2 actions are independent if this is
actually a central motion in partial
order reduction yes if I mean if two
conditions are satisfied neither one
enables a disables the other and if both
are enabled then they commute so if I
cannot have alpha enabled in a state and
then beta not enabled and then if actor
executes alpha the execution of alpha
cannot make beta enabled and vice versa
and if beta is enabled execution of
alpha cannot disable beta and if both of
them are enabled then executing them in
either order doesn't matter I always get
the same state so that's that's what's
meant by independent of actions so so
since I wrote this example to illustrate
that so alpha and beta are independent
here right because you have the Diamonds
everywhere
is it 11 so that's actually basically
basically the key that's what's going to
help you through the state reduction but
you could have dependence between
actions as well I mean I could start and
explore a bomb when X is 3 and Y is 3
right and then what happens is so what
happens is that at 3 3 then I could
execute gamma and then explode the bomb
but then gamma know becomes dependent on
both alpha and beta all right so you
could have the typical situation is
you're going to have some actions that
are dependent on each other and some
actions that are independent of each
other so the key idea in partial order
method is that if you have a mutually
instead of mutually independent actions
this instead of mutually independent
actions then the order in which you
executive in a particular state is not
usually irrelevant and you need to
expose only one but there are some
caveats and before I get to the carriers
let me just formally define what partial
reduction is so two action sequences a
and B or partial order equivalent if you
could get from one the other by swapping
adjacent independent actions at any
number of times so that's an equivalence
relation or action sequences and the
idea is to explore only one
representative in each sequence class
right so they take one on a partial
order direction we suppose and you had
come up with a partial order algorithm
this is probably what you would first
come up with and it's wrong I'll show
you why
so the idea is
suppose I'm in fated right and there's a
bunch of transition to that there are
actions that are the locators you hear
and what I do is that I need acute only
a subset of them say Delta and I don't
execute the remaining ones I disagree
with you and I can do that as long as
every action here is independent of
every action here the reason for that is
since it's independent I can always
execute these later it doesn't matter I
mean I have not lost anything by by not
executing them right so then I can I can
say but that usually doesn't work out
let's consider the bomb example so here
alpha is independent of beta so I get
this execute alpha and then I could do
the same thing and then I could just
miss the bomb right if you ask the
property if you want to take the
property does they just the bomb will go
so you might say yes when actually it
does go so it turns out of the problem
it really is is okay so the problem
really is here is that at that point
what actually happened was alpha was
independent of beta right but what you
could do is that you have decided to
postpone beta but what you have lost is
that by executing beta a few times you
can get to someplace that is dependent
on alpha so it's not just efficient to
have everything in your state
independent of alpha but everything you
can reach by executing the things you
have missed should still be independent
of you so that's the idea behind take 2
which is called persistence X then
persistence that's what you want to do
is you want to make sure that Delta is
not just independent of gamma minus
Delta but it's independent of anywhere
you can reach by executing descent right
any length on the future right and
saying the bombing example those are the
World Cup because if you go here then
now alpha is not a persistent set right
because now I can execute better for
three steps and I can get it something
that is dependent on alpha since we use
persistent sets then you do fine find
the other so it turns out that actually
that is also not right what do you need
to do also is that if you have a set of
if you get if you're doing exploration
right and if you if you execute Delta
and if you don't get any new states then
you have to execute all the transitions
so yeah you have to do a formal theorem
that if you choose this then what you
get is a valid partial order direction
and the proof is actually pretty
complicated so but I try to give you
just some intuition using examples but
the title like the height of it exactly
somebody is there he uses independence
then you have to worry about persistence
then you are worried about this thing
called ample mess as well so the one
thing that happens is there and I'm just
nearing completion is the computing in
this independence relations and
persistence set itself is pretty hard
thing to do because they require
knowledge in state space as well but
what you could do is you could come up
with syntactic sufficient conditions
what you could do is you could come up
with persistent set there are larger
than necessary because they're easier to
compute and then you could come up with
independence relations that are stronger
than necessary because again they are
hard to compute and still that works out
ok and they offer pretty good reductions
in asynchronous protocols where there's
things going on that don't actually
relate to each other and there are few
actions that actually sort of
communicate and you are worried about
only those actions pretty seriously and
you can write art visual examples in
which in which they offer like
exponential reductions you can see
papers in it say I don't use partial
reduction I blow and then otherwise that
you do it in two minutes but in the
things that I have experimented with and
and in the times the things that I see
in papers if you take system it's about
5 to 10 times faster if you have a lot
of asynchrony and they're implemented in
spin and they're also implemented in the
sync all very sad very soft and we'll
revisit this later so I'll stop here
today</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>