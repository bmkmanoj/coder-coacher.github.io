<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Advances in Quantum Algorithms &amp; Devices: Quantum Monte Carlo versus Quantum Adiabatic Optimization | Coder Coacher - Coaching Coders</title><meta content="Advances in Quantum Algorithms &amp; Devices: Quantum Monte Carlo versus Quantum Adiabatic Optimization - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Advances in Quantum Algorithms &amp; Devices: Quantum Monte Carlo versus Quantum Adiabatic Optimization</b></h2><h5 class="post__date">2016-06-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/YSyDHDN7zKs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
okay great so now we have our final talk
of the day from wim van Dam and he's
going to tell us about quantum
polynomial interpolation okay thanks for
the opportunity this is the first time
that I'm going to give a talk about this
topic so I'm still like very
enthusiastic about it but that also of
course means that I want to talk about
every detail you know because it's all
so fresh so but only honor that I've got
a plane to catch so it will be
impossible for me to run over time but
yeah I apologize for like the abundance
of math it's just that yeah I couldn't
couldn't help myself it's a decidedly
lowbrow problem that I'm attacking here
polynomial interpolation in Palo meals
in one variable and of course you know
if you if I'm facing a unknown quadratic
polynomial then I know after I've
evaluated this polynomial on three
points I know what the three
coefficients are of this polynomial so
this you know holds for reals this holds
four coefficients you know that are
maybe finite field elements this holds
in general so that's you know how you do
it you if you have a degree D polynomial
that you do not know and you access it
it kind of in a black box query model
you need when you do D plus 1
evaluations then you know your
polynomial and that kind of makes sense
because you need to know D plus 1
coefficient so you ask d plus 1 times
for information and then you know and
the Saudis works and this works you can
do this efficiently and it works without
error so that's the classical what you
can do and then classically what you
cannot do and as always then crypto
people think that that's a good thing is
doing it with less than D plus one
carries if I have a degree D polynomial
and I only know the sides d values of
this polynomial well then obviously I
know a little bit about the polynomial
because I know d values but if somebody
asked me like well what about a next
point like a deepest one point on this
polynomial then I don't know anything so
it's kind of like a zero knowledge kind
of
knowledge that you get from this
polynomial that you know that the values
f x1 through fxd that you queried but
you don't know anything else about the
polynomial and you can make this precise
you say so this call gets kind of
complicated when you deal about the
reels of course because if I have a
point here and I've got a point near by
then I kind of expect the polynomial to
be kind of like in between you know that
it's a straight line unless the
coefficients can be very wild and then
you know you need to have a kind of like
well what do you what assumption do you
have about what these coefficients of
this polynomial so the goal gets very
messy so what we do instead is we assume
from now on that the coefficients are of
a finite field of size q but i will use
P because that's easier on the notation
and so now you know they're each
coefficient there r cube so there p
possibilities i can just take random
completely uniformly random coefficients
that's my assumption and then you know
I've you can you can quite easily show
that if i only have d classical queries
that if i want to guess the function
value or a value input value that i did
not evaluate that my all i can do is
guess and i will be correct 1 over P
times so it's completely and this is a
technical term this is useless like
useless the D queries are useless in
interpolating a classical a polynomial
in a classical manner so and that that
is a good thing because that kind of
it's the basis of show me yours secret
sharing protocol where you need d + want
people to get together to figure out the
shared secret which is the polynomial if
you have only d people that get together
then they cannot like unravel what the
discover what this polynomial is so this
is this is known this is tight useless
with d queries perfect with deepest one
classical queries and yeah so we'll be
all done so this is the traditional
topic and it's kind of you know
surprising to me that I never thought of
this before
until my co-author Andhra child's
mention it to me that you know what
changes if I allow a that I quantum
query this polynomial because this
polynomial is we like a black box so you
know we can imagine that we have at our
disposal you know this this polynomial
is in a black box and I contemporary
this polynomial what can we do better
can we do better than the classical D
plus 1 elgar so that's a natural
question to ask and yeah I don't know
why but the relief that maybe people
thought about this and then like did not
write it up for sure but but there are
some results Kanan kooten proved in 2009
and Maya and promotion approved in 2010
that you need quantumly at least D plus
1 over to queries the the stronger a
result is the 2010 result where it
showed that quantumly if you have d over
to queries then that's useless again
that if i have d over to queries to my
unknown polynomial then I cannot do any
interpretation so i need at least d plus
2 D plus 1 over to queries and you know
you just have to whenever you see d over
to you just have to assume that these
even and when you see D plus 1 over to
you just have to assume that these odd
and that's kind of it's not interesting
to talk about that I'm Kanan kooten
conjecture in 2009 that actually there
would be no quantum advantage that D
plus 1 quantum queries were needed this
was disproven by Binet and zandri in
2012 where they showed that there is a d
quantum query algorithm that does the
job it doesn't do it perfectly but it
has a success probability of 1 minus
something that gets smaller and smaller
smaller as P gross p is the size of the
finite field and these the degree of the
polynomial
and so specifically what they could
summarize what they do is they kind of
figure out that one query is sufficient
for you know a linear expression so then
you've got like two coefficients for the
price of one query and then you know the
remaining coefficients you just kind of
like do kind of like the way you would
do it classically so that's kind of how
Albany in centralia do the stuff so
there is a condom advantage but it's
like if ever there was a minut advantage
this would be it that you can you can do
better constantly so that status like
the state of the art until our result
that says that actually D plus 1 over to
quantum queries is sufficient to find an
interpolation of a polynomial and our
success probability is constant it's a
constant successful bility so we're not
doing it perfectly we're not doing it
with a probability that is you know
close to one but it's a constant success
probability so I have to yes exactly
exactly exactly exactly no so so what's
not what's the model here well I fix my
degree D and then I let my finite field
size grow because like why don't you do
it the other way around well I don't
want to but also that if your field
would be like really small and you would
have a big degree well you know modulo 2
x squared equals x modulo 3 sound you
know high degree polynomial open only
makes sense if the finite field is big
enough and so in that sense what you do
is you fix the degree and then you let p
grow that that's kind of the the model
and so this omega 1.is as P growth but
it levels out at a constant specifically
as you're in the limit of large enough p
the success probability goes over and
this is not because i'm very excited but
this is because it's 1 over K factor
real where k is the number of queries so
so so from now on case the number of
queries and k is d plus 1 over over 2 so
it the success probability goes down
pretty badly as a function of the degree
but for a fixed degree it's a constant
so that that's that's that's the that's
the setting and sure if the query
setting and as an aside the space time
complexity of this algorithm is
polynomial it's like efficient it's
polynomial in the logarithm of P so
that's all you know the best you can
hope for can you do better than get plus
1 over to queries no because of the
results of the previous slide that D
over to queries gives us a useless
quantum as setting can you do better
than this one over K factorial are six a
probability I don't think so but we
don't have a proof of that so there are
like reasons why dat one over K
factorial actually comes up quite
naturally and so this might be the best
you can do with the plus one over two
queries so that's that's that's that's
our that's our result so it we reduce
the grameen when you think of it in the
crypto set at setting you know show me
your secret cheering then you know a
constant success probability is not like
that's like a bad thing so it's
definitely kind of significant to have a
constant success probability and yeah so
we've got a query reduction by a factor
of two and I think this is the hardest
factor of two improvement that I've ever
worked on in the since I've been working
on the quantum algorithms so how does
our element yes
mobility is taking his face of problems
the space of runs BR 00 k ghia yes so
this success probability these
probabilities come completely from
quantum mechanics so for each instance
it's the same probability yeah but but
we're in the business then the number of
queries then became K times K factorial
so that's not particularly good yeah
yeah I know it's not well it is there
it's worse than like the classical
approach yes yes so these probabilities
are because of cupcakes yeah and it's
independent of the instance of the
follow me all that you try to solve yeah
so our algorithm works as follows it has
these five steps four of which are
trivial you showcase the number of
queries in case then D plus 1 over to
you create a superstition over K
registers this is the input then you
evaluate the polynomial k times so our
queries are not adaptive or anything we
just like dude you could or you could do
it in parallel then we do VA transform
because you always do a free a transform
some time and then then the magic
happens we do some elaborate
computations modulo our finite field and
then we do another flea a transform and
we measure and then with the success
probability of 1 over K factorial we
measure the coefficients of the
polynomial f that we are looking at this
algorithm is inspired by the pretty good
measurement approach to the hidden
subgroup problem so that that field is
bearing fruit now and the magic happens
in step 4 that's where the heart
analysis takes place and for some of you
who know some all the results that may
sound somewhat similar we do not use
quantum Oracle interrogation that's in a
different setting where you carry a
a binary black boxer you get a speed-up
of almost to an improvement offer to it
that's not what we're doing we're doing
something quite different from our we
also we are not doing an adaptation of
parity clearing like all it's not the
factor to improvements that you've seen
before it's something it's something
different that we're doing all right so
right so let's do the first three steps
just just to kind of get started we
create a uniform superposition over the
input register we query the function K
times so now we're in this superposition
and then we do a free a transformer we
do k of them k free a transforms just
over these k registers and so now what
we have is a superposition over your
from suppositions over X values and y
values and all the information are all
information about the function is now in
the coefficients in the amplitudes of
this superposition so that that's what
the sittings now some of you have dealt
with you know phase and phase estimation
say like well why don't you use the kick
face kick back trick right where you
kind of you don't use this second
register that won't work because notice
we need a d-plus one at the end we need
to have D plus 1 coefficients and so we
need to read out d plus 1 registers and
only if you know k plus K equals D plus
well do we have enough space to have the
coefficients stored so it is crucial
that indeed you write out the function
values here and then do the free
transfer because you need 2k registers
have to be involved we will even store
the coefficients at the end of the day
so yeah okay so these are all the
the trivial I mean it's kind of like
it's obvious well it's not obvious but
to me make sense if you've seen a few
quantum algorithms that this might work
and so so where are we we're here and
because i need my letter I for an index
i'm going to rewrite etudie 2 pi just as
sigh and so the state that we ended up
with on the previous slide is that state
that that state the Bob the top top
right a substation / x and y's that are
register of length K each 2k in total
then you know a face that is determined
by the polynomial on the the polynomial
values of x times y and like let's let
let's get the coefficients that we need
to that we want let's get them out of
let's get them out in the clear let's
rewrite this you know using the fact
that F is indeed this polynomial with
coefficients C I and so we're having
this state uniform suppositions / x and
y's phases where you know you've got a
sum over the coefficients that we need
and then polynomial expressions where
the wise come in as linear terms and the
x-values come in as Exponential's as in
like you've got like x and x squared all
the way up to x to the power D that this
is you know this is the algebra this is
how it works out okay so this is what we
have and you know well is this good it's
this useful well it would be useful if
it would be just a little bit different
if you know I told you that in the end
we're going to do a transform and then
we're going to measure the registers and
that's going to be the coefficients we
hope we and that will be the
coefficients with a certain the success
probability now when is it that you know
if you apply free transform k times and
then you end up with the sorry if you
apply the veterans for
d + 1 x 2 K times on all the registers
and then you have the coefficients when
do you you know end up in all the
coefficients well that works if you are
dealing with this state so if we have
this state we're perfect because now
just a bunch of VA transforms it will
give me the coefficient but you don't
have this state we have that state but
they're not all that different remember
that k equals D plus 1 over 2 so this is
all good the only thing and so you know
a summation over coefficient C I that's
also that the only thing that is kind of
stand between us and perfection is that
you know if only these terms here these
summations were some kind of you know
values Zi and at the end of values zi
would be written there so so I hope I
kind of make my point that this if I
write that a CIS and then if I would
have in those registers those Zi values
also then I would be then things would
be perfect and I find my coefficients
domestically but we're not there so some
magic needs to happen to go from this
state to this ideal state over here
that's that's that's what we want um I
know that you know I'm going a little
bit fast but at some point I can reach
like an intermediate stage where i can
say like well even if you didn't follow
the details this is where it's at ok so
what do we want well so we want to go
from those x and y expression to the ze
expression that's what we want to do and
let's pretend for let's just define zi
to be those values so what it means that
you know given the x and y values i want
to make these z I values so what I want
what this magic step is going to be this
step for in my
my algorithm is you know starting with
these X values that I end up with the z
values that that would be like the ideal
scenario if I could do that where these
z eyes are these expressions now
obviously given x and y i can figure out
what pc is i can just get you know x y
and z so then the only thing that I need
to do is uncomplete the XY from x y&amp;amp;z so
what I need to do is figuring out what
the z values are is trivial what I need
to do is given the z values can I figure
out the x and y values that led to the z
values such that so that I can
uncomplete the x and y's and then i
would be in good shape now we won't be
able to do this step perfectly because
it's not unitary it turns out that you
know sir different X's and Y's lead to
the same value Z so it's not a unitary
transformation so that's kind of why we
do not have a deterministic algorithm
but what we can do is we can it we can
do it pretty well we can like
approximate this behavior and and also
another observation to make is that this
this crucial step that is missing is
independent of the polynomial that we're
trying to discover and so this is why
you know the success probability is
independent of the polynomial f that you
try to discover and so if i can get this
working some like as unitary if i can
implement this you know approx that
works for almost all X's and Y's and
almost sees that I'm good so it becomes
kind of an average case problem that you
need an average problem that you
probably need to be able to solve like
on average and so that's that's kind of
nice because that means that you know if
you come up with like very obnoxious Z
values just like you count them if
they're not there were too many you just
like ignore them so we just need to
solve this problem on average okay so
that's that's that that's what the
that's not the promise so the problem is
again
given x y&amp;amp;z find a way to get rid of x
and y we're going to do that by like
given Z compute x and y's so like the
hard part is we're going from the right
to the left awfully enough that's that's
how I'm computing a goes okay so so what
what goes in the analysis of how you can
do this so that that took a while to
kind of figure out the crucial until
we're dealing now with a problem that is
purely classical in its formulation like
giving a bunch of value Z figure out
which X's and Y's are responsible for
these evals so it's a classical problem
and in the end the algorithm that we
will use to solve this is going to be a
traditional classical problem so all
that like all the quantum Ness has
already happened that I was actually you
know uniform superposition Fourier
transform via transform that's it so the
quantum part of this algorithm is is
it's not very very big bell of course
you need to do this computation in
superposition so you know it is a
continent so but it's crucial in
figuring out to which extent we're going
to be able to approximate that that
magicus step for will depend upon how
many solutions there are for a given Z
and so any analysis what what what
matters is that you know given these
values z Z 0 through ZD how many
solutions x and y are there that have
you know that leads to those Z and we
call this a disease it's the number of
solutions for a given Z now if Iran Z
would always be one then you know we're
talking about a bijection between x and
y and z and we could do it perfectly but
that's not the case the success
probability of our algorithm is going to
be this this expression market the
square root of the success
is going to be this expression this is
something that you know we did before
when we were doing a hidden soccer
problem we were dealing with in soccer
pro problems and so now remember that
deepest one equals to K and so this kind
of makes sense it says that well you
know there are P to the power 2 K are x
and y values so that's the total of so
if I add all my numbers of solutions I
should get P to the power 2 K I've had
all the eds I should get Peter power to
K the number of Z registers that I have
to deal with is also p to the power 2 K
because D plus 1 equals to K so if there
was no square root here this would add
up to p to the power 2 K and this
success probability the square root
would be exactly one and so this is you
know kind of what what I alluded to that
if all these if all if this was like a
function that always had like exactly
one solution X Y for a given Z then the
success probability would be one well
it's not that's not the case instead
what we proved is that the typical case
or ignoring you know aberrations of like
art very peculiar Z cases the typical
case is that an eda the number of
solutions idea is zero in other words
you know given as e there is no xly pair
that produces that Z or if there is a
solution that are like K factorial
solutions and so what this means is that
you know this summation you know
introduces the square root of K
factorial and then you know you do the
math and then it turns out that you know
your success probability is going to be
1 over K factorial and so again the
number of solutions ideally
completely uniform but instead what we
prove is that it's like uniform the
number of solutions or K factorial
solutions and or there are no solutions
that those are the typical cases that
that's what we needed to prove and
that's what we that's what we that's
what we proved the prove itself was kind
of fun to do and so this is this is the
the problem that we're solving just
what's in the in the box there if that
you're given the moments oh sorry that
should be D plus 1 moments you're given
D plus 1 moments Z 0 through DD and yet
you're asked to find y values and X
values over the finite field such that
the equation on the right holds for all
these e values so that's the problem
that you try to solve like given as e
does there exist a solution if so how
many are them do you understand what
they are that's what you try to solve
this is a moment problem that some of
you with a physics background might be
familiar with that you know just think
of a distribution over the real line and
you're given moments of this
distribution so the distribution is mu
and you know the moments are X to the
power n so given a bunch of moments of
the real line find out if there is a
distribution mu that has these moments
or proof that is not possible or proof
that there are more than one
distributions this is a traditional
problem and then depending upon if the
real line goes you know you take the
whole real line or you take like half
the real line or you take the interval
between 0 and 1 this is called the
hamburger or the still cheese or the
third person whose name i forgot moment
problem so this is a problem that as
well studied and it's not trivial to
solve but we kind of know how to do it
and so what we what we did was that well
you know you steal results we looked at
you know how it's the moment problem
down over the real line what are useful
ingredients that apply in our case where
we're dealing with the finite field
moments problem and so in our finite
field
problem rather than this distribution
Moo we have the values why so the Y
values are like a distribution over the
over the X values and so you look at the
powers of X as the different moments and
so fortunately some techniques of the
traditional moments problem were useful
we could like employ them and then
Andrew child's always enjoys doing that
he founds like and it finds like a
reference from 18th century where that
was useful for us it's called produce
method which is something that in signal
processing is is still used and they're
using this this like set of techniques
we did in the proof what I said earlier
that you know typically for typical Z
there will either be no solutions at all
or will be K factorial solutions there
are aberrations but you know they are
insignificant and answer you know why
does the K factorial come where does the
K factorial comes from well go again to
the say that you've got a solution x and
y that that does the job for the moments
that you are given now obviously when I
permute the in ssj that also gives a
solution so we never have a solution x
and y if I permute x and y you know the
same permutation which I can do in K
factorial different ways I've got again
a solution so a solution can never never
come by itself it always comes in like
blobs of K factorial switches what's
that unless it is symmetric indeed if
you know or you know other stuff happens
of course that if one of the wise is 0
then X can be anything right because it
but indeed or some of the X cases are
some of the X values are the same then
you know the premiership a doesn't make
it the different solution and so this is
why we use an abundance of the words
typical the typical situation is that
all the Y's are nonzero and all the x's
are different if you take a field large
enough and then you know the K factorial
cannot come kicks in that's kind of how
it goes
yeah and so that's that's I enjoyed this
tip of graphical to do this that that's
ready k factorial comes from and so then
you can put it all together and you get
the diagram and so just to remind people
and like I did I did go fast enough this
is then you know how you get this result
and i conjecture would be that for D
plus 1 over to queries the success
probability of 1 over K factorial is
tight I think that I think it's tight
but I really I don't want to prove it
I'll leave it to other people to do
that's it thanks questions for win do
you have sense as to what each
additional query gets you and I had a
long conversation how I would answer
this obvious question yes yes I do have
a sense yes so this is going down so
that's one over to queries
this is the result that we have we think
if you go one we know we know we know
that if you go if you add half a query
to it that then your success probability
jumps up to 21 minus in term that gets
smaller and smaller as he grows so now
why did I not talk about that because
we're still finishing up on the proof of
that so we we ever got to prove we've
got this result proven for some small d
we've got numerical computations that
confirm that what we're seeing for small
D also holds for arbitrary d4 for larger
d and so we're kind of a we know what we
need to prove to make it work but
they're still all like finishing up the
proof of that yeah so yeah if you add
half a query as it were you your success
probability jumps to effectively well
yeah sure so I get a question but your
success probability is this I didn't see
how it whether or not your success is
Harold it when you get it out or how the
checking ends up happening to see if you
got a success is it in a form it's
convenient to use amplitude
amplification well given given that
we're working on like finishing is proof
that never kind of equipment I mean what
you can do is if you have a kind of
conjecture for polynomial you just kind
of evaluate it at a random point and see
if it works that that's kind of you know
the best I think you can do maybe you
can do it a little bit better quantum
mechanically but that's already pretty
good so you just evaluate on a random
point and see if your conjecture matches
about the black box is doing yeah so
John got away from this question by by
pre-empting it do you have any idea what
what the gate counts in circuit depth on
our on this yet so what you've seen thus
far is everything but step four is
pretty straightforward right free
transform like box evaluation so you
know whatever the complexities of the
black box the computation that we're
doing in step 4 to make it work is
effectively what's the most expensive
part matrix inversion so however hard it
is to invert a matrix of dimension D or
D plus 1 over over finite field on a
quantum computer that's like the main
cost so it's not going to be
particularly cheap but it's not too bad
I think I still on mark was it oh yeah I
mean it really looks like parody I mean
I know you blew that off in the
beginning right I mean and especially
when you do this and you tell me that
you know one more step and it gets a lot
better it's so
of interesting I mean but you're not
going to write you mean what you don't
want to go there so priority goes from
being useless to deterministic that's
like one indication and then it's also
quantum mechanically it's the same thing
it's half the number of queries right
yeah but quantum mechanically with
parity you go from like useless to
deterministic yeah browse really kind of
our in this intermediate like we can
apply get like success probabilities
that are you know neither 0 or or bomb i
I really don't see I don't see the
parity ok I'll go I'm working on it now
ya know I has the same smell but this
looks much more complicated any other
Martin I think wondering if you have any
thoughts about multivariate
generalization I was wondering that
somebody was gonna ask a question that's
like can obvious question and there are
some results rather recent on
multivariate polynomials that are multi
linear and there is some quantum
advantage there so it seems that ya know
we that would be like the next thing to
do because we already know that there
are some quantum advantages for some
specific systems with with multi linear
polynomials and so that that I expect
that we can do better what I what what
will be interesting is by going to
multivariable polynomials if maybe you
know this factor of 2 becomes like
something more impressive that would
that would be the hope and I do but I
don't know what to expect her I don't
know
yeah great well let's think whim and all
of our speakers today thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>