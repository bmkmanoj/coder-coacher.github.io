<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Good Programming is Mathematics and Vice Versa | Coder Coacher - Coaching Coders</title><meta content="Good Programming is Mathematics and Vice Versa - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Good Programming is Mathematics and Vice Versa</b></h2><h5 class="post__date">2016-08-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/R9aAu9j67u8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">materials supplied by Microsoft
Corporation may be used for internal
review analysis or research only any
editing reproduction publication
reproduction internet or public display
is forbidden and may violate copyright
law
okay welcome everybody I'm really
pleased to have a Gabrielle dos Reis
here from Texas A&amp;amp;M where he's a
professor he has a very interesting
history as a PhD in mathematics from
University Paris 7 sorry an école
normale superiore di kishan France and
his research interest range from
mathematical software applied formal
methods programming languages and
libraries to generic programming in 2012
he received NSF Career Award for his
research in compilers for dependable
computational mathematics he's an active
member of the ISO C++ Standards
Committee and he's authored and
co-authored several features of the 2011
ISO C++ standard as well as doing
research in axiomatic programming and is
open axiom system for scientific
computation and also at some point being
the release manager for GCC so can you
imagine all of that and in one person
here he is to tell us about his recent
work thank you very much tom and thank
you for inviting me to make sure so yes
when people ask me what I do was say I
do programming and I say I also do math
and I'd like to tell you today why I
believe that doing programming he's
actually doing math for women to have to
qualify to say doing good programming is
doing math but eventually I hope that
we'll just say programming is math so
it's not essentially what two weeks you
know gives you an overview of what I'm
doing no programming really is math and
I started from camp algebra and it is
all connected and I'll try to explain
and try to convince you that yes is very
connected and then I will focus near the
end on my one of my recent project which
is lazy
it's you know an experimental language
for doing research in structured genetic
programming so I studied C student
working on geometry and then get seduced
by using computers to to the geometry
and then quickly spend too much time in
the computer room and and and now I'm
going back again okay so I did an
internship oh sorry we finish married at
INRIA working in European Commission
project called Frisco which was a
project to write libraries to solve huge
for liminal systems that no people found
in science and engineering and I was
mentally time by Victor Pan who is one
of the experts on structured matrix
competitions and and so forth and had to
work on the one of the fastest algorithm
for uniform approximation of univariate
polynomial roots and anytime there are
several the project consisted of you
working at an RIA
sufficiency police and rent me with
enough of West and people in Italy and
Spain but essentially we had only to
implementation languages Fortran and C
Paz was so I didn't really find my self
very comfortable with photons so I chose
C class was and this was 96 so if you
remember at the time I had GCC but it
was horrible and your choice I had was
Sun Microsystems compiler CC it's pretty
good and in the end I end up actually
reimplemented a components of the
superest under because wasn't part of
GCC and I needed to get the inner
library done so that my colleagues could
use my library without having to
reinstall everything and while I work on
the implementation of valeria form
several bugs and the only we could
actually get them fixed and the center
was to join
the Avner group which is the equivalent
to the MC group body French group and
then no I contribute Valerie's juice you
see and that's a punishment and he asked
me to become maintainer and later become
risk manager from 2002 till 2007 and we
stopped because no can't be professor
already release manager at the same time
but what I got out of it was real
interest in supporting generating
programming because you know a lot of
computer algebra and usually sequester's
course templates discover that you also
need to something different and the
reason why I got in GCC was that it was
just a software so it should be fixed
and that turns out to be a little more
complicated I realized ok so I'm going
to you know to show the connection
between join a program in C++ and
computer algebra so chary programming is
essentially methodology for the
low-paying you know reusable form of of
libraries annual deficiency and really
want to parameterize the component so
that you can use them and you want to
manage complexity and so my background
is in computer algebra where we have
really rich mathematical structures so
it's essential that we find a way to
manage complexity so since you're here
you have one function called files I can
use them a vector I can museum list I
can use in any unit dimensional sequence
and it just works the same I can use the
same you know wisdom no working with
vectors or based now why is it important
it is important because it is a
principled way of constructing software
we we need principles we need things
that scale and the other thing is that
actually it is not just some
experimental methodology now it once
made streams is not just some academics
you know playing with four or exists it
is their real code no you're at
Microsoft Adobe Google
Blumberg a nine one of the things common
with doing a nanny is that Alex de panne
of who invented the STL worked Dobie
till two years ago and now he's at a
nine and still working on chairing
program trying to get you know educates
programmers to get things done and
actually is effective there are many
places were object-oriented programming
was very fashionable in the 90s failed
were no musing Jenny program you
actually succeed pretty well languages
like Java I'll tell you why they studied
less pure object-oriented and then he
added generations now a collection of
compiled Gibran so actually compute
algebra is one of the original areas of
generic programming because of the
complexity and enriched structures that
mathematicians computational
mathematician may have had to deal with
you can think of GCD and if you think of
the Euclidean algorithm the this
statement we could you know it is very
abstract if you have a Euclidean domain
essentially a collection of things that
look like numbers you can divide them
and you can have a process that tells
you when you can terminate so we have is
some kind of termination criteria you
can do DCD are there or you want it to
compute Gaussian elimination this is
what you know people who do linear
algebra like you know to do it you can
do the Gaussian elimination with
floating point numbers which is kind of
approximation of fields but what if you
don't have division well it can still
work now use Gaussian elimination on
rings that happen to have the right
property so you see that if you if you
set up your algorithm and you understand
the conditions and very little bit you
can get a Verity of complexity and very
good algorithm that actually scale and
last thing and probably said before
repeatedly games that mathematical
structures are very very complex that's
one of the things that Alliance mafia is
great but I've ever you know understand
that it's love completely stuff out
there and general programming helps with
complexity
well there are many ways of doing jury
programming
if you feel languages ask her or you
know more FB oriented in Italy of good
stuff out there and we know several
experimental systems to look at several
ways of doing tearing programming from
you know Haskell point of view most of
these have in common a focus on the
orientation of data okay and try to
explain this with analogy or sometimes
inspiration from category theory and
patterning and this is actually what
you'll see in most academic papers and
then there is the donor aspect that were
you focused on algorithm so as I said if
you look at compiler Brides mostly
having to do with the Fargo rhythms okay
so the seven of explained the instant
exam file is through the STL using
suppose templates
it focuses on algorithms we know when
you go to industry it is what you find
predominantly even whether you use
c-sharp Java you know its focus is and
are learning from another computer
algebra community and the idea here is
that you may have a general formulation
of an algorithm but you can add you know
a series of requirements and refinement
to have better in our complexity so for
example if you want to search an item in
a sequence you can do linear search but
if you happen to have a you know if you
have a single linked list then you have
to do linear search but if you let's say
have an array and you know that the
array is sorted you can do binary search
and there you have a better complexity
you know an average then you have linear
search the connection between data type
general programming and algorithm
focused during programming is still
something that's in the hustle community
some turtle Jones and roughly all have
been trying to breathe the gap and so we
have these paper series of scrappy
boilerplates
try to not read the gap
Yakub yavi and myself trying to you know
bring some ideas from Haskell in city
service community because you know it's
always good to to get infected by other
people yes so for the example that you
mentioned about you know changing the
implementation to another thing is very
naturally done with type classes at
Haskell right yes at least for type
classes it's more about operations at
that data source so if you look at type
classes type classes focus on type not
on algorithms the I'll have some slides
on the contrast I wanted to show but if
you give the example of sorts for its
alt algorithm in CSS if you want to
parameterize your sorting you know the
cooperation function you can do it in
Haskell but you start getting into hoops
you have to use multi type type classes
which aren't standard and once you get
there you have a lot of ambiguities and
how you solve that you can try to use
functional dependencies that it's more
problems you can try to solve this
problem in Haskell but you know as you
do it you're building more machinery
complexity which became this problem or
more complex because at the very
beginning the focus was on type not on
functions yes we can use type classes
but you are going to only go in one
direction not try to have at least two a
three-dimensional view of what the
problem is yeah sure we can have more
discussion on this but yeah very good
question
so going to give a brief example of
interaction application of generic
programming in computer algebra it's a
great in differentiation so we all know
this thing about
the pronunciation went a calculus class
which is you know we have the Lebanese
law and then it so it sounds very simple
problem the problem you're looking at
here is different which is that you have
a program that computes some
mathematical function and you like to
have another program like compute the
derivative of that function so you don't
have a cost formula you have a an
algorithm that computes that function
and you like to generate automatically
another program that computes it already
so let's algorithm differentiation so
you know transformation Phi here you
know you if you accept that you have
some semantic function that gives
meaning your program in some
mathematical domain and you liked and
you have the mathematical property here
you can get derivative and you like to
have a transfer its transformation of
your source program to something else if
you take the meaning of that you get the
derivative it's what you're working in
fact well the first thing is this is not
divided difference meaning this is it is
not computing the value of a program you
know a function at two different point
and then divide and by the difference
there's no words about that scheme is
empirically unstable not very
interesting it is not taking an
expression tree and just apply that its
role indefinitely know that assume you
have a closed formula it's no worries
but this about imagine you take the Lib
C implementation of square roots okay
and you like to have a function that
computes derivative of that it's done
automatically not using difference
equation okay so if you want to do that
the first thing you need to do is to get
a better understanding of what is going
on and you have to work at very high
level not the concrete presentation but
a very high level set the properties of
your function and also have a formal
semantics of your language so that you
understand how
control flow is expressed and work at
the mathematical level and then design a
transformation that gives you the actual
representation so this is something that
I did I work on with my colleague Yaqui
Ravi and student Jacob Smith he's now at
Intel so one of the reason why this is
actually good thing to do is that most
functions we use in size they don't have
closed form now when you take calculus
zero two or three classes they always
come with very nice functions then they
teach you how to compute derivatives so
you move to the real world where you
know I have two sub problems and
suddenly you realize well most of your
functions don't have clothes okay
probably defined by some differential
equations and you know you devise
algorithms to to complete a function but
you don't have a closed form and
sometimes even if you have a closed form
you don't really want to present that as
question three and your IV if you take
this sequence series of functions form
so we have zero they have the identity
and the other thing is sure you lie it's
like no Fibonacci function but it is not
because you have some lot they're
interesting it's thinking about log is
that when you derive it to get quotients
and it keeps going on well if you if you
derive try to draw compute the
derivative of each element here
essentially the orientation double at
every step so you don't want that worse
if you result it as an algorithm that
computes the other is compiled you know
fixed size doesn't change so you prefer
the algorithm your presentation over the
expression tree a presentation photo
mini idea computation and the rules that
you actually use is not the Landis rule
that says social distinct plus linearity
what you actually use is the chain rule
so if you imagine that have statement s1
Sigma X to you run this on a machine
essentially transformation of the state
of you machine so if Phi is this
function in the transformation that
compute the derivative well you have to
use the chain rule right let's say if
you come if you compose FNG
the derivative of this whole thing is a
derivative of F apply it what was there
earlier which is a function f 1 so this
is what you use mini practice this
really sometimes you want to have x
times y probably need that but most of
us what we did and it socially
implemented as a library and the reason
why is very successful was that in the
open action system we have this notion
of categories will be equivalent to type
classes except that they're multi
parameter type classes and well-behaved
and the world library in action is
generic and in an instruction very much
a magical way and action was designed to
prove a point which was that you can do
structure computer algebra with a strong
typing if you take maple or Mathematica
that's not the case Mathematica we have
expression tree and you substitutes
you'd get something if you get the
answer
great most of your time you get
something you don't know exactly what it
is maple is is close to that and it
turns out that this such a paper was an
improvement or what existed in maple in
2007 I think we have been in US but in
2007 it was a huge improvement over what
yeah very good question so the question
was whether I'm assuming the functions
that continuous not only I'm assuming
that yet continues I'm not sure that the
idea they can be different series and
forever
I'm assuring that the algorithms
representation is very natural so to
give you an example if you take the
identity function you can decide that
well it's f of X equal return X
something like this or you can say well
it is return X except if X is 42 in
which case you return for the two you
have a switch statement so suddenly you
have some kind of artificial
discontinuity right so I'm not assuming
any of those
things it is a restriction on the form
of the input program in practice it is
not a big deal because in practice most
of your rights functions and throw away
and if you write it in a way that is not
natural if you run it well return X
except if X is funny to then return 42
you will see that you get the derivative
if you apply the rules you get one for
everything except for it you won't get
zero because its customer right but yeah
it is one of these shortcomings and I
was hoping that no one of student will
continue and try to use ideas from
abstract interpretation to try to kind
of symbolic limits at some artificial
discontinuities but yeah and in practice
again is not real it's not a big deal
because most codes they're written in a
proper way but it don't handle for loops
like you write in C yeah things just
work beautifully it's it's amazing it's
very very simple and amazing
and another thing is that showing the ha
yeah so a different station is actually
numerically stable it inherits the same
eraser we can actually prove theorem is
you know right the only in the formal
rules that if you do this program
transformation the numerical error you
get is the same as you know the accuracy
is the same as the original input so it
is actually preferred way and the matter
of fact I wish that when we teach
calculus classes we teach the algorithm
algorithmic way of differentiating a
program then the formula that people
learn it it's a very good work to mean
algorithm and the rules are very very
simple you only need one zero
and any computer science programming and
calculus at the same time okay so next
thing how do I get from so Jerry
programming I'm doing that for C++ go
did I get that from there to the other
part of my research which is trust for
free systems they're just two slides
because I want to move very quickly to
today's the first thing is I really like
to trust my libraries
first I want to trust the implementation
or summer library and I would like to
trust your library and you probably want
to trust my library and how do we get
there it is proven correct answer
evolution is really easier if you know
you don't depend on some implementation
details and that is a shoot by working
at the most abstract level okay so you
need to generate programming and another
thing is that I actually believe that
super spies receive a fine
implementation language okay I was
raised in France so in the good French
tradition I had to learn Pascal and the
next was okay well of course from geek
cuisine oh you know monkey people who
yeah for Jessica and Terry were people
who were at the Future Foundation of
okay well soda or camel stands for no
categorical abstract machine language
and there is a logic but you know this
come from because II know a Joey but see
path is very fine language work with you
just have to be principles and and
disciplined so one project I have you
know a long term project is to try to
build a a formally verified super source
compiler the same way that we built the
concert compiler which i think is very
very good thing it's for both the c
community and for the formal methods
community which is that well hey you can
actually
very complexed of an improve it to be
correct so it's good stuff I'll let you
do that for C++ too because the language
it's complex but there are key things
there that I then I would like to see
more in mainstream languages the first
is the notion of construction
destruction many of the currently
language have the construction but they
don't have the destruction part they
have finalization and it's messy no
systematic reliable destruction of needs
of resource is something very important
you can depend on it and this is
something that I think should be
preserved in in future languages and so
if the and tahina we will formalize that
notion we've got you know dynamic
allocation but just not in the principle
it was original entrance by being in
early eighties but even - is they should
be production to be correct and in
process we found some bugs in the
stunner so this is one of the cases
where get some academic paper and you
fix the real world thing so it's really
good any nerdy bugs have to do with
virtual function dispatch during
construction
next time I'll write to provides
depreciation stuff is it compiler that's
transforming effect syntax trees so so
the concrete representation now in
traditional zone as a library but it
works at a fully typed
abstracts semantics graph not abstract
syntax tree I prefer cement I wish we
say abstract semantic graph are supposed
to ASC
because know when you have the
presentation it is no longer a tree it's
really a graph and it is tight because
types give meaning to the programs okay
when I have integer and say well integer
satisfies an ocean of rain it is on the
same as
having string so being able to
distinguish an integer from string is
very important so you don't just do some
transformation on expression trees you
look at the time this satisfies some
constraint which is unable to have rain
not just a ring you have to have a
differential ring not only that you have
to have an algorithm differential rate
so the details actually in the paper I
was soils going very fast yeah so yeah
so if you go to the open a some website
you actually get yeah I develop a
library for program analysis so it has
it comes with its syntax the compiler is
available at runtime so yeah I think
good what you detail about actually but
it has parameterize types it is
statically typed but types are instance
it it at runtime which means that you
have a reification of types at runtime
if you wanted to have introspection yes
it compiles a little BOTS runtime so but
the program programs aesthetically typed
syntactic structure
attraction is not a problem when you're
doing symbolic mathematics because when
you have your symbol is a symbol X is of
type 8 whether it's something you just
go at the wrong time interesting like
what do you do math if you want to
formalize that it is most of it at the
wrong time if you want to do everything
statically you get to a lot of trouble
now if you want to integrate a function
you first need to understand where that
function for example is rational is
elementary or it has some defined by oh
do de this is something you you don't
just look at the form of the function so
oh yeah I just led you you you try to
talk into the function this is something
you you do at runtime that by looking at
the structure running meeting the
function over some kind of test for set
of polynomials or set of equations to
see which one it's it's the root of it
no it's 0 and then we discover that you
come back oh here is actually what it is
and then you go on so it is a lot of
dynamic thing going on it just nuts
compression of magmatic is not static it
is very very dynamic so I'm not too
worried and yeah I can tell you more
about yeah open x2 how it works and and
the static typing is is achieved through
a two-level type system where you have
domains that instance it at runtime and
then you have categories will be
equivalent of type classes that used to
predict what might happen at the wrong
time and since you're doing your
reasoning not only type but on the
abstract mathematical structure you can
still do type checking and you don't
break abstraction because things like
concrete representation is not
accessible at runtime what what is I
said that one time is is algebraic
properties analytical properties
so yeah I was here and so now they think
that I would like to work on of course I
like templates I would like to have more
formal accounts of templates very
complicated I know but I think we can
get there and one thing I want to
announce is that the new student Robert
has been working on code extraction from
 development to C++ and easing C++
11 and its makes things much simpler he
is quite well addressed and I hope that
we soon will have something that is part
of the main distribution was
supposed to just being he and me having
something we put on the web but part of
me you know that way I could develop
part of libraries in cut get them
exactly to C++ integrate that into my
programs and say way I can say these
parts of my suppressor program has been
proven to be correct okay so next thing
so how I go from thruster system to lase
and come charity right so liz is this
experimental language I'm working on and
interestingly enough it brings me back
to computer algebra not that I want to
solve polynomials but trying to write a
compiler for this language brings me
back to old problems that I was trying
to avoid okay so what is lists a system
for structure what I call subject during
programming the decor semantics is based
on that curve C professor I think it is
okay now there are a bunch of things
that you can find complex about
Supersport but there is a car it's
actually well designed that I think is
good for basis for a new programming
language it is inspired by the book by
Alec Stepanov it's published in 2009
elements of programming where you try to
explain that generally programming is
really really bad and and of course I
know I was hugely influenced by my
experience
on musing axiom system first time I hear
what action was when I did my internship
at anyway I was 96 then I became
developer maintainer of the compiler and
so this lot of implementation techniques
that actually should find their way
through mainstream so I'm it's it's it's
a good programming language I believe
for studying efficient and scalable
chattering programming and lessons in
terms of design and implementation
technique I like to use that to second
effort at design C++ concept I probably
were in the C plus 2x we try to have
concept for C++ which kind of type
system for templates they get in the
starter draft and then it had to be
taken out again because of various
problems some of them ready to grow in
complexity and this time around Barry
and I got funds from funding from NSF to
do this thing again properly and and I
believe we know how to do it and but I
don't want to have all the complexity of
super stress while I'm looking at this
program so I'm taking some part of it
and looking at them in this system and
the other thing is the constraints that
we put for service concepts we believe
that for this to succeed we have to
break with commercial type checking what
I call by conventional type checking is
you have a nice interface and you're
going to represent these by some kind of
V tables and you're going to dispatch
three tables at runtime
I'm still going to fly for C++ the
reason is I'm going to five for C++ is
that if people have to move to improve
system and lose inefficiency they're not
going to do it because the premiere
discipline through a programmer knows
how to use template effectively what
you're trying to do is to get the masses
do the same thing get the same benefits
so we have to break with commercial type
checking and it is being developed as
open-source on our BSD type license you
know
can you look at the code and do whatever
I want to do it wait
finally so he started with Carla she was
at the time when I graduate I had heard
right the first pastor for Felice she's
now at Microsoft as program manager then
after that every Katzen he know I had
him rewrite part of the Sunna library
using the facilities that added and
based on his his work I decided to
rewrite the part of myself and change
completely the syntax so since last
summer I've been busy rewriting pattern
tests on is a PhD student F with me he's
actually from ECE being co-advised and
he's interested in network and secure
network protocol design and he wanted to
use the ideas from these two to the cats
you know good design for the network and
Jordan Deniz is undergrad doing research
and he has been very good at finding
bugs in the latest implementation now
know the first thing is that I like to
go back to the hidden unit and I suspect
this probably is rated to some of your
questions about a badass girl so we have
zero in programming language which is
the hilly melee attack system its
masterpiece it's it is great and it has
only four rules sometimes write five
originally it was written five but you
can have four rows and it is based on
very simple ideas you get your programs
and you know what you're doing it's
actually you have functions you apply
them and you have variable that's
essentially all and idea is that you
don't need to write tabs for your
program just write your program and
based on this structure we can tell you
whether it is well-formed
we have rules in the word form and the
compiling is always the winner is going
to infer a type and if you can supply of
time if you supplier type it's going to
be a smaller version
of where they compare I can deduce
smaller in terms of its translation
going through installation of the most
general type so what they compiled in
first is always the best you could
possibly write so you write you your
program your types and if you believe
that tab gives meaning su program then
the compiler is going to find meaning
for your program and because can have
several type that means can have several
meanings yes it's a very very simple
idea but what happens well it's a clear
success but what happens is that it's
kind of put emphasis on some kind of a
bottom-up views of how we look at types
usually will take most traditional
papers on type systems they're going to
give you some initial algebra and here's
the way you construct things and it's
what you do it one problem with that is
if you try to develop a generic
libraries very rapidly very quickly you
run into having several type parameters
so it's just a same instance when people
know develop type classes for Haskell
and they wanted to write
container libraries they realized well
it needs more than just one parameter
because containers happen to care a lot
of things we don't talk about almost
every time and so Mark Jones introduced
the notion of multiple multi type
parameter sorry multi parameter type
classes and originally sounds a great
idea till realize there's some problems
with bigger G so he introduced
functional dependencies to say well I
can have two types but one is going to
determine the order and then you can
solve ambiguities but only partially and
things started you know falling and and
so forth eventually in the two thousands
people decided well why don't we just go
back to those C++ guys and bore some of
the ideas and years being tapped rates
that's how you get associated types so
when the paper on associate types will
publish originally explicit mention of
the influence of c++ and after that
never again because now no subjective
grew up to refer back to the more formal
version so the point here is that when
you Bay
your system on a human touch system so
it's very nice and you builds generic
libraries she gets a lot of experiment
is that you have to mention again and
again again it is a distraction you know
it makes the user interface the the
suffix complexity very sick this is my
criticism of the system that isn't good
is that we want to build generic
libraries it is complicated so it is not
just alumina the same is true for
super-stretch I'm going to show you an
example so I'm going to present
something propose something different
it's so it's my experimental system
there are ideas there that probably long
scale but I do believe there's good idea
there that we should look at and that by
actually go and free us the rest of ya
the in languages okay so the first thing
is when you write your program your
library think of it as a mathematical
objects even if you're not your G meter
or you know thing is the kind of
geometrical object here you have a
surface and you have some you know the
sphere and they have some curves
algebraic curve of degree over 40 and
how would you describe this thing
would you like to use extracted
parameters to describe it or would you
prefer implicit equations take this
sphere for example as an implicit
equation just did one I'm just saying
well x squared plus y squared plus Z
squared equal radius squared some number
that's all if you prefer the primary
version you can just use one system of
parametric equation to describe the
entire sphere that's just a mathematical
theorem we need at least two now if you
need to you're going to have real antsy
now you need
current conditions between its it's
complicated what I'm saying is that in
some analogy here between this situation
and how we develop programs look at you
generate algorithms are you happy about
them
do you have the right number of
parameters and you have two more a lot
few just enough
how do you specify constraints okay now
if you take the exit parameterization
for example is this is a
parameterization of the sphere I'm just
using the insert graphic projection and
compare that with the implicit equation
this one is really nice to work with if
you're just looking literally at not a
portion of the sphere but in general
it's complicated okay
on the other hand the implicit equation
is really nice just one thing all the
other points at equal distance from the
center good okay but sometimes is very
hard to get things like you know what's
the tangent to the sphere that's a
certain point it's much nicer to do
there here okay so what actually
happened is that you can't just say one
is better than you order systematically
what you have is different ways of
looking at the same problem and
mathematicians have been very successful
at this because they developed tools to
convert from one to the other and you
need combination to be successful now
listen from here is that I would like to
propose a way of looking at type systems
differently from the initial algebra
view of type system so that's what I'm
going to talk about next what I want is
some kind of code right view so in
serratura
you essentially have some structure and
and and you look at it quite a rack you
poke you ask questions can I do this can
I do that okay if you look at the STL
for example one of the reason why it is
very successful is that it is purely
quality right it doesn't it doesn't have
any memory allocation okay it is very
functional in nature even if it is
written simpler so it's very functional
but it doesn't have any memory
allocation it's not a copy so in a place
the literature knows how to allocate it
is not the algorithm job okay no do no
transform you print many things are done
with that knowing how they're done just
you have to specify what's going ok so
here is what I don't want people to do
with extra parameter so I don't make
this I didn't make this up you can take
GCC and you look at the internal
implementation of the hash table this is
what you get you get at least eleven
temperature meters how do you know you
have them in your right order how do you
know you have all of them correctly I'm
not this is not artificial okay it's
taken directly from the edge easy source
code
I don't touch that part of GCC because I
think it is insane okay so I don't want
this so if I don't want is what what you
people do I'm sorry oh yeah so yeah if
you I'm sorry possibly I just look at no
I have a copy of this issue in my Hydra
just look at it and I'm pretty sure I
can come up with something similar to
this in Haskell okay but that I do is
much easier the fact that this is reset
is not the issue the fact is that this
is how people write it yes you're right
hash tables were not in C++ tree in the
air you see process 11 so this is a
recent version but the point is that
this is what people do because they want
to control every part so they they have
to pass at least 11 parameters now fix
no mention them I did so here look
everything is real except these dot dot
because they're here's parameters and it
won't fit on this slide so just reason
about that but you know if you have the
source code you can look at it it's ugly
but apparently it works so I don't want
this what I want is the first thing is
we spend too much time especially in
object-oriented programming world
asking what is this thing I supposed to
how can I use this and when I use it
what does it do it is actually what is
most important the ACL is successful
because I asked you to be something you
just say this is juror conditions when
you use this thing this is how it should
what it should produce so you focus on a
behavior as opposed to some kind of
glorious state of being something okay
so for example if you take this soft
function from the STL it takes two
iterators that designates some sequence
and you want to sort you can provide
your own comparison function here is a
cup so it is just some kind of you know
value of some type and I can use my own
comparator that way or I can provide 22
real function it worked great the
problem is if I even messed up and
passive wrong your arguments well I get
very terrifying error message yeah I
don't know where to start
so the question is how can i specify
constraints on these template parameters
that reflect what is supposed to do not
what they are but what is supposed to do
okay so to look at that problem that we
try that you know the past decades and
didn't work exactly as we want it I'm
very persistent
oh very precious so I'm trying again and
so what ISIL eight one aspect of it and
study it in know some experimental
language gain some understanding and see
what scares and get that back to to C++
okay so the idea is to impact a
real-world language just for some
language but looking at fundamental
problem so the codes right view is that
well I'm going to look at type checking
differently one look at type checking
algorithm
there's certain questions we ask
implicitly I watch tributing for that
specifically in language so that the
programmer can state what's going on for
the first thing is what distinguish
something that can come from something
that shouldn't we call it at all
so call that function now function
I can't defy something like function
well I have to know whether I'm calling
to the right number of arguments so I
need any primitive that gives me arity
of a function type then I want to be
able to look at its arguing positions so
this is also an input type is the
operation binary operation that gives me
the type of a parameter at a given
position and then the return type so if
you again if you look at take a
geometric view essentially a function is
is an object of n dimension or n plus 1
damage where n is the air every T and
then you use input tab and codomain as
the coordinate axis to talk about what's
going on right ok so that's it's it's
that geometric view that you form so
what I'm doing so for example if I take
the function type now point vector and I
construct a vector field for example
what are the arity is 2 and the input
type at 0 is point input about 1 is
vector and the codomain is vector field
so that's essentially what these
primitives are well now my claim is that
these four primitives are and five
because I also need a way to do when two
types are equivalent are sufficient to
conduct type checking of an algorithm in
a most abstract level so that's my claim
okay and that's what's the basis of the
LEAs projects so here I have a
mathematical so you know I want first to
prove that you can actually have in
mathematical statements of something and
have that in code that's strong okay so
here I take a notion of a homogeneous
function so a function type is it
homogeneous if it takes at least one
input type and all its input types are
the same
and we don't say anything about the
return time so the era T must be zero
must be positive sorry and for all
inputs type you have the same you know
here I have an equality no earlier on
the previous slide and say how can I say
two types are equal so I have a notion
of equality of time so here I'm defining
what I call it concepts a concept is
essentially predicates over something
and that predicate is supposed to define
an entity in the most fundamental way
anything else I should derive that from
the definition okay I suppose to having
it in my head during some documentation
okay so here for example if I take the
function distance between two points
well it is homogeneous function but if I
if they Q function translate that
translated point by a vector and
producer map why it is not homogeneous
function because the two input types are
the same but distance is the homogeneous
function even though return type is
different so this is what this notion of
concept says okay so essentially I have
sequence of you know requirement
predicate you can think of a concept as
a predicate over its argument and again
my claim is that concept would consider
the basis of type checking so if all the
input type are the same actually have
the notion of domain of the object here
I have the role that gives me the
identify notion of domain just like your
role can think of it as some kind of
something I added to C++ 11 which is
template aliases a way of having
function types of type functions
you know namely the function type
directly or way of doing competitions
with values and types at compile time so
those two things are in C++ 11 I
implemented myself ds1 directly in GCC
so it is in any recent version of GCC
and this one was implemented by someone
else now in a person what is an
operation you know
version is a homogeneous function that
have the same where the domain type is
the same as input type so here I can
state shortly what that thing is it is
code so the compiler understand ik and I
can use it to do type checking that's
it's the good part and again I'm using
type of equality an example of a
operation so if I multiplication
operation it's an operation but you know
computer you norm of a vector is not an
operation and binary operation now I
have to fix the Garrity here I don't fix
the arity not only the input types are
free to go in the direction but they are
all the same so I have some kind of
homothetic view but here I fix the
number of a parameter and again these
are sufficient to do type checking now
here is a function called square so if
you if you know you know if you have an
operation you can actually use it to to
do village squaring and so so here just
have a function that takes an operation
any value of in its domain and returns
that function so that binary function
apply to the argument right so if you
apply to call this function square with
three and and and multiplication you get
nine and if you call it with three and
addition get six okay this basis of the
repeated squaring algorithm that no it's
so basic and interestingly the type of
this function is well I take some type
alpha and I require that it satisfies
the predicate binary operator and any
input types are not referenced constants
we can domain and alpha you think here
is that in real parameter is what I want
to emphasize which is that I'm applying
an operation two things in its domain
not the parameter not the domain type
but the operation itself this is where I
want to put emphasis if I want to use
the classical view then I have to
introduce this reference T as the
parameter and then have to somehow
you fight directly the representation of
the domain I don't wonder I wanted an
additional fee of a function to be as
abstract as possible okay so here
example I can apply its own
multiplication or the addition now more
least so it is customary to every time
you want something to define type and
say oh I have a tap something of that
type but type are just carrier sets
right the the helpers represent values
and carrier sets could be cursor for
many algebraic structures for example if
stick mono leads
for example a notion of monoids we'd
essentially have a binary operation and
you have one element when you combine
with weights just return that elements
and then have so many things going on
well integers infinite integers replies
from the monoid
but if you take infinite integers and
the GCD for example it's also a modeling
structure so you can't just say integer
is similarly we have to be very pleased
I have to say with respect which
operation okay and then you see that
well you profit is very simple you want
you want to put them on operations as
opposed to the carrier set okay so here
how do I select an operation is
associative I can see that specifically
this is of the again writing code get a
compiler to check the definition and at
some point I can inform the compiler
that well and oppression actually I'm
going to assume a GCD is no is
associative
I could in a more advanced system I
could actually provide a definition of
GCD and try to prove that this was it
here but I want something that's a scale
of something that I can you know you can
scale I can get back to original CIPA so
I can't have everybody to proof but most
people prefer right algorithm not true
so the type checker I can also have a
tactical use actions desire semantics
runtime semantic properties no two aides
with a volunteer solution so if I want
to have a notion of semigroup marina
said earlier so I need know
swimming group so it's suddenly group
operation is parameterize over in
operation and I need it type for that
operation so I put it as a for all can
think this is it templates so
essentially it's the guess table type
okay what I really want to supply is a
reversion I don't care about it tap but
I need a type should I thinking get some
other things move okay and then I can
define notion of neutral value it's it's
an axiom so and if I you know there's
some value E and if I put it in
different places I get the other stuff
back and now I can states what it means
for an operation to be a moderate
operation well essentially I need to
have somebody's distinguished value the
neutral value has to satisfy that
property and by the way I would like to
be able to refer to that later on so I
introduce the rule that says well I want
to name that intro value no no II bet
I'll call it is also implicitly this is
actually a function of the operation
okay because I have some existence here
get its colonization and it turns into a
function this is a principled way of
doing type functions or associated
values currently in c plus we have
traits or in haskell have type families
and you state action they are not even
control you can control but most of them
are not controlled and they are the root
causes of many of the headaches that
haskell people have and many of the
headaches that people people have trying
to build a scale of generic programming
we want we want type functions but
wonder instructor we want to know where
you introduce a typed rate at a given
point what is the controlling condition
it is there so this is not something
that is defined by the programmer really
nearly it has to satisfy some constraint
and a program ID compares going to check
that so what do I get out of this well
first thing is that I got a shorter and
an clearcoat it have higher level
specification and it it aids for
verification and I really want to get
rid of these things okay
they look nice but they're not good for
software construction at least software
construction and so what one thing is
trying to
saying was I had students in house
another something nothing
and I said well let's look at this in a
computer algebra system because you know
we have free shot you break structures
we should be able to do something with
it so the first thing is can we do some
form of now low-hanging fruit some kind
of implicit polarization many operations
happen to be associated in a computer
the right setting
so can we get this thing actually so at
the Pascal conference we were able to
quantify you know opportunities for
implicit prioritization if we can inform
the compiler about certain algebraic
properties like acitivity natural
elements and and support so you see
which we use very frequently in
perennial system solving is all really
where we gain a lot and then in a
subsequent work got him to actually get
the compiler do programs also and
generates code implicitly and it's
pretty good yes yes
I hope yeah yeah I know I'm running a
bit yes I'll get to that and and this is
where it is still ongoing work and then
I would like to see what scale and put
it back but I do believe that reducing
the number of extra parameters is good
way to go yeah but you can combine
things I will surely be the formal
version yeah I had the Greek part of it
oh good question
it is very desirable so the this system
is implemented so that I can experience
it but currently I do have restrictions
like well certain quantifiers cannot be
nested and so that I can decide things
and the other thing is it will be very
interesting from software engineering
point of view what kind of restrictions
now if you put certain restrictions on
certain formula logical formula what
kind of programming technique you can
develop what is supported what becomes
too complicated
personally enough the FCN is very first
order in as many things just know work
beautifully and of course I would like
to test these in order now fields and
get an idea for what actually work
that's yeah but yeah in full generality
is not desirable well that's fine
even in Haskell because you know have
type classes and again to tap over
competitions and Nouveau terminates and
so ok so good thing is that part of the
algorithms that I developed for Felice
were used by Andrew Sutton who is a
postdoc with me and biani on this new
version of C++ concept so we got the I
know two weeks ago we got the ISO C
first honours committee approve a
technical they request for technical
specification so we are going to say we
want this but it committee want to have
a some formal presentation first and if
we all agree on it then we just drop it
yes that's the go and actually have an
ax student shows off me at sector
working on that with GCC just have to
keep did we get something so last year I
should design an early implementation at
CSC M and the only thing is that concept
actually no they've already into a set
of pro fabrications when we define a
generic function you use them as
hypothesis so that we came to check the
body and when you call a generate
function you have to you know provide
evidence that the proof obligations are
satisfied so that's essentially what the
idea is about so you can have now
predicates like this the it's not really
propositional formula okay you can ask
that a set on apportions exists this is
resolved through name lookup and you can
possibly
actions inside a the the concept
definition this essentially requires the
compiler to go up and see where there is
a statement by user there are certain
property holes and any have how to get
rid of tab traits okay now
so essentially have DD quantifiers so
just asking you a question you see this
halibut also this is so the full
implementation is of course on this side
of because I want to experience in
several directions but here I'm showing
essentially the part that I'm
comfortable about so I have a constraint
to essentially have a quantified formula
with three types and sometimes I want to
be able to have some type deduced like
in templates you know the template
parameters are usually deduced so easy
question ref says I want the the
deducible part an expression so this is
just a simple expressions like in the
function call function definition and
then instance a type formulas and
inverse of course any program is just
the definition of functions or
definition of concepts and when I'm
going to type checking you have to
maintain all the corrections and I have
to maintain the actions properties about
entities and of course one thing that
doesn't show here is that this is all
since I have equality between tabs I
also needs a congruence closure to keep
track of when things become a quote like
when I say code domain of F is the same
as domain then I have to maintain that
in all type checking so yes so the
implementation little bit tricky but it
works and it's actually something that
area thing is I did and I was very happy
about it
and recall so the implementation so this
position here I didn't say much about
the the monotype but it's socially
because they are expressions and then it
becomes tight by putting restrictions on
what actually it's like when you have
dependent types you have to the way you
decide everything is the type you
actually evaluate to see what's going on
and you put restrictions on yeah Ben
if you infinite types or is the issue
yeah so competitors some evaluations at
compile time
yes but only rules for example rules
essentially functions that evaluate at
compile time and we already have that in
super sauce eleven already so yeah I put
that into plus eleven last time I wrong
and say yeah you can have certain
functions it'll be simple enough and
actually it makes now completions go
forever but you know we already do that
with template this is just a better way
no it's simpler way of doing the same
thing I think in in in 90s you know
there was a desirable type system was
fashionable but discernible type system
means a lot of things it was something
sorry no something is undecidable it can
be under stuff for many reasons right
because we don't know the algorithm or
sometimes certain competitions just go
on forever and if you put a limit on
upper bound on how long you can spend
time do any computation you get some
feedback and you can increase and you
know even Houska before now every okay
with that yeah so I think it is okay now
if on this table means some competitions
can go forever
so during type checking have to maintain
congruence closures for for a topic
quality just to give you an idea about
how I elaborate this so if you take the
source level definition so this is very
pretty simple so homogeneous is a a here
it is a concept constructive so it has
type it takes a type and there is the
predicate on a tab so when a a predicate
is unary I can use it actually as a type
you know when say F colon function
actually means F is a type such that the
predicates function of F holes
okay so just short notation and they
define a concept and in the body I have
that arity has to be has to be positive
and then elaborate a so I put some
constraints on so questioner that gets
very often they know both increment in
addition wise and when I present this is
what is the theory that you have for
integers is it everything and I test you
know
see or that kind of stuff oh okay for
romance just say I can order in to use
any sense at all and I have this beauty
notion of no the integers are bounded I
can go more I can do more but I wanted
something something pretty simple and
you know once you start writing only the
basic concept a little bit complicated
to get Petroski let's find the rest it's
pretty pretty simple right here I'm just
saying that code Thurman has to be the
same as domain and domain it's the rule
so it gets a very compact time it's get
into to this form and so again equality
constraint I maintain them throughout
type checking and one slide something
very interesting is when I say that well
I have notion of Mirage operation so the
idea is that you have this function so
certain types a semigroup operation and
they out resistant elements in its
domain such that I have this relation
between F in that Annette Annette
element and by the way I would like you
refer to that element later on as
neutral element so when I elaborate this
I get two things I get of course the
definition of 108 which is just
essentially that I have you know I have
a semigroup buggy it's alpha so let's
have to be able to differ
our phones up here it's inferred from
the the the argument F here is a bug
sorry it's a our first video and then
the actual function goes from from
Webster to go from F to three concept
and the requirement is just this that I
ought to be able to find this and this
is solvable just looking at you know
database create the base in files now
the other interesting is natural value
so this one body actually is the
function is associated value this is you
know it's had families but in a
principled way it is implicitly defined
by the compiler and the compiler is
exactly when you define it because there
is a conditions on where it is and what
approach that we have with our families
in Haskell is that most of reasonably
unprincipled so when you're designing
attached
a guru type checking you have to imagine
that you'll get institutions were some
action just popped out of thin air
no in real practice wouldn't people
write real program they don't pop out of
tear they have conditions ok so if you
take that ability I don't you program
put in a compiler you can actually do
okay so this is an actual but neutral
element you know it's defined here but I
could have assumed a literal value GCD
which one yes so these are the points
where I trusted the user you talked
about the the natural value no the
context of function the area side-effect
free the function if I'm talking about
can have side effect that is fine but
these atoms are pure form are pure
expressions so so when I say this I'm
not running in program I'm stating a
property that the compiler is free every
time it is type checking and it says
this expression it is free to simplify
to this it is like these optimizations
that compilers yeah yeah yeah so if one
is this it is already happening what I'm
doing is to try to reduce the clutter if
I have the luxury of requiring everybody
to do proof then it is okay okay so the
question is this is design now you know
how much you require people to do and
how much you know you tolerates us noise
okay I'm know if I can get away with now
if I can remove tap traits and just have
these I'm very happy with that because
this is even the interpreter you know
okay they are useful currently because
we don't have a better way of doing it
but if I can take that and you replace
through this that's fine we do this sort
of time and then from compute algebra
point of view here you think so usually
people say oh 14 points numbers they
don't form a field whatever it is and
and multiplying but to be sorry addition
alpha to point isn't associated what is
true you can provide examples and
showing that this is an associative but
if you know your input data this is set
on that that assumption becomes true as
a matter of fact this is real thing one
of the fastest modular algorithms
working on integers uses fourteen point
double to present integers because it is
where around 32 bits and you get no 53
bits and why are you running your
program on on your machine the CPU is
busy doing arithmetic operations and
decoding instruction why the
floating-point units just sit there
looking at what's going on so if you
move the data show it to the tree to the
FPU well it works because you know your
input set of course that assumption is
not true in the absolute mathematical
science but you know you input set and
that's what matters and this is like a
library in that develop it's one of the
fastest library on modularity pretty
pretty pretty neat idea okay so where am
I oh okay so you get know this and
currently you have some feedback
Andrew southern who is a postdoc with me
you know implementing part of these
part of the idea is some of the scale of
ideas into GCC and we want needs to get
into the concept technical support and
Michael his period is been working with
me for a year and a half he's working on
next genetic parts in GCC so things are
moving pretty good I hope that we'll get
some purely a pop-up paper soon it's
going to be harder for Papa but PGI is
really good so for future work I would
like to have less segmentation fault you
know you know polish the implementation
and and and get Jason a test more
network is pretty any brilliant idea
about how to use some of the constraints
for a network protocol and so people
like contract programming by contract in
that kind of stuff so I'd like to
understand much better you know
yeah very so of interpreting actions
yeah things that you just assumed for
optimization purpose or are things that
you actually check at from time and with
part of it now some of them you cannot
check at run time for elliptic last year
defined algorithm for example assumes
that we the two iterative to give one is
reachable from the first and that
essentially is running yogurt so you can
check that systematic at wrong time and
of course I want you know for more
account Felice and yeah can we trust
usually time this is the design point
that have to look at okay I'm ready to
take questions
okay Greg vocab he will hear an
interview for the next that's two days
and thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>