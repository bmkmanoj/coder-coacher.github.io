<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Systems, Science and FreeBSD | Coder Coacher - Coaching Coders</title><meta content="Systems, Science and FreeBSD - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Systems, Science and FreeBSD</b></h2><h5 class="post__date">2016-06-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_oWcfUt9QUs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year Microsoft Research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
okay I guess we can start so it's my
pleasure to have jobs visiting us today
I'm sure many of you know George from is
a column on the ACM communications of
the ACM code vicious and of course your
terminal form is involvement with the
FreeBSD community where it's been very
active both from a development and
research perspective as well as teaching
perspectives and in fact is here in
Cambridge because is designing a new
master course for operating system in
the computer lab and today it's gonna
talk us about the FreeBSD and how
they've been using it as a research
platform and George thank you good
afternoon my name is george o'neal and
i'll be talking about systems science
and freebsd so what is FreeBSD I'm find
it a bit amusing to be given a talk on
an open-source operating system in this
particular venue
I think but it should be good fun so
FreeBSD is a complete integrated UNIX
system what we mean by complete is when
you get it you don't have to install new
packages to develop software on it the
original goal of all of the BSD s
including FreeBSD is that when you get
this one thing you can actually start
doing work immediately and you'd have to
start adding stuff to it
modern multi processing multi-threaded
pre-emptive kernel works beautifully on
S&amp;amp;P Hardware UNIX POSIX BSD programming
interfaces which are familiar to people
which are very familiar to people from
long usage extensible debugging tools
both for user land and kernel kernel
debugger usual and a bugger and a number
of tools that I'll actually talk about
later in the talk multi-protocol network
stack so one of the things that the bsts
and freebsd have had for a long time and
one of the things that a great deal of
research has done on is on network
protocols so it's very important that we
have the ability to add new protocols
not just the ones that you see on the
open internet but new protocols are get
used in terms of research unified
coherent build system across components
we can build natively or cross build so
that we can do embedded research as well
as research on sort of more common
server server architectures extensive
documentation one of the things that
Paula mentioned is that I
we work on the code but I also work on
the text FreeBSD is an incredibly
well-documented system there in a month
there will be a second book about the
kernel which as my second book
co-authored with Robert Watson at the
University of Cambridge and Kirk
McKusick who's been working on BSD for
quite a long time so it's not just a
kernel and it's not just the user space
it's also a huge family of ports and
packages everything from systems like
zookeeper or editors or other compilers
or whatever tools people need to do
their work those exist is what we call
third-party software ports and those
have all been adapted to run on top of
the operating system so it's this entire
package of the kernel the user space
utilities documentation and then all the
third-party tools you need to do it work
who uses FreeBSD quite a number of
people it turns out some of them
seemingly pop up out of nowhere some of
them we know pretty well
Apple Yahoo whatsapp which is pretty
amusing at the moment given what
Facebook paid for them
Netflix juniper has a whole list here
FreeBSD exists in gaming systems like
the ps4 filtering systems from Cisco and
Norris storage systems from EMC
which formerly Isilon HP and NetApp so
it's used in a lot of places and why
that's important is while you probably
are really interested in how you use the
system to do research a lot of people
really like their research to be applied
so one of the nice things is that things
that get researched in FreeBSD
eventually wound up in products and
eventually wind up in the real world and
that's a really nice story to be able to
tell about tech transfer from research
to industry so FreeBSD is not just a
collection of source code that it exists
on a bunch of servers it's a project and
it's a project that's carried out by a
large number of people worldwide the
project itself breaks down into several
different groups all of which who all of
which whom work together to produce the
system we have what are called source
commuters these are the people you would
think of as committing
the kernel code or to use the land
utilities just 300 of those people who
have access to the central repo and can
update the kernel on an ongoing basis
prior to release the ports when you have
24,000 ports you can't support that with
a small number of people so there are a
large number of people in the world who
all they do is maintain a few ports that
are shipped with freebsd as part of the
ports collection so there are several
hundred of these people some of them
will work on one or two ports some very
adventurous people will work on 20 or 30
ports I can't even imagine maintaining
20 or 30 ports myself that sounds like a
lot of work large independent
documentation team you don't get great
documentation out of developers you're
supposed to laugh at that joke sometimes
you do but not often so one of the
things that FreeBSD and the BSD s have
always had is a commitment to really
good documentation so that people can
use this system we've always produced
books and papers and all of these other
things an internal documentation and so
to that end there's a documentation team
some of whom work on code but many of
whom take what the developers have
written in the code and explain it so
that other people can actually use it
and then thousands of individual and
corporate users there's people who are
installing this or around the world and
building it into products and using it
in universities and I'll talk a lot more
about the university research later on
the whole project is led by a
democratically-elected core team of nine
members I have served on that core team
I serve on that core team now the core
team does not set a specific technical
direction there is no central dictator
to the FreeBSD project the core team
exists to make sure that everything goes
smoothly so if there are technical or
personal issues between people on the
project they bring them to core and then
the core team tries to figure out how to
come to a good agreement between those
people the core also often acts as a
public face of the project as does
lastly the FreeBSD foundation so FreeBSD
project has no legal standing it does
not exist in terms of you ask a lawyer
the FreeBSD Foundation exists to hell
the project we get financing for the
project and we interact with lawyers
when we have to because things that
happen in the real world have to deal
with law so the foundation is the group
that holds things like intellectual
property rights for the project and in
this flood I mentor I mentioned
mentorship one of the things it's really
important to the project when you've got
a group of 300 volunteers and you're
trying to get them to all produce
something and work in one direction if
you think it's difficult to manage
people who work for you it's really
difficult to manage volunteers and so
it's really important on the project is
that we involve people in the project
through a mentorship process when people
want to contribute to FreeBSD first
they'll join the mailing list they might
send some questions eventually they'll
send some patches eventually they'll
send us enough patches that will get
annoyed and decide that we should and
what we call inflict a commit bit on
them so we should make them commit their
own patches but we don't simply turn on
their commits that we give them commit
access but then we connect them with
someone else in the community who's
going to help them in in terms of
getting their code into the appropriate
style all of the code in FreeBSD follows
a style guide called style 9 named out
of the manual page getting appropriate
tests getting appropriate interactions
and basically helping to integrate that
new developer into the FreeBSD community
so mentorship is an incredibly important
part of how the project works and how
it's been able to survive for 20 years
so FreeBSD is one of the longest-running
democratically run open-source projects
that's ever existed other projects may
have lasted longer but there are very
few as last as long as this so I'm came
here today to talk about FreeBSD and
systems research this is an area that's
very interesting to me and I think very
interesting to everyone in the audience
so FreeBSD is a derivative of the
Berkeley software distribution which was
started in the late 70s early 1980s at
the University of California at Berkeley
and CSR gee the computer systems
Research Group that built the original
BSD built it as a research platform one
of the reasons that that work got funded
by DARPA
was so that there would be one platform
on which everyone could do systems
research and share their results instead
of everyone building a tiny little
operating system specific to whatever
hardware they happen to have in their
basement the idea was that with a single
platform on which to integrate
components and run tests and deploy
systems systems research itself could
move forward much faster and and this is
actually what came to pass so starting
in the late seventies early eighties a
large number of fairly important bits of
research were done on the early bsds
including one of the first commercial
well one of the first integrations of
virtual memory into a large system fast
file system which I'll talk about later
incredibly important for the development
of the Internet protocols tcp/ip and the
sockets API the sockets API that
everyone has used pretty much on every
operating system since was developed
first for BSD later on Berkeley packet
filter and in all of the bsts
the first versions of ipv6 so the
versions of ipv6 that most people use
today developed by the comment project
in Japan and there's one of the earliest
references to a paper on the BSD s done
by ozawa bugaloo and William joy about
the virtual memory system integrated
into the internal BST so BSD lasted for
a large number of years and the project
finally ended and then the 1990s and
then several projects respond off of
that bsd 386 openbsd netbsd and freebsd
which is the one that i work on in terms
of FreeBSD and systems research well
what some of our motivations
well like the original BS DS we really
want a platform on which to build we
don't want to have to build up you know
fake operating systems for those who've
taught classes or taking classes in
operating systems often they're taught
on non production operating systems
operating systems that never will see
the light of day in real products
they're only going to exist at your
university or some small number of
universities but what we wanted was a
platform on which we could not only do
experiments but which if those
experiments were successful we could
ship that code to other people a large
number of other people who would use it
in deployed systems throughout the world
one of the things that's really helpful
in systems research is to have a very
large number of systems running your
code because you can't simulate the
internet you can try but it's like
boiling the ocean and so it's much
easier to just give your code to someone
who's going to connect it to the
internet and see what happens
so hmm very strong emphasis on tools the
FreeBSD project really likes to build
tools because we like to be able to make
good statements about measurements and
we have a very strong commitment to
measurement and to measuring results
presenting results and then writing and
sharing those results so what makes a
good platform for systems research one
of them is reality and this is something
I've been referring to in the last
couple of slides is that it's a real
system that's executing on a lot of
machines that people use there aren't 10
of them there are millions of them
another is consistency one of the things
that you need for good software
engineering but also for good science is
a consistent platform on which to make
your measurements if the platform you're
working on changes every week or every
month or even you know to some extent
every year and you can't find the
previous system that you worked on or
it's very hard to track the previous
system than you worked on then as you're
making measurements over time it's very
difficult to say something about the
measurements you've made because they're
not going to be comparable measurability
being able to measure what's going on
having a large amount of infrastructure
in which - having a large amount of
infrastructure that allows you to
measure the changes you've made analysis
tools and finally a choice of
open-source license really matters so
I'm going to talk a little bit more
about consistency FreeBSD is very big on
consistency we believe in regular
releases and we believe in what I call
KPI and API stability and it's easier to
show this is a graphic so here's
our current tree - I have a laser here's
our current tree and the way software is
developed on FreeBSD is in the following
way you see this line going upwards this
is what we call the head of the tree and
the head of the tree is where all the
new features go all the new research
goes when people have some hopefully not
crazy idea but sometimes we call them
crazy ideas but it's not so crazy that
it can't go into the tree that it's
going to go into headfirst and as as we
add features and as we had things to the
system eventually we come to the point
of making a release we try to make
regular releases and we hit them more
often than not so at some point we
decided ok it's time to have released
nine of FreeBSD and once we cut a
release that's called the stable branch
so now we have a branch in which no
kernel api's will change the size of
kernel structures will not change and we
will not change the programming API for
users so if you built an experiment on
nine anywhere on nine it will always
execute now device drivers change people
change code people fix bugs so you may
not get the exact same measurement along
this entire branch but you won't get
wildly divergent results and your code
will not stop working your code will
work for these branches last for two
years of active development and that are
kept around for three to five more years
for security fixes companies that have
integrated the code have actually
remained on branches far longer that
presents some problems if they want to
then eventually get to a newer branch
because this is a is a jump so what we
will not do between major releases is we
will not preserve all kpi's now we don't
you know go higgledy-piggledy and just
break them because we're that way but in
order for the operating system to
advance you have to be able to change
api's you have to be able to add them
which isn't usually a problem and we you
know remove them occasionally but it's
when you change them or you change the
contract between the program and the
kernel or components of the kernel that
you would get changes between major
releases so as the operating system
advances we
head forward eventually the next major
release will be 11.0 sometime next year
and then we will have an 11 dotto stable
branch and we will deprecated the nine
branch in order to keep our release
engineering team from committing suicide
we try to reduce the number of major
branches that we keep excellent at any
moment that doesn't mean that other
people can't keep them many people
mirror our tree and they hold onto
branches much longer if they wish to do
work but in particular if they're
producing systems like appliances so
when people build an actual object and
they ship that object often they don't
want to upgrade because they know what
the hardware is and they know how it
tested but in terms of research it's a
little easier to follow this along
there's one more thing I want to mention
when people add new things in the head
there are always candidates to be merged
so if that feature or that idea or that
concept is one that can actually be
moved back into a major branch without
it disturbing the other components of
that branch new device drivers is a
clear example of this you have a device
driver here adding it back into an older
branch isn't going to cause a major
problem but there are other things that
we can add people have added you know
different file systems and support for
other systems that were that were new
and therefore didn't disturb the rest of
the system that's called a merge from
current MFC so if you ever look at our
source tree you'll see commits called
MFC and what that just means is oh
someone did something here that's really
cool and useful we'd really like it to
be in ten or nine or some previous
release it's this commitment to regular
releases though and to good software
engineering that makes it a good stable
platform for people who've worked on
platforms that are less stable or looked
at platforms that are less stable you
know how much trouble it would be if you
ran a bunch of experiments and then six
months later came back and all over your
kernels were completely different I said
that the license was really important I
am NOT a lawyer I get to say that every
time I get one of these presentations so
the way I characterize our licenses
don't sue us we would really like you
anyone to use our code and we really
want to share
what we've built and we really want to
share results so in order to do that
we've created a license completely
different from the GPL that has been
used for many years now it's been
originally developed at the University
of California at Berkeley and it
continues to shrink which is kind of
amusing when the license was first
written up by the University of
California lawyers and the CSR G team it
had four different things for clauses
it's now down to two clauses I'll be
very amused if I ever got our lawyer to
simply just put don't sue us but I don't
think that's gonna work so unlike a GPL
like license which says that you must
give back any modifications you make the
BSD license doesn't say that direct it
says you can do it you want you don't
have to give things back now many people
have pointed at that as failing of the
license because it means that we
sometimes miss out on innovations that
people have added based on our code that
you know people have extended our code
or modified the kernel in such ways and
we don't get to share in that but we
believe that it's more important that
more people run our code than that we
get control of what other people have
done we look at it as saying that this
is our code this is what we've done
please use it and if you would like to
give things back which many people do
and many companies do then we were
willing to take them and we would like
to work with you but we are not going to
force you to give us things and because
of this research on FreeBSD cannon does
go into directly shipping code and I'll
talk about that in several examples so
I'm going to talk very broadly about
three areas of research today and try to
highlight some of the areas in which
FreeBSD has been used very recently some
of the papers I'm going to cite haven't
been published yet they've been listed
for their conferences but they actually
haven't been presented three broad areas
of research file systems networking
insecurity not that these are the only
things that we do but because when I was
looking at all the work I wanted to talk
about they broke down naturally into
these three areas so the fast file
system is kind of amazing fast file
system was
first developed in the early 1980s as
part of the original bsd original paper
on this is from 1984 and i graduated
high school in 1985 so it's you know
from before I even started programming
operating systems it is the longest live
filesystem development project that I
know of
certainly ongoing it currently supports
journaling soft update snapshots in fact
what's most interesting about the fast
file system isn't just that the original
design was a very good design it's that
it was an extensible design in fact I
like to think of the fast file system as
the project that launched a thousand
other file systems papers and every time
someone went and developed a new file
system like large structured file
systems or they went and did journaling
or things like snapshots McKusick and
other people working on the fast file
system would turn around and say oh
that's a really great idea I bet we can
make that work in ffs and they would
just integrate that and then there would
be another paper so it's a it's been a
really interesting platform for file
systems research for 30 years and it
continues to be worked on today then it
met its maker hmm
so the fast file system is excellent for
systems of gigabytes but some
Microsystems wanted to build very large
zettabyte file systems which is where
the zed comes from in set FS this is now
the big file system in freebsd
so this is originally done in
opensolaris under a CDL license which is
I am not a lawyer again a slightly
different license to be asti but one
that is not completely incompatible so
son built this system that can handle
incredibly huge file systems and has
become the place where people who want
to work on big storage go to do their
research so things like raid-z
compression and just seeing what you can
store in massive file stores of you know
terabytes petabytes huge amounts of data
that's currently done in ZFS and at the
moment those are the two major file
systems and those are the two areas
where almost all file systems research
gets done from system
research from assistants research
perspective on FreeBSD moving on to
networking so networking has always been
one of the major areas in which the bsds
of exotic selled the earliest not the
earliest implementation of tcp/ip but
the earliest widely shipped
implementation of tcp/ip existed in the
early bsds and has continued to be
updated modified and improved to the to
this very day it's also the component of
the system that is most often lifted so
early Windows tcp/ip stacks for the
Berkeley stack the tcp/ip stack that
exists in the embedded systems that
currently wander around Mars which I
actually worked on are all based on the
early bsd stack they took the code right
out of it and took it with the BSD
license to put it into the product so
it's an area where there's always been a
lot of active research and I'm sure
people in this room know the work of
Luigi Rizzo at University of Pisa one of
the earliest things he did in the
FreeBSD stack was to add a system called
dummy net and most people now think of
dummy net as a component of IPFW which
is used to do far walling and in the BSD
s but actually it was originally
intended as a way of evaluating TCP
protocols because if you didn't want to
simulate the whole internet it would be
much easier to pass your flows through a
machine that could do things like create
delay lines or drop you know packets
based on some algorithm rearrange
packets so this was one of the earlier
contributions from Luigi into FreeBSD
and this wound up is a sitcom paper
never one to sit still I believe which
is actually given a talk here on net map
so net map is currently the big exciting
thing for Network and systems
researchers using FreeBSD it's also been
ported to other open-source operating
systems but it does not show up by
default because it has not been accepted
into their source tree so when you
install freebies
you get this system called net map and
what net map does is it exposes hardware
it's exposed the cues in the Rings from
a Nick into Hardware allowing people to
build incredibly fast and complex packet
protocols on top of the operating system
and this supports a variety of hardware
from Intel and Chelsea oh and others ten
gig in 40 gig NICs
and using this someone else well talked
about talked about later is actually
built networking applications that can
completely fill a 10 gig pipe on
commodity software and hardware that's
what we're gonna talk about now so some
very recent so recent that it will
appear in about a week at sitcom work by
Ilyas Marino's Robert Watson and Mark
Hanley took the net map system and they
thought well what can we build on top of
this of this that would show how fast
commodity hardware and software it can
actually run and so they built sandstorm
and named storm sandstorm is a static
content web server named storm is a name
server they both sit on top of net map
and what they've been able to do is to
show that you can use commodity 10 and
40 gig hardware to get 10 and 40 gig
speeds pink with a come out of the
operating system if you have the right
api's and it turns out that Netta net
map for certain types of protocols is
exactly the right API in particular if
you want high bandwidth it's definitely
the right idea because what you need to
do is to get directly at the hardware
and to get everything outside of the way
another interesting thing that's come
out of their research and if you looked
at the paper which is currently online
you'll find that the performance of
Linux and FreeBSD which are compared to
sandstorm and named storm have almost
exactly the same curve that is they fall
off in the same places and they increase
at the same places and there's a really
interesting reason for this a lot of
people believe that if you replace all
the lines of a piece of software that
that software is going to operate
differently it turns out if you replace
all of the lines but you keep the
structures and the API is the same
that's
we will operate in the same way and so
while the Linux stack was originally
derived from the BSD stack and then
completely rewritten the fact that its
data structures and API is and how the
cake is cut within the stack are almost
the same means that the FreeBSD in the
Linux stack operate almost the same now
as they did 10-15 years ago when they
when the code was originally pulled out
and branched some folks swinburne do a
huge amount of really interesting TCP
research I actually feel they do
interesting TCP research because
Australia is so far from everywhere else
it's a really good testbed for long
distance networks we used to have a
saying at a company I worked out where
we had colas in Australia and the joke
was don't ping the Australia colas
because every packet is 25 cents so the
folks in Swinburne have done some really
great work around TCP in particular and
of interest to to networking in systems
researchers is sifter so what they did
was they put a complete logging
framework for interesting TCP changes in
your TCP flows into the kernel so the
way most people do TCP research is
they'll they'll either create something
in a simulator or if they've got real
traffic they're looking at TCP dump
style traces to speed up another thing
created in bsd but what you're doing is
you're looking at the packet traces
without looking at the actual machinery
as it runs so sifter puts in logging to
the kernel that puts out interesting
events as the Machine state machine runs
so you can see things like how my
congestion window is going what are the
scaling factors what is the actual state
of the finite state machine for TCP what
is what what does each side of the
connection think the smooth round-trip
time look at looks like these are all
really important if you're doing TCP
research and it's far easier to record
it at the source and the sink and then
deploy it than it is to try and get it
back from a bunch of traces
that's a bunch of the networking work
that's been done I want to talk a bit
about tools at the moment so one of the
systems was developed independently of
FreeBSD although happily with the BSD
license was LLVM so most people now know
about LLVM and clang this is a modern
extensible system for building compilers
until LLVM came along most people who
are not using commercial development
environments we're using the new tool
chain if you've ever looked at the canoe
tool chain and you've looked at the
canoe compiler then your eyes have bled
because it was not meant to be
extensible interacted specifically
written against extensibility to prevent
it from being to prevent it from being
effectively reused in ways that its
original author did not want it to be
reused so LLVM took a completely
different approach they wanted a modular
toolkit for building compilers and
running experiments on on compilers and
thinking about how they could do
optimization and thinking about how they
could learn about performance as the
compiler ran a really amazing system
that they produced a couple of things
happen at the same time there one was
GPL v3 which was even more draconian
than GPL v2 came out and companies who
wanted to ship compilers like Apple
realized they needed a new compiler and
projects that want to be able to ship
code that is not going to poison their
downstream vendors or people who use it
like FreeBSD also wanted the same thing
luckily Apple had money and we had hands
so Apple went and hired the entire LLVM
team and then built a huge team around
it and built that into their compiler
and the FreeBSD project adopted that
compiler as the base compiler for
FreeBSD itself and this has had some
really nice effects in terms of the kind
of research is now being done on FreeBSD
so a couple of things we're done both at
urbana-champaign to look at how the
compiler could be used to generate more
secure systems now coffee which I'm told
is pronounced just coffee is a system
built by these folks at urbana-champaign
to lock out return oriented programs so
to make it impossible for things that
try to manipulate the system in a way
that return error into programs do from
running that was done using LLVM - you
know I was done by using LOV m to
implement the secure virtual
architecture and within SVA if you look
at the sba papers you can see how they
use this to prevent our LPS from running
they chose freebsd because freebsd was
already being built with LLVM so they
had an entire computing base that they
could build with the compiler they
wanted to use to prove that things were
safe so they use FreeBSD 9 because
FreeBSD 9 while it didn't completely
have LLVM for every architecture hat was
able to be built with clang the C
language compiler from LLVM they then
went on and also did this thing called
virtual ghost which is a way of
protecting applications from hostile
operating systems by introducing a very
small hardware layer generated by LLVM
to prevent programs from getting at
certain bits of memory so these are two
papers from 2014 that are all based on
the work with LLVM and freebsd in
combination
virtualization so previously was a
little late to the virtualization again
in part because the way in which a lot
of people use virtualization was to run
for instance multiple copies of a web
server and you could already do that on
FreeBSD with a system called gels you
could protect people from each other
without creating an entire
virtualization system and so the drive
for a virtualization system wasn't there
and if you wanted to run FreeBSD on a
virtualization system well you could do
that on anyone's but eventually one
bunch of people that NetApp decided that
they really needed a BSD licensed and
also legacy free hypervisor and what I
mean by legacy free is that a lot of
hypervisors have to deal with
architectures on which there are not
virtualization instructions and the
folks at NetApp said we do not do that
we're only going to ever ship on modern
hardware all modern hardware has
virtualization instructions and probably
always will so why don't we get rid of
all of this legacy and and do some to
work so would be hive they created a
virtualization system that can host many
different operating systems not just
freebsd in ten thousand lines of code
which is pretty small compared to what
most virtualization systems require so
beehive is currently the the
virtualization system used by most
people in pure freebsd environments and
turns out that doing this work has
generated some interesting reuse cases
again for research one of the places
where it's being reused is a system
called OS v which they call a
virtualized operating system this is to
run JVM directly on top of a hypervisor
so that you don't have to run JVM on top
of an opal on top of an operating system
on top of a hypervisor osv leverages
components of FreeBSD and also runs on
beehive as well as other virtualization
technologies though see folks realized
there were a bunch of components they
could get directly from FreeBSD like ZFS
in the network stack and so they'd pull
those right out so there's a paper
that's going to show up in that is
already shown up in the 2014 used to
expand ATC annual
conference now that was done by a
company Claudia systems other
hypervisors so freebsd also works with
Zen which was work contributed by Citrix
that got Dom's you're on x86 and arm and
some of you may have heard of hyper-v I
hope so
the FreeBSD project worked directly with
the hyper-v folks at Microsoft to make
sure that FreeBSD ran well in Azure
so we got all the drivers ported with
them and there are now images of FreeBSD
available to you in the VM Depot for
sure if you want to run that nothing
about research would ever be done
without talking about formal modeling so
there's currently two interesting
products there are currently two
interesting projects that are utilizing
formal modeling with FreeBSD there's an
effort currently underway at Cambridge
to run FreeBSD on a system called l3 and
l3 implements the mips is a in a formal
model this has generated some very
interesting results for instance we're
finding or they're finding undefined
behavior in the mips is a certain math
operations that are really not well
defined it allows us to verify both the
ISA and the operating system against
each other so this generates some very
interesting discussions because most
people are used to the idea of well is
it my program or is it the kernel well
this is is it the kernel or the formal
model you have to figure out if the
formal model is broken another effort
being undertaken both at ut-austin now
and also in Cambridge by Warren Hunt UT
Austin folks have a complete formal
model of the x86 so they can run x86
programs directly in a formal model and
ask all kinds of interesting questions
about the nature of the code being run
run under it so they can eventually they
will eventually verify the entire
trusted computing base on this simulated
processor
the problem is that when all you have is
a simulated processor you need some
other parts like if you want to run real
programs you kind of need a console and
you might need storage and you might
care about networking but you certainly
need a console because just being able
to load a program into a formal model
doesn't mean that you can interact with
it in any interesting way so one of the
places where the beehive work is going
to show up in research is that parts of
beehive are being reused in their formal
model as the execution environment that
acts the same way your system board
would and now we come to security so
there's been all a long history of
security on security research on BSD
systems the capsicum work done in
various places but a lot of it has been
done at the University of Cambridge
really brought capabilities back most
people who had even heard about
capabilities never believed they would
see something that actually used them
because the belief has always been that
capabilities are far too expensive and
they aren't you know going to be
performant and that systems that don't
have capabilities are always going to be
faster and no one's that we're going to
do that and there's currently a computer
that was built for capability sitting in
the hallway at the computer lab at
Cambridge on the cap computer but
capsicum change this capsicum was work
done on FreeBSD and it introduced
lightweight capabilities for UNIX and
allowed the sandboxing of applications
so for instance ping and TCP dump and
procs that and you might ask well who
cares about sandboxing TCP dump how
dangerous could that possibly be so one
of the hacking competitions it takes
place every year the first thing people
do is they try to send packets well one
set of people is trying to look at
packets on the wire and the other set of
people are attacking those packet
captures by sending packets they know
we'll be able to route TCP dump because
TCP dump has to run his route so if you
know someone on your network is running
TCP dump and you route TCP dump then you
have routed their system so it turns out
programs that run his route and read
packets from the wire that's the first
place you actually want
start doing some protection ping T
spinning up rocks tat and the capsicum
includes a set of API is that extend the
operating system so that you can do this
fine-grained decomposition of programs
some of the other work that's been done
on top of FreeBSD because of the
security features that exist in it as a
recent set of papers from the folks at
Harvard where they've created a
scripting language not unlike a shell
scripting language and actually intended
to replace shell scripting languages
called shil so this is built actually on
top of the Mac framework the components
inside of she'll acquire and dealing
capabilities and very likely we'll start
using something like the capsicum system
in FreeBSD because it's already
implemented on top of it to create a
secure replacement for any one of the
shell programs and so things that people
normally deal with I mean think about
what shell programs do usually shell
programs is doing things like running
his route to install software on your
system well that's not a place where
you'd want security so it's probably not
that important it's incredibly important
so the components in she'll like file
objects when you open a file or you get
a file or sockets when you communicate
with the network or even environment
variables can be wrapped within
capabilities and that means you have
this way of the shell programmer has a
way of saying that only certain things
need certain capabilities and only
certain things will get them they have a
whole language for expressing this and
that's all based on work done at Harvard
and then done using FreeBSD so I
mentioned capabilities and how people
claimed that they would be very slow and
there's always problems that so one of
the things that the folks Cambridge
decided to do is to start investigating
in modern boundaries in the hardware
software interface and they developed
two systems berry and cherry berry is a
blue spec implementation of the MIPS is
a implemented isn't if an FPGA and it
comes with an extended version of LLVM
which is all currently in freebsd so if
you get this hardware platform you have
a complete system for doing
research on the hardware software
interface you have an operating system
you have all the tools to work with that
operating system and you have an open
source piece of hardware that you can
actually you know burn yourself with an
FPGA burning kit or building kit in
order to do your own experiments and you
can find that at very CPU in terms of
the capabilities work you cherry can be
thought of as a security extended
version of berries so all of the things
that make capabilities slow the fact
they're not implemented in hardware were
then added to hardware and so chary
actually has support for capabilities in
the instruction set architecture and the
memory architecture again like barry the
platform and designer open source so if
someone now wants to do research on
capabilities on a system where
capabilities are actually built into the
hardware they have a complete open
source platform for that as well they've
got the compiler and the operating
system and the tools and the hardware
and all it requires is electricity in an
FPGA
so I want to come to some of the more
recent work in terms of thinking about
how we're going to move forward with
systems research on FreeBSD and one of
the biggest boons to this area although
I don't know that the original designers
thought about this at the time has been
something called DTrace so almost every
version of any of the open-source
operating systems and probably the
closed first ones as well have some form
of tracing for debugging DTrace was
really a major advance because it was a
complete tracing system it dealt with
the kernel in userspace we imported it
into FreeBSD six years ago now John
Braille imported it it's been
consistently extended there's a huge set
of scripts but what DTrace really gives
us is unlike systems where you have to
hand add your trace points it builds
them automatically for you the build
process in FreeBSD will now build all
the trace points you want automatically
and so for instance every single system
call and every single function call in
the kernel or anything else you compile
with DTrace turned on will be torn down
and reassembled in a way that DTrace can
understand so this means well this meant
to the folks son who built it that when
they deployed systems if there were some
performance problems in the field they
could actually have someone go in and
turn on addy trace filter or addy trace
program and actually get information out
but what it means for the developer of
an operating system or of a set of tools
is I don't have to think about what
trace points I'm going to add I don't
have to add trace points for locking I
don't have to add trace points for many
of the subsystems unless I want
something very specific in the middle of
a function but if I don't need something
very specific in the middle of a
function it's probably there already
it also gives a consistent measurement
framework if you look at the history of
tracing systems and and you look at
things like s trace and K trace and all
of the other systems that have ever been
built for all of the other operating
systems that are existed they're all
slightly different and within the same
operating system you have a history
either updating them or changing them so
if you think of things for instance in
FreeBSD we have a system called witness
which shows things about lock order
reversals well that was hand coded we
have something that shows scheduler
issues that was hand coded now we're
gonna stop hand coding right I mean we
might hand code a few small things but
we've got something that automatically
generates that gives us his amazing
visibility into all types of code it can
not only look at function calls or
system calls they can tear down data
structures so now I want to ask
questions like sifter asked about TCP
well I can get directly at the TCP data
structure and I can ask questions about
it at runtime it has built in basic
statistics this is something that most
systems researchers and most researchers
really want like give me some
statistical information on the data
you've caught and so the D scripting
language gives us that it's extensible
also it's nearly free when not used so
when not in use there are no instruction
replacements the way that DTrace works
is at runtime it will replace a single
instruction where the function call is
going to be called with a different
function call and so that introduces
overhead but you can ship a system with
dtrace compiled in without paying even
the cost of an if statement
I'm just the typical cost of most
tracing systems so what does it provide
function boundary tracing this is the
you know 30,000 trace points in the
kernel which are just what the compiling
system was able to rip out by looking at
the the function boundaries system calls
a timing source called profile so you
can do things like build scripts that
periodically look at things proc io
we've added NFS and we're gonna be
adding a ton more providers it's pretty
easy to add them and here's the one of
the ways in which we're going to apply
this and how this comes back to systems
research again so I mentioned at the
beginning that one of the things I'm
doing in Cambridge is helping Robert
Watson develop a new masters course in
operating systems at the University of
Cambridge and so what this course is
going to do is it's going to use tracing
as its method
to teach students so when I took
operating systems a long time ago we
were given a toy operating system shown
a few things and allowed to create
ridiculously trivial device drivers and
if you've ever read a device driver for
most operating systems you'll realize
that people who write device drivers
don't actually understand how the rest
of the kernel works anyway so I don't
know how that method was ever supposed
to teach people operating systems and I
don't think it did so the new method
that we're gonna try out is to actually
show students complex data structures
and interactions within the kernel at
runtime using the tracing and they'll be
able to see things like locking and
scheduling behavior without having to
change the scheduler as their first
attempt they won't have to build their
own system to figure out what is
actually going on they'll be able to
look at complex TCP flows and they'll be
able to do real performance analysis
with real experiments so the lab
experiments in the class will be using
de trÃªs and performance analysis to
actually show what happens when they
make changes so conclusion
FreeBSD it's a platform for systems
research oh and it's a system that's
shipping in products but it's also a
system being used extensively by
researchers to do this kind of work the
true set of tools low-stress business
compatible license and as you can see
from the timeline this is not everything
that's ever been contributed but it was
some of the things I talked about today
in the nearly 35 years of contributions
to systems research and everything you
need is a FreeBSD org any questions
yes so I can't really see people so
father if you can point of people I've
got the lights right on so there are
several tools used for the for the tape
the question is can I talk about more
about measurement there are several
tools used to apply measurement to
freebsd dtrace is one of them and I
think DTrace well I'm currently working
on DTrace so of course I believe the
DTrace will eventually be the
centralized repository of all
measurement but in terms of doing things
like performance analysis on
instructions and caches at runtime
there's a system called HW pmc which I
also work with which exposes chip level
performance counters to analysis tools
so if you're trying to collect a trace
of how many instructions are executed
between two places that's done using
something called PMC other other
performance tools generally work off the
two of those or people will do
performance analysis or systems analysis
using the exposed counters from every
system so there's no sub system in
freebsd that doesn't have a wealth of
you know counters of what happened to
the system because we really believe in
that kind of visibility yes I can see
actually yeah huge number of people
still use Linux I don't know why well I
asked you do you know why what is
missing from FreeBSD what could you guys
do to entice I mean it seems very
important to you to have a large
installed base right diverse one as well
so there's a couple of answers to that
question so one of the reasons that if
you look at the uptake of freebsd in
linux and you see linux ahead is that
the bsd folks got into a bit of a lawyer
discussion with AT&amp;amp;T and so that delayed
for several years the release of the
source code although people could get a
license to the BSD code this before
FreeBSD for
what to an institution would be a
nominal fee of $1,000 but to an
individual would be a huge amount of
money the code was not accessible to as
many people as Linux was right out so if
you look at the graph and Kirk when he
gives his history talk on this shows
this graph you'll see that they're kind
of following each other as as adoption
goes up they're almost straight lines
the other things I think that are
missing are a lot of promotion one of
the things that we've talked about quite
a bit is that the somewhat academic bent
of the bsts means that we are a little
more reticent to just jump up and down
and say hey we did this we did this
brand new thing and as someone who's
frequently brought up short by a
colleague who will often say oh we did
that in the Atlas in 1953 you realize
there's nothing new but you really
should talk about it anyway I think
that's one of the things one of the
places where we need to do a lot more
promotion
lastly education so one of the reasons
to develop a master's course in FreeBSD
is to actually get more students
knowledgeable about it before they go
out into the world a lot of people used
the original UNIX and that's why UNIX
became part of a lot of products and a
lot of students have used Linux and
that's why Linux winds up in a lot of
places because you go to your first job
unless probably it's here and and you
say oh well you know I've used Linux at
school I'm gonna go you lose Linux
somewhere else so we think that
promoting it to universities will
actually have a really big boon in the
operating system yes take that there are
numerous bsds now which at least in
terms of attention they do compete with
each other
so as a FreeBSD person I can say the
well we have more installed base than
any of them put together but we all try
to play nice with each other and not
step on each other we actually think
that it's not a bad thing generally so
because there are different styles to
each of the BSD s the open BSD folks
tend to be paranoid is probably the
nicest word
and so you get really interesting bits
of security work out of them right so
you know we do some really good security
work on FreeBSD but there's a certain
mindset that generates a certain
interesting amount of work that we then
will adopt and one of the nice things
that the BSD Hat vsts have with each
other is we have a pretty good working
relationship and stuff that's been
developed or brought into one of the bsp
will go into the others certainly is a
brand identity I would say that there's
an issue there but I'm also not a
marketing person other questions
documentation hmm I wonder whether you
end up in the situation where there are
actual code changes which are driven for
the desire for better documentation or
whether the influence only goes the
other way you only change the
documentation based on the code so that
depends on your point of view certainly
from the standpoint of applications that
run in user space so one of the one of
the main tenets of the FreeBSD project
is the principle of least astonishment
so if someone builds a piece of code
that's really cool but yet when you use
it astonishes you not in a good way
often we will go back you know the
documentation team will usually be the
people who figure that out because
they'll actually try all this stuff and
they interact with users a bit more than
say a deep kernel developer well and
they'll say well that's really cool but
could you make it so that when you run
it it doesn't make people's eyes bleed
and so you will get changes to go both
directions I'd say the majority is
pretty typical for software where a lot
of the changes in documentation are
driven by code but it does go both ways
and the documentation team has as
license to tell people to you know fix
things and make them understandable
because they're really the ones who are
interacting a lot more with less deeply
technical coders other questions yes
going back
em part so now the whole system
including all the libraries like see
library everything is built with client
right yes
so everything is but the question is is
everything built with clang and yes
everything is built with clang is it
possible do you know this is possible
also to emit a little bit bit code on
the side except for you know building it
for x86 or x64 yes that's also possible
on github
if somebody wanted it we can only commit
it ok Brooks here works on some of that
so that's why I was looking at him cuz I
I knew I sort of knew the answer but I
was waiting for the nod other questions
yes tools tape to build the entire
system how powerful a computer do you
have and if you're so if you're building
on a typical modern multi-core machine
and you want to build all of world and
all of the kernel it's an hour hour and
15 depending on how fast your machine is
yes it does not take a week he has a
really good machine I often cross build
from a laptop so it's a little slower
but yeah it's pretty fast that is not
all 24 hour 24,000 ports that's all of
the user space and all of the kernel the
ports take about a day
yeah listen a little less than a day for
everything to be built because
everything can be built in parallel and
we have you know we run on 64 our core
machines and I think we're about to run
on 128 core machines and we'll just
throw a lot of cores at it all right
well thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>