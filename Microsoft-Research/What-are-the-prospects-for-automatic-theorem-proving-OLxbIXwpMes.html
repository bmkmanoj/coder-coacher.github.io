<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>What are the prospects for automatic theorem proving? | Coder Coacher - Coaching Coders</title><meta content="What are the prospects for automatic theorem proving? - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>What are the prospects for automatic theorem proving?</b></h2><h5 class="post__date">2016-06-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/OLxbIXwpMes" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">materials supplied by Microsoft
Corporation may be used for internal
review analysis or research only any
editing reproduction publication
reproduction internet or public display
is forbidden and may violate copyright
law
well a very good afternoon and welcome
my name is Chris Bishop I'm the director
of Microsoft Research in Cambridge great
pleasure to welcome you to the Microsoft
distinguished research lecture and an
especially warm welcome to the visitors
and particularly if it's your first
visit to microsoft research so it's a
great pleasure today to welcome sir
timothy Gower's as our lecturer timothy
of course is a very noted British
mathematician he's a fellow of the Royal
Society
he holds the riceball chair of
mathematics Cambridge he is also a rural
society research professor in the
department of pure mathematics and
mathematical statistics and he's a
fellow of Trinity College he's worked on
Banach spaces Ramsey theory and random
graphs and random sets and a problem
that's familiar to many of us the the
problem of P versus NP in 1998 he
received the Fields Medal which i think
is widely agreed to be the highest honor
that a mathematician can receive often
compared to the the Nobel Prize and that
was for research connecting the fields
of functional analysis and combinatoric
s-- as well as doing his deep research
he's also variant in communicating
mathematics to a broader audience many
of you will have come across the very
short introduction series of short books
published by Oxford University Press
he's written one on mathematics which as
it happened I read about six months ago
and it's a delightful overview and and
gives very good insight into the beauty
of mathematics I commend it highly now
of course a lot of mathematics is done
by individuals or small collaborations
well Timothy's explored the opposite
extreme he asked on his blog whether
it's possible to solve mathematical
problems through massive collaboration
and he posed a particular problem as
part of this so-called polymath project
and within about seven weeks he
concluded that that particular problem
was probably solved now Timothy was
recently knighted by the Queen for
services to mathematics and today he's
going to talk about another of his
interest which is the the challenge of
automated theorem moving so Timothy
thank you very much I'm very aware that
there are likely to be several people in
the room who are much more expert than I
am in the field of automatic serum
proving so I feel a bit nervous about
the title here I'm not really an
authority a sufficient authority to be
able to give a proper answer to this
question so maybe a more accurate title
B what are the prospects for the
particular approach to automatic theorem
proving that I myself like and whether
or not that's the right approach is a
completely different question so as a
mathematician I've always been
interested in not just mathematics but
in how we come up with mathematics how
we find proofs and things like that
that's partly for a very practical
reason if you're going to spend your
life doing mathematical research now one
of the things you want to do is make the
process of doing it as efficient as
possible so you produce as much as
possible or as good things as possible
and so just standing back and thinking
what am i doing when I'm doing it I
think it's a good investment somehow and
so that's also with teaching one of the
things one of the jobs I've had in
additions research is trying to help
other people come to understand things
that they don't understand and again I
think one wants to think more abstractly
about what it is to understand massive
mathematics what it is to what it is
that the people you're teaching aren't
able to do that you want to get one to
be able to do how to get one to be able
to do it and things like that and this
all leads me into thinking very much
about this general question of how to
find proofs and there's a short step
from there to thinking about automatic
theorem proving it's really the question
how do you teach humans to find proofs
is not that different I would contend
although there's a slightly
controversial from the question how
would you teach computers to find proofs
but I just want to sort of say a little
bit more about what I what I mean when I
say that I'm talking about one
particular approach to automatic fear
improving rather than the whole field so
their various spectra suppose one should
say so one is
we just remind myself where we go from
going from checking to proving so
sometimes when people use the phrase
automatic theorem proving what they're
really talking about is the checking of
proofs are talking about taking proofs
writing them in some formal language
like caulk or something like that so
that a computer can check that it's it's
valid what I'm interested in it's very
much the other end of the spectrum it's
improving it's in sort of the ultimate
would be you just type in a statement
your computer would spend a millisecond
or two and then it would up comes a
proof of the statement on the screen of
course in general that's not feasible
that's an it's an np-complete problem so
if you don't want np-complete means it
just means hopelessly difficult but
mathematicians aren't doing this problem
in general they're not taking arbitrary
statements and trying to find proofs
they're taking very specifically sort of
tailored statements that are sort of
beautiful interesting important relating
to other statements and that sort of
thing so that's really what I'm talking
about so I'm taking sort of natural nice
statements and trying to find natural
nice proofs so another very important
spectrum just on just a sort of place
what I'm talking about between machine
oriented and human oriented so roughly
the machine oriented approach says what
is what is it that computers are really
good at they're good at searching
through lots of stuff extremely fast
they have much bigger memories than we
do there goes a whole lot of brute power
what we're good at is a sort of
ingenuity bit so sort of combination of
our ingenuity and the sort of brute
force of the computer should be able to
do more than we can do on our own so the
idea of err roughly speaking is to use
the superior power of the computer and
really exploit it in a way that would be
impossible for humans the human oriented
approach to fair improving is to say
well it really seems to be the case that
humans are remarkably good at finding
proofs and they can find proofs of
things that so far
nobody knows how to get computers
defined at least on their own so it
makes sense if you're trying to program
computers to look at how humans do it
and try to imitate that so there's a
sort of balance to be struck do use the
brute power of the computer or do you
could try to coffee humans as much as
possible and I am right at the I mean
what I'm interested in is right at the
human oriented thing that's what's what
fits in with my interest in my own
research and teaching and so on and that
is what I'm very interested in trying to
get computers to do I'll say what I mean
but I would classify myself as an
extreme human oriented whatever I should
mention at this stage that although I'd
sort of it's pretty best to regard this
as a hobby in a sense the day job is my
actual mathematical research it's a bit
more than just a hobby and I've as I
mentioned in my abstract I've worked
with probably called Mohan ganas
Willingham from the computer lab in
Cambridge well I was just saying from
the computer lab is perhaps not doing
him justice because he's very very good
at mathematics linguistics and the
computing and all sorts of he's a very
talented person indeed with all sorts of
relevant abilities and I'll talk a
little bit about our work at the very
end but because as I say I feel a bit of
an amateur and a roomful of
professionals I'll just so I'll relegate
that to the end just show you a tiny bit
about what we've done but really what I
want to do more is just sort of so to
speak play to my strengths and just
concentrate more on a mathematical side
and one more spectrum between
interactive and fully automatic do you
want your program to be something that
you keep giving it little hints to which
is a an important thing could be very
useful or do you want to be fully
automatic so what we're interested in is
the fully automatic side but actually
it's not such an important distinction
because if you've got something that's
fully automatic but can't do absolutely
everything then you've already got an
interactive problem solver suppose
you've got a problem solver that can do
sort of moderately hard problems but not
super hard problems and if you're trying
to solve a super hard problem then you
sort of chop it up into moderately hard
problems getting computers
to those and everything could be much
much faster so actually a sort of not a
semi powerful fully automatic prove our
would turn into a very useful
interactive approver
okay so here is what I regard as the
fundamental problem that I'm interested
in so this is where it's sort of an
interested in not just from the point of
view of computing but also from my own
research as I say sort of what is it
how do humans find proofs as efficient
as they do it's an np-complete problem
in general and yet when we for the
actual problems that we come up with in
practice of course there are lots of
open problems but we are also remarkable
success in solving some of these
problems that look completely impossible
to start with and then eventually they
get solved I want to give a very very
simple example it actually requires a
tiny bit of group theory but if you if
you're not familiar with group theory I
think you'll sort of get the general
idea or get the general sort of broader
point I'm trying to make with this
example so one of the important facts
about groups are something called a
cancellation or if ax equals a Y you
have to prove that x equals y this is
true for ordinary numbers but groups are
a bit more sort of like a lot of
abstract form of ordinary numbers so
here is a sort of what a human might do
they say well if ax equals say Y by the
one of the group axiom says you can find
an inverse at a which be a equals the
identity if you multiply both sides on
the left by B then you use the
associative law you can replace B of B
times a X by B a times X is the same as
B times ax B a so identity we've
established out so we get at ax equals B
ax e times X is X because it's the
identity so X is e X because you can
swap things around when you have an
equality I'm just going through this
rather fast you do something similar on
the right-hand side and then you get a
big chain of equalities and you end up
showing it x equals y that's sort of the
steps if you just go right back to the
group axioms that would need to be in a
computer and it's not very difficult for
human to come up with them in practice
of course a human wouldn't right
all these intermediate steps and it
would look more like this you'd say
we've got the day x equals a y multiply
both sides on the left by the inverse of
a and then the inverse of a cancels with
the a on both sides and so you get 2x
equals y now the slightly mysterious
thing about this is it's a very very
simple proof for a human but if you
start thinking about how a computer
might discover it you get this sort of
odds thing that it's taken the original
equation ax equals a Y and made it look
more complicated because we just put an
a to the minus 1 on both sides you've
got sort of a more complicated
expression and only after you've done
that do you then get that a 2-1 a
cancels and it gets down to something
simpler and if I go back to what we had
here sort of spelling out all the
intermediate steps and it really makes
it quite a lot more complicated before
you finally get to the simple x equals y
and if you've got something that's got
to get more complicated first then that
makes it much more dangerous if you're
trying to get a computer to search for
the answer because if you had an
algorithm to just said whenever you can
spot a simplification simplified and you
know that that's going to terminate it's
going to something get simpler and
simpler it can't go on getting simpler
and simpler forever so at some point
it'll terminate but if you're allowed to
get more complicated then there's all
sorts of different ways that you could
imagine getting more complicated perhaps
we could have multiplied things on the
left on the right by a to the minus one
or we could have taken the inverse of
both sides or all sorts of ridiculous
things that we could have done why did
we choose that one if you just had a
sort of brute force search you'd end up
looking through all sorts of different
possibilities until you sort of stumbled
on one that just happened to simplify
when you got down to makes equals y and
that would be very unlike the way a
human works so this is just as why I
give this example to give it sort of to
say that even this rather simple problem
for humans is quite subtle so if you're
more of an advocate of machine oriented
approach then what you would might do is
in general with proofs and this is a big
difference between the way Mohan and I
think about it and the way quite a lot
people think about it so you can think
of the search for a proof as a general
sort of sir
problem computers can do quite a lot of
search but if you keep on sort of you're
searching for a step to do and then each
step you do leads to another search for
a step that you want to do in each step
there leads to another search if these
searches build up you get what's called
a combinatorial explosions there are two
possibilities and then for each
possibility there are two more
possibilities and for each of those
possibilities are two more then you're
sort of doubling and if you've got a
hundred steps to do then you've got two
to the hundred possible things to search
and that's just too big so what people
do is to say well if the search
threatens to get too big let's find
clever ways of pruning it you could
imagine it's fitted with a chess-playing
program you don't want to look at every
single possible position so you have to
find clever ways of ruling out some of
the ones who don't want to look at it's
a bit similar we're looking for a
mathematical proof there so this the
idea here is you sort of you would like
to do a massive search you can't and so
you sort of chop it down until it just
becomes practical then you use the brute
force as a computer to do it so that
would be the sort of outside in approach
and an inside-out approach would be the
exact opposite you sort of you basically
don't want to you want to start with
with the aim of using no search
whatsoever if a human would just say of
course you multiply both sides on the
left by a to the minus one then so
should a computer and after a while you
realize that even humans do a little bit
of search so you can't just rule it out
completely but you then just sort of
build it up little by little just so
instead of starting with a huge amount
of search and pruning it you start with
a tiny little plant and sort of let it
grow so to speak it's a different
emphasis but one of the difficulties
that bedevils this approach is that it's
very difficult not to come up with sort
of ad hoc reasons for why you might say
well in this example we like to multiply
on the left by a 2-1 for such-and-such a
reason but and but then that won't
generalize to other problems but on to
some general principle that works here
and actually I think unfortunately I
think the reason for this example is a
slightly ad-hoc one I think the reason
we find it obvious that we multiply on
both sides by a to the minus one is that
we're just used to ordinary numbers
the ordinary numbers we just divide both
sides by a that's the cancellation law
and then we sort of know when we first
start learning group theory that a to
the minus one is sort of behaving like 1
over a and its are sort of analog of 1
over a and so we just reason by analogy
somehow and say let's try and do
something similar to what we do if it
were ordinary numbers and then multiply
on the left by a to the minus 1 is the
nearest we can think of and it works but
that is rather particular well it's
either rather particular to that example
or it requires you to understand all
about numbers and how to reason by
analogy things like that so that becomes
a big task just for a very small problem
but I think that's possibly just the way
it is so why bother with a human
oriented approach at all the Moschino
approaches had some spectacular
successes one of which is a solution of
something called the robbins conjecture
I won't say too much about that except
to say that it was an open problem of
interest to mathematicians and it was
finally solved by a computer so this was
regarded as one of the great success
stories of automatic theorem proving the
final proof that it found was fairly
short but the search for that proof was
huge so it had to run for a very long
time searching through all sorts of
possible manipulations until finally it
found one that got from the sort of
starting point to the target and and
then that proves the robbins conjecture
but somehow that was a very special sort
of problem and not very like the
questions that we most mathematicians
come up with most of the time even
undergraduates so for a lot of
interesting problems I'm not saying the
robbins conjecture wasn't an interesting
problem but for a lot of interesting
problems you get this problem but I've
just talked about of combinatorial
explosion so you have the process of
discovering a proof involves lots of
steps but each step there are plenty of
different things you could do so if you
did a brute-force search then the number
of possibilities you'd have to explore
would rapidly become completely
impractical so and that's so
characteristic of such a lot of
mathematics that I just feel that the
human oriented approach it's just
absolutely essential they're not going
to get too
a fully automatic theorem proved that
without taking very seriously how human
mathematicians have evolved over the
centuries to do mathematics and another
reason actually is that if you've got a
process that finds a proof in the way
that a human mathematician finds a proof
it gives you much more insight into that
proof than if you just have a sequence
of steps that happens to guarantee that
the original statement is true
guaranteeing that it's true is sort of
worth doing in math but it's only a
small part of the story and what we
really like out of our proofs is
explanations we'd like to understand why
the thing is true and one of the ways of
understanding it is just to be left with
the feeling when you read the proof that
sort of with hindsight maybe I could
have found that proof myself I sort of
see where the ideas come from and that
sort of thing actually this is a
criticism of some math papers some math
papers right are written in very cryptic
ways - okay see that it works but how on
earth did you know why why form I
formulate that lemma and thought oh
that's very annoying actually but people
sort of write in a way that obscures
ideas but some people don't and I think
we're having an automatic theorem
provers and one that can tell you it's
thought processes and they're not you
know I searched a billion possibly the
possibilities and this one happened to
work would give you much more insight
that would be very nice so that's just
another reason for being interested as a
mathematician in the human oriented
approach so I've said that there are
some problems that humans find quite
easy and Computers still find quite
difficult I'm going to show you a couple
of problems and this is the first one so
the two problems I'm going to show you
are consecutive problems on the first
example sheet of a first term
undergraduate course in Cambridge it's
called numbers and sets of course so you
don't set a question on an undergraduate
example street if you think it's going
to be impossibly difficult so and this
wasn't one little sometimes you do he
put it at the very end of the sheet and
put a star this was not a starred
question it was an ordinary question
that it was expected that you know
substantial fraction of undergraduates
would be able to do
now the reason this would be fairly hard
for a computer I think and I like my
guesses or not absolutely certain but my
guess is beyond current technology for a
fully automatic their improver to be
able to prove something like this the
reason is that it's it's asking you to
find something it's asking you to find
some N some integer n such that n n plus
1 n plus 2 all the way up to n plus 99
are all prime numbers and doesn't give
you any clue about how to do it so how
might one try and do it well the only
obvious thing it's just a brute-force
search does one work no the to work out
it's three way but actually it's a
carefully chosen question if you do a
brute-force search we're going to have
to go up to very very very large in and
used it's not gonna work so right there
just too many Prime's the primes do thin
out eventually but it takes a very very
long time for them to thin out so
brute-force search is not going to work
but then what do you do there's nothing
in the question that sort of tells you
what to do next somehow so it's very
hard to imagine how a machine would do
now what I want to try to do is just
break down the sort of typical thought
process for solving this question not
the only possible thought process but
just a typical one into smaller units
and those smaller units I think should
look much less challenging for a
computer to do automatically so I'm
really just trying to convince you I'm
trying to explain in a sense why I'm
really sort of have been convinced for a
long time that something like this
something like this extreme human
approach should be possible
unfortunately I can't claim that I have
a program that's doing this sort of
thing but I feel that what's stopping me
is simply that it's just a lot of work
is needed to convert the sort of basic
idea I don't feel as a fundamental
obstacle if I had a team of you know 20
people working with me for five years
all very much with the same sort of view
about how things should be done and we
did nothing else
so III think we'd it would be possible
to to get there what
experience with Mohan has been that
we've got things to prove quite easy
results also sort undergraduate results
but we keep finding sort of little tiny
technical difficulties they don't seem
fundamental but sort of oh gosh and
quite thought about that it's a little
tweak and it feels that if that process
will convert but it just it hasn't yet
anyway
let's see how we might find so first of
all it has made the question just a tiny
bit more formal and it could be
formalized much more if we wanted to
make it comprehensible to a computer but
I'll use words like we want and things
but that's if you that's short for
that's standing for an existential
quantifier and anyway so we'd like to
find an N such that n plus R is not
prime for all our is naught 1 up to 99
and that gives us our hundred
consecutive non primes that's just say
what it means for it not to be probably
need to have some a that goes into n
plus R and being a bit sloppy I'm not
saying that a mustn't be 1 or n plus R
and it must be a positive integer but
that's what I mean
it's must be a proper factor of n plus R
so one of the standard techniques that
one uses is generalizing so when you see
a number like 99 you think well that
probably hasn't got a very fundamental
role to play in this problem let's tidy
things up a little bit and and we'll
will replace 99 by to some arbitrary
number M attempted one of the reasons
for that is just not to get distracted
by sort of irrelevant data so to speak
but actually have another advantage
which is once you've made M a variable
you can try some other cases and me you
can actually try simple special cases
and not just not just complicated ones a
very obvious one why not this is try M
equals one so can we find an n such that
both N and n plus 1 or non Prime's I
they've got factors now let's just
consider so we'd like to find an N and
an A and a B that a and B will be the
factors so what
going into N and be going into n plus
one and I'll just reproduce that up here
so what next
well if you're going to do something
like that a very standard everything be
so positive all standard proof finding
techniques so another very standard
technique would be just let's pick the
simplest possibility for a and see
whether it works if we can get it to
work so we can find so I'm just
specializing at this point I'm going to
say instead of finding n a and B I'm
going to just declare that a is 2 and
see whether it works so we'll go for N
and B so 2 goes into N and B goes into n
plus 1 well okay so far we could get to
going into n but let's just we've still
got this B to worry about well let's try
the simplest possibility again the same
technique and well the absolute
simplicity might tries to but if 2 goes
into n then is even n plus 1 will be odd
so 2 is ruled out so let's try the next
one
we'll try 3 so can we get two to go into
n and three to go into n plus 1 but some
specifically chosen n and you're not
allowed to choose n is 2 because the 2
wasn't allowed to equal n sir so just
make that clear but if one thinks about
it for a tiny bit even with a
brute-force search you quickly arrive at
the resolves at 8 works so 8 is even and
9 is a multiple of 3 so 2 goes into 8 3
goes into 9 and we've done it for that
special case so it seems to contradict
what I've just said so when I say are we
done what I really mean is has that
given us a sufficient insight to solve
the whole problem does the fact that 2
goes into 8 and 3 goes into 9 show us
how to find a hundred consecutive non
Prime's and the answer is no it doesn't
it's just unfortunate just looks like
some experimental fact that doesn't have
too much bearing on the general problem
so there's continued a little bit
anything I can think of at this point is
to try the next case so let's try find
the N a B and C though a goes into n B
goes to the N + 1 C goes at n plus 2
and we dispose of this one fairly
quickly because we take as two beers
three but once we know that n is even we
know that n plus two is even and so
actually we can just take C is two so
that's not very important I mean not
very it didn't really help us much what
about the next one so what are we trying
to do here by the way why we're trying
to more cases we're sort of hoping that
at some point we'll stare at it and see
some sort of pattern that we can then
generalize so n ABCD a goes into n B
goes into n plus one and so on
so then which was the simplest values
we've already know that 2 3 &amp;amp; 2 are
going to work for a B and C and now we
find what could we do for D going into n
plus 3 well because n is even n plus 3
is odd so twos not going to work because
n plus 1 is a multiple of 3 n plus 3 is
not a multiple of 3 so 3 doesn't work
either for doesn't work because 2
doesn't work so 5 is the next possible
thing that could work so we think okay
can we find an N so that n is even n
plus 1 to multiple of 3 and n plus 3 is
a multiple of 5 now there's another
question here it says is it worth the
bother of trying to find such an N in a
way it's not really because you know
when we found an N that worked for 2 &amp;amp; 3
we found 8 it didn't really help
it just was okay could be done but it
hadn't the fact it couldn't could be
done didn't really give us a clue about
how to generalize so actually just
experiment we might want to do it to
reassure ourselves but it's not really
going to help just to exhibit an end so
maybe we just don't bother instead we
just carry on with this pattern so what
happens next
let's just quickly if you carry on this
same sort of argument n plus 4 is taken
care of and so we end up wanting to to
go into n 3 to go into n plus 1 5 to go
into n plus 3 and 7 to go into n plus 5
if we just carry on this general
approach and now I think one can see a
pattern so what does 2 3 5 7
just anything those are the first four
prime numbers and 2 goes into n 3 n plus
1 5 goes into n plus 3 and 7 goes into n
plus 5 is there a pattern there yes
because 2 minus 2 is 0 3 minus 2 is 1 5
minus 2 is 3 and 7 minus 2 is 5 so it
seems as though what we're getting all
the time is sort of we want Prime's to
go into n plus that prime minus 2 and we
would want things to work up to n plus m
so if you look at it a little bit you
find a B but we would like this
condition to hold for every prime up to
M plus 2 it's just if you're not
following exactly what I'm saying I
think I just want to go a little bit I
was a whiz through a little bit but just
believe me that came that was very easy
what I just what I did if one thinks
about it I suppose time to think about
it and it's reasonably easy to show that
if you've got that condition and I'll
jump over that part then you will in
fact be done so if if it is the case
that for all Prime's up to n plus 2 P
goes into n plus P minus 2 then you'll
have your M consecutive non Prime's so
that's the general principle want P to
go into n plus P minus 2 for every prime
up to n plus 2 and now we realize that
we can simplify it so P going into n
plus P minus 2 is the same as P going
into n minus 2 if n plus P minus 2 is a
multiple of P and so is n minus 2 and
conversely but it just looks nicer not
to have the P here so we now want n
minus 2 to be a multiple of every prime
up to M plus 2 now this point has become
a very easy problem but that's just
spell it out can we find a positive
integer that's divisible by all Prime's
up to n plus 2 which would be our n
minus 2 yes just multiply all those
Prime's together and then of course it's
divisible by all those Prime's and
actually that's finished we found a
solution so what is the solution it's
multiplied the first few Prime's
together in the case of a hundred
multiply all the primes up to 101
together and
subtract to know add to and that will be
your starting number and then those next
hundred or that number in the next 99
will none of them be prime so there's a
whole process I've sort of broken down
the thought process into much smaller
steps if you go to a supervision of bad
supervisor the supervisor will say
consider n factorial plus 2/3 area so
it's like 101 factorial then 101
factorial plus 2 is a multiple - I'm
connect Orion plus 3 the multiple of 3
all the way up to 101 factorial plus 101
is a multiple of 101 so it was easy and
of course it's very easy to follow that
argument or if you don't follow it if
you're a undergraduate mathematician
it's very easy to follow that argument
but absolutely no insight has been given
into how to find the argument right and
that's the sort of thing that computer
for a computer just sort of happening to
think of 101 factorial + 2 3 4 5 is not
feasible so here that said here this was
the next question on the same sheet so
here we have a sequence which we get
each term we had two then we had four
then we had six and then we had eight
and so on and so forth and the question
is do you always get a prime so how
might one go about that well here's a
case actually where it turns out that if
you use brute force on a computer you
can solve it in very short time but
you'll get an extremely on enlightening
solution is a sort of here's one that's
not prime and it would be just a bit too
tedious a brute force for a human to do
for human it's much better to think so
the obvious thing to try first is to
look at the first the next few terms of
the sequence so 61 we had 10 at 12 at 14
at 16 at 18 at 20 and all those numbers
of Prime's
so after a while when you do that you
start losing heart and thinking well
perhaps is actually as they are all
prime or at least I'm not likely to find
a composite one for quite a long time
and so maybe we should sort of step back
and see whether there's anything else to
do
well there's a fair this is going to
take much quickly much less time than
the previous one there's a pretty
obvious first thing to do is to find a
formula for the general term of this
sequence and what is the nth term well
it's for t 1 plus 2 plus 4 plus 6 plus 8
all the way up to as it turns out twice
n minus 1 and a human would do this by I
mean maybe a computer would do that by
just sticking it in mathematic or or
something like that I don't know but a
human might do it a bit like this you
say well this is the sum of the first
lot of even numbers but I know that the
sum of the first n whole numbers is
because I was at school I did a level
where there's n n plus 1 over 2 so if
you double that I'll get in and plus 1
but if I'm instead I get only go up to n
minus 1 I substitute n minus 1 for n
here and get 41 plus n times n minus 1
and so that's a formula for the general
term not too important how you come up
haven't come by that it's a sort of
standard thing to do so now the problem
is are all numbers of this form prime so
either you see that straight away in
which case it's a mysterious thing and I
don't want I don't like mystery and that
many so let's just see what one might do
if you didn't see it straight away and
maybe you don't some you know some say
could it ever be an even number for
example so we will try to being
effective so could this ever be even now
just know because one of those two
numbers will be even so that product
will be even and then when you add 40
wanted to make it odd and a similar
argument shows that it can't be multiple
of three are slightly more cases to
check but it turns out this can never be
a multiple of three and in fact if you
want you can check that it will never be
a multiple of five but after a while
you'll start getting a little tired of
this case checking now when you get
tired of the case checking then instead
of just trying any old small things
instead of trying the simplest thing you
might say was there is another problem
solving technique which instead of
finally look just looking at the
smallest thing or something like that
try and find something it's actually
connected with the problem so are there
any integers that are connected with the
expression for T 1 plus n times n minus
1 well of course that's one staring
face its 41 so it might be rather
natural I mean perhaps it would turn out
that in reality of model 40 or 42 or
something but 41 looks like a pretty
good candidate for something to to try
so does 40 can we find an end for which
41 goes into 41 plus n times n minus 1
that is very easy but let me spell that
out by defining up into even smaller
steps so what does it mean for 41 to go
into n n minus 1 it means that we want
an N and an M such that 41 times M
equals n times n minus 1 and now we can
just solve it by matching up the 41 at
the end and the M at the n minus 1 just
say well let's take n to be 41 n minus 1
to be M which means that M is n plus 1
so M is 40 and then we're done so going
back to here if n is 41 and this is a
multiple of 41 there's not a prime and
there again you could just say that
straight away but it's there is a sort
of genuine problem-solving technique
okay so of course it's not enough to
show you that the search for a proof can
be broken up into small simple steps in
the way that I've tried to do by there's
a very important distinction between the
proof being divided up into small simple
steps and the discovery of the proof
being divided into small simple steps
I'm talking about the second rather than
the first so the small simple steps are
things like let's generalize this or
let's look at a simple special case and
that sort of thing they're not you know
this implies this implies this implies
there's a completely different thing it
is a very interesting fact about
mathematics that proofs themselves can
be divided up into tiny steps but that's
not the fact that concerns me right now
so we've got all these devices it's not
enough to show that a sequence of those
devices will end up in a discovery for
proof I've also got to give you some
account of how you choose the particular
devices and you don't choose other ones
that are totally unsuitable so there are
all sorts of other things that one could
do that wouldn't have helped to solve
those problems and so how do they know
to go for the ones that would so that's
one problem and
another problem is sort of lower level
problems on AI once you've actually
chosen which problem-solving device to
use like generalize or something how do
you actually go ahead and do it
I think the second is much easier than
the first to automate so I'm going to
concentrate on the first so that itself
divides up into two subproblems so one
of the things you want to do when you're
looking for a device has make some
estimate of how much effort it's going
to be and how helpful it's likely to be
in that sort of thing
so how do you actually do that how do
you look at it and say oh generalizing
looks as though it's going to be good
here trying setting N equals 1 that's
not going to be any help at all so a
human we make these judgments quite
easily but how would that be an
automatable saying so that's one
question and another question is
supposing you can do that so supposing
you can make good judgments about how
useful various techniques are likely to
be you won't be able to say with
absolute certainty that this technique
can help and that one's not going to be
very helpful you'll always be some
probabilistic judgment which you'll then
have to go and actually do it and see
whether it does help if you didn't have
to do that you would solve the problem
already so to speak so if you've got
assessments of various different things
to do how do you actually go ahead and
decide which one to do what would be a
good strategy so I want to discuss this
second subproblem the sort of problem
there's a little strategic problem that
you face when you're doing mass so it's
actually a special case of a much more
general problem so you're sort of in
some environment and the environment I'm
thinking of here is it's you and the
piece of paper on which you've scribbled
and the problem that you're trying to
solve and the thoughts that you've had
and you have a choice of actions that
you can make and these actions have some
information about what you think the
rewards the various actions will be in
what the costs of various actions will
be typical cost will be just the time it
takes all the annoying effort it takes
to do some calculation that you know
that you could do in principle but it
might be rather tedious and then
for the possible rewards are you know
maybe if I do that that will give me
some insight which will help me later on
to solve the problems you've got these
sort of costs and rewards and a goal you
want to get to which is solving a
problem but there's a much more general
thing which is this idea of actions and
costs so for example in there's things
that people look at which I'm sure many
people that know about Markov decision
processes it sounds quite like Markov
decision processes well there are fairly
important distinction between this and
Markov decision processes is that we
don't at all have perfect information
about what's going to happen later on if
we take various actions so if you do
know about those there's also a very
strong sort of information constraint
well there people have thought about
that sort of thing as well about acting
when you don't have perfect information
so the point I want to emphasize is that
this sort of question has been studied
quite a lot so I think it's worth
studying it in the context of
mathematics although I think it raises
interesting difficulties that are
peculiar to mathematics there's
something a bit odd about using a
probabilistic model for something that's
deterministic as mathematics so you
might sort of say I'm going to do a
calculation and I think the probability
that it will simplify down to something
nice is quite high if you say what does
that mean either it God sitting up there
knows either knows that was definitely
going to simplify or that it's
definitely not going to simplify down to
something nice so what do you mean and
that's actually as I find out quite an
amusing problem but it's not something
that puts me off because we're all
Bayesian as these days and some
probability is not a sort of measure of
what will happen if you repeat the
experiment over and over again it's a
sort of measure of our uncertainty in
that something so I think that's a
probabilistic model is appropriate even
in this rather deterministic context
without a complete solution to this
problem let's just distill a couple of
general principles so something is good
to do if it's cheap and something is
good if there's a reasonable chance that
it'll it'll be helpful so if you've got
a very complicated calculation you
perhaps try and do simpler things first
or if you've got a simple calculation
but you're pretty convinced is just
going to be completely irrelevant like
that one of seeing whether five went
into 41 plus and n minus
would be fairly simple but unlikely to
be helpful so you just don't bother with
it or you don't bother it if you're
trying to optimize your efficiency but
yeah sometimes you find that there are
some easy things you can do that are
probably not going to be all that
helpful and some things that look at
that there might be quite helpful but
it's going to require an awful lot of
thought to make them work which do you
do first and it's the balance so let's
just have a look in going back to this
example about how we might choose a
problem-solving device so remember we
wanted to find an A and an N such of a
goes into 41 plus NN minus 1 so here's a
selection of probability of
problem-solving devices that we might
have tried so one must have a look at
the smallest value of n that isn't yet
ruled out and then Droid go for a but we
did that right at the beginning we
looked at some small values of N and we
found that all the numbers for all prime
and so we sort of know now that that
doesn't work it's not a ridiculous thing
to try but we've now established that it
won't work another one might be find a
smallest value of well actually it's a
I'll come to the assessment so there's
on another slide but here so another one
we find the smallest value of a and then
the smallest value of n will find the
smallest value of a that hasn't been
ruled out and then see what that would
tell you about N and then try choosing
an end that's related to the problem try
using an a that's related to the problem
we'll try generalizing the problem by
changing 41 into M and some of these are
good but some of these are not so good
so let's have a look at some not so good
ones
so I just said it so if you try the
smallest value of n that hasn't been
ruled out you find that you look at
these numbers 41 43 47 53 61 71 83 97
from uh stop and they're all prime so we
don't really get anywhere the next form
is to try finding the smallest value of
a and then the smallest value of n but
we already know that small values of n
aren't going to work so this strategy
doesn't you can sort of tell actually
did it won't be helpful and what about
the smallest value of a that hasn't been
ruled out and then look at the
constraints on n so you might say let's
try a
- I talked about this before so that's
saying can you find an N such that 41
plus n times n minus 1 is even it turns
out you can't it's always odd so it
might say well let's try a equals 3 can
you find one that it's a multiple of
three no it turns I just never a
multiple of three it's never a multiple
of five and when you've tried a few of
those as a point I want to emphasize it
was sensible to try out small values of
a to start with because it's a simple
thing to do simple thing to see whether
it works but after a short while first
of all the larger a gets the harder it
gets to see what happens and secondly
the larger it gets the more you sort of
increase a and don't don't get anywhere
the more you start to feel this whole
approach isn't getting anywhere and so
you're sort of assessments of the
probability of that trying small values
of a is the way to go
changes and you start a total balance
between rewards and ease of calculation
changes we get new information that
suggests that maybe this this approach
is not a good one so wasn't hopeless but
it turns out not to be good so you don't
try something else
then all three of these it turns out are
good ones so if you choose an N you
could take n is forty one problem solved
it she was an a a is forty one that's
one I actually used before
problem solved forty one divides n n
minus one and okay and it's forty one
will do fine the third one's slightly
subtler if you're a plate if you
generalize rather as we did with the
first problem by replacing forty one by
an arbitrary integer M that immediately
sort of tells you not to look at small
things like two and three because you
don't know anything about em so then
you're forced to think of something that
somehow related to the problem or built
out of em in some way and it just forces
you back this desire of generalizing
forces you back to these strategies that
were good ones and away from the
strategies that were bad ones
so it's sort of good in a more meta
sense I don't take this slide too
seriously because I'm not an expert on
machine learning so this is just my
little hunch I'm in a room full of
people who will probably have exactly
the opposite hunch with much better
reason and I have for having the hunch
but let me just say
so I feel that there could be a role for
machine learning in mathematics but a
rather restricted roles I think machine
learning might be good for those
situations where but I would maintain
these are very rare these situations
where humans can do something with ease
but when you ask them how they do it
they just cannot tell you so if I if you
ask me how is it that I recognize my
mother's face or something like that I
can't really explain ice endicott
explained it in such a way that if you
met her in the street you say wow that
must be so but I think that sort of
situation doesn't occur very much in
mathematics that my spirit seems to be
that even if you think you've had some
sort of idea it just popped in your head
out of nowhere actually if you are not
lazy and you think about it hard you can
work out at least a plausible story
about how it might have got into a head
or how it could pop into other people's
heads and so I feel that machine sort of
saying let's try machine learning feels
to me like I sort of cop out although
that's not to say that I wouldn't be
absolutely fascinated if somebody
managed to do something using machine
learning in a serious way that could
sort of come up with ideas but even then
I'd be little bit disappointed because
then this idea of explaining thought
processes might be rather hard to get
it'd be more like you know you put it in
your neural network sort of it puts the
something that sort of tells you what
the idea is and it just looks a bit like
magic because it's for other hearts to
open up and you let work and understand
how it's working maybe not always
completely impossible but I feel unsafe
territory it's let me pass quickly on to
discuss very briefly and I know damage
so I've been talking about the high end
problem sort of how we choose strategies
and things like that but there's a sort
of lower end problem so if you want a
machine to think it like a human and
avoid search where humans would avoid
searched and it has quite a lot to be
said for looking at problems that humans
can solve doing no search at all there's
a whole class of problems
that we would classes routine I think of
them as problems or proofs that I don't
have to all I have to do if I'm if I'm
giving a lecture where I have to present
such a proof is just remember the
mnemonic do the obvious thing at each
stage and you'll get there and don't
worry nothing will go wrong so I call
those routine proofs ones that you can
find just by doing the obvious thing at
each stage and they definitely exist as
a sort of human phenomenon and so if
you're trying to find something that
doesn't do search where humans won't do
search then you have this sort of
general idea what you'd like to find an
algorithm that when humans don't search
and backtrack and that sort of thing the
algorithm words if a human just goes
straight from the hypotheses to the to
the conclusion so should the algorithm
so that was a challenge we set ourselves
with in one small subdomain of
mathematics which was abstract analysis
metrics basis in particular and so this
is in a way the most I think the most
striking thing to other people about the
program but it wasn't our main focus is
that it we could quite easily get it to
output its proofs in pretty much natural
language so I'll show you what a proof
looks like we actually did a tests I
won't do it here but we did a test of on
my blog I posted output from the program
and some human written proofs and asked
if people could tell the difference and
more people voted for our thing than for
the human ones but it was not a sort of
overwhelming majority it was you know 40
percent got it right and 60 percent got
it wrong something like that so that was
a sort of mini Turing test so that our
program passed so here's here was the
problem if you haven't done second year
undergraduate mathematics and this will
make too much sense but at least I think
you can sort of look at that and see
that it sort of vaguely like the kind of
prose that you see and it's sort of not
a hundred percent formal language it's
got all these sort of words in and
I might say just a tiny bit about how
that said one of the key things we
wanted was so one thing you might do for
this would be first you find the proof
and then you do a whole lot more
processing in order to turn it into into
a natural language output we very much
didn't want to do that we wanted to have
something that reflected the thought
processes of the program so it was
important that it be a sort of local
method of producing the output in other
words it would have a thought writes
down that thought there's another
thought it writes down that's what it
has another thought so what you see here
is basically what's going on inside the
program it's not some cheat where we
where you reconstruct a sort of human
readable proof after concealing all
sorts of search that the program did
there's a tiny bit of sort of not
exactly cheating but sort of tidying up
so if you just a sentence by sentence
then you find that you get sort of ugly
little repetitions from one sentence to
another and where a human would sort of
we've established that we're talking
about this and so we can use a pronoun
here instead or whatever it might be so
a few tiny little adjustments but really
not very much at all this is a this was
not a so Mohan actually works on
something much more difficult which is
understanding the sort of text that
you'd read in a mathematical textbook
and converting it into into sort of more
logical form this is the reverse process
you have something in a logical form and
you just want to produce some text that
it's more human-like that's much easier
because you get to choose what your text
is if you want to do the other way you
have to resolve all sorts of ambiguities
that was the main challenge for him and
that's very much harder but nevertheless
his expertise was extremely useful well
his multiple expertise was extremely
useful for all these things but it's
particularly useful at this part here
and I think I will stop there
in torque we have a little bit of time
for questions I might take the liberty
actually of asking the first question if
I may
you said there that we're all Bayesian
so music to my ears of course my work is
done if we're if mathematicians to be
Bayesian should they not therefore move
beyond saying that a theorem has been
proven or not proven and talk
quantitatively about the probability of
it having been proven for example if a
computer has just checked the first
billion cases and not found an exception
then a rational betting mathematician
would presumably change the BET that
they would make based on the evidence
provided by those first billion cases
even though of course it doesn't
constitute a proof any thoughts
well one thought is that you have to
formulate what you're talking about
rather carefully so for example if my
safe theorem every positive number is
less than ten to a hundred ten to 100
and then you still check the first
billion so some it's a it's a rather
interesting question actually when it is
that looking at a whole lot of cases
constitutes evidence for something and
when it when it's not so a case where it
where it is very compelling evidence is
Goldbach's conjecture so that says that
every even number is the sum of I've
been even number beyond from six onwards
there's a sum of two prime numbers and
if you use various heuristics about the
primes being sort of reasonably random
you can actually predict not just it's
not just that every even number or bit
of sum of two primes but it ought to be
the sum of two primes in several ways
and moreover you can estimate roughly
how many ways any given large even
number ought to be expressible as a sum
of two primes and if you compare that
against a graph of how many ways these
even numbers actually can be written as
a sum of two primes the agreement is
quite astonishing so when you see that
that becomes very compelling evidence
that think about the primes behaving in
a random sort of way is correct and I
think there's been lot of controversy if
you've been tried to sort of convert
that into a number somehow those numbers
didn't seem very robust
you know somebody then suddenly proves
an unexpected fact about the primes and
maybe your whole estimates which a but
perhaps that's actually what should
happen in a bayesian world some new
piece of evidence comes to light and
then your possibilities change so it
feels to me as though there are
possibilities there and they're also
obstacles to well I regard that as one
of the major challenges basically so one
which I don't have a clear idea have to
do it is a rather mysterious process
when you watch human mathematicians
learning some say an undergraduate
course if you set them some well-chosen
exercises today sort of do those
exercises and then something clicks
they've got the idea and in future they
find that sort of thing easy even if
they find it hard before because
something's going on that's
once they've sort of done a certain sort
of struggle after that it's easy but
what has happened for that to happen
I don't know so that's the whole that is
the problem of yeah how can how could
you get a program to learn from
experience so I think at the moment are
we own I think to try and tackle that
would be setting our sights very high
indeed so at the moment I think with our
focus is more on can you just make a
program that could be taught so you sort
of let's say a program that as long as
you can say so you have to tell it the
abstract idea that lies behind a
particular class of problems that say
rather than but
yeah it is a question I find very
fascinating but also another thing is I
would like to make clear that what you
said with one of the other things you
said is very important that different
people with different experiences will
backtrack by different amounts so
everything is always sort of relative to
the experience of of the person and the
same would be true if you're serious
about imitating humans would be true
about programs so what I would want is
for a program maybe I should make it
slightly more precise so program should
not backtrack if a human with a
comparable level of experience for what
you've given the program would not
backtrack something like that but in
order to get to sort of the singularity
I think you'd need programs that can
learn from themselves maybe even set
their own exercises and once you've once
they can do that then you just stand
back and wait for the serum say of
course the answer's no advocate how you
put it because by the prime number
theorem and even if another prime number
theorem they know the primes thin out
therefore it's impossible that one
percent of numbers are scoring to be
prime forever so they will know the
right answer immediately simply because
of their background knowledge and in
fact in fact to me the idea of
multiplying a bunch of numbers together
also occurred immediately and that I
assume comes from the inside I have I do
have a math degree but I've only done
math long ago on your second question
that was even easier to my mind the
immediate thing said was I'm numbers
don't behave like that and this is a
knowledge of any mathematicians just
quite high assume you agree with me
everyone just knows they just don't they
don't have these simple things that say
oh yeah all of those are going to be
prime and this is the combination I've
had of reading lots of awesome
my nipples and somehow you let invest
amounts of knowledge but this is known
to be a very difficult problem in AI you
just you make vast encyclopedias like
sight which I type in mountains of
trivial facts and then try and get
natural behavior out of it so I mean
this is what you're up against the point
I was making was that with those
examples was I agreed it for a really
experienced mathematician the solutions
would sort of pop into your head but it
is also possible to solve the myths the
idea doesn't pop enjoy it if you've got
much less experience and so this you
know for a first-year undergraduates
they wouldn't know the prime number
theorem so they wouldn't necessarily
think oh the primes going to thin out
and up so it's obviously going to be
true actually now that sort of small
thing is yes I think the question is
find an end that works rather than just
show that there exists an ends and then
that would mean that appealing for the
prime numbers theorem would would not be
enough who would just be a sort of
abstract existence proof but that's a
sort of pedantic point so I think that
mayst I mean I think this could have
accumulation of common sense I'm sure it
would be a challenge but I don't think
it and it might be enough of a challenge
that it means that there are significant
limits to where one can go with this
sort of approach but I think what I've
tried to try to convince you of obvious
that at least one can get started it's
possible to solve these problems or to
break them break up a thought process
into small ones even if that thought
process is not something that an
experienced mathematician would do but
it could be something that's an
inexperienced mathematician might do to
get from sort of zero to solving those
problems so so it's not obviously
correct this but I have a sort of hope
stroke belief that mathematics is the
sort of domain where there of course
where some of these notorious AI
problems kind of some happy
but I admit that that could be wrong
could eventually find that we just get
stuck because of very notorious problems
so there are quite a lot of people still
wanting to ask questions I think in the
interest of time apps will bring the
formal questions to a conclusion sir
Timothy will be staying around for a
little while you're very welcome to ask
him questions
informally outside please do join us for
drinks afterwards and but first please
join me in thanking sir Timothy for our
fascinating and</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>