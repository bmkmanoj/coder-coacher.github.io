<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Ziria: Wireless Programming for Hardware Dummies - Part 3 | Coder Coacher - Coaching Coders</title><meta content="Ziria: Wireless Programming for Hardware Dummies - Part 3 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Ziria: Wireless Programming for Hardware Dummies - Part 3</b></h2><h5 class="post__date">2016-07-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/22pSt8mXiSc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay shall I start so thanks for coming
again I don't know if you were excited
by the talk yesterday and came again oh
you want to see the talk after me but in
any case good to have you back again so
okay just to remind you so we were
talking about these programming language
and the goal was really to present you
well give you an idea how to design
programming language there would be
specific for wireless applications and
also give you some insights in how
compilers design how can do this
processing very fast so where I left
yesterday was one optimization which
with the lookup tables I believe you
heard a little bit about from kun last
week so the advantage here that we kind
of follow up on their work is really
being able to do it automatically from
your code without really needing to to
do to think about where to do that and
letting compiler do it for you after
that I'm just going to give you a little
bit of code examples and show you how
these optimizations are all being done
and then we're going to go over Wi-Fi
receiver and transmitter and I'm going
to give you a brief overview of each
block and I'm try to demo you each block
in Syria and give you the code how it
looks like explain you how it's
implemented and so in one on one hand
give you an idea y Wi-Fi design wifis
design is it design and then on the
other hand show you what kind of
optimizations you have to do because to
make it run real time in sora and also
kind of show you how you can do all
these things together very easily right
so the examples are very small and we
should be able to go to them in real
time right and you should be able to
understand right so that's the hope and
right so again if you have any questions
just stop and ask me so I'm just going
to come again back to these
optimizations that's where we stopped
yesterday so basically add in particular
Wi-Fi transmitter you have lots of
operations as executed a bit level right
and so what we said is that we want to
be able if you have an operation that is
executed at the bit level it's very
inefficient if you do it on cpu right
it's mint and the
sign of the whole thing is inherently
done for fpgas and a 60 the way you do
that is you know basically bit level is
normal on cpu is not normal because you
have you working on but at least bite if
not more right so here the the thing
what you want to do is here's an example
of a scrambler so the scrambler does we
had this yesterday are just going to
briefly repeat see otay you're taking
one bit of from the input and then you
are doing small bit state machine so
there's this scrambler stage which is
seven bits and then there is the there
is the so basically take this you
calculate a state a temporary variable
from this scrambler you shift the
scrambler basically you move 0 to 5 to
12 6 and basically the europe and the
last bit you put whatever the new
scramble status ok so it's a kind of
random number generator lfsr i can
remember about the abbreviation is but
it's kind of a standard thing where you
kind of generated to the random sequence
through these shifts and then you simply
saw your input with this output of the
sequence and you out put it out and so
the first thing that was kind of
interested here is that the code is kind
of quite obvious there is no i mean it
kind of maps directly to what is in
Wi-Fi specs so there was one of the
goals you have to when you write the
code it should be very clear now the
question is how do we do it fast right
so the first so there is optimization we
discussed yesterday first was the
vectorization so the fact that we can do
this we can automatically figure out
this could be done in the loop of eight
and then we want to optimize think
inside so first we vectorize this and we
say okay now i take this code inside and
i put a for loop around it right and i
realize that in a for loop around it
basically it's a very simple
transformation kind of obvious but it's
automatic right you don't have to do it
you create an array and for each element
of an array so this is an array and the
output is in ray you just do this eight
times as simple as that but you need to
figure out you need to do it
automatically right and then the next
thing is really if you look at this
array you need to realize that it could
be mapped to lookup table so again the
lookup table is basically something you
do in fpgas you say okay I'm look at the
inputs to this piece of code look at the
outputs of this piece of gold and I
realize that instead of running this
thing here my input and output space is
small enough to that I can then I'm able
to put it in a big lookup table right so
that's what FPGA is doing and that is
what sort of guys did right they had to
go through this process manually for
each piece of code to understand how to
do it and so on so here we claim the
compiler should be able to do it
themselves with a little guidance of you
there's no kind of you can't really
optimize everything so the only thing
here we would need to specify is that we
we want the unrolling loop and rolling
to the level of eight because we know
our cache size and so on the rest the
rest can happen automatically so
basically so what the compiler then does
it goes to this code and says okay what
are the input variables so we have this
scrambler state and this thing basically
so what what happens in this code we do
this once and then we return for the
next piece of information if you look at
that code we do this and repeat it for
every input right so that persistent
state for this block is this scrambler
state so essentially this kind of state
is the input to this calculation and the
other input to the second question is
this extinct right which here is a is
given through vector X a right so these
are the two inputs this this guy here is
not an input it's not an alpha because
it's just the index and it never seen
anywhere out of there this guy as well
this temp guy again it's actually
reinitialize here and lost there so it's
not any good so this is again the kind
of analysis other guys had to do my
nearly so we kind of do it all
automatically and we calculate right
okay we have this state which is this
guy which is a vector of seven bits and
we have this guy which is a vector of a
bit because that's what we decided so
the input space is 15 bits right so any
input to this block so the performance
of this block if I give it to you to run
it and I give you this 15 bits you are
able to execute this block without any
help from me if you don't see the rest
of the code so you just do it for all
combinations of 15 bits so it is to the
power 15 and the output you give me are
to bite right because the output is
these two states right again I need to
output the Scrambler state because
that's something which repeats through
this outer loop that I'm not doing
lookup table over right
this actually has to be both input and
output state so i have two 8-bit states
well they're not a bit but overall it
has to be two bytes so I create a lookup
table to the power 15 times to 64
kilobytes and then when I actually
execute the code it is going to read
from a lookup table it's not going to
run all this and if you think of it this
is very expensive a CPU will have to do
eight iterations a lot of bit level
operations instead of it it is just
going to do sorry it's just going to do
one read from a lookup table right and
so the nice thing is now you have these
abstract syntax tree the compiler go
street looks for all possible
expressions every single item in little
cups industry it will actually look for
and and and do automatic lookup table
right so that's the benefit however you
need to be aware how you write the code
it's not you know you you have to write
the code in the sense that it could be
optimized this guy is simple to optimize
right so here is an example of a code
which is not easy to optimizing the
credits for implantation go to kuna and
Sora guys we just kind of made sure we
can capture these characterizations to
true true true true true in Syria as
well so suppose you want to do a
permutation right so I have an input
array so there is a function permutation
right so if i give you a set of in dice
and then i give you an input array you
should permute them to read the
corresponding this so for example if i
give any plain one two three four so you
should output first the zero element
which is one then the second element
which is three then the third element
which is four and then the first term
which is two ok so it's a simple
permutation ah now ok sorry I did
showing the in this I didn't really
assume suppose the inputs are bit arrays
not by therese because then it becomes
difficult suppose this input is bit
arrays so unlike here right so the
question is can we can we make this a
look up table ok it's a trick question
if anyone ok the question for you could
you think of how to make a lookup table
it's not easy the hint is that this
permutation indices are constant right
so there isn't you don't need to
consider them as input variables right
so the only input variable is this guy
and this the output variable is this
however they can be actually quite large
right so okay it's difficult I mean I
just kind of let you think about it
basically the thing what you have to do
is you can break this input arrays into
small chunks right so if you think about
it as we had an example in the previous
example here the input 15 bits right the
size of lookup table is 2 to power 15 it
explodes exponentially right but the
output is only to bite it's not to do
the power of divine right of 2 or 15
bits right so it's better to put things
in the output and keep the input small
if you can so in this case you still
need to do this transfer may have to
write the code that where yourself
because the compiler cannot do this high
level thinking for you right and only if
you write the code that way you could
figure out so basically what you have to
do is basically if you have a large
input array so you pat you cut it into
small arrays binary raise and then the
input is a small array and the output is
a big array right so this makes you this
makes it possible because they let's say
this this input is i don't know like
eight bits and the output is 32-bit so
you want to permute larger larger tables
so you will only so you keep this array
empty I say all zeros and you put once
only where you see where your
permutation index tells you to put it
right so then what you have to do is
just all these things together and that
you can do quickly so basically by up so
what would you do you basically break
this vector into sub sub vectors and you
do a permutation of EPL vector but now
you're permute in a larger space so
instead of doing over this suppose this
big vector is huge right but you just
take a chunk of it you created here take
another chunk you create another of
these vectors and you just all these
vectors and you've done it in a much
faster way than you do otherwise so the
key takeaway point here I mean we can
discuss if you're interested in the
details of how this is done but the key
point here is that if you want to do
look-up tables there are lots of places
where the compiler can do it for you but
no compiler is kind of
almighty so there's no you have to do a
little bit of thinking for these kind of
examples to make sure that and if you
don't do this optimization you cannot
have you cannot have Wi-Fi running in
real time right so and again all these
credits for doing these optimization
goes to Sora code what we try to do is
kind of capture these in a more general
room so if you write other kind of codes
in the same way you can you can expand
it there so this is these are kind of
things you would need to do whatever
programming what are you doing New ready
or you do it in Sora if you want to do
real time in radian cpu right so that
the thing is if I give you if I give you
this I think I was too quick so
basically if I give you this and I say I
take this for I equals 0 to 8 and I've
right this guy and whenever the index of
it is right so the input space is a bit
and this guy is constant that's what I
said there's a hint so if it's not
constant you can do it so this guy is
constant so my input to the whole block
is just this but the output is large the
output can be 32-bit 64-bit whatever you
want so my lookup table is going to be 2
to the power 8 x 32 bits right which is
not too bad but if I put that whole
32-bit here right if I don't cut it in
pieces then I'm screwed i have to 232
it's four gigabytes for gigabit lan so
so the key observation here is that you
need to chant to cut this input table
and do the you could have done it the
inversely right if you look at this
formula you could have said o R of I
equals IR FBI for the big one and put in
that wouldn't work because the symmetry
is the other way so you need to figure
out this trick and then the lookup table
is of this size now the or is or if it's
very two-bit you can do SMD order it's
really fast so you forever block so it
does by you like two orders of magnitude
any other
okay so so then the next potential of
the comp of this kind of approach which
we haven't done yet what we are hoping
to do is that now we are targeting only
CP architectures and lots of things here
are really specific for Sora and could
be ported to glue or whatever wherever
you have your cpu running it with a
single core now the so that's what I
call like symmetric multi-core let's say
multi-course multi core intel cpus and
so on now other options are you can have
DSP SF pjs lots of small multi-course so
be really interesting to understand how
can you map these things if you can map
these things efficiently to the core a
nice thing would be that you can write
code once and then you can run anywhere
right and that would allow a research
community to compare the code to do
benchmarking to share the code in all
that right so I think it's kind of um I
like the idea because of that and that
was the motivation for the project to
try to kind of make this whole area a
bit more coherent so people can you know
collaborate more closely in terms of
code as well so this is a kind of an
interesting thing and then the key
problem here is you have different types
of parties if you have data process and
pipeline parallelism you know then you
have this thing like SIMD instructions
you have a coprocessors maybe have DSP
if you have a DSP block you will have an
FB Jacob sorry FFT coprocessor and
decoder core processor and so on so
they're interesting questions there how
do you see in your code which
coprocessor we can use and so on so this
is pretty much open question so what we
actually do is just we support SMP so
symmetric multi-person multiprocessor
machines like intel multi course we
support pipeline data parallelism i'm
going to briefly mention it next and we
support SMD so this is something again
you have an intel cpu so it's really
like a mainstream platform so the data
pipeline parallelism again this is the
we again borrow the low level c code
from sora but the interesting of the
ration here is that we can really do
something like this if you have this
pipeline you can just put a special
operator which put this bracket and the
compiler then we'll go and insert
rewrite this into putting the queue on
this side so they will say okay this is
on one chord
another car so on this score i put a
queue and then on the other caught up
with the other q and i'll just read this
Q and I do all the synchronization for
you completely automatically right and
so basically i put this core to this
thread to pin to core one to this to try
to court to and give them real time
access and i can speed up the things
right so so there is flexibility there
and the pipeline polarization is
relatively safe over there still cases
where it's not obvious in in Syria so
this is still kind of all this
polarization still kind of work in
progress but there are lots of cases we
can do that and we can use politician in
Wi-Fi design to to again make it work as
fast as we need right so like this is a
synchronization Q so I want to give you
a simple code example so we talked about
the we talked about the Scrambler right
so I just want to run the example with
you so it's the same code we saw there
and um let me see how is that going to
work so so this is our good start
maybe I put it here
scrambler I think this is the one
this is not that one
okay so this is a kind of the the
simpler code like scrambler but you can
write anything so the benefit is that
now you can change its groundbreaking
shine you can change the code you
actually run and the compiler will be
able to do it automatically so you
should be it's very similar to we did
before it's some kind of state machine I
just typed in something right and so the
key thing which we instrument here is
this thing which says I know this is a
lookup table right so you could maybe do
it automatically we haven't done it yet
but it's certainly easy for me to see
okay I want to vectorize this into size
aid because I know it's going to look
update it's going to create the look up
table it's easy for human is difficult
for for a computer so we didn't
automatic I think you know but so that's
the only instrumentation we put here
right so now I'll just go and
right so
one thing
so this is called so i'll just do make
of this thing
so what I'm saying is I suggest when i'm
done the output so you can see how the
compiler created this code so what is
the kind of optimization it did and
basically if i don't give it any this is
the thing so if i don't give it any i
give some input
I didn't give all the sorry I have too
many examples i'm getting of compute so
see
let me try to do it this way
so what I'm trying to do is basically
i'm running this and this is the amount
of time it takes without any
optimization so if i'm so the only thing
i need to do
to make it optimized it just put two
switches so basically that's edit this
vector as a no to loot and then
something is wrong with this thing the
other examples work better sorry for
this one I kind of changed so many to so
I basically I won't show you this
difference in the in the performance but
ok at least I kind of showed you that ok
this is the type of code we can run in
the annotation we have to add there and
i'll have more successful devils
afterwards so sorry for this one I think
it the other ones I'd practice more so
ok coming back to the to the Wi-Fi
basically we had them so this is the
kind of performance relation with it so
we implemented the entire Wi-Fi reported
the Soraa code and again the algorithms
that we used are the ones they did in
sora and pretty much the optimizations
are kind of similar the only thing is
that the code is very simple and all the
optimizations are detected automatically
right so the same nature of musician but
they're all done automatically so so
here I'll give again I'm giving you all
the receivers right at different rates
and then this is the the throughput that
is required in mega samples per second
right so it's somewhat basically here
here is a what sort of does here is what
we can do and this is the this is
basically the Wi-Fi requirement right
and so we do lose a little bit right but
basically we get much easier to write
code right so there's much less you have
to worry about so we loser I guess I I
don't know twenty percent or so on the
transmitter site and so these tuples
right are mega samples per second and
each sample is complex 16-bit number and
so we get like mega so form four times
despite per second so it's a kind of
coin high speed and in all cases we kind
of meet the Wi-Fi requirement so even
though we lose a little bit on
performance we can still comfortably run
Wi-Fi receiver at 40 40 40 minutes and
this is on a transmitter side right so
here we are possibly not as efficient
doing look-up tables because
they can do that manually and we
discovering the compiler but
nevertheless we kind of sodas are again
that the requirements now the here the
requirement is basically you have a
constant stream of data that comes in 40
megabits per second no matter what your
rate is you need to process data and
forty megabytes per second and down the
line you'll trim out something and you
will have a lower processing great so
that's why the requirement is constant
here on the transmitter side right your
data input comes at the rate which
matches your transliterate right because
it's bits per second so if you're
sending 6mm megabits per second you need
to feed in six megabits per second so we
are able to process again way faster
than that and again this is even when
there is a bigger difference with
respect to sora but this is because it's
suboptimal when discovering look-up
tables and unrolling them but again we
have a flexibility we don't have to do
it manually it's all pull the
automatically done so another thing we
did we did the kind of an LT like demo
it's not a fool implantation royalty so
we had that the resource blocks we were
able to populate the frame put the
reference signals the psssss and send
these subframes and kind of create this
grid and then we do some random encoding
of packets inside so we have the basic
signal search in there implement and so
on we had two solar boards we didn't do
it on very large distances but basically
we were able to write completely news
zrya code for a LTE receiver without
even know just from scratch without
popping anything and we were able to get
the real-time performance at 20 minutes
already right so so there was no
extrapolation it was really kind of just
developing the algorithm so I was quite
happy to see that because he was a
completely new project with where we had
to really design only the algorithms and
we had really spend very little time
dealing with all the other optimizations
which he had to do in any other tool so
I kind of was quite happy with these
kind of experimental result of the
program so this is the last slide about
about Syria and next I'm going to move
to Wi-Fi
so we did okay we did the basic cell
search so we did the the things inside
we were cheating we encoded we use it
Wi-Fi encoders because as we have an
implemented right so we have all this
grid and then we do random well we just
pack pack it in there but it was easy
because the Syria is very easy to inter
interface right you just you know it
checks the types you just put it in
that's all the vectorization for you so
it literally took the Wi-Fi decoder
encoder plug it in there and said okay
will encode our packet in the whole area
I just work so that but it uses I don't
know qpsk 11 half coder for from Wi-Fi
on a topic so there is something we go
get data to right so it's released to
github under a patch 20 so you can
download it we will we are hoping to
very soon have a demo where you can just
take the code take the Wi-Fi you need
sir aboard you plug in your two swords
and you get your Wi-Fi code running
immediately right so that's the goal in
we have a few demos coming up so we have
to get this ready very soon right and
this is in this implantation including
release and pretty much the things I'm
going to discuss next are from not the
exact code from the release its kind of
adapted to show you the showcase the
things that are interested from Wi-Fi
design point of view but they're kind of
the same algorithms in the same ideas as
they're in a regular Wi-Fi and again
this is that the algorithm design comes
from Sora we just did it much simpler
than my much higher level right and so
essentially at this point we depend on
CP and SMD SMD vectorization is done by
a programmer right so we haven't we made
it easy and you see we made it easier to
write back preparations in snd but you
still have to do that manually as you
have to do other stuff like this lookup
table things some algorithms will not be
able you cannot do by a compiler you
have to you have to give something but
it's relatively like this permutation
algorithm we now give us a library
function so you don't need to worry
about it you just call this permutation
it will do this for you and then we are
looking into pulling for either
cpu-based things ok so we're coming to
the case study of Wi-Fi design so here
basically I want to go through the basic
Wi-Fi design
and so so motivation here is that what I
what I see in the community is that the
wireless architecture and design people
are looking at the the two communities
they're looking by fire protection
designer fragmented so you have lots of
e guys who consider lots of physical air
do a little bit of Mac but they rarely
go all the way to building systems
looking at the application layer issues
you know running TCP ran understanding
you know going all that way right and
then you have a CS guys which start
usually considering from mark and above
and they go from the high level and they
try to hack all the way they can but
they stopped pretty much where they have
the firmware and so on I mean there are
obviously exceptions and but it's just
like this is the kind of general feel
and so I think one of the reason when I
talk to people about it I say why don't
you you know give to your students
software idea to try to kind of
implement everything all the way and
they say oh it's too difficult they
can't learn all that and it's true right
if you want to program if you get an
fpga radio you can spend a year of your
I don't know three years PhD if it's a
short one just learning how to start
anything and then you need to start you
need to learn how to program the thing
need to learn about the optimizations
you have to do and you need to learn
about signal processing things and you
need to have your own ideas and you know
all this stuff so it's you're just
overwhelmed with the things you need to
learn and so basically the goal of this
is to try to remove some complexity and
then you know give this to a PhD student
who can then use it and say okay well I
don't have to worry about look up tables
and to worry about course I need to do I
don't need to worry about real-time been
pinning trick or real-time priorities
vectorization all this stuff it should
be taken away so the actual burden of
student is just to you know do some
algorithmic research and it Drive I try
it out so this is a goal right we are
how far we've gone we'll see but that so
then we can we have hopefully some
opportunities for synergies and the
other thing which is important for me is
that you're able to build bigger
platforms right so so so basically when
you could build a code for example
inside a group you build piece of code
the next student come
wants to pick up well pretty much from
the code you have now it's kind of
impossible I'm find it difficult to use
my own code in the next project let
alone somebody else who is less
experienced in working this area pinging
up a code and it's just very very very
difficult I mean those of you I guess
work with in having this experience so
really is kind of trying to facilitate
wireless designed in a way that open
source community have done for I don't
know MapReduce or this kind of Hadoop or
these kind of things you can actually
build bigger systems compared and so on
so it's a big goal but at least this is
a kind of step there so let's let's see
how far we can go so why is this exam
why is this interesting to do synergy so
you know as lot of people think okay we
have these layers for reason mark and
Phi and so on there lots of interesting
examples some of you might be there I
think maybe they mentioned some of them
last week is basically that you it's not
about having spaghetti design where you
can do everything physically the upper
layers and so on but but you can rethink
the fundamental layering of the of the
wireless and there's several good
examples for that so if you think about
how did Eric you write less code right
so that wasn't there I mean Wi-Fi you
don't have hybrid Eric you so basically
and you can't really implement it
because that's the way mark is designed
so there is no notion of being able to
keep the packet knocking LT you do have
it but that comes with a whole new thing
of standards right so is there a reason
not to put some of these things up front
as a separate blocks which people can
change and you know use other stuff and
then build a Mac upon it with assuming
different underlying API so basically
similar like write less code I think you
heard about last last week and so on
then so here's the correlation detection
so we've done some work there as well
and so and so I thinking up in the
morning hope you heard about the
inefficiencies of AC and so on because
of these detection issues so the problem
is that you know this is not really
exposed to to to the medium access
control right so you could maybe have a
different parts so what you have is just
energy will have some CC a procedure
right so you don't know if it does
energy tection or does correlation what
level of correlation does so all these
things are hidden because the
I mean I think that let's be kind of
very generalizing CS guys usually we
don't understand it so they just like
this abstraction of challenge three is
channel is empty right but if you
provide an instruction that say okay I
have some reading some correlation
something that you still need to think
of there's lots of information there you
can't just give the sample the whole
waveforms there inq samples due to the
mac because it's too much but you can
give some other details about the signal
and there's lots of you heard about them
correlation detection in the in the
previous talk right so you can give lots
of other things potentially to a
designer to deal with it and then so to
address this huge inefficiency right now
you pretty much your hands are tied you
can't do anything you just have this CCA
which is giving you yes or no right and
then ok the other thing that I've been
working on before and other people
working on to use our channel impulse
response for example for organization
these are just three random examples
pretty much so if you if you have a
channel impulse response from a channel
you can do much better localization for
Wi-Fi then if you just have an snr
because snr is some kind of aggregate
and it won't allow you to deal with
multi-part and other stuff if you
actually expose this channel impulse
response it becomes way easier and you
get much more information the
localization is more accurate and this
is not very difficult I mean even some
of the int'l cards kind of accidentally
expose it so you just get it from a
header you don't need to give me all the
inq samples right you can just give me
the ones from channel estimation and I
can do lots of things with it or you
know I can do maybe cognitive sensing
with that as well right some kind of
commune sensing so there are lots of
things you could do if you're able to
rethink these kind of designs and don't
not have such a hard line between a mark
and physical air so and and I'm instead
one of the goal here is that you know if
you're if you are able to come up with
these blocks and hopefully that's going
to be maybe a future research come up
with different physical are blocks that
are useful for the system builders
afterwards right with the right
abstractions we drive algorithms the
whole networks will be faster and more
efficient and so on and so the goal of
the tool is kind of help you do that so
so I mentioned some of this basically
five level is in Wi-Fi five standardized
you cannot really change it
you have to feed the pipes in the you
know the bits in datapipe you get your
bits out and then you can just do tricks
like okay you might you might change the
mac you can just get a data even with
errors and try to beat the bits with
kind of hard decoding and do some post
processing out of it but it's very kind
of solid very very very well-defined api
between the mac and phy which you can't
really get in and people do lots of
innovation on on a Mac layer so they're
people that we design the firmware for
some cars you can write your own mark
and so on and lots of interested in
coming out of there but still because of
this because of this interface to fight
there's lots of innovation that cannot
happen some of this I mentioned there
people do it in soft radios now so so
for for similar its kind of even worse
because you pretty much you get your
dongle or your phone and you you can
just get laid out you can't even change
the mac the base stations you can't even
touch so it's very difficult to
understand the scheduler inside and all
this so the only innovation you can do
is try to go from the upper layers and
for example what people do is try to
figure out okay so when is the base
station going to wake me up again so I'm
going to learn that pattern and I'm
going to save my energy by optimizing
for that so you get very very little
information so again if you had more
information there and if you have some
different design you could be able to
that so you can experiment with all
these things we software find right here
so that's the kind of and then if you
have a good ideas and good prototypes
you know hope is that could become
standard one day so so what happens in
reality and then lots of people kind of
it's not a new idea i mean people have
noticed that that if you look at the
most of the wireless designs nowadays
they have lots of standard blocks which
if you go to a few if you try to design
anything in a DSP when these DSPs are
already equipped with correlators that
with the coprocessors they do these
things fast so it's a so if you look at
these standard blocks right there there
is no reason why some of these would be
exposed to you as a natural designer in
a smart way right not just giving
everything so that you can actually
build network from the standard rules so
you have to expect maybe some
certain ground rules but you can
redesign your max and you you know you
can do all this kind of crazy stuff in
there if you want so so okay so now I'm
trying to basically assume that you are
very interested in this topic right and
you want to jump into doing this kind of
cross-layer design and you want to build
your own system which you want to
evaluate on so the first thing is how to
design a wireless transceiver ok so you
don't know much about it for example you
know some basics but actually I think
even if you know signal processing there
are lots of small tricks which are not
really rocket science but you kind of
need to learn understand its kind of
mixed of I guess industry experience and
experience of design these things and
what hardware can do and so on which are
kind of decided and decide on the under
under under receive on the transceiver
design and so here basically I'm just
taking one part and again I'll use
mostly algorithms restaura because
they've already done it very nicely and
it works in that in real time but so
basically ok first I want to touch on
challenges on them so the issue is
performance obviously you want to do it
you want to do it real time on the line
speed the second into the second thing
is complexity when I have a flexible
system so these DSPs are very difficult
to program and even though they are very
low power and so on you don't probably
want to experiment with them because
there's not an experimental platform and
then the other thing if you want to you
know if you want a commercial or
something then you don't need to worry
about the cost of these things about the
patents so there are lots of stories
from the industry for example LT has
lots of patterns there so if you're
selling an LT chip you know you need to
be aware that you have to pay I don't
know how much dollars for every chip for
the patterns where if you sell Wi-Fi
chip you don't do that or a gsm the
other thing is also um I don't know who
owns now pattinson ofdm but for example
there was a remember back in the days of
ultra wideband so in toulouse pushing or
DM you try been only because they only
had a receiver and transmitter a new toy
been so for them it was cheaper to build
it you know at the end regardless of
whether it's a good technology or not so
they're all these things in the industry
so it kind of is difficult to understand
what is the kind of best thing i'm not
trying to answer all these things
kind of trying to give you one idea how
to choose your design right and and and
how can make this initial design from
where you can actually learn an
experiment change a bit of sun blocks
and see what you can do with the hole
with a whole network so that's the kind
of goal of this the remaining of the top
so okay the first thing we have to ask
is which physical air will use there are
lots of them out there and so for
example I mean cdma still widely used
and the reserve diem so the question is
which one do you use right so we will
use right them because it's the one we
have but there are there's a there's a
better reason at that I think so the
cdma basically in a nutshell it uses
random codes to the random codes to
combat multi-part so you sent you you
you take your symbols module symbols you
you scramble them with these codes you
send them out so the process that is not
as complicated to implement and but it's
difficult to equalize over wide spectrum
so they're different trade-offs you can
do it with in there now the ofdm is a
different way basically if you see
subcarriers so it uses frequency domain
instead of code domain to to to deal
with multiple so it has a great
robustness and less complexity but
actually for it's more difficult
implement for us or for simple receivers
so and it can achieve higher spectral
efficiency so pretty much the rule of
thumb I've heard of is that if you want
to go for very low power low rate
receivers you you you should go for cdma
or other kind of things but if you go
above 10 10 Mbps or so you're safe of
using or at the end right so that's why
most of the today's I think I have it
there yeah so most of the today's files
are using are using ofdm anyway so I
think it's kind of a safe bet to assume
that's the kind of thing you wanna
experiment with and so in particular
Wi-Fi LTE wimax and the six new 60
gigahertz are also proposing to our DM
what is the reason again I think it's
definitely a good technology it's
difficult always always to know whether
it's because one
many as patterns in there so want to
push the standard and they're strong
enough or or but it works fine and so
the other example to a DMA and OFDM a is
used is a variant of OFDM which is
essentially the basic principle are the
same the only thing you do is multiple
users can share the same atom symbol
both uplink and downlink so and then you
can do mark scheduling it simple level
and so on so that's an interesting
example of of what I've been mentioning
before so if you think of it to some
extent of emea can be seen as a kind of
a mix of physical Aaron mark and if you
look at her if you look at the LT specs
it's not really clear what the markets
right you have the scheduling of
resource blocks they're happening pretty
much of the physical there and then you
have to do time synchronization
different levels so this distinction
really in the modern seller system is
very blurred and you know you when you
talk about Mac there's a lot of
confusion repeat talk about low level
mark or higher level mark and so on so
this is an example of this kind of
synergy in my mind that coming coming to
do to their so basically so but the
bottom line is that if you thinking
about Doyle dma most of the things I
mentioned here really hold because you
need to do a proper signaling and
channel pilot estimation all that
already before you start doing the ofdm
a processing for taking out different
users and so on so this basically the
base basic things here really applied to
most of the tip to most of these things
to do what I'm going to talk about
anyway right so so I'm going to give you
an overview of a transmitter and then
just give you a brief discussion of what
each block is useful and for some of the
blocks I'll um I'll demo I'll try to run
the code and show you the output and
give you an idea how what kind of what
kind of things why they use their so
there's lots of very nice mark behind
all this but I'll avoid any math now
because I don't have enough time and it
takes much more time so this is really
almost like an extreme
session well give you a very high level
idea with simple examples why you do at
the end the way you do right so of
course if you're interested they're very
there are lots of nice books where you
can read about it it's a basic basic
wireless system design the other thing
is also some of the things I'll discuss
is actually how do you do this
efficiently on on a cpu on how you can
do it efficiently on Sora in
particularly implantation we have in
Syria which again should be portable to
most of the new radios blade RFS and all
these systems that use CPUs right so
here is the baseline a basic transmitter
in a nutshell so and I'm giving it in
Syria code so all these their functions
between plan and separately but this is
really copy paste from from from the
implementation so first thing we do we
create an SDS symbol in time st symbol
is the preamble so this is a fixed set
of iron q samples that you're going to
send so you create them ahead of time
and you just say I amid this on the air
and the next thing I do I amid my LTS so
this is the first part of preamble is
the thing you use to search in time for
your packet okay and then the second
thing is the thing you use to estimate
your channel so basically once you found
your ears packet you use this to do
equalization and I'll talk about it in
more details afterwards so then so this
is all the this is bit semi columns
means i do first this then this and then
i do this big bunch of things right so
what i do then i have a package so
packet comes in here right so these guys
are executed before the packet even
comes so that my data starts coming in
here and i do the crc so crc and this is
the thing I like about it was one of the
design goals of the languages we clearly
see whether the chef States so the CRC
depends only on on this parameter here
and this is this is coming from the
header which I which I omitted for Kyle
it should be a header pressing before
this right but there is a clear sharing
upon it you exactly know what happens
here right there's no other shared state
except for this so and so why do I put
216 so this is the padding thing
because you're sending these IBM symbols
and we'll talk about that IAM symbols in
a moment you need to make sure if you
finish in the middle about the symbol
you cannot really send half of a dream
symbol for to create energy symbol you
have to have pool ofdm symbol of data so
we just make sure we dis padding we are
adding whatever we send has to be a
module of 216 so if you stop at
one-hundred we have to another add
another hundred sixteen dummy bits to
make sure we send the exact number of
empty of symbols then this thing is
getting scrambler then it's getting
encoded then it's getting interleaved
and then it's getting modulated then we
add pilots we do ifft and then we send
ok so again this preamble detection was
good preamble first channel detection
estimation so the CRC the basic idea of
crc when you do all this to the receiver
you look at the packet in look at the
crc if your CFC is wrong you throw away
packet you did the best you could with
your packet decoding if you couldn't
because it okay so you throw it away now
the scrambler it prevents high peaks in
a date and i'll show you that if you
have a very kind of to smooth data like
a vault zeros you could create some
problems we'll see you later and so
basically you want to scramble to avoid
this kind of very to too obvious data
patterns and then you do coding i
suppose most of you know what the coding
is but basically okay that a nutshell
you send more bits so that at the
receiver if some bits are corrupted you
can do some clever algorithms to remove
get information out okay then
interleaver so the basic idea of
interleaver is when you send your code
out there will be and you send in
frequency they'll be low there we are
somewhere right maybe your channel is
bad in some cases and usually the
servers are correlated if you look at a
channel it will have like a deep fade
and at some point so if you think about
it you when if you lose some bits or if
you have been information at some beats
they'll be very local right so here you
do some kind of random permutation at
the transmitter so to make sure the
beats when you decode them the bits that
have local errors I'm going to spread
all out and let's simply the nature of
the codes the codes can deal better with
this if the errors are not local because
codes are operating locally that's
really kind of a
a technicality but quite important right
so modulate basically it's just the
regular usual thing you take your a few
bits and you map it in this
constellation thing I show one but I
believe you all heard about that the
anyway you should know a lot about it
and then you have to add pilots okay so
you will see also what the pilots are
used for but basically they're they're
used to track all the inefficiencies and
and and problems with receiver so the
fact the channel is constantly changing
a little bit and also your your clocks
are skewed and all these kind of
imperfect sees in the in the in the
signal it can be corrected with these
pilots and then you do I 50 and we'll
talk about f50 an OFDM in a bit but
basically this is kind of the final
block will explain a little bit later
sorry
yes yes yes you can you can add
different yeah we haven't we have an
important man was ourselves and I mean
I'm sure it can be done but you can put
more yeah this is all the code you can
put more blocks inside and so on yes so
I don't know if you want to add in here
some precoding or whatever you know it
won't you want to use but this is I mean
the code and i'll show some of the code
now it's okay so so one of the things i
wanted to show is like basically what is
the what is the ofdm so what is the
point of at the end so i guess and also
show you a little bit of demo how you
can do that with them with a cold let's
see i'm hoping and going to be more
successful now it should be so this one
is
so I have a lot of code here because I
don't want to right in front of you I
just want to kind of uncomment what I
want to show you and then run it in
front of you so let's see I'm first
going to run this one okay so what am I
doing here so if you look at this bit of
code so basically what i'm doing i'm
going to do take some bit input and i
created some random bit input i'm going
to modulate the bit input ok and then ah
ok so I want to illustrate what the or
DM is doing what the i-15 doing in this
case so I want to modulate this bit
input and then this block what is it
doing it's actually it's it's cheating
is just taking one bit of the output and
then meeting lots of zeros so what I'm
going to do I basically c0 is a complex
0 so I kind of take emit only one input
from the actual signal and lots of
zeroes right to just create a simple
sign what our DM would do and then I do
ifft right and then I plot this it's ok
so it's a kind of it simple then and so
how FFT looks like this is the one we're
using now ok so it's ok this is the
Soraa fft implantation this is the plane
f50 nothing special value so what you do
you basically say first of all I zero
out these things I don't really have to
do but I think it remained from some
other part of code and then I here take
I say take sixty four elements their
complex 60 numbers do the f50 and omit
nothing more than that right so so now
I'm just going to run this code
chips
and while i'm running I should get this
other guy ready is my mouth
yes
so this is my this is actually sort of
visualization
ok I think I have to do it once again so
I'm just running so there I created this
makefile just running a sequence so I'm
doing here I'm running this compilation
from zrya to see and then what i do i
run this completes is a visual studio
compiling from c2x a file and I just run
this on a file okay and so now i can use
this sort of debugging tool in my mouse
back here right now just this one don't
know so Mouse keep escaping there it is
so i can look at this thing ok so what i
have here
right so what did I do I basically
created 11 sine wave okay and so why did
I create one sine wave because I create
I take a vector of inputs and I
basically put the the put a 0 in there
so what whatever 50 is doing is taking
my vector is doing transformation in the
in the in the frequency domain right so
it's summing lots of signs right so I
guess you're all aware of the f50 is a
single protein right basically what it
means is that if I take a vector it is
all zeros and one symbol right it's just
going to give me a sign right and so
that's what I created here and then you
know I can create another sign so but so
the interesting I mean okay it's a sign
at one frequency right so if I so if i
give him so here i created the code that
is doing the same thing is just non-zero
inc the thing at a different frequency
right so now it's kind of sending a
symbol 0 and this was sending x0 and and
complex 0 and this is sending complex 0
and x 1 right so it's just a simple a
different frequency and so if i run this
one then will shortly see
okay so it's just a different frequency
right so every symbol is representing
different frequency and what modulation
is telling you so the actual stimulus
ending is where is the starting phase of
this thing right so if you change the
phase is going to move up and down but
you're sending a simple sign okay so now
what happens if you just step if you
just send two symbols right these two
signs together at the same time so now I
basically here i was taking two elements
and sending only first one and zero here
we're sending the second one in zero in
the second one now I'm gonna send both
elements i took some summing up the two
so it's really just the sum of these
signs right so it's the compilation is
slow not really the
okay so now it's so I have just a simple
you know a mix of these signs so I
actually you can see that so if you do
your f of t you see some crazy waveform
the reason why I see this crazy way from
is because you keep sending science
right and they just simply sum up in the
different ways and so in the end of the
day so I think pick everything here as
well so basically this was the point we
were sending in the first example so
there's a modulation here and then
basically means where is the starting
point of this sign right and it's a sign
at one frequency so the starting point
of this sign is a different modulation
point so it's a different frequency and
you just simply sum them up and you get
a second time right and if you put so
but this means i have a vector with all
zeros in my ifft and i put just two two
symbols in there and I get just two
signs if I put lots of them I get lots
of sign so this is my random arbitrary I
have to I 50 thing right so if you think
of it that basically because you do I 50
each of each of the symbols is traveling
is modulated in one sub carrier right or
one-on-one sign right it's kind of a
narrowband transmission on each time but
you are actually superposing them
together so that's the best kind of it
so you can actually control which symbol
goes on which frequency that's the the
idea so now that's the ifft thing right
so that's what happens with do I 50 now
how do you actually do it in Wi-Fi so
you take your um you take your you take
your thing here your data packet right
and then the first thing you do you
actually have to add this pilots so
we'll explain in a second what the
pilots at four and then you basically do
your ifft so if you wish so usually the
way people represent this the y-axis is
the frequency right so you put your
signals in frequency now you can't send
in frequency sending reading time so you
have to do this I 50 to convert this in
time and you get this funny way from
that we got before and that's something
you send on the radio but before you do
that you have to add a factor prefix
right and so will explain a bit what the
cyclic prefix is for right so that's
kind of adding the cyclic prefix and so
okay so maybe we can stop now for
for for a break and then I think we is
it now yeah and then we can we will fall
on afterwards
this is a fair comparison the same kind
of architecture right so here's one
chord is one foot we also both of us are
better we mean when we use to course but
we are still slower right really the
difference is because for example the
main different comes from mem copies and
we are optimizing that where you're
still improving because while they know
where the signals are going to and so
they can avoid lots of mem copying there
but we don't really know we don't we can
never fully understand the code right so
for example if I give you a data block
whether you're going to change modify it
or not so semantically you're not from
the compiler point of view not supposed
to modify so the way I do it I copy then
I give you a copy and I know you know
modifying it but if i give you the
pointer right I don't know whether your
my way sometimes in my analysis I can
figure out that you're not modifying it
and I'll detect it and I do a pointer
and we don't really do that yet but they
know it because they had optimize
everything right but that means your you
know your effort is much bigger so I
mean I wrote all these examples in half
a day all that you're seeing today and I
would like to see anyone writing these
examples in Sora well you have their
code right you know ok so if you call an
expert in Sora you would take much more
than that</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>