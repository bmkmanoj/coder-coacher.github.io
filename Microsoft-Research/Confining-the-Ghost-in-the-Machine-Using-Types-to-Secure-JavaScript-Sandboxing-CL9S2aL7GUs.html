<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Confining the Ghost in the Machine: Using Types to Secure JavaScript Sandboxing | Coder Coacher - Coaching Coders</title><meta content="Confining the Ghost in the Machine: Using Types to Secure JavaScript Sandboxing - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Confining the Ghost in the Machine: Using Types to Secure JavaScript Sandboxing</b></h2><h5 class="post__date">2016-08-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/CL9S2aL7GUs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year Microsoft Research hosts
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
yep so it's a my pleasure to introduce
Sri Ram Krishna Murthy who's visiting
today for Simon's Cavs workshop but has
kindly offered to give a talk on his
work on JavaScript so I think for many
programming language research as
javascript is a bit of a kind of figure
of fun but well last time I saw him talk
about JavaScript I I found myself
actually respecting the language to a
certain extent oh my goodness I are you
gonna work at all then I have to worry i
have to work there i'm getting here so
and as recent developments are shown i
think we need to take javascript quite
seriously especially as it's forming no
part of our strategy at microsoft so
streams going to tell us how to make it
safe i think thank you thank you thanks
for having me here thanks for coming
despite the milner workshop so that's
tough competition and so we all know
JavaScript we've all seen a mash-up or
two on the web here's the most famous
mashup it's the one that introduced the
word mashup to into our vocabulary it's
from a mashup of craigslist and Google
Maps and it's called housing maps com
very famous feel big splashy thing on
the web and said it was the starter for
mashup revolution you all use mashups on
a daily basis yes or no perhaps not so
but perhaps there is so perhaps the
revolution is not here yet or perhaps we
don't know so you know if you're a
university professor in the u.s. you're
required to read the house where AG
which is the new york times now the new
york times is the very opposite of a
mashup right because a mash-up is just
combining data from random places and
putting them together New York Times is
trying to be an authoritative that you
would like to be where's the mash up
here yeah so all of those ads and if
you're like me if you obsessively read
the source of pages rather than what's
actually on them you see that it says
that this is getting content from pics
Oh for dot website net and if you go to
website net it's called audience science
and it even gives you a little periodic
table of users so you can guess that
maybe your privacy is not in their best
interests all right if you go to the
opposite end of the world hears you know
new zealand herald code NZ which is a
terrible newspaper but it's their
newspaper and if you look at their
sources there's a content add content
coming from all over the place in
particular there's this thing from AMG
dgt com and there's the source well that
doesn't have a privacy policy well we're
word at am GT GT calm doesn't even exist
and if you go to the ad server geeks
will recognize that as a server whose
home page has not yet been configured so
you know that's the state of content
coming in on the web these days and all
the stuff is being put together on a web
page now why does this matter because it
matters because you go to some host that
you presumably trust or want to do
business with and this host is sending
down a web page to you which seems
innocent enough except this web page is
pulling in data from all sorts of other
places such as ad servers but it's not
only about ads which so far still looks
good i have a blue box in a red box
unfortunately there are no blue and red
boxes on the internet in your browser
there is a box and all these things one
with everybody else's privilege in other
words we're back to Windows 3.1 which
even Microsoft can tell you now is a
mistake right so that's the that's the
execution model of the web so what can
these malicious programs do from
third-party content well here's one
thing they could do they could write
this line of code in JavaScript called
window dot location and what that does
is effectively takes that string it's as
if you put it in your url bar and hit
enter okay now the thing about this
about web content is I mean you don't
actually know what's happening in the
world wait i mean there's a page that
says the following things happened and
maybe that's the truth and maybe it's
not and maybe that's what the new york
times is really reporting or maybe not
but maybe you're like me and you
obsessively look at URL bar so you
wouldn't fall for a trick like this but
instead here's a piece here's a
different piece of code
it's you don't even have to hit refresh
the point is this is as if you put it in
hit enter automatically so it
automatically redirects you it's a
redirect that's right right right right
except the URL bar looks looks now
different right so if you pay attention
you would notice I'm actually at you
know bank of america com or something
like that okay but here's something a
little more subtle which is you can go
through so this is the power of
JavaScript being exploited right
javascript makes it very easy to find
all the elements on the page that have
the a tag which is in other words links
and now you can rewrite all of those
eight tags to instead go through some
tracker that's tracking what articles
you're reading or what you're doing or
something else and it might even be that
this adcom then redirects you to the
actual news page so you don't even
realize that you've gone through some
intermediary that's tracking your
behavior now if you look at this you say
well it's pretty obvious right we should
just statically reject these pages why
is somebody being allowed to write to
window dot location why is somebody
allowed to write a document so let's
just reject all of those things
statically but of course this is
JavaScript which means you have this
wonderful property feature called eval
and this is the interesting thing about
eval you mean val is a is a is a is a
programming language feature that always
elicits some reaction or the other from
a crowd the real problem with eval is no
matter what static guarantees you erect
for your program there is a dynamic back
door around those static guarantees that
the static checker never got to see
there's parts of a program it never got
to see that's the real problem a devout
question some there's actually been a
pretty good study of this by Gregor
Richards and he's young b.tech student
but the predictable title the eval that
men do and I seem to remember their
findings were about eighty percent of it
could have been rewritten to be much
less harmful he could have gotten rid of
all the ugliness but about twenty
percent of it you know people are the
code patterns people it's it's what you
expect right random yeah yeah so so
something that's clearly what you need
to do right it would be pretty harmless
to get rid of a bell yeah it would be
and I say harmless it would be it would
not be a major intrusion on programmers
freedoms to get rid of a bell and it
would be a good thing okay alright so
that's the real problem with the eval
and so then of course there's you know
it's JavaScript so it's obvious what
this is right this is this is window dot
location and there's actually a website
that will convert any JavaScript code
into something that uses these strings
for you it's you know the usual
amusement okay so this is the kind of
thing that your ad could be doing so
this is the kind of read code that could
be running with the Bluecoats privileges
okay it could also be talking back to
the host server it could be talking back
to the New York Times or to the Facebook
server okay so here's the kind of thing
it can do and this this chunk of code
I'm going to go through and steps so
there's an operation called window dot
XML HTTP request which is basically a
way of saying please connect me back to
the server that I came from so connect
me back to the blue server okay and this
is a mouthful so I'll just call it xhr
as all people on the internet do now
this is a kind of important JavaScript
detail and this is where JavaScript even
though it claims to be an
object-oriented language behaves very
differently than traditional
object-oriented languages do as this
Python as does Ruby as does Lewis so
every modern scripting language has this
feature or bug which is that when you
write something like Oh dot f you mean a
static dereference of the first order
name f but it's actually purely
syntactic sugar for turn f into a string
and look it up dynamically in this big
array of properties that oh has and
there are some wonderful bugs that you
can discover in this way you can for
example use this kind of thing to we
locked up Google we locked up google
docs for example using this feature
because because of the because of this
this problem that something is both a
dictionary and an object and it's in
certain contexts you can confuse it from
thinking one as the other okay so this
is this is just a underlying reality of
JavaScript code and this is a difference
from say Java almost
or the first member yeah yeah I am
because um the thing is that thing in
double quotes could be a cut could be a
generated string it could be a
calculated string because it's a string
that's right yeah a little bit like
about effective sort of sort of yeah
yeah after of the matter of the members
name it's a very specialized eval yes
okay so when I say window dot xhr what
I'm really operating on is I'm calling
window of this string okay so here's the
kind of thing that this malicious code
could do it could create one of these
objects and if it happens to know where
the where some method resides on the
server it could actually invoke that
method so it could you know if it knew
that the privacy settings are behind the
URL set privacy it could send a message
there and change your privacy settings
yeah yeah yeah not yet not yet but it's
a good setup for something that will
happen in a little while okay good but
but not for this particular example now
okay all right so people have known
about this for a long time in 1998
hotmail introduced this wonderful
feature which is you could put on HTML
in your messages which meant you could
put javascript in your messages and you
know in about two days you had messages
like this hotmail open to attacks which
of course explains why in 2010 this is
now a feature it's the same thing by the
way oh the attack is I can put
JavaScript inside my email message to
you which then goes off and you know
does whatever evil thing I forget which
particularly evil think this attack did
but you know the point is you're
expecting you it could be changing
things on your page it could also be
talking to the server okay the point is
you expected your email message to be
inert at best you expected it to have
some local reactivity maybe a little
spinny thing in there
then you have these problems right but
but now you can actually do it and it's
considered a feature it sits in its you
know they forgot that they introduced it
about 12 years ago so what changed well
one of the things that's changes people
are now aware of some of these problems
and there are now commercial solutions
to these problems Facebook for example
critically need solutions to these
problems because Facebook depends very
much on you being able to put farmville
inside your Facebook page this is the
business model of both Zynga and
Facebook but if you look at their
filings you know both of them are deeply
antagonistic to the other right they
sort of tolerate each other for their
purposes but they both the tagging istic
and neither one wants the other one to
be able to come in and do something
delicious to their users right so
Facebook certainly doesn't want to let
Zynga be able to modify your Facebook
settings and vice versa so Facebook
needs this kind of solution Yahoo needs
this kind of solution Google needs his
kind of solution so a lot of companies
have gotten into the business of trying
to define sandboxing solutions for
javascript which is basically i drew you
this virtual picture of this blue box in
this red box let's keep the blue and red
boxes as red and blue boxes okay and not
have the merge together that's that's
what a sandbox is trying to do but if I
wear my PL researcher hat of course I
see this as a different different thing
they're trying to do which is they're
saying JavaScript and this and it's not
just JavaScript right it's this
environment that JavaScript runs and
this environment is too powerful a
programming language and what we want to
do is define a sub language of it that
is still effective for people to provide
programs in but much safer right and so
now this is a PL problem this is our
business okay kaha the qajar team and
just to give you a point to some of the
difficulties here these are large
collections of some i ad hoc javascript
these sandboxes so the caja team
actually brought in an external security
review team and they said wonderful
things about it and cajas a very very
clever product but they also said cajas
very hard to review there's no map that
states what the invariants are and
points to where they're enforced which
of course hurts maintainability and
security and of course i read this kind
of text and i think you you're saying
there no types right so so this is the
karma is a solution to send boxing and
I'm going to talk quite a bit more about
10 boxes so it's just a name for now
it's a Google product that's very good
but has this problem that people
identified and add safe is yahoo's
proposed solution and if you look at you
know when ad safe was released this is a
message that went out I need your help
in testing its robustness are the rules
sufficient etc etc etc and essentially
it ends with if the program produces no
errors under this condition I will buy
you a plate of shrimp so if you can
break it I'll buy you a plate of shrimp
security by shrimp okay so perhaps a
better name for ad safe is at safe and
that's the ? we'd like to get rid of
okay so let me give you a high-level
overview of the structure of these
sandboxing solutions there are lots of
technical differences between them but
it's you know from 30,000 feet they're
all the same which is the following the
first is they are going to statically
reject things that that will destroy any
invariance like eval and I'd have dot 0
dot that because there's other eval like
things not the field dereference but
other things that give you the power of
the full power of eval so those if it
sees them in the program it's just going
to say sorry I'm not going to let this
program go through but the problem is
there's a lot of things that are only
conditionally bad so like you know if
you dereference xhr that may be a
problem but if you'd be referenced some
other string that could be just fine so
those are conditional things so it
rewrites them into guarded operations
okay and these guarded operations are
going to come from some trusted server
okay so those are rappers that are going
to check whether you're using look up in
a bad way if you are they going to
terminate execution or something like
that it's not to let you continue okay
so this this paradigm of checks wraps
and rewriting is a sort of standard
terminology in the web sandboxing
literature but it's always good to step
back a little bit and never mind you
know the web blah blah blah this is a
much older is much older name for this
which is these are reference monitors
and if you go back to the original paper
that introduced the term reference
monitor which is a I believe a miter
tech report from 1972's of gem of a
paper and the person who wrote it
pointed out what what the properties are
that a reference monitor should have for
it
vacation the first is it should be
tamper resistant because one way to
break this as I just break into the New
York Times server and produce you know
stick a lookup function that that allows
evil things to happen the second is it
has to always be invoked pretty
obviously right that's the reference
monitor part and the third is it
shouldn't be circumvented I'll tell you
in a moment what sir commendable means
so let me give you a very simple lookup
function okay so I want a guard against
you being able to access the xhr method
that's the guard I want to perform and
I'm actually exploiting the fact that
the field name is a string right I can
basically do my meta programming in the
language itself because I can I turn it
into this function call where the field
value became a string and so I have this
function that takes an object takes a
field name if the field name is the
string xhr I you know I slap you on the
wrist otherwise I let this to operate so
far so good very very simple reference
monitor and some of them will rewrite it
for you others will expect you to have
rewritten it yourself so if you put
brackets it you know if you if you write
the bracket in there it'll statically
reject it saying you should have written
look up instead that's that's a that's
an implementation of difference okay
assume that the rewriting was done by
machine or man okay okay so here's your
reference monitor it's all it's obvious
to everyone that this is buggy right
well actually here's what you can do in
javascript since JavaScript wants to be
maximally permissive if the field name
is an actual string it will look up the
string but the field name can be all
sorts of other things in particular the
field name could itself the field name
could itself be an object and if it's an
object it invokes the two string method
of that object and so if i call look up
with an object that consists of a
two-string method now my look up has
been subverted r exactly the thing that
i'm trying to prevent okay so okay so
there's my second argument and so look
up is in fact unsafe so this is an
example of circumventing right i'm
actually using i'm sending a nasty
payload that makes the reference monitor
do the nasty thing that i was that it
was designed to prevent very simple
example
and part of the messiness of JavaScript
this is just sort of reality of the
browser is there lots of other evals in
the world yeah good so there are other
evolves in the world so here is
something called set timeout set timeout
is basically it's it's a way of telling
the co-operative multitasker put this in
the queue and when the timer elapses
please call this function okay so a
thousand milliseconds in the future
please run the function f but it would
be a huge it'd be hugely owners to
expect people to create functions so in
fact you can actually write a string
there instead which of course means
that's an eval right it converts any
javascript string you want into a into a
piece of executable code so so you have
to look out for these other things as
well so here's the structure of AD safe
I've given you a high-level overview of
how it works and there's you know
there's lots of entry points there's
these Dom calls that you need to check
for there's various assertions type
desks regular expressions so it's you
know it's a chunk of messy code and
that's what we want to set out to verify
it has both black lists and white less
yeah so the structure is yeah but but in
particular it has black lists that you
want check okay okay so in so this is
the same picture I showed you before j/s
lint is the name of the static checker
it's a link checker for javascript that
happens to have an option that says
please perform some additional checks
because I'm going to run this with that
safe so I have giant and if things
eslint will reject things like eval it's
like a code smell tester for JavaScript
and things that pass jslint are going to
be linked against this ad safe reference
library right that's the reference
monitor and so this is what we want to
verify now what does it mean to verify
because if you go to the add safe home
page it doesn't actually list any
properties or anything like that so we
went out and spent about a month reading
the code trying to figure out what
properties it might have sent them off
to the developers and said these are
what we believe to be the properties and
they wrote back and said yes
and here's one more so here are the
properties the first so the assumption
is that you've passed jslint you pass
the static check okay if you pass the
static check you can't load new code at
runtime essentially no eval or eval like
things yeah yes yes yes right that's
right that's right so no no evals
widgets can't obtain direct references
to dom nodes on the dom is the data
structure that it's it's a reflection of
the web page structure into a data type
in javascript it's kind of the power of
javascript is reactive data type you can
read it and it's sort of a live datum if
you're right to it the web page
automatically changes that's all very
nice the problem is that the Dom happens
to not be a tree it's actually a graph
and it has evals and things like that
sitting in it so you really don't want
to give the Dom itself you want to have
this mediation to the doll okay so add
see if is going to define something
called a bunch which is a gentle version
of the DOM and you want you don't want
people to get direct references to the
dog which it shouldn't affect the Dom
outside their sub tree either right
there's this expectation that i'm going
to give you this chunk on the page to
put your ad or farmville or whatever
content in and you shouldn't go
traipsing off from there to alter the
news headlines or the facebook status
and so forth and finally multiple
widgets on the same page can't
communicate so add see if gives you some
mechanism whereby midgets can talk so it
can also turn them off and you shouldn't
be talking to each other directly ok
this is the properties we'll see at the
end how well we do does the properties
we're trying to verify okay um let me
give you a sense of how this actually
works in these in these sandbox and
systems we have this property that says
widgets can't obtain direct references
to dom nodes so first of all jslint is
going to make sure that you can't get
direct references it's going to look for
you know there's it's all four letter
words like eval no these are all four
letter words and it's checking a whole
bunch of bad words okay so it says if
you try to do yes exactly so hey well
yeah so that that's the subtlety okay
we'll get there we'll get there so first
it's going to just check for direct
references to bad words yeah yeah
Global's that you shouldn't be getting
access to yeah exactly exactly / yeah
so that's trivial it's only going to let
the word bunch through it's not going to
let the word note through and see if is
then going to ensure somehow hopefully
that it only permitted safe methods in
this bunch collection so bunch is a new
data type and it's got a reference to
the actual node right the actual Dom and
it provides these things like a pendant
get text and these are meant to be
sanitized pieces of code okay now nodes
are sitting there and it's kind of
public because javascript is of course a
scripting language you can't have
private declarations and things like
that that would be too sophisticated so
just make sure that you can't say nodes
ada that's another kind of bad word so
it's basically making it a private field
and then add see if is going to
hopefully make sure that things like a
pen don't return the Dom hopefully write
it hopefully returns a bunch rather than
the Dom but you have to worry that the
code might itself be broken or maybe
there's a subversive payload that can
cause it to return something you don't
want okay so so this is the kind of
subtlety that you have to this is sort
of the reasoning that goes on to make
sure that this program is actually doing
the right thing yes that's right that's
right that's right sorry it's trusted
call it what so the thing is the point
of showing you that little look up
example I showed you is that you
shouldn't trust the trusted code right
right that's right that's right right
right so okay so we want to verify this
system and what we are after is
verifying add safe we want to check the
code of add safe to make sure it can't
be subverted but remember add safe is
running with the expectation that jslint
has already run right yeah in fact the
ad safe code on its own almost certainly
will fail to verify if you don't encode
the assumptions of jslint somehow right
because there's just too many attack
surfaces so we need to do two things we
need to first model jslint and then we
need to verify add safe against that
modeling so the way we chose to model
jazzlyn is through static types so we're
going to try to construct a static type
that represents the set of a loud
behaviors of code that passes jslint
okay so what are you allowed to do in
jail int well so I'm going to define
this type called widget so you're
have to declare you know constants
constants are fine they're basically
harmless so the widget type lets you
write down your own numbers and
boolean's and strings and so forth okay
you're allowed to define objects okay
but some fields of some objects are not
good so this name arguments is a bad
name because once you have arguments it
turns out it's another way of getting
eval okay so you're allowed to write
objects notice I'm defining a recursive
type here so star means all fields
except those explicitly enumerated and
things like arguments and caller and a
handful of other names the blacklist are
marked with this little skull and
crossbones well in the in the technical
development the skull and crossbones is
basically a type that has no elimination
forms okay so you can't wipe them out so
you know you can't construct you can
actually construct a type judgment tree
so that's what they are so think of them
as if you touch this the type checker
blows up okay so you can't write those
you're obviously allowed to write
functions but the functions have to
consume safe values and return safe
values so they're all widget to widget
and the dot r dot is saying they can
have any number of widget at arguments
but they have to return with your type
values okay and finally you're allowed
to do a certain handful of harmless
things like creating arrays and regular
expressions and so on okay so there's a
type that's about 20 25 lines long that
represents what we claim are the allowed
behaviors off jslint okay this is the
type we've constructed by sitting there
and writing lots of programs and
studying several programs and this is
our claim about its intended behavior
okay um beg your pardon some of those
ended up in the skull and crossbones no
no there's a dot a dot there's about 20
other things there there's a that's yeah
yeah it's all the bad words are in then
you'll see a little more a bad word
modeling in a moment okay good question
no okay stretching good okay
so this type we claim represents what
jslint is trying to allow a 25 line 25
line type is kind of a messy thing but
it's a heck of a lot better than several
thousand lines of ad hoc JavaScript code
that is claiming to represent a static
checker of programs now the question of
course is how does this type compared to
what reality is doing yeah yeah yeah
there's a little messiness with things
like you know prototypes and so forth
but yeah that's that is what we're
getting at that is effectively what was
that's what jslint was doing yeah and
we'd like to aspire to do a bit better
okay um but yes effectively you could
summarize it in those three lines okay
there's a bunch of things on that last
line other than that it's three lines
okay good so now there's a question
which is I've got my claim about what I
think GS lint is doing and there's
something that GS lint is actually doing
right and what's the relationship
between these we would like the
relationship to be the one I've just
shown you which is if the things that
pass jslint are contained within the
widget type then we can just use the
widget type for our verification and
know that we've covered everything that
Jess lint is going to let through right
in fact if it's a little bigger that's
actually okay right and it turned out
that this claim was not true we ran it
against the test suite of add safe so
when I say eleven hundred lines of code
it's actually about 1,100 tests and we
ran it against the test suite and it
failed a few times this claim did not
hold and every single one of those
failures was converted into a security
attack so the problem sorry no no
they've passed their test suite but this
claim was run over the test suite so
what we're doing is we're testing our
programs against their test suite are
our type checker against that s sweet
right with this type and the reality is
when you write a graplar grep like
program you don't write a proper
recursive descent program which means
you miss corner cases
and since we have a type checker we
catch the corner cases so now it is true
this this containment now holds right we
sort of found all the things that we're
sticking out and found that we could
turn them into attacks and once you get
rid of those attacks the corners
actually the circles fit and the other
thing to note here is that passing this
containment is actually means that you
could get rid of jas lint entirely and
just use our type checker as the front
as a front end right so if you don't
have to but you could do that and you
would actually be able to write run more
widgets in that case alright so that's
we're going to use this type to model
claims about add safe about guess lint
now I'm talking about types for
javascript where do these come from
these are actually Argent's thesis so
for example it has uh none untag unions
in the type language it's got this
notion of blacklisting it has prototypes
rather than classes because that's what
javascript has underneath and it also
has these field patterns which are
actually they could be any any decidable
language but they happen to be regular
expressions because we have to take into
account the fact that field names are
actually strings they're not actually
first order field names okay so you can
encode some of the field name structure
in the type of of objects so the two key
features one is this thing that I just
said which is that field names are
strings the other one is this thing that
you can do which is type refinement
through control for discrimination and
I'll show you that in just a few moments
so now we're ready to verify at safe
what does that mean we have the ad safe
library and we've got some widget we
don't know what the widget is right
we're trying to verify this for all
widgets that pass a particular type what
we know about the widget is no matter
how complicated is what communications
happening inside all that communication
is widget typed that much we know right
it's everything is recursively widget
okay when it calls them to add safe then
it must be the case that it's sending
widget type values and we want to make
sure that ad safe is also returning
widget type values except of course at
say if someone has to do the actual work
right the reference monitor is the thing
that has the reference to whatever
harmful operations are there and so it
might be talking to things like HTML
elements and modifying the web page so
the critical thing is that widget and
HTML
element are not in a subtyping
relationship so you can do widget HTML
element type things over here just so
long as you don't return any references
to the caller and similarly there's the
set timeout thing which is also I told
your kind of eval and that one will
investigate in a moment so again we're
good we've got these widget type things
coming in and we want to make sure only
widget type things go back out that's
the thing that enables us to do the
security reasoning about the properties
that I mentioned ok so we have to type
check add safe we have a type checker
that has explicit type annotations so we
have to put annotations on but it's
actually very easy to infer the types
because the types we infer are
everything consumes a set of widgets and
returns of widget right that's our type
that's our type annotation a little
script does that for us and we go off
and run the program and so some of the
evil things like I told you this is
other eval which isn't set time out the
way we record that isn't the type
environment which I've glossed over
until now right I've got this huge DOM
and I need a type environment for it so
we go through the IDL files and generate
an initial type a type environment and
then we go in and refine the type
environment in places where bad things
could happen so notice that set timeout
was one of these things that could
either take a function or take a string
I have written my type to prevent it
from taking the string argument it has
to take an explicit function argument
right so I'm blocking the eval case of
set timeout through that type
environment yeah for the for the browser
it's for the browser API yeah yes that's
right that's right that's that's right
exactly exactly exactly exactly ok so
here is an example of bad code so add
safe exports set timeout under the name
later and later takes a callback and a
unit of time and it called set timeout
on call back in that unit of time ok
well except of course this is bad code
because there's nothing here that
prevents me from sending a string
because widgets are string strings or
widgets so I
send a string and then I can get the
eval behavior so this is not the actual
lat safe code and if you try to type
check this piece of code you would get a
type error because there's nothing that
says the callback argument must be a
function right it could be the much
bigger widget type not just a function
part of it so the actual code inside ad
safe looks like this it says if typeof
callback equals function type off in
javascript is a misnomer it should
really be tagged off because it's
checking the runtime tag ok so it's
saying if the thing that I garden is an
honest-to-goodness closure then you can
pass it to set timeout otherwise you
know error or something else ok yes come
again please right ok good point so the
reasoning here is this runtime check is
only in only ensuring that i have an
arrow type ok but my widget type the
only kinds of arrow types that permits
our widget arrow widgets in that big
recursive type ok and so in fact that is
precisely the thing that's interesting
here which is if you think about the
type of call back as declared at the top
I've declared it to be of type widget
right so in a traditional type checking
context when I try to type check that
call to set timeout it's still a type
widget right i mean there's an if
statement above it but it's still of
type widget so this ought to fail for
the same reason the previous code failed
but in fact what type javascript does is
it takes these type checks into account
these tag checks into account and
narrows the type based on the supposedly
dynamic checks that were performed so
that that line that says if it's equal
to function picks out of this big union
type it picks out the line that says you
must be the arrow type since
so this is so it there's more
complications into that which is there's
a whole bunch of control operators in
Java Script right it's a small language
so obviously it has only about 10
different ways of doing these kinds of
tests and people use all of these to
greater or lesser extent we've also
studied code bases in Python and Ruby
and we find the same behavior in Python
and Ruby where people use tagged as to
do type discrimination so the
interesting thing in in type javascript
is it actually uses a combination of
flow analysis and type checking to
perform this kind of type refinement and
it's technically quite interesting
because one so the progress and
preservation are only achieved through
the union of them one of them does not
satisfy progress the other one does not
satisfy preservation but you compose
them together and the theorems prove
that you actually get progress
preservation out of the composition so
there's a little bit of technical
innovation going on to make this work
out and that's how we handle those kinds
of cases question there and then their
strings are widgets oh yeah so what if
the fun so the point is the two string
case was I had to pass in an object
right and if I passed in an object that
would not pass the type of check over
here so if I sent in a malicious object
that had a two-string in it the
top-level thing I would be sending in
still as an object and not a not a
string or a function could you construct
well you presumably could but then the
function could not truly be malicious
because it would have to be type widget
to widget right because if I allow you
to pass an object into set timeout then
I could construct the function in such a
way that the type checker that the JS
lint would not be able to see it right
but because I'm only allowing you to
pass in functions here that function
must be that something that jslint got a
chance to examine and blessed as being
widget to widget and our assumption is
that widget widget is not harmful okay
so that's that's the line of reasoning
here good catch are there was somebody
else yeah
uh well so it's very much inspired by
that in some sense what happened was we
looked carefully the occurrence typing
rules and noticed that what was really
going on in our mind anyway was it was
an encoding of a transfer function in a
data flow so we said well why not just
make it a transfer function of data flow
and and there's actually a I don't know
if this is the right time to talk but I
I'll say something interesting about
that later on about about spines ask me
about spines at the end ok ok so anyway
so that that's the thing that makes this
kind of so this is what enables us to
type-check a bunch of legacy code that
was written without type javascript in
mind using the type tag tests that
programmers in javascript are already
performing so here's an example of an
actual piece of code and type checking
it gives this error what's going on here
is let me see so I have this URL which
I'm using as a regular expression and
I'm testing whether its value passes
whatever this test criterion is and I'm
then later on using the value over here
I'm assigning it over here and the
problem is the way you attack this code
is you pass in a function you passing a
value an object that actually has state
in it and so the first time it will pass
the URL test because it basically
records how many times it's been invoked
it says the first time I was invoked I'm
going to return an innocent string it'll
pass the URL test over there the second
time it's invoked in a to string it will
eventually produce the malicious thing
right and so the type checker notices
basically here the type checker is not
giving us the counter example that says
here's how you attack it what it's
saying is I am unable to statically
prove that this thing is safe right that
construction in the red do you see the
red line there yeah but I got a widget
which could be an object which could
have a two-string in it which could be
bad bad
um that's that's because that's yes that
is in the type environment that you are
that regular expression test should be
given strings right okay yeah and if you
turn if you write the appropriate test
or check around it it actually blood
plus it in this case so we found some
actual errors we found JavaScript
execution errors that could be hijacked
to cause malicious behavior in each case
we were able to construct an actual
attack on the system we also found a
bunch of the nice thing about our type
checker of course I don't need to tell
this room is that type checker is
actually improved the quality of your
code so we also found several ways to
improve the correctness of the code of
the readability of the code and every
single one of the edits we suggested was
actually accepted and put into the ad
safe code base and it's now been a year
and a half and nobody has discovered a
new attack that doesn't mean there isn't
one it just means that maybe nobody's
checking for attacks I don't know so the
point is we've been able to successfully
improve a production system using this
type based strategy so how did we do on
these properties well so the first one
where I'm going to claim success but I'm
to be honest it's a little bit of a
shaky claim because it's really a
question of how good our model of the
environment was right it could be that
we missed something and really if we
wanted to do a proper end-to-end
verification story we ought to be
looking at the source of the browsers as
well it's something I've been wanting to
do we just haven't had the resources to
do it yet the bit about obtaining direct
references Dom nodes which as I've
explained can be quite harmful and it
sort of completely destroys the idea of
having an ad that's in a sandbox that is
achieved through a type based argument
right even the first one is also a type
based argument but it's only as good as
our modeling the second one is basically
because of this lack of subtyping in
either direction right so you don't get
this flow of values of nasty things into
good things the minibar affecting the
Dom outside their sub tree we have a
partial argument for it based on the
types we can't completely constructed
based on the types but it's also less
important because the way people achieve
this in reality is using something
called an iframe which gives you this
kind of sandboxing for free and it's
sort of your punting to the operating
system level which is perhaps
undesirable to a PL person but the point
is we have a combination
arguments between iframes and the type
based argument that essentially gives it
to us we just can't make the argument
entirely based on types the last one is
interesting because we started to think
about how we might prove such a thing
this is kind of a non-interference
property which our type system was not
set up for so we started to construct
some we started to investigate the
question and we came up with a we came
up with a type error that we were able
to turn into a counterexample to this
claim so we sent it to the developer at
yahoo and the response was oh I can give
you much better counter-examples than
that i'm going to retract this property
which is kind of a scary thing it says
that basically the current structure of
our web infrastructure is so bad it's so
leaky that you essentially can't get a
meaningful non-interference property for
it and that's kind of unfortunate
through global methods through writing
things to the dom writing i mean there's
just all sorts of covert channels of
communication that you can't quite pin
down in fact I when I gave when to give
this talk at ya at Google uh I started
off you know I had the same slide at the
beginning of the talk I recall and I put
up these properties and I got to the
fourth property in the moment I listed
the property mark millar jumped out of
his chair says that's complete nonsense
where did you get that property from so
I'm beginning to think maybe the
property was given just to test us not
because it was actually believed to be a
property so who knows so it says
something unfortunate about the web that
getting some kind of non-interference
property seems completely beyond scope
with the current technology so there's
there's a research question right
defining this in a better way anyway so
I started off asking at safe and I'm
claiming now add safe except we have
about 11 lines of code we haven't been
able to verify as of the time of writing
this paper so maybe take a little bit of
the claimed off sorry oh well so we did
that and not only did we convince
ourselves six of the lines have now
disappeared in the new version of java
script because it's working around a
weakness of javascript the other five
lines we do now know how to type check
so if it felt like it we could go back
and get you know the 11 off but the
bigger test of course is there's the
shrimp
they in fact that's Joe and Arjuna they
got they went to a duck crockford to
some restaurant of the Bay Area and Doug
ordered all the shrimp dishes available
on the menu so so he must have liked
what we did okay now meet claims about
you know a type system and I talked
about soundness progress preservation so
basically making claims about
correctness proofs for JavaScript how do
we do this where do we get you know what
do we prove correctness against write
javascript is this language it's about
its definition it will hurt your foot
right it's in that category of language
if you drop the manual you will have to
go to the doctor NHS I guess so of
course we do what academics do right we
define the essence of JavaScript and the
essence of javascript is you know lambda
j s and it fits all on one side well
it's actually there's one more figure
that's missing but you know it sort of
fits on us out of those URLs I'm sorry I
should go away um so it kind of fits on
a slide right it's lncs it's about three
figures are about this big so we're done
well except that's a little unsatisfying
yeah that's the dynamic semantics that's
right that's right but even then there's
no reason you should necessarily believe
my claims about the dynamic semantics
right I mean we've written down no this
is the core language I'll get to the Dom
in a little bit okay but but even let's
just talk about lambda J's right just
the core language I mean I've got
JavaScript programs about lambda J's
programs I mean it's easy to write an
interpreter for lambda J's right every
PL student can write one in an afternoon
on so we did something that this sort of
dangerous as a PL researcher which is
actually we actually implemented that
transformation so it's about 1,100 lines
of haskell code which meant we could now
take JavaScript programs in the wild and
run them through our interpreter slowly
get an answer and as you might know
there are other evaluate errs for
javascript in the world which means we
now have to confront this question of
are these answers the same so writing
down lambda GS tocar know about a week
or two this process took about three
months but we now have identical output
for a chunk of the Mozilla JavaScript
test suite and when I say identical that
means I mean it prints out answers it
says ok not ok ok not ok we can run
against the Mozilla JavaScript test
suite we
run against ours much lower and at the
end of the day we get two files we dip
them in the output is empty okay so we
have a tested semantics and it's I like
the fact that it's essentially as tested
as the browser right it's against the
browser's test Suites it also has this
nice virtue which is in the security
world people don't attack specifications
they attack implementations so being
able to say we model the implementation
has some real value to it well actually
uh mattila doesn't pass its own test
suite for amusing reasons so we didn't
need to they've already put them in
there yeah so partly that and partly you
know grad student effort you know three
months was a good upper bound on it so
so ah so actually there's an interesting
girl footnote to this which is the new
ECMO script standard they have made I
think I think in part because of efforts
like this they have actually provided a
conformance sweet as part of the
standard which i think is very nice
because instead of trying to bake a
semantics into the standard they've
implicitly baked a semantics by baking a
conformance wheat into the standard
that's actually maintained and all the
browser implementers are behind so our
new version of this for the new ECMO
script language is tested I think about
eighty percent now against the
conformance sweet that is provided by
the spec writers yes oh oh this is a
several thousand yeah it's it's
non-trivial I mean this is why we're
able to discover subtle bugs yeah
otherwise you want yeah everything buddy
bell everything but eval but we also do
width which is like this incredibly ugly
piece of JavaScript oh yeah so we do
that we've got like you know prototypes
you know like cats and dogs you said cat
dot prototype 2 dog and dog report a pic
cat and all this other beautiful self
yeah it's all 92 Jess yeah yeah yeah um
and I mean of course the lambda genesis
you know we said the essence but there's
no reason to call it des since it's an
essence of JavaScript right you could
you know like water said oh you should
have put you know the prototype
look up into a loop and then you could
have just done that in the lambda
calculus itself but we felt it was
important to provide a calculus that
identified what we think are the
critical elements of JavaScript somebody
reading it will get some insight into
the language but at the same time we
threw out scope objects and we actually
made substitution work because we think
that's just a bug and now the new
standard is also concluded it's a bug so
we've had some effect on the
standardization process which is nice
and the nice thing about a tool suite is
of course now lots of people can use
them so we have several it's you know
kind of unfortunate all of our
competitors are using it now but you
know I suppose that's that's a success
of a sort so that's the end of my talk
about the verification effort I wanted
to just step back and tell you a little
bit about what we're thinking about as a
group one is as I said we did lambda GS
for the old for action script three now
we're doing it for a transcript five and
using the conformance sweet that's not
part of the standard so it's very nice
we have the sort of synergistic
relationship type JavaScript I told you
about with object types I've been
working for some time on something
called flapjacks which is sort of a
reactive programming framework on top of
JavaScript we started out all of this to
buy because we needed to do static
analysis to do server-side intrusion
detection because in a server sends
programs down to a client it's kind of
in the web world it's kind of a hope
right not a guarantee that that's what's
actually going to run so we were able to
extract a specification of what the
client is supposed to do by looking at
the code and then randomized that code
because there's no reason I should send
you and you the same code because that
lets you attack him right let's you know
what does code is so we were able to
randomize the code that different
clients get but to do the randomization
you need a sound analysis and that was
the thing that inspired all this
JavaScript research as we said we have
no reason to believe our analysis is
sound especially because we're roper
operating on the source language which
just has way too much noise in it like
you know plus right if I say plus so
quarter of the room starts to smile + +
javascript is actually a page long right
and you know it's got all these weird
cases yeah exactly exactly so so we came
to conclude that we need a new approach
and that's what it inspired all of this
so now we have a semantics for the Dom
it's appearing at usenix web apps and so
the
about the DOM is this two parts the Dom
there's a tree that's just a damn tree
it's not trees not that interesting but
what is interesting about it is that the
DOM is where javascript javascript is
inert without the Dom it just sits there
on a page it doesn't do anything for the
most part until an event comes in so to
really understand the semantics of
JavaScript on page you have to
understand the semantics of event
dispatch which basically there's
something called a capture phase a
target phase in a bubble phase so
there's sort of a three-phase algorithm
and you're allowed to escape at any
point so the right way to think about
the DOM is it's a great big control
operator that's what it is okay and so
JavaScript and the Dom are two control
operators that sort of are mutually
recursive and so now we have a semantics
that actually explains what the DOM is
doing and lays this all out you know
again in a mechanized semantics that
people can use and we've started to use
it for some other task tests we're
working with Google on capabilities for
authentication sharing basically turning
capabilities into something that works
with modern web frameworks I believe
this is due to go into App Engine any
day now and we also have some static
reasoning for capabilities built on top
of App Engine so that's sort of a out
Creed story there we're right now
looking a lot of browser extensions
here's a fun fun a funny thing about
browser so browsers are extensible right
how many views I shouldn't ask in this
room honey if you use Firefox ok no well
ok there you go and so you know Firefox
has extensions right and the whole point
of extensions is they have extensive
privileges unlike the JavaScript inside
the page because they're allowed to
change the behavior well Firefox also
has private browsing mode what's the
interaction between the two it turns out
on well so for extensions came first so
Firefox said oh you can do whatever you
want the private browsing mode do
whatever you want they say well that's
not a good idea so now they put a bit in
the API that you can look up if you wish
but ask am I in private browsing mode
and then potentially change your
behavior or not and there's a manual
review process for it so chrome said
well this is crazy this is no way to
build a system so chrome automatically
turns all extensions off in private
browsing mode
which sounds like a great default and it
you know it's it's a wise default but
there are two problems with it first is
you can turn them back on and there's no
advice that tells you whether you should
turn it back on whether it's safe or
unsafe to turn it back on the other
problem is the most common extensions
are things like adblock and no script
which people use to protect their
privacy so those are the things that
have just been turned off by chrome all
right so the point is it's a bit it's a
subtle thing this interaction is not an
obvious right default even though
there's maybe a slightly safer default
so what we're doing now is analyzing
browser extensions for whether they
violate private browsing mode or not and
think about ways to scale it to other
forms modality as well and that's
another type JavaScript story as you
might guess that's a kind of sandboxing
argument essentially we're also working
on what now that we've built three four
type systems we've realized that there's
actually a pattern to all of them it's
something that we call progressive types
the type soundness theorem for the add
safe work is a little weird because we
don't actually have we have preservation
but our progress statement is really
quite weak and that's because
termination here is not an observable
channel and it's anyway not a channel we
were told to worry about so terminating
a program is okay so art there's a
trade-off when you take a legacy piece
of code and try to bring it into a type
system which is you can make a program
or do a little work or a lot of work and
if you actually have to be able to type
every application and make sure that you
know the precise type of every field and
every object so that when you try to use
it an application position is going to
work out that's a huge annotation burden
so we resolve it to some extent by
actually running the program and
recording types and giving that as an
initial hypothesis to the programmer but
it's still a fair bit of work for a
programmer and maybe they don't need the
full guarantee of that the type sounds
theorem comes with so progressive types
is a way of saying you can select in a
check box precisely which parts of the
which exceptions you do not want to see
at runtime right now in a language like
Haskell that doesn't really make sense
because there's a whole world of
exceptions that were never listed
anywhere because you know you have a
typed language but in Python and in
racket and
and you know JavaScript and so on we
know what the runtime exceptions are and
some of them are the ones that are being
prevented statically so you could choose
I'm willing to accept more of these
runtime exceptions in return for a lower
annotation overhead to get the program
through the type system and then
hopefully Ratchet it up as you go along
so it's it's a dual kind of gradual
typing right you ratchet up the
guarantee rather than the places where
you put the annotations so there's
something we're working out and the last
thing is you know the sole javascript
thing is complete nonsense of course
nobody should be programming in it so
where we've been working for some years
on a system called alchemy which is
taking alloy specifications alloy is a
relational modeling language from Daniel
Jackson's group taking alka alloy
specifications and automatically
converting them to programs there's a
there's a bunch of interesting things
there that I won't get into here but but
anyway that's that's where we are the
other experiment we're doing as a
research group is blogging we now try to
blog once a month we take one result and
try to explain it in a reasonably
accessible way they get a few thousand
readers so that's that's something
though they don't stay on the site for
very long some of you may have heard of
what what anyone remember yeah ok so the
hackers in the room this is a very
entertaining presentation by a
programmer that how would you describe
it sort of is a is scripting languages
for people who don't realize how
wonderful they are it's a up I yes Here
I am yes as a matter of speaking of
intrusions so it's basically it's it's
it's a very entertaining blog look for
wate ? just search search in your
favorite search engine and it's five
minutes of your life that you will
you'll be amused and so what we did was
we took all the JavaScript portions of
what of the what video and ran each of
them through the semantics that we have
we basically said hey these are test
Suites more test suites are better so we
ran them through the semantics and
showed that our semantics can predict
what the what video says will happen
except in a handful of cases because
there's a undefined pneus about the
top-level semantics of javascript and we
found a bug and Firefox as a result so
so it's good
we like random stuff off the web is all
good so anyway that's where we are and
that's the collection of stuff we're
working on okay and I'm happy to take
questions those who need to leave please
leave but thank you for coming what's
his name Gary Gary anyone search for s5
colon what look for the blog post and
then there's a link on the blog post no
that's our blog post about it so that
should work and then that'll get you to
our blog post and from there you can go
to the actual video there was something
we put off in the middle of the talk
occurrence typing yeah spines yeah so
there's so a current typing in Sam Tobin
Hogstedt style is really written for
very functional programs or you always
write ifs and nest ifs nicely it turns
out that at some places like Mozilla the
house style is actually opposed is doing
that the house style is instead you do a
conditional you do a type discrimination
you do something and you either throw an
exception or returned and then returned
back to sort of the left column right
they want you to have your spine as
straight as possible so you do all of
sort of your exceptional behavior and
then you can it actually sort of
improves the readability of the code
because you can just read the primary
behavior at the end of this collection
of ifs and returns all right and Sam
star would never be able to take that
because that sort of is opposed to the
style that he wants to handle right so
in contrast we allow you to straighten
out your spine so because in Sam's the
spine sort of goes like this so we I
call it chiropractic see right so we
straighten out the spine because these
returns are something that the flow
analysis knows how to handle does the
type discrimination and when you get to
the main line piece of code you can say
ah that is the main behavior of the
function and all the types of now been
properly refined and there's actually a
fair number of interesting programs that
use this kind of this kind of style for
example every time you have optional
arguments you will find code that says
if the third argument equals equals
undefined do something either return or
patch it to
the correct value right I'll patch it to
be you know like like splice right I
give you an array give you a start and
an end point if you leave off the end it
says the end eek if n B equals undefined
and now equals a raid length so too now
to look at end in the main body of the
code you have to reason about both
control flow and state to know that it's
type safe but it is type-safe absolutely
is that conditional was written that
precisely to make end in the you in the
body b-type safe and we can handle that
kind of thing because of our use of flow
analysis so so that's the relationship
between those two other questions yes
ask him ask him I didn't yeah well look
I mean all right so me personally I'd
rather this is where my head is okay and
that's actually this is where my heart
is certainly but if you accept the fact
that it's out there and it's half of it
is a perfectly reasonable language right
I mean it's sort of like scheme would
like bad syntax so what's going to work
what could be wrong with that so if you
accept that as is it that accept that
there's a reasonable core which there is
in all of these languages right there is
a reasonable course sitting in all these
languages then what we're doing with our
type system is basically making that
reasonable core more immediately obvious
to the developer right instead of
JavaScript the good parts which is this
lovely little book but it's you know you
have to read a whole book here's a type
system that basically keeps you in the
good parts that seems like a perfectly
reasonable thing to do the other thing
that I you know as a programming
language researcher that interests me a
lot is this idea that somehow this this
associative array data structure seems
to be seems to have some real value to
it right people seem to like it a lot it
seems to be convenient for rapid
software development in a way that like
the list never really took off right so
I don't know why that is but it seems to
be very popular data structure but if
you look at what people are doing if you
study the code they're using this
associated data structures sometimes as
an object sometimes as a dictionary
sometimes as an array and sometimes is
some confused combination of all of
those okay
the google docs bug is pretty amusing so
what Google Docs was doing was they
created an object as a dictionary and
then they put every single word in the
document inside that dictionary okay so
they reference it so when you type
search for words they can quickly use
they can use this hash table that's
built into the associative array to tell
you where the word is in the document
and very rapidly show you all the
highlights in the document okay sounds
great right what could possibly be boy
no no it's a hash table Simon all you
would have built a hash table they've
given your hash table a hash table as a
hash table that's brilliant what else
would you do but but it turns out that
it's actually a JavaScript object
JavaScript objects have a prototype
field call underscore underscore proto
underscore underscore obviously and if
you type underscore underscore proto
underscore underscore in your google
docs document yeah exactly exactly locks
up and you can you can you know denial
of service attack on somebody who's
sharing the document and and of course
the problem is the hack is like it's
where it's almost as bad as the product
is the initial solution right you got to
like put a prefix of some string in
there right X before everything or
something like that so our type system
will let you handle this kind of thing
of course but but it's just horrible
right so it would be nice if we could
try to extract some of those principles
out and that's what we're trying to do
in the type system is to say look this
is an object that's being used as a disk
this is an object that's being used is
at that so you can separate out these
cut these uses but one of the things
that does make me that does intrigue me
is so the so you want to start with this
like you know hacky thing perhaps or
people seem to want to you then grow
your program into something that's well
typed and disciplined but how does that
sort of back what about the loop how do
you tie the loop because now you're here
and you've lost your flexibility how do
you gain flexibility back such that you
can you know how do you weaken your
program right you've hardened it how do
you soften it again so that you can
reharden it again maybe we don't need to
maybe we do I don't know we don't know
enough about this stuff in my other site
is I do a lot of empirical work with
programming environments and things like
that and I want to start
more empirical work with languages as
well right 8 CI on environments is
obviously something we should be doing
we're clearly you know program languages
are human things right we should be
doing HCI on language is much more than
we have very little good work in this
area and I think we should do more why
did we use red X on we did we did we did
so no no so in fact the language s we
originally did it in red X the problem
is the execution engines just far too
slow so we end up writing the
interpreter again so we have used red X
we've used Oh camel we used Haskell then
we went back to oak Emma went back to
Haskell went back to red X and now I
think we're back at Haskell it's yeah we
can't find something that there's lots
of things that are sort of good and
nothing that's good enough yeah so
question here you know if we got like 50
people asked us for it we'd build it
overnight we haven't had for a few
people ask for it in fact there seems to
be sort of types and the JavaScript
culture don't seem to quite match up so
yeah you need for name friends yeah and
then we'll build it for you yeah yeah ah
what's the threat well um the so one is
collusion but that seems like okay I
mean if you want to collude you could
have colluded offline right so what's
the big deal the bigger problem is you
don't know what the nature that
communication is if I you know so I'm
farmville and I happen to notice this
other game companies widget is on the
page well all I could just go on like
bombard them with junk messages that I
know will cause them to crash making
that game you know putting that game out
of business that's the bigger problem
right whereas if you went through and
save ad safe would say wait a minute
you're Zynga you're not supposed to be
talking to this other company what are
you trying to do and it could block it
so that's why you need the mediation
that make sense other questions ok great
thank you all for coming and thank you
for the questions
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>