<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Mechanical Cryptographer: Tolerant Algebraic Side-Channel Attacks using pseudo-Boolean Solvers | Coder Coacher - Coaching Coders</title><meta content="The Mechanical Cryptographer: Tolerant Algebraic Side-Channel Attacks using pseudo-Boolean Solvers - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Mechanical Cryptographer: Tolerant Algebraic Side-Channel Attacks using pseudo-Boolean Solvers</b></h2><h5 class="post__date">2016-07-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/OIqJJusJDbI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
ok so today we're very pleased to have
Yossi orange visiting us from tel-aviv
university he'll speak to us about the
mechanical cryptographer thank you fine
ok so I'm going to talk to you about the
mechanical cryptographer which is a bit
of a pretty exciting thing that we did
in our group in the previous few months
and I think it's really interesting and
I hope to share the excitement with you
ok so first of all a bit about me I'm
part of the cryptography network with
security lab until leave University and
among other things we do in our lab we
research SCADA systems we do some
foundations of cryptography work rfid
work personally my interests are secure
hardware which means power analysis a
ways to attack using power analysis both
applied work lab work in both
theoretical work and lower SS
cryptography for likely computer search
particularly RFID tags and other things
I do is our cryptography in the real
world which are voter privacy web
application security and so on
specifically today I'm going to talk
about perrin else and other hardware tax
and specifically by the type of power
analysis attack which is very unique in
its application specifically it can be
used where previous forms of power
analysis were unusable it needs much
less data and it can be much more
versatile ok things which I did we're
not related to two of the academic about
me might be interesting for you I did a
lot of coding in my life I was both a
technical leader in a program and a
project manager I know it's different
things neither in Microsoft and I also
wrote some comedy might be apparent in
the talk depends on you ok so I just
want to calibrate people here might be
from different backgrounds who here
knows what a flip-flop is Wow not the
shoe right who here has ever touched
scope mm okay who knows what a s looks
like from the inside yes yes okay okay
so okay so here is the AES cipher okay
the structure of the ASI fer the the
uses of a DI cipher you get plain text
on the top you get ciphertext on the
bottom you get key and what's inside bit
flipping bit shifting permutations and
so on this is a very efficient algorithm
okay modern CPUs can do to to the 31 AAS
operations per second very efficient
okay so if i give you the plain text and
the key it's very easy to do encryption
if i give you the cipher text and the
key very difficult to do decryption yes
get on what is too big the chip is too
hey yes me yes knee multi-core okay yeah
you have to do the day you have to cheat
a bit but in terms of how many times per
second the AES make or is involved is
invoked okay okay so if we give you the
ciphertext in the key play Texas easier
calculate on the other hand if i give
you the plane tix in a separate text and
the key is not given it's difficult to
calculate okay why is this so hard well
this is what cryptography this is why
the cipher was designed this way it's
designed to be difficult to do crypt
analysis playtex and cipher text do not
lead to the key and what this means
essentially is that that there is no
efficient way to represent the the key
as a function of the plain text in the
ciphertext okay in fact most random
functions which have 128 bit input sir
256-bit inputs and 108 bit outputs are
very difficult to represent most random
functions so if you have a very
difficult represent function you can do
either two things you either spend a lot
of space you create a huge lookup table
or you can try the efficient thing which
is known kyun known kyun known plaintext
secular ciphertext
just go over it a lot of times until you
find the pair looking for this takes a
lot a lot of time so it's either yuge
space a long time or some sort of trade
off between the two which is inefficient
but anyway there is no efficient way to
represent the key of the function of
plentakill Saturday okay I just want to
put this in the side we're going to go
into this a bit more in the future of
the Tuck okay so let's put a s to the
side for a moment and I want to talk to
you about a nice software tool or
software machine called a solver who
here has ever dealt into solvers try to
use a solver and your work I know that
ms RC is actually writing a solver so
you can talk to them solver as the as
its defined it's designed to solve stuff
okay how do I use a solver I input into
the solver a set of statements over
variables written in some sort of logic
language there's no real restriction on
what language I can use it can use a SAT
statements i can use conditional logic
statements i can use english i don't
know okay and the solver upon receiving
the set of statements runs for a short
while or a long well yeah and then it
outputs a satisfying assignment for this
set of statements okay its outputs the
set of variables which can be assigned
to the segments such that all of them
are satisfied this is a very useful tool
it's very general purpose very versatile
one thing I one example I can give to
you which is it is used for is
scheduling for example doctors
assignments okay let's assume I have a
set of doctors in a set of assignments
and now the doctors have constraints
what are the constraints for example a
doctor cannot be present at two
different stations at the same time okay
right because it's a it's a classical
doctor another quantum doctor and the
doctor would like to sleep six hours per
night ok perhaps you would like a day
free or this doctor can't do saturdays
and so on ok so the set of statements is
given to and the variables would be dr.
Cohen is doing opthamology on Thursday
and so on so the sabul will set up at
the satisfying assignment which is the
way to assign the
doctors two rooms similarly the way to
assign postdocs to universities and so
on another thing which is very common
application of solvers is verifying
hardware designs okay however design you
start with a high-level language and you
end up with actually a picture which is
burnt onto silicon and some parts of
this process leading from the hardware
design to the silicon our manual some
some places are prone to errors so what
you do is you give the solver both the
desire level definition and the actual
net list which is so-called this is a
low level description and you tell the
solver is there an assignment of inputs
which is different with which leads to a
different output if I feed it to the
high level design if I fit it to the to
the silicon okay these are solvers okay
solvers are very versatile so one of the
things people thought of doing is let's
try to do crip analysis with solvers
okay and just going to tell you what
kept analysis is again okay I am going
to take this trip to algorithm for
example a yes i'm going to write the set
of states mint which is as follows okay
this the plaintext is be the ciphertext
is see the transformation between plane
tix and cipher text is this set of
logical expressions and please give me
the cryptographic key this is the
assignment I want to the variables the
cryptographic key will satisfy the set
of statements what this means is if i
take the plaintext in encrypted with the
key i will arrive at the ciphertext this
is exactly cryptanalyst okay and that
would be really cute if we could just
give this problem to a computer and come
back tomorrow and get the key right so
this was tried in the year 2000 by
Misaki muwah 2000a AES was not live yet
they used the death and what they found
out is that not surprisingly of course
modern crypto was strong enough to
resist solvers okay obviously you would
have heard about it if it was successful
so what does this what does this mean
you give the solver the plane tix in the
ciphertext in the key and the solver
runs for intractable time okay and the
solver takes an unreasonable amount of
memory they just run it for a while and
then they said okay we give up
we don't have enough fabric why is why
why is this so okay we we feel it we
feel that it should be so but why is it
so actually so if any of you have done
some symmetric cipher design you know
that one of the most crucial elements of
a symmetric ciphers what's called the
diffusion property or the Avalanche
property what this means is that if I
change one bit in one of the inputs very
quickly it's going to affect half of the
outputs okay one bit flips in the input
half was a bit flippant the output and
this does this happens very quickly so a
s has ten rounds if I change a bit in
one of the rounds in two or three rounds
all of the bits are going to be affected
so effectively what does what the solver
is trying to do is trying to find a
candidate assignment so it's guessing
okay let's say one of the bits of the
key is is is one and then it has to
propagate this belief and see if it
makes all of the rest of the statement
and satisfiable and and as soon as the
change is one of the statements all of
this other assignments become invalid
because of this avalanche property so
the the solver is reduced to actually
brute forcing all the pill all of the
keys try to find if one of them
satisfies the relationship between
political subjects ok so it's
established at this point that classical
crypt analysis using a solver is
difficult and the reason is diffusion so
okay I'm an engineer and when I'm faced
with a difficult problem what I do
typically is I solve a different problem
right this is what engine used it okay
so let's try to change change the
problem in a way which makes solvers
more efficient okay so this is a
definition of a crypt analysis in the
sense that i'm going to use today i am
giving a description of an outdoors in
plain text and cipher text i want to
output the key so what can i do to make
this easier for me the engineer okay so
first of all i'm going to take this aes
algorithm and replace it with a concrete
aes device okay it could be a smart car
this could be a software implementation
this could be a server running somewhere
ok but this device of course implement
say yes but it does so in a way which
has in a physical way and what happened
that as it does its work
it kicked give me hints about what it's
doing about its internal structure
specifically in my case I'm going to
take a look at the power consumption the
instantaneous power consumption of this
device every micro second and I'm going
to output a power trace a power trace is
ax is a sequence of let's say a million
points and each one of these points is
instantaneous power consumption of the
device while it's doing encryption at
specific time and and now I have more
information which I can try to use for
my attack okay and if i write this as
the formal definition of power analysis
i'm good as i'm going to use it and
display and this work now i have a
description of a cryptographic device
playtex and cipher text and power traces
okay and i'm going to try to find the
cryptographic key what's nice about
power traces as i told you previously
what really causes problems for me and
the attacker when I only have the plain
text and the cipher text is a diffusion
property the Avalanche property what
happens if I'm using traces traces if
I'm looking at two very adjacent periods
in the power trace they do not have the
Avalanche property the diffusion between
two similar to close and time spots and
the power trace are close enough
together for me to be able to make an a
hypothesis at time T and check it at
time T plus one without compromising all
of the rest of the assumptions i have
about the system so power traces are
very good for me the attacker when I'm
trying to attack this device okay power
analysis has been demonstrated in 1996
it's well known that it works okay so
what I'm trying to do now is trying to
use this power trace and the scope of
solvers so what am I going to do okay Oh
before I do that i'd like to say up a
few things about power analysis I
understand that a few of you have
touched it nobody has ever done it here
so power analysis in a nutshell okay
power analysis builds on the assumption
that power consumption is variable
and not only this variable different
instructions cause different power
consumption and different data across
different power consumption and this
means that the the logical leap here
means that I can do this I can run this
backwards if I analyze the power
consumption I can make some inferences
about the instruction than the data what
does this mean and it's fair inference
about the instructions me like you do
reverse engineering I can output the
list of the instructions the devices in
performing and inferences about data
specifically in my case is key recovery
okay so because power consumption
depends on instructions and data I can
look at the power consumption and learn
about the instructions in the data now
at this point I I'm doing this talk in
variance of it for a few years now and I
would have a few animations and pictures
of transistors where I would use to
prove you that power analysis the power
consumption is something which is
dependent on instructions day but now
fortunately there is a revolution in the
world and it's much easier to me to
prove this to you and this is called a
smartphone probably you have it and this
is a living proof that power analysis
works okay the smartphone has a cpu it
has a lot of sensors right it has radios
has accelerometers and so on let's
ignore the sensors for a moment in the
radios it has a cpu okay and sometimes
we take our smartphones and perform a
CPU intensive operation which has no no
I O&amp;amp;O sensor for example we play a game
okay some of us play games on our
smartphones we can admit it okay and as
we are playing this game on a smartphone
we feel that our smartphone gets gets
hot right and the battery runs down okay
yes 3d games incredible man was in power
downloading yes yes about three times
the amount of three times the power they
spend on the games they spend on the ads
yes but it's yeah it's it's kind of
scary to think about that but but the
whole the whole thing only runs out to
about a dollar a year if you just charge
your computer all the years cost you
about the doll and electric but okay so
so now i can i can give you a living
proof that power consumption is variable
okay
just by I just want to show this picture
which I found online so power
consumption is variable okay so i have
this fact it's established and i'm going
to do side channel analysis with solvers
and okay so now i'm trying to use I'm
tried to do crypt analysis and two
groups one of them in bells on one of
them in Princeton thought of doing it
they just use the cipher and instead of
feeding only the inputs and the outputs
of the cipher they also fed intermediate
data which is related to the power
consumption and of course I'm standing
here and I'm talking to you so of course
they were successful okay the result the
key can be recovered from the side
channel data great right okay but as you
see there is a small but and let's see
if we can try and find the the mine in
this statement together okay the key can
be recovered from the side channel data
if there are no errors in the side
channel trace okay so many of you are
scoped jockeys and have tried to measure
physical phenomena using your scope and
as you know there are never no errors in
their scope measurement okay so this is
the harsh reality of power analysis here
is a very small device can anybody guess
what this device does yes uh-huh this is
an inverter it takes a square wave input
here and an outpost a square wave output
here which is the inverse this is a an
n-type transistor and this is a p-type
transistor you can just go through it in
your head and you can see that a logical
one here causes the zero to run out here
and logical 0 here classes the 12 right
out here ok so now I'm going to I'm
going to feed the square wave input into
here and I'm going to take my
oscilloscope and I'm going to look at
the output okay and how am I going to
measure him at the power trace I'm going
to take a very small resistor let's say
1 ohm resistor I'm going to put it in
series between the device and the ground
and I'm going to measure the voltage
drop on this resistor and this the
voltage drop is related to the power
consumption okay now what do we see here
when nothing is happening on the circuit
there is no power consumption at all
this is something which is a property of
CMOS transistors and you really like it
this is why we can use small battery to
power
our devices for a long time okay if
nothing happens there is practically no
power consumption and when the device
which is from 1 to 0 there is a peek
okay sometimes it's a big peak some time
which is smaller p it's related to the
fact that these capacitors passive
capacitors get charged and discharged
okay I don't want doesn't go into it
okay so if i was able if i was somehow
tasked with performing power analysis of
this device this power trace would be
beautiful for me okay but the problem is
that it never looks like this right what
happens to the power twist and a really
factor measurement okay so there are
several things the show going on in this
device which caused problems for me okay
first of all I'm not measuring only the
cryptographic operation okay I'm
attacking the system okay a chip or a
decoder or a video setup box and this
system is doing other stuff other than
doing my encryptions it might be doing I
don't know io could be doing a all sorts
of CPU tasks threads and so on what
happens is that other stuff is going on
in this device under test and I'm almost
obviously measuring not only my
calculations but also this this is
called switching noise another thing
that happens I'm sorry I give you too
much errors here I'll just bring it up
slowly every piece of conducting wire on
my device and connecting my devices the
world is both the transmitting and a
receiving antenna and the electrons
which are moving through the air
modulate themselves onto these cables
and this is called electronic noise or
thermal noise because when you cool the
device down it gets weaker and I'm
obviously measuring this thermal noise
as well because I measuring what's going
on at the cable and the third thing
which is causing problems for me is that
I'm using a physical device called an
oscilloscope which is connected using a
physical device called a probe the scope
has its limitations it has a digital
analog to digital converter which runs
certain times of the amount of times per
second it has its own impulse function
it has it own sensitivities it has this
quantization what happens at the but at
the end of the day is instead of having
this pretty exact representation of
power consumption I have this disgusting
error
third thing which and we feel is
difficult for us to perform power
analysis on and let's let's try to give
this a rigorous treatment okay and this
is called the information or buses
trade-off let's take a rigorous look at
this phenomenon we just saw okay so
let's assume I'm going to perform my
solver attack the solver needs set of
statements and each one of these
statements is calculated from a
measurement okay I take this trace power
trace and a measurement let's say I
measure it at a hundred different times
and I feed these measurements into my
solver system okay so i have a
measurement space which is 100
dimensional and each one of these axes
is the value of a certain measurement
okay is this okay okay so here is the
precise measurement okay if there were
no errors no artifacts and also and no
nothing this would what I have measured
what I would have been able to measure
using my test setup and it has been
shown in the works of the Belgians and
the Princeton guys that this is enough
to recover the key with actually very
good accuracy in very high speed okay
and here is what I get on my scope okay
if this was the case I would be very
happy because my actual measurement
would be the precise measurement and I
would be able to output the key quickly
and efficiently but what happens is that
these errors and things or noise you
don't have to treat it as something bad
error it means that it's bad noise mean
that it's a fact of life okay so what
happens is if the circle moves aside now
what happens okay I'm running I'm
providing this measurement to the solver
and the solver looks at the equations
and looks at this measurement and what
does the solver output no no its essence
unsatisfiable there is no key which can
give out this this measurement okay okay
the measurement space has a code word
here it doesn't have a code we're here
so now looking at this picture what do
we immediately feel inclined to do to
make this work again we want to do this
right we increase we increase the
robustness of the equations this system
ok so we increase the robustness we
now say the equation set could be okay
at time t1 the leak is 3 now we say no
it's not three could be two or three or
two or three or four or somewhere no but
it can't be seven or something of the
sort and we increase this robustness
until we get into until the set of valid
measurements includes the precise
measurement but what happens here is
that the measurement space does not look
like this but rather it looks like this
okay and now what happens is that inside
the circle of measurements which are
valid which are validly represented by
the satchel measurement there are
exponentially many satisfying keys what
happens when the solver has
exponentially many satisfying keys what
do we know what it does it just route
forces all of these keys and because all
of these keys are legal what happens is
that the sour is again reduced to
brute-forcing and this results again in
an intractable running time so this is
what we call the the robustness
information trade-off it's a very very
cruel trade-off if we use an equation
set which has errors in it then the
solver returns understand satisfiability
because the correct solution is that
inside the set of measurement with which
I can accommodate but if i increase the
set of measurements if i add robustness
then the solver runs for an intractable
time okay so this is where we were stuck
at 2009 well not either one of these is
not good for us we can't use solvers for
power analysis crypt analysis in the
real world ok so again it's a hard
problem so again I'm an engineer so if I
have a hard problem then I solve a
different problem ok so how can i change
the problem to make it more acceptable
for me ok here is the solver this is the
tool I used previously and software
receives set of statements and it Out's
was a satisfying assignment now instead
of a solver I can use a bit of a more
elaborate tool called an optimizer
now an optimizer works more or less the
same way as a solver but it doesn't
receive only a set of statements it also
received something called the goal
function and the solver the optimizer
chooses among all of the possible
satisfying assignments the optimal
assignment the one that gives us the
best value for the gold function let's
say it's I want to minimize the goal
function give me the minimal value of
the bogo function and again this is a
general purpose tool it's a bit more
elaborate and heavy it takes more time
to run than the solver but it's also
very useful one example where it's used
actually IBM has a group which rolled
their own solver and all day they sell
usage of the solver to companies around
the world transportation companies
shipping companies who want to optimize
the routes ok here is in a classical
application for for optimizers which
actually is in the field today I want to
take the Russian railway system and I
want to save fuel ok I want to serve all
of the stations in the railway system I
have constraints a train cannot be
present in two places at once two trains
cannot be present and the same railway
at the same time ok train cannot travel
so on and so forth before needing fuel
but i also have a goal function the goal
function is please serve the schedule of
the russian troll railway system in a
way which minimizes the distance
travelled by the trains minimize the gas
consumption of the trains and so on and
when you save a lot of money using this
tool suddenly becomes very very
important ok so this is an optimizer and
similar to SAT solvers which are also
developed in universities and there's
competition between every year there's a
something called the SAT race where
people runs or sat travels and see which
one of the fastest there's also
something called the food or boolean
competition every other sovereign
competition after master competition
every year people compare the optimizers
it's an active work people are actually
researching them trying to find the best
way of doing it so okay how do I use
this in my in my context okay so if I go
to the previous slide I had this big
circle and my assumption was that all of
those points inside the circle
equally eligible to be the correct key
so now my insight is that some mistakes
are more expensive than others what do i
mean i am going to give a price to each
mistake I make okay there is a the
correct measurement which is not the
correct measurements the measurement I
got every time I deviate from this
measurement I'm going to pay a price and
the optimization will be let's try to
pay the minimum price and what's really
nice is that I gave you this idea that
there's a continuum of points and and
the decoder which receives this trace
outfits a point on this continuum this
is not correct actually the decoder is a
bit more elaborate it's something called
a soft decoder the decoder for each one
of the points along its axis outputs and
a posteriori probability which means how
likely it is that this specific point is
the one that was transmitted conditioned
on the fact that the distress was the
one received okay if somebody here that
did some signal processing work this is
a bajan decoder a naive bayesian decoder
other decoders also exist okay so i can
give a price to every mistake I make and
I want to do the best I can okay so here
is my new definition of side channel
analysis based on solvers okay I have a
description of the device I have plenty
x I have cipher text and now I have I
need to find the key that minimizes the
estimated error okay so once I output a
key I can run this backwards and say if
this is the key then this is the power
trace that should have been if there
were no errors I want the parrot race
that should have been to be closest as
possible to the power trace that I did
see with my school ok so now let's take
a look at what really happens if I do
this ok again i'm going to look at the
measurement space and this is our real
measurement for my lab actually it's
based on a simulation of a device but
this will get argues ok i just going to
look at two dimensions of this
measurement space and the brightness of
each point is courage to the like
that this is the point what just really
received okay so there are lots of
pointy which are non zero okay and if
you would shut down the light you would
see them also less likely points here
where is the precise measurement Wow
yeah you see it great can I have lights
again Matt well Matt you're awesome so
let's just take a look a bit closer at
at the points here and where is the
precise measurement here it is okay this
measurement it's a 688 most probable of
the 65,000 points here so it's pretty
likely but it's still exponentially
difficult to find okay now i just gave
you two two measurements okay I don't
give you two measurements I'm going to
give you a hundred measurements okay so
if i didn't have if i if i would try to
brute force over all of these
measurements i would have to do an
exponentially crazy amount of evaluation
to see if it's a correct one but now if
i have a ranking by probability i still
have to do a crazy large amount of
exponential work okay and practically in
my measurements the average rank of the
correct correct bite out of 256 possible
candidates it's number 14 okay so 14 to
the power of 100 is still a lot of work
but the thing is that these points now
are not iid and this is the really this
is the real trick here because I also
gave to my solver the the description of
the cryptographic process which is
creating these bites to be open okay so
if one of these bite by one of these
measurements is the inputs to sub bites
and one of them is the outputs to sub
bites as soon as I assume one of them I
also have to assume the other okay so
what this means is that this point might
be quite unlikely but it's really really
powerfully suggested by other
information I have and as I said because
of the slow diffusion property what I
saw a minute before what I'm going to
see a minute after is going to really
affect my a choice at this stage
okay so I'm just going to go of it into
the tool I use which might be useful for
you and other applications the specific
optimizing system i used is called the
suitable and optimizer and this is how
its work it works like the objective of
the sodium suitable an optimizer is to
output the vector X variables which
minimizes this goal function ok this is
a constraint function called see I
multiply it by X I get a number ok when
I'm in my this number subject to this
matrix of linear constraints a times X
has to be greater or equal to B and why
is this called a pseudo boolean
optimizer because the variables
themselves are boolean but the
coefficients of a are signed integers ok
so if if you develop it into logic
systems and so on you know that the
simplest logical system we've used our
SAT statesman's such statements are
boolean and boolean and on the other
side there's something called integer
integer programming where the variables
themselves are integers and the
coefficients of integers so this is
somewhere in between it's a compromise
which is very good for me because this
simplification makes the solver quicker
and it makes the implementation more
easy to use ok so I'm using very simple
to describe gadgets I can turn a linear
suitable an optimizer into a nonlinear
suitable an optimizer and this is using
a the classier classical linearization
technique if you know ok so if I have a
constraint let's say Y is X 1 X 2
remember that y and x 1 x 2 are boolean
ok so what this actually means is that
x1 plus x2 if both of them are one then
then why has to be ok more or less this
ok i'm not sure i wrote the statement
kratika but there is a linearization
system and you can use nonlinear and
they also can multiply these variables
together and you can also use their
inverts so this language is
very very expressive I can very easily
described you a suitable an instance you
can look at it and understand what it
does and this is in contrast to sat
systems which are really you need to be
somebody who can understand assembly
language to understand what seson here
is a sample suitable an instant written
in the open surah bullion programming
language ok what do I try to do what am
I trying to do here I'm trying to find
the vector x1 x2 x3 which minimizes this
goal function ok and it has this
constraint ok x 1 + 2 x2 + x3 is greater
than 2 ok so let's try to see if we can
find in our heads the optimal assignment
let's try the all zeros assignment ok
the all zeros assignment gives us the
goal function of the year which is
really great but zero plus zero plus
zero is not does not satisfy the
constraint ok so that's not good let's
try the all ones assignment ok this
gives me 4 4 s more than two this is
great and the goal function now is going
to pay the price of five ok can anybody
looking at this equation system give me
the optimal assignment 101 precisely 10
wine very well this gives me a price to
pay of two and 10 1 is to 2 is equal to
greater clinical too great ok this
language is very expressive and it's
very rich ok what do I mean a rich it's
really useful for my application
specifically I'm trying to find the
variables my variables which are either
the inputs the outputs or all sorts of
internal state internal state evolutions
of my device they're all flip-flops
flip-flops can either be 0 0 1 so it's
really great that the variables are
zeros and ones on the other hand the
measurements which are the things I
provide to my system they're assembled
on some continuous axis but I can sample
them into integers so the constraints is
really great that they're integers ok
and the nonlinear notation is rich and
expressive enough for me to be able to
write very elegantly and simply the
things which are you can see encrypted
devices for example here are some very
simple sudha bullion statements here is
the negative or
you see out is equal to naught x 1 x
naught x 2 ok it's pretty trivial ok you
can see this is a this is an or- or gate
here is an exclusive or get this is a
bit cute ok I wanted to put this here
because you see that i'm actually using
here a nonlinear i'm using here the suit
of boolean ok this integer if you would
write the truth table for this thing you
would see that this is exactly the
exclusive or statement ok now you can
just play with you in your head here is
a bit of a more disgusting function this
is the key lock ciphers nonlinear
feedback function it's five inputs one
bit output it's there's no efficient
algebraic representation of it but as
you can see i just i wrote something
here which is a suitable in
representation of it ok and also the
gold function is really good for me ok
the gold function let's say I'm trying
to determine the cost the price of ma my
i'm going to i'm going to guess i'm
trying to do a side channel analysis i
guess that the key is a certain vector
ok now choosing the key forces of course
all the internal values of the state to
be also strictly defined so now i have
for each one of these intolerant values
a chosen value and I know the a
posteriori probability of each one of
these values I want to find the overall
probability that this is the correct
value what do i do I multiply all of
these together and I get a single value
which is which is yes you know missing
some place up max doesn't become a
mineral su negation yes the max is less
than 1 all of this all of these products
although the pups to your abilities are
probability is always s and one so the
log of a number less as one is negative
so I want the minimum sum it's the
minimum it's like entropy ok it's a
negative number you woman and I want to
maximize the next to me yes yes thank
you go right ok so here is another
example of not of a pseudo boolean
instance here I have a vector X ok you
can just look at it it's so so apparent
to see what I'm written what I've been
down here X can be either 0 1 2 or 3 ok
this
it means that only one one and only one
of this of these variables can be true
okay and x is an 8-bit value here are
the 8 values of X X sub 1 to X sub 7 and
as soon as one of these events happens
it forces all the other events to have
to get their value and these are the
constraints and here is the goal
function okay the vault function means
that okay if you're going to choose 0
you're going to pay a pretty low price
if you're going to go ahead and say that
X is 3 you're going to be you're going
to have to be pretty sure of it based on
other evidence before you can go ahead
and choose X is equal to 3 so as the
solver as the optimizer works it will
probably try first x is 0 and then move
down this list okay but again because X
might be determined by the previous
value in this decryption the former
value in the description it will do a
bit more efficiently but this is how
this is how my equation system looks any
question about this because now i'm
going to describe my workflow and my
results okay so yes please wondering how
you get the expected trace so you got to
simulate hurricanrana okay um the the
way I prepare my decoder it's it's a
method that's well known in the art it's
from a paper 2005 called template
attacks which is very very interesting
it basically you take your device and
yeah under captivity and you force it to
output values which you would like it to
output and you would you measure let's
say you want that that value number two
would be five okay you make it output
value many traces in which value number
two is equal to five and you find an
interesting point and this trace or a
few interesting points which are highly
correlated with the value or measured
measuring their statistical tools which
assist you in finding this point and
then for this point this interesting
point you create a mean and standard
deviation and the meanest and deviation
are the meanest and deviation
conditioned on the fact that you were
expecting five
okay now for all possible values 256
values you create 206 means and standard
deviation okay if you're using for
example 2 interesting points you also
have a covariance matrix for each of
these so now I have if I if I get a
trace which I don't know I can use these
variables these means and variances to
create 256 probabilities probability of
this trace conditioned on one condition
on to conditioned on three and then
using bayesian and version i can flip
this around and get the probability i'm
looking on looking for okay okay it's
it's really interesting signal
processing and the paper describes it
much better than I just did okay okay
well good for you okay so here's the
workflow I have this device under test
I'm going to do something novel to it
which will end up and the optimizer up
adding the secret key okay so what is my
workflow a tasca by the way is tolerant
algebraic side channel attack tolerant
because I can tolerate errors okay so
first of all I'm going to take my device
under test and subject it to reverse
engineering okay this can be based on
pure prior knowledge this could be based
on really probing and so on and the
output was this would be the power model
a power model means that I am going to
write a set of constraints would say if
the device is doing this at time is
doing something at this time then I
expect its power its precise power to be
this okay if this is output from reverse
engineering and I'm also going to take
traces or let's say one Padres which is
output from the device as I am attacking
it and I'm going to put it into this
decoder this Beijing decoder which I dis
is dread and this decoder is going to
output the vector of a posteriori
probabilities for each one of the
measurements on going ok I get let's
take a look at the the amount of data
i'm using the data complexity here i
have a single trace for instance and in
this trace i'm going to take 100
interesting points okay and each one of
these interesting points is going to
cost the output of a vector of a
posteriori probabilities okay
so from this one price i'm going to get
let's say a hundred times 256 a
posterior probabilities and then i'm
going to put this into the optimizer
okay these together and it's going to
run and it's going to end up in a paper
and i'm very happy okay we know we know
how it works right our objective
function is very well defined as
researchers okay so let's talk about a
real attack okay and the results back by
the way this is going to appear in chess
two thousand twelve months from now so
the solver is skip skip is an open
source solver written by tipa the Berlin
University it's it keeps running in
these skip competition and these are
suitable and competitions and winning so
it's pretty good and the crypto system
i'm attacking is a simulation it's not a
real lab device but rather based on
measurements which have been performed
by my belgian colleagues so it's real
data but it's created by a tool which
outputs simulated data okay I just don't
I don't want to I don't want to make any
groundbreaking claims I didn't break a
physical device yet ok and what I did I
took a single power trace and i
extracted 100 measurements from this
single trace so single power trace data
complexity is one the signal-to-noise
ratio is reasonable at NDB it means that
there's ten times the amount of power in
the single than there is in the engine
room in the noise this is a reasonable
signal-to-noise ratio I put these
instances i created a lot of these
instances i said to have a tool that
creates them i took off to hundreds of
these instances and then on average in
about less than 10 minutes the key was
recovered with perfect perfect success
rate ok ok one trace 10 minutes one
hundred percent success rate ok what
does this mean ok before I describe what
it means I want to tell you a bit about
the field of power analysis power
analysis has been in something which
people in the academic world know about
since 96 and it's well assumed that
government agencies and so on and so
Worf know about it from world war two
and on ok
people know that power analysis the tax
work but what happens at the most power
announced attacks until this day are
based on statistical methods what means
what it means that you need many traces
and you try to you try to make
hypothesis on these traces which will
cause them to behave in way which for
example you can split them into two bins
if your assignment is correct if you're
a hypothesis is correct then these two
bins will be statistically significant
or there will be a correlation between
your career like pasta this and the
trace is a certain amount of time so
counterman and another thing which all
of the previous not all of them but many
of the previous attacks assume is that
there is a linear correlation between
the power consumption of the device and
the data is processing okay which is
this we know because it's a CMOS device
okay so how do you break how do you
break power analysis how do you make a
device in resist power analysis you
attack both of these venues first of all
you try to make your protocol you try to
make your environment so that the keys
are changed with high frequency they're
always fresh so you won't be able to get
a lot of measurements so your
statistical methods will fail or you can
just inject noise to make the mystical
correlation weaker another thing you do
is you try to make all sort of
electronical engineering tricks to break
the linear correlation between the power
consumption and the and the amount of
bits which are flipping at a certain
time you can do this by for example
what's called dual where logic you do
you create your singing you're a circuit
and then you create a mirror image of
the circuit and they always do the
opposite from one another so you really
don't know what's going on okay but what
happens is that both of these
assumptions which make today's resistant
devices resistant do not hold when I'm
using this new attack first of all
capable devices don't need high data
complexity to be attacked with this
thing okay the data complexity is one
and if I really have a lot of noise I
can average two traces together so the
dead complexity is to averaging really
really hits the signal-to-noise ratio ok
so I don't really need to average if
average 16 traces together I can do a
great work in reducing the seasonal
ratio so the data complexity is very low
which is something which
previous countermeasures assumed would
would make them resistant to power
analysis okay another thing is that that
I don't need anything particular about
the leak as i told you i make no
assumption about the leak i leave this
problem to the right to the author of
the decoder okay the guy writes the
decoder he can as long as you can output
the vector of a posteriori probabilities
that's enough for me okay so if the leak
is linear that's fine if it's nonlinear
okay the device I told you has a
nonlinear correlation between the
Hamming weight of the device of the bike
and the power consumption but if there
is a relation ok so anything I only
think that kind of a curator soft
decoder for and it can be doesn't even
have to be power consumption could be
anything exotic anything else as long as
I can ride the South Dakota I can do
this attack okay so these two facts
together call into question the security
of previously safety devices okay so if
you say a device is resistant to power
analysis you might have to go and check
this claim again okay and so I think
this is pretty exciting okay I still I
still didn't don't have any practical
devices i have attacked because it's a
very first result but i feel there is a
lot a lot of things that will have to be
questioned if this really turns out to
be practical so where do I go from now
future work okay first of all I used
only power analysis and decoder so I
feel that anything that leaks can be
attacked so a nice thing to do was to
try to try different things which leaked
and try to feed them into my solver what
I do know at least I feel it that if I
throw garbage at my solver which means
low quality data it knows to ignore it
more or less so if there is a if there
is a measurement where all of the values
in these measurements have the same
probability the salvo will just ignore
it okay so I really feel that the more
data I throw out the solver the more
effective it will be okay the second
thing is different leakage models again
I can try and different things for
example I can try to use a cache timing
leak electronic leakage and so on so
what
and the third thing I touched on it
briefly the decoders we currently use
have this very elaborate pre-processing
phase where I have a captive device and
I do profiling and I create these
vectors and then I have a very very
small data complexity I only need one
trace and I use this trace and I get the
key so it might be that I have limited
time with my device there might be it
might be probably might be possible to
use less profiling time and more traces
for the attack and still get in an
attack with low data complexity both in
the online and offline faces okay and
the third thing which the fourth thing
which is really a parent is to get a
real let's say smart card or car or
computer and the tacit using this method
which is really something interesting to
do with bit difficult okay so this time
I thank you and you can get the paper
from this website and I'd really welcome
any questions or comments yes please so
i don't know if this is really within
your mandate what you're interested in
but what would be the characteristics of
the device that could defeat this attack
um let's see I would say that what I
really need is diffusion I need low
diffusion so I device which has lots of
diffusion with the defeatist system okay
so if for example that if I make a guess
and to check this guess I would have to
go over whole space of solutions that
would make my device amount difficult
one example is for example a device
which does a lot of things in parallel
okay so I have to make a lot of guests
at the same time okay anything else
how does the attack scale with higher
complexity cryptosystem
what do you mean complexity so say we
make the big size larger so a much
bigger keys aes doesn't use the
different round structure for larger
Keith just does it more rounds so a yes
with a larger key is not more not more
powerful and when I affected using this
way the exception of TV decoder cars who
it is right mind puts his secrets
without the other guy it'll get the two
inches of the middle scho hmm oh yeah
yeah that's true that's true if you can
always say that that if you have
physical access to a device then you're
screwed anyway okay but first of all TV
decoders are very interesting market and
the second thing is it now we are taking
our cell phones with all of them secrets
and touching them to all sorts of with
this want to do it once the software in
heart is in place we're going to go and
touch ok places you wouldn't touch with
your hand suddenly you're going to touch
with your phone and who knows what's on
the other side and the third thing I can
say is that if you're using
electromagnetic leakage suddenly your
ranges is range is much larger ok pyrah
analysis does always have this this
comment you have to make that that to do
power analysis you need a power trace
yes ok anything else
okay okay thank you thank you for the</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>