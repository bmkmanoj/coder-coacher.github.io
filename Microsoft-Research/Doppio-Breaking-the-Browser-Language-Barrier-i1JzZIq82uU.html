<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Doppio: Breaking the Browser Language Barrier | Coder Coacher - Coaching Coders</title><meta content="Doppio: Breaking the Browser Language Barrier - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Doppio: Breaking the Browser Language Barrier</b></h2><h5 class="post__date">2016-06-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/i1JzZIq82uU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
so I think we're ready to get started
here so it's my pleasure to introduce
John vilk today I think a lot of you
know him he's kind of becoming a regular
here dining turn ships the last two
summers now so it's good um he you know
he's also a PhD student at umass amherst
with emory burger where he's done the
work that he's going to be talking about
today it was presented at PLD I last
year it was a cig plan highlight award
there so it's really exciting I think
it's pretty cool and I'll just give it
to John I'm gonna tell you exactly what
it is thanks mark so this work is that
is joint work with Emory so let's just
get right to it so as many of you are
aware there are a number of programming
languages out there so for example we
have Java Python and Ruby and it turns
out that there are actually a lot of
useful programs and libraries that are
already written in these languages but
unfortunately there's only one language
that runs across all the browsers and
that's JavaScript wouldn't it be nice if
we could just take our existing
well-tested programs and libraries and
run them in the browser with no
modifications so to motivate this
problem i'll be discussing a
non-existent text chat client written in
java as it elicits the challenges of
bringing conventional languages and
their programs into the browser so our
theoretical non-existent chat client
lets you connect to multiple chat
servers at once it logs your chats as
text files and encapsulate each server
connection in its own thread what we
would like to do is take this java chat
client and run it in the browser with no
modifications whatsoever how might we go
about doing this now you might
reasonably expect that you could simply
take the java source code of the client
and just recompile it somehow into
javascript but unfortunately this turns
out to be infeasible for a number of
reasons so for the first part of my talk
I'm going to discuss why this is the
case
the first problem has to do with the
nature of Java itself Java is a dynamic
language performing ahead of time
compilation on Java code will rule out
dynamic class loading and many parts of
the Java reflection API the second
problem is a bit more fundamental our
checkpoint uses multiple threads all
inhabiting the same address space but
JavaScript does not support threads
instead it supports workers these
workers do not inhabit the same address
space and they can't share memory with
each other so instead they communicate
by sending messages so we can't simply
map threads directly to workers which
poses a challenge to bringing our chat
client to the web our check client uses
TCP sockets to communicate with chat
servers the browser doesn't have support
for TCP sockets instead it supports
WebSockets which is a protocol
implemented on top of TCP as a result
our chat client will not be able to
communicate with the chat servers which
expect a regular TCP connection to log
chats the checkpoint rights text files
into the file system as you would expect
but the browser doesn't have a file
system instead it has a variety of other
mechanisms for storing data which are
uneven we supported across all the
different browsers and they also have a
variety of restrictions one of these
does use a filesystem abstraction but it
is asynchronous and does not support
blocking operations and I'll explain the
importance of this little detail in a
little bit unbeknownst to our chat
program under the covers the Java check
that Java class library which has things
like the string class and all the other
things that Java clients Java programs
take advantage of it performs a number
of unsafe operations using explicit
memory allocation requiring an unmanaged
heap but the browser doesn't offer a
mechanism for explicit memory allocation
and I want to note here carefully that
I'm not complaining about this this is
actually good but I'm just stating a
fact it's not there and it's something
needs to be there so the chat client
requires all these component
in order to function properly so if we
want to run a chat client in the browser
we need to somehow emulate all of these
resources in the browser but there is
another challenge to doing this and
that's browser diversity we're not just
trying to bring our chat client into one
browser such as Google Chrome or opera
or something like that we're actually
trying to bring it into multiple
browsers which unevenly implement the
various web standards we need to use in
order to implement all of these missing
abstractions but there also isn't just
one version of every browser out there
there's actually multiple major versions
in use at any given time and there are
additional differences too there's
differences between desktop tablet
mobile etc and this becomes a major
obstacle to bringing the resources that
the chat client needs into the browser
and I can illustrate this with an
example also I want to pause for a
second if anyone has any questions along
the way feel free to interrupt me and
let me know because I'll be happy to
answer them so let's ignore the version
differences to simplify this discussion
a bit and we'll focus on the latest
version of each browser as I mentioned
earlier our chat client needs to write
log files into a some sort of file
system but and there are a few
persistent storage mechanisms available
in the browser that we could use to
emulate the file system first all
browsers implement a simple key value
store that gives programs a paltry five
megabytes of storage Safari allows web
pages to sort of larger amounts of data
into a sequel database Chrome and opera
offer the same functionality but they do
not persist a database it is temporary
storage Firefox and Internet Explorer
allow web pages to persist data in an
object database and once again chrome
and opera they put it into temporary
storage they don't persist it and
Internet Explorer's version is not fully
spec compliant and then finally we have
the html5 file system which is primarily
used in WebKit browsers so only Chrome
and opera support this interface
and so the takeaway is this if our chat
client wants to persist more than five
megabytes of logs in the browser and
cares about browser compatibility then
it needs to support three completely
different storage interfaces sequel
database in object database yep I
thought index DB is persisted the low
all browsers now right so it it's in
like temporary storage so it's shared
between there's like a pool of storage
that shared among all like web pages and
then if you exceed if that like pool
fills up it'll just knock out the last
thing in the storage so it's not totally
persistent as horrible yeah Ari's not
where the key when I kids based oh sorry
i meant to say blink base yeah for some
reason reason though it's in the WebKit
sources so far didn't have it it may
have it now but i haven't checked
recently but i suspect it has the same
restrictions as the other ones okay so
yeah this is painful because these are
all completely different interfaces so
that's one challenge another challenge
is the event-driven runtime model in
javascript so this results in pervasive
asynchrony in all JavaScript code so in
particular javascript IO requires
callbacks which proves to be painful to
bring in conventional languages into the
browser let's walk through an example
just to make this very clear so our chat
client needs to periodically send a ping
command to the chat server to insert
detection is alive and waits for a pong
response we'll walk through the code in
Java and then we'll try to directly
translate it to JavaScript let's say
that somewhere in our main method the
chat client fires off of a fires off of
pain so the send ping function might
look something like this but I want to
note that I am simplifying this for
presentation purposes I realize this is
not totally valid code on the first line
the chat client writes the ping command
on the socket to the server then issues
a blocking read to wait for a response
finally once the pong comes back it
returns the data that it read off the
wire
in our chat client continues on its
merry way well try this yep java code
the way you present it makes it read
like it's completely synchronous and
will block until the response arrives
yes is that what your client does or is
there another soul to link to the
presence of a UI thread running in
parallel or something um so this is what
like this theoretical non-existent chat
client does and this is actually what a
lot of Java programs do they do
completely synchronous operations on
sockets what was your other question um
so the Java client if it blocks like if
the network is there something that
means to you I do sorry face is going to
be frozen for a duration of the read
call on this locker right in JavaScript
if you weren't a naive we map it into
JavaScript that is the case the way that
we deal with it in doppio means that
that does not happen I'll describe how
that works sold in a little bit but the
way that it works in doppio is that
we're able to have the same effect as
asynchronous call from in from the Java
perspective but from the Java strippers
perspective that call is actually a
synchronous and causes things to wind
down so the GUI does have a chance to
repaint and everything stays responsive
and that but you raise a good point
that's actually the key issue I'm trying
to hammer home here because a lot of
people aren't familiar with JavaScript
or the browser and they might be very
surprised to see that some synchronous
i/o would actually block the GUI and
cause things not to render properly so
let's see if we can translate this into
JavaScript somehow so like before the
main function fires off call to send
Peng and send ping sends a ping command
on the WebSocket like before but then we
need to assign a callback function on
the socket object which the browser will
call once it receives data from the chat
server but here we have a problem the
main function expects that send ping
will return the response from the server
but send thing does not have the
response yet it needs to wait for the
browser to call the callback we just
registered what do we have to do here to
return the value that main expects
JavaScript doesn't have a sleep function
that we can use just
and execution and persist the activation
records on the call stack for send ping
and main if we try to busy wait and the
server does send the WebSocket message
to the browser it will end up in the
browser event queue which the program
has no access to this is also where
mouse clicks timer fires and other
events queue up including repainting the
browser window while javascript is
executing in addition if we try the busy
wait the browser will try to kill our
script because we are blocking progress
in the browser event queue one result of
this is that JavaScript programs have no
choice but to execute in some sort of
continuation passing style where they
periodically yield to the browser event
queue by scheduling the next phase of
the program to occur as a new event in
any case the only way to unblock the
browser event queue and receive the
WebSocket message that is queued up in
there is to empty the JavaScript call
stack which means we have to return from
send ping and then we have to return
from Maine now the JavaScript call stack
is empty and the browser will fire its
next event which triggers are called
back but now we have completely
disrupted the program and we have no way
to get this data back to Maine if we
wanted to port the Java code to
JavaScript the program would need to be
completely restructured into
continuation passing style to allow for
breaks in execution for callbacks to
execute this is not well this is a just
a fundamental requirement here so I've
discussed these challenges and I want to
describe how the doppio runtime system
overcomes them yes file system my
another alternative would be to use a
file system in the cloud and just have a
local cache why don't you want to
explore that oh I'm not loaning to that
in fact when I described it later our
file system does support Dropbox cloud
storage but in that case it's it's still
going to be asynchronous so it doesn't
isn't going to support blocking
operations I mean instead of having to
support the three different you could
just use its true yeah you could do that
but the thing is you also have limited
local caching because you have to cash
to something local in the browser and so
then you're back you're stuck back to
the original
problem you have those four different
interfaces one of which is supported
everywhere but only gives you five
megabytes of cash and passionate discs
and not memory right you could catch a
memory yeah you can cash in memory but
if you want to persist it if you're a
web application right and you want to
make sure that the caching persists
across reloads if you have like a large
when I didn't you want to cash you don't
want to grab that off the wire every
time then you have these very limited
storage options that are everywhere and
then these better ones that support
large files that are completely separate
and need to support all of them to have
full coverage so that's like huge issue
there yep sure so the the limits are for
storage if you if you do the cloud-based
option and then you just load in the
data ass JavaScript files you could
presumably exceed those limits yes but
up about what I was saying is that if
you wanted to catch them so you avoid
you can cash them that way right so when
you the next time you load the app it
loads a big-ass javascript file with all
of the stuff that you wanted cash oh yah
the script gets cached over the 55
megabit limit or my goodbye limit that's
true but you don't control the semantics
of that so you don't really know when
the cash will be empty and such like
that but you're writing that you can
piggyback on the browser's existing
caching mechanism which works for
scripts images etc to capture your
assets you're you're correct there but
you also don't exactly control the
semantics of that so you don't know when
that will be emptied and stuff like that
but I suspect in a lot of cases that
might be good if you don't think you
ever fully control it cuz the user
cannot be there their web history at any
time that's true yeah just as a comment
i do so and if you are mapping from a
model that synchronous and that's you
know i mean pretty much what he
describes a base and so so forth right
so you you put a fundamental mismatch as
opposed to having something that's a
promise base that I mean could still be
Java already just so talk about the
programming style and frameworks one
users so any thoughts on that I mean as
far is the closing the gap if you will
in terms of the programming paradigm
so it sounds like what you're suggesting
would eliminate the ability to run
existing programs that are already
written in like the blocking style is
that correct yeah yeah so um if you
wanted to go that route there's already
things like Google web toolkit and
things like that that work for things
that you write programs in JavaScript
style where you write things with
callbacks and you write things so that
they carefully manage how long they
execute so that they don't block the
browser but if you have existing code do
you have know what you you'd have to
rewrite all that essentially to get it
to run in the browser and so our that's
our pain point here that we're trying to
address we don't want people to have to
port gigantic applications like Java Sea
or things like that to get them to work
in the browser okay so i guess i'll
continue and again feel free to
interrupt me in the future if you have
any further questions so now I've
discussed these challenges and now I'm
going to talk about how the doppio
runtime system overcomes them so first
off doppio is a one hundred percent
JavaScript runtime library for bringing
conventional languages to the web
there's no applets there's no there's no
native escape hatch it's complete
JavaScript we haven't threads on top of
the JavaScript event-driven runtime
model and language implementations use
these threads to keep programs
responsive support synchronous i/o and
to run multi-threaded programs we also
expose a TCP socket interface on top of
web sockets a file system interface on
top of the various storage mechanisms
available to the browser and we emulate
an unmanaged tape these three services
handle the challenges of browser
diversity that have discussed previously
and they let programs running in doppio
to function across all of the major
browsers and using this infrastructure
in doppio we built doppio JVM which is a
proof-of-concept Java Virtual Machine
interpreter written in a hundred percent
JavaScript that can run unmodified
programs straight from their jar files
in doppio JVM contains all the features
required to bring our chat client to the
web
I've discussed all those components now
let's talk about each of them first
let's talk about doppio threads so as
discussed previously the chat client and
capsule aged each individual server
connection in its own thread and this is
problematic in the browser because
javascript only has one threat how might
we met multiple language level threads
onto one hardware thread so first off
doppio threads require language
implementations to explicitly manage
their stack state and this allows doppio
threads to suspend execution by saving
the stack information into a JavaScript
object and resume later using the same
stack and then on top of this basic
mechanism we build a time slice
priority-based thread scheduler that
adjusts its quantity Amik way for
responsiveness and using the scheduler
not only are we able to support
multi-threaded programs but end with a
preemptive semantics from the language
level we also run we also allow
long-running threads to to execute over
multiple quanta and that prevents them
from freezing the web page and keeps the
application responsive to i/o such as
mouse clicks etc but wait there's
there's actually more so using this
mechanism we can support the synchronous
blocking i/o by simply suspending
threads when they use JavaScript
asynchronous i/o and then resuming them
once the needed information comes back
so now we can actually directly hook up
JVM threads to doppio threads and
that'll let's our chat client spawn and
run across multiple threads without
needing to be modified at all so that
yep the Coast series maintain your own
State yeah and it's a bit like that's
it's a big thing it's true yes generally
it does have an impact on performance
but the thing is there's actually
there's a there's a la a large class of
applications out there that aren't
computationally intensive that run just
fine with this overhead and if you think
about the web
for right now most applications on there
are not computationally intensive
they're just front ends to something
stuff like that and so they run just
fine the operate fine in this
environment with the overhead um if you
thought also but there was this other
project and their day generated code a
little bit more special when they meant
to JavaScript since it naked it's a few
points they could kind of recover the
stack when you need to save it from
whatever the jobs get busy so it became
more like trampoline style yeah was that
the racket based whale song work or song
ceases like that this law work Tesla and
even the Volta Volta right oh is that
the MSR work first least in microsomes
mostly for ya I looked into that they
never actually implemented that it I
looked at there's code and then and if
they discussed it it's not part of the
actual project that they dumped on the
github and I couldn't find any
information on that yes go Calvin Jesus
already doing this kind of thing for
dealing with tail recursion um Jesus
camel not doing trampoline but for
mutually recursive functions think yeah
not that I know of the only work that
I'm aware of right now that does
something similar for threads is well
song which is for racket but they don't
deal with multi-threaded programs they
don't deal with operating system things
they just deal with like single-threaded
programs so when you say explicitly
manager stack and saying is its CBS in a
way so right now the one language that
we fully support the JVM it just has an
explicit threat object that manages its
state but that's not a requirement for
doppio threads all dopey which requires
that at a suspend point you can suspend
by somehow recovering your stack either
through either through explicitly
managing it during execution or by
dynamically recovering it at a point
where you when you need to that's up to
the application program to figure out
how it once you know it's up to the
language Porter not to the application
developer the the language itself
supports it so the application has no
idea it's happening at all
um try another strategy yep oh yeah you
could wait it's not a limitation of our
of our framework whatsoever because now
it's like if you commit if you can use
the JavaScript stank as most as possible
you can take advantage of all the
optimizations people do for JavaScript
engines right if you maintain your own
stick now you you know yeah actually on
this slide the java chip stack is only
you introspect on local variables or
state like that so you would need to to
basically have custom logic in every
function or something that would persist
that data somehow and that would be
another expense in addition if you do
something like trampolining with
exceptions the javascript jet engines
are very sensitive to where you place
throws and catches and so it might
degrade performance right yeah yeah I
know I agree it's a difficult it is yeah
it's a very interesting space to explore
but I haven't fully explored it in this
work I just laid down all the
requirements and I've chosen one just
for the proof of concept right yep no
question yeah two questions first one is
you have to have a precise understanding
of where you insert calls to your custom
yield function right yeah so the yield
function only comes into play during
methods that need to be written directly
in JavaScript so like native methods so
in the JVM their native methods things
like socket dot read and write they
eventually map down to a method that's
normally written in C that interacts
with the operating system environment so
within those the person who creates the
language and rewrites these native
methods needs to be aware of how the
threads work it needs to say hey I'm
going to do an asynchronous operation
you can schedule another thread now and
then the thread schedule will go ahead
and pick another thread to schedule
while it's waiting for whatever to come
back there's also we also dynamically so
using method call counts right now as a
proxy for program run time we use that
to determine when to suspend after like
a certain number and we measure we also
dynamically adjust that count depending
on how long it took to get to the count
in the first place using a moving
average and so we we try to stay
responsive regardless of what the
program is doing so if it stays within
java code for a very long time it
doesn't hit a native method that says I
need to pause for a bit and then come
back it will eventually decide on its
own I think it's time to pause him what
the GUI repaint and not freeze the page
my other question was what you describe
is actually pretty similar to diem yes
7i think yield generators yeah so it do
exactly yeah there's a yield keyword
that suspends the thread and then you
just need to have an outer function I
agree so James beckons here actually
implemented some sort of like threading
mechanism on top of those and they're
very slow right now and they're not very
well optimized oh yeah you can in a high
level yeah the yield keyword allows you
to implement so many ideas that were
discussed back here but the idea of
trying to leverage the native JavaScript
stacked remember activation records now
the time that we wrote this maybe like a
year ago yields were super unoptimized
they were interpreted entirely I mean
they remembered the whole way and they
weren't well supported across browsers
at all so it only worked in Firefox and
then chrome eventually got it now
recently they've hit sort of like the
first level slow jit and a lot of the
browsers so I think they improved by
like an order of manhood or something
like that we can talk about that more
offline but you're exactly right the
yield what I do to deliver to some of
the automatic JavaScript stack yeah
that's another thing you can explore
with the dough via framework if you want
to I didn't explore it at the time the
paper was written because it was just
too slow and before I get you another
audience question I actually have one
here on the screen here it asks how do
we switch threads when their quantum has
expired I kind of enter that a little
bit so there's two situations or three
situation that guess in which a thread
will be switched one is if the programs
are running for a long time and we use
method call counts as a proxy for
measuring program run time oh okay they
got an answer never mind okay so next
audience question the issue of timeouts
right browser timeouts and predicting
how long something might run some Nora
toledo's what's your overall thinking
oh yeah so yeah so we so what we do is
we just do the method call counts to
figure out how to estimate kind of how
long it's been running and we assume
that the method durations they fall like
a nice distribution and so they're not
going to take forever to between method
calls now right now in our proof of
concept if you have a like long-running
loop that does not make a method call it
can freeze the browser GUI but we could
fix that by augmenting our metric to
incorporate loopback edges but right now
we haven't encountered a program that
has actually done that yeah I realize
it's in precise but I haven't
encountered much that is like taking
down the browser yet cuz it's kind of a
somewhat of a terrible possibility it is
if I got it can just terminate the
current yeah I'm fluke I'm them just
proceed it is yeah and in the future you
can use web workers which would
completely eliminate that possibility of
taking down the browser because the web
worker is completely separate from the
GUI context but the issue is you still
have to occasionally suspend because it
it gets messages from the main context
from the GUI like mouse clicks etc in
its own event queue and it will not
receive those until it winds down so you
still have to periodically suspend to be
responsive to user input but in a web
worker context you would not be able to
take down the GUI if our proxy for a
program run time turned out to be
inaccurate in some case and it took a
long time to suspend anything else
okay I'll continue with the next bit
then so that's the the doppio threads
and next I'm just going to discuss the
the file system so our text chat client
that I discussed earlier it writes files
into the file system for log files and
that's normally implemented in the UNIX
file system class in Java when you're on
unix based systems and the doppio file
system which I it's actually called
browser FS it exposes a POSIX file
system interface in JavaScript and this
file system supports many backends
including most of the persistent storage
mechanisms mentioned earlier Dropbox
cloud storage zip files in memory
storage etc all through the same
interface and then you can actually
mount these into arbitrary locations in
the dopa file system which lets you it
gives you great flexibility and where
the checkpoint writes its log files and
lets you lets you determine dynamically
which one you want to use in case for
some reason you don't have access to
some of the better storage mechanisms at
the time and so these are actually some
of these are synchronous some of these
are asynchronous depending on the
interface now that's not a problem for
the java programs because as i mentioned
before our threading implementation lets
you map the synchronous i/o to the
asynchronous i/o it's not a problem at
all so that is the overview over the
file system and next I'll discuss
network sockets and what someone wants
to know more about that so our check
line expects to connect to the chat
server through a TCP connection but
there's a problem to porting the setup
to the browser that I've sort of
inferred earlier the browser does not
give you raw access to TCP at all and
instead you must use web sockets the
website and web sockets are is a
protocol on top of TCP the server is no
idea how to handle these web socket
connections so using doppio threads we
can implement the JVM synchronous socket
abstraction on top of asynchronous
JavaScript web sockets but the server
still has no idea what a WebSocket
connection even ants but we can fix that
with a pre-existing Python
program called web Sokka phi so web
sacrifi wraps the server program and
transparently proxies a WebSocket
connection to the server as a standard
tcp connection and so neither program
Knights be modified you only have to
have cooperation with a server runner to
wrap the program like this and everybody
wins on both sides you have a unmodified
chat client running to connecting to an
unmodified server and neither have any
idea of the mechanisms that are in
between each other but yeah two good
like Microsoft and icq and tell them to
run all their servers and in one soccer
if you want to do that yeah you could
also run a local proxy if you wanted to
in someone safe escape hatch but ideally
if you are bringing something to the web
you control the server portion as well
and so you can simply wrap your program
like this yep um Firefox had the same
problem in Firefox OS when they wrote
the mail client they needed raw TCP
access what they did was create a
privilege API that's when you available
to privilege I Firefox code called mass
TCP socket have you gone critical and
tried to pressure them into you know
putting it in a standard strike like hey
makes me cry every time I seal with
these layers of abstraction please do
something about it you know I haven't I
mean it's very time-consuming so I'm
difficult so what we understand if she
didn't sisters yeah I haven't pressured
them because I'm not entirely certain if
it's a good idea just to let web
programs connect to arbitrary servers to
TCP I haven't really thought through all
the issues with that they're very
sensitive these things um but you know I
maybe not sure yeah I'm where I was more
concerned about the threading and what I
can do to improve that in the web
platform than the OS stuff because I
assume that eventually all these
services are going to expose some sort
of WebSocket connection once that
permeates through all the browsers it
becomes more commonplace ok
so that's where the sockets now I'm just
going to talk about this unmanaged heap
so when our chat client starts up it
pulls in a wide variety of libraries in
the Java class library and if you invoke
this unsafe Java API when they
statically initialize which what's the
program do many really fun things and
supporting this library is a requirement
to bringing the Java platform and the
chat client into the browser so how we
really need here is an implementation of
our old friends or enemies depending on
how you feel about them malloc and free
and implementing these is very well
understood and won't be covered in the
talk in detail but you need to operate
somehow on buffers of memory and funnily
enough therein lies the problem
representing binary data efficiently
across all these browser variants so we
actually use three different
representations depending on the browser
and what support it has for these things
so array buffer in its predecessor
canvas pixel array are guaranteed to
compactly represent our heap in memory
and for those in the audience who are
familiar with the html5 canvas the
canvas pixel array is used as to back
the image data that is stored on the
canvas we're just completely abusing it
because it's the only thing available in
that situation that has a very compact
memory representation where every bite
that your right to it maps to one byte
of memory now unfortunately if the
browser doesn't support those two
objects such as Internet Explorer 8 we
fall back to a vanilla JavaScript array
of numbers and this has a2x memory
overhead since JavaScript numbers are
64-bit doubles but it's the best
Universal fallback that we can possibly
do since all of the JavaScript bit
operations like or and etc they coerce
the numbers into a 32-bit form and so
with these buffers of memory we can
implement a the unmanaged heap using the
data structures and we can also meant
the JVM malloc and free interfaces
directly on top of this unmanaged tape
and that what's the java class firebreak
perform all this unsafe budu a program
start up
during run time so I've covered the run
time system and now I'm going to move
into doppio JVM and how it hooks up into
all this to bring the JVM to the browser
so doppio JVM uses an unmodified copy of
the OpenJDK java class library to
provide the applications with all the
library support that they expect and as
I mentioned before the various java
class library interfaces within doppio
are mapped sorry when we start over the
various java class library interfaces
are mapped directly onto the doppio
operating system support and using
doppio threads these interfaces can keep
their blocking JVM semantics even when
they need to invoke an asynchronous
JavaScript operation and we also
implement all the native portions of
these classes which we have been on here
but there that's a part of it as well so
we covered that let's talk about the
more fundamental details so we map the
cord JVM data structures into javascript
features in a fairly straightforward
manner java objects become JavaScript
objects java rays become JavaScript
arrays most numeric types become
JavaScript numbers which act as both
32-bit integers and 64-bit doubles but
64-bit integers are not natively
provided in the browser so we emulate
them using Google's geelong library
which means that if you have any code
that operates with long data types we
have no choice but to allocate an object
to represent that longer memory and due
to this straightforward mapping we
actually get garbage collection
completely for free because we are
already executing within a garbage
collected environment finally there are
some features of the JVM that we had to
just completely reimplement for the
browser this includes the core by code
interpreter for JVM bytecode the JVM
class loader and JVM monitors which are
used for synchronization across JVM
threads and so doppio JVM is completely
real it exists it's been evaluated by
the pldi
artifact evaluation committee it got the
distinguished artifact award and this is
the demo here and this is our mock
terminal interface that you can see
yourself at doppio JVM org and play
around with and in tradition with all my
microsoft research talks i'm actually
going to show you a live demo i can
figure out what's side of screen there
it is okay so this is the interface I'm
serving it locally just to avoid any
potential network shenanigans to
interfere with the demo so we have a
trait forward terminal interface here
we're in temporary storage but if I go
to the root directory you see we have
this mount directory which has a bunch
of browser storage things mounted
because we're in chrome i mounted html5
file system in local storage in here and
you can go in here and you can write
files so what's let's create a simple
Java file here i have a very blurry
screen over here so forgive me and
fumbling about so let's write a little
hello world program here so system dot
out dot print line hello microsoft
research actually let's put a syntax
error in here just for fun save and
close so now i actually have a choice of
two Java compilers that I can use their
cumpleano fide we have Java Sea and the
Eclipse compiler let's invoke Java Sea
on this see what it tells us and so now
what it's doing is it's actually pulling
an individual class files off the wire
so the first one is always slower and
you can see here it tells me oh I'm
missing a semicolon here oops so let me
edit that and add that back in so we can
pile that bad boy so you in these edits
are right and that's actually an
existing JavaScript library called s
editor um yeah so we just do it with
this from the shell basically
yeah this shout dishes the shell is
actually implanted in JavaScript I was
debating rewriting it in java at some
point just for fun that's fine then and
that works directly with the dopey OPM
yeah this works directly with the dopey
ovm and the file system to bring all
that together so the doppio file system
is accessible nicely with in JavaScript
as I understand it it's cool you made
this in JavaScript because of the
problem with the ASM JavaScript's our
favor really cool policy programs yep
mitigates and things it doesn't work
well with the other JavaScript right no
just a no it's cool but everything
actually is JavaScript so you can easily
interface between them right yes yeah
there's no yeah because with that people
unfamiliar as MJS it puts certain
JavaScript engines like Firefox into a
different mode where strangely enough
you can't use objects which is kind of a
requirement for most JavaScript code and
so if you want to interface between
something in as MJS and regular
JavaScript you have to use an FFI
between the two which as far as I can
tell is undocumented and I couldn't get
it to work but in addition all of the
stuff like and scripted and things like
that the compile things to as MJS they
don't do any of the threading things
that I do and so as a result they can't
map their file system to html5 file
system or any of the large storage
mechanisms now in the browser right and
in fact if you want to use them you have
to manually it like implement sync
operations that tells it when to do
certain things yeah on the other hand
you know being inside as in Gloria's you
get some isolation properties apart from
these undocumented FF eyes yeah you know
that your ambient JavaScript isn't going
to muck with the invariance of your
compiled language whereas here you have
JavaScript you know interfacing with the
trivia implemented inside JavaScript you
may worry that you know are potentially
malicious or buggy JavaScript just
completely screws with the invariance of
your system that's that's true but it's
also true of any other JavaScript code
that you have on the page absolutely
yeah so the way that we view this is
that if you are deploying doppio on the
pay
you are also controlling what data you
feed to it and much like any other
JavaScript library you guard the global
variable that we expose that you use to
interface with it to do all the JVM
things and so as a result we have like
the same sort of security properties as
any other JavaScript library as far as
I'm concerned right really I mean for
example if you make a call from inside
your jvm abstraction to a JavaScript
function yeah what prevents I mean how
the calling convention for example that
that you're emulating that's java's
column conventional inside JavaScript
which isn't really the same yet was
differences may be observable to a
native JavaScript program that wasn't
compiled or it wasn't run inside your
environment for example it may try to do
you know collar or not you know collie
stack blah right yeah which may not
exist or maybe set up differently in
your environment then what that
JavaScript program expects and it may be
able to notice that difference and do
something with it okay so you're talking
about if a Java programs interfacing
with any JavaScript librarians on the
page that's right yes yeah as this
program seems to be doing right uh yeah
you're calling into Java Sea from here
which is a java program mm-hmm and maybe
this is this JavaScript program I mean
you wrote it so it's not particularly
malicious but I mean if you got it wrong
for example it your program may be able
to your JavaScript program may be able
to break invariance of your compile Java
program yes that's true hmm um so I'm
just saying which is perfectly I mean I
think in the setting that you have it
it's quite a you know it's okay but I
mean it's coming back to the car
appointment with Asmodeus this kind of
isolation between azamgarh Jas and the
rest of the environment which is only
maintained for a reason right it's only
maintained really within Firefox as far
as I can tell in other browsers that
don't support the special use as inflamm
they just treated as regular JavaScript
and so there's nothing blocking you from
mucking about with that in Firefly
I'm not sure what happens if you break
the invariance that they assume I don't
know if the page reloads and just
execute in regular JavaScript node or if
it fails to execute but that wasn't no
design as a security issue it was just
that wasn't really designed as a
security invariant to maintain it was
designed as we can turn on extra
optimizations and make it fast yeah so I
would not use that as a as some sort of
sandbox mechanism okay uh so yes just do
licks point i guess i mean it's nothing
doesn't sound like you're making
particularly strong promises about the
fidelity of the translation just given
how difficult it is so this is one of
the issues there which is within an
environment that could be hostile you
could have all sorts of funny things
happen you yeah absolutely it is what it
is to build off that we have been
implemented the bicoid verifier so
simply malformed class files if you
don't control that input would throw the
JVM off track because we don't consider
that to be an important issue and the
overall contributions we're trying to
make here what about things like you
know mapping java's memory model
precisely to your model of threads and
that native EEP and that's a good
question because this is no difficult
enough clear jack will ya I didn't
really consider that to be a priority
when I was nothing on this so I would
not be surprised if you could find
violations the memory model could be
considered future work but at the moment
I haven't found any programs that have
triggered any weird memory model issues
so okay could you show us how much code
there is some dummies I'm debugger me to
go just tell us so in terms of lines of
code if you include all the native bits
with the JVM and everything the GOP Oh
JVM it's like less than 25k of
JavaScript from what I remember last
time I measured that includes the file
system and and doppio JVM and its native
implementations and everything else
that does not include the Google long
library that i'm importing i don't know
how hard that is but overall it's not an
unreasonable amount of javascript now
the big part is actually the class files
that i'm pulling in the java class
library itself the core part of it
compressed in zip form is 30 megabytes
and uncompressed it's 60 but that's only
if you pull in the entire thing every
program typically use probably about
like five megabytes 10 megabytes of that
and that's uncompressed sized so if you
gzip that you get huge savings there so
it really depends on the program and how
much of the JCL it uses that's the
biggest cost the javascript is almost
nothing compared to that but so yeah
let's see i fixed my syntax error i'm
just going to compile this using java
sea takes about i think eight seconds
last time i measured and now if i run it
with java it'll just print that out and
also we have ECJ which is the equips
compiler which yeah all this little
options are here and that's just we
didn't modify any of this it's just it's
direct class files so in addition to
being able to do that let's see java p
works which is the disassembler so we
can just see that this actually has the
structure that we desire and in addition
other languages that work on the JVM
work so for example cowboys scheme is an
implementation of scheme on the JVM so
we can boot that up it is loading all
the files from the jar file which takes
it for the first time but now we have
it's a little ripple and going to do one
plus one give us two I'm not much of a
scheme hacker so I can't do anything
really cool here but you can mess around
with it a doppio JVM you let me know if
you break anything and also finally just
for one final thing before I switch back
to the slides Rhino is a JavaScript
implementation on top of the JVM so
naturally we wanted to go a little bit
meta
so if we run rhino we're going to get to
a JavaScript repple that is executing on
our JVM then it's executing in
JavaScript I have yet to complete the
loop because I have to the only thing
remaining to complete the loop in which
i can run doppio in rhino on dopey oh oh
this thing went to sleep that's back is
I have to actually poured a filesystem
back end to my file system that maps to
rhino which Maps the doppio which maps
to browser all that stuff but I'm very
close to go putting the loop I'm sure
next demo have it ready yeah we have a
javascript rebel here now it's also
amazing like the like when you do Java
Sea it runs an entire java compiler
inside your browser right on JavaScript
interpreter yeah oh so that means the
JavaScript interpreters are are there
good this is this is I mean it's amazing
it is work yeah um your product Oh would
I forget well maybe you don't have much
experience with John about it is so trip
that's even everybody's a critic oh that
was right line maybe it's just regimens
ice right no because it's a different
interface completely from gold solid
wall print print oh its paw print this
is amazing it's just this is like their
programming guys exactly one yeah there
we go print doesn't add the new one so I
think it'll mess up the console a little
bit so if I do this it'll just to alert
I don't think you have access to away
from this cuz there's no Dom yeah look
at that okay so let's exit I think it's
Exeter it's quit yeah cool to keats for
jawline swinging gwg good point do that
so um we tried the port awt which is the
abstract window toolkit which is what
swing is implemented on top of on the
web but there's a well-documented issue
with openjdk and that the AWT is
hard-coded funnily enough to the
platform's of supports even though it's
called the abstract window to locate
it's not abstract at all in fact it
calls a bunch of
final sunglasses that are hard-coded to
different platforms and so if you wanted
to port it to the web would have to
modify the Java class library which we
don't want to do with that said I did
find that someone on the internet is
porting javafx to doppio and they have a
basic demo working with like like shapes
moving around the canvas both with a
complete Java software renderer running
at full speed in the interpreter and
also one that has some native methods
implemented so it's using the canvas and
hardware acceleration directly looky
what was that it's nothin key I have
located at all because in the open
hiccups yes yeah um so the only thing
that you have to do is write the native
methods for that and if it requires a
special back end for the platform you
have to do that as well so it's the same
as porting it to a different yet to put
in as much effort as porting that to a
different operating system or a
different flavor of linux or something
but yeah I haven't looked into that in
particular so that's the little demo and
again this is at doppio JVM gorg feel
free to mess around with it you can also
mount dropbox in here yeah
which takes a bit sometimes because it's
it's a hitting Dropbox server every time
I do it file system thing but a little
is this actually so this is actually
downloading this for my dropbox account
I'm not sure if this will work meaning I
don't know if it never connection cut
out at second too long so this is
actually downloading this jar file from
my dropbox account and control C kills
it so yeah feel free to mess around
doppio JVM gorg it's also sources on
github if you want to see that it's just
static files you can clone the demo demo
repository and look at the gh-pages
branch and you'll see it's just files so
let me go back to my presentation to
finish up
okay yes so as I just showed you doppio
jvm oh this thing like just minimized
sorry okay I was reconnecting with the
question interface so doppio JPM runs
with real and modified programs they
just showed you those four programs are
actually our little benchmark programs
and in some cases they're not so little
they're quite large those are the that's
how large they are in Java and we'll
jump into the benchmark results so we're
compare comparing doppio je viens
performance to the hotspot interpreter
because doppio JVM is also an
interpreter and we want to note that
doppio JVM is totally untuned it's the
proof of concept and hotspot is highly
optimized and it's written natively but
despite this in our best browser Google
Chrome doppio JVM on these benchmark
programs is a 24 to 42 times slower than
the hotspot interpreter oh the hotspot
interpreter is when you get java from
oracle it's their job implementation and
the interpreter is with jit compilation
turned off running running on the same
server so these are both running on a
Mac Mini with a core i7 it's two
gigahertz I think it's in the paper but
yeah they're running on the same system
in fact i don't i don't think i could
find out how to turn off multi-threading
so the hotspot interpreters actually
using multithreading to get ahead in
some cases but any case we're comparing
against that um yes so I assume well
these benchmarks are running a very
compute-intensive manner yes so this is
sort of the worst case today you
wouldn't even want to really do this
you're well you would not insert a UI
bag do you have any examples of like I
do okay I'm actually getting to that
point okay good yeah yeah so um so yeah
these are these are the results you'll
see that it differs a lot between
browsers we develop this in chrome and
we profiled it in chrome and so we
probably are a bit tightly coupled with
it and because it's an interpreter any
small changes in the how we dispatch op
codes and such is going to have a huge
impact on program run time
also you'll notice that Safari had an
issue with Java p we found an issue in
Safari wear it wasn't garbage
certain things and that's been fixed now
so that's no longer an issue but yeah
these are these are all
compute-intensive code like you give it
a command and it goes on forever it's
the worst case and the browser's don't
generally run this type of code and so
we found that doppio JVM is fast enough
for many people already who have
discovered it so for example the
University of Illinois came to me for
some help and they've launched a website
called code mood calm which uses doppio
JVM to teach Java programming or basic
java programming skills to children so
this is a little game that they can play
this is like a level one game that so
children go here they string together
function calls to guide the character in
red to to the goal without bumping into
bad guys and when ready after arranging
all these things the child clicks the
green button and watches the character
carry out the instructed actions under
the covers these instructions are placed
into a Java file in the doppio file
system compiled with the equips compiler
running within doppio and then the
resulting class file is running doppio
JVM again and that all harnesses the
power of the visitors own browser so
existing things like this is loosing
platforms people use in universities use
to teach children how to program in Java
use server back-end surround the Java
code in this case it's just using the
browser directly and all they have to do
is serve the static files so yeah in
this talk i introduce doppio a full run
time system that bridges the impedance
mismatch between conventional languages
and the browser i showed off our proof
of concept Java Virtual Machine doppio
JVM which can run to modify Java
programs in the browser I also didn't
mention that our file system can
sometimes integrate into and scripting
programs and so that's been used on a
variety of web pages and I encourage you
to check out doppio with doppio JVM org
and thank you all for your attention
I think we've got a lot of questions
throughout but definitely time for one
yeah so that execution was from februari
what's what's been going on in the last
11 months um so we've been looking at
speed we've been looking at supporting
other languages and I also in my spare
time got job aight working so variety of
things on the plate right now that I'm
exploring not much to talk about just
yet but I'm hoping all of some news on
that in a few months yep even show you
mentioned compatibility with Freddy old
browsers Chaz ie8 yes it's that
important for you um yeah I wanted to I
wanted to see what all the issues were
with browser diversity now I think I
broke a i ate i think it's broken on our
demo right now but ie9 definitely works
but yeah I wanted to see what web
developers currently face in bringing
programs to the web and at one of the
see if I EA could work and I did have it
working at one point I think there's a
weird bug in there somewhere never
enough yep I'm curious what the tape
loop for executing individual java
bytecodes is are you is it like a array
index into a bunch of function and where
is it me think as of the demo I'd I've
rewritten it recently so as the demo
that I showed you that actually has an
object allocated for every interpreter
instruction which has like a run command
and so that allows for some nice i'm
lining in some cases the version that i
have now is a lot simpler and it it has
an array of functions for every
interpreter opcode and dispatches it to
using the number at a certain offset in
the bytecode directly so those are the
two that I've used and they have similar
performance I don't know if that was
clear but is it a big switch statement
or is it edge now you know so actually
switch statements in some JavaScript jet
engines are not optimized if you have
more than one hundred twenty eight cases
so we you you index you and yeah
integrations yep
all right well let's thank John again</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>