<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>A Cloud TPM for Cross-Device Trusted Applications | Coder Coacher - Coaching Coders</title><meta content="A Cloud TPM for Cross-Device Trusted Applications - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>A Cloud TPM for Cross-Device Trusted Applications</b></h2><h5 class="post__date">2016-06-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1wpzdm99wNI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year microsoft research helps
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
you
okay hello everyone my name is Stefano
you I'm a researcher in the mobility and
networking research group it's my
pleasure today to host Chen Chen who is
a graduate student from ETH Zurich Chen
was a summer internship with Alec and I
last summer and he's gonna tell us about
his work over the summer called CT p.m.
now the format of the talk is a little
unique it's you know certain we have two
goals in mind one is to present this
work at MSR but also to have a little
bit of a practice stock for him he's
going to give this talk tomorrow at this
conference in Seattle so if you don't
mind if you can hold your questions
until the end so he's gonna talk for
about 20-25 minutes and after I will
have ample time to discuss and ask all
your questions and we actually welcome
all sorts of discussions afterwards but
but that will give us a little bit of an
opportunity to time his talk and have an
idea anyway so Chinese from edho like I
said he's advisories Adrian parikh who
is recently moved from CMU to EDH and
chair move with him go ahead thank you
Stefan hello everyone my name is
changing from ETH Zurich today I'm going
to present my work seetee p.m. a cloudy
p.m. for cross-device trusted
applications this is joint work with
commercial Raj Stefan surreal and alack
alack woman from Microsoft Research to
motivate our work today people are
increasing using modern while mobile
twice and sharing data across these
devices has greatly boosted user
experiences and another trend in mobile
computing world mobile trusted
applications have started to use trusted
hardware one important start transit
hardware is TPM and for example Google
Chromebooks use TPM for different
features including firmware drawback
prevention and fair encryption and
windows 8 use TPM for applications like
BitLocker and virtual smart cards there
are also many research prototypes
proposed
by the research community among them are
plaster which offers offline secure
offline data access the trusted sensors
which use TPM to send the sensor
readings and trusted language runtime
which provides a dull night language
runtime for building trusted
applications may further notice that
cross device data sharing is easy today
in fact most applications build some
form of data sharing or app state
sharing across multiple devices to boost
user experiences however for these
trusted applications which surely stores
their app state data or criminal keys in
trusted hardware like TPM sharing this
TPM protected data becomes hard the
primary reason for this difficulty is
that the key is managed and protected by
the tpms by TPM design bound to that TPM
trip let me use these animations to show
why this is the case at the beginning a
set of root keys installed in the TPM
chip bank manufacturers and after that
this route keys a guaranteed never leave
the TPM chip and the keys created by the
TPM will either be in the TPM chip or
protected by this route keys when they
are outside of the TPM chip as a result
as long as root keys never leave tpms
this key generated by the TPM will be
secret only to the TPM chip itself
current TPM specification did provide a
mechanism for key migration however to
use this key migration which is to marry
the key from 1pm to another a PPI from a
third party has to be pure asian also
configuration of this key migration has
to run a malware free environment both
of these requirements actually
challenging to mobile devices
I will come back to this point in two
minutes so the main research question in
this work is what is the minimum change
we can make to a TPM design to be able
cross device data sharing our answer to
that question is C D p.m. which is short
for cloudy p.m. as indicated by the name
CD p.m. use cloud services to provide
multiple features including key
migration across tpms compared to the
current TPM design the primary change we
made is to require additional root keys
pre shared with the cloud let me give
you a flavor about how we can use this
route keys to year Bo easy data sharing
across tpms let's assume to see DPMS
running on two mobile devices and belong
to the same user and the cloud provides
to TPM emulators as cloud service for
the user and these two tbm emulators are
bound to the same user and each of the
CD p.m. will shared root keys with one
of the TPM emulators with the root keys
shared between the CT p.m. and TP FML
emulators we can then establish a secure
communication channel between each pair
of CD p.m. and TP I'm emulators with
this secure committing channel and with
the help of the cloud Sharon TPM
protected data becomes easy what's more
with the established a secure channel
the club the further provided additional
two features for CT p.m. today TPM chip
surely has a small and slow precision
storage device called a mere on each
slot in nvram could only be written
around 10,000 times during the entire
life with these establish the secure
channel the first feature that cloud can
provide to see TPM is a fast and large
remotely storage
as for the second feature current TPM
cheap only has a trusted timer in the
design it doesn't have a trusted clock
that means the policy this movie can
only be watched after midnight Friday
cannot be enabled with this established
secure channel now the TPM can build a
clock and sing this clock with the clock
in the cloud and now this helps enable
multiple interesting time relevant
policies here is offline of my today's
talk so after talking about our
motivation let's talk about the TPM as
the background in case people are not
familiar with it and then I will talk
about why these are alternatives are not
for favorable TPM is short for trusted
platform module it is a secure
coprocessor offering multiple crypto
primitives it also enables measurement
and attestation of code running in the
platform it is white hope for trust
computing technology and is widely
deployed in laptops input by the
producers such as HP or dell or etc and
nor this trust computing group defined
specification for TPM current completed
specification is TPM 1.2 is widely
deployed in the TPM chip available and
there's one additional specification to
replace the PM 1.2 that is TPM 2.0 and
our CT p.m. is based on TPM 2.0 but I
want to point out that our design does
not rely on any features specific to TPM
2.0 Oct p.m. can be easily applied to
TPM 1.2 in this work with doped similar
threat model to current TPM that is all
sorts of software attacks including
malware will be considered in our threat
model however we don't consider hardware
tags such as macro scooping the TPM chip
and read out the root keys
for the trust assumption we have CT p.m.
keeps the dual relationship with the
cloud on one hand and trusted the cloud
with all the shard would keys with the
club and the truth the keys drive from
this root keys however it isolates the
key route keys that exists exists exists
in current EPM design and keep them this
keys local to the TPM chip as a result
if the cloud is compromised only the key
sheriff is the cloud will be compromised
the keys that are local to TPM chip are
still secure secure the cloud service
without trust in the cloud has been an
active research area and we leave
securing the cloud side of CTP n as our
future work for now let's assume that
cloud can be trusted now to lick the
shared root keys as a design alternative
secure execution mode could be used to
implement TPM extensibility mechanism
this mode is also called trust as
children technology II Intel in deep
male implements a cpu based reboot and
set up isolated environment to run
transit code it could be generally used
to implement additional TPM
functionalities such as kimya girish key
migration across tpms in order to remove
urbanism out of the trance computing
base we can implement TPM additional he
p.m. code in two steps in the first step
with husband opposition and the initiate
is secure execution mode and then this
in this mode we can run this additional
TPM code in the second step after the
code is finished we can do necessarily a
necessary cleanup and exit secure
execution mode and continue to redo a
processor these two steps may seems
simple however it is quite challenging
to use the cue execution mode in this
way first it poses some
performance issues as the Opera system
and all the applications has to be
suspended in the platform no progress
can be made by the entire platform until
this additional code for TPM is finished
and also since the organism is not exist
doesn't exist in this secure execution
mode the app up TP additional TPM code
run is like running on a parent metal
therefore it causes some engineering
issues for the developer of this
additional TPM code in fact today the
unprocessed doesn't have this secure
execution mode which prevents the
majority of this mobile device to use it
from beginning has approved this
challenges actually there is no
production software using secure
execution mode in this way after briefly
talking about these and alternatives
let's talk about our 6pm design and the
implementations in this section review
mainly address 5 design challenges first
what are these root keys and how to a
proration them second with this rookies
how do we design easy secure key sharing
across devices and we will see that this
requires a clear communication channel
and next I will talk about the details
of this secure communication channel and
finally with this secure connection
channel enabled I would hope briefly
talk about how we design a clock back
and Miss storage and trusted clock first
for the root traditional pre-shared root
keys with the cloud of CPMs root of
trust Ct p.m. generate this route keys
using a random seed pressure with the
cloud you can imagine that in the future
iphone and ipad can share a random seed
with a club and the microsoft surfaces
can share a random seed with microsoft
azure only this random seed on each put
up CPM chi specifically generate to root
keys
the first one is called cloud root key
or crk it is used to protect all the
secret sharer cross tpms and with the
cloud the second key is called cloud
communication key or cck it is used to
protect the data exchanged between c-d
p.m. and cloud and to establish this
secure communication channel so let's
let's talk about our design of secure
key sharing across C tpms the cloud root
key plays a significant role here
suppose to see DBMS on to mobile devices
belonging to the same user one to share
keys in CT p.m. this is done in three
steps in the first step the user has the
cloud to generate a shared key for its
devices the cloud will use command TPM
to create to create a char key among
these two TPM emulators and the shared
key output by this TPM to TPM to create
will be protected by the crk of each TPM
emulators and in the next step the key
we will be shipped with this secure
Canadian channel to see TPM and in the
final step the CT p.m. device can just
use the command TPM to load to load the
shared key protected by the CR k and
then obtain a handle for later use so at
a high level the cct p.m. only execute
one simple command and it doesn't
require either secure connection a
secure execution mode or pki the only
missing component here is this secure
connection communication channel in step
2 so let's talk about this details about
this secure communication channel in CT
p.m. we use cloud sat and me ran as the
message box for the CD p.m. device and
cloud to communicate in general sending
and receiving messages by CT p.m.
is like a only right and only read by
the tutor cloud side and we ran you can
think of this abstraction like the
design in UNIX where the kernel code and
the user mode code use the file system
interfaces to communicate with each
other and also as transition network
network connectivity loss is common on
mobile devices with further design a
client-side cash to mask this transient
network connectivity loss and we provide
us synchronization protocols to sync the
clan clan side cash with the cloud side
producing storage device here are the
details of our synchronization protocols
we design a pool and a push method for
only read and only read each of the
synchronization process includes two
messages switch between CT p.m. and the
cloud here I only I want to highlight
two details about our synchronization
protocols first the messages are
protected by the cloud communication key
second the counter and nuns are used to
prevent message replace by the software
stacks on mobile device and the network
node in the middle between the CT p.m.
and the club I further want to point out
that in each of the synchronization
protocol it is the TPM who initiated the
command issues the connection with the
club however in current TPM usage model
TPM is supposed to handle command and
return result it cannot initiate
connection with the cloud so there is a
problem to solve this problem we propose
a matter called secure a synchronous
communication in this mode method the
caller app assume the positions of a
connection initiator and message for
water each synchronization process will
be divided into three phases
in the first phase the call app issue a
command to see TPM and obtain a blob
from CT p.m. in the second phase the
collab will forward this blob to the
club and that will obtain a response
blog prime from the club in the third
phase the call app will forward this
plop ram to CT p.m. and obtain the
result for the command one of the vision
of this method is in phase one and Phase
three whose latency could be very short
Ct p.m. will be blocking it will not
handle command from other color
application however in phase 2 whose
latency is dominated by network latency
and this lesion see could potentially be
very long Ct p.m. can continue to handle
command from other collapse this helped
to improve the responsiveness and
availability of CT p.m. for other color
applications and next I want to remind
you that here only CT p.m. and the cloud
are trusted the call app is not trusted
so here essentially we create a secure
communication channel based on the
energies we do not trust so with this
secure communication channel established
let's talk about how we can design
clouds back and V storage and trusted
clock here is a picture to show how a
remote nvram slot could be read during
this process of synchronization protocol
is used to sync the cleanser cash with
the cloud side persistent storage after
that the client can just use only read
to read the content out of the local
cache suppose the caller app would like
to read only index 42 from the club it
will first issue TPM to sync begin which
is a new command implemented by CT p.m.
to tell CT p.m. it wants to access and
we only 42
in the second phase the cloud would use
TPM to sync proc to process the blob and
return 0 response in the first phase in
a third phase third phase the caller app
can use TPM to sync end to let see TPM
to process this response and obtain a
return code of this command if the
return code is success that means
synchronization protocols successfully
sync the local TPM cash with the cloud
side persistent storage now in the final
phase the kora app can issue a me read
to read the content of from this local
cache yeah I will remotely storage
design the all the local cache and the
interest will have TTL values if the TK
Alex Paris so the cached and the injury
is no longer available it has to be
resync the and all also see tbm has a
timeout for all the to abort this
pending cloud commands the cloud would
address this were a timeout value
according to his needs the current
default value is five minutes finally
with this remote in my storage
established building a trusted clock for
CT p.m. is relatively straightforward
the cloud can just reserved a special
only index for the club for the client
and put the clock information into this
special index now the client can read
clock information out of this special
only index and even build policies upon
this and we index the only difference
between this special on the index and
other normal and the index is used a
small a different time out to keep high
precision the default value for this
time out is one second for
implementation details in total CT p.m.
add three new command outside of one's
108 commands in current TPM 2.0
specification
and the usage of these commands are
covered in previous slides our 6pm is
implemented based on TPM 2.0 reference
implementation the involves 1300 lines
of code outside of 23,000 finally to
prove the usefulness of CT p.m. will
recommend posture and drink to work with
CT p.m. for posture we extended this
functionality to work across multiple
devices and for drink we provide a high
performance only run for it after
talking about our basics DPM design and
the implementation details let me share
some evaluation result our evaluation
test pad uses a client-side machine
equipped with TPM chip to run T p.m. CT
p.m. client-side code we also set up a
server running of TPM emulator in
virtual machine for the cloud service we
use wet area network emulator to emulate
both Wi-Fi and 3g network we adopt the
long trip time information reported by
one in mobile 6 2012 specifically in
this section we would like to answer
three questions first e are the CD p.m.
protocol designed here secure second
what is the performance scriptural
operations of CT p.m. and finally what
is the performance of a remote and near
I'm accesses for CT p.m. to answer the
first question we verify the correctness
of synchronization protocols with the
verifier proverit here we model attacker
with unrestricted access to applications
open systems and the networks and I want
to point out that the verification is
upon a model of our synchronization
protocols we didn't verify the
correctness of our implementation
to answer the second question we use
experiment to compare the crypto
operation between CT p.m. and the TPM
chip in experiment we create a 2048-bit
ski on both TPM chip and the CT p.m.
cloud side emulator and we compare the
latency of each one of this key creation
in the figure shows in the bottom the
x-axis depicts number of the runs is to
create this key and the y-axis shows the
latency of each one the result
demonstrated here shows that the the
latency of CT p.m. to create a 22,000 48
RSA key is 12 times smaller than that of
that of a TPM chip and the variation is
much smaller the primary reason for this
difference is because the crypto
operation and an entropy source on our
CT p.m. software emulator are much
faster than that of a TPM chip and we
expect this gap to be even larger when
the cloud used faster into resource and
the better perform hardware of crypto
module to build TPM emulators 12 the
third question we use experiment to
compare the performance between remote
only access and the local only access we
measure the latency of accessing on the
index of 640 beds as the remote in the
excess newly requires three phases
synchronization protocol we actually
profile each type of the synchronization
prodigal in the figure shows in the
below the x-axis tip shows the different
operations on different network
connections and waxes shows the latency
of each operation and different color
shows that the latency of different
tabs in remotely accesses the result
demonstrate that for a env3 remote and
we read this performance is comparable
to that of a local NV rid however for
only remotely me right it's latency is
3.5 times smaller than that of a local
and be right and also the latency of a
remote only accesses is actually
dominated by the network latency so we
can expect this better locality in
excess Penton and patched operation
optimization this performance for remote
enemy accesses could be better to
summarize in this work we present CT
p.m. which is essentially a TPM chip
with additional random seed service the
club we demonstrate that with this
additional random seed share with the
cloud we can able cross-device scenarios
we can easily support cross-device
scenarios by supporting across TPM data
sharing the design change also be able
to additional features they are high
performance and miss storage and trusted
clock finally represent the full
implementation of CT p.m. and we also
represent pasture and drink and extend
their functionalities with CT p.m. so
with that have you end the matter they
stop I would like to answer your
questions thank you
now you're welcome to ask any questions
you like the harder the better
so what what kind of applications are
you targeting with this I mean you
mentioned things like this locker
beginning of the time which is just a
local tedium with what what new
applications are from what modifications
existing applications I see the question
is so what applications we be able like
for example can we like what function
additional functionality that we can
provide for BitLocker a good question so
the main applications considering this
work are like the greaser crop research
prototypes like posture and drink so for
posture posture previously let me show
you this oh sorry so count the the
semantics of pasture with CDM may be
complex but let's compare pasture the
traditional patcher and pastor vinh City
here for this traditional unmodified
pasture when it works on multiple
devices so we have to run pasture
protocol in lockstep on multiple devices
for example if you pass worries for like
for example to manage movies offline ok
so when user by movie from the clouds
from the cloud provider and it use
pastor to say I want to watch the movie
out I don't want to watch the movie
however if with the traditional pasture
when the movie back if the user have to
device and has to wait want to buy buy a
new movie it has to find all these
mobile devices and make decisions about
its previous movies so with but in the
CT p.m. pastor with CD p.m. so when the
user has multiple movies it can just
continue to buy movies or truth watch or
not watch on one device and all the
decisions can be synced to other devices
with the club and since but however the
difficulty here is to do all the things
in a secure manner
so if you look at the pasture cymatics
so achieved this is actually hard
without CT PA okay and further for drink
drink is used to solve you convocation
problem for distributing system so the
key problem for drink is require a
counter in the RAM which can potentially
just be written around 10,000 times
during its lifetime and with CD p.m.
enabled so we can provide this
high-performance only a mere am for the
cheap and therefore makes a drink like
more accessible to mobile devices so for
but for the BitLocker since i'm not very
clear about its semantics with TPM so i
cannot reason about it now but i would
like to talk with you more about this CD
p.m. and be lager to see how we can
build a better logger
the other I think that answered the
other thing be so another benefit of
this sort of for for a platform would be
that they better multiple laptops or
multiple phones i have to put me in a
virtual scorecard separately with each
other
we're besties to be automatically sort
of provision for me once they said we do
that across all right places because the
cloud or the Cup or the enterprise if
you want to imagine couldn't know what
is the right purchase Marquardt returned
from me in hand ready from so I want my
device connects to the club next story
comes from and with BitLocker the what
other benefit I think would be although
he's reckon that we haven't thought
through very carefully through the
details to be that you can imagine
devices share the BitLocker encryption
credentials keys and that might make
some of humanization is interesting
where you can copy all copy data from
one hard drive to an honor fallen
wishing another and we don't have to
decrypt them in crypt we just sort of
perfect accessible enough yeah so my
favorite example we just have you know
these mobile device password managers
just to have that so that it's
automatically TPM protected and
synchronized across sort of
well I mean we have time for questions
but the feds events my to know why I've
got the slide of her so when you're when
you're yelling time outs the timers do
you have to do any rights to the live
all around I see so good so the question
is when we have this time out is TTL
logic to have to access this local nvram
to can it work in particular visual
range yeah so we don't so because the t
the TPM chip will have ram ram building
side so all this logic will be built in
the ram so think about why so why we can
build it in the ram instead of only run
if it is building only run when the TPM
crash the information stays however for
this TTL values it's one does TPM like
is crashes or loose loose battery then
it doesn't matter if we can reset the
TTL value because it's just the left
hand for this local cache and the local
cache is already gone so we don't have
to store TTL value so and also this
helps to make this only local in the
ramp have a longer lifetime
if you lost connectivity to the cloud
for a long period of time will be worse
off I've been using CT yeah good
question so so question is what if we
lost the connection with the club what
functionalities could be harmed by this
loss of connectivity so so to answer the
question let's assume another scenario
which is gmail and if we want to use
gmail and we lost our network network
connectivity so we basically cannot send
emails right and we probably can still
see the emails in local cache right and
if you look at CT p.m. as a cloud
service and then when the connectivity
is lost so it can it cannot communicate
for the cloud for for example trust
clock information or the content stored
in the club however it can it can also
discuss still read informations already
information to his local cache and as
long as this cache is not expired
because it's the TTL value it can be
used but however it is this network
connectivity is too long this carries
work works only with trends in network
connectivity right so the cat will
ultimately be expert then this cloud
cloud service cannot be used by cgpa
so another professor are looking at a
high level is this that
the cloud made us more ambitious with
the applications we provide certain
functional and we always make sure that
I'd functional it is secure imaging so
for example when you lose your network
connectivity there are cases when that
extra functionality becomes unavailable
it stops working and you could argue I
think you could argue in some cases that
the way it stops work is in fact worse
then then having a purity p.m. that
would not offer this extra functional
but my continue to make some sort of
progress in the disconnected face
because you have the DK locally we
should I mean so it's in some sense the
way the way we're thinking about it is
this what the application developers who
should actually understand the usage
bottle and say well I'm willing to
actually take the risk of stopping
existing functionality and making the
thing worse for the user just because I
can offer this extra functional in that
case they should use this tres horas can
see you know what I don't need this
cloud thing I don't want to deal with
the lust and in which case you should
fall back on your GPA because we leave
that there would you be you could you
could design your absence such a way
that they have fallback paths so that
whenever the cloud resources are
unavailable and some fallback mechanism
it just uses but it's true that there
are cases when being expected with the
cloud will turn off all the cppm
function all these clouds hierarchy you
won't be able to access it all because
they do want to think hard about what
your timeout value should be relative to
your expected network connection
characteristics
okay okay thanks thanks thank you for
coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>