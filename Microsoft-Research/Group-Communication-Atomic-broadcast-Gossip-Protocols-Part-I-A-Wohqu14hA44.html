<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Group Communication, Atomic broadcast, Gossip Protocols Part I (A) | Coder Coacher - Coaching Coders</title><meta content="Group Communication, Atomic broadcast, Gossip Protocols Part I (A) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Microsoft-Research/">Microsoft Research</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Group Communication, Atomic broadcast, Gossip Protocols Part I (A)</b></h2><h5 class="post__date">2016-08-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Wohqu14hA44" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">each year Microsoft Research hosts
hundreds of influential speakers from
around the world including leading
scientists renowned experts in
technology book authors and leading
academics and makes videos of these
lectures freely available
I guess I'll start so my name is Robert
Baroness in fact I've got a little
slight introducing myself I got my PhD
at the Free University of Amsterdam
under Andy Tannenbaum working with
people like Tito for awesome who did the
Python language for the me but this
river operating system that I was
building at the time then I worked at
ATT Research Phillips in Murray Hill
with 29 people and since 91 I've been at
Cornell University where first the
pleasure of meeting Lorenzo there worked
on the system called Horus that was a
license to Stratos I worked i co-founded
is something called double ups which was
acquired by something called fast which
then was acquired by something called
Microsoft which some people in the room
here have heard of it's a search engine
company and we it was together with my
colleagues called Fred Schneider we did
something called chain replication for
for fast and also leader election
vertical that I believe is in use today
in Microsoft products then I did
reliable network solutions that was
accompanied with my colleagues for
Fogle's and Ken Berman and Vera Falls of
course now ctod Amazon if it developed
gossip based solutions there and some
Kasbah
I'll be talking about in these talks and
and then I also worked a bit for the
database company greenplum
which was acquired by by EMC so that's
my background
and let's talk a little bit it's the
same slice oh it's not the right slide
let me see
if the monks lights it up huh what
happened here
let's see it's an old version of my
slides is here hopefully my powerpoint
works there we go
hopefully these are a new slides
otherwise we'll just be working with the
old ones I added that them this morning
so no that's weird huh okay well maybe
it's this the way it is going to be okay
well sorry about that I was going to ask
ask you guys about my processes
communicate and I don't know what
happened to those slides but here the
answers already but I mean let's this
talk about this a little bit so you know
before we we talked about distributed
systems and communication it's kind of
interesting to know why processes
communicate so seems pretty obvious why
why processes communicate but you know
when you really go and take a step step
back and look at a lot of these these
algorithms
the reason they communicate really is
because they want to share some part of
their state with other processes
it's basically a poor man's substitute
for shared memory they they're not
sharing memory in a networked system and
so the only way they can impart some of
what they know is by sending a message
to the other processes I mean I have
here some other examples I mean clearly
when you take your web browser to a web
site the idea of communication is simply
to copy bits there's some stuff that's
stored at the web server and they
somehow want to have at the web browser
that's done with a mess
but that's also in sensation of the web
browser wanting to share some state with
the with the browser sometimes you
actually want to transfer the bits the
source doesn't really care about them
anymore but there's some destination
that cares about the email is a good
example send email from one place to
another but again you know like really
the source and the destination are
trying to share some state like when I
send an email to Lorenzo it's because I
want to share some state little Aransas
again it's a substitution for for shared
memory and so really the the reason that
one process sends a message to another
process is to impart some information
that it has so what kind of ways are
there to communicate shared memory and
message passing and then if their
advantages and disadvantages shared
memory is is of course a very convenient
abstraction to have but there are a lot
of and you know we already talked this
morning about locks there's some other
ways for processes that share memory to
synchronize with one another it tends to
be hard to implement in a truly
distributed system system where there's
lots of machines that are connected by a
network can be done but we have not
really been able to do scale that
solution so message passing is really
all we're left with basically you know
where messages are being sent
and delivered but it's a as we can see
in from experience fairly error-prone
way of doing things the message passing
API itself is fairly simple this is what
we will be working with there's a Down
hole to send the message to a particular
destination and then there's a an
optical that's delivered at the
destination that specifies the message
and where it came from so but what are
the semantics of of sent and deliver
because it's not necessarily all
that clear in a distribute system what
one will get out of this I mean for TCP
for example it's you know when you send
a message
is it really guaranteed to be delivered
well only under under certain
assumptions TCP connections can break
under if it takes too long and so let's
see what we want so before we do that
before we can talk about this event we
have to talk about what what processes
that send every messages how they may
fail so they I do anybody bigger letters
good I can read it too so processes can
crash which means that a process is
processes make transitions they have
some kind of specification from which
they work they have you know state
things happen timers go off messages are
received and based on that processes
make transitions until a process crashes
in which case process makes no more
transitions so that's you know any
sometimes four but the nine failure a
non Byzantine failure
it's just process stopping for whatever
the reason that is may be the power
disappears or something like that
we're going to define a correct process
to be a process that never crashes it's
a kind of a weird thing well clear
concepts you think of it so because if
we're going to consider process that is
going to crash
faulty our how do we know that a process
is going to crash well we don't but
nonetheless going to call it that
faultiness we'll see in a minute that's
has some advantages we're also going to
assume that that these crashes can be
detected somehow and accurately of
course you can try to ping a process and
that way you can suspect a process being
faulty
but we'll see in a bit and there they
sing in the assumption which is really a
lack of assumption about timing it's you
you can be sure that the process is
Christ just by pinging nonetheless we're
going to assume that we can accurately
detect a crash and in particular a
prophet correct process is never
considered faulty and a faulty process
is eventually detected and and reported
not necessarily at the same time though
okay so in here are the semantics of the
send and deliver primitives that we want
so first of all you want if that if a
connect process P invokes sent a sent
primitive once the send a message to Q
and B and Q are both correct this means
they'll never crash ever then eventually
the process process Q will deliver that
message and invoke this uphold deliver
p.m. that's a liveness property it
something good eventually happens that's
a very good example of a liveness
property I think and here's a very good
example of a safety property it says if
some process Q and I don't care what
it's it's correct your faulty delivers a
message from P well then it had better
be the case that P send that message so
there are no missing delivered out of
the blue if there were to happen that
would be bad
that's why this is a safety property
this says you know like if you send a
message eventually something has step as
a result that's aliveness property now
we're going to consider all these
messages to be unique and why is that
well think about it when say that
different processes could send the same
message to Q you know what does that
really mean now you know I the process
made the liver
well actually it's it's not not so much
when it's different processing it thank
you
let me see but then the same process
piece it's multiple message
messages to 2q these these particular
definitions get a little murky about in
invocation it might be that some of
those messages got lost some did it get
lost you know if you send a message
three times to kyushu to be delivered
three times just to get away from all
that murkiness we're going to consider
every message to be unique okay so when
you cannot send the same message twice
the process will not send the same
message twice so now it should be clear
although it's probably it's not yet but
we're gonna make it clear why we define
a correct process the way we did like
you said a correct process is one that
never crashes and a faulty process is a
process that is not correct so somebody
maybe say why that is
say that that wasn't the case you know
that process is only faulty after it
crashes you know at the time that it
crashes it becomes faulty I mean if that
were the case then a faulty processes
could not possibly invoke sin right
because the crash process is one that
doesn't make any transitions and so
these definitions really don't mean much
anymore if a process is only faulty
after it has crashed so it would mean
that if a correct processing invokes
sent then it has to be delivered even if
it crashes right at the time
after invoking send it would be very
hard to implement for one thing
definition wouldn't make much much sense
the implementation will be very hard
that's why it's easier to just consider
a process that never crashes correct and
a process that at some point might might
crash faulty even though you know
clearly we cannot tell the future but
it's the easier way to think about these
these failures that way we can also put
bounds on the number of processes that
may crash the number of faulty processes
and it would that makes a lot more sense
- yes
so if a deliverer is encountered well I
mean so the the safety condition here is
that if a deliverer of coal is invoked
that you know it's it's it's only 2 P I
mean we're not talking about broadcast
here right so the point-to-point
communication primitives where message
is sent to a particular process so when
it's delivered we do have the guarantee
that it was sent by some process I don't
know what you mean by also deliver to q
I don't I'm not following sorry or the
likeness for focal processes
if you add like an acknowledgment the
event or something like that
yeah I don't know I'm so I'm the the
primitives here are simple one-way
message sending and so there's a process
that sends a message it's another
process that delivers the message and it
doesn't really make sense to think about
what of me would mean you know what the
semantics are of a faulty process
sending a message that faulty process
may have crashed just before sending or
just after sanding so you know it may or
may not be delivered and that's in fact
captured here you know like it doesn't
say that if a process the faulty process
crashes that message that it sent cannot
be delivered it's faulty process and the
message from a faulty process may be
delivered in which case we know that the
faulty processes send it but it doesn't
guarantee that if a faulty process
invokes Stanford is that it will
eventually be delivered system
those are just the semantics is defined
under this fill your mom the only only
guarantee that applies here I think is
this one if a faulty process delivers a
message it was sent by some process we
don't know what it is speaker up here
and we don't know whether the the
process that send the message is faulty
or correct but the but that is that's
the only guarantee that applies because
that that particular guarantee only
applies to correct processes okay I
think I should probably move on but I'm
happy to discuss this further offline so
how's it implemented very simple really
in order to implement these particular
semantics you just have to keep on
retransmitting until either you receive
an acknowledgment or until you find out
that the destination has crashed and
again we're assuming that we have a
reliable notification mechanism so
that's pretty pretty easy their implicit
assumptions underneath here that I you
know like that we're actually brought up
this morning we do need to assume that
the link between P and Q is fair that
you know eventually some messages will
get through if we're not assuming that
and none of these these these replicas
of the messages that are sent are ever
delivered this would still not work so
there's an implicit assumption here the
link is fair and and then you know so as
soon as you receive one of these
messages you deliver it only the first
time want to filter out duplicates and
every time you receive a message you
send back an acknowledgement and then
we'll do the trick it's a protocol that
in fact is its quiescent you know will
eventually terminate once the message is
is not oh not only when the the misses
the reliably delivered but when the
sender has detected through the
acknowledgement that it has been
delivered it will stop eventually this
protocol terminates again under the
assumption that failure detection is
accurate and links are fair so what
might make it make sense to stop here
for a second and figure out what if the
failure notification was not reliable
what if we didn't have an accurate
failure detection service and so we've
never know for sure that Q was faulty or
not with this protocol still stopped
still terminate
a close there's only two answers
right you would never ever know if you
don't get an acknowledgment you don't
know whether process queue is faulty or
whether every message you sent so far
got lost or maybe they all got there but
all the acknowledgments got lost or in
any case there's never been a correct
delivery and a correct acknowledgement
coming back so you can never be able to
stop until until you receive an
acknowledgement and of course if Q is in
fact faulty you would never would
receive that acknowledgment and so this
protocol would not terminate so Hank
heard a lot about timing this morning so
we're gonna make no assumptions about
timing we're gonna know no assumptions
about the delay of messages no
assumptions about the time that it takes
to process a message once it once it's
delivered know something about how long
it takes for failure to be notified
after it happens know something about
clocks so the clocks may be running
arbitrarily fast or slow they may be
skew between the different processes you
know one proximately think it's one
o'clock in the afternoon yeah I don't
want me think that it's in the middle of
the night like I do at the moment and so
there can be arbitrarily off so we're
not going to be measuring time at all
it's gonna have basically make no sense
whatsoever a nurse in our system and
that's what they singing E is you know
they're basically a complete absence of
assumptions about time and we should not
be confused with non blocking that's
also often you know people talk about a
singing Asst you know RPC and they sing
and is this anything is that that's not
what they sing it is that's non blocking
a singing they really you know in the in
distributed systems means there's
there's no real time and and so yeah
it's a complete absence of assumptions
so if you're not making assumptions
about anything it's very hard to do
anything right it's it's if if you made
you know started with a system that you
make absolutely no assumptions about how
would you build something on top of that
start out with very weak assumptions
like you're trying to solve consensus in
this in a system where we make
absolutely no consumptions about
anything well that would be hard I mean
that actually is kind of what the
Americans would say duh it's clearly not
you know if you make no assumptions
whatsoever there's nothing you can do so
but we're going to make no assumptions
just about time so that's very weak very
weak assumption the other and we make
this very strong assumption about
failure detection so we can accurately
detect it somehow and that actually is
you know really the secret ingredient in
a lot of what I'm going to be talking
about at least in the in the first first
two hours today so why a singer D well
it's kind of hard to make any
assumptions that are any stronger than a
Singh and you know in a system where
that we have today right if you send a
message if I send an email to one of you
I cannot get tell you how long it will
take before it's delivered they you know
typically take only a second but you
know occasionally we'll take a little
longer you know maybe some servers down
maybe some linkies it's crashed maybe
there's been a power outage somewhere
there's no bound that can come up with
it can be arbitrarily long you know if
you give me a bound I can probably come
up with some really bizarre scenarios
it'll take even longer than that so so
that's one reason another reason is that
if you're gonna say like well okay let's
come up with a bound let's say well you
know a message you know it's very
unlikely an email won't be delivered
within say a month so now we have a
got rid of the acing and the assumption
is saying everything will happen within
a month now I'm gonna build a system on
top of that that's gonna take that
month-long bound into account some power
and you can kind of see that any
algorithm that's gonna wait a month for
something to happen the units to make
sure that the message didn't get through
before it detects a failure or something
and you know for example in primary
backup elect a new primary would be
impossibly slow so if you're going to
make worst case assumptions you know the
higher you said those bounce the slower
your system will be in fact you know if
you look at some of the the early
attempts at building real time like
flight control systems they fail because
there's bounce were just too too long
and third it's as I pointed out it's
certainly makes it a lot harder I mean
if we had singin II you know it would be
a lot simpler to to come up with a lot
of these algorithms so just to make it a
more fun puzzle but also I think a more
realistic fossil we will assume a sing
any and another slide that I inserted
here which I guess I'll go over so other
way so the other assumptions you can
make our singin e so singin e typically
is defined as there is a known bound on
every operation like there's a known
bound on mrs. Layton sees no bound on
how long it takes to process a message
that's you know a very strong assumption
it means like your system is real time
it's hard hard bounce on everything that
happens and then in between there is
something called semi singles and there
are various definitions for that but you
know common definition would be that
there exists bounds on all these things
but we don't know what those bounds are
and so that gives sort of a range of
environments in which we can try to
solve very
problems like consensus so it turns out
that for example consensus can be solved
in a semi Singh in this environment
where we don't know what the bound is
but we just know that there is about but
for example Eckerd failure detection
which requires this pinging would not be
possible in the semi Singers environment
we actually need to know what those
bounds are so depending on what
assumptions you make some problems
become you know harder some stay
impossible some desert so the clearly
weaker assumptions means harder harder
solutions and some some some problems
are impossible if your assumptions are
too weak and it's different for
different kinds of problems so it makes
distributed systems a very fun fun area
to work in this we kind of covered
already this morning there's a in the
absence of time we can still talk about
the order of events and it's important
so events that a process are naturally
ordered the basically the transitions
that the process makes are we basically
assume that processes are single
threaded for simplicity also assume that
the message is delivered after a message
sent before it's delivered that seems to
make sense for most people though I the
interesting fun little anecdote when I
was working with the formal methods
group at in our department
I gave them some algorithm and they were
trying to prove it correct and they
couldn't get the proof to go through at
some point they said oh but you're
assuming that a message is delivered
after it was sent is it oh yeah so they
stuck it into their into their their set
of assumptions and voila the proof went
through ok so ok and the similarly
process crashes before it can be
reported that's the accurate failure
assumption so that's also an ordering
and then the transitive closure of those
things if X happens before
my happens before Z then X happens
before Z so that's cool t happens before
ordering sometimes you know called
causal order and if neither X happens
before Y nor Y happens before X and
we're going to say that x and y
concurrent so we can talk about ordering
of events we cannot talk about the time
at which these events happen okay so
that all sounds sounds good but we live
in a real world and in a real world
we cannot detect failures like the
record failure detection that I'm making
is very hard to implement right as I
said you can try and do pinging if I did
it don't get a response to my ping
message I don't know anything ever get a
response to my pinkness it's all I know
is that the process was alive and well
since the time that I send a thing but
if I don't get a response to my ping
then I don't know what it's filthy
whether the network is broken or it's
slow anything can be going on messages
get lost crashes can happen any time
machines can get slow even with I could
fill detection you know some processes
may have detected a failure some other
process may not have to detected the
failure so there still it's it's it's a
very messy messy world out there and so
this is where the the notion of virtual
singing this group communication comes
into comes into the picture so for two
singles group communication was
something that I think a term coined by
my colleague Ken Berman at at Cornell
University in the mid 80s
a lot of people I think if you know I'm
it's it's it's it's an it's an
interesting environment I don't think
there's a good formal definition for
exactly what it means I'm not going to
give you a formal definition today but
I'm going to give you what I think it
means and why it makes things simpler
and then the first bullet here is really
what what it's about that is we're going
to simulate an environment
and which processes doing that Crescent
messages do not get lost or in other
words a process in which failures do not
happen and it's gonna make processes
believe that that old failures are gone
and then once in a while you know
processes do crash we're gonna
reconfigure the system and then we're
gonna agree on an on a new state and
continue again so we're sort of going to
define the right execution up into epics
and then we add to that some nice zoom
tools to simplify the programming of the
surveyed algorithms with things like
leader election and broadcast protocols
and all that so how do we do that
so first we're gonna this four
ingredients that I'm gonna go over one
important ingredient is the notion of a
view view is just a membership set of
processes and and here's the important
part about these view there is one
single sequence of views so we start out
with an initial view v-0 and you run for
a while and then you know if some
process crashes or some other processes
want to join we're gonna add a new view
v1 and v2 etc and so on but it's a
single sequence and that actually turns
out to be a non-trivial property of
virtual singing in fact it requires
solving consensus to get in single view
because every time you create a new view
there can be effect multiple proposals
for a new view that can be only one next
view if there be zero there can be only
one next view if there v1 so but we'll
talk about that more detail later then
we got these epics which are the
execution between two consecutive views
so the first step up would be between
v-0 v1 second do you want to be to and
in in an in an epoch the process first
gets a new view up whole there's a new
op
whole new view that says what the view
is and so every process in that Empire
gets that view at least as far as we can
simulate it alright so so that happens
and again processes in an airport do not
crash the process in view V only knows
about the process in few V it cannot
send two processes outside of V so and
it can only deliver messages for
processing be so all it knows is that
membership that view until the end of
the air park when there is a view change
there's a three three-way handshake for
that in fact so a process in in the in
in in in a particular air park receives
an up call stop you or stop a pop or
something like that which it has to
acknowledge that with the down cold it
says okay I'm done all processes are are
expected to invoke that after getting
this up call and then sometime later it
will hear about the new view it starts
the new epoch so that's the handshake
process comes on you know this busily
working in some view get some up calls
stop you then it yields after yields is
no longer allowed to send messages until
here's about the new view with the new
membership and then it can start sending
messages again so and we're going to get
rid of faulty P because we're simulating
environment in which failures do not
occur so the only thing that do occur is
these these these view messages but
that's at the end of the air park so
during the air park there are no
failures at the very end of the air park
we we get a new view notification
processes never die and they they are
off in this air park they just send
matter they deliver messages they were
simulating an environment it was they
don't die I mean we may not no longer
hear from a particular process but as
far as our simulation is concerned
it is still alive it's just no longer
sending messages so yeah there are no
failures and so if the process is in
some view and it's not in the next view
that really means that as far as we we
have been able to determine it has
crashed and in fact we're going to
assume that the addiction still occurred
so in fact it has crashed yes
yes that is what we're gonna guarantee
that in the because we're assuming that
that failure detection is in fact
accurate the underlying implementation
is not going to remove a process from a
view or from it you know it's good keep
that in the next view unless it's really
full so the processes so soon P being in
V but not in the subsequent V prime
means it's really crashed it's dead it's
gone yeah so we have to make a
difference between the abstraction and
the implementation of that abstraction
so in the abstraction processes don't
crash in the implementation of the
abstraction process of course do crash
and we're going to guarantee that if
that's the case so it's crashing during
the air park it will not be in the next
view it will not be in the next step if
it does because of the following
property
the last ingredient it says there's
messages don't get lost in an Airpark
and so all the messages that a process
sent also have to be delivered so if B
sends a message to Q P and Q are are
both in in in in in the original view
and in the in the in the next view then
clearly those messages have to be
delivered but we're going to go a little
further by also saying that all the
messages that were sent prior to M
according to this happens before
relation that we defined has to be
delivered in the viewers will like
messages cannot get lost and that means
that you know if some message is
delivered then all prior messages better
had be delivered as well or clearly
there would be a way to detect the
message that their failures
that's an abstraction right so yes so if
we can hide that from the other
processes then we're fine so yes the
it's it's like the tree in the forest if
nobody else has noticed that a faulty
process is send a message and then it
crashes there's actually no obligation
on our part to deliver that message
right if if that message is delivered to
correct process then all prior misses
better have that you know be delivered
as well otherwise somebody can detect it
something that they were not
implementing abstraction correctly let's
see so yes we're not not actually let's
see what is this okay so we we cannot
deliver a new view until all processes
have yielded the the old Airpark so so
yesterday the views can only be
instantiated on zahl
all correct processes in the previous
view are okay with that yes
Yeah right study the the intersection
between V and V Prime are in some
sensitive processes all processes in the
abstraction are correct until the end of
the epoch but then at the beginning of
the next epoch we are allowed to remove
some of those old processes and those
are will be the processes that have
crashed but we can replace some of them
with new processes so we are allowed to
add new processes and so this is in many
ways an elastic type of primitive where
we can change the membership over time
yeah that's correct I mean so processes
may elect to leave in an Park and the
cell cam I don't want to have anything
to do with this anymore as far as the
other processes are concerned that
process crashed at the end of the I
Parker one I'm not going to allow is a
process that's taken out of a view that
hasn't yielded the old view to to go on
and leave its separate life without
having you know it has to crash you safe
process either has to yield or it has to
crash before a new view can be installed
of course in this historical node in
Isis that was not the case a process
could go on a new view could be
installed just because the process was
suspected of being faulty and that leads
to a whole lot of semantic problems so
that's why I simplified live a little
bit here and the swimming Eckerd failure
detection ok so here's an example of the
reliable messaging so we got two
messages here the the red one and the
black one the black one is being
delivered to to the third process I said
something I did in my new slide said
which hasn't made it into this old slide
set because time is ordered and all that
kind of horrible stuff
is that these things were nicely labeled
but so we have two views here a view
with three processes in a new view here
with two processes because one of the
processes crashed when one second and
there are two messages this message here
that's delivered and that red message
that was sent to another process that
that process was not delivered yet but
because of the virtual singly property
there's an obligation on us to deliver
that message we have to deliver it
because it's constantly prior to this
message if we didn't deliver that
message these processes would actually
be able to figure out possibly that
something that occurred because the
effect that that message was send
awareness was sent may may be a
piggyback on top of the black message
yes your question
yeah I mean and I apologize box and
views I try to make you know so view is
is is the way I define it just a
membership a set of processes and the
Airpark is this is the execution of
those processes that happens after the
view but the group communication
terminology is such that we often we
actually don't usually use the term
epoch we call them both use it for
educational purposes I introduced the
new term but I'm fortunately not very
consistent with using it and you don't
have to be either I mean it's it's very
common for people to say you know like a
process in view we execute it so and so
and you know that makes sense enough the
epic this epic is really defined by the
view let's that answer your question
ah interesting let's go over this like
this was actually one one that I took
out and replaced by another one and but
but it's good that it's here
so here's here's a here's a more
detailed picture of what goes on so that
three processes P Q and R and they're in
a view together and so P actually
crashes very early on even before it it
learns about the view P Q R the Q and R
learn about this at some point they
learn about that the view is being
discontinued then they have to yield and
then at some point they learn about a
new view consisting of this Q and R so
here's a message that's sent in via V it
can actually be delivered even after
after the view is yield but it's
guaranteed that this message will be
delivered before the new view and so you
can see that the F box don't completely
match up with one another and they don't
have to
doesn't mean anything it is in in this
picture I mean this is for us as
observers a picture of time time going
down and a message is going across but
that's this the way for us to think
think about it what the processes see
are these up calls and uncles they don't
know anything about times but they do
know about ordering of events so the
result of all this is that processes
survive until the end of the epoch sorry
that the process that do survive in the
end of the elk and park cannot tell the
difference B what what tell the
difference between what they saw like
all the uncles and won in the epoch in
which no failures actually occurred you
know I you could come up with an
execution that's I didn't you know like
a correct execution as far as they know
and that's that's what happened and
that's exactly what we try to accomplish
and this will see that makes the
implementation a lot of mystery with
algorithms similar it's a little bit
similar to this notion of a consistent
cut that we heard about this morning
again the consistent cut the cut that
you see is a state that could have
happened like that is you know it could
be a real thing probably wasn't I mean
probably never happened to cut the cut
that you saw didn't happen you know
wasn't taken at any particular time but
it could have been we cannot tell the
difference here again you know like
we're building a simulation and that's
you know it looks as if no failure or it
could have been that no failures are
currently processes cannot tell the
difference and so we have it
so each Airpark and each app up there
are no failures no mess these get lost
no processes fail and then of course a
lot of things suddenly become very
simple let me give you some idea of that
leader election it becomes very simple
when you hear about a new view
the leader simply the process with the
minimum identifier dot leader election
it's really nothing more you need to do
I mean and if at some point the leader
crashes new view gets installed we take
the minimum and we have a new leader
so guarantees since it can be only one
view at a time there can be only one
leader at a time yes and the abstraction
is as though it and Christ at the very
end of the epoch if this was slow until
the end of the eye pockit wasn't making
any more transitions and then it crashed
but during the apartheid was alive and
well and any problem any any message
that it sent as far as we know you know
got delivered and anything that happened
before it so yeah so so why is it that
there's only because but it's actually
not completely obvious why there's only
one leader at a time why is there only
one leader at a time
yes simplifies consistency but but why
does this algorithm that I this very
simple one-line algorithm here why does
it guarantee one single leader at a time
there can be only one minimum interview
but you know there was another view
before it is and there will be another
view after that and each of these views
picks the minimum process to be the
leader and yet I'm claiming there's only
at a time one leader so why is that yeah
I mean that that all I mean I agree with
that I mean that says that you know each
leader it's view has one leader but I'm
saying something stronger I'm saying at
a time and the first time you know
processes cannot tell time but I have as
an observer can tell time I can look at
the execution and yet I claim that there
can be only one leader at a time and
yeah well the and don't disagree with
what you said with the answer I was
looking for is that a new view cannot
start until old processes in the old
view of either yielded or crashed and so
you know some process was the leader in
the previous view you know either it
yielded and then it may be reelected
here is the new leader whether it still
means there's only one leader at a time
or if this is a different leader we know
that the older the other process must
have crashed you cannot move into the
new view until it's it has crashed so if
this this point this this very simple
one-line algorithm does in fact give you
one leader at a time and it's not
completely obvious I mean it's it seems
obvious but you still need to do a
little bit of reasoning about it still
assuming accurate failure protection I
mean so later you know so in my talk at
least a my talk about atomic
broadcasters group communication I will
be assuming Eckerd failure detection
throughout because as soon as you drop
that assumption you suddenly have opened
up a can of worms and you have to get
into all this packs of stuff and
consensus and all that and I was told by
reliable source that there be other
speakers there will be going into that
there cannot be multiple fuse for him
the wrong way so I mean so I mean this
it's it's this one the one you talked
about stop yes slightly worried when you
said there were multiple if I said that
I unintentionally confusion so that it
really is the case that when a new view
is being when any process learns about a
new view all processes in the old view
have either crashed or they have have
yielded the view so there can be only
one of you at a time and therefore only
one layer at a time
no I know there may be a new view here
which includes the same leader at the
same process it may not be the leader
crash but some other process crashed and
then we install a new view and then you
know like it could be that it replaced
is actually the old layer because
there's a smaller identifier but it
could be you could end up with the same
leader
that's that would be is probably as well
it defensive in in real time it's it's
it's a slightly complicated question
because you know it has to do with the
details of the view change like every
view has exactly one leader by this
particular rule the leader is the
minimum process of the view and after
all epoch starts with the view and in
through the view so there's an atomic
transition from one impact to the next
so there's exactly one leader who's
crashed in the implement and in the
underlying thing with the abstraction is
that the process is still leader the
process doesn't crash until the end of
the view so in the abstraction there's
one leader even though it might have
crashed over here it's still the leader
and as far as we know it's still alive
and doing stuff that's obstruction we
provide so there's exactly one leader
not at most one yes every view as a fix
yeah every view is static every view is
it's just numbered zero one two three
I'm not I'm not understanding well it is
trivial yeah yeah well yeah it's a one
line algorithm yes it's a it's it's not
it not even an algorithm right because
it's just the static property of every
view any deterministic rule you apply to
the view will work I mean you know
there's some again some hidden
assumptions here you know we're assuming
that the that the process identifier
Tsar ordered some way you know like but
when you work with these formal methods
people you know they get into the
nitty-gritty of everything and they tend
to not go into that but yes reliable
broadcast
there's the specification of reliable
broadcast reliable broadcast this is a
simple primitive but which some process
broadcast and and all processes like in
this case interview deliver that message
so you know here's the here's the more
formal definition the senator is correct
and some correct process delivers and
then all correct processes must deliver
them that's the liveness part of
broadcast the safety part is the same as
before you cannot deliver message unless
it was sent so that's the the spec so
how could one go about that in in this
particular abstraction of virtual
singing
yeah suggestions for a nice algorithm
you send the message and you wait for
all processes to acknowledge does that
guarantee that all correct processes
delivered because well I mean yeah exit
so this is again I think a problem with
there's actually not a property which
seems to be sorry this is because my
slide changed there's an there's another
very important property that's missing
which is not the safety property it's
another it's the real a property it says
if some correct process delivers in then
old correct processes have to deliver in
that's a very important property that
needs to be on here as well so sorry
about that this is this is the simple
property to to get because actually the
virtual singing property already gives
you that if the correct process sends a
message all the process all correct
process was delivered but the other one
is the hard one
this is part of it
oh yeah yeah sorry yeah see I yeah I was
surprised ok here I had it as two
separate properties on the other slide
but here it's it's it's in one property
if some correct process delivers and
then okaayy processes must deliver in
and your l variant won't work for that
in that particular algorithm if the
sender is fully if the sender for
example only since the message do a few
other processes it can't wait for
announcements but if it's if it's
crashed right but so so if the sender is
correct or some correct process delivers
and then all correct process must
deliver M&amp;amp;I it's the second part the or
part if some process delivers am in the
view all processes have to deliver it
how do i implement that with virtually
any it's a little little hairier than it
than it looks
that's right so every time you receive a
message you have to echo it to everybody
else so here's the algorithm when you
want to brought the process PU that
wants to broadcast reliably broadcasts
the message sends it to all the
processes in V and then whenever you
liver the process delivers ones of these
messages but hasn't delivered it yet it
delivers it and then it echoes it to
everybody else so why does that work oh
yes sir I'm not keeping track of time I
hope you have one of you guys do time is
up
okay over the break figure out why this
algorithm works</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>